  }

    CapiError
    AsCapiError(pki::Exception const &rExc)
    {
        return AsCapiError(ERROR_INVALID_PARAMETER);
    }

    CapiError
    AsCapiError(scu::Exception const &rExc)
    {
        using namespace scu;

        CapiError ce;

        switch (rExc.Facility())
        {
        case Exception::fcCCI:
            ce = AsCapiError(static_cast<cci::Exception const &>(rExc));
            break;

        case Exception::fcIOP:
            ce = AsCapiError(static_cast<iop::Exception const &>(rExc));
            break;

        case Exception::fcOS:
            ce = AsCapiError(static_cast<scu::OsException const &>(rExc));
            break;

        case Exception::fcPKI:
            ce = AsCapiError(static_cast<pki::Exception const &>(rExc));
            break;

        case Exception::fcSmartCard:
            ce = AsCapiError(static_cast<iop::CSmartCard::Exception const &>(rExc));
            break;

        default:
            ce = AsCapiError(E_UNEXPECTED);
            break;
        }

        return ce;
    }

    CapiError
    AsCapiError(std::bad_alloc const &rExc)
    {
        return AsCapiError(NTE_NO_MEMORY);
    }

    void
    Assign(void *pvDestination,
           DWORD *pcbDestinationLength,
           void const *pvSource,
           size_t cSourceLength)
    {
        DWORD dwError = ERROR_SUCCESS;
        if (pcbDestinationLength)
        {
            if (numeric_limits<DWORD>::max() >= cSourceLength)
            {
                if (pvSource)
                {
                    if (pvDestination)
                    {
                        if (*pcbDestinationLength >= cSourceLength)
                            CopyMemory(pvDestination, pvSource, cSourceLength);
                        else
                            dwError = ERROR_MORE_DATA;
                    }
                }

                *pcbDestinationLength = cSourceLength;
            }
            else
                dwError = ERROR_INVALID_PARAMETER;
        }
        else
            dwError = ERROR_INVALID_PARAMETER;

        if (ERROR_SUCCESS != dwError)
            throw scu::OsException(dwError);
    }

    void
    Assign(void *pvDestination,
           DWORD *pcbDestinationLength,
           LPCTSTR pvSource
           )
    {
        DWORD dwError = ERROR_SUCCESS;
        if (pcbDestinationLength)
        {
                // We want the number of characters including NULL
            DWORD cSourceLength = _tcslen(pvSource) + 1;

            if (numeric_limits<DWORD>::max() >= cSourceLength)
            {
                if (pvSource)
                {
                    if (pvDestination)
                    {
                        if (*pcbDestinationLength >= cSourceLength)
                        {
                            char *sTarget = (char *)pvDestination;

                            for(int i =0; i<cSourceLength; i++)
                                sTarget[i] = static_cast<char>(*(pvSource+i));
                        }
                        else
                            dwError = ERROR_MORE_DATA;
                    }
                }

                *pcbDestinationLength = cSourceLength;
            }
            else
                dwError = ERROR_INVALID_PARAMETER;
        }
        else
            dwError = ERROR_INVALID_PARAMETER;

        if (ERROR_SUCCESS != dwError)
            throw scu::OsException(dwError);
    }

    void
    Assign(void *pvDestination,
           DWORD *pcbDestinationLength,
           Blob const &rblob)
    {
        Assign(pvDestination, pcbDestinationLength,
               rblob.data(), rblob.length());
    }

    void
    Assign(void *pvDestination,
           DWORD cbDestinationLength,
           Blob const &rblob)
    {
        if (cbDestinationLength < rblob.length())
            throw scu::OsException(ERROR_INTERNAL_ERROR);

        Assign(pvDestination, &cbDestinationLength,
               rblob.data(), rblob.length());
    }

    // Helper to BufferLengthRequired to compare length of strings.
    struct LengthIsLess
        : public binary_function<string const &, string const &, bool>
    {
    public:
        explicit
        LengthIsLess()
        {};

        result_type
        operator()(first_argument_type lhs,
                   second_argument_type rhs) const
        {
            return lhs.length() < rhs.length();
        }
    };

    // Return the data buffer length required to hold the largest
    // string in the vector.
    DWORD
    BufferLengthRequired(vector<string> const &rvs)
    {
        DWORD dwRequiredLength = 0;
        vector<string>::const_iterator
            itLongestString(max_element(rvs.begin(), rvs.end(),
                                        LengthIsLess()));
        if (rvs.end() != itLongestString)
            dwRequiredLength = itLongestString->length() + 1;

        return dwRequiredLength;
    }

    // Helper to enumerate the container names for the given context,
    // returning the result in user parameters pbData and pdwDataLen.
    void
    EnumContainers(Guarded<CryptContext *> &rgpCtx,
                   BYTE *pbData,
                   DWORD *pdwDataLen,
                   bool fFirst)

    {
        DWORD dwError = ERROR_SUCCESS;

        string sName;
        DWORD dwReturnLength     = 0;
        void const *pvReturnData = 0;

        if (!pbData)
        {
            // Return the buffer size required for the longest string
            auto_ptr<ContainerEnumerator> apce;
            if (!fFirst)
                apce = auto_ptr<ContainerEnumerator>(new ContainerEnumerator(rgpCtx->CntrEnumerator(false)));
            else
                apce = auto_ptr<ContainerEnumerator>(new ContainerEnumerator(rgpCtx->CntrEnumerator(true)));
            vector<string>::const_iterator &rit = apce->Iterator();
            if(apce->Names().end() != rit)
            {
                dwReturnLength = BufferLengthRequired(apce->Names());
                if (0 == dwReturnLength)
                    dwError = ERROR_NO_MORE_ITEMS;
            }
            else
                dwError = ERROR_NO_MORE_ITEMS;
        }
        else
        {
            ContainerEnumerator ce(rgpCtx->CntrEnumerator(fFirst));
            vector<string>::const_iterator &rit = ce.Iterator();
            if (ce.Names().end() != rit)
            {
                sName          = *rit++;
                dwReturnLength = sName.length() + 1;
                pvReturnData   = sName.c_str();

                if (dwReturnLength > *pdwDataLen)
                {
                    // tell'em the size required for the longest name
                    pbData = 0;
                    dwReturnLength =
                        BufferLengthRequired(ce.Names());
                    dwError = ERROR_MORE_DATA;
                }
                else
                    rgpCtx->CntrEnumerator(ce);
            }
            else
                dwError = ERROR_NO_MORE_ITEMS;
        }

        if ((ERROR_SUCCESS != dwError) &&
            (ERROR_MORE_DATA != dwError))
            throw scu::OsException(dwError);

        Assign(pbData, pdwDataLen, pvReturnData, dwReturnLength);
    }

    bool
    FlagsAreSet(DWORD dwFlags,
                DWORD dwFlagsToTestFor)
    {
        return (dwFlags & dwFlagsToTestFor)
            ? true
            : false;
    }

    void
    Pin(Guarded<CryptContext *> const &rgpCtx,
        char const *pszPin)
    {
        // TO DO: Should forward PIN setting to aux context
        // when this context is ephemeral.
        if (rgpCtx->IsEphemeral())
            throw scu::OsException(ERROR_INVALID_PARAMETER);

            // TO DO: UNICODE ?
        rgpCtx->Pin(User, pszPin);
    }

    // Throw if more than dwValidFlags are set in dwFlags
    void
    ValidateFlags(DWORD dwFlags,
                  DWORD dwValidFlags)
    {
        if (dwFlags & ~dwValidFlags)
            throw scu::OsException(NTE_BAD_FLAGS);
    }

    class StaleContainerKeyAccumulator
        : public binary_function<vector<AdaptiveContainerRegistrar::EnrolleeType>,
                                 AdaptiveContainerRegistrar::RegistryType::CollectionType::value_type,
                                 vector<AdaptiveContainerRegistrar::EnrolleeType> >
    {
    public:

        explicit
        StaleContainerKeyAccumulator()
        {}


        result_type
        operator()(first_argument_type &rvStaleCntrs,
                   second_argument_type const &rvt) const
        {
            if (!rvt.second->CardContext(false))
                rvStaleCntrs.push_back(rvt.second);

            return rvStaleCntrs;
        }

    private:

    };

    bool FindCryptCtxForACntr(HAdaptiveContainer &rhAdptCntr)
    {
        bool fRetValue = false;
        for(int i = 0; i< hlCryptContexts.Count();i++)
        {
            CryptContext *pCryptCtx = static_cast<CryptContext *>
                (hlCryptContexts.GetQuietly(hlCryptContexts.IndexHandle(i)));
            if( pCryptCtx && pCryptCtx->AdaptiveContainer() == rhAdptCntr)
            {
                fRetValue = true;
            }
        }
        return fRetValue;
    }
    

    void CollectRegistryGarbage()
    {
        Guarded<Lockable *> guard(&AdaptiveContainerRegistrar::Registry());  // serialize registry access
        
        AdaptiveContainerRegistrar::ConstRegistryType &rRegistry = 
            AdaptiveContainerRegistrar::Registry();
        
        AdaptiveContainerRegistrar::ConstRegistryType::CollectionType
            &rcollection = rRegistry();
        vector<AdaptiveContainerRegistrar::EnrolleeType>
            vStaleCntrs(accumulate(rcollection.begin(), rcollection.end(),
                                   vector<AdaptiveContainerRegistrar::EnrolleeType>(),
                                   StaleContainerKeyAccumulator()));
        for (vector<AdaptiveContainerRegistrar::EnrolleeType>::iterator iCurrent(vStaleCntrs.begin());
             iCurrent != vStaleCntrs.end(); ++iCurrent)
        {
            //Lookup the CryptContext list to see if any of these
            //stale container are referenced. If not, remove them
            //to avoid memory leaks.
            if(!FindCryptCtxForACntr(HAdaptiveContainer(*iCurrent)))
            {
                //Remove the adaptive container from the registry
                AdaptiveContainerKey aKey(HCardContext(0),
                                          (*iCurrent)->Name());
                AdaptiveContainerRegistrar::Discard(aKey);
            }
        } 
    }
    
} // namespace

////////////////////////// BEGIN CSP INTERFACE /////////////////////////////
//
// See MSDN for documentation on these interfaces.
//


SLBCSPAPI
CPAcquireContext(OUT HCRYPTPROV *phProv,
                 IN LPCTSTR pszContainer,
                 IN DWORD dwFlags,
                 IN PVTableProvStruc pVTable)
{
    BOOL fSts = CRYPT_FAILED;    

    SecureArray<char> sac(80);
    
    CSPI_TRY(CPAcquireContext)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        CSpec cspec(pszContainer
                    ? AsCCharP(pszContainer)
                    : "");

        ValidateFlags(dwFlags, (CRYPT_VERIFYCONTEXT |
                                CRYPT_NEWKEYSET |
                                CRYPT_MACHINE_KEYSET |
                                CRYPT_DELETEKEYSET |
                                CRYPT_SILENT));

        if (!phProv)
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        bool const fMakeEphemeral   = FlagsAreSet(dwFlags,
                                                  CRYPT_VERIFYCONTEXT);
        bool const fGuiEnabled      = !(FlagsAreSet(dwFlags, CRYPT_SILENT) ||
                                        (cspec.CardId().empty() &&
                                         fMakeEphemeral));
        bool const fCreateContainer = FlagsAreSet(dwFlags, CRYPT_NEWKEYSET);
        auto_ptr<CryptContext> apCtx(new CryptContext(cspec, pVTable,
                                                      fGuiEnabled,
                                                      fCreateContainer,
                                                      fMakeEphemeral));

        if (FlagsAreSet(dwFlags, CRYPT_DELETEKEYSET))
            apCtx->RemoveContainer();
        else
        {
            *phProv =
                static_cast<HCRYPTPROV>(hlCryptContexts.Add(apCtx.get()));
            apCtx.release();
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGetProvParam(IN HCRYPTPROV hProv,
               IN DWORD dwParam,
               IN BYTE *pbData,
               IN OUT DWORD *pdwDataLen,
               IN DWORD dwFlags)
{
    using namespace ProviderProfile;

    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGetProvParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        switch (dwParam)
        {
        case PP_CONTAINER:
        case PP_UNIQUE_CONTAINER:
            {
                ValidateFlags(dwFlags, 0);
                HAdaptiveContainer hacntr = gpCtx->AdaptiveContainer();
                if (!hacntr)
                    throw scu::OsException(ERROR_INVALID_PARAMETER);
                string sName(hacntr->TheCContainer()->Name());
                Assign(pbData, pdwDataLen, sName.c_str(),
                       sName.length() + 1);
            }
        break;

        case PP_ENUMALGS:
        case PP_ENUMALGS_EX:
            {
                ValidateFlags(dwFlags, CRYPT_FIRST);
                AlignedBlob abAlgInfo;
                gpCtx->EnumAlgorithms(dwParam, dwFlags, (0 != pbData),
                                      abAlgInfo); 
                Assign(pbData, pdwDataLen, abAlgInfo.Data(),
                       abAlgInfo.Length());
            }
            break;

        case PP_ENUMCONTAINERS:
            ValidateFlags(dwFlags, CRYPT_FIRST | CRYPT_MACHINE_KEYSET);
            EnumContainers(gpCtx, pbData, pdwDataLen,
                           (CRYPT_FIRST & dwFlags));
            break;

        case PP_IMPTYPE:
            {
                ValidateFlags(dwFlags, 0);
                DWORD const dwImplType = CRYPT_IMPL_MIXED | CRYPT_IMPL_REMOVABLE;
                Assign(pbData, pdwDataLen, &dwImplType,
                       sizeof dwImplType);
            }
        break;

        case PP_NAME:
            {
                ValidateFlags(dwFlags, 0);
                CString sName(CspProfile::Instance().Name());
                
                Assign(pbData, pdwDataLen, (LPCTSTR)sName);
            }
        break;

        case PP_VERSION:
            {
                ValidateFlags(dwFlags, 0);
                VersionInfo const &ver = CspProfile::Instance().Version();
                DWORD dwVersion = (ver.m_dwMajor << 8) | ver.m_dwMinor;
                Assign(pbData, pdwDataLen, &dwVersion, sizeof dwVersion);
            }
        break;

        case PP_PROVTYPE:
            {
                ValidateFlags(dwFlags, 0);
                DWORD const dwType = CspProfile::Instance().Type();
                Assign(pbData, pdwDataLen, &dwType, sizeof dwType);
            }
        break;

        case PP_KEYX_KEYSIZE_INC: // fall-through
        case PP_SIG_KEYSIZE_INC:
            {
                ValidateFlags(dwFlags, 0);
                DWORD const dwIncrement = 0;
                Assign(pbData, pdwDataLen, &dwIncrement, sizeof dwIncrement);
            }
        break;

        case PP_ENUMEX_SIGNING_PROT:
            ValidateFlags(dwFlags, 0);
            if (CryptGetProvParam(gpCtx->AuxContext(), dwParam,
                                  pbData, pdwDataLen, dwFlags))
                throw scu::OsException(GetLastError());
            break;

        case PP_KEYSPEC:
            {
                ValidateFlags(dwFlags, 0);
                DWORD const dwKeySpec = AT_SIGNATURE | AT_KEYEXCHANGE;
                Assign(pbData, pdwDataLen, &dwKeySpec, sizeof
                       dwKeySpec);
            }
            break;
            
        default:
            throw scu::OsException(NTE_BAD_TYPE);
            break;
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPReleaseContext(IN HCRYPTPROV hProv,
                 IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPReleaseContext)
    {
        ValidateFlags(dwFlags, 0);

        Guard<Lockable> grdMaster(TheMasterLock());
        
        auto_ptr<CryptContext> apCtx(static_cast<CryptContext *>(hlCryptContexts.Close(hProv)));

        // TO DO: Verify current thread is this context's owning
        // thread *and* not currently in use; if not, return
        // ERROR_BUSY.

        //Garbage collection of unusable adaptive containers
        //that this or other threads may have left behind. An unusable
        //container is one which is not referenced by any of the
        //existing active crypt contexts.
        try
        {
            CollectRegistryGarbage();        
        }
        catch(...)
        {
            //Don't let exceptions during garbage collection
            //propagate outside. These are likely due to other
            //problems which are better exposed with proper error
            //codes from other parts of the CSP.
        }
    }

    CSPI_CATCH(fSts);

    if ((CRYPT_SUCCEED == fSts) && (0 != dwFlags))
        fSts = false;

    return fSts;
}

SLBCSPAPI
CPSetProvParam(IN HCRYPTPROV hProv,
               IN DWORD dwParam,
               IN BYTE *pbData,
               IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPSetProvParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        switch (dwParam)
        {
        case PP_KEYEXCHANGE_PIN: // fall-through
        case PP_SIGNATURE_PIN:
            Pin(gpCtx, reinterpret_cast<char *>(pbData));
            break;

        case PP_KEYSET_SEC_DESCR:
            // Ignore this option and return success.
            break;

        case PP_USE_HARDWARE_RNG:
            if (!CryptSetProvParam(gpCtx->AuxContext(), dwParam,
                                   pbData, dwFlags))
                throw scu::OsException(GetLastError());
            break;

        default:
            throw scu::OsException(ERROR_NOT_SUPPORTED);
            break;
        }

    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDeriveKey(IN HCRYPTPROV hProv,
            IN ALG_ID Algid,
            IN HCRYPTHASH hHash,
            IN DWORD dwFlags,
            OUT HCRYPTKEY *phKey)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPDeriveKey)
    {
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);

        auto_ptr<CSessionKeyContext>
            apSessionKey(new CSessionKeyContext(gpCtx->AuxContext()));

        apSessionKey->Derive(Algid, pHash->HashHandleInAuxCSP(),
                             dwFlags);

        *phKey = gpCtx->Add(apSessionKey);
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDestroyKey(IN HCRYPTPROV hProv,
             IN HCRYPTKEY hKey)
{
    BOOL fSts = CRYPT_FAILED;

    // TO DO: Throw ERROR_BUSY if destroying thread is not the owning
    // thread OR some other thread has a handle to this key.

    CSPI_TRY(CPDestroyKey)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        // TO DO: Deleting the first handle usually fails for some reason.
        // For now, protect against the exception and carry on.
        try
        {
            auto_ptr<CKeyContext> apKey(gpCtx->CloseKey(hKey));
        }

        catch (...)
        {}
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDuplicateHash(IN HCRYPTPROV hProv,
                IN HCRYPTHASH hHash,
                IN DWORD *pdwReserved,
                IN DWORD dwFlags,
                OUT HCRYPTHASH *phDupHash)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPDuplicateHash)
    {
        ValidateFlags(dwFlags, 0);

        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);

        auto_ptr<CHashContext> apDupHash(pHash->Clone(pdwReserved, dwFlags));

        *phDupHash = gpCtx->Add(apDupHash);
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDuplicateKey(IN HCRYPTPROV hProv,
               IN HCRYPTKEY hKey,
               IN DWORD *pdwReserved,
               IN DWORD dwFlags,
               OUT HCRYPTKEY *phDupKey)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPDuplicateKey)
    {
        ValidateFlags(dwFlags, 0);

        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CKeyContext *pKey = gpCtx->LookupKey(hKey);

        auto_ptr<CKeyContext> apDupKey(pKey->Clone(pdwReserved, dwFlags));

        *phDupKey = gpCtx->Add(apDupKey);
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPExportKey(IN HCRYPTPROV hProv,
            IN HCRYPTKEY hKey,
            IN HCRYPTKEY hExpKey,
            IN DWORD dwBlobType,
            IN DWORD dwFlags,
            OUT BYTE *pbData,
            IN OUT DWORD *pdwDataLen)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPExportKey)
    {
        ValidateFlags(dwFlags, 0);

        if (PRIVATEKEYBLOB == dwBlobType)
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CKeyContext *pKey = gpCtx->LookupKey(hKey);

        if (KT_SESSIONKEY == pKey->TypeOfKey())
        {
            if ((SIMPLEBLOB != dwBlobType) &&
                (SYMMETRICWRAPKEYBLOB != dwBlobType))
                throw scu::OsException(NTE_BAD_TYPE);
        }
        else
            if (PUBLICKEYBLOB != dwBlobType)
                throw scu::OsException(NTE_BAD_TYPE);

        if (hExpKey && (PUBLICKEYBLOB == dwBlobType))
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        
        CKeyContext *pExpKey = 0;
        if (SIMPLEBLOB != dwBlobType)
        {
            pExpKey = hExpKey
                ? gpCtx->LookupKey(hExpKey)
                : 0;
        }
        else
        {
            CPublicKeyContext *pPubExpKey = hExpKey
                ? gpCtx->LookupPublicKey(hExpKey)
                : 0;

            if (pPubExpKey)
            {
                if (!pPubExpKey->AuxKeyLoaded())
                    pPubExpKey->AuxPublicKey(pPubExpKey->AsAlignedBlob(0, dwBlobType));
            }
            pExpKey = pPubExpKey;
        }
        HCRYPTKEY hAuxExpKey = pExpKey
            ? pExpKey->KeyHandleInAuxCSP()
            : 0;
        
        SecureArray<BYTE> abKey(pKey->AsAlignedBlob(hAuxExpKey, dwBlobType));

        Assign(pbData, pdwDataLen, abKey.data(), abKey.length());
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGenKey(IN HCRYPTPROV hProv,
         IN ALG_ID Algid,
         IN DWORD dwFlags,
         OUT HCRYPTKEY *phKey)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGenKey)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        if (FlagsAreSet(dwFlags, CRYPT_USER_PROTECTED) &&
            !gpCtx->GuiEnabled())
            throw scu::OsException(NTE_SILENT_CONTEXT);

        *phKey = gpCtx->GenerateKey(Algid, dwFlags);

        fSts = CRYPT_SUCCEED;
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGetKeyParam(IN HCRYPTPROV hProv,
              IN HCRYPTKEY hKey,
              IN DWORD dwParam,
              OUT BYTE *pbData,
              IN DWORD *pdwDataLen,
              IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGetKeyParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CKeyContext *pKey = gpCtx->LookupKey(hKey);

        ValidateFlags(dwFlags, 0);

        if (KT_PUBLICKEY == pKey->TypeOfKey())
        {

            // Public key
            CPublicKeyContext *pPubKey =
                static_cast<CPublicKeyContext *>(pKey);

            switch (dwParam)
            {
            case KP_ALGID:
                {
                    pPubKey->VerifyKeyExists();
                    ALG_ID algid;
                    if (pPubKey->KeySpec() == AT_KEYEXCHANGE)
                        algid = CALG_RSA_KEYX;
                    else
                        algid = CALG_RSA_SIGN;
                    Assign(pbData, pdwDataLen, &algid, sizeof algid);
                }
            break;

            case KP_BLOCKLEN:
                {
                    pPubKey->VerifyKeyExists();
                    CPublicKeyContext::StrengthType stBlockLen =
                        pPubKey->MaxStrength();
                    Assign(pbData, pdwDataLen, &stBlockLen, sizeof stBlockLen);
                }
            break;

            case KP_KEYLEN:
                {
                    pPubKey->VerifyKeyExists();
                    DWORD dwKeyLen = pPubKey->MaxStrength(); // must be DWORD
                    Assign(pbData, pdwDataLen, &dwKeyLen, sizeof dwKeyLen);
                }
            break;

            case KP_PERMISSIONS:
                {
                    pPubKey->VerifyKeyExists();
                    BYTE bPermissions = pPubKey->Permissions();
                    Assign(pbData, pdwDataLen,
                           &bPermissions, sizeof bPermissions);
                }

            break;

            case KP_CERTIFICATE:
                {
                    CWaitCursor waitCursor;

                    Blob const blob(pPubKey->Certificate());
                    Assign(pbData, pdwDataLen, blob);
                }
            break;

            default:
                throw scu::OsException(NTE_BAD_TYPE);

            }
        }
        else
        {
            // session key
            CSessionKeyContext *pSessionKey =
                static_cast<CSessionKeyContext *>(pKey);
            if (!CryptGetKeyParam(pSessionKey->KeyHandleInAuxCSP(),
                                  dwParam, pbData, pdwDataLen, dwFlags))
                throw scu::OsException(GetLastError());
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGenRandom(IN HCRYPTPROV hProv,
            IN DWORD dwLen,
            IN OUT BYTE *pbBuffer)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGenRandom)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

                if (!pbBuffer || (0 == dwLen))
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        HAdaptiveContainer hacntr = gpCtx->AdaptiveContainer();
        if (!hacntr)
        {
            if (!CryptGenRandom(gpCtx->AuxContext(), dwLen, pbBuffer))
                throw scu::OsException(GetLastError());
        }
        else
        {
            Secured<HAdaptiveContainer> hsacntr(hacntr);

            hsacntr->TheCContainer()->Card()->GenRandom(dwLen, pbBuffer);
        }

        fSts = CRYPT_SUCCEED;
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGetUserKey(IN HCRYPTPROV hProv,
             IN DWORD dwKeySpec,
             OUT HCRYPTKEY *phUserKey)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGetUserKey)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        // TO DO: This should really be a key pair, not public key.
        CKeyContext *pKey = 0;
        auto_ptr<CKeyContext>
            apKey(new CPublicKeyContext(gpCtx->AuxContext(), **gpCtx,
                                        dwKeySpec));

        *phUserKey = gpCtx->Add(apKey);
        fSts = CRYPT_SUCCEED;
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPImportKey(IN HCRYPTPROV hProv,
            IN CONST BYTE *pbData,
            IN DWORD dwDataLen,
            IN HCRYPTKEY hImpKey,
            IN DWORD dwFlags,
            OUT HCRYPTKEY *phKey)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPImportKey)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        if (!phKey)
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        // Conversion to do here
        PUBLICKEYSTRUC const *pPubKey =
            reinterpret_cast<PUBLICKEYSTRUC const *>(pbData);
        if (CUR_BLOB_VERSION != pPubKey->bVersion)   // 2
            throw scu::OsException(NTE_BAD_VER);

        switch(pPubKey->bType)
        {
        case PRIVATEKEYBLOB:  // fall-through intentional
        case PUBLICKEYBLOB:
            {
                DWORD dwKeySpec;

                switch (pPubKey->aiKeyAlg)
                {
                case CALG_RSA_SIGN:
                    dwKeySpec = AT_SIGNATURE;
                    break;

                case CALG_RSA_KEYX:
                    dwKeySpec = AT_KEYEXCHANGE;
                    break;

                default:
                    throw scu::OsException(NTE_BAD_ALGID);
                }
                              
                SecureArray<BYTE> blbMsKey(pbData, dwDataLen);
                auto_ptr<CPublicKeyContext> apKey;
                if (PRIVATEKEYBLOB == pPubKey->bType)
                {
                    HCRYPTKEY hEncKey = hImpKey
                        ? gpCtx->LookupSessionKey(hImpKey)->KeyHandleInAuxCSP()
                        : 0;

                    ValidateFlags(dwFlags, CRYPT_EXPORTABLE);
                    apKey = gpCtx->ImportPrivateKey(blbMsKey,
                                                    dwKeySpec,
                                                    (dwFlags &
                                                     CRYPT_EXPORTABLE) != 0,
                                                    hEncKey);
                }
                else
                {
                    if (0 != hImpKey)
                        throw scu::OsException(ERROR_INVALID_PARAMETER);
                    ValidateFlags(dwFlags, 0);
                    apKey = gpCtx->ImportPublicKey(blbMsKey,
                                                   dwKeySpec);
                }
                *phKey = gpCtx->Add(apKey);
            }
        break;

        case SIMPLEBLOB:
            {
                auto_ptr<CSessionKeyContext> apKey;
                ALG_ID const *pAlgId =
                    reinterpret_cast<ALG_ID const *>(&pbData[sizeof BLOBHEADER]);

                if (CALG_RSA_KEYX == *pAlgId)
                {
                    // ignore hImp
                    apKey = gpCtx->UseSessionKey(pbData, dwDataLen, 0, dwFlags);
                }
                else
                {
                    // if other algo then hImp shall specify a session key
                    if (!hImpKey)
                        throw scu::OsException(ERROR_INVALID_PARAMETER);

                    // Find the handle in the Aux CSP corresponding
                    // to hImpKey which should have been previously
                    // imported in the CSP
                    CSessionKeyContext *pSessionKey =
                        gpCtx->LookupSessionKey(hImpKey);

                    apKey = gpCtx->UseSessionKey(pbData, dwDataLen,
                                                 pSessionKey->KeyHandleInAuxCSP(),
                                                 dwFlags);

                }
                *phKey = gpCtx->Add(apKey);
            }
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPSetKeyParam(IN HCRYPTPROV hProv,
              IN HCRYPTKEY hKey,
              IN DWORD dwParam,
              IN BYTE *pbData,
              IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPSetKeyParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CKeyContext *pKey = gpCtx->LookupKey(hKey);

        switch (pKey->TypeOfKey())
        {
        case KT_PUBLICKEY:
            {
                CPublicKeyContext *pPubKey =
                    static_cast<CPublicKeyContext *>(pKey);

                // Error return is a special case for KP_CERTIFICATE,
                // see below.
                if (KP_CERTIFICATE != dwParam)
                    ValidateFlags(dwFlags, 0);

                switch(dwParam)
                {
                case KP_CERTIFICATE:
                    try
                    {
                        ValidateFlags(dwFlags, 0);
                        pPubKey->Certificate(pbData);
                    }

                    // Xenroll provided by Microsoft only recognizes
                    // SCARD_ errors when writing a certificate.  It
                    // does, however, recognize all other errors when
                    // *not* writing a certificate.  The MS
                    // OS/Security group recognizes Xenroll is in
                    // error but it will be some time, if ever, before
                    // it will be fixed.  So, all errors are
                    // translated into SCARD_ errors at this point.
                    catch (scu::Exception const &rExc)
                    {
                        CapiError ce(AsCapiError(rExc));
                        if (NTE_TOKEN_KEYSET_STORAGE_FULL == ce)
                            ce = SCARD_E_WRITE_TOO_MANY;
                        else
                            if (FACILITY_SCARD != HRESULT_FACILITY(ce))
                                ce = SCARD_E_UNEXPECTED;
                        throw scu::OsException(ce);
                    }

                    catch (...)
                    {
                        throw scu::OsException(SCARD_E_UNEXPECTED);
                    }
                    
                    break;

                case KP_PERMISSIONS:
                    pPubKey->Permissions(*pbData);
                    break;

                case PP_KEYEXCHANGE_PIN: // fall-through
                case PP_SIGNATURE_PIN:
                    Pin(gpCtx, reinterpret_cast<char *>(pbData));
                    break;

                default:
                    throw scu::OsException(ERROR_NOT_SUPPORTED);
                    break;
                }
                break;
            }

        case KT_SESSIONKEY:
            {
                CSessionKeyContext *pSessionKey =
                    static_cast<CSessionKeyContext*>(pKey);

                if (!CryptSetKeyParam(pSessionKey->KeyHandleInAuxCSP(),
                                      dwParam, pbData, dwFlags))
                    throw scu::OsException(GetLastError());

                break;
            }

        default:
            throw scu::OsException(ERROR_NOT_SUPPORTED);
            break;
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPEncrypt(IN HCRYPTPROV hProv,
          IN HCRYPTKEY hKey,
          IN HCRYPTHASH hHash,
          IN BOOL Final,
          IN DWORD dwFlags,
          IN OUT BYTE *pbData,
          IN OUT DWORD *pdwDataLen,
          IN DWORD dwBufLen)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPEncrypt)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CKeyContext *pKeyCtx = gpCtx->LookupKey(hKey);

        ValidateFlags(dwFlags, CRYPT_OAEP);

        HCRYPTHASH hAuxHash = hHash
            ? gpCtx->LookupHash(hHash)->HashHandleInAuxCSP()
            : NULL;

        pKeyCtx->Encrypt(hAuxHash, Final, dwFlags, pbData, pdwDataLen,
                                 dwBufLen);

    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDecrypt(IN HCRYPTPROV hProv,
          IN HCRYPTKEY hKey,
          IN HCRYPTHASH hHash,
          IN BOOL Final,
          IN DWORD dwFlags,
          IN OUT BYTE *pbData,
          IN OUT DWORD *pdwDataLen)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPDecrypt)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CSessionKeyContext *pSessionKey = gpCtx->LookupSessionKey(hKey);

        ValidateFlags(dwFlags, CRYPT_OAEP);

        if (hHash)
        {
            CHashContext *pHash = gpCtx->LookupHash(hHash);

            pSessionKey->Decrypt(pHash->HashHandleInAuxCSP(), Final,
                                 dwFlags, pbData, pdwDataLen);

            pHash->ExportFromAuxCSP();
        }
        else
            pSessionKey->Decrypt(0, Final, dwFlags, pbData, pdwDataLen);

    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPCreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPCreateHash)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        ValidateFlags(dwFlags, 0);

        auto_ptr<CHashContext> apHash(CHashContext::Make(Algid, **gpCtx));

        apHash->ImportToAuxCSP();

        *phHash = gpCtx->Add(apHash);
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPDestroyHash(IN HCRYPTPROV hProv,
              IN HCRYPTHASH hHash)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPDestroyHash)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        auto_ptr<CHashContext> apHash(gpCtx->CloseHash(hHash));
        apHash->Close();
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPGetHashParam(IN HCRYPTPROV hProv,
               IN HCRYPTHASH hHash,
               IN DWORD dwParam,
               OUT BYTE *pbData,
               IN DWORD *pdwDataLen,
               IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPGetHashParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);

        ValidateFlags(dwFlags, 0);

        switch (dwParam)
        {
        case HP_ALGID:
            {
                ALG_ID const algid = pHash->AlgId();
                Assign(pbData, pdwDataLen, &algid, sizeof algid);
            }
        break;

        case HP_HASHSIZE:
            {
                CHashContext::SizeType const cLength = pHash->Length();
                Assign(pbData, pdwDataLen, &cLength, sizeof cLength);
            }
        break;

        case HP_HASHVAL:
            {
                Blob const blob(pHash->Value());
                Assign(pbData, pdwDataLen, blob);
            }
        break;

        default:
            throw scu::OsException(ERROR_INVALID_PARAMETER);
            break;
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPHashData(IN HCRYPTPROV hProv,
           IN HCRYPTHASH hHash,
           IN CONST BYTE *pbData,
           IN DWORD dwDataLen,
           IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPHashData)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);
        if (!CryptHashData(pHash->HashHandleInAuxCSP(), pbData, dwDataLen,
                           dwFlags))
            throw scu::OsException(GetLastError());
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPHashSessionKey(IN HCRYPTPROV hProv,
                 IN HCRYPTHASH hHash,
                 IN  HCRYPTKEY hKey,
                 IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPHashSessionKey)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CSessionKeyContext *pSessionKey = gpCtx->LookupSessionKey(hKey);
        CHashContext *pHash = gpCtx->LookupHash(hHash);

        if (!CryptHashSessionKey(pHash->HashHandleInAuxCSP(),
                                 pSessionKey->KeyHandleInAuxCSP(),
                                 dwFlags))
            throw scu::OsException(GetLastError());

        pHash->ExportFromAuxCSP();
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPSetHashParam(IN HCRYPTPROV hProv,
               IN HCRYPTHASH hHash,
               IN DWORD dwParam,
               IN BYTE *pbData,
               IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPSetHashParam)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);
        if (!CryptSetHashParam(pHash->HashHandleInAuxCSP(), dwParam,
                               pbData, dwFlags))
            throw scu::OsException(GetLastError());
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPSignHash(IN HCRYPTPROV hProv,
           IN HCRYPTHASH hHash,
           IN DWORD dwKeySpec,
           IN LPCTSTR szDescription,
           IN DWORD dwFlags,
           OUT BYTE *pbSignature,
           IN OUT DWORD *pdwSigLen)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPSignHash)
	{
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);

        if (!pdwSigLen)
            throw scu::OsException(ERROR_INVALID_PARAMETER);

        ValidateFlags(dwFlags, CRYPT_NOHASHOID);

        // TO DO: This should really be a private key and
        // avoid having to fetch the public key to get the modulus
        CPublicKeyContext Key(gpCtx->AuxContext(), **gpCtx, dwKeySpec);
        DWORD cSignatureLength =
            Key.Strength() / numeric_limits<BYTE>::digits;

        if (!pbSignature)
        {
            *pdwSigLen = cSignatureLength;
        }
        else if (*pdwSigLen < cSignatureLength)
        {
            *pdwSigLen = cSignatureLength;
            throw scu::OsException(ERROR_MORE_DATA);
        }
        else
        {
            // Security:  Support for the description parameter is
            // removed due to security vulnerability.
            if (szDescription)
                throw scu::OsException(ERROR_INVALID_PARAMETER);
            Blob SignedHash(Key.Sign(pHash, dwFlags & CRYPT_NOHASHOID));
            memcpy(pbSignature, SignedHash.data(), SignedHash.length());
            *pdwSigLen = SignedHash.length();
        }
    }

    CSPI_CATCH(fSts);

    return fSts;
}

SLBCSPAPI
CPVerifySignature(IN HCRYPTPROV hProv,
                  IN HCRYPTHASH hHash,
                  IN CONST BYTE *pbSignature,
                  IN DWORD dwSigLen,
                  IN HCRYPTKEY hPubKey,
                  IN LPCTSTR szDescription,
                  IN DWORD dwFlags)
{
    BOOL fSts = CRYPT_FAILED;

    CSPI_TRY(CPVerifySignature)
    {
        Guard<Lockable> grdMaster(TheMasterLock());
        
        Guarded<CryptContext *>
            gpCtx(static_cast<CryptContext *>(hlCryptContexts[hProv]));

        CHashContext *pHash = gpCtx->LookupHash(hHash);
        CPublicKeyContext *pKey = gpCtx->LookupPublicKey(hPubKey);

        ValidateFlags(dwFlags, CRYPT_NOHASHOID);

        pKey->VerifySignature(pHash->HashHandleInAuxCSP(),
                              pbSignature, dwSigLen,
                              szDescription, dwFlags);
    }

    CSPI_CATCH(fSts);

    return fSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspprofile.cpp ===
// CspProfile.cpp -- CSP Profile class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "stdafx.h"

#include <stddef.h>
#include <basetsd.h>
#include <wincrypt.h>

#include <scuOsExc.h>

#include <slbModVer.h>

#include "StResource.h"
#include "MasterLock.h"
#include "Guard.h"
#include "Blob.h"
#include "CspProfile.h"

using namespace std;
using namespace ProviderProfile;

namespace
{
    BYTE g_abCF4kATRString[]     = { 0x3b, 0xe2, 0x00, 0x00, 0x40, 0x20,
                                     0x49, 0x00 };
    BYTE g_abCF4kATRMask[]       = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                     0xff, 0x00 };

    BYTE g_abCF8kATRString[]     = { 0x3b, 0x85, 0x40, 0x20, 0x68,
                                     0x01, 0x01, 0x00, 0x00 };
    BYTE g_abCF8kATRMask[]       = { 0xff, 0xff, 0xff, 0xff, 0xff,
                                     0xff, 0xff, 0x00, 0x00 };

    BYTE g_abCF8kV2ATRString[]   = { 0x3b, 0x95, 0x15, 0x40, 0x00,
                                     0x68, 0x01, 0x02, 0x00, 0x00 };
    BYTE g_abCF8kV2ATRMask[]     = { 0xff, 0xff, 0xff, 0xff, 0x00,
                                     0xff, 0xff, 0xff, 0x00, 0x00 };

//      BYTE g_abCF16kATRString[]    = { 0x3B, 0x95, 0x15, 0x40, 0xFF, 0x63,
//                                       0x01, 0x01, 0x00, 0x00 };
//      BYTE g_abCF16kATRMask[]      = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//                                       0xFF, 0xFF, 0x00, 0x00 };

    BYTE g_abCFe_gateATRString[] = { 0x3B, 0x95, 0x00, 0x40, 0xFF,
                                     0x62, 0x01, 0x01, 0x00, 0x00 };
    BYTE g_abCFe_gateATRMask[]   = { 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
                                     0xFF, 0xFF, 0xFF, 0x00, 0x00 };

    BYTE g_abCA16kATRString[]    = { 0x3b, 0x16, 0x94, 0x81, 0x10,
                                     0x06, 0x01, 0x00, 0x00 };
    BYTE g_abCA16kATRMask[]      = { 0xff, 0xff, 0xff, 0xff, 0xff,
                                     0xff, 0xff, 0x00, 0x00 };

    BYTE g_abCACampusATRString[] = { 0x3b, 0x23, 0x00, 0x35, 0x13, 0x80 };
    BYTE g_abCACampusATRMask[]   = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

    BYTE g_abCFActivCardATRString[]   = { 0x3b, 0x05, 0x68, 0x01, 0x01,
                                          0x02, 0x05 };
    BYTE g_abCFActivCardATRMask[]     = { 0xff, 0xff, 0xff, 0xff, 0xff,
                                          0xff, 0xff };

    GUID g_guidPrimaryProvider   = { 0x19B7E2E8, 0xFEBD, 0x11d0,
                                     { 0x88, 0x27, 0x00, 0xA0, 0xC9,
                                       0x55, 0xFC, 0x7E } };

} // namespace

ATR::ATR()
    : m_al(0)
{}

ATR::ATR(Length al,
         BYTE const abATR[],
         BYTE const abMask[])
    : m_al(al)
{
    memcpy(m_atrstring, abATR, al);
    memcpy(m_atrsMask, abMask, al);
}

BYTE const *
ATR::String() const
{
    return m_atrstring;
}

BYTE const *
ATR::Mask() const
{
    return m_atrsMask;
}

ATR::Length
ATR::ATRLength() const
{
    return m_al;
}

size_t
ATR::Size() const
{
    return m_al * sizeof *m_atrstring;
}

ATR &
ATR::operator=(ATR const &rhs)
{
    if (*this != rhs)
    {
        m_al = rhs.m_al;
        memcpy(m_atrstring, rhs.m_atrstring,
               sizeof m_atrstring / sizeof *m_atrstring);
        memcpy(m_atrsMask, rhs.m_atrsMask,
               sizeof m_atrsMask / sizeof *m_atrsMask);
    }

    return *this;
}

bool
ATR::operator==(ATR const &rhs)
{
    return !(*this != rhs);
}

bool
ATR::operator!=(ATR const &rhs)
{
    return (m_al != rhs.m_al) ||
        memcmp(m_atrstring, rhs.m_atrstring, m_al) ||
        memcmp(m_atrsMask, rhs.m_atrsMask, m_al);
}

CardProfile::CardProfile()
    : m_atr(),
      m_sFriendlyName(),
      m_sRegistryName(),
      m_csFriendlyName(),
      m_csRegistryName(),
      m_gPrimaryProvider(),
      m_attr(Attribute::attrNone)
{}

CardProfile::CardProfile(ProviderProfile::ATR const &ratr,
                         string const &rsFriendlyName,
                         string const &rsRegistryName,
                         GUID const &rgPrimaryProvider,
                         Attribute attr)
    : m_atr(ratr),
      m_sFriendlyName(rsFriendlyName),
      m_sRegistryName(rsRegistryName),
      m_csFriendlyName(StringResource::UnicodeFromAscii(rsFriendlyName)),
      m_csRegistryName(StringResource::UnicodeFromAscii(rsRegistryName)),
      m_gPrimaryProvider(rgPrimaryProvider),
      m_attr(attr)
{}

CardProfile::CardProfile(ProviderProfile::ATR const &ratr,
                         CString const &rcsFriendlyName,
                         CString const &rcsRegistryName,
                         GUID const &rgPrimaryProvider,
                         Attribute attr)
    : m_atr(ratr),
      m_csFriendlyName(rcsFriendlyName),
      m_csRegistryName(rcsRegistryName),
      m_sFriendlyName(StringResource::AsciiFromUnicode((LPCTSTR)rcsFriendlyName)),
      m_sRegistryName(StringResource::AsciiFromUnicode((LPCTSTR)rcsRegistryName)),
      m_gPrimaryProvider(rgPrimaryProvider),
      m_attr(attr)
{}

CardProfile::~CardProfile()
{}

ATR const &
CardProfile::ATR() const
{
    return m_atr;
}

string
CardProfile::FriendlyName() const
{
    return m_sFriendlyName;
}

CString
CardProfile::csFriendlyName() const
{
    return m_csFriendlyName;
}

GUID const &
CardProfile::PrimaryProvider() const
{
    return m_gPrimaryProvider;
}

string
CardProfile::RegistryName() const
{
    return m_sRegistryName;
}

CString
CardProfile::csRegistryName() const
{
    return m_csRegistryName;
}

bool
CardProfile::AtrMatches(ATR::Length cAtr,
                        BYTE const *pbRhsAtr) const
{
    bool fIsAMatch = false;
    ATR::Length const cAtrLength = m_atr.ATRLength();
    if (cAtrLength == cAtr)
    {
        BYTE const *pbLhsAtr = m_atr.String();
        BYTE const *pbLhsMask = m_atr.Mask();
        for (ATR::Length i = 0; cAtrLength != i; ++i)
        {
            if ((pbLhsMask[i] & pbLhsAtr[i]) != (pbLhsMask[i] & pbRhsAtr[i]))
                    break;                        // no sense continuing
        }

        if (cAtrLength == i)
            fIsAMatch = true;
    }

    return fIsAMatch;
}

bool
CardProfile::HasAttribute(Attribute attr) const
{
    return m_attr & attr ? true : false;
}

bool
CardProfile::operator==(CardProfile const &rhs)
{
    return !(*this != rhs);
}

bool
CardProfile::operator!=(CardProfile const &rhs)
{
    return (m_atr != rhs.m_atr) ||
        (m_sFriendlyName != rhs.m_sFriendlyName) ||
        (memcmp(&m_gPrimaryProvider, &rhs.m_gPrimaryProvider,
                sizeof m_gPrimaryProvider)) ||
        (m_attr != m_attr);
}

CspProfile::CspProfile(DWORD Type,
                       vector<CardProfile> const &rvcp)
    : m_hDllInstance(0),
      m_dwType(Type),
      m_vi(),
      m_vcp(rvcp),
      m_hResInstance(0),
      m_apExtDll()
{
    static const TCHAR szBaseRsrc[] = TEXT("slbRcCsp.dll");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_hDllInstance = AfxGetInstanceHandle();
    if (!m_hDllInstance)
        throw scu::OsException(GetLastError());

    // Try loading slbRcCsp.dll from the same directory as this CSP.
    DWORD dwLen;
    TCHAR szFileName[MAX_PATH + sizeof TCHAR];
    dwLen = GetModuleFileName(m_hDllInstance, szFileName,
                              MAX_PATH );
    if (0 == dwLen)
        throw scu::OsException(GetLastError());
    szFileName[dwLen] = 0;

    wstring wsPathDelimiters(TEXT(":\\"));
    wstring wsDllName(szFileName);
    wstring::size_type cDelimiterPosition(wsDllName.find_last_of(wsPathDelimiters));
    // Security: Ensure the filename used to LoadLibraryEx contains a
    // path so the normal search strategy is not invoked; otherwise it
    // leaves a security vulnerability.
    if (wstring::npos != cDelimiterPosition)
    {
        wstring wsModuleName = wsDllName.substr(0, cDelimiterPosition + 1) +
            wstring(szBaseRsrc);
        m_hResInstance  = LoadLibraryEx(wsModuleName.c_str(), NULL,
                                        LOAD_LIBRARY_AS_DATAFILE);
        if (!m_hResInstance)
            throw scu::OsException(GetLastError());
    }
    else
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    CModuleVersion cmv;
    if (!cmv.GetFileVersionInfo((HMODULE)m_hDllInstance))
        throw scu::OsException(GetLastError());
    
    m_vi.m_dwMajor = HIWORD(cmv.dwProductVersionMS);
    m_vi.m_dwMinor = LOWORD(cmv.dwProductVersionMS);
}

CspProfile::~CspProfile()
{
    try
    {
        if (m_hResInstance)
        {
            FreeLibrary(m_hResInstance);
            m_hResInstance = NULL;
        }
    }

    catch (...)
    {
    }
}

const CString
CspProfile::Name() const
{
    return StringResource(IDS_CSP_NAME).AsCString();
}

HINSTANCE
CspProfile::DllInstance() const
{
    if (!m_hDllInstance)
        throw scu::OsException(static_cast<HRESULT>(HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)));

    return m_hDllInstance;
}

HINSTANCE
CspProfile::Resources() const
{
    return (NULL == m_hResInstance) ? m_hDllInstance : m_hResInstance;
}

DWORD
CspProfile::Type() const
{
    return m_dwType;
}

VersionInfo
CspProfile::Version() const
{
    return m_vi;
}

vector<CardProfile> const &
CspProfile::Cards() const
{
    return m_vcp;
}

// Return the one and only Profile object for this CSP
CspProfile const &
CspProfile::Instance()
{
    Guard<Lockable> guard(TheMasterLock());

    if (!m_pInstance)
    {
        //We use CString to be able to do Unicode string manipulations
        CString csCardNamePrefix(TEXT("Schlumberger "),
                                 _tcslen(TEXT("Schlumberger ")));
        ATR atrCF4k(sizeof g_abCF4kATRString / sizeof g_abCF4kATRString[0],
                    g_abCF4kATRString, g_abCF4kATRMask);

        ATR atrCF8k(sizeof g_abCF8kATRString / sizeof g_abCF8kATRString[0],
                    g_abCF8kATRString, g_abCF8kATRMask);

        ATR atrCF8kV2(sizeof g_abCF8kV2ATRString / sizeof g_abCF8kV2ATRString[0],
                      g_abCF8kV2ATRString, g_abCF8kV2ATRMask);

//          ATR atrCF16k(sizeof g_abCF16kATRString / sizeof g_abCF16kATRString[0],
//                      g_abCF16kATRString, g_abCF16kATRMask);

        ATR atrCFe_gate(sizeof g_abCFe_gateATRString / sizeof g_abCFe_gateATRString[0],
                        g_abCFe_gateATRString, g_abCFe_gateATRMask);

        ATR atrCA16k(sizeof g_abCA16kATRString / sizeof g_abCA16kATRString[0],
                      g_abCA16kATRString, g_abCA16kATRMask);

        ATR atrCACampus(sizeof g_abCACampusATRString /
                        sizeof g_abCACampusATRString[0],
                        g_abCACampusATRString, g_abCACampusATRMask);

        ATR atrCFActivCard(sizeof g_abCFActivCardATRString /
                           sizeof g_abCFActivCardATRString[0],
                           g_abCFActivCardATRString, g_abCFActivCardATRMask);

        CString csCF4kFriendlyName(TEXT("Cryptoflex 4K"),
                                   _tcslen(TEXT("Cryptoflex 4K")));
        CardProfile cpCF4k(atrCF4k,
                           csCF4kFriendlyName,
                           csCardNamePrefix + csCF4kFriendlyName,
                           g_guidPrimaryProvider);
  
        CString csCF8kFriendlyName(TEXT("Cryptoflex 8K"),
                                   _tcslen(TEXT("Cryptoflex 8K")));
        CardProfile cpCF8k(atrCF8k,
                           csCF8kFriendlyName,
                           csCardNamePrefix + csCF8kFriendlyName,
                           g_guidPrimaryProvider,
                           CardProfile::attrMsbKeyDefect);

        CString csCF8kV2FriendlyName(TEXT("Cryptoflex 8K v2"),
                                     _tcslen(TEXT("Cryptoflex 8K v2")));
        CardProfile cpCF8kV2(atrCF8kV2,
                             csCF8kV2FriendlyName,
                             csCardNamePrefix + csCF8kV2FriendlyName,
                             g_guidPrimaryProvider);

//          string CF16kFriendlyName(TEXT("Cryptoflex 16K"));
//          CardProfile cpCF16k(atrCF16k,
//                              CF16kFriendlyName,
//                              CardNamePrefix + CF16kFriendlyName,
//                              g_guidPrimaryProvider);

        CString  csCFe_gateFriendlyName(TEXT("Cryptoflex e-gate"),
                                        _tcslen(TEXT("Cryptoflex e-gate")));
        CardProfile cpCFe_gate(atrCFe_gate,
                               csCFe_gateFriendlyName,
                               csCardNamePrefix + csCFe_gateFriendlyName,
                               g_guidPrimaryProvider);

        CString csCA16kFriendlyName(TEXT("Cyberflex Access 16K"),
									_tcslen(TEXT("Cyberflex Access 16K")));
		CardProfile cpCA16k(atrCA16k,
                            csCA16kFriendlyName,
                            csCardNamePrefix + csCA16kFriendlyName,
                            g_guidPrimaryProvider);

        CString csCACampusFriendlyName(TEXT("Cyberflex Access Campus"),
                                       _tcslen(TEXT("Cyberflex Access Campus")));
        CardProfile cpCACampus(atrCACampus,
                               csCACampusFriendlyName,
                               csCardNamePrefix + csCACampusFriendlyName,
                               g_guidPrimaryProvider);

        CString csCFActivCardFriendlyName(TEXT("Cryptoflex ActivCard"),
                                          _tcslen(TEXT("Cryptoflex ActivCard")));
        CardProfile cpCFActivCard(atrCFActivCard,
                                  csCFActivCardFriendlyName,
                                  csCardNamePrefix + csCFActivCardFriendlyName,
                                  g_guidPrimaryProvider);

        vector<CardProfile> vcp;
        vcp.push_back(cpCF4k);
        vcp.push_back(cpCF8k);
        vcp.push_back(cpCF8kV2);
//             vcp.push_back(cpCF16k);
        vcp.push_back(cpCFe_gate);
        vcp.push_back(cpCA16k);
        vcp.push_back(cpCACampus);
        vcp.push_back(cpCFActivCard);

        m_pInstance = new CspProfile(PROV_RSA_FULL, vcp);
    }

    return *m_pInstance;
}

void
CspProfile::Release()
{
    if (m_pInstance)
    {
        Guard<Lockable> guard(TheMasterLock());
        if (m_pInstance)
        {
            // in case delete throws, this is VC++ you know...
            CspProfile *pTmp = m_pInstance;
            m_pInstance = 0;

            delete m_pInstance;
        }
    }
}

CspProfile *CspProfile::m_pInstance = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\encodedmsg.cpp ===
// EncodedMsg.cpp -- Encoded Message implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <scuOsExc.h>

#include "EncodedMsg.h"

///////////////////////////    HELPER     /////////////////////////////////

namespace
{
    typedef Blob::value_type Marker;

    enum
    {
        mSeparator                 = '\x00',
        mPrivatePad                = '\xff'
    };

    enum
    {
        // Require three markers: one block type + two separators
        cRequiredMarkersLength = 3 * sizeof Marker
    };

    enum
    {
        mAlternatePrivateBlockType = '\x00',
        mPrivateBlockType          = '\x01',
        mPublicBlockType           = '\x02'
    };

    enum
    {
        cMinimumPadding = 8
    };


    Blob::size_type
    PadLength(Blob::size_type cMessageLength,
              Blob::size_type cIntendedEncodingLength)
    {
        // Require three markers: one block type + two separators
        Blob::size_type cLength = cIntendedEncodingLength;

        // Calculate pad length, guarding against underflow.
        if (cLength < cMessageLength)
            return 0;
        cLength -= cMessageLength;
        if (cLength < cRequiredMarkersLength)
            return 0;
        cLength -= cRequiredMarkersLength;

        return cLength;
    }
}



///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
EncodedMessage::EncodedMessage(Blob const &rMessage,
                               RsaKey::Type ktOperation,
                               Blob::size_type cIntendedEncodingLength)
    : m_blob()
{
    // Precondition:
//     if (!RsaKey::IsValidModulusLength(cIntendedEncodingLength))
//         throw scu::OsException(ERROR_INTERNAL_ERROR);

    // Precondition: Message must be small enough to encode
    if (!IsMessageLengthValid(rMessage.length(), cIntendedEncodingLength))
        throw scu::OsException(ERROR_INTERNAL_ERROR);

    m_blob.reserve(cIntendedEncodingLength);

    // Ensure the encoded message when converted to an integer is
    // less than the modulus by leading with a separator
    m_blob += mSeparator;

    Marker const mBlockType = (ktOperation == RsaKey::ktPrivate) ?
        mPrivateBlockType : mPublicBlockType;
    m_blob += mBlockType;

    Blob::size_type cPadLength = PadLength(rMessage.length(),
                                           cIntendedEncodingLength);
    Pad(ktOperation, cPadLength);

    // Mark beginning of message
    m_blob += mSeparator;

    m_blob += rMessage;
}

EncodedMessage::~EncodedMessage()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
Blob
EncodedMessage::Value() const
{
    return m_blob;
}

                                                  // Predicates
bool
EncodedMessage::IsMessageLengthValid(Blob::size_type cMessageLength,
                                     Blob::size_type cIntendedEncodingLength)
{
    return PadLength(cMessageLength, cIntendedEncodingLength) >=
        cMinimumPadding;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

                                                  // Operators

                                                  // Operations

                                                  // Access

                                                  // Predicates

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
EncodedMessage::Pad(RsaKey::Type ktOperation,
                    Blob::size_type cRequiredPadLength)
{
    if (RsaKey::ktPrivate == ktOperation)
        m_blob.append(cRequiredPadLength, mPrivatePad);
    else // TO DO: Support random pad
        throw scu::OsException(NTE_FAIL);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\dialogbox.h ===
// DialogBox.h -- Dialog box helper declarations

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if !defined(SLBCSP_DIALOGBOX_H)
#define SLBCSP_DIALOGBOX_H

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

extern DWORD
InitDialogBox(CDialog *pCDlg,         // The dialog reference
              UINT nTemplate,         // identifies dialog box template
              CWnd *pWnd);            // pointer to parent window

#endif // !defined(SLBCSP_DIALOGBOX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\cspprofile.h ===
// CspProfile.h -- CSP Profile class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_PROFILE_H)
#define SLBCSP_PROFILE_H

#if _UNICODE
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include <memory>                                 // for auto_ptr
#include <string>
#include <vector>

namespace ProviderProfile
{

    class ATR
    {
    public:
        typedef unsigned char Length;
        enum Attribute
        {
            MaxLength = 33
        };

        explicit
        ATR();

        ATR(Length al, BYTE const abATR[], BYTE const abMask[]);

        BYTE const *String() const;
        BYTE const *Mask() const;
        ATR::Length ATRLength() const;
        size_t Size() const;

        ATR &operator=(ATR const &rhs);
        bool operator==(ATR const &rhs);
        bool operator!=(ATR const &rhs);

    private:
        typedef BYTE ATRString[MaxLength];

        Length m_al;
        ATRString m_atrstring;
        ATRString m_atrsMask;
    };

    class CardProfile
    {
    public:
        enum Attribute
        {
            attrNone = 0,

            // Card has the "Cryptoflex Most Significant Byte zero
            // private Key Defect."
            attrMsbKeyDefect = 0x01,
        };

        explicit
        CardProfile();

        CardProfile(ProviderProfile::ATR const &ratr,
                    std::string const &rsFriendlyName,
                    std::string const &rsRegistryName,
                    GUID const &rgPrimaryProvider,
                    Attribute attr = attrNone);

        CardProfile(ProviderProfile::ATR const &ratr,
                    CString const &rcsFriendlyName,
                    CString const &rcsRegistryName,
                    GUID const &rgPrimaryProvider,
                    Attribute attr = attrNone);

        ~CardProfile();

        ATR const &ATR() const;
        std::string FriendlyName() const;
        CString csFriendlyName() const;
        GUID const &PrimaryProvider() const;
        std::string RegistryName() const;
        CString csRegistryName() const;
        bool AtrMatches(ATR::Length cAtr,
                        BYTE const *pbAtr) const;
        bool HasAttribute(Attribute attr) const;

        bool operator==(CardProfile const &rhs);
        bool operator!=(CardProfile const &rhs);

    private:
        ProviderProfile::ATR m_atr;
        std::string m_sFriendlyName;
        std::string m_sRegistryName;
        CString m_csFriendlyName;
        CString m_csRegistryName;
        GUID m_gPrimaryProvider;
        Attribute m_attr;
    };

    struct VersionInfo
    {
        explicit
        VersionInfo()
            : m_dwMajor(0),
              m_dwMinor(0)
        {}

        DWORD m_dwMajor;
        DWORD m_dwMinor;
    };

    class CspProfile
    {
    public:
        HINSTANCE
        DllInstance() const;

        static CspProfile const &
        Instance();

        const CString
        Name() const;

        HINSTANCE
        Resources() const;

        DWORD
        Type() const;

        VersionInfo
        Version() const;

        std::vector<CardProfile> const &
        Cards() const;

        static void
        Release();

    private:
        // client can not directly create a Profile
        // object, use Instance to get the handle
        CspProfile(DWORD Type,
                   std::vector<CardProfile> const &rvcp);

        // not implemented, copy is not allowed
        CspProfile(CspProfile const &rhs);

        // client can not directly delete a profile, use Release to
        // delete one.
        ~CspProfile();

        // not implemented, assignment is not allowed
        CspProfile &
        operator=(CspProfile const &rProfile);

        HINSTANCE m_hDllInstance;
        DWORD const m_dwType;
        VersionInfo m_vi;
        std::vector<CardProfile> m_vcp;
        HINSTANCE m_hResInstance;
        std::auto_ptr<CDynLinkLibrary> m_apExtDll;

        static CspProfile *m_pInstance;
    };
}

#endif // SLBCSP_PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\dialogbox.cpp ===
// DialogBox.cpp -- DialogBox helper routines

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "stdafx.h"

#include "CspProfile.h"
#include "DialogBox.h"

using namespace std;
using namespace ProviderProfile;

DWORD
InitDialogBox(CDialog *pCDlg,         // The dialog reference
              UINT nTemplate,         // identifies dialog box template
              CWnd* pWnd)             // pointer to parent window
{

    HRSRC hrsrc = NULL;
    HGLOBAL hgbl = NULL;
    LPDLGTEMPLATE pDlg = NULL;
    DWORD dwReturn;
    hrsrc = FindResource(CspProfile::Instance().Resources(),
                         MAKEINTRESOURCE(nTemplate),
                         RT_DIALOG);
    if (NULL == hrsrc)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    hgbl = LoadResource(CspProfile::Instance().Resources(), hrsrc);
    if (NULL == hgbl)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    pDlg = (LPDLGTEMPLATE)LockResource(hgbl);
    if (NULL == pDlg)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pCDlg->InitModalIndirect(pDlg, pWnd);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\forcelib.h ===
// ForceLib.h -- Forces correct link order when mixing C Run-Time
// (CRT) and MFC libraries

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_FORCELIB_H)
#define SLBCSP_FORCELIB_H

// From MSDN Knowledge Base article ID: Q148652, when mixing the CRT
// and MFC, the linker may complain about symbols already defined in
// other CRT/MFC modules.  One fix is to always include Afx.h directly
// or indirectly through StdAfx.h but if the module doesn't use MFC,
// then this header file can be used to force the right link order.

// This head file was created from ..\MsDev\MFC\Include\Afx.h

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _AFXDLL
    #ifndef _UNICODE
        #ifdef _DEBUG
            #pragma comment(lib, "nafxcwd.lib")
        #else
            #pragma comment(lib, "nafxcw.lib")
        #endif
    #else
        #ifdef _DEBUG
            #pragma comment(lib, "uafxcwd.lib")
        #else
            #pragma comment(lib, "uafxcw.lib")
        #endif
    #endif
#else
    #ifndef _UNICODE
        #ifdef _DEBUG
            #pragma comment(lib, "mfc42d.lib")
            #pragma comment(lib, "mfcs42d.lib")
        #else
            #pragma comment(lib, "mfc42.lib")
            #pragma comment(lib, "mfcs42.lib")
        #endif
    #else
        #ifdef _DEBUG
            #pragma comment(lib, "mfc42ud.lib")
            #pragma comment(lib, "mfcs42ud.lib")
        #else
            #pragma comment(lib, "mfc42u.lib")
            #pragma comment(lib, "mfcs42u.lib")
        #endif
    #endif
#endif

#ifdef _DLL
    #if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
        #pragma comment(lib, "msvcrtd.lib")
    #else
        #pragma comment(lib, "msvcrt.lib")
    #endif
#else
#ifdef _MT
    #if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
        #pragma comment(lib, "libcmtd.lib")
    #else
        #pragma comment(lib, "libcmt.lib")
    #endif
#else
    #if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
        #pragma comment(lib, "libcd.lib")
    #else
        #pragma comment(lib, "libc.lib")
    #endif
#endif
#endif

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")

// force inclusion of NOLIB.OBJ for /disallowlib directives
#pragma comment(linker, "/include:__afxForceEXCLUDE")

// force inclusion of DLLMODUL.OBJ for _USRDLL
#ifdef _USRDLL
#pragma comment(linker, "/include:__afxForceUSRDLL")
#endif

// force inclusion of STDAFX.OBJ for precompiled types
#ifdef _AFXDLL
#pragma comment(linker, "/include:__afxForceSTDAFX")
#endif

#endif //!_AFX_NOFORCE_LIBS

#endif // !defined(SLBCSP_FORCELIB_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hadptvcntr.cpp ===
// HAdptvCntr.cpp -- Handle Card ConTeXt class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include "HAdptvCntr.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
HAdaptiveContainer::HAdaptiveContainer(AdaptiveContainer *pacntr)
    : slbRefCnt::RCPtr<AdaptiveContainer>(pacntr)
{}

HAdaptiveContainer::HAdaptiveContainer(AdaptiveContainerKey const &rKey)
    : slbRefCnt::RCPtr<AdaptiveContainer>(AdaptiveContainer::Instance(rKey))
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\exceptioncontext.cpp ===
// ExceptionContext.cpp -- ExceptionContext class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "ExceptionContext.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

ExceptionContext::ExceptionContext()
    : m_apexception(0)
{}

ExceptionContext::~ExceptionContext()
{}

                                                  // Operators
                                                  // Operations

void
ExceptionContext::Exception(std::auto_ptr<scu::Exception const> &rapexc)
{
    m_apexception = rapexc;
}

void
ExceptionContext::ClearException()
{
    m_apexception = std::auto_ptr<scu::Exception const>(0);
}

void
ExceptionContext::PropagateException()
{
    scu::Exception const *pexc = Exception();
    if (pexc)
        pexc->Raise();
}

void
ExceptionContext::PropagateException(std::auto_ptr<scu::Exception const> &rapexc)
{
    Exception(rapexc);
    PropagateException();
}


                                                  // Access

scu::Exception const *
ExceptionContext::Exception() const
{
    return m_apexception.get();
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\encodedmsg.h ===
// EncodedMsg.h -- Encoded Message class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ENCODEDMSG_H)
#define SLBCSP_ENCODEDMSG_H

#include "RsaKey.h"
#include "Blob.h"

class EncodedMessage
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    EncodedMessage(Blob const &rMessage,
                   RsaKey::Type ktOperation,
                   Blob::size_type cIntendedEncodingLength);
    ~EncodedMessage();


                                                  // Operators
                                                  // Operations
                                                  // Access
    Blob
    Value() const;

                                                  // Predicates
    static bool
    IsMessageLengthValid(Blob::size_type cMessageLength,
                         Blob::size_type cIntendedEncodingLength);

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
    void
    Pad(RsaKey::Type ktOperation,
        Blob::size_type cRequiredPadLength);

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    Blob m_blob;
};

#endif // SLBCSP_ENCODEDMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hadptvcntr.h ===
// HAdptvCntr.h -- Handle Card ConTeXt class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HADPTVCNTR_H)
#define SLBCSP_HADPTVCNTR_H

#include <string>
#include <stack>

#include <cciCont.h>

#include "slbRCPtr.h"
#include "Securable.h"
#include "CachingObj.h"
#include "ACntrReg.h"
#include "Secured.h"
#include "Container.h"

// Forward declaration necessary to satisfy HAdaptiveContainer's declaration
class AdaptiveContainer;

class HAdaptiveContainer
    : public slbRefCnt::RCPtr<AdaptiveContainer>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    HAdaptiveContainer(AdaptiveContainer *pacntr = 0);

    explicit
    HAdaptiveContainer(AdaptiveContainerKey const &rKey);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

// Adaptive Container is a reference counted wrapper to a CCI
// Container providing several features the CCI ignores.  The first is
// adapting to the CCI container that currently represents the
// physical container on the card.  This is necessary in case the
// cards state changed between transactions and card's contents
// changed.  If the container no longer exists, then an exception is
// thrown; otherwise the Adaptive Container references the (refreshed)
// CCI container reference.
//
// Second, one unique adaptive container is maintained for all threads since
// the CCI does not reflect changes made to one CContainer in all
// CContainer objects that refer to the same container.
//
// Third, an adaptive container cannot be created unless the container
// it represents is exists on the card.  When instantiating, the
// container is created if it doesn't exist.
//
// An adaptive container provides a Securable interface to lock
// transactions to the container (card) it represents.
class AdaptiveContainer
    : public Lockable,
      private Securable,
      public AdaptiveContainerRegistrar,
      public Container
{
public:
                                                  // Types
                                                  // Friends
    friend void
    Retained<HAdaptiveContainer>::DoAcquire();

    friend void
    Secured<HAdaptiveContainer>::DoAcquire();

    friend void
    Retained<HAdaptiveContainer>::DoRelease();

    friend void
    Secured<HAdaptiveContainer>::DoRelease();

    friend EnrolleeType
    AdaptiveContainerRegistrar::Instance(KeyType const &rkey);

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    ClearCache();

                                                  // Access
    cci::CContainer
    TheCContainer();

    HCardContext
    CardContext(bool Reconnect = true);

    static EnrolleeType
    Find(AdaptiveContainerKey const &rKey);

    std::string
    Name() const;

    void
    NullifyCard();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    AdaptiveContainer(AdaptiveContainerKey const &rKey);

    ~AdaptiveContainer();

                                                  // Operators
                                                  // Operations
	void
	ClearCardContext();

    void
    DiscardHook();

    static EnrolleeType
    DoInstantiation(AdaptiveContainerKey const &rKey);

    void
    EnrollHook();

                                                  // Access
                                                  // Predicates
    bool
    KeepEnrolled();

    void
    ReconnectOnError(scu::OsException const &rExc,
                     Retained<HCardContext> &rhcardctx);

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Abandon();

    void
    Expire();

    void
    RefreshContainer();

    void
    Relinquish();

    void
    Retain();

    void
    Secure();

                                                  // Access
                                                  // Predicates
                                                  // Variables

    // The card could be derived from the CCI container object but
    // since the CCI allows card objects to be reused, the card may
    // not be the container originally found.  The CardContext class
    // tries to mitigate that problem by storing an HCardContext in a
    // container's context object.
    HAdaptiveContainerKey m_hacKey;
    bool m_fValidContext;
    std::list<Retained<HCardContext> > m_stkRetainedCardContexts;
    std::list<Secured<HCardContext> > m_stkSecuredCardContexts;
};

#endif // SLBCSP_HADPTVCNTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\exceptioncontext.h ===
// ExceptionContext.h -- Exception Context class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work,
// created 2001. This computer program includes Confidential,
// Proprietary Information and is a Trade Secret of Schlumberger
// Technology Corp. All use, disclosure, and/or reproduction is
// prohibited unless authorized in writing.  All Rights Reserved.

#if !defined(SLBCSP_EXCEPTIONCONTEXT_H)
#define SLBCSP_EXCEPTIONCONTEXT_H

#include <memory>                                 // for auto_ptr

#include <scuOsExc.h>

///////////////////////////   HELPERS   /////////////////////////////////

// Macros to trap exceptions and set the exception context
// appropriately with an optionally throw.
#define EXCCTX_TRY                                                    \
    {                                                                 \
        try


#define EXCCTX_CATCH(pExcCtx, fDoThrow)                               \
        catch (scu::Exception const &rExc)                            \
        {                                                             \
            if (!pExcCtx->Exception())                                \
                pExcCtx->Exception(auto_ptr<scu::Exception const>(rExc.Clone())); \
        }                                                             \
                                                                      \
        catch (std::bad_alloc const &)                                \
        {                                                             \
            if (!pExcCtx->Exception())                                \
                pExcCtx->Exception(auto_ptr<scu::Exception const>(scu::OsException(NTE_NO_MEMORY).Clone())); \
        }                                                             \
                                                                      \
        catch (...)                                                   \
        {                                                             \
            if (!pExcCtx->Exception())                                \
                pExcCtx->Exception(auto_ptr<scu::Exception const>(scu::OsException(NTE_FAIL).Clone())); \
        }                                                             \
                                                                      \
        if (fDoThrow)                                                 \
            pExcCtx->PropagateException();                            \
    }


// Abstract base class mixin for derived classes that want to maintain
// an exception context.  Typically this is used in conjuction with
// calling conventional libraries that require a callback routine and
// that callback routine want to raise exceptions which shouldn't be
// thrown across the library.
class ExceptionContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    ExceptionContext();

    virtual
    ~ExceptionContext();
                                                  // Operators
                                                  // Operations

    void
    Exception(std::auto_ptr<scu::Exception const> &rapexc);

    void
    ClearException();

    void
    PropagateException();

    void
    PropagateException(std::auto_ptr<scu::Exception const> &rapExc);

                                                  // Access

    scu::Exception const *
    Exception() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    ExceptionContext(ExceptionContext const &rhs); // not defined, copying not allowed

                                                  // Operators
    ExceptionContext &
    operator=(ExceptionContext const &rhs); // not defined, assignment not allowed

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    std::auto_ptr<scu::Exception const> m_apexception;
};

#endif // SLBCSP_EXCEPTIONCONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\guard.h ===
// Guard.h -- Guard class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_GUARD_H)
#define SLBCSP_GUARD_H

#include "Lockable.h"

// Guard (manage) the locking and unlocking of a lockable object.
template<class T>
class Guard
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Guard(T &rLock)
        : m_rLock(rLock)
    {
        m_rLock.Lock();
    }

    ~Guard()
    {
        try
        {
            m_rLock.Unlock();
        }

        catch (...)
        {
            // do nothing, exceptions should not propagate out of
            // destructors
        }
    }


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    T &m_rLock;

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

template<>
class Guard<Lockable *>
    : public Guard<Lockable>
{
    Guard(Lockable *pLock)
        : Guard<Lockable>(*pLock)
    {};

    ~Guard()
    {};
};


#endif // SLBCSP_GUARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\guarded.h ===
// Guarded.h -- Guarded template class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_GUARDED_H)
#define SLBCSP_GUARDED_H

#include "RsrcCtrlr.h"

// Using the "resource acquisition is initialization" idiom, the
// Guarded template manages automatically acquiring and releasing the
// lock of a Lockable object (the resource).  Classes derived from
// Lockable may need to specialize this template's c'tor and d'tor
// rather than take the default.
template<class T>
class Guarded
    : public ResourceController<T>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Guarded(T const &rResource = T());

    Guarded(Guarded<T> const &rhs);

    virtual
    ~Guarded() throw();


                                                  // Operators
    Guarded<T> &
    operator=(T const &rhs);

                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Acquire();

    virtual void
    DoAfterAssignment();

    virtual void
    DoBeforeAssignment();

    void
    Release();

                                                  // Access
                                                  // Predicates
                                                  // Variables
private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    DoAcquire();

    void
    DoRelease();

                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool m_fIsGuarded;
};

/////////////////////////  TEMPLATE METHODS  //////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<class T>
Guarded<T>::Guarded(T const &rResource)
    : ResourceController<T>(rResource),
      m_fIsGuarded(false)
{
    Acquire();
}

template<class T>
Guarded<T>::Guarded(Guarded<T> const &rhs)
    : ResourceController<T>(rhs.m_Resource),
      m_fIsGuarded(false)
{
    Acquire();
}

template<class T>
Guarded<T>::~Guarded() throw()
{
    try
    {
        Release();
    }

    catch (...)
    {
        // don't allow exceptions to propagate out of destructors
    }
}

                                                  // Operators
template<class T>
Guarded<T> &
Guarded<T>::operator=(T const &rhs)
{
    ResourceController<T>::operator=(rhs);

    return *this;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Guarded<T>::Acquire()
{
    if (m_Resource && !m_fIsGuarded)
    {
        DoAcquire();
        m_fIsGuarded = true;
    }
}

template<class T>
void
Guarded<T>::DoAfterAssignment()
{
    ResourceController<T>::DoAfterAssignment();

    Acquire();
}

template<class T>
void
Guarded<T>::DoBeforeAssignment()
{
    Release();

    ResourceController<T>::DoBeforeAssignment();
}

template<class T>
void
Guarded<T>::Release()
{
    if (m_Resource && m_fIsGuarded)
    {
        DoRelease();
        m_fIsGuarded = false;
    }
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Guarded<T>::DoAcquire()
{
    m_Resource->Lock();
}

template<class T>
void
Guarded<T>::DoRelease()
{
    m_Resource->Unlock();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////    HELPERS    /////////////////////////////////

#endif // SLBCSP_GUARDED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd4.h ===
// HashMD4.h -- declaration of CHashMD4

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHMD4_H)
#define SLBCSP_HASHMD4_H

#include "HashCtx.h"

class CHashMD4
    : public CHashContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CHashMD4(CryptContext const &rcryptctx);

    ~CHashMD4() throw();

                                                  // Operators
                                                  // Operations

    std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserverd,
          DWORD dwFlags) const;


                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate the hash and its state
    CHashMD4(CHashMD4 const &rhs,
             DWORD const *pdwReserved,
             DWORD dwFlags);


                                                  // Operators
                                                  // Operations
                                                  // Access

    Blob
    EncodedAlgorithmOid();

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_HASHMD4_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd2.h ===
// HashMD2.h -- declaration of CHashMD2

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1988. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHMD2_H)
#define SLBCSP_HASHMD2_H

#include "HashCtx.h"

class CHashMD2
    : public CHashContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CHashMD2(CryptContext const &rcryptctx);

    ~CHashMD2() throw();

                                                  // Operators
                                                  // Operations

    std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserverd,
          DWORD dwFlags) const;

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate the hash and its state
    CHashMD2(CHashMD2 const &rhs,
             DWORD const *pdwReserved,
             DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access

    Blob
    EncodedAlgorithmOid();

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_HASHMD2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd5.cpp ===
// HashMD5.cpp -- definition of MD5Hash

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include "HashMD5.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashMD5::CHashMD5(CryptContext const &rcryptctx)
    : CHashContext(rcryptctx, CALG_MD5)
{}

CHashMD5::~CHashMD5() throw()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CHashContext>
CHashMD5::Clone(DWORD const *pdwReserved,
                DWORD dwFlags) const
{
    return auto_ptr<CHashContext>(new CHashMD5(*this, pdwReserved,
                                               dwFlags));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate the hash and its state
CHashMD5::CHashMD5(CHashMD5 const &rhs,
                   DWORD const *pdwReserved,
                   DWORD dwFlags)
    : CHashContext(rhs, pdwReserved, dwFlags)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access

Blob
CHashMD5::EncodedAlgorithmOid()
{
    // MD5 Algorithm Object IDentifier (OID) in ASN.1 format (little endian)
    static unsigned char const sMd5Oid[] =
    {
        '\x30', '\x20', '\x30', '\x0c', '\x06', '\x08',
        '\x2a', '\x86', '\x48', '\x86', '\xf7', '\x0d',
        '\x02', '\x05', '\x05', '\x00', '\x04', '\x10'
    };

    return Blob(sMd5Oid, sizeof sMd5Oid / sizeof *sMd5Oid);
}

                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd2.cpp ===
// HashMD2.cpp -- definition of CHashMD2

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include "HashMD2.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashMD2::CHashMD2(CryptContext const &rcryptctx)
    : CHashContext(rcryptctx, CALG_MD2)
{}

CHashMD2::~CHashMD2() throw()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CHashContext>
CHashMD2::Clone(DWORD const *pdwReserved,
                DWORD dwFlags) const
{
    return auto_ptr<CHashContext>(new CHashMD2(*this, pdwReserved,
                                               dwFlags));
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate the hash and its state
CHashMD2::CHashMD2(CHashMD2 const &rhs,
                   DWORD const *pdwReserved,
                   DWORD dwFlags)
    : CHashContext(rhs, pdwReserved, dwFlags)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access

Blob
CHashMD2::EncodedAlgorithmOid()
{
    // MD2 Algorithm Object IDentifier (OID) in ASN.1 format (little endian)
    static unsigned char const sMd2Oid[] =
    {
        '\x30', '\x20', '\x30', '\x0c', '\x06', '\x08',
        '\x2a', '\x86', '\x48', '\x86', '\xf7', '\x0d',
        '\x02', '\x02', '\x05', '\x00', '\x04', '\x10'
    };

    return Blob(sMd2Oid, sizeof sMd2Oid / sizeof *sMd2Oid);
}

                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd4.cpp ===
// HashMD4.cpp -- definition of CHashMD4

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include "HashMD4.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashMD4::CHashMD4(CryptContext const &rcryptctx)
    : CHashContext(rcryptctx, CALG_MD4)
{}

CHashMD4::~CHashMD4() throw()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CHashContext>
CHashMD4::Clone(DWORD const *pdwReserved,
                DWORD dwFlags) const
{
    return auto_ptr<CHashContext>(new CHashMD4(*this, pdwReserved,
                                               dwFlags));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate the hash and its state
CHashMD4::CHashMD4(CHashMD4 const &rhs,
                   DWORD const *pdwReserved,
                   DWORD dwFlags)
    : CHashContext(rhs, pdwReserved, dwFlags)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access

Blob
CHashMD4::EncodedAlgorithmOid()
{
    // MD4 Algorithm Object IDentifier (OID) in ASN.1 format (little endian)
    static unsigned char const sMd4Oid[] =
    {
        '\x30', '\x20', '\x30', '\x0c', '\x06', '\x08',
        '\x2a', '\x86', '\x48', '\x86', '\xf7', '\x0d',
        '\x02', '\x04', '\x05', '\x00', '\x04', '\x10'
    };

    return Blob(sMd4Oid, sizeof sMd4Oid / sizeof *sMd4Oid);
}

                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashctx.cpp ===
// HashCtx.cpp -- definition of CHashContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h" // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include <scuOsVersion.h>
#include <scuArrayP.h>

#include "HashCtx.h"
#include "HashMD2.h"
#include "HashMD4.h"
#include "HashMD5.h"
#include "HashSHA1.h"
#include "HashSHAMD5.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashContext::~CHashContext() throw()
{
    try
    {
        Close();
    }

    catch (...)
    {
    }
}

                                                  // Operators
                                                  // Operations

void
CHashContext::Close()
{
    if (m_HashHandle)
    {
        if (!CryptDestroyHash(m_HashHandle))
            throw scu::OsException(GetLastError());
        m_HashHandle = NULL;
    }
}

void
CHashContext::ExportFromAuxCSP()
{
    if (!m_HashHandle)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    if (m_fJustCreated)
    {
        DWORD dwNeedLen;
        DWORD dwDataLen = sizeof DWORD;
        if (!CryptGetHashParam(m_HashHandle, HP_HASHSIZE,
                               reinterpret_cast<BYTE *>(&dwNeedLen),
                               &dwDataLen, 0))
            throw scu::OsException(GetLastError());


        AutoArrayPtr<BYTE> apbHashValue(new BYTE[dwNeedLen]);
        if (!CryptGetHashParam(m_HashHandle, HP_HASHVAL,
                               apbHashValue.Get(), &dwNeedLen, 0))
            throw scu::OsException(GetLastError());

        Value(Blob(apbHashValue.Get(), dwNeedLen));
    }
}

void CHashContext::Hash(BYTE const *pbData,
                        DWORD dwLength)
{
    HCRYPTHASH hch = HashHandleInAuxCSP();

    if (!CryptHashData(hch, pbData, dwLength, 0))
        throw scu::OsException(GetLastError());

    m_fJustCreated = false;

}

void
CHashContext::ImportToAuxCSP()
{
    if (!m_HashHandle)
    {
        if (!CryptCreateHash(m_rcryptctx.AuxContext(),
                             m_algid, 0, 0, &m_HashHandle))
            throw scu::OsException(GetLastError());
    }

    if (!m_fJustCreated && !m_fDone)
    {
        if (!CryptSetHashParam(m_HashHandle, HP_HASHVAL,
                               const_cast<Blob::value_type *>(Value().data()),
                               0))
            throw scu::OsException(GetLastError());
    }
}

void
CHashContext::Initialize()
{
    m_fDone = false;
}

auto_ptr<CHashContext>
CHashContext::Make(ALG_ID algid,
                   CryptContext const &rcryptctx)
{
    auto_ptr<CHashContext> apHash;

    switch (algid)
    {
    case CALG_MD2:
        apHash = auto_ptr<CHashContext>(new CHashMD2(rcryptctx));
        break;

    case CALG_MD4:
        apHash = auto_ptr<CHashContext>(new CHashMD4(rcryptctx));
        break;

    case CALG_MD5:
        apHash = auto_ptr<CHashContext>(new CHashMD5(rcryptctx));
        break;

    case CALG_SHA:
        apHash = auto_ptr<CHashContext>(new CHashSHA1(rcryptctx));
        break;

    case CALG_SSL3_SHAMD5:
        apHash = auto_ptr<CHashContext>(new CHashSHAMD5(rcryptctx));
        break;

    default:
        throw scu::OsException(NTE_BAD_ALGID);
        break;
    }

    return apHash;
}


void
CHashContext::Value(Blob const &rhs)
{
    if (!m_fJustCreated)
        throw scu::OsException(NTE_PERM);

    m_blbValue = rhs;

    m_fJustCreated = false;
    m_fDone = true;
}


                                                  // Access

ALG_ID
CHashContext::AlgId()
{
    return m_algid;
}

Blob
CHashContext::EncodedValue()
{
    return EncodedAlgorithmOid() + Value();
}

HCRYPTHASH
CHashContext::HashHandleInAuxCSP()
{
    ImportToAuxCSP();
    return m_HashHandle;
}

CHashContext::SizeType
CHashContext::Length() const
{
    SizeType cHashLength;

    if (!m_fDone)
    {
        DWORD dwData;
        DWORD dwDataLength = sizeof dwData;
        if (!CryptGetHashParam(m_HashHandle, HP_HASHSIZE,
                               reinterpret_cast<BYTE *>(&dwData),
                               &dwDataLength, 0))
            throw scu::OsException(GetLastError());
        cHashLength = dwData;
    }
    else
        cHashLength = m_blbValue.length();

    return cHashLength;
}

Blob
CHashContext::Value()
{
    if (!m_fDone)
        ExportFromAuxCSP();

    return m_blbValue;
}

                                                  // Predicates

bool
CHashContext::IsSupported(ALG_ID algid)
{
    bool IsSupported = true;

    switch (algid)
    {
    case CALG_MD2:
    case CALG_MD4:
    case CALG_MD5:
    case CALG_SHA:
    case CALG_SSL3_SHAMD5:
        break;
        
    default:
        IsSupported = false;
        break;
    }

    return IsSupported;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

CHashContext::CHashContext(CryptContext const &rcryptctx,
                           ALG_ID algid)
    : CHandle(),
      m_rcryptctx(rcryptctx),
      m_algid(algid),
      m_blbValue(),
      m_fDone(false),
      m_fJustCreated(true),
      m_HashHandle(NULL)
{}

// Duplicate the hash and its state
CHashContext::CHashContext(CHashContext const &rhs,
                           DWORD const *pdwReserved,
                           DWORD dwFlags)
    : CHandle(),
      m_rcryptctx(rhs.m_rcryptctx),
      m_algid(rhs.m_algid),
      m_blbValue(rhs.m_blbValue),
      m_fDone(rhs.m_fDone),
      m_fJustCreated(rhs.m_fJustCreated)
{

#if defined(SLB_WIN2K_BUILD)
    if (!CryptDuplicateHash(HashHandleInAuxCSP(),
                            const_cast<DWORD *>(pdwReserved),
                            dwFlags,
                            &m_HashHandle))
        throw scu::OsException(GetLastError());
#else
    throw scu::OsException(ERROR_NOT_SUPPORTED);
#endif

}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashctx.h ===
// HashCtx.h -- declaration of CHashContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHCTX_H)
#define SLBCSP_HASHCTX_H

#include <memory>                                 // for auto_ptr

#include <wincrypt.h>

#include <handles.h>

#include "Blob.h"
#include "CryptCtx.h"

class CHashContext
    : public CHandle
{
public:
                                                  // Types

    typedef DWORD SizeType;
    typedef BYTE ValueType;

                                                  // C'tors/D'tors
    virtual
    ~CHashContext() throw();


                                                  // Operators
                                                  // Operations

    virtual std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserved,
          DWORD dwFlags) const = 0;

    void
    Close();

        void
    ExportFromAuxCSP();

    void
    Hash(BYTE const *pbData,
         DWORD dwLength);

    HCRYPTHASH
    HashHandleInAuxCSP();

    void
    ImportToAuxCSP();

    void
    Initialize();

    static std::auto_ptr<CHashContext>
    Make(ALG_ID algid,
         CryptContext const &rcryptctx);
    
    void
    Value(Blob const &rhs);
                                                  // Access

    ALG_ID
    AlgId();

    Blob
    EncodedValue();

    SizeType
    Length() const;

    Blob
    Value();

                                                  // Predicates

    static bool
    IsSupported(ALG_ID algid);
    

protected:
                                                  // Types
                                                  // C'tors/D'tors

    CHashContext(CryptContext const &rcryptctx,
                 ALG_ID algid);

    // Duplicate the hash and its state
    CHashContext(CHashContext const &rhs,
                 DWORD const *pdwReserved,
                 DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access

    virtual Blob
    EncodedAlgorithmOid() = 0;

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors

    // not defined, copying not allowed...use Clone
    CHashContext(CHashContext const &rhs);

                                                  // Operators

    // not defined, initialization not allowed
    CHashContext &
    operator==(CHashContext const &rhs);

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    CryptContext const &m_rcryptctx;
        ALG_ID const m_algid;
    Blob m_blbValue;
    bool m_fDone;
    bool m_fJustCreated;
    HCRYPTHASH m_HashHandle;

};

#endif // SLBCSP_HASHCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashmd5.h ===
// HashMD5.h -- declaration of CHashMD5

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHMD5_H)
#define SLBCSP_HASHMD5_H

#include "HashCtx.h"

class CHashMD5
    : public CHashContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CHashMD5(CryptContext const &rcryptctx);

    ~CHashMD5() throw();

                                                  // Operators
                                                  // Operations

    std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserverd,
          DWORD dwFlags) const;


                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate the hash and its state
    CHashMD5(CHashMD5 const &rhs,
             DWORD const *pdwReserved,
             DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access

    Blob
    EncodedAlgorithmOid();

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_HASHMD5_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hcardctx.cpp ===
// HCardCtx.cpp -- Handle Card ConTeXt class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include "HCardCtx.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
HCardContext::HCardContext(CardContext *pcardctx)
    : slbRefCnt::RCPtr<CardContext>(pcardctx)
{}

HCardContext::HCardContext(std::string const &rsReaderName)
    : slbRefCnt::RCPtr<CardContext>(CardContext::Instance(rsReaderName))
{}
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashsha1.cpp ===
// HashSHA1.cpp -- definition of CHashSHA1

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include "HashSHA1.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashSHA1::CHashSHA1(CryptContext const &rcryptctx)
    : CHashContext(rcryptctx, CALG_SHA)
{}

CHashSHA1::~CHashSHA1() throw()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CHashContext>
CHashSHA1::Clone(DWORD const *pdwReserved,
                 DWORD dwFlags) const
{
    return auto_ptr<CHashContext>(new CHashSHA1(*this, pdwReserved,
                                                dwFlags));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate the hash and its state
CHashSHA1::CHashSHA1(CHashSHA1 const &rhs,
                     DWORD const *pdwReserved,
                     DWORD dwFlags)
    : CHashContext(rhs, pdwReserved, dwFlags)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access

Blob
CHashSHA1::EncodedAlgorithmOid()
{
    // SHA1 Algorithm Object IDentifier (OID) in ASN.1 format (little endian)
    static unsigned char const sSha1AlgOid[] =
    {
        '\x30', '\x21', '\x30', '\x09', '\x06',
        '\x05', '\x2b', '\x0e', '\x03', '\x02',
        '\x1a', '\x05', '\x00', '\x04', '\x14'
    };

    return Blob(sSha1AlgOid, sizeof sSha1AlgOid / sizeof *sSha1AlgOid);
}


                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashshamd5.h ===
// HashSHAMD5.h -- declaration of CHashSHAMD5

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1988. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHSHAMD5_H)
#define SLBCSP_HASHSHAMD5_H

#include "HashCtx.h"

class CHashSHAMD5
    : public CHashContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CHashSHAMD5(CryptContext const &rcryptctx);

    ~CHashSHAMD5() throw();

                                                  // Operators
                                                  // Operations

    std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserverd,
          DWORD dwFlags) const;

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    // Duplicate the hash and its state
    CHashSHAMD5(CHashSHAMD5 const &rhs,
                DWORD const *pdwReserved,
                DWORD dwFlags);

                                                  // Access

    Blob
    EncodedAlgorithmOid();

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_HASHSHAMD5_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hcardctx.h ===
// HCardCtx.h -- Handle Card ConTeXt class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HCARDCTX_H)
#define SLBCSP_HCARDCTX_H

#include <string>
#include <memory>
#include <stack>

#include <TransactionWrap.h>
#include <cciCard.h>

#include "slbRCPtr.h"
#include "Lockable.h"
#include "Securable.h"
#include "CachingObj.h"
#include "CardCtxReg.h"
#include "LoginId.h"
#include "Secured.h"

// Forward declaration required to satisfy HCardContext's declaration
class CardContext;

class HCardContext
    : public slbRefCnt::RCPtr<CardContext>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    HCardContext(CardContext *pcardctx = 0);

    explicit
    HCardContext(std::string const &rsReaderName);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

// Forward declarations required to break circular dependency of
// LoginContext and LoginTask class declarations on HCardContext.
class LoginContext;
class LoginTask;

// Maintains aspects of the card context that the CCI ignores.
class CardContext
    : public slbRefCnt::RCObject,
      public Lockable,
      private Securable,
      private CachingObject,
      public CardContextRegistrar
{
public:
                                                  // Types
                                                  // Friends
    friend void
    Retained<HCardContext>::DoAcquire();

    friend void
    Secured<HCardContext>::DoAcquire();

    friend void
    Retained<HCardContext>::DoRelease();

    friend void
    Secured<HCardContext>::DoRelease();

    friend EnrolleeType
    CardContextRegistrar::Instance(KeyType const &rkey);

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    ClearLogin(LoginIdentity const &rlid);

    void
    Login(LoginIdentity const &rlid,
          LoginTask &rlt,
          bool fForceLogin = false);

    void
    Logout();

                                                  // Access
    cci::CCard
    Card();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    CardContext(std::string const &rsReaderName);

    ~CardContext() throw();
                                                  // Operators
                                                  // Operations
    void
    DiscardHook();

    static EnrolleeType
    DoInstantiation(std::string const &rsReaderName);

    void
    EnrollHook();


                                                  // Access
                                                  // Predicates
    bool
    KeepEnrolled();

                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Abandon();

    void
    ClearCache();

    void
    DeleteCache();

    void
    Relinquish();

    void
    Retain();

    void
    UpdateMarkers();

    void
    Secure();
// NEVER use auto_ptr in STL containers! See Windows bug 647396. Owner (dangriff) notified
// Once fixed, back out my change in sources, where I disable the warnings
//
                                                  // Access
                                                  // Predicates
                                                  // Variables
    std::list<std::auto_ptr<Guarded<CardContext *> > > m_stkapGuards;
    std::auto_ptr<cci::CTransactionWrap> m_aptwCard;

    // count of active securers to the card.  Declared LONG for
    // compatibility with Windows interlocking routines.
    LONG m_cSecurers;

    cci::CCard m_card;
    std::map<LoginIdentity, std::auto_ptr<LoginContext> > m_mloginctx;
    scu::Marker<unsigned int> m_nMrkLastWrite;
};

#endif // SLBCSP_HCARDCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashsha1.h ===
// HashSHA1.h -- declaration of CHashSHA1

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1988. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HASHSHA1_H)
#define SLBCSP_HASHSHA1_H

#include "HashCtx.h"

class CHashSHA1
    : public CHashContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CHashSHA1(CryptContext const &rcryptctx);

    ~CHashSHA1() throw();

                                                  // Operators
                                                  // Operations

    std::auto_ptr<CHashContext>
    Clone(DWORD const *pdwReserverd,
          DWORD dwFlags) const;


                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate the hash and its state
    CHashSHA1(CHashSHA1 const &rhs,
              DWORD const *pdwReserved,
              DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access

    Blob
    EncodedAlgorithmOid();

                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

#endif // SLBCSP_HASHSHA1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hashshamd5.cpp ===
// HashSHAMD5.cpp -- definition of CHashSHAMD5

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <memory>                                 // for auto_ptr

#include "HashSHAMD5.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CHashSHAMD5::CHashSHAMD5(CryptContext const  &rcryptctx)
    : CHashContext(rcryptctx, CALG_SSL3_SHAMD5)
{}

CHashSHAMD5::~CHashSHAMD5() throw()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CHashContext>
CHashSHAMD5::Clone(DWORD const *pdwReserved,
                   DWORD dwFlags) const
{
    return auto_ptr<CHashContext>(new CHashSHAMD5(*this, pdwReserved,
                                                  dwFlags));
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate the hash and its state
CHashSHAMD5::CHashSHAMD5(CHashSHAMD5 const &rhs,
                         DWORD const *pdwReserved,
                         DWORD dwFlags)
    : CHashContext(rhs, pdwReserved, dwFlags)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access

Blob
CHashSHAMD5::EncodedAlgorithmOid()
{
    return Blob();                                // No OID for this hash
}

                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hscardctx.cpp ===
// HSCardCtx.cpp -- Handle Smart Card Context wrapper class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <scuOsExc.h>

#include "HSCardCtx.h"

///////////////////////////    HELPER     /////////////////////////////////

///////////////////////////  LOCAL VAR    /////////////////////////////////

namespace
{
    SCARDCONTEXT const sccNil = 0;
} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
HSCardContext::HSCardContext()
    : m_scc(sccNil)
{
}

HSCardContext::~HSCardContext()
{
    if (m_scc)
    {
        try
        {
            Release();
        }

        catch (...) // destructors should not throw exceptions
        {
        }
    }
}

                                                  // Operators
                                                  // Operations
void
HSCardContext::Establish(DWORD dwScope)
{
    DWORD dwErrorCode = SCardEstablishContext(dwScope, NULL, NULL,
                                              &m_scc);
    if (SCARD_S_SUCCESS != dwErrorCode)
        throw scu::OsException(dwErrorCode);
}

void
HSCardContext::Release()
{
    if (m_scc)
    {
        SCARDCONTEXT old = m_scc;

        m_scc = sccNil;

        DWORD dwErrorCode = SCardReleaseContext(old);
        if (SCARD_S_SUCCESS != dwErrorCode)
            throw scu::OsException(dwErrorCode);
    }
}
                                                  // Access
SCARDCONTEXT
HSCardContext::AsSCARDCONTEXT() const
{
    return m_scc;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\hscardctx.h ===
// HSCardCtx.h -- Handle Smart Card Context wrapper class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_HSCARDCTX_H)
#define SLBCSP_HSCARDCTX_H

#include <winscard.h>

// HSCardContext is a convenience wrapper class to manage the Resource
// Manager's SCARDCONTEXT resource.
class HSCardContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    HSCardContext();

    ~HSCardContext();
                                                  // Operators
                                                  // Operations
    void Establish(DWORD dwScope = SCARD_SCOPE_USER);
    void Release();

                                                  // Access
    SCARDCONTEXT
    AsSCARDCONTEXT() const;
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    SCARDCONTEXT m_scc;
};

#endif // SLBCSP_HSCARDCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\keylimits.h ===
// KeyLimits.h -- Key Limits template class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_KEYLIMITS_H)
#define SLBCSP_KEYLIMITS_H

template<class T>
class KeyLimits
{
public:
                                                  // Types

    // The following are defined as enums since VC++ 6.0 does
    // not support initialization of constant declarations.
    enum
    {
        cMinStrength = 0,
        cMaxStrength = 0,
    };
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};
#endif // SLBCSP_KEYLIMITS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\ilogintask.cpp ===
// ILoginTask.cpp -- Interactive Login Task helper class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "stdafx.h"

#include <scuOsExc.h>
#include <iopPriBlob.h>
#include "PromptUser.h"
#include "PswdDlg.h"
#include "ILoginTask.h"
#include "Blob.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
InteractiveLoginTask::InteractiveLoginTask(HWND const &rhwnd)
    : m_hwnd(rhwnd)
{}

InteractiveLoginTask::~InteractiveLoginTask()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
InteractiveLoginTask::GetNewPin(Capsule &rcapsule)
{
    CChangePINDlg ChgPinDlg(CWnd::FromHandle(m_hwnd));
#ifdef ISOLATION_AWARE_ENABLED
    CThemeContextActivator activator;
#endif

    DWORD dwStatus = ChgPinDlg.InitDlg();
    if (ERROR_SUCCESS != dwStatus)
        throw scu::OsException(dwStatus);
    
    SecureArray<BYTE> saBuffer(rcapsule.m_rat.Pin());
    saBuffer.append(1,0);
    ChgPinDlg.m_csOldPIN = saBuffer.data();
    INT_PTR ipResult = ChgPinDlg.DoModal();
    AfxGetApp()->DoWaitCursor(0);
    switch (ipResult)
    {
    case IDCANCEL:
        throw scu::OsException(ERROR_CANCELLED);
        break;

    case IDABORT:
        throw scu::OsException(NTE_FAIL);
        break;

    case -1:
        throw scu::OsException(ERROR_NOT_ENOUGH_MEMORY);
        break;

    default:
        ; // fall through
    };
    SecureArray<char> sTemp(StringResource::CheckAsciiFromUnicode((LPCTSTR)ChgPinDlg.m_csNewPIN));
    rcapsule.m_rat.Pin(sTemp.data());
}

void
InteractiveLoginTask::GetPin(Capsule &rcapsule)
{
    if (!rcapsule.m_rat.PinIsCached())
    {
        CPasswordDlg PswdDlg(CWnd::FromHandle(m_hwnd));

#ifdef ISOLATION_AWARE_ENABLED
        CThemeContextActivator activator;
#endif

        DWORD dwStatus = PswdDlg.InitDlg();
        if (ERROR_SUCCESS != dwStatus)
            throw scu::OsException(dwStatus);

        // Tell the password dialog the login ID, so it will
        // enable the controls and prompt appropriately.
        PswdDlg.m_lid = rcapsule.m_rat.Identity();

        INT_PTR ipResult = PswdDlg.DoModal();
        AfxGetApp()->DoWaitCursor(0);
        switch (ipResult)
        {
        case IDCANCEL:
            throw scu::OsException(ERROR_CANCELLED);
            break;

        case IDABORT:
            throw scu::OsException(NTE_FAIL);
            break;

        case -1:
            throw scu::OsException(ERROR_NOT_ENOUGH_MEMORY);
            break;

        default:
            ; // fall through
        };
        SecureArray<char> sPin(StringResource::CheckAsciiFromUnicode((LPCTSTR)PswdDlg.m_szPassword));
        rcapsule.m_rat.Pin(sPin.data(), 0 != PswdDlg.m_fHexCode);

        RequestedToChangePin(0 != PswdDlg.m_bChangePIN);
    }
}

void
InteractiveLoginTask::OnChangePinError(Capsule &rcapsule)
{
    int iResponse = PromptUser(m_hwnd, IDS_PIN_CHANGE_FAILED,
                               MB_RETRYCANCEL | MB_ICONSTOP);

    if (IDCANCEL == iResponse)
        throw scu::OsException(ERROR_CANCELLED);
}

void
InteractiveLoginTask::OnSetPinError(Capsule &rcapsule)
{
    scu::Exception const *exc = rcapsule.Exception();
    if (scu::Exception::fcSmartCard == exc->Facility())
    {
        iop::CSmartCard::Exception const &rScExc =
            *(static_cast<iop::CSmartCard::Exception const *>(exc));

        iop::CSmartCard::CauseCode cc = rScExc.Cause();
        if ((iop::CSmartCard::ccChvVerificationFailedMoreAttempts == cc) ||
            (iop::CSmartCard::ccKeyBlocked == cc))
        {
            bool fBadPin =
                (iop::CSmartCard::ccChvVerificationFailedMoreAttempts == cc);

            UINT uiId;
            UINT uiButtons;
            if (fBadPin)
            {
                uiId      = IDS_BAD_PIN_ENTERED;
                uiButtons = MB_RETRYCANCEL;
            }
            else
            {
                uiId      = IDS_PIN_BLOCKED;
                uiButtons = MB_OK;
            }

            int iResponse = PromptUser(m_hwnd, uiId,
                                       uiButtons | MB_ICONSTOP);

            if (fBadPin)
            {
                if (IDCANCEL == iResponse)
                    throw scu::OsException(ERROR_CANCELLED);
                else
                    rcapsule.m_rat.FlushPin();
            }
            else
                throw rScExc;
        }
    }
    else
        rcapsule.PropagateException();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\keycontext.h ===
// KeyContext.h -- Key Context class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_KEYCONTEXT_H)
#define SLBCSP_KEYCONTEXT_H

#include <memory>                                 // for auto_ptr

#include <wincrypt.h>
#include <winscard.h>
#include <handles.h>

#include <iopPriBlob.h>
#include "AlignedBlob.h"
#include "RsaKey.h"


#define KT_UNDEFINED    static_cast<DWORD>(0x00000000)
#define KT_PUBLICKEY    static_cast<DWORD>(PUBLICKEYBLOB)
#define KT_SESSIONKEY   static_cast<DWORD>(SIMPLEBLOB)


class CKeyContext
    : public CHandle
{
public:
                                                  // Types

    typedef RsaKey::StrengthType StrengthType;

    enum
    {
        Symmetric,
        RsaKeyPair
    } KeyClass;

                                                  // C'tors/D'tors

    virtual
    ~CKeyContext();

                                                  // Operators
                                                  // Operations

    virtual std::auto_ptr<CKeyContext>
    Clone(DWORD const *pdwReserved,
          DWORD dwFlags) const = 0;

    virtual void
    Close();

    virtual void
    Decrypt(HCRYPTHASH hAuxHash,
            BOOL fFinal,
            DWORD dwFlags,
            BYTE *pbData,
            DWORD *pdwDataLen);

    virtual void
    Encrypt(HCRYPTHASH hAuxHash,
            BOOL fFinal,
            DWORD dwFlags,
            BYTE *pbData,
            DWORD *pdwDataLen,
            DWORD dwBufLen);

    virtual void
    Generate(ALG_ID AlgoId,
             DWORD dwFlags) = 0;

    virtual void
    ImportToAuxCSP() = 0;

                                                  // Access

    virtual scu::SecureArray<BYTE>
    AsAlignedBlob(HCRYPTKEY hcryptkey,
                  DWORD dwBlobType) const = 0;

    HCRYPTKEY
    GetKey() const;

    virtual HCRYPTKEY
    KeyHandleInAuxCSP();

    virtual StrengthType
    MaxStrength() const = 0;

    virtual StrengthType
    MinStrength() const = 0;

    virtual DWORD
    TypeOfKey() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    CKeyContext(HCRYPTPROV hProv,
                DWORD dwTypeOfKey = KT_UNDEFINED);

    // Duplicate the key and its state
    CKeyContext(CKeyContext const &rhs,
                DWORD const *pdwReserved,
                DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access

    HCRYPTPROV
    AuxProvider() const;

                                                  // Predicates
                                                  // Variables
    HCRYPTKEY m_hKey;
    scu::SecureArray<BYTE> m_apabKey;

private:
                                                  // Types
                                                  // C'tors/D'tors

    // not defined, copying not allowed
    CKeyContext(CKeyContext const &rkctx);

                                                  // Operators

    // not defined, initializing not allowed
    CKeyContext &
    operator=(CKeyContext const &rkctx);

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    DWORD const m_dwTypeOfKey;
    HCRYPTPROV const m_hAuxProvider;

};

#endif // SLBCSP_KEYCONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\lockable.h ===
// Lockable.h -- Lockable class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_LOCKABLE_H)
#define SLBCSP_LOCKABLE_H

#include <windows.h>

// Abstract base class mixin for use by derived classes that must
// maintain a lock (using a critical section).
class Lockable
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    Lockable();

    virtual
    ~Lockable();
                                                  // Operators
                                                  // Operations
    virtual void
    Lock();

    virtual void
    Unlock();

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    Lockable(Lockable const &rhs); // not defined, copying not allowed

                                                  // Operators
    Lockable &
    operator=(Lockable const &rhs); // not defined, assignment not allowed

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    CRITICAL_SECTION m_CriticalSection;
};

#endif // SLBCSP_LOCKABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\ilogintask.h ===
// ILoginTask.h -- Interactive Login Task help class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_ILOGINTASK_H)
#define SLBCSP_ILOGINTASK_H

#if _UNICODE
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "LoginTask.h"

class InteractiveLoginTask
    : public LoginTask
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    InteractiveLoginTask(HWND const &rhwnd);

    virtual
    ~InteractiveLoginTask();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    GetNewPin(Capsule &rcapsule);

    virtual void
    GetPin(Capsule &rcapsule);

    virtual void
    OnChangePinError(Capsule &rcapsule);

    virtual void
    OnSetPinError(Capsule &rcapsule);

                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    HWND m_hwnd;

};

#endif // SLBCSP_ILOGINTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\lockable.cpp ===
// Lockable.cpp -- Lockable class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <windows.h>
#include <winbase.h>

#include "Lockable.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
Lockable::Lockable()
{
    InitializeCriticalSection(&m_CriticalSection);
}

Lockable::~Lockable()
{
    DeleteCriticalSection(&m_CriticalSection);
}



                                                  // Operators
                                                  // Operations
void
Lockable::Lock()
{
    EnterCriticalSection(&m_CriticalSection);
}

void
Lockable::Unlock()
{
    LeaveCriticalSection(&m_CriticalSection);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\loginctx.cpp ===
// LoginCtx.cpp -- Login Context class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <algorithm>

#include "LoginCtx.h"
#include "LoginTask.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
LoginContext::LoginContext(HCardContext const &rhcardctx,
                           LoginIdentity const &rlid)
    : m_fIsActive(false),
      m_at(rhcardctx, rlid)
{}

LoginContext::~LoginContext()
{}

                                                  // Operators
                                                  // Operations
void
LoginContext::Activate(LoginTask &rlt)
{
    m_fIsActive = false;

    rlt(m_at);

    m_fIsActive = true;
}

void
LoginContext::Deactivate()
{
    if (m_fIsActive)
    {
        m_fIsActive = false;
        m_at.CardContext()->Card()->Logout();
    }
}

void
LoginContext::Nullify()
{
    try
    {
        m_at.FlushPin();
    }
    catch(...)
    {
    }
    
    Deactivate();
}

                                                  // Access
                                                  // Predicates
bool
LoginContext::IsActive() const
{
    return m_fIsActive;
}

                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\keycontext.cpp ===
// KeyContext.cpp -- CKeyContext class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // because handles.h uses the ASSERT macro

#include <scuOsExc.h>
#include <scuOsVersion.h>

#include "KeyContext.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CKeyContext::~CKeyContext()
{
    Close();
}


                                                  // Operators
                                                  // Operations
void
CKeyContext::Close()
{
    if (m_hKey)
    {
        CryptDestroyKey(m_hKey);
        m_hKey = NULL;
    }
}

void
CKeyContext::Decrypt(HCRYPTHASH hAuxHash,
                     BOOL fFinal,
                     DWORD dwFlags,
                     BYTE *pbData,
                     DWORD *pdwDataLen)
{
    ImportToAuxCSP();

    if (!CryptDecrypt(GetKey(), hAuxHash, fFinal, dwFlags,
                      pbData, pdwDataLen))
        throw scu::OsException(GetLastError());
}

void
CKeyContext::Encrypt(HCRYPTHASH hAuxHash,
                     BOOL fFinal,
                     DWORD dwFlags,
                     BYTE *pbData,
                     DWORD *pdwDataLen,
                     DWORD dwBufLen)
{
    ImportToAuxCSP();

    if (!CryptEncrypt(GetKey(), hAuxHash, fFinal, dwFlags, pbData,
                      pdwDataLen, dwBufLen))
        throw scu::OsException(GetLastError());
}

                                                  // Access

HCRYPTKEY
CKeyContext::GetKey() const
{
    return m_hKey;
}

HCRYPTKEY
CKeyContext::KeyHandleInAuxCSP()
{
    ImportToAuxCSP();
    return m_hKey;
}

DWORD
CKeyContext::TypeOfKey() const
{
    return m_dwTypeOfKey;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

CKeyContext::CKeyContext(HCRYPTPROV hProv,
                         DWORD dwTypeOfKey)
    : CHandle(),
      m_hKey(NULL),
      m_apabKey(),
      m_dwTypeOfKey(dwTypeOfKey),
      m_hAuxProvider(hProv)
{}

// Duplicate the key and its state
CKeyContext::CKeyContext(CKeyContext const &rhs,
                         DWORD const *pdwReserved,
                         DWORD dwFlags)
    : CHandle(),
      m_hKey(rhs.m_hKey),
      m_apabKey(rhs.m_apabKey),
      m_dwTypeOfKey(rhs.m_dwTypeOfKey),
      m_hAuxProvider(rhs.m_hAuxProvider)
{

#if defined(SLB_WIN2K_BUILD)
    if (!CryptDuplicateKey(KeyHandleInAuxCSP(),
                           const_cast<DWORD *>(pdwReserved),
                           dwFlags,
                           &m_hKey))
        throw scu::OsException(GetLastError());
#else
    throw scu::OsException(ERROR_NOT_SUPPORTED);
#endif

}

                                                  // Operators
                                                  // Operations
                                                  // Access

HCRYPTPROV
CKeyContext::AuxProvider() const
{
    return m_hAuxProvider;
}



                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\loginid.h ===
// LoginId.h -- Login Identity definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_LOGINID_H)
#define SLBCSP_LOGINID_H

enum LoginIdentity
{
    User,
    Administrator,
    Manufacturer
};

#endif // SLBCSP_LOGINID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\loginctx.h ===
// LoginCtx.h -- Login ConTeXt class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_LOGINCTX_H)
#define SLBCSP_LOGINCTX_H

#include <map>

#include "HCardCtx.h"
#include "AccessTok.h"
#include "LoginTask.h"

// Encapsulates the login context of a card.  These attributes would
// be better handled as attributes of the CCI's card class itself.
class LoginContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    LoginContext(HCardContext const &rcardctx,
                 LoginIdentity const &rlid);

    ~LoginContext();

                                                  // Operators
                                                  // Operations
    void
    Activate(LoginTask &rlt);

    void
    Deactivate();

    void
    Nullify();

                                                  // Access
    bool
    IsActive() const;

                                                  // Predicates


protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    bool m_fIsActive;
    AccessToken m_at;
};

#endif // SLBCSP_LOGINCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\masterlock.h ===
// MasterLock.h -- Declarations for Master Lock routines

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MASTERLOCK_H)
#define SLBCSP_MASTERLOCK_H

#include "Lockable.h"

///////////////////////////    PUBLIC     /////////////////////////////////
void
DestroyMasterLock();

void
SetupMasterLock();

Lockable &
TheMasterLock();

#endif // SLBCSP_MASTERLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\logintask.h ===
// LoginTask.h -- Base functor (function object) declaration for card logon

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_LOGINTASK_H)
#define SLBCSP_LOGINTASK_H

#include <memory>                                 // for auto_ptr
#include <string>

#include "HCardCtx.h"
#include "AccessTok.h"
#include "Secured.h"
#include "ExceptionContext.h"

// Using the Template Method pattern with the functor idiom, this
// base class implements the task of login (authentication) to the
// card.

// Subclasses may optionally implement the primitive operations DoPin
// and DoNewPin.  The operator() attempts the authentication.  If the
// PIN specified to the constructor is empty, then operator() calls
// DoPin expecting it to set m_sPin to the PIN value to use when
// attempting authentication.  It then attempts to authenticate,
// calling DoPin repeatedly until authentication succeeds, DoPin
// throws an exception, or authentication fails due to some reason
// other than a bad PIN.  Once authentication succeeds and
// m_fChangePin is true, the DoNewPin primitive is called expecting it
// to set m_sNewPin.  If m_sNewPin is not empty, then an attempt is
// made to change the pin to the new one.  This is repeated until the
// change succeeds, throws an exception other than an slbException, or
// DoNewPin throws an exception.
class LoginTask
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    LoginTask();

    virtual
    ~LoginTask();

                                                  // Operators
    // log's onto the card
    void
    operator()(AccessToken &rat);

                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
    class Capsule
        : public ExceptionContext
    {
    public:
        explicit
        Capsule(AccessToken &rat)
            : m_rat(rat),
              m_fContinue(true)
        {};

        AccessToken &m_rat;
        bool m_fContinue;
    };

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    GetNewPin(Capsule &rcapsule);

    virtual void
    GetPin(Capsule &rcapsule);

    virtual void
    OnChangePinError(Capsule &rcapsule);

    virtual void
    OnSetPinError(Capsule &rcapsule);

    void
    RequestedToChangePin(bool flag);
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    ChangePin(AccessToken &rat);

    void
    Login(AccessToken &rat);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool m_fRequestedToChangePin;
};

#endif // SLBCSP_LOGINTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\logintask.cpp ===
// LoginTask.cpp -- Base functor (function object) definition for card login

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <scuOsExc.h>

#include "LoginTask.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
LoginTask::LoginTask()
    : m_fRequestedToChangePin(false)
{}

LoginTask::~LoginTask()
{}

                                                  // Operators
void
LoginTask::operator()(AccessToken &rat)
{
    m_fRequestedToChangePin = false;

    Secured<HCardContext> shcardctx(rat.CardContext());

    Login(rat);

    if (m_fRequestedToChangePin)
        ChangePin(rat);
}


                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
LoginTask::GetNewPin(Capsule &rcapsule)
{
    throw scu::OsException(ERROR_INVALID_PARAMETER);
}

void
LoginTask::GetPin(Capsule &rcapsule)
{
    if (!rcapsule.m_rat.PinIsCached())
        throw scu::OsException(ERROR_INVALID_PARAMETER);
}

void
LoginTask::OnChangePinError(Capsule &rcapsule)
{
    LoginTask::OnSetPinError(rcapsule);
}

void
LoginTask::OnSetPinError(Capsule &rcapsule)
{
    rcapsule.PropagateException();
}

                                                  // Access
void
LoginTask::RequestedToChangePin(bool flag)
{
    m_fRequestedToChangePin = flag;
}

                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
LoginTask::ChangePin(AccessToken &rat)
{
    AccessToken atNew(rat);

    Capsule capsule(atNew);

    GetNewPin(capsule);

    while (capsule.m_fContinue)
    {
        try
        {
            rat.ChangePin(atNew);
            capsule.ClearException();
            capsule.m_fContinue = false;
        }

        catch (scu::Exception &rexc)
        {
            capsule.Exception(auto_ptr<scu::Exception const>(rexc.Clone()));
        }

        if (capsule.Exception())
        {
            OnChangePinError(capsule);
        }

        if (capsule.m_fContinue)
            GetNewPin(capsule);
    }
}

void
LoginTask::Login(AccessToken &rat)
{
    rat.ClearPin();                               // get ready for a pin
    
    Capsule capsule(rat);

    GetPin(capsule);

    while (capsule.m_fContinue)
    {
        try
        {
            rat.Authenticate();
            capsule.ClearException();
            capsule.m_fContinue = false;
        }

        catch (scu::Exception &rexc)
        {
            capsule.Exception(auto_ptr<scu::Exception const>(rexc.Clone()));
        }

        catch (...)
        {
            throw;
        }

        if (capsule.Exception())
        {
            OnSetPinError(capsule);
        }

        if (capsule.m_fContinue)
            GetPin(capsule);
    };
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\maputility.h ===
// MapUtility.h -- Map utilities

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MAPUTILITY_H)
#define SLBCSP_MAPUTILITY_H

template<class In, class Op>
Op
ForEachMappedValue(In First,
                   In Last,
                   Op Proc)
{
    while (First != Last)
        Proc((*First++).second);
    return Proc;
}

#endif // SLBCSP_MAPUTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\masterlock.cpp ===
// MasterLock.cpp -- Master Lock routine definitions

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "NoWarning.h"
#include "ForceLib.h"

#include "MasterLock.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    Lockable *pMasterLock = 0;
}


///////////////////////////    PUBLIC     /////////////////////////////////

void
DestroyMasterLock()
{
    delete pMasterLock;
}

void
SetupMasterLock()
{
    // Assume no multi-threading issues
    if (!pMasterLock)
        pMasterLock = new Lockable;
}

Lockable &
TheMasterLock()
{
    return *pMasterLock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\mskeyblob.cpp ===
// MsKeyBlob.cpp -- MicroSoft Key Blob class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <windows.h>

#include <scuOsExc.h>

#include "MsKeyBlob.h"

using namespace scu;

///////////////////////////  LOCAL/HELPER   /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
ALG_ID
MsKeyBlob::AlgId() const
{
    return reinterpret_cast<ValueType const *>(m_aapBlob.data())->aiKeyAlg;
}

SecureArray<MsKeyBlob::KeyBlobType>
MsKeyBlob::AsAlignedBlob() const
{
    return SecureArray<BlobElemType>(m_aapBlob.data(),m_cLength);
}

MsKeyBlob::ValueType const *
MsKeyBlob::Data() const
{
    return reinterpret_cast<ValueType const *>(m_aapBlob.data());
}

MsKeyBlob::SizeType
MsKeyBlob::Length() const
{
    return m_cLength;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
MsKeyBlob::MsKeyBlob(KeyBlobType kbt,
                     ALG_ID ai,
                     SizeType cReserve)
    : m_aapBlob(0),
      m_cLength(0),
      m_cMaxSize(0)
{
    Setup(sizeof HeaderElementType + cReserve);
    
    ValueType bhTemplate =
    {
        kbt,
        CUR_BLOB_VERSION,
        0,                                        // must be zero per MS
        ai
    };

    Append(reinterpret_cast<BlobElemType const *>(&bhTemplate),
           sizeof bhTemplate);
}

MsKeyBlob::MsKeyBlob(BYTE const *pbData,
                     DWORD dwDataLength)
    : m_aapBlob(0),
      m_cLength(0),
      m_cMaxSize(0)
{
    Setup(dwDataLength);
    
    ValueType const *pvt = reinterpret_cast<ValueType const *>(pbData);
    if (!((PUBLICKEYBLOB  == pvt->bType) ||
          (PRIVATEKEYBLOB == pvt->bType) ||
          (SIMPLEBLOB     == pvt->bType)))
        throw scu::OsException(NTE_BAD_TYPE);
    if (CUR_BLOB_VERSION != pvt->bVersion)
        throw scu::OsException(NTE_BAD_TYPE);
    if (0 != pvt->reserved)
        throw scu::OsException(NTE_BAD_TYPE);
    
    Append(pbData, dwDataLength);
}

MsKeyBlob::~MsKeyBlob()
{}

                                                  // Operators
                                                  // Operations
void
MsKeyBlob::Append(BlobElemType const *pvt,
                  SizeType cLength)
{
    if ((m_cLength + cLength) > m_cMaxSize)
    {
        m_aapBlob.append(cLength, 0);
        m_cMaxSize += cLength;
    }

    memcpy(m_aapBlob.data() + m_cLength, pvt, cLength);
    m_cLength += cLength;
}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
SecureArray<MsKeyBlob::BlobElemType>
MsKeyBlob::AllocBlob(MsKeyBlob::SizeType cInitialMaxLength)
{
    return SecureArray<BlobElemType>(cInitialMaxLength);
}

void
MsKeyBlob::Setup(MsKeyBlob::SizeType cMaxLength)
{
    m_aapBlob = AllocBlob(cMaxLength);
    m_cLength = 0;
    m_cMaxSize = cMaxLength;
}

    
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsakb.h ===
// MSRsaKB.h -- MicroSoft RSA Key Blob class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MSRSAKB_H)
#define SLBCSP_MSRSAKB_H

#include <wincrypt.h>

#include "RsaKey.h"
#include "MsKeyBlob.h"

class MsRsaKeyBlob
    : public MsKeyBlob,
      public RsaKey
{
public:
                                                  // Types

    typedef DWORD PublicExponentType;

    typedef RSAPUBKEY HeaderElementType;

    struct ValueType
    {
        MsKeyBlob::ValueType keyblob;
        HeaderElementType rsapubkey;
    };


    typedef BYTE ElementValueType;                // type of modulus elements

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
    BitLengthType
    BitLength() const;

    ValueType const *
    Data() const;

    ModulusLengthType
    Length() const;

    PublicExponentType
    PublicExponent() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    MsRsaKeyBlob(MsKeyBlob::KeyBlobType kbt,
                 ALG_ID algid,
                 StrengthType strength,
                 Blob const &rbPublicExponent,
                 SizeType cReserve);

    MsRsaKeyBlob(BYTE const *pbData,
                 DWORD dwDataLength);

    virtual
    ~MsRsaKeyBlob();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types

    enum MagicConstant
    {
        mcPublic  = 0x31415352,       // hex encoding of "RSA1"
        mcPrivate = 0x32415352        // hex encoding of "RSA2"
    };

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

#endif // SLBCSP_MSRSAKB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\mskeyblob.h ===
// MsKeyBlob.h -- MicroSoft Key Blob abstract base class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MSKEYBLOB_H)
#define SLBCSP_MSKEYBLOB_H

#include <stddef.h>
#include <wincrypt.h>

#include <iopPriBlob.h>

#include "AlignedBlob.h"

class MsKeyBlob
{
public:
                                                  // Types
    typedef BYTE KeyBlobType;
    typedef BLOBHEADER HeaderElementType;
    typedef HeaderElementType ValueType;
    typedef size_t SizeType;                      // in KeyBlobType units

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
    ALG_ID
    AlgId() const;

    scu::SecureArray<KeyBlobType>
    AsAlignedBlob() const;

    ValueType const *
    Data() const;

    SizeType
    Length() const;

                                                  // Predicates

protected:
                                                  // Types
    typedef BYTE BlobElemType;

                                                  // C'tors/D'tors
    MsKeyBlob(KeyBlobType kbt,
              ALG_ID ai,
              SizeType cReserve);

    MsKeyBlob(BYTE const *pbData,
              DWORD dwDataLength);


    virtual ~MsKeyBlob();

                                                  // Operators
                                                  // Operations
    void
    Append(Blob::value_type const *pvt,
           Blob::size_type cLength);

                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    static scu::SecureArray<BlobElemType>
    AllocBlob(SizeType cInitialMaxLength);

    void
    Setup(SizeType cMaxLength);

                                                  // Access
                                                  // Predicates
                                                  // Variables
    scu::SecureArray<BlobElemType> m_aapBlob;
    SizeType m_cLength;
    SizeType m_cMaxSize;
};

#endif // SLBCSP_MSKEYBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsakb.cpp ===
// MsRsaKeyBlob.cpp -- MicroSoft RSA Key Blob class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>

#include <scuOsExc.h>

#include "MsRsaKB.h"

using namespace std;
using namespace scu;

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
MsRsaKeyBlob::MsRsaKeyBlob(KeyBlobType kbt,
                           ALG_ID ai,
                           StrengthType strength,
                           Blob const &rbPublicExponent,
                           SizeType cReserve)
    : MsKeyBlob(kbt, ai, sizeof HeaderElementType + cReserve),
      RsaKey()
{
    if (!((CALG_RSA_SIGN == ai) || (CALG_RSA_KEYX == ai)))
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    MagicConstant mc;
    switch (kbt)
    {
    case PRIVATEKEYBLOB:
        mc = mcPrivate;
        break;

    case PUBLICKEYBLOB:
        mc = mcPublic;
        break;

    default:
        throw scu::OsException(ERROR_INVALID_PARAMETER);
        break;
    }
    
    HeaderElementType rsapubkey =
    {
        mc,
        strength,
        0                                         // help pad exponent below
    };

    // finish constructing rsapubkey header by appending the exponent,
    // guarding against buffer overflow
    if (sizeof rsapubkey.pubexp <
        (rbPublicExponent.size() * sizeof BlobElemType))
        throw scu::OsException(NTE_BAD_DATA);

    // store exponent left-justified to pad with zeroes
    memcpy(&rsapubkey.pubexp, rbPublicExponent.data(),
           rbPublicExponent.length());

    Append(reinterpret_cast<BlobElemType *>(&rsapubkey),
           sizeof rsapubkey);

}

MsRsaKeyBlob::MsRsaKeyBlob(BYTE const *pbData,
                           DWORD dwDataLength)
    : MsKeyBlob(pbData, dwDataLength),
      RsaKey()
{
    switch (MsKeyBlob::Data()->bType)
    {
    case PRIVATEKEYBLOB:
        if (mcPrivate != Data()->rsapubkey.magic)
            throw scu::OsException(NTE_BAD_TYPE);
        break;

    case PUBLICKEYBLOB:
        if (mcPublic != Data()->rsapubkey.magic)
            throw scu::OsException(NTE_BAD_TYPE);
        break;

    default:
        throw scu::OsException(NTE_BAD_TYPE);
        break;
    }

    ALG_ID const ai = Data()->keyblob.aiKeyAlg;
    if (!((CALG_RSA_KEYX == ai) || (CALG_RSA_SIGN == ai)))
        throw scu::OsException(NTE_BAD_TYPE);

}

MsRsaKeyBlob::~MsRsaKeyBlob()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
MsRsaKeyBlob::BitLengthType
MsRsaKeyBlob::BitLength() const
{
    return Data()->rsapubkey.bitlen;
}

MsRsaKeyBlob::ValueType const *
MsRsaKeyBlob::Data() const
{
    return reinterpret_cast<ValueType const *>(MsKeyBlob::Data());
}

MsRsaKeyBlob::ModulusLengthType
MsRsaKeyBlob::Length() const
{
     return BitLength() / numeric_limits<ElementValueType>::digits;
}

MsRsaKeyBlob::PublicExponentType
MsRsaKeyBlob::PublicExponent() const
{
    return Data()->rsapubkey.pubexp;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsaprikb.cpp ===
// MsRsaPriKB.cpp -- MicroSoft RSA Private Key Blob class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>

#include "MsRsaPriKB.h"

using namespace std;
using namespace scu;
using namespace iop;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
auto_ptr<CPrivateKeyBlob>
AsPCciPrivateKeyBlob(MsRsaPrivateKeyBlob const &rmsprivatekeyblob)
{
    auto_ptr<CPrivateKeyBlob> appkb =
        auto_ptr<CPrivateKeyBlob>(new CPrivateKeyBlob);

    appkb->bPLen = static_cast<BYTE>(rmsprivatekeyblob.PrimeLength());
    appkb->bQLen = appkb->bPLen;
    appkb->bInvQLen = static_cast<BYTE>(rmsprivatekeyblob.CoefficientLength());
    appkb->bKsecModQLen = static_cast<BYTE>(rmsprivatekeyblob.ExponentLength());
    appkb->bKsecModPLen = appkb->bKsecModQLen;
    memcpy(appkb->bP.data(), rmsprivatekeyblob.Prime1(), appkb->bPLen);
    memcpy(appkb->bQ.data(), rmsprivatekeyblob.Prime2(), appkb->bQLen);
    memcpy(appkb->bInvQ.data(), rmsprivatekeyblob.Coefficient(), appkb->bInvQLen);
    memcpy(appkb->bKsecModQ.data(), rmsprivatekeyblob.Exponent2(),
           appkb->bKsecModQLen);
    memcpy(appkb->bKsecModP.data(), rmsprivatekeyblob.Exponent1(),
           appkb->bKsecModPLen);

    return appkb;
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
MsRsaPrivateKeyBlob::MsRsaPrivateKeyBlob(ALG_ID algid,
                                         Blob const &rbRawExponent,
                                         Blob const &rbRawModulus,
                                         Blob const &rbPrime1,
                                         Blob const &rbPrime2,
                                         Blob const &rbExponent1,
                                         Blob const &rbExponent2,
                                         Blob const &rbCoefficient,
                                         Blob const &rbPrivateExponent)
    : MsRsaPublicKeyBlob(PRIVATEKEYBLOB, algid,
                         rbRawExponent,
                         rbRawModulus,
                         (9 * (rbRawModulus.length() *
                               sizeof HeaderElementType)) / 16)
{
    Append(rbPrime1.data(), rbPrime1.length());
    Append(rbPrime2.data(), rbPrime2.length());
    Append(rbExponent1.data(), rbExponent1.length());
    Append(rbExponent2.data(), rbExponent2.length());
    Append(rbCoefficient.data(), rbCoefficient.length());
    Append(rbPrivateExponent.data(), rbPrivateExponent.length());
}

MsRsaPrivateKeyBlob::MsRsaPrivateKeyBlob(BYTE const *pbData,
                                         DWORD dwDataLength)
    : MsRsaPublicKeyBlob(pbData, dwDataLength)
{}


MsRsaPrivateKeyBlob::~MsRsaPrivateKeyBlob()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::Coefficient() const
{
    return Exponent2() + ExponentLength();
}

size_t
MsRsaPrivateKeyBlob::CoefficientLength() const
{
    return BitLength() /
        (2 * numeric_limits<ElementValueType>::digits);
}

MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::Exponent1() const
{
    return Prime2() + PrimeLength();
}

MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::Exponent2() const
{
    return Exponent1() + ExponentLength();
}

size_t
MsRsaPrivateKeyBlob::ExponentLength() const
{
    return BitLength() /
        (2 * numeric_limits<ElementValueType>::digits);
}

MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::Prime1() const
{
    return Modulus() + Length();
}

MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::Prime2() const
{
    return Prime1() + PrimeLength();
}

size_t
MsRsaPrivateKeyBlob::PrimeLength() const
{
    return BitLength() / (2 * numeric_limits<ElementValueType>::digits);
}

MsRsaPrivateKeyBlob::ElementValueType const *
MsRsaPrivateKeyBlob::PrivateExponent() const
{
    return Coefficient() + CoefficientLength();
}

size_t
MsRsaPrivateKeyBlob::PriExpLength() const
{
    return BitLength() / numeric_limits<ElementValueType>::digits;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsapubkb.cpp ===
// MsRsaPubKB.cpp -- MicroSoft RSA Public Key Blob class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>

#include <windows.h>

#include "MsRsaPubKB.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    MsRsaPublicKeyBlob::StrengthType
    Strength(Blob::size_type st)
    {
        return st *
            numeric_limits<MsRsaPublicKeyBlob::ElementValueType>::digits;
    }

    MsRsaPublicKeyBlob::SizeType
    Reserve(Blob::size_type st)
    {
        return st * sizeof MsRsaPublicKeyBlob::HeaderElementType;
    }
    
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
MsRsaPublicKeyBlob::MsRsaPublicKeyBlob(ALG_ID algid,
                                       Blob const &rblbPublicExponent,
                                       Blob const &rblbRawModulus)
    : MsRsaKeyBlob(PUBLICKEYBLOB, algid,
                   Strength(rblbRawModulus.length()),
                   rblbPublicExponent,
                   Reserve(rblbRawModulus.length()))
{
    Init(rblbRawModulus);
}

MsRsaPublicKeyBlob::MsRsaPublicKeyBlob(BYTE const *pbData,
                                       DWORD dwDataLength)
    : MsRsaKeyBlob(pbData, dwDataLength)
{}

MsRsaPublicKeyBlob::~MsRsaPublicKeyBlob()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
MsRsaPublicKeyBlob::ValueType const *
MsRsaPublicKeyBlob::Data() const
{
    return reinterpret_cast<ValueType const *>(MsRsaKeyBlob::Data());
}

MsRsaPublicKeyBlob::ElementValueType const *
MsRsaPublicKeyBlob::Modulus() const
{
    return reinterpret_cast<ElementValueType const *>(MsRsaKeyBlob::Data() + 1);
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

MsRsaPublicKeyBlob::MsRsaPublicKeyBlob(KeyBlobType kbt,
                                       ALG_ID algid,
                                       Blob const &rblbRawExponent,
                                       Blob const &rblbRawModulus,
                                       SizeType cReserve)
    : MsRsaKeyBlob(kbt, algid, Strength(rblbRawModulus.length()),
                   rblbRawExponent,
                   Reserve(rblbRawModulus.length()) + cReserve)
{
    Init(rblbRawModulus);
}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
MsRsaPublicKeyBlob::Init(Blob const &rblbRawModulus)
{
    Append(rblbRawModulus.data(), rblbRawModulus.length());
}
 

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsapubkb.h ===
// MsRsaPubKB.h -- MicroSoft RSA Public Key Blob class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MSRSAPUBKB_H)
#define SLBCSP_MSRSAPUBKB_H

#include <memory>                                 // for auto_ptr

#include "MsRsaKB.h"

class MsRsaPublicKeyBlob
    : public MsRsaKeyBlob
{
public:
                                                  // Types
    typedef ElementValueType HeaderElementType[1];

    struct ValueType
    {
        MsRsaKeyBlob::ValueType rsaheader;
        HeaderElementType modulus;                // placeholder
    };

                                                  // C'tors/D'tors
    MsRsaPublicKeyBlob(ALG_ID algid,
                       Blob const &rblbRawExponent,
                       Blob const &rblbRawModulus);

    MsRsaPublicKeyBlob(BYTE const *pbData,
                       DWORD dwDataLength);

    ~MsRsaPublicKeyBlob();

                                                  // Operators
                                                  // Operations
                                                  // Access
    ValueType const *
    Data() const;

    ElementValueType const *
    Modulus() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    MsRsaPublicKeyBlob(KeyBlobType kbt,
                       ALG_ID algid,
                       Blob const &rblbRawExponent,
                       Blob const &rblbRawModulus,
                       SizeType cReserve);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Init(Blob const &rblbRawModulus);
        
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

#endif // SLBCSP_MSRSAPUBKB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\msrsaprikb.h ===
// MsRsaPriKB.h -- MicroSoft RSA Private Key Blob class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MSRSAPRIKB_H)
#define SLBCSP_MSRSAPRIKB_H

#include <memory>                                 // for auto_ptr

#include <iopPriBlob.h>

#include "MsRsaPubKB.h"

class MsRsaPrivateKeyBlob
    : public MsRsaPublicKeyBlob
{
public:
                                                  // Types
    typedef ElementValueType HeaderElementType;

                                                  // C'tors/D'tors
    MsRsaPrivateKeyBlob(ALG_ID algid,
                        Blob const &rbRawExponent,
                        Blob const &rbRawModulus,
                        Blob const &rbPrime1,
                        Blob const &rbPrime2,
                        Blob const &rbExponent1,
                        Blob const &rbExponent2,
                        Blob const &rbCoefficient,
                        Blob const &rbPrivateExponent);

    MsRsaPrivateKeyBlob(BYTE const *pbData,
                        DWORD dwDataLength);


    ~MsRsaPrivateKeyBlob();

                                                  // Operators
                                                  // Operations
                                                  // Access
    ElementValueType const *
    Coefficient() const;

    size_t
    CoefficientLength() const;

    ElementValueType const *
    Exponent1() const;

    ElementValueType const *
    Exponent2() const;

    size_t
    ExponentLength() const;

    ElementValueType const *
    Prime1() const;

    ElementValueType const *
    Prime2() const;

    size_t
    PrimeLength() const;

    ElementValueType const *
    PrivateExponent() const;

    // Private exponent length
    size_t
    PriExpLength() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

};

std::auto_ptr<iop::CPrivateKeyBlob>
AsPCciPrivateKeyBlob(MsRsaPrivateKeyBlob const &rmsprivatekeyblob);

#endif // SLBCSP_MSRSAPRIKB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\multistrz.cpp ===
// MultiStrZ.cpp -- Multiple String, zero-terminated class definition.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <numeric>

#include "MultiStrZ.h"

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace
{
    MultiStringZ::SizeType
    LengthAccumulator(MultiStringZ::SizeType cInitLength,
                      MultiStringZ::ValueType const &rs)
    {
        return cInitLength += rs.length() + 1;  // include terminating 0
    }

    MultiStringZ::ValueType &
    StringAccumulator(MultiStringZ::ValueType &lhs,
                      MultiStringZ::ValueType const &rhs)
    {
        // include terminating 0
        lhs.append(rhs.c_str(), rhs.length() + 1);

        return lhs;
    }

    MultiStringZ::csSizeType
    csLengthAccumulator(MultiStringZ::csSizeType cInitLength,
                        MultiStringZ::csValueType const &rs)
    {
        return cInitLength += rs.GetLength()+1; //Include terminating 0
    }

    MultiStringZ::csValueType &
    csStringAccumulator(MultiStringZ::csValueType &lhs,
                        MultiStringZ::csValueType const &rhs)
    {
        int lLen = lhs.GetLength();
        int rLen = rhs.GetLength();
        LPTSTR pBuffer = lhs.GetBufferSetLength(lLen+rLen+1);
        wcsncpy(pBuffer+lLen,(LPCTSTR)rhs,rLen);
        *(pBuffer+lLen+rLen) = TCHAR('\0');//The separator between strings
        lhs.ReleaseBuffer(lLen+rLen+1);
        return lhs;
    }
} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
    MultiStringZ::MultiStringZ()
        : m_Buffer(),
          m_csBuffer()
    {}


    MultiStringZ::MultiStringZ(vector<ValueType> const &rvs)
        : m_Buffer(),
          m_csBuffer()
    {

        SizeType cLength = accumulate(rvs.begin(), rvs.end(), 0,
                                      LengthAccumulator);

        if (0 != cLength)
        {
            // +1 to account for the zero character ending the list
            m_Buffer.reserve(cLength + 1);

            m_Buffer = accumulate(rvs.begin(), rvs.end(), m_Buffer,
                                  StringAccumulator);

            m_Buffer.append(1, 0);                // mark end of list
        }
    }

    MultiStringZ::MultiStringZ(vector<csValueType> const &rvs)
        : m_Buffer(),
          m_csBuffer()
    {

        csSizeType cLength = accumulate(rvs.begin(), rvs.end(), 0,
                                        csLengthAccumulator);

        if (0 != cLength)
        {
            m_csBuffer = accumulate(rvs.begin(), rvs.end(), m_csBuffer,
                                    csStringAccumulator);
        }
    }

    MultiStringZ::~MultiStringZ()
    {}

                                                  // Operators
                                                  // Operations
                                                  // Access
    MultiStringZ::CharType const *
    MultiStringZ::Data() const
    {
        return m_Buffer.c_str();                 // use 0 terminated version
    }

    MultiStringZ::SizeType
    MultiStringZ::Length() const
    {
        return m_Buffer.length();
    }

    LPCTSTR
    MultiStringZ::csData() const
    {
        return (LPCTSTR)m_csBuffer; 
    }

    MultiStringZ::csSizeType
    MultiStringZ::csLength() const
    {
        return m_csBuffer.GetLength();
    }

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\nilogintsk.h ===
// NILoginTsk.h -- Non-Interactive Login Task help class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_NILOGINTSK_H)
#define SLBCSP_NILOGINTSK_H

#include <string>

#include "LoginTask.h"

class NonInteractiveLoginTask
    : public LoginTask
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    NonInteractiveLoginTask(char const *pczPin);

    virtual
    ~NonInteractiveLoginTask();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    virtual void
    GetPin(Capsule &rcapsule);
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    char const *m_pczPin;
};

#endif // SLBCSP_NILOGINTSK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\nilogintsk.cpp ===
// NILoginTsk.cpp -- Non-Interactive Login Task helper class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "stdafx.h"
#include "NoWarning.h"
#include "ForceLib.h"

#include "NILoginTsk.h"
#include "StResource.h"

#include <scarderr.h>

using namespace std;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
NonInteractiveLoginTask::NonInteractiveLoginTask(char const *pczPin)
    : m_pczPin(pczPin)
{
}

NonInteractiveLoginTask::~NonInteractiveLoginTask()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
NonInteractiveLoginTask::GetPin(Capsule &rcapsule)
{
    rcapsule.m_rat.Pin(m_pczPin, false);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pkcs11attr.h ===
// Pkcs11Attr.h -- PKCS #11 Attributes class header for
// interoperability with Netscape and Entrust using the SLB PKCS#11
// package.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// The Pkcs11Attributes class defines the base default values the CSP
// must set for the PKCS #11 attributes to emmulate enrollment (key
// and certificate generation) by Netscape or Entrust using Cryptoki
// (PKCS#11).  The default values are based on heuristics in
// evaluating the operation of Netscape and Entrust with what the
// Schlumberger PKCS #11 package expects in this environment.


#if !defined(SLBCSP_PKCS11ATTR_H)
#define SLBCSP_PKCS11ATTR_H

#include <string>

#include <pkiX509Cert.h>

#include "Blob.h"
#include "AuxContext.h"

class Pkcs11Attributes
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    Pkcs11Attributes(Blob const &rCertificate,
                     HCRYPTPROV hprovContext);

                                                  // Operators
                                                  // Operations
                                                  // Access
    Blob
    ContainerId();

    Blob
    EndDate() const;

    Blob
    Id() const;

    static Blob
    Id(Blob const &rblbModulus);

    Blob
    Issuer();

    std::string
    Label();

    Blob
    Modulus();

    Blob
    RawModulus();

    Blob
    SerialNumber();

    Blob
    StartDate() const;

    std::string
    Subject();


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    pki::X509Cert m_x509cert;
    HCRYPTPROV m_hprovContext;
};

#endif // SLBCSP_PKCS11ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\procedural.h ===
// Procedural.h -- Procedural binder and adapter template classes

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_PROCEDURAL_H)
#define SLBCSP_PROCEDURAL_H

#include <functional>

// Template classes that support composition of procedure objects
// (proctors).  Proctors are like functors (function objects) but
// don't return a value (void).  The template classes defined here
// follow C++ member function binders and adapters.

///////////////////////////    BINDERS    /////////////////////////////////

template<class Arg>
struct UnaryProcedure
    : public std::unary_function<Arg, void>
{};

template<class Arg1, class Arg2>
struct BinaryProcedure
    : public std::binary_function<Arg1, Arg2, void>
{};

template<class BinaryProc>
class ProcedureBinder2nd
    : public UnaryProcedure<typename BinaryProc::first_argument_type>
{
public:
    ProcedureBinder2nd(BinaryProc const &rproc,
                       typename BinaryProc::second_argument_type const &rarg)
        : m_proc(rproc),
          m_arg2(rarg)
    {}

    void
    operator()(argument_type const &arg1) const
    {
        m_proc(arg1, m_arg2);
    }

protected:
    BinaryProc m_proc;
    typename BinaryProc::second_argument_type m_arg2;
};

template<class BinaryProc, class T>
ProcedureBinder2nd<BinaryProc>
ProcedureBind2nd(BinaryProc const &rProc, T const &rv)
{
    return ProcedureBinder2nd<BinaryProc>(rProc, BinaryProc::second_argument_type(rv));
};

////////////////////  MEMBER PROCEDURE ADAPTERS //////////////////////////

template<class T>
class MemberProcedureType
    : public UnaryProcedure<T *>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    MemberProcedureType(void (T::* p)())
        : m_pmp(p)
    {}

                                                  // Operators
    void
    operator()(T *p) const
    {
        (p->*m_pmp)();
    }


                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    void (T::* m_pmp)();

};

template<class T>
MemberProcedureType<T>
MemberProcedure(void (T::* p)())
{
    return MemberProcedureType<T>(p);
};

////////////////////  POINTER TO PROCEDURE ADAPTERS ///////////////////////

template<class T1, class T2>
class PointerToBinaryProcedure
    : public BinaryProcedure<T1, T2>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    PointerToBinaryProcedure(void (*p)(T1, T2))
        : m_p(p)
    {}

                                                  // Operators
    void
    operator()(T1 arg1,
               T2 arg2) const
    {
        m_p(arg1, arg2);
    }


                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    void (*m_p)(T1, T2);

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

template<class T1, class T2>
PointerToBinaryProcedure<T1, T2>
PointerProcedure(void (*p)(T1, T2))
{
    return PointerToBinaryProcedure<T1, T2>(p);
};


template<class T>
class PointerToUnaryProcedure
    : public UnaryProcedure<T>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    PointerToUnaryProcedure(void (*p)(T))
        : m_p(p)
    {}

                                                  // Operators
    void
    operator()(T arg) const
    {
        m_p(arg);
    }


                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    void (*m_p)(T);

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

template<class T>
PointerToUnaryProcedure<T>
PointerProcedure(void (*p)(T))
{
    return PointerToUnaryProcedure<T>(p);
}

#endif // SLBCSP_PROCEDURAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pkcs11attr.cpp ===
// Pkcs11Attr.cpp -- Implementation of PKCS #11 Attributes class for
// interoperability with Netscape and Entrust using the SLB PKCS#11
// package.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

// Don't allow the min & max methods in <limits> to be superceded by
// the min/max macros in <windef.h>
#define NOMINMAX

#include <limits>
#include <functional>
#include <numeric>
#include <iterator>
#include <algorithm>
#include <sstream>

#include <cciCard.h>
#include <cciCont.h>

#include "Pkcs11Attr.h"
#include "AuxHash.h"

using namespace std;
using namespace pki;

///////////////////////////    HELPER     /////////////////////////////////
namespace
{
    class JoinWith
        : public binary_function<string, string, string>
    {
    public:

        explicit
        JoinWith(second_argument_type const &rGlue)
            : m_Glue(rGlue)
        {}


        result_type
        operator()(string const &rFirst,
                   string const &rSecond) const
        {
            return rFirst + m_Glue + rSecond;
        }

    private:

        second_argument_type const m_Glue;
    };


    string
    Combine(vector<string> const &rvsNames)
    {
        static string::value_type const cBlank = ' ';
        static string const sBlank(1, cBlank);

        return accumulate(rvsNames.begin() + 1, rvsNames.end(),
                          *rvsNames.begin(), JoinWith(sBlank));
    }

} // namespace



///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
Pkcs11Attributes::Pkcs11Attributes(Blob const &rCertificate,
                                   HCRYPTPROV hprovContext)
    : m_x509cert(AsString(rCertificate)),
      m_hprovContext(hprovContext)
{
}

                                                  // Operators
                                                  // Operations
                                                  // Access
Blob
Pkcs11Attributes::ContainerId()
{
    AuxHash ah(AuxContext(m_hprovContext), CALG_MD5);

    return ah.Value(AsBlob(Subject()));
}

Blob
Pkcs11Attributes::EndDate() const
{
    return Blob(3, 0);                            // TO DO: Set date
}

Blob
Pkcs11Attributes::Issuer()
{
    return AsBlob(m_x509cert.Issuer());
}

string
Pkcs11Attributes::Label()
{
    string sFullName(Combine(m_x509cert.SubjectCommonName()));
    string sLabel(sFullName);

    static string const sNameSuffix = "'s ";
    sLabel.append(sNameSuffix);

    string sOrganizationName(Combine(m_x509cert.IssuerOrg()));
    sLabel.append(sOrganizationName);

    static string const sLabelSuffix = " ID";
    sLabel.append(sLabelSuffix);

    return sLabel;
}

Blob
Pkcs11Attributes::Modulus()
{
    return AsBlob(m_x509cert.Modulus());
}

Blob
Pkcs11Attributes::RawModulus()
{
    return AsBlob(m_x509cert.RawModulus());
}


Blob
Pkcs11Attributes::SerialNumber()
{
    return AsBlob(m_x509cert.SerialNumber());
}

Blob
Pkcs11Attributes::StartDate() const
{
    return Blob(3, 0);                                  // TO DO: Set date
}

string
Pkcs11Attributes::Subject()
{
    return m_x509cert.Subject();
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\nowarning.h ===
// NoWarning.h - Turn off compiler warnings that may be safely
// ignored.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_NOWARNING_H)
#define SLBCSP_NOWARNING_H

//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

//  Identifier truncated to 255 in debugger/browser info
#pragma warning(disable : 4786)

#endif // SLBCSP_NOWARNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\multistrz.h ===
// MultiStrZ.h -- Multiple String, zero-terminated class declaration.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_MULTISTRZ_H)
#define SLBCSP_MULTISTRZ_H
#include "StdAfx.h"
#include <string>
#include <vector>

// Represents a vector of strings as multiple zero-terminated strings
// (C-style strings) in a data buffer.  The last string in the buffer
// terminated with two zeroes.

class MultiStringZ
{
    // TO DO: This class is incomplete, no comparison operators,
    // appending, clearing, etc.

public:
                                                  // Types
    // TO DO: What about supporting TCHAR??  Implement class as template?
    typedef char CharType;
    typedef std::string ValueType;
    typedef std::string::size_type SizeType;
    typedef CString csValueType;
    typedef size_t csSizeType;
    
                                                  // C'tors/D'tors
    explicit
    MultiStringZ();

    explicit
    MultiStringZ(std::vector<ValueType> const &rvs);

    explicit
    MultiStringZ(std::vector<csValueType> const &rvs);

    virtual
    ~MultiStringZ();

                                                  // Operators
                                                  // Operations
                                                  // Access
    CharType const *
    Data() const;

    SizeType
    Length() const;

    LPCTSTR
    csData() const;

    csSizeType
    csLength() const;


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    ValueType m_Buffer;
    csValueType m_csBuffer;
};

#endif // SLBCSP_MULTISTRZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\promptuser.cpp ===
// PromptUser.cpp -- definition of utility to prompt the user for a response.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#include "stdafx.h"

#include <string>

#include <scuOsExc.h>

#include "StResource.h"
#include "CspProfile.h"
#include "PromptUser.h"

using namespace std;
using namespace ProviderProfile;

///////////////////////////    HELPER     /////////////////////////////////

int
PromptUser(HWND hWnd,
           UINT uiResourceId,
           UINT uiStyle)
{
    
    return PromptUser(hWnd, (LPCTSTR)StringResource(uiResourceId).AsCString(),
                      uiStyle);
}

int
PromptUser(HWND hWnd,
           LPCTSTR lpMessage,
           UINT uiStyle)
{
    CString sTitle(CspProfile::Instance().Name());
#ifdef ISOLATION_AWARE_ENABLED
    CThemeContextActivator activator;
#endif

    if (!((MB_SYSTEMMODAL | uiStyle) || (MB_APPLMODAL | uiStyle)))
        uiStyle |= MB_TASKMODAL;
    uiStyle |= MB_SETFOREGROUND | MB_TOPMOST;

    int iResponse = MessageBox(hWnd, lpMessage, (LPCTSTR)sTitle,
                               uiStyle);
    if (0 == iResponse)
        throw scu::OsException(GetLastError());

    return iResponse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\promptuser.h ===
// PromptUser.h -- declaration of utility to prompt the user for a response.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_PROMPTUSER_H)
#define SLBCSP_PROMPTUSER_H

#include <Windows.h>

///////////////////////////   HELPERS   /////////////////////////////////

int
PromptUser(HWND hWnd,
           UINT uiResourceId,
           UINT uiStyle);

int
PromptUser(HWND hWnd,
           LPCTSTR lpMessage,
           UINT uiStyle);

#endif // SLBCSP_PROMPTUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pswddlg.h ===
// PswdDlg.h -- PaSsWorD DiaLoG class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//

#if !defined(SLBCSP_PSWDDLG_H)
#define SLBCSP_PSWDDLG_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "StResource.h"
#include "DialogBox.h"

#include "LoginId.h"

/////////////////////////////////////////////////////////////////////////////
// CLogoDialog dialog

class CLogoDialog : public CDialog
{
// Construction
public:
    CLogoDialog(CWnd* pParent = NULL);   // standard constructor

// Logo Attributes
public:
   CDC m_dcMem;          // Compatible Memory DC for dialog
   CDC m_dcMask;         // Compatible Memory DC for dialog

   CBitmap m_bmpLogo;    // Bitmap to display
   CBitmap m_bmpMask;    // Bitmap to display

   HBITMAP m_hBmpOld;     // Handle of old bitmap to save
   HBITMAP m_hBmpOldM;    // Handle of old bitmap to save

   BITMAP m_bmInfo;        // Bitmap Information structure
   CPoint m_pt;            // Position for upper left corner of bitmap
   CSize m_size;           // Size (width and height) of bitmap

   CWnd *m_pParent;

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CLogoDialog)
    virtual BOOL OnInitDialog();
	afx_msg void OnPaint( );
	afx_msg void OnDestroy( );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

class CPasswordDlg : public CLogoDialog
{
// Construction
public:
    CPasswordDlg(CWnd* pParent = NULL);   // standard constructor
    DWORD InitDlg(void)
    { return InitDialogBox(this, IDD, m_pParent); };

// Dialog Data
    //{{AFX_DATA(CPasswordDlg)
    enum { IDD = IDD_LOGIN };
    CButton m_ctlCheckHexCode;
    CButton m_ctlCheckChangePIN;
//    CEdit   m_ctlVerifyNewPIN;
//    CEdit   m_ctlNewPIN;
//    CStatic m_ctlVerifyPINLabel;
//    CStatic m_ctlNewPINLabel;
    CString m_szPassword;
    CString m_szMessage;
    BOOL    m_fHexCode;
    BOOL    m_bChangePIN;
//    CString m_csNewPIN;
//    CString m_csVerifyNewPIN;
    //}}AFX_DATA

    // Data Members
    LoginIdentity m_lid;
    CWnd *m_pParent;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPasswordDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPasswordDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickHexCode();
    virtual void OnOK();
    afx_msg void OnChangePINAfterLogin();
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


private:
    // Data Members
    int m_nPasswordSizeLimit;
};
/////////////////////////////////////////////////////////////////////////////
// CChangePINDlg dialog

class CChangePINDlg : public CLogoDialog
{
// Construction
public:
    CChangePINDlg(CWnd* pParent = NULL);   // standard constructor
    DWORD InitDlg(void)
    { return InitDialogBox(this, IDD, m_pParent); };

// Dialog Data
    //{{AFX_DATA(CChangePINDlg)
    enum { IDD = IDD_DIALOG_CHANGE_PIN };
    CStatic m_ctlConfirmOldPINLabel;
    CEdit   m_ctlOldPIN;
    CString m_csOldPIN;
    CString m_csNewPIN;
    CString m_csVerifyNewPIN;
    //}}AFX_DATA

    CWnd *m_pParent;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChangePINDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CChangePINDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // !defined(SLBCSP_PSWDDLG_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pubkeyctx.cpp ===
// PubKeyCtx.cpp -- definition of CPublicKeyContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"  // required  by GUI header files

#include <string>
#include <limits>


#include <slbcci.h>
#include <cciPubKey.h>
#include <cciPriKey.h>
#include <cciCert.h>
#include <cciKeyPair.h>

#include "CryptCtx.h"
#include "HashCtx.h"
#include "RsaKey.h"
#include "EncodedMsg.h"
#include "Pkcs11Attr.h"
#include "AuxHash.h"
#include "RsaKPGen.h"
#include "Secured.h"
#include "StResource.h"
#include "PromptUser.h"
#include "PublicKeyHelper.h"
#include "PubKeyCtx.h"
#include "AlignedBlob.h"
#include "CertificateExtensions.h"
#include <iopPriBlob.h>

using namespace std;
using namespace scu;
using namespace cci;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
DWORD
PkcsToDword(
    IN OUT LPBYTE pbPkcs,
    IN DWORD lth)
{
    LPBYTE pbBegin = pbPkcs;
    LPBYTE pbEnd = &pbPkcs[lth - 1];
    DWORD length = lth;
    while (pbBegin < pbEnd)
    {
        BYTE tmp = *pbBegin;
        *pbBegin++ = *pbEnd;
        *pbEnd-- = tmp;
    }
    for (pbEnd = &pbPkcs[lth - 1]; 0 == *pbEnd; pbEnd -= 1)
        length -= 1;
    return length;
}

KeySpec
AsKeySpec(ALG_ID algid)
{
    KeySpec ks;

        switch(algid)
        {
        case AT_KEYEXCHANGE:
            ks = ksExchange;
            break;
        case AT_SIGNATURE:
            ks = ksSignature;
            break;

        default:
            throw scu::OsException(NTE_BAD_KEY);
    }

    return ks;
}

ALG_ID
AsKeySpec(KeySpec ks)
{
    ALG_ID algid;

    switch(ks)
    {
    case ksExchange:
        algid = AT_KEYEXCHANGE;
        break;

    case ksSignature:
        algid = AT_SIGNATURE;
        break;

    default:
        throw scu::OsException(NTE_FAIL);       // internal error
        break;
    }

    return algid;
}

string
AsString(unsigned char const *p,
         size_t cLength)
{
    return string(reinterpret_cast<char const *>(p), cLength);
}

// make a "raw modulus" from a modulus by padding with zeroes to meet
// specified strength.  The modulus blob is assumed to represent an
// unsigned integer in little endian format whose size less than or
// equal to strength in octets.
Blob
RawModulus(Blob const &rbTrimmedModulus,
           RsaKey::StrengthType strength)
{
    RsaKey::OctetLengthType const cRawLength =
        strength / numeric_limits<Blob::value_type>::digits;
    if (cRawLength < rbTrimmedModulus.length())
        throw scu::OsException(NTE_BAD_DATA);

    Blob bRawModulus(rbTrimmedModulus);
    bRawModulus.append(cRawLength - rbTrimmedModulus.length(), 0);

    return bRawModulus;
}

/*++

ExtractTag:

    This routine extracts a tag from an ASN.1 BER stream.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwTag receives the tag.

Return Value:

    The number of bytes extracted from the stream.  Errors are thrown
    as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 10/9/1995
    Doug Barlow (dbarlow) 7/31/1997

--*/

DWORD
ExtractTag(BYTE const *pbSrc,
           LPDWORD pdwTag,
           LPBOOL pfConstr)
{
    LONG lth = 0;
    DWORD tagw;
    BYTE tagc, cls;


    tagc = pbSrc[lth++];
    cls = tagc & 0xc0;  // Top 2 bits.
    if (NULL != pfConstr)
        *pfConstr = (0 != (tagc & 0x20));
    tagc &= 0x1f;       // Bottom 5 bits.

    if (31 > tagc)
        tagw = tagc;
    else
    {
        tagw = 0;
        do
        {
            if (0 != (tagw & 0xfe000000))
                throw scu::OsException(ERROR_ARITHMETIC_OVERFLOW);
            tagc = pbSrc[lth++];
            tagw <<= 7;
            tagw |= tagc & 0x7f;
        } while (0 != (tagc & 0x80));
    }

    *pdwTag = tagw | (cls << 24);
    return lth;
}


/*++

ExtractLength:

    This routine extracts a length from an ASN.1 BER stream.  If the
    length is indefinite, this routine recurses to figure out the real
    length.  A flag as to whether or not the encoding was indefinite
    is optionally returned.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwLen receives the len.

    pfIndefinite, if not NULL, receives a flag indicating whether or not
the
        encoding was indefinite.

Return Value:

    The number of bytes extracted from the stream.  Errors are thrown as
    DWORD status codes.

Author:

    Doug Barlow (dbarlow) 10/9/1995
    Doug Barlow (dbarlow) 7/31/1997

--*/

DWORD
ExtractLength(BYTE const *pbSrc,
              LPDWORD pdwLen,
              LPBOOL pfIndefinite)
{
    DWORD ll, rslt, lth, lTotal = 0;
    BOOL fInd = FALSE;


    //
    // Extract the Length.
    //

    if (0 == (pbSrc[lTotal] & 0x80))
    {

        //
        // Short form encoding.
        //

        rslt = pbSrc[lTotal++];
    }
    else
    {
        rslt = 0;
        ll = pbSrc[lTotal++] & 0x7f;
        if (0 != ll)
        {

            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (rslt & 0xff000000))
                    throw scu::OsException(ERROR_ARITHMETIC_OVERFLOW);
                rslt = (rslt << 8) | pbSrc[lTotal];
                lTotal += 1;
            }
        }
        else
        {
            DWORD ls = lTotal;

            //
            // Indefinite encoding.
            //

            fInd = TRUE;
            while ((0 != pbSrc[ls]) || (0 != pbSrc[ls + 1]))
            {

                // Skip over the Type.
                if (31 > (pbSrc[ls] & 0x1f))
                    ls += 1;
                else
                    while (0 != (pbSrc[++ls] & 0x80));   // Empty loop body.

                lth = ExtractLength(&pbSrc[ls], &ll, NULL);
                ls += lth + ll;
            }
            rslt = ls - lTotal;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    *pdwLen = rslt;
    if (NULL != pfIndefinite)
        *pfIndefinite = fInd;
    return lTotal;
}


/*++

Asn1Length:

    This routine parses a given ASN.1 buffer and returns the complete
    length of the encoding, including the leading tag and length
    bytes.

Arguments:

    pbData supplies the buffer to be parsed.

Return Value:

    The length of the entire ASN.1 buffer.

Throws:

    Overflow errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 7/31/1997

--*/

DWORD
Asn1Length(LPCBYTE pbAsn1)
{
    DWORD dwTagLen, dwLenLen, dwValLen;
    DWORD dwTag;

    dwTagLen = ExtractTag(pbAsn1, &dwTag, NULL);
    dwLenLen = ExtractLength(&pbAsn1[dwTagLen], &dwValLen, NULL);
    return dwTagLen + dwLenLen + dwValLen;
}

} // namespace


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CPublicKeyContext::CPublicKeyContext(HCRYPTPROV hProv,
                                     CryptContext &rcryptctx,
                                     ALG_ID algid,
                                     bool fVerifyKeyExists)
    : CKeyContext(hProv, KT_PUBLICKEY),
      m_rcryptctx(rcryptctx),
      m_ks(AsKeySpec(algid))
{
    // Make sure the key exists on the card
    if (fVerifyKeyExists)
        VerifyKeyExists();
}

CPublicKeyContext::~CPublicKeyContext()
{}

                                                  // Operators


                                                  // Operations

auto_ptr<CKeyContext>
CPublicKeyContext::Clone(DWORD const *pdwReserved,
                         DWORD dwFlags) const
{
    return auto_ptr<CKeyContext>(new CPublicKeyContext(*this,
                                                       pdwReserved,
                                                       dwFlags));
}

void
CPublicKeyContext::AuxPublicKey(SecureArray<BYTE> const &rabMsPublicKey)
{

    ClearAuxPublicKey();

    m_apabKey = rabMsPublicKey;
}

void
CPublicKeyContext::ClearAuxPublicKey()
{
    m_apabKey = SecureArray<BYTE>(0);
    if (m_hKey)
    {
        if (!CryptDestroyKey(m_hKey))
            throw OsException(GetLastError());
    }
}

void
CPublicKeyContext::Certificate(BYTE *pbData)
{

    bool fError = false;
    DWORD dwErrorCode = NO_ERROR;

    if (!pbData)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    DWORD dwAsn1Len = Asn1Length(pbData);
    if (0 == dwAsn1Len)
        throw scu::OsException(ERROR_INVALID_PARAMETER);
    Blob blbCert(pbData, dwAsn1Len);
    Pkcs11Attributes PkcsAttr(blbCert, AuxProvider());

    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    // Security: Since different tecniques are used to parse the
    // certificate, it's possible one may fail while the other
    // succeeds on a malformed certificate.  To reduce the possibility
    // of a bad cert on the card, the certificate parsing is completed
    // before the certificate is stored and final card data updates
    // are performed.
    CertificateExtensions CertExts(blbCert);
    bool fMakeDefaultCntr = false;
    CCard hcard(hsacntr->CardContext()->Card());
    if (CertExts.HasEKU(szOID_KP_SMARTCARD_LOGON) ||
        CertExts.HasEKU(szOID_ENROLLMENT_AGENT))
        fMakeDefaultCntr = true;
    else
    {
        //Check to see if this is the only container on the card and
        //make it the default if so. 
        std::vector<CContainer> vCntr = hcard->EnumContainers();
        if(vCntr.size() == 1)
            fMakeDefaultCntr = true;
        else if(vCntr.size() == 0)
            throw scu::OsException(NTE_BAD_KEYSET);
    }

    CKeyPair hkp(KeyPair());
    CPublicKey hpubkey(hkp->PublicKey());

    // Verify cert's modulus matches the public key's, if it exists
    bool fLoggedIn = false;

    if (hpubkey)
    {
        if (hcard->IsPKCS11Enabled() && hpubkey->Private())
        {
            m_rcryptctx.Login(User);
            fLoggedIn = true;
        }

        Blob bKeyModulus(::AsBlob(hpubkey->Modulus()));
        Blob bTrimmedModulus(bKeyModulus); // interoperability with V1
        TrimExtraZeroes(bTrimmedModulus);

        Blob bCertModulus(PkcsAttr.Modulus());
        reverse(bCertModulus.begin(), bCertModulus.end()); // little endian

        if (0 != bTrimmedModulus.compare(bCertModulus))
            throw scu::OsException(NTE_BAD_PUBLIC_KEY);
    }

    CCertificate hcert(hkp->Certificate());
    if (hcert)
        OkReplacingCredentials();

    if (!fLoggedIn)
    {
        bool fDoLogin = hcard->IsProtectedMode();

        // retrieve the private key handle only if PKCS11 enabled
        if (!fDoLogin && hcard->IsPKCS11Enabled())
        {
            // private key is checked now for login in preparation for
            // setting the PKCS11 attributes after the cert is stored
            CPrivateKey hprikey(hkp->PrivateKey());
            fDoLogin = ((hprikey && hprikey->Private()) || // always private?
                        (hcert && hcert->Private()));
        }

        if (fDoLogin)
        {
            m_rcryptctx.Login(User);
            fLoggedIn = true;
        }
    }

    if (hcert)
        ClearCertificate(hcert);
    
    hcert = CCertificate(hcard);
    hkp->Certificate(hcert);
    hcert->Value(AsString(blbCert));

    if (hcard->IsPKCS11Enabled())
        SetCertDerivedPkcs11Attributes(hkp, PkcsAttr);

    //if (fMakeDefaultCntr)
        hcard->DefaultContainer(hsacntr->TheCContainer());
}

Blob
CPublicKeyContext::Decrypt(Blob const &rCipher)
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    // TO DO: Is the explicit check really necessary, or can we catch
    // an exception from the CCI/IOP to indicate the key does not exist?
    CPrivateKey prikey(KeyPair()->PrivateKey());
    if (!prikey)
        throw scu::OsException(NTE_NO_KEY);

    m_rcryptctx.Login(User);

    return ::AsBlob(prikey->InternalAuth(AsString(rCipher)));
}

void
CPublicKeyContext::Decrypt(HCRYPTHASH hAuxHash,
                           BOOL Final,
                           DWORD dwFlags,
                           BYTE *pbData,
                           DWORD *pdwDataLen)
{
    throw scu::OsException(ERROR_NOT_SUPPORTED);
}

void
CPublicKeyContext::Generate(ALG_ID AlgoId,
                            DWORD dwFlags)
{    
    RsaKey::StrengthType strength;
    strength = HIWORD(dwFlags);
    if (0 == strength)
        strength = MaxStrength();                 // default strength
    else
    {
        if ((MaxStrength() < strength) ||
            (MinStrength() > strength))
            throw scu::OsException(ERROR_INVALID_PARAMETER);
    }

    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    CKeyPair hkp;
    PrepToStoreKey(hkp);

    RsaKeyPairGenerator GenKey(hkp->Card(), strength);

    m_rcryptctx.Login(User);                      // to create private key

    pair<cci::CPrivateKey, cci::CPublicKey> pr(GenKey());

    CPrivateKey hprikey(pr.first);
    CPublicKey hpubkey(pr.second);

    SetAttributes(hpubkey, hprikey, GenKey.OnCard(),
                  (dwFlags & CRYPT_EXPORTABLE) != 0);

    hkp->PrivateKey(hprikey);
    hkp->PublicKey(hpubkey);

    ClearAuxPublicKey();
}

void
CPublicKeyContext::ImportPrivateKey(MsRsaPrivateKeyBlob const &rmsprikb,
                                    bool fExportable)
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    CKeyPair hkp(hsacntr->TheCContainer()->GetKeyPair(m_ks));
    CPrivateKey hprikey(hkp->PrivateKey());

    CCard hcard(hkp->Card());

    m_rcryptctx.Login(User);

    if (!hprikey)
        hprikey = CPrivateKey(hkp->Card());

    hprikey->Value(*(AsPCciPrivateKeyBlob(rmsprikb).get()));
        
    SetAttributes(CPublicKey(), hprikey, false, fExportable);
    
    hkp->PrivateKey(hprikey);
}

void
CPublicKeyContext::ImportPublicKey(MsRsaPublicKeyBlob const &rmspubkb) 
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    CKeyPair hkp(hsacntr->TheCContainer()->GetKeyPair(m_ks));
    CPublicKey hpubkey(hkp->PublicKey());
            
    CCard hcard(hkp->Card());
    if (hcard->IsProtectedMode() ||
        (hcard->IsPKCS11Enabled() &&
         (hpubkey && hpubkey->Private())))
        m_rcryptctx.Login(User);

    if (hpubkey)
    {
        hpubkey->Delete();
        hpubkey = 0;
    }

    hpubkey = CPublicKey(AsPublicKey(Blob(rmspubkb.Modulus(),
                                          rmspubkb.Length()),
                                     rmspubkb.PublicExponent(),
                                     hcard));

    SetAttributes(hpubkey, CPrivateKey(), false, true);

    hkp->PublicKey(hpubkey);

    AuxPublicKey(rmspubkb.AsAlignedBlob());
    
}

void
CPublicKeyContext::ImportToAuxCSP()
{
    if (!m_hKey)
    {
        if (!m_apabKey.data())
            throw OsException(NTE_NO_KEY);
            
        if (!CryptImportKey(AuxProvider(), m_apabKey.data(),
                            m_apabKey.length(), 0, 0, &m_hKey))
            throw scu::OsException(GetLastError());
    }
}

void
CPublicKeyContext::Permissions(BYTE bPermissions)
{
    if (bPermissions & ~(CRYPT_DECRYPT | CRYPT_ENCRYPT |
                         CRYPT_EXPORT  | CRYPT_READ    |
                         CRYPT_WRITE))
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());
    
    CKeyPair hkp(KeyPair());
    CPublicKey hpubkey(hkp->PublicKey());
    CPrivateKey hprikey(hkp->PrivateKey());

    m_rcryptctx.Login(User);

    if (hprikey)
    {
        hprikey->Decrypt((CRYPT_DECRYPT & bPermissions) != 0);

        CCard hcard(hsacntr->CardContext()->Card());
        bool PKCS11Enabled = hcard->IsPKCS11Enabled();
        bool fExportable = (CRYPT_EXPORT & bPermissions) != 0;
        if (PKCS11Enabled)
            hprikey->NeverExportable(!fExportable);
        hprikey->Exportable(fExportable);
        hprikey->Modifiable((CRYPT_WRITE & bPermissions) != 0);

        bool fReadable = (CRYPT_READ & bPermissions) != 0;
        if (PKCS11Enabled)
            hprikey->NeverRead(!fReadable);
        hprikey->Read(fReadable);
    }

    if (hpubkey)
    {
        hpubkey->Encrypt((CRYPT_ENCRYPT & bPermissions) != 0);
        hpubkey->Modifiable((CRYPT_WRITE & bPermissions) != 0);
    }
}

    
// TO DO: Sign is an operation that's performed with the private key,
// not the public key.  Make Sign an operation on a PrivateKeyContext.
// string
Blob
CPublicKeyContext::Sign(CHashContext *pHash,
                        bool fNoHashOid)
{
    Blob Message(fNoHashOid
        ? pHash->Value()
        : pHash->EncodedValue());

    // TO DO: When CCI takes object parameters as references,
    // em can be const
    EncodedMessage em(Message, RsaKey::ktPrivate,
                      Strength() / numeric_limits<Blob::value_type>::digits);


    Blob blob(em.Value());
    reverse(blob.begin(), blob.end());            // convert to big endian

    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    // TO DO: Is the explicit check really necessary, or can we catch
    // an exception from the CCI/IOP to indicate the key does not exist?
    CPrivateKey hprikey(KeyPair()->PrivateKey());
    if (!hprikey)
        throw scu::OsException(NTE_NO_KEY);

    m_rcryptctx.Login(User);

    if (!hprikey->Sign())
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    return ::AsBlob(hprikey->InternalAuth(AsString(blob)));
}

void
CPublicKeyContext::VerifyKeyExists() const
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    CKeyPair hkp(KeyPair());
    if (!hkp->PublicKey() && !hkp->PrivateKey())
        throw scu::OsException(NTE_NO_KEY);
}

void
CPublicKeyContext::VerifySignature(HCRYPTHASH hHash,
                                   BYTE const *pbSignature,
                                   DWORD dwSigLen,
                                   LPCTSTR sDescription,
                                   DWORD dwFlags)
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    CPublicKey hpubkey(KeyPair()->PublicKey());
    if (!hpubkey)
        throw scu::OsException(NTE_NO_KEY);

    if (!hpubkey->Verify())
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    //
    // Import the Public key to the AUX Provider
    //
    if (!AuxKeyLoaded())
        AuxPublicKey(AsAlignedBlob(0, 0));
    
    ImportToAuxCSP();

    //
    // Verify the signature in the AUX CSP
    //
    if (!CryptVerifySignature(hHash, pbSignature, dwSigLen, GetKey(),
                              sDescription, dwFlags))
        throw scu::OsException(GetLastError());
}

                                                  // Access

SecureArray<BYTE>
CPublicKeyContext::AsAlignedBlob(HCRYPTKEY hDummy,
                                 DWORD dwDummy) const
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    if (hDummy)
        throw scu::OsException(ERROR_INVALID_PARAMETER);

    CPublicKey hpubkey(KeyPair()->PublicKey());
    if (!hpubkey)
        throw scu::OsException(NTE_NO_KEY);

    ALG_ID ai = (ksSignature == m_ks)
        ? CALG_RSA_SIGN
        : CALG_RSA_KEYX;

    CCard hcard(hsacntr->CardContext()->Card());
    if (hcard->IsPKCS11Enabled() && hpubkey->Private())
        m_rcryptctx.Login(User);

    MsRsaPublicKeyBlob kb(ai,
                          ::AsBlob(hpubkey->Exponent()),
                          RawModulus(::AsBlob(hpubkey->Modulus()),
                                     Strength()));

    return kb.AsAlignedBlob();
}

Blob
CPublicKeyContext::Certificate()
{
    Secured<HAdaptiveContainer> shacntr(m_rcryptctx.AdaptiveContainer());

    CKeyPair hkp(KeyPair());

    CCertificate hcert(hkp->Certificate());

    if (!hcert)
        throw scu::OsException(NTE_NOT_FOUND);

    if (hcert->Private())
        m_rcryptctx.Login(User);

    return ::AsBlob(hcert->Value());
}

DWORD
CPublicKeyContext::KeySpec() const
{
    return AsKeySpec(m_ks);
}

CPublicKeyContext::StrengthType
CPublicKeyContext::MaxStrength() const
{
    return MaxKeyStrength;
}

CPublicKeyContext::StrengthType
CPublicKeyContext::MinStrength() const
{
    return MinKeyStrength;
}

BYTE
CPublicKeyContext::Permissions() const
{
    Secured<HAdaptiveContainer> hsacntr(m_rcryptctx.AdaptiveContainer());

    VerifyKeyExists();

    CKeyPair hkp(KeyPair());
    CPublicKey hpubkey(hkp->PublicKey());
    CPrivateKey hprikey(hkp->PrivateKey());

    BYTE bPermissions = 0;
    if (hpubkey)
        bPermissions |= hpubkey->Encrypt()
            ? CRYPT_ENCRYPT
            : 0;

    if (hprikey)
    {
        bPermissions |= hprikey->Decrypt()
            ? CRYPT_DECRYPT
            : 0;

        bPermissions |= hprikey->Exportable()
            ? CRYPT_EXPORT
            : 0;

        bPermissions |= hprikey->Read()
            ? CRYPT_READ
            : 0;

        bPermissions |= hprikey->Modifiable()
            ? CRYPT_WRITE
            : 0;
    }

    return bPermissions;
}

CPublicKeyContext::StrengthType
CPublicKeyContext::Strength() const
{
    // TO DO: parameterize
    return KeyLimits<RsaKey>::cMaxStrength;
}


                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

CPublicKeyContext::CPublicKeyContext(CPublicKeyContext const &rhs,
                                     DWORD const *pdwReserved,
                                     DWORD dwFlags)
    : CKeyContext(rhs, pdwReserved, dwFlags),
      m_rcryptctx(rhs.m_rcryptctx),
      m_ks(rhs.m_ks)
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
bool
CPublicKeyContext::AuxKeyLoaded() const
{
    return (0 != m_apabKey.data());
}

                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

void
CPublicKeyContext::ClearCertificate(CCertificate &rhcert) const
{
    rhcert->Delete();
    rhcert = 0;
    if (AreLogonCredentials())
        m_rcryptctx.AdaptiveContainer()->CardContext()->Card()->DefaultContainer(0);
}

void
CPublicKeyContext::OkReplacingCredentials() const
{
    UINT uiStyle = MB_OKCANCEL | MB_ICONWARNING;
    UINT uiResourceId;
    if (AreLogonCredentials())
    {
        uiResourceId = IDS_REPLACE_LOGON;
        uiStyle |= MB_DEFBUTTON2;
    }
    else
        uiResourceId = IDS_REPLACE_CREDENTIALS;
    
    if (m_rcryptctx.GuiEnabled())
    {
        UINT uiResponse = PromptUser(m_rcryptctx.Window(),
                                     uiResourceId, uiStyle);

        switch (uiResponse)
        {
        case IDCANCEL:
            throw scu::OsException(ERROR_CANCELLED);
            break;

        case IDOK:
            break;
            
        default:
            throw scu::OsException(ERROR_INTERNAL_ERROR);
            break;
        };
    }
    else
        throw scu::OsException(NTE_EXISTS);
}

void
CPublicKeyContext::PrepToStoreKey(CKeyPair &rhkp) const
{
    CContainer hcntr(m_rcryptctx.AdaptiveContainer()->TheCContainer());

    // To the CCI, a key pair always exists, but this call means the
    // key pair is not empty.
    if (hcntr->KeyPairExists(m_ks))
        OkReplacingCredentials();

    rhkp = hcntr->GetKeyPair(m_ks);
    CPublicKey hpubkey(rhkp->PublicKey());
    CPrivateKey hprikey(rhkp->PrivateKey());
    CCertificate hcert(rhkp->Certificate());

    CCard hcard(hcntr->Card());
    if (hcard->IsProtectedMode() ||
        (hcard->IsPKCS11Enabled() &&
         ((hpubkey && hpubkey->Private()) ||
          (hprikey && hprikey->Private()) ||      // always private?
          (hcert && hcert->Private()))))
        m_rcryptctx.Login(User);

    if (hpubkey)
    {
        hpubkey->Delete();
        hpubkey = 0;
    }

    if (hprikey)
    {
        hprikey->Delete();
        hprikey = 0;
    }

    if (hcert)
        ClearCertificate(hcert);
}

Blob
CPublicKeyContext::Pkcs11CredentialId(Blob const &rbModulus) const
{
    // Hash the modulus
    AuxHash ah(AuxContext(AuxProvider()), CALG_MD5);

    return ah.Value(rbModulus);
}

Blob
CPublicKeyContext::Pkcs11Id(Blob const &rbRawModulus) const
{
    AuxHash ah(AuxContext(AuxProvider()), CALG_SHA1);

    return ah.Value(rbRawModulus);
}

// Set PKCS#11 attributes that are derived from the certificate
void
CPublicKeyContext::SetCertDerivedPkcs11Attributes(CKeyPair const &rhkp,
                                                  Pkcs11Attributes &rPkcsAttr)
    const
{
    string sLabel(rPkcsAttr.Label());
    string sSubject(rPkcsAttr.Subject());
    Blob bRawModulus(rPkcsAttr.RawModulus());
    Blob Id(Pkcs11Id(bRawModulus));

    CPublicKey hpubkey(rhkp->PublicKey());
    if (hpubkey)
    {
        hpubkey->ID(::AsString(Id));
        hpubkey->Label(sLabel);
        hpubkey->Subject(sSubject);
    }

    CPrivateKey hprikey(rhkp->PrivateKey());
    if (hprikey)
    {
        hprikey->ID(::AsString(Id));
        hprikey->Label(sLabel);
        hprikey->Subject(sSubject);
    }

    CCertificate hcert(rhkp->Certificate());
    hcert->ID(AsString(Id));
    hcert->Label(sLabel);
    hcert->Subject(sSubject);
    hcert->Issuer(::AsString(rPkcsAttr.Issuer()));
    hcert->Serial(::AsString(rPkcsAttr.SerialNumber()));
    hcert->Modifiable(true);

    hcert->CredentialID(::AsString(Pkcs11CredentialId(rPkcsAttr.Modulus())));

    Blob ContainerId(rPkcsAttr.ContainerId());
    m_rcryptctx.AdaptiveContainer()->TheCContainer()->ID(::AsString(ContainerId));
}

void
CPublicKeyContext::SetAttributes(CPublicKey &rhpubkey,
                                 CPrivateKey &rhprikey,
                                 bool fLocal,
                                 bool fExportable) const
{
    // TO DO: A kludge.  The old CSP format (V1) doesn't support
    // setting key attributes but there isn't an easy way to tell
    // which format is being used.  (Should have some call to get the
    // format characteristics).  Since CCI's V1 throws
    // ccNotImplemented when calling one of the unsupported routines,
    // a try/catch is used to ignore that exception to assume the V1
    // format is used.
    bool fContinueSettingAttributes = true;
    try
    {
        // The public or the private key could by nil,
        // so do both.
        if (rhpubkey)
            rhpubkey->Encrypt(true);

        if (rhprikey)
            rhprikey->Decrypt(true);
    }
    
    catch (cci::Exception &rExc)
    {
        if (ccNotImplemented == rExc.Cause())
            fContinueSettingAttributes = false;
        else
            throw;
    }

    if (fContinueSettingAttributes)
    {
        if (rhpubkey)
        {
            rhpubkey->Derive(true);
            rhpubkey->Local(fLocal);
            rhpubkey->Modifiable(true);
            rhpubkey->Verify(true);
        }

        if (rhprikey)
        {
            rhprikey->Local(fLocal);
            rhprikey->Modifiable(true);
            rhprikey->Sign(true);
    
            rhprikey->Exportable(fExportable);
            rhprikey->Read(false);
        }

        if (rhpubkey && rhpubkey->Card()->IsPKCS11Enabled())
            SetPkcs11Attributes(rhpubkey, rhprikey);
    }
}

void
CPublicKeyContext::SetPkcs11Attributes(CPublicKey &rhpubkey,
                                       CPrivateKey &rhprikey) const
{
    Blob bBEModulus(::AsBlob(rhpubkey->Modulus()));
    reverse(bBEModulus.begin(), bBEModulus.end());    // make big endian
    string sCredentialId(::AsString(Pkcs11CredentialId(bBEModulus)));

    rhpubkey->CKInvisible(false);
    rhpubkey->CredentialID(sCredentialId);
    rhpubkey->VerifyRecover(true);
    rhpubkey->Wrap(true);

    if (rhprikey)
    {
        rhprikey->CredentialID(sCredentialId);
        rhprikey->Derive(true);
        rhprikey->SignRecover(true);
        rhprikey->Unwrap(true);

        rhprikey->NeverExportable(!rhprikey->Exportable());
        rhprikey->NeverRead(!rhprikey->Read());

        rhprikey->Modulus(rhpubkey->Modulus());
        rhprikey->PublicExponent(rhpubkey->Exponent());
    }
    
}

                                                  // Access

CKeyPair
CPublicKeyContext::KeyPair() const
{
    return m_rcryptctx.AdaptiveContainer()->TheCContainer()->GetKeyPair(m_ks);
}


                                                  // Predicates
bool
CPublicKeyContext::AreLogonCredentials() const
{
    HAdaptiveContainer hacntr(m_rcryptctx.AdaptiveContainer());
    return (ksExchange == m_ks) &&
        (hacntr->TheCContainer() ==
         hacntr->CardContext()->Card()->DefaultContainer());
}

                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\publickeyhelper.h ===
// PublicKeyHelper.h -- declarations of CCI public key helpers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_PUBLICKEYHELPER_H)
#define SLBCSP_PUBLICKEYHELPER_H

#include <windows.h>

#include <cciPubKey.h>

#include "Blob.h"

///////////////////////////   HELPERS   /////////////////////////////////

cci::CPublicKey
AsPublicKey(Blob const &rblbModulus,              // little endian
            DWORD dwExponent,
            cci::CCard &rhcard);

cci::CPublicKey
AsPublicKey(Blob const &rblbModulus,              // little endian
            Blob const &rblbExponent,             // little endian
            cci::CCard &rhcard);

// return the blob trimmed of extra zeroes.  The blob is assumed to
// represent an unsigned integer of arbitrary size in little endian
// format.  Thus the trailing zeroes are removed.
void
TrimExtraZeroes(Blob &rblob);

#endif // SLBCSP_PUBLICKEYHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\publickeyhelper.cpp ===
// PublicKeyHelper.cpp -- Helper routines to deal with CCI public keys

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "PublicKeyHelper.h"

using namespace cci;

///////////////////////////    HELPERS    /////////////////////////////////

CPublicKey
AsPublicKey(Blob const &rblbModulus,              // little endian
            DWORD dwExponent,
            cci::CCard &rhcard)
{
    Blob blbExponent(reinterpret_cast<Blob::value_type *>(&dwExponent),
                     sizeof dwExponent);

    return AsPublicKey(rblbModulus, blbExponent, rhcard);
}

CPublicKey
AsPublicKey(Blob const &rblbModulus,              // little endian
            Blob const &rblbExponent,             // little endian
            CCard &rhcard)
{
    Blob blbTmpModulus(rblbModulus);
    Blob blbTmpExponent(rblbExponent);
    if (rhcard->IsPKCS11Enabled())
    {
        // store modulus and exponent compressed
        TrimExtraZeroes(blbTmpModulus);
        TrimExtraZeroes(blbTmpExponent);
    }

    CPublicKey hpubkey(rhcard);
    hpubkey->Modulus(AsString(blbTmpModulus));
    hpubkey->Exponent(AsString(blbTmpExponent));

    return hpubkey;
}


void
TrimExtraZeroes(Blob &rblob)
{
    Blob::size_type const cLength = rblob.length();
    if (0 != cLength)
    {
        Blob::value_type const Zero = 0;
        Blob::size_type const cLastNonZero =
        rblob.find_last_not_of(Zero);         // little endian
        Blob::size_type const cLastPos = cLength - 1;
        if (cLastPos != cLastNonZero)
        {
            Blob::size_type cCharToKeep =
                (Blob::npos == cLastNonZero)
                 ? 0
                 : cLastNonZero + 1;
            if (cLastPos != cCharToKeep)         // keep one zero
                rblob.erase(cCharToKeep + 1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pswddlg.cpp ===
// PswdDlg.cpp -- PaSsWorD DiaLoG class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "stdafx.h"

#include <scuOsExc.h>

#include "slbCsp.h"
#include "LoginId.h"
#include "AccessTok.h"
#include "PswdDlg.h"
#include "PromptUser.h"
#include "StResource.h"

#include "CspProfile.h"

using namespace ProviderProfile;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BEGIN_MESSAGE_MAP(CLogoDialog, CDialog)
    //{{AFX_MSG_MAP(CLogoDialog)
	ON_WM_PAINT()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogoDialog dialog


CLogoDialog::CLogoDialog(CWnd* pParent /*=NULL*/)
    : CDialog(),
	  m_dcMem(),
	  m_dcMask(),
	  m_bmpLogo(),
	  m_bmpMask(),
	  m_hBmpOld(),
	  m_hBmpOldM(),
	  m_pt(0,0),
	  m_size()

{
    m_pParent = pParent;
}
////////////////////////////////////////////////////////////////////////////
// CLogoDialog message handlers

BOOL CLogoDialog::OnInitDialog()
{
	CBitmap * pBmpOld, * pBmpOldM;
	HINSTANCE oldHandle = NULL;
    BOOL fSuccess = TRUE;
    
	try {
		
		CDialog::OnInitDialog();
		
		// Load bitmap resource - remember to call DeleteObject when done.
		oldHandle = AfxGetResourceHandle();
		AfxSetResourceHandle(CspProfile::Instance().Resources());
		m_bmpLogo.LoadBitmap( MAKEINTRESOURCE( IDB_BITMAP_SLBLOGO ) );
		m_bmpMask.LoadBitmap( MAKEINTRESOURCE( IDB_BITMAP_SLBLOGO ) );
		
		// Get bitmap information    
		m_bmpLogo.GetObject( sizeof(BITMAP), &m_bmInfo );
		m_size.cx = m_bmInfo.bmWidth;
		m_size.cy = m_bmInfo.bmHeight;
		
		// Get temporary DC for dialog - Will be released in dc destructor
		CClientDC dc(this);
		
		// Create compatible memory DC using the dialogs DC
		m_dcMem.CreateCompatibleDC( &dc );
		m_dcMask.CreateCompatibleDC( &dc );
				
		// Select logo bitmap into DC.  
		// Get pointer to original bitmap
		// NOTE! This is temporary - save the handle instead
		pBmpOld = m_dcMem.SelectObject( &m_bmpLogo );
		
		SetBkColor(m_dcMem, RGB(255, 255, 255));
		m_dcMask.BitBlt (0, 0, m_size.cx, m_size.cy, &m_dcMem, 0, 0, SRCCOPY);
		
		pBmpOldM = m_dcMask.SelectObject( &m_bmpMask );
		
		m_hBmpOld = (HBITMAP) pBmpOld->GetSafeHandle();
		m_hBmpOldM = (HBITMAP) pBmpOldM->GetSafeHandle();
	}

	catch (...)
    {
        fSuccess = FALSE;
	}

    if (oldHandle)
        AfxSetResourceHandle(oldHandle);

	return fSuccess;
}

//***********************************************************************
// CLogoDialog::OnPaint()
//
// Purpose:
//
//        BitBlt() bitmap stored in compatible memory DC into dialogs
//        DC to display at hardcoded location.
//
// Parameters:
//
//        None.
//
// Returns:
//
//        None.
//
// Comments:
//
// History:
//
//***********************************************************************

void CLogoDialog::OnPaint()
{
    CPaintDC dc(this); // device context for painting

    // BitBlt logo bitmap onto dialog using transparancy masking

    dc.SetBkColor(RGB(255, 255, 255));      // 1s --> 0xFFFFFF
    dc.SetTextColor(RGB(0, 0, 0));          // 0s --> 0x000000

   // Do the real work.
    dc.BitBlt(m_pt.x, m_pt.y, m_size.cx, m_size.cy, &m_dcMem, 0, 0, SRCINVERT);
    dc.BitBlt(m_pt.x, m_pt.y, m_size.cx, m_size.cy, &m_dcMask, 0, 0, SRCAND);
    dc.BitBlt(m_pt.x, m_pt.y, m_size.cx, m_size.cy, &m_dcMem, 0, 0, SRCINVERT);

    /*
     * First two parameters are upper left position to place bitmap.
     * Third and fourth parameters are width and height to copy 
     * (could be less than actual size of bitmap)
     * Sixth and seventh are position in memory dc to start from
     * SRCCOPY specifies copy.
     * See BitBlt documentation for more details.
     */

     // Do not call CDialog::OnPaint() for painting messages
}


//***********************************************************************
// CLogoDialog::OnDestroy()
//
// Purpose:
//
//      Select old bitmap back into memory DC before it is destroyed
//      when CLogoDialog object is.
//      DeleteObject() the bitmap which had been loaded.
//
// Parameters:
//
//        None.
//
// Returns:
//
//        None.
//
// Comments:
//
// History:
//
//
void CLogoDialog::OnDestroy()
{
    CDialog::OnDestroy();
    
    // Select old bitmap into memory dc (selecting out logo bitmap)
    // Need to create a temporary pointer to pass to do this
	
    if (m_hBmpOld && m_dcMem)
        m_dcMem.SelectObject(CBitmap::FromHandle(m_hBmpOld));

	if (m_hBmpOldM && m_dcMem)
        m_dcMask.SelectObject(CBitmap::FromHandle(m_hBmpOldM));

    
    // Need to DeleteObject() the bitmap that was loaded
    m_bmpLogo.DeleteObject();
    m_bmpMask.DeleteObject();


    // m_dcMem and m_dcMask destructor will handle rest of cleanup    
}

            
/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
    : CLogoDialog(pParent),
      m_szPassword(_T("")),
      m_szMessage(_T("")),
      m_fHexCode(FALSE),
      m_bChangePIN(FALSE),
      m_lid(User),      // the default
      m_nPasswordSizeLimit(AccessToken::MaxPinLength)
{
    m_pParent = pParent;
	m_pt.x = 144;
	m_pt.y = 88;
}

BEGIN_MESSAGE_MAP(CPasswordDlg, CLogoDialog)
    //{{AFX_MSG_MAP(CPasswordDlg)
    ON_BN_CLICKED(IDC_HEXCODE, OnClickHexCode)
    ON_BN_CLICKED(IDC_CHANGEPIN, OnChangePINAfterLogin)
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
    CLogoDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPasswordDlg)
    DDX_Control(pDX, IDC_HEXCODE, m_ctlCheckHexCode);
    DDX_Control(pDX, IDC_CHANGEPIN, m_ctlCheckChangePIN);
//    DDX_Control(pDX, IDC_EDIT_VERNEWPIN, m_ctlVerifyNewPIN);
//    DDX_Control(pDX, IDC_EDIT_NEWPIN, m_ctlNewPIN);
//    DDX_Control(pDX, IDC_STATIC_VERNEWPIN, m_ctlVerifyPINLabel);
//    DDX_Control(pDX, IDC_STATIC_NEWPIN, m_ctlNewPINLabel);
    DDX_Text(pDX, IDC_PASSWORD, m_szPassword);
    DDV_MaxChars(pDX, m_szPassword, m_nPasswordSizeLimit);
	LPCTSTR pBuffer = (LPCTSTR) m_szMessage;
	if(!m_szMessage.IsEmpty())
	{
		DDX_Text(pDX, IDC_MESSAGE, (LPTSTR)pBuffer, m_szMessage.GetLength());
	}
    DDX_Check(pDX, IDC_CHANGEPIN, m_bChangePIN);
//    DDX_Text(pDX, IDC_EDIT_NEWPIN, m_csNewPIN);
//    DDX_Text(pDX, IDC_EDIT_VERNEWPIN, m_csVerifyNewPIN);
    //}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg message handlers

BOOL CPasswordDlg::OnInitDialog()
{

	CLogoDialog::OnInitDialog();
        

    switch (m_lid)
    {
    case User:
        // Give the user a chance to change the PIN
        m_ctlCheckChangePIN.ShowWindow(SW_SHOW);
		{
			m_szMessage = StringResource(IDS_ENTER_PIN).AsCString();
		}
        break;

    case Manufacturer:
        // Allow Hex string entry
        m_ctlCheckHexCode.ShowWindow(SW_SHOW);
		{
			m_szMessage = StringResource(IDS_ENTER_MANUFACTURER_KEY).AsCString();
		}
        break;

    case Administrator:
        // Allow Hex string entry
        m_ctlCheckHexCode.ShowWindow(SW_SHOW);
		{
			m_szMessage = StringResource(IDS_ENTER_ADMIN_KEY).AsCString();
		}
        break;

    default:
        break;

    };

    // Update GUI with changes
    UpdateData(FALSE);
    SetForegroundWindow();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPasswordDlg::OnClickHexCode()
{
    m_fHexCode = ~m_fHexCode;
    m_nPasswordSizeLimit = (m_fHexCode)
        ? AccessToken::MaxPinLength * 2
        : AccessToken::MaxPinLength;
    UpdateData(FALSE);
}

void CPasswordDlg::OnOK()
{
    UpdateData();

    CString msg;
    bool fPrompt = true;
    
    if (m_fHexCode && m_szPassword.GetLength() != m_nPasswordSizeLimit)
    {
        msg.Format((LPCTSTR)StringResource(IDS_PIN_NOT_CONFORM).AsCString(),
                   m_nPasswordSizeLimit);
    }
    else if ((User == m_lid) && (0 == m_szPassword.GetLength()))
    {
        msg = (LPCTSTR)StringResource(IDS_PIN_NOT_CONFORM).AsCString();
    }
    else
        fPrompt = false;

    if (fPrompt)
    {
        HWND hWnd = m_pParent
            ? m_pParent->m_hWnd
            : NULL;
        int iResponse = PromptUser(hWnd, msg,
                                   MB_OK | MB_ICONERROR);
        if (IDCANCEL == iResponse)
            throw scu::OsException(ERROR_CANCELLED);
    }
    else
        CLogoDialog::OnOK();
}

void CPasswordDlg::OnChangePINAfterLogin()
{
    UpdateData(); // set m_bChangePIN

   int nShowWindow = (m_bChangePIN) ? SW_SHOW : SW_HIDE;

/*
    m_ctlVerifyNewPIN.ShowWindow(nShowWindow);
    m_ctlNewPIN.ShowWindow(nShowWindow);
    m_ctlVerifyPINLabel.ShowWindow(nShowWindow);
    m_ctlNewPINLabel.ShowWindow(nShowWindow);
*/
}

void CPasswordDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CLogoDialog::OnShowWindow(bShow, nStatus);


}


/////////////////////////////////////////////////////////////////////////////
// CChangePINDlg dialog


CChangePINDlg::CChangePINDlg(CWnd* pParent /*=NULL*/)
    : CLogoDialog(pParent),
      m_csOldPIN(_T("")),
      m_csNewPIN(_T("")),
      m_csVerifyNewPIN(_T(""))

{
    m_pParent = pParent;
	m_pt.x = 144; // 132;
	m_pt.y = 75; //104;
}


void CChangePINDlg::DoDataExchange(CDataExchange* pDX)
{
    CLogoDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangePINDlg)
    DDX_Control(pDX, IDC_STATIC_CONFIRM_OLDPIN_LABEL, m_ctlConfirmOldPINLabel);
    DDX_Control(pDX, IDC_EDIT_OLDPIN, m_ctlOldPIN);
    DDX_Text(pDX, IDC_EDIT_OLDPIN, m_csOldPIN);
    DDV_MaxChars(pDX, m_csOldPIN, AccessToken::MaxPinLength);
    DDX_Text(pDX, IDC_EDIT_NEWPIN, m_csNewPIN);
    DDV_MaxChars(pDX, m_csNewPIN, AccessToken::MaxPinLength);
    DDX_Text(pDX, IDC_EDIT_VERNEWPIN, m_csVerifyNewPIN);
    DDV_MaxChars(pDX, m_csVerifyNewPIN, AccessToken::MaxPinLength);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangePINDlg, CLogoDialog)
    //{{AFX_MSG_MAP(CChangePINDlg)
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePINDlg message handlers

// The purpose of the Change PIN dialog is for changing User Pins.
// It may be invoked after having already authenticated, or prior
// to authentication. In the former case it is recommended that the
// caller will have set the m_csOldPIN data member prior to calling
// DoModal(). This is so the user will not have to reenter a PIN
// that has previously been entered.

BOOL CChangePINDlg::OnInitDialog()
{
    CLogoDialog::OnInitDialog();

    SetForegroundWindow();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CChangePINDlg::OnOK()
{
    UpdateData();

    UINT uiMsgId;
    bool fMsgIdSet = false;

    // Verify that the New PIN contains only ASCII characters
    if(!StringResource::IsASCII((LPCTSTR)m_csNewPIN))
    {
        uiMsgId = IDS_PIN_NOT_CONFORM;
        fMsgIdSet = true;
    }
    // Verify that the New PIN and Verify PIN are the same
    else if (m_csNewPIN != m_csVerifyNewPIN)
    {
        uiMsgId = IDS_PIN_VER_NO_MATCH;
        fMsgIdSet = true;
    }
    // Verify that the length of the new PIN is >= 1
    else if (0 == m_csNewPIN.GetLength())
    {
        uiMsgId = IDS_PIN_NOT_CONFORM;
        fMsgIdSet = true;
    }
    // Verify that the length of the old PIN is >= 1
    else if (0 == m_csOldPIN.GetLength())
    {
        uiMsgId = IDS_PIN_NOT_CONFORM;
        fMsgIdSet = true;
    }

    if (fMsgIdSet)
    {
        HWND hWnd = m_pParent
            ? m_pParent->m_hWnd
            : NULL;
        int iResponse = PromptUser(hWnd, uiMsgId,
                                   MB_OK | MB_ICONSTOP);

        if (IDCANCEL == iResponse)
            throw scu::OsException(ERROR_CANCELLED);
    }
    else
        CLogoDialog::OnOK();
}


void CChangePINDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CLogoDialog::OnShowWindow(bShow, nStatus);

    // if the caller placed something in the m_csOldPIN
    // prior to DoModal'ing, then don't show that control,
    // so that the user won't accidentally erase the preset,
    // current PIN
    if (m_csOldPIN.GetLength())
    {
        m_ctlOldPIN.ShowWindow(FALSE);
        m_ctlConfirmOldPINLabel.ShowWindow(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\registrar.h ===
// Registrar.h -- Registrar template class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_REGISTRAR_H)
#define SLBCSP_REGISTRAR_H

#include <map>
#include <functional>
#include <algorithm>

#include "Guarded.h"
#include "Registry.h"
#include "MasterLock.h"

template<class Key, class T, class Cmp = std::less<Key> >
class Registrar
{
public:
                                                  // Types
    typedef T *EnrolleeType;
    typedef Key KeyType;
    typedef std::map<Key, EnrolleeType, Cmp> CollectionType;
    typedef Registry<CollectionType> RegistryType;
    typedef Registry<CollectionType const> ConstRegistryType;

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    // Removes the enrollee identified by the key from the registry.
    static void
    Discard(Key const &rkey);

    // Return the enrollee identified by the key, creating it if it
    // doesn't exist.
    static EnrolleeType
    Instance(Key const &rkey);

                                                  // Access
    // Return the enrollee identified by the key if it exists, 0 otherwise.
    static EnrolleeType
    Find(Key const &rKey);

    static ConstRegistryType &
    Registry();

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Registrar(Key const &rkey); // allow subclassing

    virtual
    ~Registrar() = 0; // make base abstract


                                                  // Operators
                                                  // Operations
    // Puts the enrollee into the registry identified by the key if
    // not already listed.
    static void
    Enroll(Key const &rkey,
           EnrolleeType enrollee);
    // Removes an entry from the registry.
    static void
    RemoveEnrollee(Key const &rkey);

    // Inserts an entry into the registry.
    static void
    InsertEnrollee(Key const &rkey, EnrolleeType enrollee);


    // Operation to perform after removing the enrollee from the
    // registry.  Default does nothing.
    virtual void
    DiscardHook();


    // Subclass must define
    // Factory Method, operation returning a new enrollee for the key
    static EnrolleeType
    DoInstantiation(Key const &rkey);

    // Operation to perform after putting the enrollee into the
    // registry.  Default does nothing.
    virtual void
    EnrollHook();

                                                  // Access
                                                  // Predicates
    // Returns true if the enrollee should remain in the registry;
    // false otherwise.  Default returns true.
    virtual bool
    KeepEnrolled();

                                                  // Static Variables
                                                  // Variables

private:
                                                  // Types
    typedef Registrar<Key, T, Cmp> *BaseType;
    typedef __TYPENAME CollectionType::iterator Iterator;
    typedef __TYPENAME CollectionType::value_type ValueType;



                                                  // C'tors/D'tors
    Registrar(Registrar const &); // don't allow copies

                                                  // Operators
    Registrar<Key, T> &
    operator=(Registrar const &); // don't allow initialization

                                                  // Operations
    static void
    Discard(Iterator const &rit);

    static void
    RemoveEnrollee(Iterator const &rit);

    static EnrolleeType
    FindEnrollee(Key const &rkey);

    static void
    SetupRegistry();

                                                  // Access
    static CollectionType &
    Collection();

                                                  // Predicates
    static bool
    PassesReview(EnrolleeType enrollee);

                                                  // Variables
    static RegistryType *m_pregistry;
};

/////////////////////////  TEMPLATE METHODS  ///////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::Discard(Key const &rkey)
{
    if (m_pregistry)
    {
        Guarded<RegistryType *> gregistry(m_pregistry); // serialize registry access

        CollectionType &rcollection = Collection();
        Iterator it = rcollection.find(rkey);

        if (rcollection.end() != it)
            Discard(it);
    }
}

template<class Key, class T, class Cmp>
__TYPENAME Registrar<Key, T, Cmp>::EnrolleeType
Registrar<Key, T, Cmp>::Instance(Key const &rkey)
{
    // The Template Method pattern is used to allow the instantiator
    // of the template to specify how the the enrollee is found and,
    // if necessary, created.  Template Method can be found in "Design
    // Patterns: Elements of Reusable Object-Oriented Software,"
    // Gamma, Helm, Johnson, Vlissides, Addison-Wesley

    SetupRegistry();

    Guarded<RegistryType *> gregistry(m_pregistry);   // serialize registry access

    EnrolleeType enrollee = FindEnrollee(rkey);
    if (EnrolleeType() == enrollee)
    {
        enrollee = T::DoInstantiation(rkey);
        Enroll(rkey, enrollee);
    }

    return enrollee;
}

                                                  // Access
template<class Key, class T, class Cmp>
__TYPENAME Registrar<Key, T, Cmp>::EnrolleeType
Registrar<Key, T, Cmp>::Find(Key const &rkey)
{
    EnrolleeType enrollee = EnrolleeType();

    if (m_pregistry)
    {
        Guarded<RegistryType *> guard(m_pregistry); // serialize registry access

        enrollee = FindEnrollee(rkey);
    }

    return enrollee;
}

template<class Key, class T, class Cmp>
__TYPENAME Registrar<Key, T, Cmp>::ConstRegistryType &
Registrar<Key, T, Cmp>::Registry()
{
    SetupRegistry();

    // this "safe" cast is necessary to enforce the constness of the collection
    return reinterpret_cast<ConstRegistryType &>(*m_pregistry);
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
template<class Key, class T, class Cmp>
Registrar<Key, T, Cmp>::Registrar(Key const &rkey)
{}

template<class Key, class T, class Cmp>
Registrar<Key, T, Cmp>::~Registrar()
{}

                                                  // Operators
                                                  // Operations
template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::DiscardHook()
{}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::EnrollHook()
{}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::RemoveEnrollee(Key const &rkey)
{
    if (m_pregistry)
    {
        Guarded<RegistryType *> gregistry(m_pregistry); // serialize registry access

        CollectionType &rcollection = Collection();
        Iterator it = rcollection.find(rkey);

        if (rcollection.end() != it)
            RemoveEnrollee(it);
    }
}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::InsertEnrollee(Key const &rkey,
                                       __TYPENAME Registrar<Key, T, Cmp>::EnrolleeType enrollee)
{
    ValueType registration(rkey, enrollee);
    Guarded<RegistryType *> guard(m_pregistry); // serialize registry access
    Collection().insert(registration);
}

                                                  // Access
                                                  // Predicates
template<class Key, class T, class Cmp>
bool
Registrar<Key, T, Cmp>::KeepEnrolled()
{
    return true;
}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::Enroll(Key const &rkey,
                               __TYPENAME Registrar<Key, T, Cmp>::EnrolleeType enrollee)
{
    Guarded<RegistryType *> guard(m_pregistry); // serialize registry access

    InsertEnrollee(rkey, enrollee);

    BaseType base = enrollee;
    base->EnrollHook();
}


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::Discard(__TYPENAME Registrar<Key, T, Cmp>::Iterator const &rit)
{
    BaseType base = rit->second;
    RemoveEnrollee(rit);
    base->DiscardHook();
}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::RemoveEnrollee(__TYPENAME Registrar<Key, T, Cmp>::Iterator const &rit)
{
    Collection().erase(rit);
}

template<class Key, class T, class Cmp>
__TYPENAME Registrar<Key, T, Cmp>::EnrolleeType
Registrar<Key, T, Cmp>::FindEnrollee(Key const &rkey)
{
    EnrolleeType enrollee = EnrolleeType();

    CollectionType &rcollection = Collection();
    if (!rcollection.empty())
    {
        Iterator it = rcollection.find(rkey);
        if (rcollection.end() != it)
        {
            enrollee = it->second;

            if (!PassesReview(enrollee))
            {
                Discard(it);
                enrollee = EnrolleeType();
            }
        }
    }

    return enrollee;
}

template<class Key, class T, class Cmp>
void
Registrar<Key, T, Cmp>::SetupRegistry()
{
    // Use Double-Checked Lock pattern for proper setup in the case of
    // preemptive multi-threading
    if (!m_pregistry)
    {
        Guarded<Lockable *> gmaster(&TheMasterLock());
        if (!m_pregistry)
            m_pregistry = new RegistryType;
    }

}

                                                  // Access
template<class Key, class T, class Cmp>
__TYPENAME Registrar<Key, T, Cmp>::CollectionType &
Registrar<Key, T, Cmp>::Collection()
{
    return (*m_pregistry)();
}

                                                  // Predicates
template<class Key, class T, class Cmp>
bool
Registrar<Key, T, Cmp>::PassesReview(__TYPENAME Registrar<Key, T, Cmp>::EnrolleeType enrollee)
{
    bool fPassed = false;
    if (EnrolleeType() != enrollee)
    {
        BaseType base = enrollee;
        fPassed = base->KeepEnrolled();
    }

    return fPassed;
}

#endif // SLBCSP_REGISTRAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\pubkeyctx.h ===
// PubKeyCtx.h -- declaration of CPublicKeyContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_PUBKEYCTX_H)
#define SLBCSP_PUBKEYCTX_H

#include <cciCont.h>
#include <cciCert.h>

#include "KeyContext.h"
#include "MsRsaPriKB.h"
#include "MsRsaPubKB.h"

class CryptContext;
class CHashContext;
class Pkcs11Attributes;

class CPublicKeyContext
    : public CKeyContext
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    CPublicKeyContext(HCRYPTPROV hProv,
                      CryptContext &rcryptctx,
                      ALG_ID algid = 0,
                      bool fVerifyKeyExists = true);

    ~CPublicKeyContext();

                                                  // Operators
                                                  // Operations

    virtual std::auto_ptr<CKeyContext>
    Clone(DWORD const *pdwReserved,
          DWORD dwFlags) const;

	virtual void
	AuxPublicKey(scu::SecureArray<BYTE> const &rabMsPublicKey);

    void
    ClearAuxPublicKey();

    virtual void
    Certificate(BYTE *pbData);

    virtual Blob
    Decrypt(Blob const &rblbCipher);

    virtual void
    Decrypt(HCRYPTHASH hAuxHash,
            BOOL Final,
            DWORD dwFlags,
            BYTE *pbData,
            DWORD *pdwDataLen);

    virtual void
    Generate(ALG_ID AlgoId,
             DWORD dwFlags);

    virtual void
    ImportPrivateKey(MsRsaPrivateKeyBlob const &rmsprikb,
                     bool fExportable);

    virtual void
    ImportPublicKey(MsRsaPublicKeyBlob const &rmspubkb);

    virtual void
    Permissions(BYTE bPermissions);

    virtual Blob
    Sign(CHashContext *pHash,
         bool fNoHashOid);

    // Auxiliary CSP communication
    virtual
    void ImportToAuxCSP(void);

    void
    VerifyKeyExists() const;

    void
    VerifySignature(HCRYPTHASH hHash,
                    BYTE const *pbSignature,
                    DWORD dwSigLen,
                    LPCTSTR sDescription,
                    DWORD dwFlags);

                                                  // Access

    virtual scu::SecureArray<BYTE>
    AsAlignedBlob(HCRYPTKEY hDummy,
                  DWORD dwBlobType) const;

    virtual DWORD
    KeySpec() const;

    virtual StrengthType
    MaxStrength() const;

    virtual StrengthType
    MinStrength() const;

    virtual BYTE
    Permissions() const;

    virtual StrengthType
    Strength() const;

    virtual Blob
    Certificate();

                                                  // Predicates
    bool
    AuxKeyLoaded() const;
    
protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate key context and its current state
    CPublicKeyContext(CPublicKeyContext const &rhs,
                      DWORD const *pdwReserved,
                      DWORD dwFlags);

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
    enum
    {
    // These constants are defined as enums since VC 6.0 doesn't
    // support use of initializer specified in const declarations.

        MaxKeyStrength = 1024,                    // US Export
                                                  // restricted, do
                                                  // not change

        MinKeyStrength = 1024,                    // Only support one
                                                  // strength
    };

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    ClearCertificate(cci::CCertificate &rhcert) const;
    
    void
    OkReplacingCredentials() const;

    void
    PrepToStoreKey(cci::CKeyPair &rkp) const;

    void
    SetAttributes(cci::CPublicKey &rhpubkey, // always non-zero
                  cci::CPrivateKey &rhprikey,
                  bool fLocal,
                  bool fExportable) const;

    void
    SetCertDerivedPkcs11Attributes(cci::CKeyPair const &rkp,
                                   Pkcs11Attributes &rPkcsAttr) const;

    void
    SetPkcs11Attributes(cci::CPublicKey &rpubkey,
                        cci::CPrivateKey &rprikey) const;

                                                  // Access

    cci::CKeyPair
    KeyPair() const;

    Blob
    Pkcs11Id(Blob const &rbModulus) const;

    Blob
    Pkcs11CredentialId(Blob const &rbModulus) const;

                                                  // Predicates
    bool
    AreLogonCredentials() const;
    
                                                  // Variables
    CryptContext &m_rcryptctx;
    cci::KeySpec m_ks;

};

#endif // SLBCSP_PUBKEYCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\retainable.h ===
// Retainable.h -- Retainable class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_RETAINABLE_H)
#define SLBCSP_RETAINABLE_H

// Abstract base class mixin (interface) used by derived classes to
// define the interface to retain an object (block all other
// applications from access until interactions with that resource are
// complete).  See the companion Retained template class to manage the
// resources derived from Retainable.
class Retainable
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    Retainable();

    virtual
    ~Retainable() = 0;
                                                  // Operators
                                                  // Operations
    // Give up control of the resource.
    virtual void
    Relinquish() = 0;

    // Obtain control of the resource, blocking all others from use.
    virtual void
    Retain() = 0;

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};


#endif // SLBCSP_RETAINABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\registry.h ===
// Registry.h -- Registry template class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_REGISTRY_H)
#define SLBCSP_REGISTRY_H

#include "Lockable.h"
#include "Guarded.h"
#include "MapUtility.h"

// Companion to Registrar, the Registry template class maintains a
// collection of T pointers indexed by Key.
template<typename Collection>
class Registry
    : public Lockable
{
public:
                                                  // Types
    typedef Collection CollectionType;

                                                  // C'tors/D'tors
    // Constructs the registry.  If fSetup is true, then space is
    // allocated for the registry; otherwise operator() will return 0
    // until Setup is called.  This supports lazy initialization.
    explicit
    Registry();

    ~Registry();

                                                  // Operators
    CollectionType &
    operator()();

                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
    Registry(Registry const &rhs); // not defined, copying not allowed

                                                  // Operators
    Registry &
    operator=(Registry const &rhs); // not defined, assignment not allowed

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    CollectionType m_collection;

};

/////////////////////////  TEMPLATE METHODS  ///////////////////////////////

/////////////////////////////// HELPERS ///////////////////////////////////

template<class C, class Op>
void
ForEachEnrollee(Registry<C const> &rRegistry,
                Op &rProc)
{
    Guarded<Lockable *> guard(&rRegistry);        // serialize registry access

    C const &rcollection = (rRegistry)();

    ForEachMappedValue(rcollection.begin(), rcollection.end(),
                       rProc);
}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<typename Collection>
Registry<Collection>::Registry()
    : Lockable(),
      m_collection()
{}

template<typename Collection>
Registry<Collection>::~Registry()
{}


                                                  // Operators
template<typename Collection>
typename Registry<Collection>::CollectionType &
Registry<Collection>::operator()()
{
    return m_collection;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

#endif // SLBCSP_REGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\retainable.cpp ===
// Retainable.cpp -- Retainable class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <windows.h>
#include <winbase.h>

#include "Retainable.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
Retainable::Retainable()
{}

Retainable::~Retainable()
{}



                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\retained.h ===
// Retained.h -- Retained template class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_RETAINED_H)
#define SLBCSP_RETAINED_H

#include "RsrcCtrlr.h"

// Using the "resource acquisition is initialization" idiom, the
// Retained template manages retaining a Retainable object (the
// resource).  Classes derived from Retainable may need to specialize
// this template's c'tor and d'tor rather than take the default.
template<class T>
class Retained
    : public ResourceController<T>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Retained(T const &rResource = T());

    Retained(Retained<T> const &rhs);

    virtual
    ~Retained() throw();


                                                  // Operators
    Retained<T> &
    operator=(T const &rhs);

                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Acquire();

    virtual void
    DoAfterAssignment();

    virtual void
    DoBeforeAssignment();

    void
    Release();

                                                  // Access
                                                  // Predicates
                                                  // Variables
private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    DoAcquire();

    void
    DoRelease();

                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool m_fIsRetained;
};

/////////////////////////  TEMPLATE METHODS  //////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<class T>
Retained<T>::Retained(T const &rResource)
    : ResourceController<T>(rResource),
      m_fIsRetained(false)
{
    Acquire();
}

template<class T>
Retained<T>::Retained(Retained<T> const &rhs)
    : ResourceController<T>(rhs.m_Resource),
      m_fIsRetained(false)
{
    Acquire();
}

template<class T>
Retained<T>::~Retained() throw()
{
    try
    {
        Release();
    }

    catch (...)
    {
        // don't allow exceptions to propagate out of destructors
    }
}

                                                  // Operators
template<class T>
Retained<T> &
Retained<T>::operator=(T const &rhs)
{
    ResourceController<T>::operator=(rhs);

    return *this;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Retained<T>::Acquire()
{
    if (m_Resource && !m_fIsRetained)
    {
        DoAcquire();
        m_fIsRetained = true;
    }
}

template<class T>
void
Retained<T>::DoAfterAssignment()
{
    ResourceController<T>::DoAfterAssignment();

    Acquire();
}

template<class T>
void
Retained<T>::DoBeforeAssignment()
{
    Release();

    ResourceController<T>::DoBeforeAssignment();
}

template<class T>
void
Retained<T>::Release()
{
    if (m_Resource && m_fIsRetained)
    {
        DoRelease();
        m_fIsRetained = false;
    }
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Retained<T>::DoAcquire()
{
    m_Resource->Retain();
}

template<class T>
void
Retained<T>::DoRelease()
{
    m_Resource->Relinquish();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

#endif // SLBCSP_RETAINED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\rsakey.h ===
// RsaKey.h -- RSA Key class header

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_RSAKEY_H)
#define SLBCSP_RSAKEY_H

#include "KeyLimits.h"

struct RsaKey
{
public:
    // limited by Microsoft CryptAPI, see CryptGenKey.
    typedef unsigned __int16 BitLengthType;       // key length (strength)

    typedef BitLengthType StrengthType;

    typedef unsigned __int16 OctetLengthType;     // modulus length in octets

    typedef unsigned __int16 ModulusLengthType;

    enum Type
    {
        ktPrivate,
        ktPublic
    };

};

RsaKey::OctetLengthType
InOctets(RsaKey::BitLengthType bitlength);

RsaKey::BitLengthType
InBits(RsaKey::OctetLengthType octetlength);

bool
IsValidRsaKeyStrength(RsaKey::StrengthType strength);

template<>
class KeyLimits<RsaKey>
{
public:

    // The following are defined as enums since VC++ 6.0 does
    // not support initialization of constant declarations.
    enum
    {

        cMinStrength = 512,                       // defined by card

        cMaxStrength = 1024, // <-- DO NOT CHANGE -- US Export restricted

        cStrengthIncrement = 256,

    };
};

#endif // SLBCSP_RSAKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\rsakey.cpp ===
// RsaKey.cpp -- RSA Key implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include "RsaKey.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

RsaKey::OctetLengthType
InOctets(RsaKey::BitLengthType bitlength)
{
    return bitlength / 8;
}

RsaKey::BitLengthType
InBits(RsaKey::OctetLengthType octectlength)
{
    return octectlength * 8;
}

bool
IsValidRsaKeyStrength(RsaKey::StrengthType strength)
{
    return  (KeyLimits<RsaKey>::cMinStrength <= strength) &&
        (KeyLimits<RsaKey>::cMaxStrength >= strength) &&
        (0 == (strength % KeyLimits<RsaKey>::cStrengthIncrement));
}


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slb_CSP.rc
//
#define IDS_READERBUSY                  1
#define IDS_ENTER_16HEX                 1
#define IDS_READERINACTIVE              2
#define IDS_ENTER_8TXT                  2
#define IDS_READEREMPTY                 3
#define IDS_ADM_HEX_KEY_LEN             3
#define IDS_PINLENGTH                   4
#define IDS_ADM_TXT_KEY_LEN             4
#define IDS_PINNOMATCH                  5
#define IDS_MAX_PIN_LEN                 5
#define IDS_SIGNATURE                   6
#define IDS_PIN_VER_NO_MATCH            6
#define IDS_EXCHANGE                    7
#define IDS_MAX_UNBLOCK_LEN             7
#define IDS_WRONGCARD                   8
#define IDS_UNBLOCK_VER_NO_MATCH        8
#define IDS_ENTERPIN                    9
#define IDS_SEL_SLB_CRYPTO_CARD         9
#define IDS_ADMINISTRATOR               10
#define IDS_BAD_PIN_ENTERED             10
#define IDS_PIN_CHANGE_FAILED           11
#define IDS_PROB_READING_CARD           12
#define IDS_CARD_NOT_INIT               13
#define IDS_CONTAINER_NOT_FOUND         14
#define IDS_CONTAINER_ALREADY_EXISTS    15
#define IDS_REPLACE_CREDENTIALS         16
#define IDS_NO_KEY_GEN                  17
#define IDS_ENTER_PIN                   18
#define IDS_ENTER_MANUFACTURER_KEY      19
#define IDS_ENTER_ADMIN_KEY             20
#define IDS_PIN_CHAR_LIMIT              21
#define IDS_PIN_HEX_LIMIT               22
#define IDS_MIN_PIN_LENGTH              23
#define IDS_MIN_NEW_PIN_LENGTH          24
#define IDS_MIN_OLD_PIN_LENGTH          25
#define IDS_PIN_BLOCKED                 26
#define IDD_GETCARD                     129
#define IDD_DIALOG1                     131
#define IDD_INITCARD                    132
#define IDD_INITKEY                     133
#define IDD_LOGIN                       134
#define IDD_KEYGENERATION               135
#define IDB_BITMAP_SLBLOGO              136
#define IDD_DIALOG_INITCARD             137
#define IDD_DIALOG_MSG                  138
#define IDD_DIALOG_YESNO                139
#define IDD_DIALOG_CHANGE_PIN           141
#define IDC_MESSAGE                     1000
#define IDC_ACCOUNT                     1002
#define IDC_PASSWD1                     1003
#define IDC_PASSWD2                     1004
#define IDC_REMEMBER                    1005
#define IDC_KEYTYPE                     1006
#define IDC_PASSWORD                    1007
#define IDC_HEXCODE                     1008
#define IDC_GENPROGRESS                 1009
#define IDC_STATIC_SLBLOGO              1011
#define IDC_CHANGEPIN                   1012
#define IDC_EDIT_NEWPIN                 1013
#define IDC_EDIT_VERNEWPIN              1014
#define IDC_STATIC_NEWPIN               1015
#define IDC_STATIC_VERNEWPIN            1016
#define IDC_CHECK_HEX_CODE              1018
#define IDC_EDIT_USER_PIN               1019
#define IDC_STATIC_ADMINKEY_MSG         1020
#define IDC_EDIT_CONT_NAME              1021
#define IDC_STATIC_MSG                  1021
#define IDC_EDIT_ADMIN_KEY              1022
#define IDC_EDIT_OLDPIN                 1022
#define IDC_EDIT_UNBLOCK_PIN            1023
#define IDC_STATIC_CONFIRM_OLDPIN_LABEL 1023
#define IDC_EDIT_VERIFY_USER_PIN        1024
#define IDC_EDIT_VERIFY_UNBLOCK_PIN     1025

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1024
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\rsakpgen.cpp ===
// RsaKPGen.cpp -- Rsa Key Pair Generator class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <limits>

#include <windows.h>
#include <wincrypt.h>

#include <scuOsExc.h>
#include <scuArrayP.h>
#include <iopPriBlob.h>

#include "RsaKPGen.h"
#include "Blob.h"
#include "AuxContext.h"
#include "MsRsaPriKB.h"
#include "PublicKeyHelper.h"

using namespace std;
using namespace cci;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    KeyType
    AsKeyType(RsaKey::StrengthType st)
    {
        KeyType kt;

        switch (st)
        {
        case 512:
            kt = ktRSA512;
            break;

        case 768:
            kt = ktRSA768;
            break;

        case 1024:
            kt = ktRSA1024;
            break;

        default:
            throw scu::OsException(ERROR_INVALID_PARAMETER);
            break;
        }

        return kt;
    }

    DWORD
    DefaultPublicExponent()
    {
        return 0x00010001; // same as Microsoft providers
    }

    pair<CPrivateKey, CPublicKey>
    KeyPair(CPrivateKey const &rhprikey,
            Blob const &rblbOrigModulus,          // little endian
            Blob const &rblbOrigExponent)         // little endian
    {
        CPublicKey hpubkey(AsPublicKey(rblbOrigModulus,
                                       rblbOrigExponent,
                                       rhprikey->Card()));

        return pair<CPrivateKey, CPublicKey>(rhprikey, hpubkey);
    }

    void
    ValidateCard(CCard const &rhcard)
    {
        if (!rhcard)
            throw scu::OsException(ERROR_INVALID_PARAMETER);
    }

    void
    ValidateStrength(RsaKey::StrengthType strength)
    {
        if (!IsValidRsaKeyStrength(strength))
            throw scu::OsException(ERROR_INVALID_PARAMETER);
    }

    bool
    IsEmpty(std::pair<CPrivateKey, CPublicKey> const &rhs)
    {
        return !rhs.first || !rhs.second;
    }

}

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
RsaKeyPairGenerator::RsaKeyPairGenerator(CCard const &rhcard,
                                         RsaKey::StrengthType strength)
    : m_hcard(rhcard),
      m_kp(),
      m_strength(strength)
{
    ValidateParameters();
}

RsaKeyPairGenerator::~RsaKeyPairGenerator()
{}

                                                  // Operators
pair<CPrivateKey, CPublicKey>
RsaKeyPairGenerator::operator()() const
{
    if (IsEmpty(m_kp))
        Generate();

    return m_kp;
}

                                                  // Operations
void
RsaKeyPairGenerator::Card(CCard const &rhcard)
{
    if (m_hcard != rhcard)
    {
        ValidateCard(rhcard);

        Reset();
        m_hcard = rhcard;
    }
}

void
RsaKeyPairGenerator::Reset()
{
    m_kp = pair<CPrivateKey, CPublicKey>();
}

void
RsaKeyPairGenerator::Strength(RsaKey::StrengthType strength)
{
    if (m_strength != strength)
    {
        ValidateStrength(strength);

        Reset();
        m_strength = strength;
    }

}


                                                  // Access
CCard
RsaKeyPairGenerator::Card() const
{
    return m_hcard;
}

bool
RsaKeyPairGenerator::OnCard() const
{
    return m_hcard->SupportedKeyFunction(AsKeyType(m_strength),
                                         coKeyGeneration);
}

RsaKey::StrengthType
RsaKeyPairGenerator::Strength() const
{
    return m_strength;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
void
RsaKeyPairGenerator::Generate() const
{
    KeyType kt = AsKeyType(m_strength);

    m_kp = OnCard()
        ? GenerateOnCard(kt)
        : GenerateInSoftware();

}

pair<CPrivateKey, CPublicKey>
RsaKeyPairGenerator::GenerateInSoftware() const
{
    AuxContext auxcontext;

    DWORD dwFlags;
    // strength (bit length) is the high-order word
    dwFlags = m_strength;
    dwFlags = dwFlags << (numeric_limits<DWORD>::digits / 2);
    dwFlags |= CRYPT_EXPORTABLE;

    HCRYPTKEY hcryptkey;
    if (!CryptGenKey(auxcontext(), AT_SIGNATURE, dwFlags, &hcryptkey))
        throw scu::OsException(GetLastError());

    DWORD dwDataLength;
    if (!CryptExportKey(hcryptkey, NULL, PRIVATEKEYBLOB, 0, 0, &dwDataLength))
        throw scu::OsException(GetLastError());

    SecureArray<BYTE> apbData(dwDataLength);
    if (!CryptExportKey(hcryptkey, NULL, PRIVATEKEYBLOB, 0, apbData.data(),
                        &dwDataLength))
        throw scu::OsException(GetLastError());

    MsRsaPrivateKeyBlob msprivatekeyblob(apbData.data(), dwDataLength);

    if (msprivatekeyblob.BitLength() != m_strength)
        throw scu::OsException(NTE_BAD_LEN);

    CPrivateKey hprikey(m_hcard);
    hprikey->Value(*(AsPCciPrivateKeyBlob(msprivatekeyblob).get()));

    Blob blbModulus(msprivatekeyblob.Modulus(), msprivatekeyblob.Length());
    MsRsaPrivateKeyBlob::PublicExponentType pet = msprivatekeyblob.PublicExponent();
    Blob blbExponent(reinterpret_cast<Blob::value_type const *>(&pet), sizeof pet);

    return KeyPair(hprikey, blbModulus, blbExponent);
}

pair<CPrivateKey, CPublicKey>
RsaKeyPairGenerator::GenerateOnCard(KeyType kt) const
{
    DWORD dwExponent = DefaultPublicExponent();
    Blob blbExponent(reinterpret_cast<Blob::value_type const *>(&dwExponent),
                     sizeof dwExponent);

    pair<string, CPrivateKey>
        ModulusKeyPair(m_hcard->GenerateKeyPair(kt,
                                                AsString(blbExponent)));

    CPrivateKey hprikey(ModulusKeyPair.second);

    Blob blbModulus(AsBlob(ModulusKeyPair.first));

    return KeyPair(hprikey, blbModulus, blbExponent);
}

void
RsaKeyPairGenerator::ValidateParameters() const
{
    ValidateCard(m_hcard);
    ValidateStrength(m_strength);
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\securable.h ===
// Securable.h -- Securable class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_SECURABLE_H)
#define SLBCSP_SECURABLE_H

#include "Retainable.h"

// Abstract base class mixin (interface) used by derived classes to
// define the interface to secure an object.  Securing an object
// involves retaining the object for exclusive access and setting the
// state for secure use.  The object is then abandoned by clearing any
// priviledged state before relinquishing exclusive access.  See the
// companion Secured template class to manage the resources derived
// from Securable.
class Securable
    : public Retainable
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    Securable();

    virtual
    ~Securable() = 0;
                                                  // Operators
                                                  // Operations
    // Clear any priviledged state
    virtual void
    Abandon() = 0;

    // Prime the resource for secure use
    virtual void
    Secure() = 0;

                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};


#endif // SLBCSP_SECURABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\secured.h ===
// Secured.h -- Secured template class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_SECURED_H)
#define SLBCSP_SECURED_H

#include "RsrcCtrlr.h"
#include "Retained.h"


// Using the "resource acquisition is initialization" idiom, the
// Secured template manages acquiring and releasing a Securable object
// (the resource).  Classes derived from Securable may need to
// specialize this template's c'tor and d'tor rather than take the
// default.
template<class T>
class Secured
    : public Retained<T>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Secured(T const &rResource = T());

    Secured(Secured<T> const &rhs);

    virtual
    ~Secured() throw();


                                                  // Operators
    Secured<T> &
    operator=(T const &rhs);

                                                  // Operations
                                                  // Access
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    Acquire();

    virtual void
    DoAfterAssignment();

    virtual void
    DoBeforeAssignment();

    void
    Release();

                                                  // Access
                                                  // Predicates
                                                  // Variables
private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
    void
    DoAcquire();

    void
    DoRelease();

                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool m_fIsSecured;
};

/////////////////////////  TEMPLATE METHODS  //////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<class T>
Secured<T>::Secured(T const &rResource)
    : Retained<T>(rResource),
      m_fIsSecured(false)
{
    Acquire();
}

template<class T>
Secured<T>::Secured(Secured<T> const &rhs)
    : Retained<T>(rhs.m_Resource),
      m_fIsSecured(false)
{
    Acquire();
}

template<class T>
Secured<T>::~Secured() throw()
{
    try
    {
        Release();
    }

    catch (...)
    {
        // don't allow exceptions to propagate out of destructors
    }
}

                                                  // Operators
template<class T>
Secured<T> &
Secured<T>::operator=(T const &rhs)
{
    Retained<T>::operator=(rhs);

    return *this;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Secured<T>::Acquire()
{
    if (m_Resource && !m_fIsSecured)
    {
        DoAcquire();
        m_fIsSecured = true;
    }
}

template<class T>
void
Secured<T>::DoAfterAssignment()
{
    Retained<T>::DoAfterAssignment();

    Acquire();
}

template<class T>
void
Secured<T>::DoBeforeAssignment()
{
    Release();

    Retained<T>::DoBeforeAssignment();
}

template<class T>
void
Secured<T>::Release()
{
    if (m_Resource && m_fIsSecured)
    {
        DoRelease();
        m_fIsSecured = false;
    }
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
template<class T>
void
Secured<T>::DoAcquire()
{
    m_Resource->Secure();
}

template<class T>
void
Secured<T>::DoRelease()
{
    m_Resource->Abandon();
}

                                                  // Access
                                                  // Predicates
                                                  // Static Variables

#endif // SLBCSP_SECURED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\rsakpgen.h ===
// RsaKPGen.h -- RSA Key Pair Generator class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_RSAKPGEN_H)
#define SLBCSP_RSAKPGEN_H

#include <windows.h>

#include <utility>

#include <cciCard.h>
#include <cciPriKey.h>
#include <cciPubKey.h>

#include "Blob.h"                                 // for TrimExtraZeroes
#include "RsaKey.h"

class RsaKeyPairGenerator
{
public:
                                                  // Types
                                                  // C'tors/D'tors

    explicit
    RsaKeyPairGenerator(cci::CCard const &rhcard,
                        RsaKey::StrengthType strength =
                            KeyLimits<RsaKey>::cMaxStrength);


    ~RsaKeyPairGenerator();

                                                  // Operators

    std::pair<cci::CPrivateKey, cci::CPublicKey>
    operator()() const;

                                                  // Operations

    void
    Card(cci::CCard const &rhcard);

    void
    Reset();

    void
    Strength(RsaKey::StrengthType strength);

    void
    UseCardGenerator(bool fUseCardGenerator);

                                                  // Access

    cci::CCard
    Card() const;

    bool
    OnCard() const;

    RsaKey::StrengthType
    Strength() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations

    void
    Generate() const;

    std::pair<cci::CPrivateKey, cci::CPublicKey>
    GenerateInSoftware() const;

    std::pair<cci::CPrivateKey, cci::CPublicKey>
    GenerateOnCard(cci::KeyType kt) const;

    void
    ValidateParameters() const;

                                                  // Access
                                                  // Predicates
                                                  // Variables

    cci::CCard m_hcard;
    std::pair<cci::CPrivateKey, cci::CPublicKey> mutable m_kp;
    RsaKey::StrengthType m_strength;
};

#endif // SLBCSP_RSAKPGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\seskeyctx.h ===
// SesKeyCtx.h -- declaration of CSessionKeyContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_SESKEYCTX_H)
#define SLBCSP_SESKEYCTX_H

#include "KeyContext.h"

class CSessionKeyContext
    : public CKeyContext
{
public:
                                                  // Types

    // TO DO: reference SessionKeyBlob::size_type instead
    //     typedef KeyBlob::size_type BlobSize;

                                                  // C'tors/D'tors

    CSessionKeyContext(HCRYPTPROV hProv);

    ~CSessionKeyContext();
                                                  // Operators
                                                  // Operations

    virtual std::auto_ptr<CKeyContext>
    Clone(DWORD const *pdwReserved,
          DWORD dwFlags) const;

    virtual void
    Derive(ALG_ID algid,
           HCRYPTHASH hAuxBaseData,
           DWORD dwFlags);

    virtual void
    Generate(ALG_ID algid,
             DWORD dwFlags);

    virtual void
    ImportToAuxCSP();

    virtual void
    LoadKey(const BYTE *pbKeyBlob,
            DWORD cbKeyBlobLen,
            HCRYPTKEY hAuxImpKey,
            DWORD dwFlags);


                                                  // Access

    virtual scu::SecureArray<BYTE>
    AsAlignedBlob(HCRYPTKEY hcryptkey,
                  DWORD dwBlobType) const;

    virtual StrengthType
    MaxStrength() const;

    virtual StrengthType
    MinStrength() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors

    // Duplicate key context and its current state
    CSessionKeyContext(CSessionKeyContext const &rhs,
                       DWORD const *pdwReserved,
                       DWORD dwFlags);


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

    DWORD m_dwImportFlags;


};

#endif // SLBCSP_SESKEYCTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\seskeyctx.cpp ===
// SesKeyCtx.cpp -- definition of CSessionKeyContext

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"    // because handles.h uses the ASSERT macro

#include <scuOsExc.h>
#include <scuArrayP.h>

#include "SesKeyCtx.h"
#include "slbKeyStruct.h"
#include "AlignedBlob.h"

using namespace std;
using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors

CSessionKeyContext::CSessionKeyContext(HCRYPTPROV hProv)
        : CKeyContext(hProv, KT_SESSIONKEY),
          m_dwImportFlags(0)
{}

CSessionKeyContext::~CSessionKeyContext()
{}

                                                  // Operators
                                                  // Operations

auto_ptr<CKeyContext>
CSessionKeyContext::Clone(DWORD const *pdwReserved,
                          DWORD dwFlags) const
{
    return auto_ptr<CKeyContext>(new CSessionKeyContext(*this,
                                                        pdwReserved,
                                                        dwFlags));
}

void
CSessionKeyContext::Derive(ALG_ID algid,
                           HCRYPTHASH hAuxBaseData,
                           DWORD dwFlags)
{
    if (!CryptDeriveKey(AuxProvider(), algid, hAuxBaseData, dwFlags,
                        &m_hKey))
        throw scu::OsException(GetLastError());
}

void
CSessionKeyContext::Generate(ALG_ID algid,
                             DWORD dwFlags)
{
    // TO DO: BUG ?? : Do not allow Session with NO SALT (it's always
    // better with than without)

    if (!CryptGenKey(AuxProvider(), algid, dwFlags, &m_hKey))
        throw scu::OsException(GetLastError());
}

void
CSessionKeyContext::ImportToAuxCSP()
{
    if (!m_hKey)
    {
        if (!m_apabKey.data())
            throw OsException(NTE_NO_KEY);

        HCRYPTKEY   hPkiKey;

        if (!CryptImportKey(AuxProvider(),
                            PrivateKeyForNoRSA,
                            SIZE_OF_PRIVATEKEYFORNORSA_BLOB,
                            0, 0, &hPkiKey))
            throw scu::OsException(GetLastError());

        // import the key blob into the Aux CSP
        if (!CryptImportKey(AuxProvider(), m_apabKey.data(),
                            m_apabKey.length(), NULL, m_dwImportFlags,
                            &m_hKey))
            throw scu::OsException(GetLastError());

        // have to destroy key before generating another
        if (!CryptDestroyKey(hPkiKey))
            throw scu::OsException(GetLastError());

        hPkiKey = NULL;
        if (!CryptGenKey(AuxProvider(), AT_KEYEXCHANGE, 0, &hPkiKey))
            throw scu::OsException(GetLastError());

        if (!CryptDestroyKey(hPkiKey))
            throw scu::OsException(GetLastError());
    }
}

// CSessionKeyContext::LoadKey
// This function is called by CCryptContext::UseSessionKey
// which is called by the CPImportKey function
// Load the key blob into the Auxiliary CSP,
// and Save the key blob in m_bfSessionKey
// If hImpKey is NULL the key has been decrypted
// otherwise it is still encrypted with the corresponding session key
// If session key is still encrypted then decrypt with help of Aux CSP
void
CSessionKeyContext::LoadKey(IN const BYTE *pbKeyBlob,
                            IN DWORD cbKeyBlobLen,
                            IN HCRYPTKEY hAuxImpKey,
                            IN DWORD dwImportFlags)
{
    m_dwImportFlags = dwImportFlags;

    if (hAuxImpKey)
    {
        DWORD dwDataLen = cbKeyBlobLen - (sizeof BLOBHEADER + sizeof ALG_ID);
        SecureArray<BYTE> apbData( dwDataLen * sizeof BYTE );
        memcpy(apbData.data(), pbKeyBlob + (sizeof BLOBHEADER +
                                    sizeof ALG_ID), dwDataLen);

        // Decrypt the key blob with this session key with the Aux CSP
        if (!CryptDecrypt(hAuxImpKey, 0, TRUE, 0, apbData.data(), &dwDataLen))
            throw scu::OsException(GetLastError());

        // Construct an empty key blob
        SecureArray<BYTE> blbKey(0);//(pbKeyBlob, sizeof BLOBHEADER);

        // Set the Alg Id for the blob as encrypted with Key Exchange key
        ALG_ID algid = CALG_RSA_KEYX;
        blbKey.append(reinterpret_cast<BYTE *>(&algid),
                         sizeof ALG_ID);
        blbKey.append(apbData.data(), dwDataLen);

        // Save it
        m_apabKey = blbKey;
    }
    else
    {
        // Save key blob
        m_apabKey =
            SecureArray<BYTE>(pbKeyBlob, cbKeyBlobLen);
    }
}


                                                  // Access

SecureArray<BYTE>
CSessionKeyContext::AsAlignedBlob(HCRYPTKEY hcryptkey,
                                  DWORD dwBlobType) const
{
    DWORD dwRequiredLength;
    if (!CryptExportKey(m_hKey, hcryptkey, dwBlobType,
                        0, 0, &dwRequiredLength))
        throw scu::OsException(GetLastError());

    SecureArray<BYTE> apbKeyBlob(dwRequiredLength);
    if (!CryptExportKey(m_hKey, hcryptkey, dwBlobType,
                        0, apbKeyBlob.data(), &dwRequiredLength))
        throw scu::OsException(GetLastError());

    return apbKeyBlob;

    // The following commented code is for DEBUGGING purposes only,
    // when one needs to be able to see the unencrypted session key
    // material.

    // Now also Export it with the identity key, so we can see the
    // session key material in the clear
/*
#include "slbKeyStruct.h"
DWORD           dwErr;
BYTE            *pbBlob = NULL;
DWORD           cbBlob;
HCRYPTKEY       hPkiKey;
int                     i;
        if (!CryptImportKey(g_AuxProvider, PrivateKeyForNoRSA,
                            SIZE_OF_PRIVATEKEYFORNORSA_BLOB,
                            0, 0, &hPkiKey))
        {
            dwErr = GetLastError();
            TRACE("ERROR - CryptImportKey : %X\n", dwErr);
            goto Ret;

        }

                if (!CryptExportKey(m_hKey, hPkiKey, SIMPLEBLOB, 0, NULL, &cbBlob))
                {
            dwErr = GetLastError();
            TRACE("ERROR - CryptExportKey : %X\n", dwErr);
            goto Ret;
        }

        if (NULL == (pbBlob = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbBlob)))
        {
            TRACE("ERROR - LocalAlloc Failed\n");
            goto Ret;
        }

                if (!CryptExportKey(m_hKey, hPkiKey, SIMPLEBLOB, 0, pbBlob, &cbBlob))
                {
            dwErr = GetLastError();
            TRACE("ERROR - CryptExportKey : %X\n", dwErr);
            goto Ret;
        }

        TRACE("The Simple Blob\n\n");

        for(i=0;i<(int)cbBlob;i++)
        {
            TRACE("0x%02X, ", pbBlob[i]);
            if (0 == ((i + 1) % 8))
                TRACE("\n");
        }

Ret:

   TRACE ("Bye\n");
*/

}

// CSessionKeyContext::BlobSize
// CSessionKeyContext::BlobLength() const
// {
//     DWORD dwLength;

//     if (!CryptExportKey(m_hKey, hAuxExpKey, SIMPLEBLOB,
//                         dwFlags, 0, &dwLength))
//         throw scu::OsException(GetLastError());

//     return dwLength;
// }

CSessionKeyContext::StrengthType
CSessionKeyContext::MaxStrength() const
{
    // TO DO: Implement in terms of Auxillary provider...or don't define?
    return 56;
}

CSessionKeyContext::StrengthType
CSessionKeyContext::MinStrength() const
{
    // TO DO: Implement in terms of Auxillary provider...or don't define?
    return 56;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors

// Duplicate key context and its current state
CSessionKeyContext::CSessionKeyContext(CSessionKeyContext const &rhs,
                                       DWORD const *pdwReserved,
                                       DWORD dwFlags)
    : CKeyContext(rhs, pdwReserved, dwFlags),
      m_dwImportFlags(rhs.m_dwImportFlags)
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\securable.cpp ===
// Securable.cpp -- Securable class implementation

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "NoWarning.h"
#include "ForceLib.h"

#include <windows.h>
#include <winbase.h>

#include "Securable.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
Securable::Securable()
{}

Securable::~Securable()
{}



                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\rsrcctrlr.h ===
// RsrcCtrlr.h -- ReSouRCe ConTRoLleR template class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_RSRCCTRLR_H)
#define SLBCSP_RSRCCTRLR_H

// ResourceController is an abstract base template class to control
// the acquisition and release of a resource.  The controlled resource
// (m_Resource) is a protected member.  The class implements a handle
// interface to safely access and manipulate that resource in
// conjunction with the derived class.
//
// Example usages of the ResourceController are implementing the
// "resource acquisition is initialization," locking and unlocking an
// object for thread safety, and counted pointer idioms.
//
//
// DERIVED CLASS RESPONSIBILITY: To complete the implementation, the
// derived class must define the Acquire and Release methods to
// perform the resource acquisition and release operations,
// respectively.  The ResourceController does not call Acquire in the
// constructor since that method is defined by the derived class and
// the derived portion of the object is not be considered constructed
// at the time the base class constructor is called.  For reasons of
// symetry, ResourceController does not call Release in the
// destructor.  Therefore, it is the derived classes responsibility to
// define constructors, a destructor, and call Acquire and Release in
// those methods as appropriate.
//
// As with any derived class implementation, any assignment operators
// defined by the derived class should call the the comparable
// versions in ResourceController.
//
// CONSTRAINTS: T must support a default value (have a default
// constructor).
//
// ResourceController was not designed to be referenced directly, that
// is why all of it's methods (except Acquire and Release) are not
// defined virtual.
//
// NOTE: Comparison helpers are defined at the end.
template<class T>
class ResourceController
{
public:
                                                  // Types
    // PrivateDummy is a helper class to support validity testing of
    // ResourceController.  This class together with the conversion
    // operator PrivateDummy const *() below allows
    // ResourceControllers to be tested for nullness (validity tests).
    // The implemenation allows these tests in a syntactically natural
    // way without allowing heterogeneous comparisons and that won't
    // violate the protections that ResourceController provides.  The
    // technique is a variation from an article by Don Box in "Com
    // Smart Pointers Also Considered Harmful," 1996, C++ Report.
    class PrivateDummy
    {};

                                                  // C'tors/D'tors
    virtual
    ~ResourceController() throw () = 0;


                                                  // Operators
    operator T() const;

    ResourceController<T> &
    operator=(T const &rhs);

    ResourceController<T> &
    operator=(ResourceController<T> const &rhs);

    operator PrivateDummy const *() /* const */;
    // Enable validity test of ResourceController.  See description of
    // PrivateDummy type.
                          // making this a const routine causes compilation
                          // problems in VC++ 6.0 for some reason.

                                                  // Operations
                                                  // Access
    T
    operator->() const;

    T
    operator*() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    ResourceController(T const &rResource = T());

    ResourceController(ResourceController<T> const &rhs);

                                                  // Operators
                                                  // Operations
    void
    DoAcquire();

    virtual void
    DoAfterAssignment();

    virtual void
    DoBeforeAssignment();

    void
    DoRelease();


                                                  // Access
                                                  // Predicates
                                                  // Variables
    T m_Resource;

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
};

/////////////////////////  TEMPLATE METHODS  //////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<class T>
ResourceController<T>::~ResourceController() throw()
{}

                                                  // Operators
template<class T>
ResourceController<T>::operator T() const
{
    return m_Resource;
}

template<class T>
T
ResourceController<T>::operator->() const
{
    return m_Resource;
}

template<class T>
T
ResourceController<T>::operator*() const
{
    return m_Resource;
}

template<class T>
ResourceController<T>::operator __TYPENAME ResourceController<T>::PrivateDummy const *() /* const */
{
    return m_Resource
        ? reinterpret_cast<PrivateDummy *>(this)
        : 0;
}

template<class T>
ResourceController<T> &
ResourceController<T>::operator=(T const &rhs)
{
    if (m_Resource != rhs)
    {
        DoBeforeAssignment();

        m_Resource = rhs;

        DoAfterAssignment();
    }

    return *this;
}

template<class T>
ResourceController<T> &
ResourceController<T>::operator=(ResourceController<T> const &rhs)
{
    if (this != &rhs)
    {
        DoBeforeAssignment();

        m_Resource = rhs.m_Resource;

        DoAfterAssignment();
    }

    return *this;
}

                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
template<class T>
ResourceController<T>::ResourceController(T const &rResource)
    : m_Resource(rResource)
{}

template<class T>
ResourceController<T>::ResourceController(ResourceController<T> const &rhs)
    : m_Resource(rhs.m_Resource)
{}

                                                  // Operators
                                                  // Operations
template<class T>
void
ResourceController<T>::DoAcquire()
{}

template<class T>
void
ResourceController<T>::DoAfterAssignment()
{}

template<class T>
void
ResourceController<T>::DoBeforeAssignment()
{}

template<class T>
void
ResourceController<T>::DoRelease()
{}


                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    HELPERS    /////////////////////////////////
template<class T>
bool
operator==(ResourceController<T> const &lhs,
           ResourceController<T> const &rhs)
{
    return lhs.m_Resource == rhs.m_Resource;
}

template<class T>
bool
operator!=(ResourceController<T> const &lhs,
           ResourceController<T> const &rhs)
{
    return !operator==(lhs, rhs);
}

#endif // SLBCSP_RSRCCTRLR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\slbcsp.cpp ===
// slbCsp.cpp : Defines the initialization routines for the
// Schlumberger CSP DLL.
//

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "stdafx.h"

#include <scuOsExc.h>

#include "MasterLock.h"
#include "CspProfile.h"
#include "slbCsp.h"

// #include "initsvr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace ProviderProfile;

/////////////////////////////////////////////////////////////////////////////
// CSLBDllApp

BEGIN_MESSAGE_MAP(CSLBDllApp, CWinApp)
    //{{AFX_MSG_MAP(CSLBDllApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// To ensure the value set by SetLastError isn't reset when the DLL is
// unloaded, the DLL must be "locked" into memory until the calling
// application exits.  This is accomplished by bumping the reference
// count of this DLL using LoadLibrary without a corresponding
// FreeLibrary call.  When the application exits, the system will
// unload the DLL even though the reference count hasn't gone to zero.

namespace
{

static void
LockDLLIntoMemory()
{
    static bool bLocked = false;
    if (!bLocked)
    {
        HINSTANCE hThisDll = AfxGetInstanceHandle();
        if (NULL == hThisDll)
            throw scu::OsException(GetLastError());

        TCHAR szModulePath[MAX_PATH];
        DWORD cLength = GetModuleFileName(hThisDll, szModulePath,
                                          (sizeof szModulePath /
                                           sizeof *szModulePath));
        if (0 == cLength)
            throw scu::OsException(GetLastError());

        szModulePath[cLength] = '\0';

        if (!LoadLibrary(szModulePath))
            throw scu::OsException(GetLastError());
        bLocked = true;
    }
}

} // namespace


/////////////////////////////////////////////////////////////////////////////
// CSLBDllApp construction

CSLBDllApp::CSLBDllApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSLBDllApp object

CSLBDllApp theApp;

BOOL CSLBDllApp::InitInstance()
{
    BOOL fSuccess = TRUE;

#ifdef ISOLATION_AWARE_ENABLED
    SHFusionInitializeFromModuleID (m_hInstance, 2);
#endif

    try
    {
        // Initialize OLE module for regular DLL
        AfxOleInitModule();

        // Each public CSP interface defined in CSP_API.cpp (by
        // definition of the Microsoft CryptoAPI) uses SetLastError
        // upon returning for the calling application to determine the
        // specifics on any failure.  Unfortunately, the CSP uses MFC
        // which also calls SetLastError as part of its run-down
        // procedures when the CSP DLL is being unloaded (at least on
        // NT 4/Windows 95, didn't observe this on NT 5).  Normally,
        // one might want the CSP DLL to be unloaded when there aren't
        // any CSP resources being used by the application, (e.g. no
        // cards in the readers or no contexts acquired, etc.)
        // However, if the CSP DLL is unloaded after returning to the
        // application, then these MFC run-down procedures will stomp
        // on the result of the SetLastError call made by CSP before
        // returning to the calling application from advapi32.dll.
        // When the calling application finally gets control, the
        // result of the CSPs call to SetLastError is long gone.  To
        // avoid this, the CSP DLL is "locked" into memory during DLL
        // initialization until the application exits at which point
        // the system forces the DLL to unload.

        LockDLLIntoMemory();

        CWinApp::InitInstance();

        SetupMasterLock();

        // Initialize the CSP's world
        CspProfile::Instance();
    }

    catch (...)
    {
        fSuccess = FALSE;
    }

    return fSuccess;
}

int CSLBDllApp::ExitInstance()
{
    OnIdle(1);

    CspProfile::Release();

    DestroyMasterLock();

#ifdef ISOLATION_AWARE_ENABLED
    SHFusionUninitialize();
#endif

    // UnloadServer();
    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#if !defined(SLBCSP_STDAFX_H)
#define SLBCSP_STDAFX_H

#include "NoWarning.h"

// Avoid the compiler's redefine warning message when afxv_w32.h is included
#if defined(_WIN32_WINDOWS)
#undef _WIN32_WINDOWS
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

// Include the template class(s)
#include <afxtempl.h>
#include <afxmt.h>

#ifdef ISOLATION_AWARE_ENABLED
#include <shfusion.h>

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif

#endif // !defined(SLBCSP_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\slbkeystruct.h ===
// slbKeyStruct.h -- SchLumBeger RSA Key structure declaration
// --- Info used to import Pub/Priv key pair in Aux CSP ---
// This file is automatically generated by SLB developers.
// After generation, modify the contents to suit your purposes.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_SLBKEYSTRUCT_H)
#define SLBCSP_SLBKEYSTRUCT_H

#define SIZE_OF_PRIVATEKEYFORNORSA_BLOB 308

static BYTE PrivateKeyForNoRSA[SIZE_OF_PRIVATEKEYFORNORSA_BLOB] = {

// BLOBHEADER(8)
0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,

// RSAPUBKEY(12)
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00,

// PRIVATEKEY Stuff
// modulus(64)
0xFD, 0xCB, 0x9D, 0xA3, 0xAE, 0x8A, 0x3E, 0x17,
0x1B, 0x1B, 0x75, 0xA5, 0x32, 0x24, 0x42, 0xB6,
0x4B, 0x54, 0x09, 0x21, 0x8D, 0x9B, 0x10, 0xE2,
0xD2, 0xD8, 0xF7, 0xCE, 0x11, 0x77, 0x49, 0x45,
0x18, 0x58, 0x01, 0xCD, 0xAC, 0xA6, 0xF9, 0x5F,
0xF2, 0x01, 0x0B, 0x17, 0xBE, 0xEF, 0x9C, 0xC2,
0xAC, 0x33, 0x61, 0x5B, 0x8A, 0x30, 0xFE, 0xE1,
0x2B, 0x42, 0xA3, 0xF2, 0xE1, 0x05, 0xF2, 0x9D,
// prime1(32)
0x9D, 0x9A, 0xFC, 0x67, 0x3B, 0x14, 0x30, 0x8C,
0xEE, 0xCA, 0xFD, 0xA7, 0xC2, 0xCE, 0xFF, 0xFC,
0x3C, 0x34, 0x65, 0x96, 0x0E, 0x27, 0x97, 0xF3,
0xC8, 0x24, 0x3F, 0x22, 0xCC, 0x8C, 0x78, 0xF2,
// prime2(32)
0xE1, 0x08, 0x49, 0x5F, 0x10, 0x6D, 0x79, 0xC6,
0x15, 0xAE, 0x6F, 0x9C, 0x27, 0x65, 0x2B, 0x1B,
0xE7, 0x46, 0x29, 0x84, 0xCB, 0x71, 0xF7, 0x13,
0x31, 0xFC, 0xAF, 0xD5, 0xBF, 0x1C, 0xC2, 0xA6,
// exponent1(32)
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// exponent2(32)
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// coefficient(32)
0x69, 0x3C, 0x48, 0x6E, 0x9D, 0xAA, 0xDC, 0x06,
0x8F, 0x2D, 0x98, 0xA8, 0x52, 0x68, 0x2C, 0xD9,
0x69, 0xFA, 0x65, 0xB4, 0xFA, 0x0C, 0xBE, 0x6B,
0xF0, 0x9B, 0x6B, 0x38, 0x24, 0x8A, 0xAC, 0xB5,
// privateExponent(64)
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#endif // SLBCSP_SLBKEYSTRUCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//      SlbActx.pch will be the pre-compiled header
//      stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\slbcsp.h ===
// slbCsp.h : main header file for the SLB CSP DLL
//

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if !defined(SLBCSP_H)
#define SLBCSP_H

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include <slbRcCsp.h>

#if defined(_DEBUG)
#define breakpoint _CrtDbgBreak();
#else
#if !defined(breakpoint)
#define breakpoint
#endif // !defined(breakpoint)
#endif // defined(_DEBUG)

/////////////////////////////////////////////////////////////////////////////
// CSLBDllApp
// See SlbCsp.cpp for the implementation of this class
//

class CSLBDllApp : public CWinApp
{
public:
    virtual int ExitInstance();
    virtual BOOL InitInstance();
    CSLBDllApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSLBDllApp)
    //}}AFX_VIRTUAL

    //{{AFX_MSG(CSLBDllApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP() ;
};

/////////////////////////////////////////////////////////////////////////////

#endif // SLBCSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\stresource.h ===
// StResource.h -- String Resource helper routines

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_STRESOURCE_H)
#define SLBCSP_STRESOURCE_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <string>
#include <windef.h>

#include <slbRcCsp.h>
#include <iopPriBlob.h>

class StringResource
{
public:
    StringResource(UINT uID);

    const std::string
    AsString() const;

    const CString
    AsCString() const;
    
    static const std::string
    AsciiFromUnicode(LPCTSTR szSource);

    static const scu::SecureArray<char>
    CheckAsciiFromUnicode(LPCTSTR szSource);

    static bool
    IsASCII(LPCTSTR szSource);

    static const CString
    UnicodeFromAscii(std::string const &rsSource);

private:
    std::string m_s;
    CString m_cs;
};

extern HANDLE
GetImageResource(DWORD dwId,
                 DWORD dwType);

#endif // SLBCSP_STRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\stresource.cpp ===
// StResource.cpp -- String Resource helper routines

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE

#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include "stdafx.h"

#include <string>

#include <scuOsExc.h>

#include "CspProfile.h"
#include "StResource.h"
#include "Blob.h"

using namespace std;
using namespace scu;
using namespace ProviderProfile;

// Maximum string resource length as defined by MS
static const size_t cMaxResourceLength = 4095;

StringResource::StringResource(UINT uID)
    : m_s()
{
    static _TCHAR szBuffer[cMaxResourceLength]; // include null terminator

    if (0 == LoadString(CspProfile::Instance().Resources(), uID, szBuffer,
                        (sizeof szBuffer / sizeof szBuffer[0])))
        throw scu::OsException(ERROR_RESOURCE_NOT_PRESENT);
	string stmp(AsCCharP(szBuffer), (_tcslen(szBuffer)+1)*sizeof _TCHAR);
    m_s = stmp;
    CString cstmp(szBuffer);
    m_cs = cstmp;
}

const string
StringResource::AsString() const
{
    return m_s;
}

const CString
StringResource::AsCString() const
{
    return m_cs;
}

const string
StringResource::AsciiFromUnicode(LPCTSTR szSource)
{
    string sTarget;
    int nChars = _tcslen(szSource);
    
    sTarget.resize(nChars);
    for(int i =0; i<nChars; i++)
        sTarget[i] = static_cast<char>(*(szSource+i));
    return sTarget;
}

const SecureArray<char>
StringResource::CheckAsciiFromUnicode(LPCTSTR szSource)
{
    int nChars = _tcslen(szSource); 
    SecureArray<char> sTarget(nChars+1);// for null termination
    //Here we check every incoming character for being
    //a proper ASCII character before assigning it to the
    //output buffer. We set the output to '\xFF' if the ascii
    //test fails.
    int i=0;
    for(i=0; i<nChars; i++)
    {
        if(iswascii(*(szSource+i)))
        {
            sTarget[i] = static_cast<char>(*(szSource+i));
        }
        else
        {
            sTarget[i] = '\xFF';
        }
    }
    sTarget[i] = '\0';
    return sTarget;
}

bool
StringResource::IsASCII(LPCTSTR szSource)
{
    bool RetValue = true;
    int nChars = _tcslen(szSource);

    //Here we check every incoming character for being
    //a proper ASCII character. If one of them is non ASCII
    //we return false

    for(int i =0; i<nChars; i++)
    {
        if(!iswascii(*(szSource+i)))
        {
            return false;
        }
    }
    return RetValue;
}

const CString
StringResource::UnicodeFromAscii(string const &rsSource)
{
    CString csTarget;
    int nChars = rsSource.length();
	if(nChars)
	{
		LPTSTR pCharBuffer = csTarget.GetBufferSetLength(nChars);
		int itChar = 0;
		for(int iChar=0; iChar<nChars; iChar++)
		{
			if(rsSource[iChar] != '\0')
				*(pCharBuffer+itChar++) = rsSource[iChar];
		}
		//Set the final null terminator
		*(pCharBuffer+itChar)='\0';
		csTarget.ReleaseBuffer(-1);//Let CString set its length appropriately
	}
    return csTarget;
}   

HANDLE
GetImageResource(DWORD dwId,
                 DWORD dwType)
{

    return LoadImage(CspProfile::Instance().Resources(),
                     MAKEINTRESOURCE(dwId), dwType, 0, 0, LR_SHARED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\autobuildcount.h ===
// 10
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 10
#define BUILDCOUNT_STR "10"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\uuid.cpp ===
// Uuid.h -- Universally Unique IDentifier functor wrapper implementation to
// create and manage UUIDs

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <scuOsExc.h>

#include "Uuid.h"
#include <tchar.h>
using namespace std;

///////////////////////////    HELPER     /////////////////////////////////
typedef LPTSTR *SLB_PLPTSTR;

struct RpcString                  // to help manage deallocation
{
public:
    RpcString()
        : m_psz(0)
    {};
    ~RpcString()
    {
        if (m_psz)
#if defined(UNICODE)
            RpcStringFree((SLB_PLPTSTR)&m_psz);
#else
            RpcStringFree(&m_psz);
#endif
    };

    unsigned char *m_psz;
};

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
Uuid::Uuid(bool fNilValued)
{
    RPC_STATUS rpcstatus;

    if (fNilValued)
        rpcstatus = UuidCreateNil(&m_uuid);
    else
    {
        rpcstatus = UuidCreate(&m_uuid);
        if (RPC_S_UUID_LOCAL_ONLY == rpcstatus)
            rpcstatus = RPC_S_OK;
    }

    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);
}

Uuid::Uuid(basic_string<unsigned char> const &rusUuid)
{
    RPC_STATUS rpcstatus =
#if defined(UNICODE)
		UuidFromString((LPTSTR)rusUuid.c_str(), &m_uuid);
#else
        UuidFromString(const_cast<unsigned char *>(rusUuid.c_str()), &m_uuid);
#endif
    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);
}

Uuid::Uuid(UUID const *puuid)
{
    m_uuid = *puuid;
}

                                                  // Operators
Uuid::operator==(Uuid &ruuid)
{
    RPC_STATUS rpcstatus;
    int fResult = UuidEqual(&m_uuid, &ruuid.m_uuid, &rpcstatus);

    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);

    return fResult;
}

                                                  // Operations
                                                  // Access
basic_string<unsigned char>
Uuid::AsUString()
{
    RpcString rpcsUuid;
#if defined(UNICODE)
    RPC_STATUS rpcstatus = UuidToString(&m_uuid, (SLB_PLPTSTR)&rpcsUuid.m_psz);
#else
    RPC_STATUS rpcstatus = UuidToString(&m_uuid, &rpcsUuid.m_psz);
#endif
    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);
#if defined(UNICODE)
	LPCTSTR szSource = (LPCTSTR)rpcsUuid.m_psz;
	int nChars = _tcslen(szSource);
    basic_string<unsigned char> sAscii;
    sAscii.resize(nChars);
    for(int i =0; i<nChars; i++)
        sAscii[i] = static_cast<unsigned char>(*(szSource+i));
    return sAscii;
#else
    return basic_string<unsigned char>(rpcsUuid.m_psz);
#endif
}

unsigned short
Uuid::HashValue()
{
    RPC_STATUS rpcstatus;
    unsigned short usValue = UuidHash(&m_uuid, &rpcstatus);

    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);

    return usValue;
}

                                                  // Predicates
bool
Uuid::IsNil()
{
    RPC_STATUS rpcstatus;
    int fResult = UuidIsNil(&m_uuid, &rpcstatus);

    if (RPC_S_OK != rpcstatus)
        throw scu::OsException(rpcstatus);

    return fResult == TRUE;
}

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbcsp\uuid.h ===
// Uuid.h -- Universally Unique IDentifier functor wrapper header to
// create and manage UUIDs

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBCSP_UUID_H)
#define SLBCSP_UUID_H

#if defined(_UNICODE)
  #if !defined(UNICODE)
    #define UNICODE
  #endif //!UNICODE
#endif //_UNICODE
#if defined(UNICODE)
  #if !defined(_UNICODE)
    #define _UNICODE
  #endif //!_UNICODE
#endif //UNICODE

#include <string>

#include <rpc.h>

class Uuid
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Uuid(bool fNilValued = false);

    explicit
    Uuid(std::basic_string<unsigned char> const &rusUuid);

    explicit
    Uuid(UUID const *puuid);

                                                  // Operators
    operator==(Uuid &ruuid);

                                                  // Operations
                                                  // Access
    std::basic_string<unsigned char>
    AsUString();

    unsigned short
    HashValue();

                                                  // Predicates
    bool
    IsNil();

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    UUID m_uuid;
};


#endif // SLBCSP_UUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\accesscard.cpp ===
// AccessCard.cpp: implementation of the CAccessCard class.
//
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include <scuArrayP.h>
#include <scuSecureArray.h>

#include "AccessCard.h"
#include <stdio.h>
#include "iopExc.h"
#include "LockWrap.h"
#include "FilePath.h"

using namespace std;
using namespace iop;

namespace
{
    BYTE
    AsPrivateAlgId(KeyType kt)
    {
        BYTE bAlgId = 0;
        
        switch (kt)
        {
        case ktRSA512:
            bAlgId = 0xC4;
            break;
            
        case ktRSA768:
            bAlgId = 0xC6;
            break;
            
        case ktRSA1024:
            bAlgId = 0xC8;
            break;
        case ktDES:
			bAlgId = 0x00;
			break;
        default:
            throw Exception(ccInvalidParameter);
            break;
        }

        return bAlgId;
    }

} // namespace

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CAccessCard::CAccessCard(const SCARDHANDLE  hCardHandle, const char* szReaderName, 
						 const SCARDCONTEXT pContext,	 const DWORD dwMode)
		    : CSmartCard(hCardHandle, szReaderName, pContext, dwMode)
{
    if (ValidClassByte(0xF0))
        m_bClassByte = 0xF0;
    else
        if (ValidClassByte(0x00))
            m_bClassByte = 0x00;
    else                                          // Not an  access card!
        throw iop::Exception(iop::ccUnknownCard);
    
    m_fSupportLogout = SupportLogout();

}

CAccessCard::~CAccessCard()
{

}

void
CAccessCard::GetChallenge(const DWORD dwNumberLength, BYTE* bRandomNumber)
{
	CLockWrap wrap(&m_IOPLock);

    const BYTE bMinLen = 4, bMaxLen = 64;   // Max 64 due to bug in old cards.

    if(dwNumberLength < bMinLen) 
    {
        BYTE bBuf[bMinLen];
       	SendCardAPDU(m_bClassByte, 0x84, 0x00, 0x00, 0, NULL,
                     bMinLen,  bBuf);
        memcpy(bRandomNumber,bBuf,dwNumberLength);
    }
    else
    {

        DWORD dwRamainingBytes = dwNumberLength;
        BYTE *bpBuf = bRandomNumber;

        while(dwRamainingBytes)
        {
            BYTE bNumGet = (dwRamainingBytes > bMaxLen) ? bMaxLen : dwRamainingBytes;

        	SendCardAPDU(m_bClassByte, 0x84, 0x00, 0x00, 0, NULL,
                     bNumGet,  bpBuf);

            bpBuf             += bNumGet;
            dwRamainingBytes  -= bNumGet;           
        }
    }
}

void
CAccessCard::DeleteFile(const WORD wFileID)
{	
	CLockWrap wrap(&m_IOPLock);
	BYTE bDataIn[2];
	bDataIn[0]   = (BYTE)(MSB(wFileID));
	bDataIn[1]   = (BYTE)(LSB(wFileID));
	
	SendCardAPDU(m_bClassByte, insDeleteFile, 0x00, 0x00, 0x02, bDataIn,
                 0, NULL);

}

void
CAccessCard::Directory(const BYTE bFile_Nb, FILE_HEADER* pMyfile) 
{
	CLockWrap wrap(&m_IOPLock);

	RequireSelect();

	BYTE bDataOut[40];
    memset(bDataOut, 0, 40);
	
	SendCardAPDU(m_bClassByte, 0xA8, 0x00, bFile_Nb, 0, NULL, 40, bDataOut);

    switch(bDataOut[6])
    {			
    case 0x01:		//  Root  directory file
    case 0x02:		//  Other directory file or Instance file
        {
            pMyfile->file_id     = (WORD)(bDataOut[4] * 256 + bDataOut[5]);
            pMyfile->file_size   = (WORD)(bDataOut[2] * 256 + bDataOut[3]);					
            pMyfile->nb_file     = bDataOut[15];
            pMyfile->nb_sub_dir  = bDataOut[14];
            pMyfile->file_status = 0x01;

            if (bDataOut[9] == 0)
            {
                memset((void*)(pMyfile->applicationID), 0x00, 16);
                pMyfile->file_type = directory;
            }
            else
                if (bDataOut[9] == 0x01 || bDataOut[9] == 0x02 ||
                    bDataOut[9] == 0x03)
            {
                /////////////////////////////////////////////////////////////////
                //  Instance files contain one "hidden" file for program data  //
                //  that should not be shown to the users					   //	
                /////////////////////////////////////////////////////////////////
                pMyfile->nb_file--;												

                pMyfile->file_type = Instance;
                pMyfile->AIDLength = bDataOut[23];
                memcpy((void*)(pMyfile->applicationID), (void*)(&bDataOut[24]), pMyfile->AIDLength);
					
                /////////////////////////////////////////////////////////////////////
                //  Set flags in file status to discriminate applets/applications  //
                /////////////////////////////////////////////////////////////////////
                switch(bDataOut[9])
                {
                case 0x01:	pMyfile->file_status |= (1 << 5);		//  Applet
                    break;
                case 0x02:	pMyfile->file_status |= (1 << 4);		//  Application
                    break;
                case 0x03:  pMyfile->file_status |= (3 << 4);		//  Both
                    break;
                }

                ////////////////////////////////////////////////
                //  Set flags in file status to discriminate  //
                //	created/installed/registered instances    //
                ////////////////////////////////////////////////
                switch(bDataOut[10])
                {
                case 0x01:	pMyfile->file_status |= (1 << 1);		//  Created
                    break;
                case 0x02:	pMyfile->file_status |= (1 << 2);		//  Installed
                    break;
                case 0x03:	pMyfile->file_status |= (1 << 3);		//  Registered
                    break;
                }
            }
            ///////////////////////////////////////////////
            //  guard against a bad Instance file        //
            //  created without an AID for file control  //
            ///////////////////////////////////////////////
            else						
            {						
                pMyfile->AIDLength = 0x00;
                memset((void*)(pMyfile->applicationID), 0x00, 16);

                throw iop::Exception(iop::ccBadInstanceFile);
            }

            ///////////////////////////////
            //  Select file and get ACL	 //
            ///////////////////////////////
            Select(pMyfile->file_id);
				

            SendCardAPDU(m_bClassByte, insGetACL, 0x00, 0x00, 0,
                         NULL, 0x08, bDataOut);
				
            memcpy((void*)(pMyfile->access_cond), (void*)(bDataOut),8);
				
            /////////////////////////////////
            //  Reselect parent directory  //
            /////////////////////////////////
            Select(m_CurrentDirectory.Tail().GetShortID());				

            break;

        }	//  end case directory or Instance file

    case  0x04:		//  all other file types
        {				
            pMyfile->file_id	 = (WORD)(bDataOut[4] * 256 + bDataOut[5]);
            pMyfile->file_size   = (WORD)(bDataOut[2] * 256 + bDataOut[3]);
            pMyfile->nb_file	 = 0x00;
            pMyfile->nb_sub_dir	 = 0x00;
            pMyfile->file_status = bDataOut[11];

            switch(bDataOut[13])
            {
            case 0x00:	pMyfile->file_type = Binary_File;
                break;	
            case 0x01:	pMyfile->file_type = Fixed_Record_File;
                break;
            case 0x02:	pMyfile->file_type = Variable_Record_File;
                break;
            case 0x03:	pMyfile->file_type = Cyclic_File;
                break;
            case 0x04:	pMyfile->file_type = Program_File;
                break;
                ///////////////////////////////////////////////////////////////////////
                //  if GetResponse(...) is successful but bad file type is returned  //
                ///////////////////////////////////////////////////////////////////////
            default:	pMyfile->file_type = Unknown;
                throw iop::Exception(iop::ccFileTypeUnknown);
            }

            if (pMyfile->file_type == Cyclic_File ||
                pMyfile->file_type == Fixed_Record_File)
            {
                pMyfile->nb_sub_dir = bDataOut[14];						
                pMyfile->nb_file    = (pMyfile->nb_sub_dir)
                    ? pMyfile->file_size / pMyfile->nb_sub_dir
                    : 0;
            }

            ///////////////////////////////
            //  Select file and get ACL	 //
            ///////////////////////////////
           if (pMyfile->file_id != 0xFFFF)
			{
				
			    Select(pMyfile->file_id);

                SendCardAPDU(m_bClassByte, insGetACL, 0x00, 0x00, 0,
                             NULL, 0x08, bDataOut);

				memcpy((void*)(pMyfile->access_cond),	(void*)(bDataOut), 8);
				memset((void*)(pMyfile->applicationID), 0x00,			   16);
				
				/////////////////////////////////
				//  Reselect parent directory  //
				/////////////////////////////////
				Select(m_CurrentDirectory.Tail().GetShortID());					
			}
			break;

        }	// end case non-Directory/Instance files

    default:
        ///////////////////////////////////////////////////////////////////////////
        //  if GetResponse(...) is successful but bad file category is returned  //
        ///////////////////////////////////////////////////////////////////////////
        throw iop::Exception(iop::ccBadFileCategory);
    }	// end switch
}	

void
CAccessCard::ExternalAuth(const KeyType kt, const BYTE  bKeyNb, 
                          const BYTE bDataLength, const BYTE* bData)
{
	CLockWrap wrap(&m_IOPLock);

    BYTE bAlgo_ID = AsPrivateAlgId(kt);
    
    SendCardAPDU(m_bClassByte, insExternalAuth, bAlgo_ID,
                 bKeyNb, bDataLength, bData, 0, NULL);		 
			
}

void
CAccessCard::InternalAuth(const KeyType kt, const BYTE  bKeyNb, 
                          const BYTE bDataLength,	const BYTE*
                          bDataIn, BYTE* bDataOut)
{
	CLockWrap wrap(&m_IOPLock);
	////////////////////////////////////////////////////////////////////////////
	//  The following checks to make sure the internal Auth is not being      //
	//  used for DES, or for an RSA key operation of greater than 128 bytes.  //
	////////////////////////////////////////////////////////////////////////////
    BYTE bAlgo_ID = AsPrivateAlgId(kt);
	if (((bAlgo_ID != 0xC4) && (bAlgo_ID != 0xC6) &&
         (bAlgo_ID != 0xC8)) ||
        (bDataLength > 0x80))
		throw iop::Exception(iop::ccAlgorithmIdNotSupported);

	/////////////////////////////////////////////////////////////////////////
	// Need to reverse the byte order of the input data (big endian card)  //
	/////////////////////////////////////////////////////////////////////////
    if (cMaxApduLength < bDataLength)
        throw iop::Exception(iop::ccInvalidParameter);
    
	BYTE bReversedData[cMaxApduLength];

	for (BYTE bIndex = 0; bIndex < bDataLength; bIndex++)
		bReversedData[bIndex] = bDataIn[bDataLength - 1 - bIndex];

	SendCardAPDU(m_bClassByte, insInternalAuth,
                 bAlgo_ID, bKeyNb, bDataLength,
                 bReversedData, 0,	 NULL);
	
	GetResponse(m_bClassByte, bDataLength, bReversedData);

    //////////////////////////////////////////////////////
    //  Need to reverse the byte order of output data.  //
    //////////////////////////////////////////////////////						
    for (bIndex = 0; bIndex < bDataLength; bIndex++)
        bDataOut[bIndex] = bReversedData[bDataLength - 1 - bIndex];
}

void
CAccessCard::ReadRecord(const BYTE bRecNum, const BYTE bMode,
                        const BYTE bDataLen, BYTE *bData)
{
	CLockWrap wrap(&m_IOPLock);

    SendCardAPDU(m_bClassByte, 0xB2, bRecNum, bMode, 0, NULL,
                 bDataLen, bData);
}

void
CAccessCard::UpdateRecord(const BYTE bRecNum, const BYTE bMode,
                          const BYTE bDataLen, BYTE *bData)
{
	CLockWrap wrap(&m_IOPLock);

    SendCardAPDU(m_bClassByte, 0xDC, bRecNum, bMode, bDataLen, bData, 0, NULL);
}


void
CAccessCard::VerifyCHV(const BYTE bCHVNumber, const BYTE* bCHV)
{
	CLockWrap wrap(&m_IOPLock);
	SendCardAPDU(m_bClassByte, insVerifyChv, 0x00, bCHVNumber, 0x08,
                 bCHV,	0, NULL);
}

void
CAccessCard::VerifyKey(const BYTE bKeyNumber, const BYTE bKeyLength,
                       const BYTE* bKey)
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x2A, 0x00, bKeyNumber, bKeyLength,
                 bKey, 0, NULL);
}


void
CAccessCard::SelectCardlet(const BYTE *bAID, const BYTE bAIDLen)
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0xA4, 0x04, 0x00, bAIDLen, bAID, 0, NULL);
}

void
CAccessCard::SelectLoader()
{
	CLockWrap wrap(&m_IOPLock);
	SendCardAPDU(m_bClassByte, 0xA4, 0x04, 0x00, 0x00, NULL, 0, NULL);
}

void
CAccessCard::DeleteApplet()
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x08, 0x02, 0x00, 0x00, NULL, 0, NULL);
}


void
CAccessCard::ResetInstance()
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x08, 0x03, 0x00, 0x00,
                 NULL, 0, NULL);
}

void
CAccessCard::SetCurrentAsLoader()
{
	CLockWrap wrap(&m_IOPLock);
	SendCardAPDU(m_bClassByte, 0x08, 0x04, 0x00, 0x00, NULL, 0, NULL);
}


void
CAccessCard::SetDefaultAsLoader()
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x08, 0x05, 0x00, 0x00, NULL, 0, NULL);
}


void
CAccessCard::BlockApplet()
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x08, 0x07, 0x00, 0x00, NULL, 0, NULL);
}

void
CAccessCard::ValidateProgram(const BYTE *bSig, const BYTE bSigLength)
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x0A, 0x01, 0x00, bSigLength, bSig, 0, NULL);
}

void
CAccessCard::ResetProgram()
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, 0x0A, 0x02, 0x00, 0x00, NULL, 0, NULL);
}

void
CAccessCard::VerifyTransportKey(const BYTE *bKey)
{
	VerifyKey(0, 8, bKey);
}


void
CAccessCard::ExecuteMain()
{
	CLockWrap wrap(&m_IOPLock);
	SendCardAPDU(m_bClassByte, insExecuteMethod, 0x02, 0x00, 0x00,
                 NULL, 0, NULL);
}

void
CAccessCard::ExecuteInstall(const BYTE *bBlock, const BYTE bLen)
{
	CLockWrap wrap(&m_IOPLock);
    SendCardAPDU(m_bClassByte, insExecuteMethod, 0x13, 0x00, bLen,
                 bBlock, 0, NULL);
}

void
CAccessCard::SelectParent() 
{	
	CLockWrap wrap(&m_IOPLock);
	RequireSelect();

	///////////////////////////////////////////////////
	//  If current directory is root, reselect root  //
	///////////////////////////////////////////////////
	if (m_CurrentDirectory.NumComponents() == 1)
		Select(0x3F00);
	else
	{
		SendCardAPDU(m_bClassByte, 0xA4, 0x03, 0x00, 0, NULL, 0, NULL);
		m_CurrentDirectory.ChopTail();
		m_CurrentFile = m_CurrentDirectory;
	}
}

void
CAccessCard::Select(const WORD wFileID)
{
	CLockWrap wrap(&m_IOPLock);
	BYTE bDataIn[2];
	bDataIn[0] = (BYTE)(MSB(wFileID));
	bDataIn[1] = (BYTE)(LSB(wFileID));

	SendCardAPDU(m_bClassByte, 0xA4, 0x00, 0x00, 0x02, bDataIn, 0, NULL);
}

void
CAccessCard::LogoutAll()
{
    if(m_fSupportLogout)
    {
	    CLockWrap wrap(&m_IOPLock);
	
    	SendCardAPDU(m_bClassByte, 0x22, 0x07, 0x00, 0x00, NULL, 0, NULL);
    }
    else
        ResetCard();
}

void
CAccessCard::Select(const char* szFileFullPath, FILE_HEADER* pMyfile,
                    const bool fSelectAll)
{
	CLockWrap wrap(&m_IOPLock);
	BYTE bIndex = 0;
	char szFormattedPath[cMaxPathLength];
	BYTE bFileCount = FormatPath(szFormattedPath, szFileFullPath);
	BYTE bPathLength = strlen(szFormattedPath);

    auto_ptr<FilePath> apfp(new FilePath(string(szFormattedPath)));

	///////////////////////////////////////////////////////////
    //  Select all files in path regardless of current path. //
	//  Do this on request, or if cache is empty			 //
	///////////////////////////////////////////////////////////
	if (fSelectAll || (m_CurrentFile.IsEmpty()) || (m_CurrentDirectory.IsEmpty()))
	{
		bIndex = 0;			
	}
	////////////////////////////////////////////////////////
	//  if path names match, do nothing	except get file info  //
	////////////////////////////////////////////////////////
	else if (m_CurrentFile == *apfp)
	{
		bIndex = 0;			
        if (pMyfile) // force Select to get file info
        {
            if (1 < bFileCount)
            {
                if (m_CurrentFile == m_CurrentDirectory)
                    bIndex = bFileCount - 1;      // just reselect dir
                else
                    bIndex = bFileCount - 2;      // select dir & file
                SelectParent();
            }
        }
        else
            bIndex = bFileCount;
	}
	////////////////////////////////////////////////////////////////////
	//  if current directory is in path, only select remaining files  //
	////////////////////////////////////////////////////////////////////
	else if(m_CurrentDirectory.NumComponents() < apfp->NumComponents())
	{			
		if (apfp->GreatestCommonPrefix(m_CurrentDirectory) == m_CurrentDirectory)
			bIndex = m_CurrentDirectory.NumComponents();
		else
			bIndex = 0;
	}		
	////////////////////////////////////////////////////////////////////
	//  if new path share part of current directory, step upwards     //
	////////////////////////////////////////////////////////////////////
	else if(m_CurrentDirectory.NumComponents() > apfp->NumComponents())
    {
        BYTE bSharedPathLen;

        bSharedPathLen = apfp->GreatestCommonPrefix(m_CurrentDirectory).NumComponents();

        if(bSharedPathLen>1)        // Not worth while to step up to 3F00.
        {  
            BYTE bLevelsUp = m_CurrentDirectory.NumComponents() - bSharedPathLen;
            bool fSelectFailed = false;
            try
            {
                for(int i=0; i < bLevelsUp; i++) 
                {
                    SelectParent();
                }
            }
            
            catch (Exception const &)
            {
				// TODO: Not sure if this is handling correctly!
                fSelectFailed = true;
            }

            if (fSelectFailed)
                bIndex = 0;
            else
                bIndex = bSharedPathLen;
        }
        else 
    		bIndex = 0;
    }
			
	//////////////////////////////////////////
	//  Select the necessary files in path  //
	//////////////////////////////////////////	
	char sFileToSelect[5] = { 0, 0, 0, 0, 0 };
    bool fFileSelected = false;
    bool fSelectFailed = false;
    try
    {
        while (bIndex < bFileCount)
        {			
            WORD wFileHexID = (*apfp)[bIndex].GetShortID();
            Select(wFileHexID);
            fFileSelected = true;
            bIndex++;
        }
    }

    catch (Exception const &)
    {
        fSelectFailed = true;
        if (fSelectAll)
            throw; // TODO: throw something useful, eh?
    }

    if (fSelectFailed) // assert(!fSelectAll)
    {
        Select(szFormattedPath,pMyfile,true);
        fFileSelected = true;
    }
    
	BYTE bResponseLength = 0;
    if (fFileSelected)
        bResponseLength = ResponseLengthAvailable();

	////////////////////////////////////////////////////
	//  GetResponse and fill file header information  //
	////////////////////////////////////////////////////
	switch(bResponseLength)
	{
		case 0x17:
		case 0x28:
		{				
            ////////////////////////////////////////////////
            //  File selected is a directory or Instance  //
            ////////////////////////////////////////////////
			m_CurrentDirectory = *apfp;
			m_CurrentFile = *apfp;

            if (pMyfile)
            {
                BYTE bDataOut[0x28];
			
                GetResponse(m_bClassByte, bResponseLength, bDataOut);

                pMyfile->file_id     = (WORD)(bDataOut[4] * 256 + bDataOut[5]);
                pMyfile->file_size   = (WORD)(bDataOut[2] * 256 + bDataOut[3]);
                pMyfile->nb_file     = bDataOut[15];			
                pMyfile->nb_sub_dir  = bDataOut[14];
                pMyfile->file_status = 0x01;
			
                if (bResponseLength == 0x17)  
                {
                    ////////////////////////////////////
                    //  File selected is a directory  //
                    ////////////////////////////////////
                    pMyfile->file_type   = directory;				
                    pMyfile->AIDLength   = 0;

                    memset((void*)(pMyfile->applicationID), 0x00, 16);
                }
                else
                {
                    ////////////////////////////////////
                    //  File selected is an Instance  //
                    ////////////////////////////////////

                    /////////////////////////////////////////////////////
                    //  Instance files contain one "hidden" file for   //
                    //  program data that should not be shown to the   //
                    //  users                                          //
                    /////////////////////////////////////////////////////
                    pMyfile->nb_file--;

                    pMyfile->file_type   = Instance;					
                    pMyfile->AIDLength   = bDataOut[23];

                    memcpy((void*)(pMyfile->applicationID), 
                           (void*)(&bDataOut[24]), pMyfile->AIDLength);

                    ////////////////////////////////////////////////////
                    //  Set flags in file status to discriminate      //
                    //  applets/applications                          //
                    ///////////////////////////////////////////////////
                    switch(bDataOut[9])
                    {
					case 0x01:	pMyfile->file_status |= (1 << 5);	//  Applet
                        break;
					case 0x02:	pMyfile->file_status |= (1 << 4);	//  Application
                        break;
					case 0x03:  pMyfile->file_status |= (3 << 4);	//  Both
                        break;
                    }

                    ////////////////////////////////////////////////
                    //  Set flags in file status to discriminate  //
                    //	created/installed/registered instances    //
                    ////////////////////////////////////////////////
                    switch(bDataOut[10])
                    {
					case 0x01:	pMyfile->file_status |= (1 << 1);	//  Created
                        break;
					case 0x02:	pMyfile->file_status |= (1 << 2);	//  Installed
                        break;
					case 0x03:	pMyfile->file_status |= (1 << 3);	//  Registered
                        break;
                    }
                }

                ////////////////////
                //  Get file ACL  //
                ////////////////////
                SendCardAPDU(m_bClassByte, 0xFE, 0x00, 0x00, 0, 
                             NULL,0x08, bDataOut);
			
                memcpy((void*)(pMyfile->access_cond), (void*)(bDataOut), 8);
            }
            
			break;

		}	//  end case directory or Instance file

		case  0x0F:
		{				
            ////////////////////////////////////////////////////////
            //  File selected is an elementary file of some type  //
            ////////////////////////////////////////////////////////
			m_CurrentFile = *apfp;
			apfp->ChopTail();
			m_CurrentDirectory = *apfp;

            if (pMyfile)
            {
                BYTE bDataOut[0x0F];

                GetResponse(m_bClassByte, bResponseLength, bDataOut);

                pMyfile->file_id	 = (WORD)(bDataOut[4] * 256 + bDataOut[5]);
                pMyfile->file_size	 = (WORD)(bDataOut[2] * 256 + bDataOut[3]);
                pMyfile->nb_file	 = 0x00;
                pMyfile->nb_sub_dir  = 0x00;
                pMyfile->AIDLength	 = 0x00;
                pMyfile->file_status = bDataOut[11];

                memset((void*)pMyfile->applicationID, 0, 16);

                switch(bDataOut[13])
                {	
				case 0x00:	pMyfile->file_type  = Binary_File;
                    break;

				case 0x01:	pMyfile->file_type  = Fixed_Record_File;
                    pMyfile->nb_sub_dir = bDataOut[14];
                    pMyfile->nb_file    = pMyfile->file_size /
                        pMyfile->nb_sub_dir;
                    break;

				case 0x02:	pMyfile->file_type  = Variable_Record_File;
                    break;

				case 0x03:	pMyfile->file_type  = Cyclic_File;
                    pMyfile->nb_sub_dir = bDataOut[14];
                    pMyfile->nb_file    = pMyfile->file_size /
                        pMyfile->nb_sub_dir;
                    break;

				case 0x04:	pMyfile->file_type  = Program_File;
                    break;
                    //////////////////////////////////////////////////////////
                    //  if GetResponse(...) is successful but bad file      //
                    //  type is returned                                    //
                    //////////////////////////////////////////////////////////
				default:	pMyfile->file_type = Unknown;
                    throw iop::Exception(iop::ccFileTypeUnknown);
                }

                ////////////////////
                //  Get file ACL  //
                ////////////////////
                SendCardAPDU(m_bClassByte, 0xFE, 0x00, 0x00, 0, 
                             NULL, 0x08, bDataOut);

                memcpy((void*)(pMyfile->access_cond), (void*)(bDataOut), 8);
            }
			break;

		}	//  end case elementary file			

		default:
			//////////////////////////////////////////////////////////////////
			//  GetResponse was successful but returned an uninterpretable  //
			//////////////////////////////////////////////////////////////////
            if (fFileSelected)
                throw iop::Exception(iop::ccCannotInterpretGetResponse);
	}		//	end of SWITCH
}

void
CAccessCard::CreateFile(const FILE_HEADER* pMyfile)
{
	CLockWrap wrap(&m_IOPLock);

	BYTE bDataIn[16];		
	
	/////////////////////////////////////////////////////
	//  Cyberflex cards don't allocate space for file  //
	//  headers implicity, so it's done here manually  //
	/////////////////////////////////////////////////////
	WORD wFileSize;
	if (pMyfile->file_type == directory)
		wFileSize = pMyfile->file_size + 24;
	else
		wFileSize = pMyfile->file_size + 16;
	
	////////////////////////////////////////////////////
	//  Cyclic files need a 4 byte header per record  //
	////////////////////////////////////////////////////
	if (pMyfile->file_type == Cyclic_File)
	{
		/////////////////////////////////////////
		// prevent overflow error in card OS!  //
		/////////////////////////////////////////
		if (pMyfile->nb_sub_dir > 251)
			throw iop::Exception(iop::ccCyclicRecordSizeTooLarge);
		
		bDataIn[6] = pMyfile->nb_sub_dir + 4;
		wFileSize += pMyfile->nb_file    * 4;		
	}
	else
		bDataIn[6] = pMyfile->nb_sub_dir;

	bDataIn[0] = MSB(wFileSize);
	bDataIn[1] = LSB(wFileSize);	
	bDataIn[2] = MSB(pMyfile->file_id);
	bDataIn[3] = LSB(pMyfile->file_id);		
	bDataIn[5] = pMyfile->file_status & 1;		
	bDataIn[7] = pMyfile->nb_file;

	switch(pMyfile->file_type)
	{
		case Binary_File:			bDataIn[4] = 0x02;
									break;
		case directory:				bDataIn[4] = 0x20;
									break;
		case Cyclic_File:			bDataIn[4] = 0x1D;
									break;
		case Variable_Record_File:	bDataIn[4] = 0x19;
									break;
		case Fixed_Record_File:		bDataIn[4] = 0x0C;
									break;
		case Instance:				bDataIn[4] = 0x21;
									break;
		case Program_File:			bDataIn[4] = 0x03;
									break;

		//////////////////////////////////
		//  Requested file type is bad  //
		//////////////////////////////////
		default:
                                    // TO DO: Why not let the card return the
                                    // error?
									throw iop::Exception(iop::ccFileTypeInvalid);
                                    
	}

	memcpy((void*)&bDataIn[8], (void*)(pMyfile->access_cond), 8);		

	SendCardAPDU(m_bClassByte, insCreateFile, 0x00, 0x00, 0x10,
                 bDataIn, 0, NULL);

    Dirty(true);
    
}

void
CAccessCard::WritePublicKey(const CPublicKeyBlob aKey, const BYTE bKeyNum)
{

	CLockWrap wrap(&m_IOPLock);

    BYTE bAlgoID;
    
    switch(aKey.bModulusLength)
    {
    case 0x40:
        bAlgoID = 0xC5;
        break;

    case 0x60:
        bAlgoID = 0xC7;
        break;

    case 0x80:
        bAlgoID = 0xC9;
        break;

    default:
        throw iop::Exception(iop::ccAlgorithmIdNotSupported);
    }

	Select(0x1012);
		

	DWORD dwKeyBlockLen = 4 + 9 + aKey.bModulusLength + 4;

	BYTE bKeyBlob[256];

	bKeyBlob[0] = (BYTE) ((dwKeyBlockLen >> 8) & 0xFF);
	bKeyBlob[1] = (BYTE) (dwKeyBlockLen & 0xFF);
	bKeyBlob[2] = bKeyNum;
	bKeyBlob[3] = bAlgoID;
	bKeyBlob[4] = 0xC1;
	bKeyBlob[5] = 0x01;
	bKeyBlob[6] = 0x02;
	bKeyBlob[7] = 0xC0;
	bKeyBlob[8] = (BYTE)aKey.bModulusLength + 1;
	bKeyBlob[9] = 0x00;
	
	//////////////////////////////////////////////////
	//  Convert modulus to big endian for the card  //
	//////////////////////////////////////////////////
	for (int i = 0; i < aKey.bModulusLength; i++)
		bKeyBlob[10 + i] = aKey.bModulus[aKey.bModulusLength - 1 - i];

	bKeyBlob[10 + aKey.bModulusLength] = 0xC0;
	bKeyBlob[11 + aKey.bModulusLength] = 0x04;

	///////////////////////////////////////////////////
	//  Convert exponent to big endian for the card  //
	///////////////////////////////////////////////////
	for (i = 0; i < 4; i++)
		bKeyBlob[12 + aKey.bModulusLength + i] = aKey.bExponent[3 - i];

	WORD wOffset = (WORD) (dwKeyBlockLen * bKeyNum);

	WriteBinary(wOffset, (WORD) dwKeyBlockLen, bKeyBlob);			
}

void 
CAccessCard::GetSerial(BYTE* bSerial, size_t &SerialLength)
{
	if (bSerial == NULL)
	{
		SerialLength = 22;
		return;
	}

    if (SerialLength < 22)
    {
        throw iop::Exception(ccBufferTooSmall);
    }

    SerialLength = 22;

	SendCardAPDU(m_bClassByte, 0xCA, 0x00, 0x01, 0, 
                 NULL, 22, bSerial);
}


void
CAccessCard::ReadPublicKey(CPublicKeyBlob *aKey, const BYTE bKeyNum)
{
	CLockWrap wrap(&m_IOPLock);
	BYTE bKeyLength[2];

	Select(0x1012);
	ReadBinary(0,2,bKeyLength);


	WORD wKeyBlockLength = bKeyLength[0] * 256 + bKeyLength[1];
	WORD wOffset		 = (WORD)(wKeyBlockLength * bKeyNum);
	BYTE bBuffer[512];

	ReadBinary(wOffset, wKeyBlockLength, bBuffer);

	aKey->bModulusLength = bBuffer[8] - 1;

	scu::AutoArrayPtr<BYTE> aabModule(new BYTE[aKey->bModulusLength]);
	BYTE aExponent[4];

	memcpy((void*)aabModule.Get(), (void*)&bBuffer[10], aKey->bModulusLength);
	memcpy((void*)aExponent, (void*)&bBuffer[10 + aKey->bModulusLength + 2], 4);

	/////////////////////////////////////////////////////////////////////////
	//  Change from big endian on the card to little endian in the struct  //
	/////////////////////////////////////////////////////////////////////////
	for (WORD i = 0; i < aKey->bModulusLength; i++)
		aKey->bModulus[i]  = aabModule[aKey->bModulusLength - 1 - i];
	for (i = 0; i < 4; i++)
		aKey->bExponent[i] = aExponent[3 - i];		
}

// There are some slightly arbitrary constants used here...tighten down later.

void
CAccessCard::WritePrivateKey(const CPrivateKeyBlob aKey, const BYTE bKeyNum)
{

	CLockWrap wrap(&m_IOPLock);

    BYTE bAlgoID;
    
    switch(aKey.bPLen)
    {
    case 0x20:
        bAlgoID = 0xC4;
        break;

    case 0x30:
        bAlgoID = 0xC6;
        break;

    case 0x40:
        bAlgoID = 0xC8;
        break;

    default:
        throw iop::Exception(iop::ccAlgorithmIdNotSupported);
    }

	Select(0x0012);

	CPrivateKeyBlob anotherKey;

	WORD wKeyBlockLength = 22 + 5 * aKey.bPLen;
	WORD wOffset		 = (WORD)(bKeyNum * wKeyBlockLength);

	scu::SecureArray<BYTE> bKeyBlob(1024);
	bKeyBlob[0]	   = (BYTE)((wKeyBlockLength >> 8) & 0xFF);
	bKeyBlob[1]    = (BYTE)(wKeyBlockLength & 0xFF);
	bKeyBlob[2]    = bKeyNum;
	bKeyBlob[3]    = bAlgoID;
	bKeyBlob[4]    = 0xC2;
	bKeyBlob[5]    = 0x01;
	bKeyBlob[6]    = 0x05;

	////////////////////////////////////////////////////////////////////////
	//  Need to convert from little endian (struct) to big endian (card)  //
	////////////////////////////////////////////////////////////////////////
	scu::SecureArray<BYTE> bP(256);
	scu::SecureArray<BYTE> bQ(256);
	scu::SecureArray<BYTE> bQInv(256);
	scu::SecureArray<BYTE> bKmodP(256);
	scu::SecureArray<BYTE> bKmodQ(256);

	for (WORD i = 0; i < aKey.bPLen; i++)
	{
		bP[i]	  = aKey.bP[aKey.bQLen - 1 - i];
		bQ[i]	  = aKey.bQ[aKey.bPLen - 1 - i];
		bQInv[i]  = aKey.bInvQ[aKey.bInvQLen - 1 - i];
		bKmodP[i] = aKey.bKsecModP[aKey.bKsecModQLen - 1 - i];
		bKmodQ[i] = aKey.bKsecModQ[aKey.bKsecModPLen - 1 - i];
	}

	//////////////////////////////////////////////////////
	//  Now we need to left align the bytes of P and Q  //
	//////////////////////////////////////////////////////
	BYTE pShift = 0, qShift = 0, qIShift = 0;
	/* Punting on bad keys!
	if ((bP[0] < 8) || (bQ[0] < 8)) {
		// Bad key?
		delete bP;
		delete bQ;
		delete bQInv;
		delete bKmodP;
		delete bKmodQ;
		delete bKeyBlob;
		return FALSE;
	}
	*/

	bKeyBlob[7] = 0xC2;
	bKeyBlob[8] = (BYTE) aKey.bPLen + 1;
	bKeyBlob[9] = 0x00;

	memcpy((void*) &bKeyBlob[10],				   (void*)bQ.data(),	  aKey.bPLen);
	bKeyBlob[10 + aKey.bPLen]    = 0xC2;
	bKeyBlob[11 + aKey.bPLen]    = (BYTE) aKey.bQLen + 1;
	bKeyBlob[12 + aKey.bPLen]    = 0x00;

	memcpy((void*) &bKeyBlob[13 + aKey.bPLen],	   (void*)bP.data(),	  aKey.bPLen);
	bKeyBlob[13 + 2* aKey.bPLen] = 0xC2;
	bKeyBlob[14 + 2* aKey.bPLen] = (BYTE) aKey.bQLen + 1;
	bKeyBlob[15 + 2* aKey.bPLen] = 0x00;

	memcpy((void*) &bKeyBlob[16 + 2* aKey.bPLen],  (void*)bQInv.data(),  aKey.bPLen);
	bKeyBlob[16 + 3* aKey.bPLen] = 0xC2;
	bKeyBlob[17 + 3* aKey.bPLen] = (BYTE) aKey.bQLen + 1;
	bKeyBlob[18 + 3* aKey.bPLen] = 0x00;

	memcpy((void*) &bKeyBlob[19 + 3* aKey.bPLen],  (void*)bKmodQ.data(), aKey.bPLen);
	bKeyBlob[19 + 4* aKey.bPLen] = 0xC2;
	bKeyBlob[20 + 4* aKey.bPLen] = (BYTE) aKey.bQLen + 1;
	bKeyBlob[21 + 4* aKey.bPLen] = 0x00;

	memcpy((void*) &bKeyBlob[22 + 4 * aKey.bPLen], (void*)bKmodP.data(), aKey.bPLen);

	WriteBinary(wOffset, wKeyBlockLength, bKeyBlob.data());			
}

void
CAccessCard::ChangeCHV(const BYTE bKeyNumber, const BYTE *bOldCHV,
                       const BYTE *bNewCHV)
{
	CLockWrap wrap(&m_IOPLock);
	scu::SecureArray<BYTE> bDataIn(16);
	memcpy((void*)bDataIn.data(),	     (void*)bOldCHV, 8);
	memcpy((void*)(bDataIn.data() + 8), (void*)bNewCHV, 8);
	
	SendCardAPDU(m_bClassByte, 0x24, 0x00, bKeyNumber, 16, 
                 bDataIn.data(), 0, NULL);
	
    Dirty(true);
    
}

void
CAccessCard::ChangeCHV(const BYTE bKey_nb, const BYTE *bNewCHV)
{

    CLockWrap wrap(&m_IOPLock);

	switch (bKey_nb)
	{
		case 1:   Select("/3f00/0000");	// CHV1 and CHV2 are the only CHV's supported
				  break;
		case 2:   Select("/3f00/0100");
				  break;

		default:  throw iop::Exception(iop::ccInvalidChv);
                  break;
	}

	WriteBinary(3, 8, bNewCHV);

    BYTE bRemaingAttempts = 3;      //  Minumum number + 2
	WriteBinary(12, 1, &bRemaingAttempts);
		
    Dirty(true);
    
    VerifyCHV(bKey_nb,bNewCHV);

}

void
CAccessCard::UnblockCHV(const BYTE bKeyNumber,
                        const BYTE *bUnblockPIN, const BYTE *bNewPin)
{
	CLockWrap wrap(&m_IOPLock);

	scu::SecureArray<BYTE> bDataIn(16);
	memcpy((void*)bDataIn.data(),		 (void*)bUnblockPIN, 8);
	memcpy((void*)(bDataIn.data() + 8), (void*)bNewPin,	 8);

	SendCardAPDU(m_bClassByte, 0x2C, 0x00, bKeyNumber, 16, 
                 bDataIn.data(), 0, NULL);

    Dirty(true);
    
}

void
CAccessCard::ChangeUnblockKey(const BYTE bKeyNumber, const BYTE *bNewPIN)
{
	CLockWrap wrap(&m_IOPLock);

	switch (bKeyNumber)
	{
		case 1:   Select("/3f00/0000");	// CHV1 and CHV2 are the only CHV's supported
				  break;
		case 2:   Select("/3f00/0100");
				  break;

		default:  throw iop::Exception(iop::ccInvalidChv);
                  break;
	}

    WriteBinary(13, 8, bNewPIN);
}

void
CAccessCard::ChangeTransportKey(const BYTE *bNewKey)
{
	CLockWrap wrap(&m_IOPLock);
	Select("/3f00/0011");
					   

	//////////////////////////////////////////
	//  Build byte string to write to card  //
	//////////////////////////////////////////						   
	BYTE bKeyString[13] = 
	{
	   0x00,					// length of key
	   0x0E,					// length of key
	   0x00,					// Key number
	   0x01,					// tag to identify key as an ID PIN
	   0, 0, 0, 0, 0, 0, 0, 0,  // 8 bytes for key
	   0x03						// # of verification attempts remaining before card is blocked + 2
	};
    // copy the template into a secure array for storing the sensitive
    // part 
    const WORD wKeySize = 13;
	scu::SecureArray<BYTE> newbKeyStr(bKeyString,wKeySize);
    
	//////////////////////////////////////////////////////
	//  insert new key into key string to pass to card  //
	//////////////////////////////////////////////////////
	memcpy((void*)(newbKeyStr.data() + 4), (void*)bNewKey, 8);

	WriteBinary(0, wKeySize, newbKeyStr.data());

    // Make a (hopefully) successfull verification to re-set attempt counter

    VerifyTransportKey(bNewKey);
}

void
CAccessCard::ChangeACL(const BYTE *bACL)
{
	CLockWrap wrap(&m_IOPLock);

	SendCardAPDU(m_bClassByte, 0xFC, 0x00, 0x00, 0x08,
                 bACL, 0, NULL);

    Dirty(true);
}

void
CAccessCard::DefaultDispatchError(ClassByte cb,
                                  Instruction ins,
                                  StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;
    
    switch (sw)
    {
    case 0x6283:
        cc = ccContradictionWithInvalidationStatus;
        break;
    
    case 0x6300:
        cc = ccChvVerificationFailedMoreAttempts;
        break;
    
    case 0x6981:
        cc = ccChvNotInitialized;
        break;

    case 0x6985:
        cc = ccNoFileSelected;
        break;

    case 0x6A00:
        cc = ccFileExists;
        break;

    case 0x6A84:
        cc = ccCannotReadOutsideFileBoundaries;
        break;

    case 0x6A86:
        cc = ccLimitReached;
        break;

    case 0x6F11:
        cc = ccDirectoryNotEmpty;
        break;

    case 0x6F12:
        cc = ccInvalidSignature;
        break;

    case 0x6F14:
        cc = ccBadState;
        break;
    
    default:
        fDoThrow = false;
        break;
    }

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);

    CSmartCard::DefaultDispatchError(cb, ins, sw);
}

void
CAccessCard::DispatchError(ClassByte cb,
                           Instruction ins,
                           StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;
    
    switch (ins)
    {
    case insCreateFile:
        switch (sw)
        {
        case 0x6A00:
            cc = ccFileExists;
            break;

        case 0x6A84:
            cc = ccOutOfSpaceToCreateFile;
            break;
            
        case 0x6B00:
            cc = ccRecordInfoIncompatible;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insDeleteFile:
        switch (sw)
        {
        case 0x6A00:
            cc = ccRootDirectoryNotErasable;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insDirectory:
        switch (sw)
        {
        case 0x6985:
            cc = ccCurrentDirectoryIsNotSelected;
            break;

        case 0x6A83:
            cc = ccFileIndexDoesNotExist;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insExecuteMethod:
        switch (sw)
        {
        case 0x6283:
            cc = ccProgramFileInvalidated;
            break;

        case 0x6A00:
            cc = ccInstanceIdInUse;
            break;

        case 0x6F15:
            cc = ccCardletNotInRegisteredState;
            break;

        case 0x6F19:
            cc = ccInstallCannotRun;
            break;

        default:
            if ((0x6230 <= sw) && (0x6260 <= sw))
                cc = ccJava;
            else
                fDoThrow = false;
        }
        break;
    
    case insExternalAuth:
        switch (sw)
        {
        case 0x6300:
            cc = ccVerificationFailed;
            break;

        case 0x6981:
            cc = ccInvalidKey;
            break;

        case 0x6985:
            cc = ccAskRandomNotLastApdu;
            break;

        case 0x6B00:
            cc = ccAlgorithmIdNotSupported;
            break;

        case 0x6F15:
            cc = ccOperationNotActivatedForApdu;
            break;
    
        default:
            fDoThrow = false;
            break;
        }
        break;
        
    case insInternalAuth:
        switch (sw)
        {
        case 0x6300:
            cc = ccRequestedAlgIdMayNotMatchKeyUse;
            break;
            
        case 0x6981:
            cc = ccInvalidKey;
            break;

        case 0x6B00:
            cc = ccAlgorithmIdNotSupported;
            break;

        case 0x6F15:
            cc = ccOperationNotActivatedForApdu;
            break;
    
        default:
            fDoThrow = false;
            break;
        }
        break;
        
    case insReadBinary:
        // fall-through intentional
    case insUpdateBinary:
        switch (sw)
        {
        case 0x6A84:
            cc = ccCannotReadOutsideFileBoundaries;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    default:
        fDoThrow = false;
        break;
    }

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);

    CSmartCard::DispatchError(cb, ins, sw);
}

void
CAccessCard::DoReadBlock(WORD wOffset,
                         BYTE *pbBuffer,
                         BYTE bLength)
{
    SendCardAPDU(m_bClassByte, insReadBinary, HIBYTE(wOffset),
                 LOBYTE(wOffset), 0, 0,  bLength, pbBuffer);
			
}
        
void
CAccessCard::DoWriteBlock(WORD wOffset,
                          BYTE const *pbBuffer,
                          BYTE cLength)
{
    SendCardAPDU(m_bClassByte, insUpdateBinary, HIBYTE(wOffset),
                 LOBYTE(wOffset), cLength, pbBuffer,  0, 0);
}
    
bool
CAccessCard::ValidClassByte(BYTE bClassByte)
{
    ////////////////////////////////////////////////////////////////
    //  Calling Directory on root to check for proper class byte  //
    ////////////////////////////////////////////////////////////////

	BYTE bOutput[cMaxDirInfo];

    bool fValidClassByte = true;
    
    try
    {
        SendCardAPDU(bClassByte, insDirectory, 0x00, 0x00, 0, NULL,
                     sizeof bOutput / sizeof *bOutput, bOutput);
    }

    catch (Exception &)
    {
        fValidClassByte = false;
    }

    return fValidClassByte;
}

bool
CAccessCard::SupportLogout()
{
    bool fSuccess = true;
    try
    {
    	CLockWrap wrap(&m_IOPLock);
	    SendCardAPDU(m_bClassByte, 0x22, 0x07, 0x00, 0x00, NULL, 0, NULL);

    }
    catch(...)
    {
        fSuccess =  false;
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\accesscard.h ===
// AccessCard.h: interface for the CAccessCard class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(ACCESSCARD_H__INCLUDED_)
#define ACCESSCARD_H__INCLUDED_

#include "DllSymDefn.h"
#include "SmartCard.h"

namespace iop
{
	class IOPDLL_API CAccessCard : public CSmartCard
	{
	public:
		CAccessCard(const SCARDHANDLE  hCardHandle, const char* szReaderName,
					const SCARDCONTEXT pContext,	const DWORD dwMode);
		virtual ~CAccessCard();

		virtual void DeleteFile(const WORD wFileID);
		virtual void CreateFile(const FILE_HEADER* pMyFile);

		virtual void SelectParent();
		virtual void Directory	(const BYTE  bFile_Nb,		 FILE_HEADER* pMyFile);
		virtual void Select		(const char* szFileFullPath, FILE_HEADER* pMyFile=NULL, const bool fSelectAll = false);
		virtual void SelectCardlet(const BYTE *bAID, const BYTE bAIDLen);
		virtual void SelectLoader();
		virtual void GetSerial(BYTE* bSerial, size_t &SerialLength);

		virtual void DeleteApplet();
		virtual void ResetInstance();
		virtual void SetCurrentAsLoader();
		virtual void SetDefaultAsLoader();
		virtual void BlockApplet();

		virtual void ValidateProgram(const BYTE *bSig, const BYTE bSigLength);
		virtual void ResetProgram();
		
		virtual void ExecuteMain();
		virtual void ExecuteInstall(const BYTE *bBlock, const BYTE bLen);

		virtual void ReadRecord(const BYTE bRecNum, const BYTE bMode, const BYTE bDataLen, BYTE *bData);		
		virtual void UpdateRecord(const BYTE bRecNum, const BYTE bMode, const BYTE bDataLen, BYTE *bData);
		virtual void VerifyKey	(const BYTE bKeyNumber,	const BYTE  bKeyLength,	const BYTE* bKey);
		virtual void VerifyCHV	(const BYTE bCHVNumber,	const BYTE* bCHV);
		virtual void VerifyTransportKey(const BYTE *bKey);		
		virtual void LogoutAll();	

        virtual void GetChallenge(const DWORD dwNumberLength, BYTE* bRandomNumber);
		virtual void ExternalAuth(const KeyType kt,		const BYTE  bKeyNb, 
								  const BYTE bDataLength,   const BYTE* bData);		
		virtual void InternalAuth(const KeyType kt,		const BYTE  bKeyNb, 
								  const BYTE bDataLength,	const BYTE* bDataIn, BYTE* bDataOut);		

		virtual void ReadPublicKey	(CPublicKeyBlob *aKey,		 const BYTE bKeyNum);
		virtual void WritePublicKey	(const CPublicKeyBlob  aKey, const BYTE bKeyNum);
        virtual void WritePrivateKey(const CPrivateKeyBlob aKey, const BYTE bKeyNum);

		virtual void ChangeACL		   (const BYTE *bACL);
		virtual void ChangeCHV		   (const BYTE bKeyNumber, const BYTE *bOldCHV,		const BYTE *bNewCHV);
        virtual void ChangeCHV         (const BYTE bKey_nb, const BYTE *bNewCHV);
		virtual void UnblockCHV		   (const BYTE bKeyNumber, const BYTE *bUnblockPIN, const BYTE *bNewPin);
		virtual void ChangeUnblockKey  (const BYTE bKeyNumber, const BYTE *bNewPIN);
		virtual void ChangeTransportKey(const BYTE *bNewKey);			
		


	protected:
        virtual void
        DefaultDispatchError(ClassByte cb,
                             Instruction ins,
                             WORD StatusWord) const;

        virtual void
        DispatchError(ClassByte cb,
                      Instruction ins,
                      WORD StatusWord) const;

        virtual void
        DoReadBlock(WORD wOffset,
                    BYTE *pbBuffer,
                    BYTE bLength);

        virtual void
        DoWriteBlock(WORD wOffset,
                     BYTE const *pbBuffer,
                     BYTE cLength);
        virtual bool
        SupportLogout();

		virtual void Select(const WORD wFileID);
		BYTE m_bClassByte;
		
	private:
        enum                                      // size_t/count
        {
            cMaxDirInfo     = 0x28,
        };

        enum                                      // Instruction
        {
            insDeleteFile    = 0xE4,
            insDirectory     = 0xA8,
            insExecuteMethod = 0x0C,
            insExternalAuth  = 0x82,
			insGetACL		 = 0xFE,
        };
        
        bool
        ValidClassByte(BYTE bClassByte);

	};
}
#endif // !defined(AFX_ACCESSCARD_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\cryptocard.cpp ===
// CryptoCard.cpp: implementation of the CCryptoCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include <scuArrayP.h>

#include "iopExc.h"
#include "CryptoCard.h"
#include "LockWrap.h"

using namespace std;
using namespace iop;

namespace
{
    BYTE
    AsPrivateAlgId(KeyType kt)
    {
        BYTE bAlgId = 0;
        
        switch (kt)
        {
        case ktRSA512:
            bAlgId = 0x40;
            break;
            
        case ktRSA768:
            bAlgId = 0x60;
            break;
            
        case ktRSA1024:
            bAlgId = 0x80;
            break;
        case ktDES:
			bAlgId = 0x08;
			break;
        default:
            throw Exception(ccInvalidParameter);
            break;
        }

        return bAlgId;
    }

} // namespace 



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCryptoCard::CCryptoCard(const SCARDHANDLE hCardHandle, const char* szReaderName, 
						 const SCARDCONTEXT pContext,	const DWORD dwMode)
            : CSmartCard(hCardHandle, szReaderName, pContext, dwMode)
{

    m_fSupportLogout = SupportLogout();

}

CCryptoCard::~CCryptoCard()
{

}

void
CCryptoCard::LogoutAll()
{
    if(m_fSupportLogout)
    {
	    CLockWrap wrap(&m_IOPLock);
		SendCardAPDU(0xF0, 0x22, 0x07, 0, 0, NULL, 0, NULL);
    }
    else
        ResetCard();
}

void
CCryptoCard::DeleteFile(const WORD wFileID)
{
	CLockWrap wrap(&m_IOPLock);
	RequireSelect();
	
	////////////////////////////////////////////////////////
	//  Ensure that a directory is empty before deletion  //
	////////////////////////////////////////////////////////
	
	char cFilePathFormatter[2] = "/";
	char cZero[2]			   = "0";
	char sBuffer[4]			   = { 0, 0, 0, 0 };
	char szFileToDelete[80];
	FILE_HEADER FHeader;
	int  iPad;

	if (!(m_CurrentDirectory == m_CurrentFile))
	{
		/////////////////////////////////////////////////////////////////////////////////////////////
		//  File's parent directory was not selected (Currently selected file is not a directory)  //
		/////////////////////////////////////////////////////////////////////////////////////////////
		throw iop::Exception(iop::ccSelectedFileNotDirectory);
	}

	strcpy(szFileToDelete, m_CurrentDirectory.GetStringPath().c_str());				 
	strcat(szFileToDelete, cFilePathFormatter);				
	_itoa(wFileID, sBuffer, 16);	

	/////////////////////////////////////////////////////////////////////////
	//  Padding file path with 0 if file ID does not contain 4 characters  //
	/////////////////////////////////////////////////////////////////////////
	iPad = strlen(sBuffer);									
	while (iPad < 4)										
	{														
		strcat(szFileToDelete, cZero);						
		iPad++;												
	}														
	
	strcat(szFileToDelete, sBuffer);						//  
	szFileToDelete[m_CurrentDirectory.NumComponents() * 5 + 5] = '\0';	//	Select file to delete
	Select(szFileToDelete, &FHeader);

	if (FHeader.file_type == directory && (FHeader.nb_file + FHeader.nb_sub_dir) > 0)
	{
		////////////////////////////////////////////////////////
		//  re-establish current file and directory pointers  //
		////////////////////////////////////////////////////////
		SelectParent();			
		//////////////////////////////////////////////////////////////////////////////
		//  Directory was not empty, and will not be deleted.  Cryptoflex does not  //
		//  support this check internally -- this is the Cyberflex status code!     //
		//////////////////////////////////////////////////////////////////////////////
		throw iop::Exception(iop::ccDirectoryNotEmpty);
	}

	////////////////////////////////////////////////////////
	//  re-establish current file and directory pointers  //
	////////////////////////////////////////////////////////		
	szFileToDelete[strlen(szFileToDelete) - 5] = '\0';
	Select(szFileToDelete);		

	///////////////////////////////////////////////////////////////////////////
	//	File was not a directory or directory was empty - proceed to delete  //
	///////////////////////////////////////////////////////////////////////////
		
	BYTE bDataIn[2];
	bDataIn[0]   = (BYTE)(MSB(wFileID));
	bDataIn[1]   = (BYTE)(LSB(wFileID));	
	
	SendCardAPDU(0xF0, 0xE4, 0x00, 0x00, 0x02, bDataIn, 0, NULL);		
    
    Dirty(true);
}

void
CCryptoCard::CreateFile(const FILE_HEADER* pMyFile)
{
	CLockWrap wrap(&m_IOPLock);

	switch(pMyFile->file_type)
	{
		case Binary_File:
		case Variable_Record_File:		
		case Cyclic_File:
		case Fixed_Record_File:		
		{			
			BYTE bData[17];
			BYTE bP2;
			BYTE bDataLength;
			
			if (pMyFile->file_type == Binary_File)
				bP2 = 0x00;						// binary files have no records					
			else								
				bP2 = pMyFile->nb_file;			// number of records

			if (pMyFile->file_type == Binary_File || pMyFile->file_type	== Variable_Record_File)
			{	
				bDataLength = 0x10;
				bData[12]   = 0x03;
			}
			else
			{
			//////////////////////////////////////////////////////
			//  Cyclic and Fixed Record files contain an extra  //
			//  byte that denotes the length of their records   //
			//////////////////////////////////////////////////////
				bDataLength = 0x11;		
				bData[12]   = 0x04;
			}

			/////////////////////////////////////////////////////////////////////////////////
			//  Note: cyclic files also have an added 4B header allocated for each record  //
			//        in the file in addition to the space allocated by CreateFile(...)    //
			/////////////////////////////////////////////////////////////////////////////////

			bData[0] = 0;							//	RFU
			bData[1] = 0;							//	RFU				
			bData[2] = MSB(pMyFile->file_size);		//	File Size
			bData[3] = LSB(pMyFile->file_size);		//	File Size
			bData[4] = MSB(pMyFile->file_id);		//	File ID
			bData[5] = LSB(pMyFile->file_id);		//	File ID

			switch(pMyFile->file_type)				//  File type
			{
				case Binary_File:			bData[6] = 0x01;		break;
				case Variable_Record_File:  bData[6] = 0x04;		break;
				case Cyclic_File:			bData[6] = 0x06;		break;
				case Fixed_Record_File:		bData[6] = 0x02;		break;
			}
			bData[7]  = 0xFF;						
			bData[8]  = 0;							//	File ACL, to be set
			bData[9]  = 0;							//	File ACL, to be set
			bData[10] = 0;							//	File ACL, to be set
			bData[11] = pMyFile->file_status & 1;	//	File Status
		//	bData[12] = 0x03;						//	Length of the following data, already set
			bData[13] = 0;							//	AUT key numbers, to be set
			bData[14] = 0;							//	AUT key numbers, to be set
			bData[15] = 0;							//	AUT key numbers, to be set
			bData[16] = pMyFile->nb_sub_dir;		//  Record length (irrelevant for
													//  binary and variable record files)
			bool ReadACL[8];
			bool WriteACL[8];
			bool InvalidateACL[8];
			bool RehabilitateACL[8];

			CryptoACL Read         = { 0, 0, 0, 0, 0 };
			CryptoACL Write        = { 0, 0, 0, 0, 0 };
			CryptoACL Invalidate   = { 0, 0, 0, 0, 0 };
			CryptoACL Rehabilitate = { 0, 0, 0, 0, 0 };
			
			////////////////////////////////////////////////////////////////////////////
			//  Determination of the state of each action for each member of the ACL  //
			////////////////////////////////////////////////////////////////////////////

			for(int i = 0; i < 8; i++)
			{
				ReadACL[i]         = ((pMyFile->access_cond[i]) & 1)  ? true : false;
				WriteACL[i]        = ((pMyFile->access_cond[i]) & 2)  ? true : false;	
				InvalidateACL[i]   = ((pMyFile->access_cond[i]) & 8)  ? true : false;	
				RehabilitateACL[i] = ((pMyFile->access_cond[i]) & 16) ? true : false;
			}

			/////////////////////////////////////////////////
			//  Remapping Cyberflex ACL to Cryptoflex ACL  //
			/////////////////////////////////////////////////

            AccessToCryptoACL(ReadACL,         &Read);
            AccessToCryptoACL(WriteACL,        &Write);
            AccessToCryptoACL(InvalidateACL,   &Invalidate);
            AccessToCryptoACL(RehabilitateACL, &Rehabilitate);
			
			////////////////////////////////////
			//  Assignment of security level  //
			////////////////////////////////////
	
			bData[8]  = Read.Level			   * 16 + Write.Level;
			bData[10] = Rehabilitate.Level	   * 16 + Invalidate.Level;			
			bData[13] = Read.AUTnumber		   * 16 + Write.AUTnumber;	
			bData[15] = Rehabilitate.AUTnumber * 16 + Invalidate.AUTnumber;
			
			// If all the cyberflex ACL are 0, but the Cryptoflex are not, use the Cryptoflex.
			
			bool zero = true;
			for (int j = 0; j < 8; j++)
				if (pMyFile->access_cond[j] != 0x00) zero = false;

			if (zero)
			{
				// Use cryptoflex ACL)
				memcpy(&bData[7], pMyFile->CryptoflexACL, 4);
				memcpy(&bData[13], &(pMyFile->CryptoflexACL[4]),3);
			}

			SendCardAPDU(0xF0, insCreateFile, 0x00, bP2, bDataLength,
                         bData, 0, NULL);
		}

		break;		// end case non-Directory file

		case directory:
		{			
			BYTE bData[17];

			bData[0]  = 0;							//	RFU
			bData[1]  = 0;							//	RFU
			bData[2]  = MSB(pMyFile->file_size);		//	File Size
			bData[3]  = LSB(pMyFile->file_size);		//	File Size
			bData[4]  = MSB(pMyFile->file_id);		//	File ID
			bData[5]  = LSB(pMyFile->file_id);		//	File ID
			bData[6]  = 0x38;						//	File type
			bData[7]  = 0x00;						//	No Use for Dedicated files
			bData[8]  = 0;							//	File ACL, to be set
			bData[9]  = 0;							//	File ACL, to be set
			bData[10] = 0x00;						//	RFU
			bData[11] = pMyFile->file_status & 1;	//	File Status
			bData[12] = 0x04;						//	Length of the following data
			bData[13] = 0;							//  AUT key numbers, to be set
			bData[14] = 0;							//  AUT key numbers, to be set
			bData[15] = 0x00;						//	RFU
			bData[16] = 0xFF;						//	RFU

			bool DirNextACL[8];
			bool DeleteACL[8];
			bool CreateACL[8];			

			CryptoACL DirNext = { 0, 0, 0, 0, 0 };
			CryptoACL Delete  = { 0, 0, 0, 0, 0 };
			CryptoACL Create  = { 0, 0, 0, 0, 0 };	

			////////////////////////////////////////////////////////////////////////////
			//  Determination of the state of each action for each member of the ACL  //
			////////////////////////////////////////////////////////////////////////////

			for(int i = 0; i < 8; i++)
			{
				DirNextACL[i] = ((pMyFile->access_cond[i]) & 1)  ? true : false;
				DeleteACL[i]  = ((pMyFile->access_cond[i]) & 2)  ? true : false;
				CreateACL[i]  = ((pMyFile->access_cond[i]) & 32) ? true : false;
			}

			/////////////////////////////////////////////////
			//  Remapping Cyberflex ACL to Cryptoflex ACL  //
			/////////////////////////////////////////////////

            AccessToCryptoACL(DirNextACL, &DirNext);
            AccessToCryptoACL(DeleteACL,  &Delete);
            AccessToCryptoACL(CreateACL,  &Create);
			
			////////////////////////////////////
			//  Assignment of security level  //
			////////////////////////////////////

			bData[8]  = DirNext.Level	  * 16;
			bData[9]  = Delete.Level	  * 16 + Create.Level;			
			bData[13] = DirNext.AUTnumber * 16;	
			bData[14] = Delete.AUTnumber  * 16 + Create.AUTnumber;						

			bool zero = true;
			for (int j = 0; j < 8; j++)
				if (pMyFile->access_cond[j] != 0x00) zero = false;

			if (zero)
			{
				for (int j = 0; j < 7; j++)
					if (pMyFile->CryptoflexACL[j] != 00) zero = false;

				if (!zero)
				{
					// Use cryptoflex ACL)
					memcpy(&bData[7], pMyFile->CryptoflexACL, 4);
					memcpy(&bData[13], &(pMyFile->CryptoflexACL[4]),3);
				}
			}


			SendCardAPDU(0xF0, 0xE0, 0x00, 0x00, 0x11, bData, 0, NULL);
		}

		break;			// end case Directory file

		default:
			throw iop::Exception(iop::ccFileTypeInvalid);
            break;
	}				
	
    Dirty(true);
}

void
CCryptoCard::Directory(BYTE bFile_Nb, FILE_HEADER* pMyFile)
{
	CLockWrap wrap(&m_IOPLock);
	RequireSelect();
	BYTE bDataOut[18];		
	
	for (BYTE index = 0; index < bFile_Nb; index++)
		SendCardAPDU(0xF0, 0xA8, 0x00, 0x00, 0, NULL, 0x10, bDataOut);

    switch(bDataOut[4])
    {
    case 0x38:		// Directory file
        {
            pMyFile->file_id     = (WORD)(bDataOut[2] * 256 + bDataOut[3]);
            pMyFile->file_type   = directory;
            pMyFile->nb_file     = bDataOut[15];
            pMyFile->nb_sub_dir  = bDataOut[14];
            pMyFile->file_status = bDataOut[9];
			memcpy(pMyFile->CryptoflexACL, &bDataOut[6], 3);
			memcpy(&(pMyFile->CryptoflexACL[3]), &bDataOut[11],3);
				
            ///////////////////////////////////////////////////////////////////////
            // Build ACL														 //
            ///////////////////////////////////////////////////////////////////////

            BYTE bACL[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            BYTE bACLNibble;
            BYTE bKeyNibble;

            ///////////////////
            //  Dir Next AC  //
            ///////////////////
            bACLNibble = bDataOut[6]  / 16;
            bKeyNibble = bDataOut[11] / 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 0);
				
            //////////////////////
            //  Delete File AC  //
            //////////////////////
            bACLNibble = bDataOut[7]  / 16;
            bKeyNibble = bDataOut[12] / 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 1);					

            //////////////////////
            //  Create File AC  //
            //////////////////////
            bACLNibble = bDataOut[7]  % 16;
            bKeyNibble = bDataOut[12] % 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 5);

            ////////////////////////////////////////////////
            //  done remapping; assigning to file header  //
            ////////////////////////////////////////////////

            memcpy((void*)(pMyFile->access_cond), (void*)(bACL), 8);
            memset((void*)(pMyFile->applicationID), 0x00, 16);

            break;

        }	// end case Directory				

    case 0x01:		// Binary_File
    case 0x02:		// Fixed_Record_File
    case 0x04:		// Variable_Record_File
    case 0x06:		// Cyclic_File
        {
            pMyFile->file_id	 = (WORD)(bDataOut[2] * 256 + bDataOut[3]);
            pMyFile->file_status = bDataOut[9];
            pMyFile->nb_sub_dir  = bDataOut[14];	
            pMyFile->nb_file	 = bDataOut[15]; 
			memcpy(pMyFile->CryptoflexACL, &bDataOut[6], 3);
			memcpy(&(pMyFile->CryptoflexACL[3]), &bDataOut[11],3);

            ////////////////////////////////////////////////////////////////////////
            //  Cryptoflex includes the file header in the file size -- removing  //
            ////////////////////////////////////////////////////////////////////////
            pMyFile->file_size   = (WORD)(bDataOut[0] * 256 + bDataOut[1] - 16);

            //////////////////////////////////////////
            //  Remove flag for file size rounding  //
            //////////////////////////////////////////
            if (pMyFile->file_size >= 0x3FFF)
                pMyFile->file_size &= 0x3FFF;

            switch(bDataOut[4])
            {
            case 0x01:	pMyFile->file_type = Binary_File;
                break;
            case 0x02:	pMyFile->file_type = Fixed_Record_File;
                break;
            case 0x04:	pMyFile->file_type = Variable_Record_File;
                break;
            case 0x06:	pMyFile->file_type = Cyclic_File;
                break;
            }									
				
            ////////////////////////////////////////////////////////////////////////
            //  Also includes 4 bytes record headers in cyclic files -- removing  //
            ////////////////////////////////////////////////////////////////////////
            if (pMyFile->file_type == Cyclic_File)
                pMyFile->file_size -= pMyFile->nb_file * 4;

            ///////////////////////////////////////////////////////////////////////
            // Build ACL														 //
            ///////////////////////////////////////////////////////////////////////

            BYTE bACL[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            BYTE bACLNibble;
            BYTE bKeyNibble;

            ////////////////////
            //  Read file AC  //
            ////////////////////
            bACLNibble = bDataOut[6]  / 16;
            bKeyNibble = bDataOut[11] / 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 0);
				
            ////////////////////////
            //  Write to file AC  //
            ////////////////////////
            bACLNibble = bDataOut[6]  % 16;
            bKeyNibble = bDataOut[11] % 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 1);
				
            ///////////////////////
            //  Rehabilitate AC  //
            ///////////////////////	
            bACLNibble = bDataOut[8]  / 16;
            bKeyNibble = bDataOut[13] / 16;
				
            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 4);

            /////////////////////
            //  Invalidate AC  //
            /////////////////////
            bACLNibble = bDataOut[8]  % 16;
            bKeyNibble = bDataOut[13] % 16;

            CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 3);

            ////////////////////////
            //  Create Record AC  //
            ////////////////////////
            if (bDataOut[4] != 0x01)  // omit create record file AC for binary file
            {
                bACLNibble = bDataOut[7]  % 16;
                bKeyNibble = bDataOut[12] % 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 2);
            }
				
            ////////////////////////////////////////////////////
            //  done remapping ACL; assigning to file header  //
            ////////////////////////////////////////////////////

            memcpy((void*)(pMyFile->access_cond), (void*)(bACL), 8);
            memset((void*)(pMyFile->applicationID), 0x00, 16);
				
            break;
        }			// end case non-Directory file

    default:
        break;
    }

	/////////////////////////////
	//  reset DirNext pointer  //
	/////////////////////////////
	char   szCurrentFile[80];
	strcpy(szCurrentFile, m_CurrentFile.GetStringPath().c_str());		

	Select(m_CurrentDirectory.GetStringPath().c_str(),  NULL, true);
	Select(szCurrentFile,		NULL); 

}

void
CCryptoCard::Select(const WORD wFileID)
{
	CLockWrap wrap(&m_IOPLock);
	BYTE bDataIn[2];				
	bDataIn[0] = (BYTE)(MSB(wFileID));
	bDataIn[1] = (BYTE)(LSB(wFileID));

	SendCardAPDU(0xC0, 0xA4, 0x00, 0x00, 0x02, bDataIn, 0, NULL);
			
}

void
CCryptoCard::Select(const char* szFileFullPath,
                    FILE_HEADER* pMyFile,
                    const bool fSelectAll)
{
	CLockWrap wrap(&m_IOPLock);
	BYTE bIndex = 0;
	char szFormattedPath[cMaxPathLength];
	BYTE bFileCount = FormatPath(szFormattedPath, szFileFullPath);
	BYTE bPathLength = strlen(szFormattedPath);

	
    auto_ptr<FilePath> apfp(new FilePath(string(szFormattedPath)));

	///////////////////////////////////////////////////////////
	//  Select all files in path regardless of current path. //
	//  Do this on request, or if cache is empty			 //
	///////////////////////////////////////////////////////////
	if (fSelectAll || (m_CurrentFile.IsEmpty()) || (m_CurrentDirectory.IsEmpty()))
	{
		bIndex = 0;			
	}
	////////////////////////////////////////////////////////
	//  if path names match, do nothing					  //
	////////////////////////////////////////////////////////
	else if (m_CurrentFile == *apfp)
	{
        if (pMyFile) // force Select so file info is retrieved
        {
            if (1 < bFileCount)
            {
                if (m_CurrentFile == m_CurrentDirectory)
                    bIndex = bFileCount - 1;      // just reselect dir
                else
                    bIndex = bFileCount - 2;      // select dir & file
                SelectParent();
            }
        }
        else
            bIndex = bFileCount;
	}
	////////////////////////////////////////////////////////////////////
	//  if current directory is in path, only select remaining files  //
	////////////////////////////////////////////////////////////////////
	else if(m_CurrentDirectory.NumComponents() < apfp->NumComponents())
	{			
		if (apfp->GreatestCommonPrefix(m_CurrentDirectory) == m_CurrentDirectory)
			bIndex = m_CurrentDirectory.NumComponents();
		else
			bIndex = 0;
	}		
			
	//////////////////////////////////////////
	//  Select the necessary files in path  //
	//////////////////////////////////////////	
	char sFileToSelect[5] = { 0, 0, 0, 0, 0 };
    bool fFileSelected = false;
    bool fSelectFailed = false;
    try
    {
        while (bIndex < bFileCount)
        {			
            WORD wFileHexID = (*apfp)[bIndex].GetShortID();
            Select(wFileHexID);
            fFileSelected = true;
            bIndex++;
        }
    }

    catch (Exception const &)
    {
        fSelectFailed = true;
        if (fSelectAll)
            throw;
    }
        
    if (fSelectFailed) // assert(!fSelectAll)
    {
        Select(szFormattedPath, pMyFile, true);
        fFileSelected = true;
    }

    BYTE bResponseLength = 0;
    if (fFileSelected)
        bResponseLength = ResponseLengthAvailable();
    
	/////////////////////////////////////////
	//  Get response and fill file header  //
	/////////////////////////////////////////

	switch(bResponseLength)
	{
		case 0x17:		//
		case 0x16:		//
		case 0x15:		//	Directory file
		case 0x14:		//
		case 0x13:		//
		case 0x12:		//
		{				
            //////////////////////////////////////////
            //  Update file and directory pointers  //
            //////////////////////////////////////////

			m_CurrentDirectory = *apfp;
			m_CurrentFile = *apfp;

            if (pMyFile)
            {
                BYTE  bDataOut[0x19];	
			
                GetResponse(0xC0, bResponseLength, bDataOut);
			
                pMyFile->file_id     = (unsigned short)(bDataOut[4] * 256 + bDataOut[5]);
                pMyFile->file_size   = (unsigned short)(bDataOut[2] * 256 + bDataOut[3]);
                pMyFile->file_type   = directory;
                pMyFile->nb_file     = bDataOut[15];
                pMyFile->nb_sub_dir  = bDataOut[14];
                pMyFile->file_status = bDataOut[11];
				memcpy(m_bLastACL, &bDataOut[7],4);
			
                //////////////////////////////////////////////////////////////
                // Build ACL
                //////////////////////////////////////////////////////////////

                BYTE bACL[]     = { 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00 };
                BYTE bKeyNibble = 0xFF;		// flag to ignore AUT keys
                                            // -- useless for
                                            // Select(...)
                BYTE bACLNibble;				

                //////////////////
                // Dir Next AC	//
                //////////////////
                bACLNibble = bDataOut[8] / 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 0);
			
                //////////////////////
                //  Delete File AC  //
                //////////////////////
                bACLNibble = bDataOut[9] / 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 1);

                /////////////////////
                //  CreateFile AC  //
                /////////////////////
                bACLNibble = bDataOut[9] % 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 5);

                ////////////////////////////////////////////////////
                //  done remapping ACL; assigning to file header  //
                ////////////////////////////////////////////////////

                memcpy((void*)(pMyFile->access_cond), (void*)(bACL), 8);
                memset((void*)(pMyFile->applicationID), 0x00, 16);
            }
			
		}	// end case Directory file

		break;
		
		case  0x0F:		//	non-Directory file types
		case  0x0E:		//
		{				
            //////////////////////////////////////////
            //  Update file and directory pointers  //
            //////////////////////////////////////////

			m_CurrentFile = *apfp;
			apfp->ChopTail();
			m_CurrentDirectory = *apfp;

            if (pMyFile)
            {
                BYTE  bDataOut[0x11];				

                GetResponse(0xC0, bResponseLength, bDataOut);
			
                pMyFile->file_size   = (WORD)(bDataOut[2]*256+bDataOut[3]);
                pMyFile->file_id     = (WORD)(bDataOut[4]*256+bDataOut[5]);
                pMyFile->file_status = bDataOut[11];				
				memcpy(m_bLastACL, &bDataOut[7],4);
					
                switch(bDataOut[6])
                {
				case 0x01:	pMyFile->file_type = Binary_File;
                    break;
				case 0x02:	pMyFile->file_type = Fixed_Record_File;
                    break;
				case 0x04:	pMyFile->file_type = Variable_Record_File;
                    break;
				case 0x06:	pMyFile->file_type = Cyclic_File;
                    break;
                }
			
                if (pMyFile->file_type == Cyclic_File ||
                    pMyFile->file_type == Fixed_Record_File)
                {
                    pMyFile->nb_sub_dir = bDataOut[14];				
                    pMyFile->nb_file    = (pMyFile->nb_sub_dir)
                        ? pMyFile->file_size / pMyFile->nb_sub_dir
                        : 0;
                }
                else 
                {
                    ///////////////////////////////////////////////////////////
                    //  number of records inaccessable except by file        //
                    //  size calculation above                               //
                    ///////////////////////////////////////////////////////////
                    pMyFile->nb_file    = 0x00; 
                    pMyFile->nb_sub_dir = 0x00;
                }
			
                //////////////////////////////////////////////////////////////
                // Build ACL                                                //
                //////////////////////////////////////////////////////////////

                BYTE bACL[]     = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                BYTE bKeyNibble = 0xFF;		// flag to ignore AUT keys
                                            // -- useless for
                                            // Select(...)
                BYTE bACLNibble;
			
                ////////////////////
                //  Read file AC  //
                ////////////////////
                bACLNibble = bDataOut[8] / 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 0);

                ////////////////////////
                //  Write to file AC  //
                ////////////////////////
                bACLNibble = bDataOut[8] % 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 1);

                ///////////////////////
                //  Rehabilitate AC  //
                ///////////////////////
                bACLNibble = bDataOut[10] / 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 4);
		
                /////////////////////
                //  Invalidate AC  //
                /////////////////////
                bACLNibble = bDataOut[10] % 16;

                CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 3);
							
                ////////////////////////
                //  Create Record AC  //
                ////////////////////////
                if (bDataOut[6] != 0x01)  // omit create record file
                                          // AC for binary file
                {
                    bACLNibble = bDataOut[9] % 16;
				
                    CryptoToAccessACL(bACL, bACLNibble, bKeyNibble, 2);
                }

                ////////////////////////////////////////////////////
                //  done remapping ACL; assigning to file header  //
                ////////////////////////////////////////////////////
			
                memcpy((void*)(pMyFile->access_cond),   (void*)(bACL), 8);
                memset((void*)(pMyFile->applicationID),  0x00,  16);
			}
            
		}	// end case non-Directory file

		break;

		default:
            break;
	}
}

void
CCryptoCard::SelectParent()
{
	CLockWrap wrap(&m_IOPLock);
	RequireSelect();

	///////////////////////////////////////////////////
	//  If current directory is root, reselect root  //
	///////////////////////////////////////////////////
	if (m_CurrentDirectory.NumComponents() == 1)
	{
		Select(0x3F00);
		m_CurrentFile = m_CurrentDirectory;
	}
	else
	{
		if (m_CurrentDirectory == m_CurrentFile)
		{
			m_CurrentDirectory.ChopTail();
			Select(m_CurrentDirectory.Tail().GetShortID());
			m_CurrentFile = m_CurrentDirectory;
		}
		else
		{
			Select(m_CurrentDirectory.Tail().GetShortID());
			m_CurrentFile = m_CurrentDirectory;
		}
	}
}

void
CCryptoCard::VerifyKey(const BYTE bKeyNumber, const BYTE bKeyLength,
                       const BYTE* bKey)
{
	CLockWrap wrap(&m_IOPLock);

	SendCardAPDU(0xF0, 0x2A, 0x00, bKeyNumber, bKeyLength, bKey, 0, NULL);
}

void
CCryptoCard::VerifyCHV(const BYTE bCHVNumber, const BYTE* bCHV)
{
	CLockWrap wrap(&m_IOPLock);
	
	SendCardAPDU(0xC0, insVerifyChv, 0x00, bCHVNumber,
                 0x08, bCHV, 0, NULL);
}


void
CCryptoCard::VerifyTransportKey(const BYTE *bKey)
{
	CLockWrap wrap(&m_IOPLock);
	VerifyKey(1, 8, bKey);
}

void
CCryptoCard::GetChallenge(const DWORD dwNumberLength, BYTE* bRandomNumber)
{
	CLockWrap wrap(&m_IOPLock);

    const DWORD dwMaxLen = 64;

    DWORD dwRamainingBytes = dwNumberLength;
    BYTE *bpBuf = bRandomNumber;

    while(dwRamainingBytes)
    {
        BYTE bNumGet = (dwRamainingBytes > dwMaxLen) ? dwMaxLen : dwRamainingBytes;

    	SendCardAPDU(0xC0, 0x84, 0x00, 0x00, 0, NULL,
                 bNumGet,  bpBuf);

        bpBuf             += bNumGet;
        dwRamainingBytes  -= bNumGet;           
    }
}

void
CCryptoCard::ExternalAuth(const KeyType kt, const BYTE bKeyNb, 
                          const BYTE bDataLength, const BYTE* bData)
{
	CLockWrap wrap(&m_IOPLock);

    //BYTE bAlgo_ID = AsPrivateAlgId(kt);
    
	SendCardAPDU(0xC0,  0x82, 0, bKeyNb, bDataLength,	
                 bData, 0, NULL);
}

void
CCryptoCard::InternalAuth(const KeyType kt, const BYTE  bKeyNb, 
                          const BYTE bDataLength, const BYTE* bDataIn,
                          BYTE* bDataOut)
{
	CLockWrap wrap(&m_IOPLock);

	if ((bDataLength < 0x40) || (bDataLength > 0x80))
		throw iop::Exception(iop::ccAlgorithmIdNotSupported);

	SendCardAPDU(0xC0, insInternalAuth, 0, bKeyNb,
                 bDataLength, bDataIn, 0, NULL);

    GetResponse(0xC0, ResponseLengthAvailable(), bDataOut);		
}

void
CCryptoCard::WritePublicKey(const CPublicKeyBlob aKey, const BYTE bKeyNum)
{
	CLockWrap wrap(&m_IOPLock);

	WORD wOffset;

	Select(0x1012);
	
	WORD wKeyBlockLen = 7 + 5 * aKey.bModulusLength / 2;

	scu::AutoArrayPtr<BYTE> aabKeyBlob(new BYTE[wKeyBlockLen]);

	aabKeyBlob[0] = HIBYTE(wKeyBlockLen);
	aabKeyBlob[1] = LOBYTE(wKeyBlockLen);
	aabKeyBlob[2] = bKeyNum + 1;    // Cryptoflex key numbers are offset by one on the file...

	memcpy((void*) &aabKeyBlob[3], (void*)&aKey.bModulus, aKey.bModulusLength);
	// Would need to set Montgomery constants here, but since nobody seems
	// to know what they are...

	// Montgomery constants take 3 * modulus_length / 2 bytes
	memcpy((void*) &aabKeyBlob[3 + aKey.bModulusLength + (3 * aKey.bModulusLength / 2)], aKey.bExponent,4);

	wOffset  = bKeyNum * wKeyBlockLen;

	WriteBinary(wOffset, wKeyBlockLen, aabKeyBlob.Get());		
}

void 
CCryptoCard::GetSerial(BYTE* bSerial, size_t &SerialLength)
{
	CLockWrap wrap(&m_IOPLock);

    try {
	
        FILE_HEADER fh;
	    Select("/3f00/0002", &fh);

	    if (SerialLength < fh.file_size)
	    {
		    SerialLength = fh.file_size;
		    return;
	    }

	    ReadBinary(0, fh.file_size, bSerial);
    }
    catch(Exception &rExc)
    {
        if(rExc.Cause()==ccFileNotFound	|| rExc.Cause()==ccFileNotFoundOrNoMoreFilesInDf)
            SerialLength = 0;
        else
            throw;
    }
}

void
CCryptoCard::ReadPublicKey(CPublicKeyBlob *aKey, const BYTE bKeyNum)
{
	CLockWrap wrap(&m_IOPLock);

	BYTE bKeyLength[2];	

	Select(0x1012);
	ReadBinary(0, 2, bKeyLength);

	WORD wKeyBlockLength = bKeyLength[0] * 256 + bKeyLength[1];
	WORD wOffset		 = wKeyBlockLength * bKeyNum;
	scu::AutoArrayPtr<BYTE> aabBuffer(new BYTE[wKeyBlockLength]);

	ReadBinary(wOffset, wKeyBlockLength, aabBuffer.Get());

	aKey->bModulusLength = ((wKeyBlockLength - 7) * 2) / 5;

	memcpy((void*)aKey->bModulus,  (void*)&aabBuffer[3], aKey->bModulusLength);
	memcpy((void*)aKey->bExponent, (void*)&aabBuffer[wKeyBlockLength - 4],  4);
}

void
CCryptoCard::WritePrivateKey(const CPrivateKeyBlob aKey, const BYTE bKeyNum)
{
	CLockWrap wrap(&m_IOPLock);

	Select(0x0012);

    WORD wHalfModulus    = aKey.bPLen;  // Check that the lengths are all equal?
	WORD wKeyBlockLength = wHalfModulus * 5 + 3;
	WORD wOffset         = bKeyNum * wKeyBlockLength;
	scu::SecureArray<BYTE> aabKeyBlob(wKeyBlockLength);

	aabKeyBlob[0] = HIBYTE(wKeyBlockLength);
	aabKeyBlob[1] = LOBYTE(wKeyBlockLength);
	aabKeyBlob[2] = bKeyNum + 1;    // Cryptoflex key numbers are offset by one on the file...

	memcpy(&aabKeyBlob[3                   ],	aKey.bP.data(),      wHalfModulus);
	memcpy(&aabKeyBlob[3 +     wHalfModulus], aKey.bQ.data(),        wHalfModulus);
	memcpy(&aabKeyBlob[3 + 2 * wHalfModulus], aKey.bInvQ.data(),     wHalfModulus);
	memcpy(&aabKeyBlob[3 + 3 * wHalfModulus], aKey.bKsecModP.data(), wHalfModulus);
	memcpy(&aabKeyBlob[3 + 4 * wHalfModulus], aKey.bKsecModQ.data(), wHalfModulus);

	WriteBinary(wOffset, wKeyBlockLength, aabKeyBlob.data());
}

CPublicKeyBlob CCryptoCard::GenerateKeyPair(const BYTE *bpPublExp, const WORD wPublExpLen, 
                                            const BYTE bKeyNum, const KeyType kt)
{

    // This function generates a key-pair, using the public exponent as specified in 
    // in CPublicKeyBlob parameter. The private key is stored in the private
    // key file at position specified by bKeyNum. The public key components are 
    // returned through the CPublicKeyBlob parameter. Prior to call, the correct
    // DF containing the key file must be selected.

    // Implementation:
    // The offset of the key in the private key file is proportional to the key number
    // and it is assumed that all keys in a private key file have the same length. It 
    // assumes that there is a public key file available  with space for at least one 
    // public key. The public key will always be written to the first position in the 
    // public key file.

    BYTE bModulusLength;

    switch(kt)
    {
    case ktRSA512:
        bModulusLength = 0x40;
        break;

    case ktRSA768:
        bModulusLength = 0x60;
        break;

    case ktRSA1024:
        bModulusLength = 0x80;
        break;

    default:
        throw iop::Exception(iop::ccAlgorithmIdNotSupported);

    }

    // Check public exponent size and copy to 4 byte buffer

    if(wPublExpLen < 1 || wPublExpLen > 4)
        throw iop::Exception(iop::ccInvalidParameter);

    BYTE bPublExponent[4];
    memset(bPublExponent,0,4);
    memcpy(bPublExponent,bpPublExp,wPublExpLen);

    // Pre-define public key

    CPublicKeyBlob PublKey;

    PublKey.bModulusLength = bModulusLength;
    memset(PublKey.bModulus,0,bModulusLength);
    memset(PublKey.bExponent,0,4);

    WritePublicKey(PublKey, 0); // Write in first position.

    // Specify the correct key number in this position

    BYTE bKeyNumPlus1 = bKeyNum + 1;    // Cryptoflex key numbers are offset by one on the file...
    Select(0x1012);
    WriteBinary(2, 1, &bKeyNumPlus1);

    // Pre-define private key

    CPrivateKeyBlob PrivKey;
    
    PrivKey.bPLen = bModulusLength/2;
    memset(PrivKey.bP.data(),0,PrivKey.bPLen);

    PrivKey.bQLen = bModulusLength/2;
    memset(PrivKey.bQ.data(),0,PrivKey.bQLen);

    PrivKey.bInvQLen = bModulusLength/2;
    memset(PrivKey.bInvQ.data(),0,PrivKey.bInvQLen);

    PrivKey.bKsecModQLen = bModulusLength/2;
    memset(PrivKey.bKsecModQ.data(),0,PrivKey.bKsecModQLen);

    PrivKey.bKsecModPLen = bModulusLength/2;
    memset(PrivKey.bKsecModP.data(),0,PrivKey.bKsecModPLen);

    WritePrivateKey(PrivKey, bKeyNum); // Write in actual position.

    // Generate the key pair

	SendCardAPDU(0xF0, insKeyGeneration, bKeyNum, bModulusLength,
                                4, bPublExponent, 0, NULL);
    ReadPublicKey(&PublKey,0);

    return PublKey;

}

void
CCryptoCard::ChangeCHV(const BYTE bKey_nb, const BYTE *bOldCHV,
                       const BYTE *bNewCHV)
{
	CLockWrap wrap(&m_IOPLock);

	scu::SecureArray<BYTE> bDataIn(16);				
	
	memcpy((void*)(bDataIn.data()),	 (void*)bOldCHV, 8);
	memcpy((void*)(bDataIn.data() + 8), (void*)bNewCHV, 8);

	SendCardAPDU(0xF0, insChangeChv, 0x00, bKey_nb, 0x10, bDataIn.data(), 0, NULL);

    Dirty(true);
}

void
CCryptoCard::ChangeCHV(const BYTE bKey_nb, const BYTE *bNewCHV)
{

    CLockWrap wrap(&m_IOPLock);

	switch (bKey_nb)
	{
		case 1:   Select("/3f00/0000");	// CHV1 and CHV2 are the only CHV's supported
				  break;
		case 2:   Select("/3f00/0100");
				  break;

		default:  throw iop::Exception(iop::ccInvalidChv);
                  break;
	}

	WriteBinary(3, 8, bNewCHV);

    BYTE bRemaingAttempts = 1;
	WriteBinary(12, 1, &bRemaingAttempts);
		
    Dirty(true);
    
    VerifyCHV(bKey_nb,bNewCHV);

}

void
CCryptoCard::UnblockCHV(const BYTE bKey_nb, const BYTE *bUnblockPIN,
                        const BYTE *bNewPin)
{
	CLockWrap wrap(&m_IOPLock);
	scu::SecureArray<BYTE> bDataIn(16);		
	
	memcpy((void*)(bDataIn.data()),	 (void*)bUnblockPIN, 8);
	memcpy((void*)(bDataIn.data() + 8), (void*)bNewPin,	 8);

	SendCardAPDU(0xF0, insUnblockChv, 0x00, bKey_nb, 0x10, bDataIn.data(), 0, NULL);

    Dirty(true);
}

void
CCryptoCard::ChangeUnblockKey(const BYTE bKey_nb, const BYTE *bNewPIN)
{
	CLockWrap wrap(&m_IOPLock);

	switch (bKey_nb)
	{
		case 1:   Select("/3f00/0000");	// CHV1 and CHV2 are the only CHV's supported
				  break;
		case 2:   Select("/3f00/0100");
				  break;

		default:  throw iop::Exception(iop::ccInvalidChv);
                  break;
	}

	WriteBinary(13, 8, bNewPIN);
		
}

void
CCryptoCard::ChangeTransportKey(const BYTE *bNewKey)
{

	CLockWrap wrap(&m_IOPLock);
	Select("/3f00/0011");
		

	//////////////////////////////////////////
	//  Build byte string to write to card  //
	//////////////////////////////////////////						   
	BYTE bKeyString[10] = 
	{
	   0x08,					// length of key
	   0x00,					// tag to identify key as a DES key
	   0, 0, 0, 0, 0, 0, 0, 0   // 8 bytes for key
	};
    // Copy the template into secure arry for storing the key
    const WORD wKeySize = 10;
	scu::SecureArray<BYTE> newbKeyStr(bKeyString,wKeySize);
    
	//////////////////////////////////////////////////////
	//  insert new key into key string to pass to card  //
	//////////////////////////////////////////////////////
	memcpy((void*)(newbKeyStr.data() + 2), (void*)bNewKey, 8);

	WriteBinary(13, wKeySize, newbKeyStr.data());

    BYTE bRemainingAttempt = 1; // Minumum # of verification attempts remaining before card is blocked
	WriteBinary(24, 1, &bRemainingAttempt);

    // Make a (hopefully) successfull verification to re-set attempt counter

    VerifyTransportKey(bNewKey);
}

void
CCryptoCard::ChangeACL(const BYTE *bACL)
{
    throw iop::Exception(iop::ccUnsupportedCommand);
}

void
CCryptoCard::AccessToCryptoACL(bool* fAccessACL, CryptoACL* pCryptoACL)
{
	if (fAccessACL[0] == true)

		pCryptoACL->Level = 0;

	else 
	{
		pCryptoACL->Level = 0x0F;
		for(BYTE i = 1; i < 3; i++)
		{
			if (fAccessACL[i] == true)
			{
				pCryptoACL->CHVcounter++;
				pCryptoACL->CHVnumber = i;
			}
			
			if (pCryptoACL->CHVcounter > 1 )
			{
                // More than one CHV for a single action 
                // is not supported by Cryptoflex						
                throw iop::Exception(iop::ccAclNotSupported);
			}
		}

		for(i = 3; i < 8; i++)
		{
			if (fAccessACL[i] == true)
			{
				pCryptoACL->AUTcounter++;
				pCryptoACL->AUTnumber = i - 3;		// AUT0 starts with an index of 3
			}
		
			if (pCryptoACL->AUTcounter > 1)
			{
                // More than one AUT for a single action 
                // is not supported by Cryptoflex						
                throw iop::Exception(iop::ccAclNotSupported);
			}
			
		}
	}
	
	if (pCryptoACL->CHVcounter == 1 && pCryptoACL->AUTcounter == 1)
	{
		if(pCryptoACL->CHVnumber == 1)
			pCryptoACL->Level = 8;
		else
			pCryptoACL->Level = 9;
	}

	if (pCryptoACL->CHVcounter == 1 && pCryptoACL->AUTcounter == 0)
	{
		if(pCryptoACL->CHVnumber == 1)
			pCryptoACL->Level = 1;
		else
			pCryptoACL->Level = 2;
	}

	if (pCryptoACL->CHVcounter == 0 && pCryptoACL->AUTcounter == 1)
		pCryptoACL->Level = 4;		
	
}

void CCryptoCard::CryptoToAccessACL(BYTE* bAccessACL,		const BYTE bACLNibble, 
									const BYTE bKeyNibble,	const BYTE bShift)
{
	switch (bACLNibble)
	{
		case 0x00:	bAccessACL[0] = (1 << bShift) | bAccessACL[0];
					break;
		case 0x01:
		case 0x06:
		case 0x08:	bAccessACL[1] = (1 << bShift) | bAccessACL[1];
					break;
		case 0x02:
		case 0x07:
		case 0x09:	bAccessACL[2] = (1 << bShift) | bAccessACL[2];
					break;
		default:	//  bAccessACL already initialized to 0x00
					break;
	}

	if (bACLNibble == 0x04 || bACLNibble == 0x08 || bACLNibble == 0x09)
	{
		////////////////////////////////////////////////////////////////////////////
		//  Cyberflex only supports 5 AUT keys, and AUT0 starts at bAccessACL[3]  //
		////////////////////////////////////////////////////////////////////////////
		if (bKeyNibble < 0x05)									
			bAccessACL[3 + bKeyNibble] = (1 << bShift) | bAccessACL[3 + bKeyNibble];	
	}	
}

void
CCryptoCard::DefaultDispatchError(ClassByte cb,
                                  Instruction ins,
                                  StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;
    
    switch (sw)
	{
	case 0x6281:
		cc = ccDataPossiblyCorrupted;
        break;
        
	case 0x6300:
		cc = ccAuthenticationFailed;
        break;
        
	case 0x6982:
		cc = ccAccessConditionsNotMet;
        break;
        
    case 0x6981:
        cc = ccNoEfExistsOrNoChvKeyDefined;
        break;
            
    case 0x6985:
        cc = ccNoGetChallengeBefore;
        break;
        
    case 0x6986:
        cc = ccNoEfSelected;
        break;
        
	case 0x6A83:
        cc = ccOutOfRangeOrRecordNotFound;
        break;

    case 0x6A84:
        cc = ccInsufficientSpace;
        break;
        
	case 0x6A82:
		cc = ccFileNotFoundOrNoMoreFilesInDf;
        break;

    default:
        fDoThrow = false;
        break;
	}

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);

    CSmartCard::DefaultDispatchError(cb, ins, sw);
}

void
CCryptoCard::DispatchError(ClassByte cb,
                           Instruction ins,
                           StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;

    switch (ins)
    {
    case insChangeChv:
        // fall-through intentional
    case insUnblockChv:
        switch (sw)
        {
        case 0x6300:
            cc = ccChvVerificationFailedMoreAttempts;
            break;
            
        case 0x6581:
            cc = ccUpdateImpossible;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insCreateFile:
        switch (sw)
        {
        case 0x6A80:
            cc = ccFileIdExistsOrTypeInconsistentOrRecordTooLong;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insGetResponse:
        switch (sw)
        {
        case 0x6500:
            cc = ccTooMuchDataForProMode;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insReadBinary:
        switch (sw)
        {
        case 0x6B00:
            cc = ccCannotReadOutsideFileBoundaries;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;

    case insVerifyChv:
        switch (sw)
        {
        case 0x6300:
            cc = ccChvVerificationFailedMoreAttempts;
            break;

        default:
            fDoThrow = false;
            break;
        }
        break;
        
    default:
        fDoThrow = false;
        break;
    }

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);

    DefaultDispatchError(cb, ins, sw);
}

void
CCryptoCard::DoReadBlock(WORD wOffset,
                         BYTE *pbBuffer,
                         BYTE bLength)
{
    SendCardAPDU(0xC0, insReadBinary, HIBYTE(wOffset),
                 LOBYTE(wOffset), 0, 0,  bLength, pbBuffer);
			
}
        
void
CCryptoCard::DoWriteBlock(WORD wOffset,
                          BYTE const *pbBuffer,
                          BYTE cLength)
{
    SendCardAPDU(0xC0, insUpdateBinary, HIBYTE(wOffset),
                 LOBYTE(wOffset), cLength, pbBuffer,  0, 0);
}
    
bool
CCryptoCard::SupportLogout()
{
    bool fSuccess = true;
    try
    {
    	CLockWrap wrap(&m_IOPLock);
    	SendCardAPDU(0xF0, 0x22, 0x07, 0, 0, NULL, 0, NULL);
    }
    catch(...)
    {
        fSuccess = false;
    }

    return fSuccess;
}


void CCryptoCard::GetACL(BYTE *bACL)
{
	CLockWrap wrap(&m_IOPLock);

	memcpy(bACL,m_bLastACL,4);

	BYTE bTemp[5];

	SendCardAPDU(0xF0, 0xC4, 0x00, 0x00, 0x00, NULL, 0x03, bTemp);

	memcpy(&bACL[4], bTemp, 3);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\exception.cpp ===
// Exception.cpp -- IOP Exception class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <scuExcHelp.h>

#include "iopExc.h"


using namespace iop;
    
/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    
    scu::CauseCodeDescriptionTable<iop::Exception::CauseCode> ccdt[] = 
    {
        {
            ccAclNotSupported,
            TEXT("ACL is not supported.")
        },
        {
            ccAclNotTranslatable,
            TEXT("ACL is not translatable.")
        },
        {
            ccAlgorithmIdNotSupported,
            TEXT("The algorithm id is not supported.")
        },
        {
            ccBadFileCategory,
            TEXT("An unsupported file category was returned from the "
                 "card.")
        },
        {
            ccBadFilePath,
            TEXT("An invalid file path was specified.")
        },
        {
            ccBadInstanceFile,
            TEXT("The file was created without an AID for file "
                 "control.")
        },
        {
            ccBadLockReferenceCount,
            TEXT("Lock count invalid.")
        },
        {
            ccCannotInterpretGetResponse,
            TEXT("The response returned from the card was "
                 "uninterpretable.")
        },
        {
            ccCyclicRecordSizeTooLarge,
            TEXT("The record size for the cyclic file is too large.")
        },
        {
            ccDirectoryNotEmpty,
            TEXT("The directory is not empty.")
        },
        {
            ccFail,
            TEXT("An unknown error occured.")
        },
        {
            ccFileIdNotHex,
            TEXT("The file ID specified is not in hexadecimal form.")
        },
        {
            ccFileIdTooLarge,
            TEXT("The file ID specified is too large.")
        },
        {
            ccFilePathTooLong,
            TEXT("The file path is too long.")
        },
        {
            ccFileTypeUnknown,
            TEXT("The file type specified is unknown.")
        },
        {
            ccFileTypeInvalid,
            TEXT("The file type specifies is invalid.")
        },
        {
            ccInvalidChecksum,
            TEXT("Invalid checksum.")
        },
        {
            ccInvalidChv,
            TEXT("Invalid CHV specified.  CHV1 and CHV2 are the only "
                 "CHVs supported.")
        },
        {
            ccInvalidParameter,
            TEXT("Invalid parameter.")
        },
        {
            ccLockCorrupted,
            TEXT("Lock corrupted.")
        },
        {
            ccMutexHandleChanged,
            TEXT("Original mutex handle lost.")
        },
        {
            ccNoFileSelected,
            TEXT("A file must be selected before performing this "
                 "operation.")
        },
        {
            ccNotImplemented,
            TEXT("The function is not implemented."),
        },
        {
            ccResourceManagerDisabled,
            TEXT("The Microsoft Resource Manager is not running.")
        },
        {
            ccSelectedFileNotDirectory,
            TEXT("Currently selected file is not a directory.")
        },
        {
            ccSynchronizationObjectNameTooLong,
            TEXT("The synchronization object name is too long.")
        },
        {
            ccUnknownCard,
            TEXT("The card is not recognized.")
        },
        {
            ccUnsupportedCommand,
            TEXT("Routine is not supported.")
        },
		{
			ccNoResponseAvailable,
			TEXT("No response is available from the card.")
		},
		{
			ccBadATR,
			TEXT("The ATR is malformed.")
		}

    };
} // namespace

char const *
iop::Description(Exception const &rExc)
{
    return scu::FindDescription(rExc.Cause(), ccdt,
                                sizeof ccdt / sizeof *ccdt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\dllsymdefn.h ===
// DllSymDefn.h -- Dynamic Link Library SYMbol DEFinitioN compilation directives

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// NOTE: This header is "private" to the IOP.  It should be included
// only by the IOP modules and its header files.  Only the IOP should
// use the declarations made in this file.

#if !defined(IOP_DLLSYMDEFN_H)
#define IOP_DLLSYMDEFN_H

// When compling the IOP, IOPDLL_EXPORTS should be defined prior to
// including this file for the IOP interface and data to be defined properly
// for use by client applications.
#ifdef IOPDLL_EXPORTS
#define IOPDLL_API __declspec(dllexport)
#define IOPDLL_CONST __declspec(dllexport)
#define IOPDLL_EXPIMP_TEMPLATE
#else
#define IOPDLL_API __declspec(dllimport)
#define IOPDLL_CONST
#define IOPDLL_EXPIMP_TEMPLATE extern
#endif

#endif // IOP_DLLSYMDEFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\iop.cpp ===
// iop.cpp -- Definition of CIOP

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <tchar.h>
#include <string>

#include <scuOsExc.h>
#include <scuOsVersion.h>
#include <scuArrayP.h>
#include "iop.h"
#include <aclapi.h>

#include "LockWrap.h"

using namespace std;

namespace
{
    char g_szSLBRegistryPath[] = "SOFTWARE\\Schlumberger";
    char g_szTerminalsName[]   = "Smart Cards and Terminals";
    char g_szCardName[]        = "Smart Cards";
    char g_szCrypto4KName[]    = "Cryptoflex 4K";
    char g_szOldCrypto8KName[] = "Cryptoflex 8K (no RSA key generation)";
    char g_szNewCrypto8KName[] = "Cryptoflex 8K (with RSA key generation)";
    char g_szCrypto8KV2Name[]  = "Cryptoflex 8K (V2)";
    char g_szAccessName[]      = "Cyberflex Access 16K"; 
    char g_sze_gateName[]      = "Schlumberger Cryptoflex e-gate";
    char g_szCrypto16KName[]   = "Cryptoflex 16K";
    char g_szAccessCampus[]    = "Schlumberger Cyberflex Access Campus";
    char g_szCryptoActivCard[] = "Schlumberger Cryptoflex ActivCard";

    string
    CardPath()
    {
        static string sPath = string(g_szSLBRegistryPath) +
            string("\\") + string(g_szTerminalsName) + string("\\") +
            string(g_szCardName);

        return sPath;
    }

#if defined(SLBIOP_WAIT_FOR_RM_STARTUP)

    HANDLE GetSCResourceManagerStartedEvent(void)
    {
        typedef HANDLE (*LPCALAISACCESSEVENT)(void);

        HANDLE hReturn = NULL;

        try
        {
            HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
            if (NULL != hWinScard)
            {
                LPCALAISACCESSEVENT pfCalais =
                    (LPCALAISACCESSEVENT)GetProcAddress(hWinScard,
                                                        "SCardAccessStartedEvent");
                if (NULL != pfCalais)
                {
                    hReturn = (*pfCalais)();
                }
            }
        }
        catch (...)
        {
            hReturn = NULL;
        }

        return hReturn;

    }

#endif // defined(SLBIOP_WAIT_FOR_RM_STARTUP)

}

namespace iop
{


CIOP::CIOP()
    : m_hContext(NULL)
{
    // Ensure that resorce manager is running, then Establish context

    if (!CIOP::WaitForSCManager())
        throw Exception(ccResourceManagerDisabled);
    
    HRESULT hResult = SCardEstablishContext(SCARD_SCOPE_SYSTEM, NULL, NULL, &m_hContext);
    if (SCARD_S_SUCCESS != hResult)
        throw scu::OsException(hResult);
}

CIOP::~CIOP()
{
    SCardReleaseContext(m_hContext);
}

CSmartCard *
CIOP::Connect(const char* szReaderName,
              bool fExclusiveMode)
{
    HRESULT hResult = NOERROR;
    DWORD   dwShare = (fExclusiveMode ? SCARD_SHARE_EXCLUSIVE : SCARD_SHARE_SHARED);
    DWORD   dwProtocol;
    SCARDHANDLE hCard;

    // Grab our Mutex.  This is a hack around an RM bug.

    CIOPLock TempLock(szReaderName);  // This is ok as long as one do not try to do SCard locking
    CIOPMutex tempMutex(&TempLock);

    // Connect to the reader

    hResult = SCardConnect(m_hContext, szReaderName, dwShare,
                           SCARD_PROTOCOL_T0, &hCard, &dwProtocol);

    if (hResult != SCARD_S_SUCCESS)
        throw scu::OsException(hResult);

    // Get the ATR and determine card type

    DWORD dwBufferLen = 0;
    DWORD dwState;
    BYTE  bATR[CSmartCard::cMaxAtrLength];
    DWORD dwATRLen = sizeof bATR / sizeof *bATR;

    hResult = SCardStatus(hCard,NULL, &dwBufferLen, &dwState,
                          &dwProtocol, bATR, &dwATRLen);

    if (hResult != SCARD_S_SUCCESS)
        throw scu::OsException(hResult);

    // Create a SmartCard of the right type.
    CSmartCard *psc = CreateCard(bATR, dwATRLen, hCard, szReaderName, dwShare);

    return psc;
}

// This function creates a smart card of the appropriate type

CSmartCard * CIOP::CreateCard(const BYTE* bATR,
                              const DWORD dwLength,
                              const SCARDHANDLE hCard,
                              const char* szReaderName,
                              const DWORD dwShareMode)
{
    ////////////////////////////////////
    //  Open path to registered keys  //
    ////////////////////////////////////

    HKEY hkCardKey;
    HKEY hkTestKey;

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, CardPath().c_str(), NULL,
                 KEY_READ, &hkCardKey);

    //////////////////////////////////////////////
    //  Enumerate subkeys to find an ATR match  //
    //////////////////////////////////////////////

    FILETIME fileTime;
    char  szATR[]      = "ATR";
    char  szMask[]     = "ATR Mask";
    char  szCardType[] = "Card Type";
    char  sBuffer[MAX_PATH + 1];
    BYTE  bATRtest[CSmartCard::cMaxAtrLength];
    BYTE  bMask[CSmartCard::cMaxAtrLength];

    BYTE  type;
    char szCardName[MAX_PATH + 1];
    DWORD dwBufferSize = sizeof(sBuffer);
    DWORD dwATRSize    = sizeof bATRtest / sizeof *bATRtest;
    DWORD dwMaskSize   = sizeof bMask / sizeof *bMask;
    DWORD dwTypeSize   = 1;
    DWORD index        = 0;
    
    
    LONG iRetVal = RegEnumKeyEx(hkCardKey, index, sBuffer,
                                &dwBufferSize, NULL, NULL, NULL,
                                &fileTime);

    while (iRetVal == ERROR_SUCCESS)
    {
        strcpy(szCardName, sBuffer);

        RegOpenKeyEx(hkCardKey, sBuffer, NULL, KEY_READ, &hkTestKey);
        RegQueryValueEx(hkTestKey, szATR, NULL, NULL, bATRtest, &dwATRSize);
        RegQueryValueEx(hkTestKey, szMask, NULL, NULL, bMask, &dwMaskSize);
        RegQueryValueEx(hkTestKey, szCardType, NULL, NULL, &type, &dwTypeSize);

        if (dwATRSize == dwLength)
        {
            scu::AutoArrayPtr<BYTE> aabMaskedATR(new BYTE[dwATRSize]);
            for (DWORD count = 0; count < dwATRSize; count++)
                aabMaskedATR[count] = bATR[count] & bMask[count];

            if (!memcmp(aabMaskedATR.Get(), bATRtest, dwATRSize))
                break;
        }

        index++;
        dwBufferSize = sizeof(sBuffer);
        dwATRSize    = sizeof bATRtest / sizeof *bATRtest;
        dwMaskSize   = sizeof bMask / sizeof *bMask;
        RegCloseKey(hkTestKey); 
        iRetVal = RegEnumKeyEx(hkCardKey, index, sBuffer, &dwBufferSize, NULL, NULL, NULL, &fileTime);
    }
    
    //  if loop was broken, iRetVal is still ERROR_SUCCESS, and type holds correct card to use
    CSmartCard *retVal = NULL;

    if (iRetVal == ERROR_SUCCESS)
    {
        switch (type)
        {
            case CRYPTO_CARD:  retVal = new CCryptoCard(hCard,
                                                        szReaderName,
                                                        m_hContext,
                                                        dwShareMode);
                               break;
            case ACCESS_CARD:  retVal = new CAccessCard(hCard,
                                                        szReaderName,
                                                        m_hContext,
                                                        dwShareMode);
                               break;
            default:           throw Exception(ccUnknownCard);
                               break;
        }
    }
    //  loop wasn't broken, i.e., ATR not found.  Try to make an Access Card.
    else
        retVal = new CAccessCard(hCard, szReaderName, m_hContext,
                                 dwShareMode);

    retVal->setCardName(szCardName);
    return retVal;
}


void
CIOP::ListReaders(char* szReadersList, int &iSizeOfList)
{
    DWORD  dwSize = static_cast<DWORD>(iSizeOfList);
    LONG   lRet;
    lRet = SCardListReaders(m_hContext, NULL, szReadersList, &dwSize);
    iSizeOfList = static_cast<int>(dwSize);
    if (SCARD_S_SUCCESS != lRet)
        throw scu::OsException(lRet);
}

void
CIOP::ListKnownCards(char* szCardList, int& iSizeOfList)
{
    ////////////////////////////////////
    //  Open path to registered keys  //
    ////////////////////////////////////

    LONG rv;
    HKEY hkCardKey;

    rv = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CardPath().c_str(), NULL,
                      KEY_READ, &hkCardKey);
    if(ERROR_SUCCESS != rv)
        throw scu::OsException(rv);

    ///////////////////////////////////////////
    //  Enumerate subkeys to get card names  //
    ///////////////////////////////////////////

    FILETIME fileTime;  
    char  sBuffer[1024];
    DWORD dwBufferSize = sizeof sBuffer / sizeof *sBuffer;
    int   iTotalSize   = 0;
    int   index        = 0;

    memset(sBuffer, 0, dwBufferSize);

    scu::AutoArrayPtr<char> aaszCardListBuffer(new char[iSizeOfList]);
    memset(aaszCardListBuffer.Get(), 0, iSizeOfList);   
    
    rv = RegEnumKeyEx(hkCardKey, index++, sBuffer, &dwBufferSize,
                      NULL, NULL, NULL, &fileTime);
    while (rv == ERROR_SUCCESS)
    {       
        if (iTotalSize + dwBufferSize <= iSizeOfList - 2) // spare two chars for trailing nulls
        {
            strcpy((aaszCardListBuffer.Get() + iTotalSize), sBuffer);
            iTotalSize += dwBufferSize;

            aaszCardListBuffer[iTotalSize++] = 0;
        }
        else
        {
            iTotalSize += dwBufferSize + 1;
        }

        dwBufferSize = sizeof sBuffer / sizeof *sBuffer;
        memset(sBuffer, 0, dwBufferSize);

        rv = RegEnumKeyEx(hkCardKey, index++, sBuffer, &dwBufferSize,
                          NULL, NULL, NULL, &fileTime);
    }

    bool fRetVal = (iTotalSize <= iSizeOfList - 1);  // spare byte for final null terminator
    if  (fRetVal)
    {
        aaszCardListBuffer[iTotalSize++] = 0;
        
        memcpy(szCardList, aaszCardListBuffer.Get(), iTotalSize);
    }
    else
        iTotalSize++;                               // spare byte for final null terminator

    iSizeOfList = iTotalSize;

    rv = RegCloseKey(hkCardKey);
    if (ERROR_SUCCESS != rv)
        throw scu::OsException(rv);
}

void
CIOP::RegisterCard(const char* szCardName,
                   const BYTE* bATR,
                   BYTE bATRLength,
                   const BYTE* bATRMask,
                   BYTE bATRMaskLength,
                   const BYTE* bProperties,
                   cardType type)
{
    HKEY  hkCardKey;
    DWORD dwCreateFlag;
    BYTE  bCardType      = (BYTE)type;
    char  szATR[]        = "ATR";
    char  szATRMask[]    = "ATR Mask";
    char  szCardType[]   = "Card Type";
    char  szProperties[] = "Properties";

    string sCardRegPath(CardPath());
    sCardRegPath.append("\\");
    sCardRegPath.append(szCardName);

    LONG rv = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             sCardRegPath.c_str(), NULL, NULL, NULL,
                             KEY_ALL_ACCESS, NULL, &hkCardKey, &dwCreateFlag);
    
    if(ERROR_SUCCESS!=rv) 
        throw scu::OsException(rv);

    if (dwCreateFlag == REG_CREATED_NEW_KEY)
    {
        rv = RegSetValueEx(hkCardKey, szATR, NULL, REG_BINARY, bATR,
                           bATRLength);
        if (ERROR_SUCCESS==rv)
        {
            rv = RegSetValueEx(hkCardKey, szATRMask,    NULL,
                               REG_BINARY, bATRMask,
                               bATRMaskLength);
            if (ERROR_SUCCESS==rv)
            {
                rv = RegSetValueEx(hkCardKey, szCardType,   NULL,
                                   REG_BINARY, &bCardType,  1);
                if (ERROR_SUCCESS==rv)
                    rv = RegSetValueEx(hkCardKey, szProperties, NULL,
                                       REG_BINARY, bProperties, 512);
            }
        }
    }

    LONG rv2 = RegCloseKey(hkCardKey);
    if (ERROR_SUCCESS!=rv) // an error occured earlier
        throw scu::OsException(rv);

    if (ERROR_SUCCESS != rv2)
        throw scu::OsException(rv2);

    
//  return (dwCreateFlag == REG_CREATED_NEW_KEY);
}

void
CIOP::RegisterDefaultCards()
{
    BYTE bMask[]       = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    BYTE bAccessMask[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00 };
    BYTE bOldCrypto8KMask[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00 };
    BYTE bCMask[]      = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 };
    BYTE bMaskLength   = 9;
    BYTE bATRLength    = 9;

    BYTE bProperties[512];
    memset(bProperties, 0, sizeof(bProperties));

    // Register Cryptoflex 16K
    BYTE b16KCryptoATR[]      = { 0x3B, 0x95, 0x15, 0x40, 0xFF, 0x63,
                                  0x01, 0x01, 0x00, 0x00 };
    BYTE b16KCryptoMask[]     = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                  0xFF, 0xFF, 0x00, 0x00 };
    
    RegisterCard(g_szCrypto16KName, b16KCryptoATR,
                 sizeof b16KCryptoATR / sizeof *b16KCryptoATR, b16KCryptoMask,
                 sizeof b16KCryptoMask / sizeof *b16KCryptoMask,
                 bProperties, CRYPTO_CARD);

    // Register e-gate
    BYTE be_gateATR[]      = { 0x3B, 0x95, 0x00, 0x40, 0xFF, 0x62,
                               0x01, 0x01, 0x00, 0x00 };
    BYTE be_gateMask[]     = { 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
                               0xFF, 0xFF, 0x00, 0x00 };
    
    RegisterCard(g_sze_gateName, be_gateATR,
                 sizeof be_gateATR / sizeof *be_gateATR, be_gateMask,
                 sizeof be_gateMask / sizeof *be_gateMask,
                 bProperties, CRYPTO_CARD);

    // Register Cyberflex Access card
    BYTE bAccessATR[]      = { 0x3B, 0x16, 0x94, 0x81, 0x10, 0x06, 0x01, 0x00, 0x00 };

    RegisterCard(g_szAccessName, bAccessATR,  bATRLength, bAccessMask,
                 bMaskLength,  bProperties, ACCESS_CARD);

    // Register old Cryptoflex 8K card
    BYTE bOldCryptoATR[]   = { 0x3B, 0x85, 0x40, 0x20, 0x68, 0x01, 0x01, 0x00, 0x00 };  

    RegisterCard(g_szOldCrypto8KName, bOldCryptoATR, bATRLength, bOldCrypto8KMask,
                 bMaskLength,     bProperties,   CRYPTO_CARD);

    // Register new Cryptoflex 8K card
    BYTE bNewCryptoATR[]   = { 0x3B, 0x85, 0x40, 0x20, 0x68, 0x01, 0x01, 0x05, 0x01 };      
    
    RegisterCard(g_szNewCrypto8KName, bNewCryptoATR, bATRLength, bMask, 
                 bMaskLength,     bProperties,   CRYPTO_CARD);

    // Register another new Cryptoflex 8K card
    BYTE bCrypto8KV2ATR[]   = { 0x3B, 0x95, 0x15, 0x40, 0x00, 0x68, 0x01, 0x02, 0x00, 0x00 };
    BYTE bCrypto8KV2Mask[]  = { 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00 };

    RegisterCard(g_szCrypto8KV2Name, bCrypto8KV2ATR, sizeof(bCrypto8KV2ATR), bCrypto8KV2Mask, 
                 sizeof(bCrypto8KV2Mask),     bProperties,   CRYPTO_CARD);

    // Register Cryptoflex 4K card
    BYTE b4KCryptoATR[]    = { 0x3B, 0xE2, 0x00, 0x00, 0x40, 0x20, 0x49, 0x00 };
    bATRLength             = 8;
    bMaskLength            = 8;

    RegisterCard(g_szCrypto4KName,  b4KCryptoATR, bATRLength, bCMask, 
                 bMaskLength,     bProperties,  CRYPTO_CARD);

    // Register Cyberflex Access Campus
    BYTE be_AccessCampusATR[]      = { 0x3B, 0x23, 0x00, 0x35, 0x13, 0x80 };
    BYTE be_AccessCampusMask[]     = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    
    RegisterCard(g_szAccessCampus, be_AccessCampusATR,
                 sizeof be_AccessCampusATR / sizeof *be_AccessCampusATR,
                 be_AccessCampusMask,
                 sizeof be_AccessCampusMask / sizeof *be_AccessCampusMask,
                 bProperties, ACCESS_CARD);

    // Register Cryptoflex ActivCard
    BYTE bCryptoActivCardATR[]   = { 0x3B, 0x05, 0x68, 0x01, 0x01,
                                     0x02, 0x05 };
    BYTE bCryptoActivCardMask[]  = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                     0xFF, 0xFF };

    RegisterCard(g_szCryptoActivCard, bCryptoActivCardATR,
                 sizeof(bCryptoActivCardATR), bCryptoActivCardMask,
                 sizeof(bCryptoActivCardMask), bProperties, CRYPTO_CARD);

}

#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)
void
CIOP::InitIOPSecurityAttrs(CSecurityAttributes *psa)
{
    
    DWORD dwRes;
    PSID pEveryoneSID = NULL, pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea;
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    bool fErrorFound = false;

    // Create a well-known SID for the Everyone group.
    if(!AllocateAndInitializeSid(&SIDAuthWorld, 1,
                                 SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0, &pEveryoneSID)) 
        throw scu::OsException(GetLastError());

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;
    ea.grfAccessMode = SET_ACCESS;
    ea.grfInheritance= NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

#if 0
    // Create a SID for the BUILTIN\Administrators group.
    if (!AllocateAndInitializeSid(&SIDAuthNT, 2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0,
                                  0, 0, &pAdminSID))
        throw scu::OsException(GetLastError());
    
    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the Administrators group full access to the key.
    ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;
    ea.grfAccessMode = SET_ACCESS;
    ea.grfInheritance= NO_INHERITANCE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName  = (LPTSTR) pAdminSID;
#endif // 0
    // Create a new ACL that contains the new ACEs.
    dwRes = SetEntriesInAcl(1, &ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        fErrorFound = true;
    }
    else
    {
        // Initialize a security descriptor.   
        pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
        if (pSD == NULL)
        {
            fErrorFound = true;
        }
        else if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            fErrorFound = true;
        }
        // Add the ACL to the security descriptor.
        else if (!SetSecurityDescriptorDacl(pSD, 
                                           TRUE,     // fDaclPresent flag           
                                           pACL, 
                                           FALSE))   // not a default DACL 
        {
            fErrorFound = true;
        }
        else
        {
            if (!IsValidSecurityDescriptor(pSD))
            {
                fErrorFound = true;
            }
            else
            {
                // Initialize a security attributes structure.
                psa->sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                psa->sa.lpSecurityDescriptor = pSD;
                psa->sa.bInheritHandle = FALSE;
                psa->pEveryoneSID = pEveryoneSID;
                psa->pACL = pACL;
            }
        }
    }

    DWORD dwLastError = GetLastError();

    if (true == fErrorFound)
    {
        if (NULL != pACL)
        {
            LocalFree(pACL);
            pACL = NULL;
        }
        if (NULL != pSD)
        {
            LocalFree(pSD);
            pSD = NULL;
        }
        if (NULL != pEveryoneSID)
        {
            FreeSid(pEveryoneSID);
            pEveryoneSID = NULL;
        }
        throw scu::OsException(dwLastError);
    }
#if 0
    // Create a new ACL that contains the new ACEs.
    dwRes = SetEntriesInAcl(1, &ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
        throw scu::OsException(GetLastError());

    // Initialize a security descriptor.   
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL)
        throw scu::OsException(GetLastError());

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        throw scu::OsException(GetLastError());

    // Add the ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl(pSD, 
                                   TRUE,     // fDaclPresent flag           
                                   pACL, 
                                   FALSE))   // not a default DACL 
        throw scu::OsException(GetLastError());

    // Initialize a security attributes structure.
    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = pSD;
    psa->bInheritHandle = FALSE;

    if (!IsValidSecurityDescriptor(pSD))
        throw scu::OsException(GetLastError());
#endif
}

#endif // defined(SLBIOP_USE_SECURITY_ATTRIBUTES)


bool CIOP::WaitForSCManager() 
{
#if defined(SLBIOP_WAIT_FOR_RM_STARTUP)
    // Wait for the SCManager to start, time out at dwTimeout seconds.

    HANDLE hStarted = GetSCResourceManagerStartedEvent();
    if (hStarted)
    {
        if (WaitForSingleObject(hStarted, 60 * 1000) == WAIT_OBJECT_0)
            return true;
    }

    return false;

#else // defined(SLBIOP_WAIT_FOR_RM_STARTUP)

    return true;

#endif // defined(SLBIOP_WAIT_FOR_RM_STARTUP)

}




} // namespace iop


STDAPI DllGetVersion(DLLVERSIONINFO *dvi)
{
    dvi->dwBuildNumber = 0;
    dvi->dwMajorVersion = 0;
    dvi->dwMinorVersion = 9;

    return 0;
}

STDAPI DllRegisterServer()
{
    // Ensure default cards are registered to the system
    HRESULT hResult = ERROR_SUCCESS;
    try
    {
        iop::CIOP::RegisterDefaultCards();
    }

    catch (scu::OsException const &rExc)
    {
        hResult = rExc.Cause();
    }

    return hResult;
}

STDAPI DllUnregisterServer()
{
    HRESULT hResult = NOERROR;

    LONG rv;
    HKEY hkSLBKey;
    HKEY hkTerminalsKey;
    HKEY hkCardsKey;

    
    bool bSLBKey = false, bTerminalsKey = false, bCardsKey = false;

    try
    {
        rv = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szSLBRegistryPath, NULL, KEY_ALL_ACCESS, &hkSLBKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bSLBKey = true;
     
        RegOpenKeyEx(hkSLBKey,           g_szTerminalsName,  NULL, KEY_ALL_ACCESS, &hkTerminalsKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bTerminalsKey = true;

        RegOpenKeyEx(hkTerminalsKey,     g_szCardName,      NULL, KEY_ALL_ACCESS, &hkCardsKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bCardsKey = true;

        rv = RegDeleteKey(hkCardsKey, g_szCrypto4KName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szOldCrypto8KName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szNewCrypto8KName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szCrypto8KV2Name);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;
        
        rv = RegDeleteKey(hkCardsKey, g_szAccessName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_sze_gateName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szCrypto16KName);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szAccessCampus);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegDeleteKey(hkCardsKey, g_szCryptoActivCard);
        if(rv!=ERROR_SUCCESS) hResult = E_UNEXPECTED;

        rv = RegCloseKey (hkCardsKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bCardsKey = false;

        rv = RegDeleteKey(hkTerminalsKey, g_szCardName);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bCardsKey = false;

        rv = RegCloseKey (hkTerminalsKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bTerminalsKey = false;

        rv = RegDeleteKey(hkSLBKey,      g_szTerminalsName);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bCardsKey = false;

        rv = RegCloseKey(hkSLBKey);
        if(rv!=ERROR_SUCCESS) throw scu::OsException(rv);
        bSLBKey = false;
    }
    catch(...)
    {
        hResult = E_UNEXPECTED;
    }

    if(bCardsKey) RegCloseKey (hkCardsKey);
    if(bTerminalsKey) RegCloseKey (hkTerminalsKey);
    if(bSLBKey) RegCloseKey (hkSLBKey);

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\filepath.h ===
// FilePath.h: interface for the FilePath class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////


#if !defined(AFX_FILEPATH_H__9C7FE273_F538_11D3_A5E0_00104BD32DA8__INCLUDED_)
#define AFX_FILEPATH_H__9C7FE273_F538_11D3_A5E0_00104BD32DA8__INCLUDED_

#include <string>
#include <list>
#include <iostream>

#include <windows.h>

#include "DllSymDefn.h"

namespace iop
{

class IOPDLL_API FilePathComponent
{
public:
	FilePathComponent(unsigned short sFileID);
	FilePathComponent(std::string strFileID);

	virtual ~FilePathComponent();

	unsigned short GetShortID() { return m_usFileID; };
	std::string GetStringID();
	
	friend bool operator<(FilePathComponent const &lhs, FilePathComponent const &rhs); // Needed if you want these in a list
	friend bool operator>(FilePathComponent const &lhs, FilePathComponent const &rhs); // Needed if you want these in a list

	friend bool operator==(FilePathComponent const &lhs, FilePathComponent const &rhs);
	friend bool operator!=(FilePathComponent const &lhs, FilePathComponent const &rhs);

	friend std::ostream &operator<<(std::ostream &, FilePathComponent &);

private:
	unsigned short m_usFileID;
};

#pragma warning(push)
//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API std::list<FilePathComponent>;

#pragma warning(pop)

class IOPDLL_API FilePath  
{
public:
	FilePath();
	FilePath(const std::string strFilePath);
	FilePath(FilePath const &fp);

	virtual ~FilePath();

	FilePathComponent& operator[](unsigned int index);

	friend bool operator==(FilePath const &lhs, FilePath const &rhs);
	//operator +();
	const FilePath &operator +=(FilePathComponent);
	friend std::ostream &operator<<(std::ostream &, FilePath &);

	FilePathComponent Head();
	FilePathComponent Tail();

	void Clear();

	bool IsEmpty();

	FilePathComponent ChopTail();

	BYTE
    NumComponents();

	std::list<FilePathComponent> Components() { return m_FilePath; };

	FilePath GreatestCommonPrefix(FilePath &rPath);

	std::string GetStringPath();

	static FilePath Root();
	static bool IsValidPath(const std::string strFilePath);

private:

	std::list<FilePathComponent> m_FilePath;

 
};

} // namespace iop

#endif // !defined(AFX_FILEPATH_H__9C7FE273_F538_11D3_A5E0_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\filepath.cpp ===
// FilePath.cpp: implementation of the FilePath class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

// Don't allow the min & max macros in WINDEF.H to be defined so the
// min/max methods declared in limits are accessible.
#define NOMINMAX

#include "NoWarning.h"

#include <limits>

#include "iopExc.h"
#include "FilePath.h"

using namespace std;
using namespace iop;

namespace
{
    const char szSeparators[] = "/\\:";
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

FilePath::FilePath()
{

}

FilePath::FilePath(const string strFilePath)
{

	// Make local copy of the string, since we need to manipulate it
	string strPath(strFilePath);

	while (strPath.length() > 0)
	{
        string::size_type i(0);
        string::size_type j(0);

		i = strPath.find_first_not_of(szSeparators, 0);
		if (i == std::string::npos)
            break;
		j = strPath.find_first_of(szSeparators, i+1);

        std::string::size_type cIndex =
            std::string::npos == j
            ? strPath.length()
            : j - i;

        FilePathComponent fpc(FilePathComponent(strPath.substr(i, cIndex)));
		m_FilePath.push_back(fpc);
		
		if (std::string::npos == j)
            break;

		strPath = strPath.substr(j+1, strPath.length() - (j+1));
	}

}

FilePath::FilePath(FilePath const &fp)
{
	m_FilePath = list<FilePathComponent>(fp.m_FilePath);
}

FilePath::~FilePath()
{

}

BYTE
FilePath::NumComponents()
{
	return static_cast<BYTE>(m_FilePath.size());
}

bool FilePath::IsEmpty()
{
	return (m_FilePath.size() == 0);
}

FilePathComponent FilePath::ChopTail()
{
	std::list<FilePathComponent>::iterator iter1 = m_FilePath.begin();
	std::list<FilePathComponent>::iterator iter2 = m_FilePath.end();

	if (iter1 == iter2)
		throw Exception(ccBadFilePath);
	iter2--;
	FilePathComponent fpc = *iter2;
	m_FilePath.erase(iter2);
	return fpc;
}

void FilePath::Clear()
{
	m_FilePath.clear();
}
	
FilePathComponent FilePath::Head()
{
	std::list<FilePathComponent>::iterator iter = m_FilePath.begin();
    if (m_FilePath.end() == iter)
        throw Exception(ccBadFilePath);
	return *iter;
}

FilePathComponent FilePath::Tail()
{
	std::list<FilePathComponent>::iterator iter = m_FilePath.end();
    if (m_FilePath.begin() == iter)
        throw Exception(ccBadFilePath);
	return *(--iter);
}

string FilePath::GetStringPath()
{
	string str;
	std::list<FilePathComponent>::iterator iter = m_FilePath.begin();
	while (iter != m_FilePath.end())
	{
		str += (*iter).GetStringID();
		iter++;
	}
	return str;
}

FilePath FilePath::Root()
{
	return FilePath(string("/3f00"));
}

const FilePath &FilePath::operator +=(const FilePathComponent fp)
{
    if (m_FilePath.size() >= std::numeric_limits<BYTE>::max())
        throw Exception(ccFilePathTooLong);
	m_FilePath.push_back(fp);
	return *this;
}

FilePathComponent &FilePath::operator [](unsigned int index)
{
	if (index > (m_FilePath.size() - 1))
		throw Exception(ccInvalidParameter);
	std::list<FilePathComponent>::iterator iter = m_FilePath.begin();
	for (unsigned int i = 0; i < index; i++)
		iter++;
	return *iter;
}

FilePath FilePath::GreatestCommonPrefix(FilePath &rPath)
{
	FilePath fp;
	std::list<FilePathComponent>::iterator iter1 = m_FilePath.begin();
	std::list<FilePathComponent>::iterator iter2 = rPath.m_FilePath.begin();
	while ((iter1 != m_FilePath.end()) &&
           (iter2 != rPath.m_FilePath.end()) &&
           (*iter1 == *iter2))
	{
		fp += *iter1;
		iter1++;
		iter2++;
	}
	return fp;
}




bool iop::operator==(FilePath const &lhs, FilePath const &rhs)
{
	return lhs.m_FilePath == rhs.m_FilePath;
}

std::ostream &iop::operator<<(std::ostream &output, FilePath &fp)
{
	string str = fp.GetStringPath();
	output << str;
	return output;
}

FilePathComponent::FilePathComponent(string strFileID)
{
	// Check the length and throw if it is greater than 5
	if (strFileID.length() > 5)
        throw Exception(ccFileIdTooLarge);

	char *stopstring;
	
	const char* buf = strFileID.c_str();
	if ((buf[0] == '/') || (buf[0] == '\\') || (buf[0] == ':'))
		m_usFileID = (short)strtoul(&buf[1],&stopstring,16);
	else
		m_usFileID = (short)strtoul(buf,&stopstring,16);

}

FilePathComponent::FilePathComponent(unsigned short usFileID) : m_usFileID(usFileID)
{

}

FilePathComponent::~FilePathComponent()
{

}

// Overloaded == operator for FilePathComponent
bool iop::operator==(FilePathComponent const &lhs,
                     FilePathComponent const &rhs)
{
	return lhs.m_usFileID == rhs.m_usFileID;
}

bool iop::operator!=(FilePathComponent const &lhs,
                     FilePathComponent const &rhs)
{
	return lhs.m_usFileID != rhs.m_usFileID;
}
bool iop::operator<(FilePathComponent const &lhs,
                    FilePathComponent const &rhs)
{
	return lhs.m_usFileID < rhs.m_usFileID;
}
bool iop::operator>(FilePathComponent const &lhs,
                    FilePathComponent const &rhs)
{
	return lhs.m_usFileID > rhs.m_usFileID;
}


std::ostream &iop::operator<<(std::ostream &output,
                              FilePathComponent &fpc)
{
	output << fpc.GetStringID();
	return output;
}

string FilePathComponent::GetStringID()
{
	char buf[33];	// 
	_itoa(m_usFileID,buf,16);
	string tmp(buf);
	for (unsigned int i = 4; i > strlen(buf); i--) tmp = string("0") + tmp;
	return string("/") + tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\cryptocard.h ===
// CryptoCard.h: interface for the CCryptoCard class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(CRYPTOCARD_H__INCLUDED_)
#define CRYPTOCARD_H__INCLUDED_

#include "NoWarning.h"

#include "DllSymDefn.h"
#include "SmartCard.h"

namespace iop
{

struct CryptoACL
{
    BYTE	Level;			// ranges from 0 to 15
    BYTE    CHVnumber;		// Number of the CHV is requested, equal to 0 by default
    BYTE	AUTnumber;		// Number of the AUT is requested, equal to 0 by default
	BYTE	CHVcounter;
	BYTE	AUTcounter;

};

	class IOPDLL_API CCryptoCard : public CSmartCard
	{
	
		public:
			void GetACL(BYTE *bACL);
			CCryptoCard(const SCARDHANDLE  hCardHandle, const char* szReaderName, 
				        const SCARDCONTEXT pContext,	const DWORD dwMode);
			virtual ~CCryptoCard();
			
			virtual void DeleteFile(const WORD wFileID);
			virtual void CreateFile(const FILE_HEADER* pMyFile);
               
			virtual void SelectParent();
			virtual void Directory  (const BYTE  bFile_Nb,		 FILE_HEADER* pMyFile);
			virtual void Select	    (const char* szFileFullPath, FILE_HEADER* pMyFile = NULL, const bool fSelectAll = false);
			virtual void VerifyKey  (const BYTE bKeyNumber, const BYTE  bKeyLength, const BYTE* bKey);
			virtual void VerifyCHV  (const BYTE bCHVNumber,	const BYTE* bCHV);
			virtual void VerifyTransportKey(const BYTE *bKey);

            virtual void GetChallenge(const DWORD dwNumberLength, BYTE* bRandomNumber);
			virtual void ExternalAuth(const KeyType kt,		const BYTE  bKeyNb, 
									  const BYTE bDataLength,	const BYTE* bData);
			virtual void InternalAuth(const KeyType kt,      const BYTE  bKeyNb,
									  const BYTE bDataLength,   const BYTE* bDataIn, BYTE* bDataOut);

			virtual void ReadPublicKey  (CPublicKeyBlob *aKey,		 const BYTE bKeyNum);
			virtual void WritePublicKey (const CPublicKeyBlob aKey,  const BYTE bKeyNum);
			virtual void WritePrivateKey(const CPrivateKeyBlob aKey, const BYTE bKeyNum);

            virtual CPublicKeyBlob GenerateKeyPair(const BYTE *bpPublExp, const WORD wPublExpLen, 
                                                   const BYTE bKeyNum, const KeyType kt);

            virtual void ChangeACL		   (const BYTE *bACL);
			virtual void ChangeCHV		   (const BYTE bKey_nb, const BYTE *bOldCHV,     const BYTE *bNewCHV);
            virtual void ChangeCHV         (const BYTE bKey_nb, const BYTE *bNewCHV);
			virtual void UnblockCHV        (const BYTE bKey_nb, const BYTE *bUnblockPIN, const BYTE *bNewPin);
			virtual void ChangeUnblockKey  (const BYTE bKey_nb, const BYTE *bNewPIN);
			virtual void ChangeTransportKey(const BYTE *bNewKey);

			virtual void GetSerial(BYTE* bSerial, size_t &SerialLength);
			virtual void LogoutAll();
					 
		protected:
            virtual void
            DefaultDispatchError(ClassByte cb,
                                 Instruction ins,
                                 StatusWord sw) const;

            virtual void
            DispatchError(ClassByte cb,
                          Instruction ins,
                          StatusWord sw) const;

            virtual void
            DoReadBlock(WORD wOffset,
                        BYTE *pbBuffer,
                        BYTE bLength);

            virtual void
            DoWriteBlock(WORD wOffset,
                         BYTE const *pbBuffer,
                         BYTE cLength);
            
            virtual bool
            SupportLogout();

			virtual void Select(const WORD wFileID);
			void AccessToCryptoACL(bool* fAccessACL, CryptoACL* pCryptoACL);
			void CryptoToAccessACL(BYTE* bAccessACL,	  const BYTE bACLNibble, 
								   const BYTE bKeyNibble, const BYTE bShift);

    private:
        enum                                      // Instruction
        {
            insChangeChv     = 0x24,
            insUnblockChv    = 0x2C,
            insKeyGeneration = 0x46,
        };
		BYTE m_bLastACL[4];
	};

}
#endif // !defined(AFX_CRYPTOCARD_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\iopexc.h ===
// iopExc.h -- IOP EXCeption class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(IOP_EXC_H)
#define IOP_EXC_H

#include <scuExc.h>

#include "DllSymDefn.h"

namespace iop
{

enum CauseCode
{
    ccAclNotSupported,
    ccAclNotTranslatable,
    ccAlgorithmIdNotSupported,
    ccBadFileCategory,
    ccBadFilePath,
    ccBadInstanceFile,
    ccBadLockReferenceCount,
    ccCannotInterpretGetResponse,
    ccCyclicRecordSizeTooLarge,
    ccDirectoryNotEmpty,
    ccFail,
    ccFileIdNotHex,
    ccFileIdTooLarge,
    ccFilePathTooLong,
    ccFileTypeUnknown,
    ccFileTypeInvalid,
    ccInvalidChecksum,
    ccInvalidChv,
    ccInvalidParameter,
    ccLockCorrupted,
    ccMutexHandleChanged,
    ccNoFileSelected,                             // TO DO: Delete?
    ccNoResponseAvailable,
    ccNotImplemented,
    ccResourceManagerDisabled,
    ccSelectedFileNotDirectory,
    ccSynchronizationObjectNameTooLong,
    ccUnknownCard,
    ccUnsupportedCommand,
	ccBadATR,
    ccBufferTooSmall,
};

typedef scu::ExcTemplate<scu::Exception::fcIOP, CauseCode> Exception;

///////////////////////////    HELPERS    /////////////////////////////////
char const *
Description(Exception const &rExc);

} // namespace iop
 
inline char const *
iop::Exception::Description() const
{
    return iop::Description(*this);
}

#endif // IOP_EXC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\ioplock.cpp ===
// IOPLock.cpp: implementation of the CIOPLock class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include <scuOsExc.h>
#include <scuOsVersion.h>

#include "IOPLock.h"
#include "iopExc.h"
#include "iop.h"
#include "SmartCard.h"

using namespace std;
using namespace iop;

RMHangProcDeathSynchObjects::RMHangProcDeathSynchObjects(SECURITY_ATTRIBUTES *psa,
                                                         LPCTSTR lpMutexName)
    : m_hMutex(INVALID_HANDLE_VALUE)
{
	InitializeCriticalSection(&m_cs);

	// Set up Mutex

	m_hMutex = CreateMutex(psa, FALSE, lpMutexName);

    if (!m_hMutex)
    {
        DWORD dwLastError = GetLastError();
        DeleteCriticalSection(&m_cs);
        throw scu::OsException(dwLastError);
    }
}

RMHangProcDeathSynchObjects::~RMHangProcDeathSynchObjects()
{
    try
    {
        // Be sure that the calling thread is the owner (if any) of the locks
        EnterCriticalSection(&m_cs);
        CloseHandle(m_hMutex);
    }

    catch (...)
    {
    }

    try
    {
        LeaveCriticalSection(&m_cs);
        DeleteCriticalSection(&m_cs);
    }

    catch (...)
    {
    }
}

CRITICAL_SECTION *
RMHangProcDeathSynchObjects::CriticalSection()
{
    return &m_cs;
}

HANDLE
RMHangProcDeathSynchObjects::Mutex() const
{
    return m_hMutex;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CIOPLock::CIOPLock(const char *szReaderName)
    : m_apRMHangProcDeathSynchObjects(0),
      m_pSmartCard(0)
{
    m_iRefCount = 0;

#if defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
	SECURITY_ATTRIBUTES *psa = NULL;
#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)

    CSecurityAttributes *sa = new CSecurityAttributes;
    CIOP::InitIOPSecurityAttrs(sa);
	psa = &(sa->sa);

#endif

	// Set up mutex name
	char szMutexName[RMHangProcDeathSynchObjects::cMaxMutexNameLength]
        = "SLBIOP_MUTEX_";

	if (strlen(szMutexName) + strlen(szReaderName) + 1 >
        RMHangProcDeathSynchObjects::cMaxMutexNameLength)
       throw Exception(ccSynchronizationObjectNameTooLong);
 
	strcat(szMutexName, szReaderName);

    m_apRMHangProcDeathSynchObjects =
        auto_ptr<RMHangProcDeathSynchObjects>(new
                                              RMHangProcDeathSynchObjects(psa,
                                                                          szMutexName));
#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)

	delete sa;

#endif
#endif // defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
}

CIOPLock::~CIOPLock()
{
}

CRITICAL_SECTION *
CIOPLock::CriticalSection()
{
    return m_apRMHangProcDeathSynchObjects->CriticalSection();
}

void CIOPLock::Init(CSmartCard *pSmartCard)
{ 
    m_pSmartCard = pSmartCard; 
}

HANDLE
CIOPLock::MutexHandle()
{
    return m_apRMHangProcDeathSynchObjects->Mutex();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\ioplock.h ===
// IOPLock.h: interface for the CIOPLock class.
//
// There is a CIOPLock object associated with each card object.  The card object passes in its reader
// name to the CIOPLock object in order to create the mutex by name.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IOPLOCK_H__EB8BCE22_0ED2_11D3_A585_00104BD32DA8__INCLUDED_)
#define AFX_IOPLOCK_H__EB8BCE22_0ED2_11D3_A585_00104BD32DA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <memory>                                 // for std::auto_ptr

#include <windows.h>
#include <winscard.h>

#include <scuOsVersion.h>

#include "DllSymDefn.h"

// Define when target OS is anything but W2K series.  On non-W2K
// platforms, the smart card Resource Manager will hang other
// processes when another process using the RM dies suddenly without
// cleaning up.
#if !SLBSCU_WIN2K_SERIES
#define SLBIOP_RM_HANG_AT_PROCESS_DEATH
#endif

namespace iop
{

class CSmartCard;

// Instantiate the templates so they will be properly accessible
// as data members to the exported class CIOPLock in the DLL.  See
// MSDN Knowledge Base Article Q168958 for more information.

#pragma warning(push)
//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

// Synchronization objects used to guard against the Resource
// Manager hanging when a process dies.  Only used in non-W2K MS
// environments since the RM doesn't have that attribute in W2K+.
class RMHangProcDeathSynchObjects
{
public:

    enum
    {
        cMaxMutexNameLength = MAX_PATH,
    };

    RMHangProcDeathSynchObjects(SECURITY_ATTRIBUTES *psa,
                                LPCTSTR lpMutexName);

    ~RMHangProcDeathSynchObjects();

    CRITICAL_SECTION *
    CriticalSection();

    HANDLE
    Mutex() const;
        
private:
    CRITICAL_SECTION m_cs;
    HANDLE m_hMutex;
};
    
IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API std::auto_ptr<RMHangProcDeathSynchObjects>;

#pragma warning(pop)

class IOPDLL_API CIOPLock  
{
public:
	explicit CIOPLock(const char *szReaderName);
	virtual ~CIOPLock();

    CRITICAL_SECTION *CriticalSection();
    HANDLE MutexHandle();

    CSmartCard *SmartCard() {return m_pSmartCard;};

    void IncrementRefCount() {m_iRefCount++;};
    void DecrementRefCount() {if(m_iRefCount) m_iRefCount--;};
    long RefCount() {return m_iRefCount;};

	void RegisterWriteEvent();

	void Init(CSmartCard *pSmartCard);

private:

    // CIOPLock can not be copied due to CRITICAL_SECTION member, so
    // copy member routines are declared private and not defined.
    CIOPLock(CIOPLock const &rhs);

    CIOPLock &
    operator=(CIOPLock const &rhs);
    
	unsigned long m_iRefCount;
    std::auto_ptr<RMHangProcDeathSynchObjects> m_apRMHangProcDeathSynchObjects;
	CSmartCard *m_pSmartCard;

};

} // namespace iop

#endif // !defined(AFX_IOPLOCK_H__EB8BCE22_0ED2_11D3_A585_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\ioppubblob.h ===
// iopPubBlob.h: interface for the CPublicKeyBlob.
//
//////////////////////////////////////////////////////////////////////


#if !defined(IOP_PUBBLOB_H)
#define IOP_PUBBLOB_H

#include <windows.h>

#include "DllSymDefn.h"

namespace iop
{

class IOPDLL_API CPublicKeyBlob
{
public:
    CPublicKeyBlob() {};
    virtual ~CPublicKeyBlob(){};

    BYTE bModulusLength;
    BYTE bModulus[128];
    BYTE bExponent[4];
};

///////////////////////////    HELPERS    /////////////////////////////////

void IOPDLL_API __cdecl             // __cdecl req'd by CCI
Clear(CPublicKeyBlob &rKeyBlob);    // defined in KeyBlobHlp.cpp

}  // namespace iop


#endif // !defined(IOP_PUBBLOB_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\iop.h ===
// IOP.h -- Main header for IOP

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(IOP_IOP_H)
#define IOP_IOP_H

#include "NoWarning.h"

#include <winscard.h>
#include <shlwapi.h>

#include <scuOsVersion.h>

#include "DllSymDefn.h"
#include "SmartCard.h"
#include "CryptoCard.h"
#include "AccessCard.h"
#include "iopExc.h"
#include "SharedMarker.h"
#include "SecurityAttributes.h"

#ifdef IOPDLL_EXPORTS
STDAPI DllRegisterServer();

STDAPI DllUnregisterServer();
	
STDAPI DllGetVersion(DLLVERSIONINFO *dvi);
#endif

#if defined(SLB_WINNT_BUILD) || defined(SLB_WIN2K_BUILD)
#define SLBIOP_USE_SECURITY_ATTRIBUTES
#endif

// To support smart card logon, wait for the Microsoft Resource Manager
// to startup. This is not relevant for Windows 9x.
#if SLBSCU_WINNT_ONLY_SERIES
#define SLBIOP_WAIT_FOR_RM_STARTUP
#endif


namespace iop
{
    
typedef IOPDLL_API enum
{
	UNKNOWN_CARD = 0x00,		//	Assign values to card class specifiers (CCryptoCard, 
	CRYPTO_CARD	 = 0x01,		//  CAccessCard, etc...) between 0x00 and 0xFF, since only 
	ACCESS_CARD	 = 0x02,		//	one byte will be stored in the registry for cardType
	
} cardType;

class IOPDLL_API CIOP {

	public:	
		CIOP();
   	   ~CIOP();

		CSmartCard *
        Connect(const char* szReaderName,
                bool fExclusiveMode = false);

		void ListReaders(char* szReadersList, int& iSizeOfList);
		static void ListKnownCards(char* szCardList, int& iSizeOfList);

		static void RegisterCard(const char* szCardName, const BYTE* bATR,			 const BYTE  bATRLength,
							     const BYTE* bATRMask,   const BYTE  bATRMaskLength, const BYTE* bProperties,
								 const cardType type);

		static void RegisterDefaultCards();

#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)
	    static void InitIOPSecurityAttrs(CSecurityAttributes* psa);
#endif

        static bool WINAPI WaitForSCManager();

    private:
        CSmartCard* CreateCard(const BYTE *bATR,		 const DWORD dwLength, const SCARDHANDLE hCard,
							   const char* szReaderName, const DWORD dwShareMode);	
 		// handle to resource manager
        SCARDCONTEXT m_hContext;		

};

}

#endif // !defined(IOP_IOP_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\ioppriblob.h ===
// iopPriBlob.h: interface for the CPrivateKeyBlob
//
//////////////////////////////////////////////////////////////////////

#if !defined(IOP_PRIBLOB_H)
#define IOP_PRIBLOB_H

#include <windows.h>
#include <scuSecureArray.h>

#include "DllSymDefn.h"

namespace iop
{
// Instantiate the templates so they will be properly accessible
// as data members to the exported class CSmartCard in the DLL.  See
// MSDN Knowledge Base Article Q168958 for more information.

#pragma warning(push)
//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API scu::SecureArray<BYTE>;
IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API scu::SecureArray<char>;
#pragma warning(pop)
    
class IOPDLL_API CPrivateKeyBlob
{
public:
    CPrivateKeyBlob()
        : bP(scu::SecureArray<BYTE>(64)),
          bQ(scu::SecureArray<BYTE>(64)),
          bInvQ(scu::SecureArray<BYTE>(64)),
          bKsecModQ(scu::SecureArray<BYTE>(64)),
          bKsecModP(scu::SecureArray<BYTE>(64))
    {
    };
    virtual ~CPrivateKeyBlob(){};

    BYTE bPLen;
    BYTE bQLen;
    BYTE bInvQLen;
    BYTE bKsecModQLen;
    BYTE bKsecModPLen;
    
    scu::SecureArray<BYTE> bP;
    scu::SecureArray<BYTE> bQ;
    scu::SecureArray<BYTE>bInvQ;
    scu::SecureArray<BYTE> bKsecModQ;
    scu::SecureArray<BYTE> bKsecModP;
};

///////////////////////////    HELPERS    /////////////////////////////////

void IOPDLL_API __cdecl              // __cdecl req'd by CCI
Clear(CPrivateKeyBlob &rKeyBlob);    // defined in KeyBlobHlp.cpp

} // namespace iop

#endif // IOP_PRIBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\keyblobhlp.cpp ===
// KeyBlobHlp.cpp -- Key Blob Helpers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "iopPubBlob.h"
#include "iopPriBlob.h"

///////////////////////////    HELPERS    /////////////////////////////////

void IOPDLL_API __cdecl
iop::Clear(CPrivateKeyBlob &rKeyBlob)
{
    rKeyBlob.bPLen = 0;
    rKeyBlob.bQLen = 0;
    rKeyBlob.bInvQLen = 0;
    rKeyBlob.bKsecModQLen = 0;
    rKeyBlob.bKsecModPLen = 0;

    ZeroMemory(rKeyBlob.bP.data(), rKeyBlob.bP.size() * sizeof BYTE);
    ZeroMemory(rKeyBlob.bQ.data(), rKeyBlob.bQ.size() * sizeof BYTE);
    ZeroMemory(rKeyBlob.bInvQ.data(),rKeyBlob.bInvQ.size() * sizeof BYTE);
    ZeroMemory(rKeyBlob.bKsecModQ.data(), rKeyBlob.bKsecModQ.size() * sizeof BYTE);
    ZeroMemory(rKeyBlob.bKsecModP.data(), rKeyBlob.bKsecModP.size() * sizeof BYTE);
}

void IOPDLL_API __cdecl
iop::Clear(CPublicKeyBlob &rKeyBlob)
{
    rKeyBlob.bModulusLength = 0;
    ZeroMemory(rKeyBlob.bModulus, sizeof rKeyBlob.bModulus);
    ZeroMemory(rKeyBlob.bExponent, sizeof rKeyBlob.bExponent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\lockwrap.cpp ===
// LockWrap.cpp: implementation of the CLockWrap class.
// LockWrap.cpp: implementation of the CIOPCriticalSection class.
// LockWrap.cpp: implementation of the CIOPMutex class.
// LockWrap.cpp: implementation of the CSCardLock class.
//
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include "LockWrap.h"
#include "SmartCard.h"

using namespace iop;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLockWrap::CLockWrap(CIOPLock *pIOPLock)
    : m_IOPCritSect(pIOPLock),
                                           m_IOPMutex(pIOPLock),
                                           m_SCardLock(pIOPLock),
                                           m_pIOPLock(pIOPLock)
{
    if (0 == m_pIOPLock->RefCount())
        m_pIOPLock->SmartCard()->ResetSelect();
    m_pIOPLock->IncrementRefCount();
}

CLockWrap::~CLockWrap()
{
    try {
        m_pIOPLock->DecrementRefCount();
    }
    catch(...) {};
}

CIOPCriticalSection::CIOPCriticalSection(CIOPLock *pIOPLock)
    : m_pIOPLock(pIOPLock)
{
#if defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
    EnterCriticalSection(m_pIOPLock->CriticalSection());
#endif
}

CIOPCriticalSection::~CIOPCriticalSection()
{
#if defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
    try {
        LeaveCriticalSection(m_pIOPLock->CriticalSection());
    }
    catch(...) {};
#endif
}

CIOPMutex::CIOPMutex(CIOPLock *pIOPLock) : m_pIOPLock(pIOPLock)
{
#if defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
    if (0 == m_pIOPLock->RefCount())
    {
        if (WaitForSingleObject(m_pIOPLock->MutexHandle(),
                                INFINITE) == WAIT_FAILED)
            throw scu::OsException(GetLastError());
    }
#endif
}

CIOPMutex::~CIOPMutex()
{
#if defined(SLBIOP_RM_HANG_AT_PROCESS_DEATH)
    try
    {
        if (0 == m_pIOPLock->RefCount())
            ReleaseMutex(m_pIOPLock->MutexHandle());
    }
    catch (...)
    {}
#endif
}


CSCardLock::CSCardLock(CIOPLock *pIOPLock) : m_pIOPLock(pIOPLock)
{

    if (0 == m_pIOPLock->RefCount())
    {
        HRESULT hResult;

        SCARDHANDLE hCard = m_pIOPLock->SmartCard()->getCardHandle();

        hResult = SCardBeginTransaction(hCard);
        if (hResult != SCARD_S_SUCCESS)
        {
            DWORD dwState;
            DWORD dwProtocol;
            BYTE bATR[CSmartCard::cMaxAtrLength];
            DWORD dwATRLen = sizeof bATR / sizeof *bATR;
            DWORD dwReaderNameLen = 0;

            HRESULT hr = SCardStatus(hCard, NULL, &dwReaderNameLen,
                                     &dwState, &dwProtocol, bATR,
                                     &dwATRLen);
            if (hr == SCARD_W_RESET_CARD)
            {
                m_pIOPLock->SmartCard()->ResetSelect();
                m_pIOPLock->SmartCard()->ReConnect();
            }
            else
                throw scu::OsException(hResult);

            hr = SCardBeginTransaction(hCard);
            if (hr != SCARD_S_SUCCESS)
                throw scu::OsException(hResult);
        }
        // set the dirty flag on the card to indicate that no data
        // on the card has changed since the beginning if the
        // transaction. 
        m_pIOPLock->SmartCard()->Dirty(false);
    }
}

CSCardLock::~CSCardLock()
{
    try
    {
        if (0 == m_pIOPLock->RefCount())
        {
        HRESULT hResult;
        SCARDHANDLE hCard = m_pIOPLock->SmartCard()->getCardHandle();

        hResult = SCardEndTransaction(hCard, SCARD_LEAVE_CARD);

        if (hResult != SCARD_S_SUCCESS)
        {
            DWORD dwState;
            DWORD dwProtocol;
            BYTE bATR[CSmartCard::cMaxAtrLength];
            DWORD dwATRLen = sizeof bATR / sizeof *bATR;
            DWORD dwReaderNameLen = 0;
                HRESULT hr = SCardStatus(hCard, NULL,
                                         &dwReaderNameLen, &dwState,
                                         &dwProtocol, bATR,
                                         &dwATRLen);

                // ignore failures since in destructor.
            if (hr == SCARD_W_RESET_CARD)
            {
                m_pIOPLock->SmartCard()->ResetSelect();
                m_pIOPLock->SmartCard()->ReConnect();

            hr = SCardEndTransaction(hCard, SCARD_LEAVE_CARD);
                }
            }
        }
    }

    catch (...)
    {}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\lockwrap.h ===
// LockWrap.h: interface for the CLockWrap class.
// LockWrap.h: interface for the CIOPCriticalSection class.
// LockWrap.h: interface for the CIOPMutex class.
// LockWrap.h: interface for the CSCardLock class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOCKWRAP_H__46F3EF74_97A9_11D3_A5D4_00104BD32DA8__INCLUDED_)
#define AFX_LOCKWRAP_H__46F3EF74_97A9_11D3_A5D4_00104BD32DA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000



#include "IOPLock.h"

namespace iop {

class IOPDLL_API CIOPCriticalSection
{
public:
    explicit CIOPCriticalSection::CIOPCriticalSection(CIOPLock *pIOPLock);
    ~CIOPCriticalSection();

private:
    CIOPLock *m_pIOPLock;

};



class IOPDLL_API CIOPMutex
{
public:
    explicit CIOPMutex::CIOPMutex(CIOPLock *pIOPLock);
    ~CIOPMutex();

private:
    CIOPLock *m_pIOPLock;

};



class IOPDLL_API CSCardLock
{
public:
    explicit CSCardLock::CSCardLock(CIOPLock *pIOPLock);
    ~CSCardLock();

private:
    CIOPLock *m_pIOPLock;

};



class IOPDLL_API CLockWrap
{
public:
    explicit CLockWrap(CIOPLock *pIOPLock);
    ~CLockWrap();

private:
    CIOPCriticalSection m_IOPCritSect;
    CIOPMutex m_IOPMutex;
    CSCardLock m_SCardLock;
    CIOPLock *m_pIOPLock;
};



} // namespace iop


#endif // !defined(AFX_LOCKWRAP_H__46F3EF74_97A9_11D3_A5D4_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\marker.h ===
// Marker.h: interface for the CMarker class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MARKER_H__8B7450C2_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_)
#define AFX_MARKER_H__8B7450C2_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <rpc.h>
#include "DllSymDefn.h"

namespace iop
{

class IOPDLL_API CMarker
{
public:

typedef __int64 MarkerCounter;

typedef enum {  PinMarker=0,
                WriteMarker=1,
                // ... add more above this line.
                MaximumMarker   // Reserved name.
             } MarkerType;

    explicit CMarker(MarkerType const &Type);
    CMarker(CMarker const &Marker);
    CMarker(MarkerType Type, UUID const &GUID, const MarkerCounter &Counter);
    virtual ~CMarker();

    CMarker& operator=(const CMarker &rhs);

    friend bool IOPDLL_API __cdecl operator==(const CMarker &lhs, const CMarker &rhs);
    friend bool IOPDLL_API __cdecl operator!=(const CMarker &lhs, const CMarker &rhs);

private:
    MarkerType m_Type;
    MarkerCounter m_Counter;
    UUID m_GUID;
};

} // namespace iop

#endif // !defined(AFX_MARKER_H__8B7450C2_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slbiop.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\securityattributes.h ===
// SecurityAttributes.h: interface for the CSecurityAttributes class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SECURITYATTRIBUTES_H__372E2879_069C_4C84_8E1C_CFB50EE49DFE__INCLUDED_)
#define AFX_SECURITYATTRIBUTES_H__372E2879_069C_4C84_8E1C_CFB50EE49DFE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>

class CSecurityAttributes  
{
public:
	CSecurityAttributes();
	virtual ~CSecurityAttributes();

	SECURITY_ATTRIBUTES sa;
	PSID pEveryoneSID;
	PACL pACL;

};

#endif // !defined(AFX_SECURITYATTRIBUTES_H__372E2879_069C_4C84_8E1C_CFB50EE49DFE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\marker.cpp ===
// Marker.cpp: implementation of the CMarker class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "iopExc.h"
#include "Marker.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

namespace iop
{

// #if defined(WIN32_LEAN_AND_MEAN)
// operator==(UUID const &lhs,
//            UUID const &rhs)
// {
//     return (0 == memcmp(&lhs, &rhs, sizeof lhs));
// }

// bool
// operator!=(UUID const &lhs,
//            UUID const &rhs)
// {
//     return !(lhs == rhs);
// }
// #endif // defined(WIN32_LEAN_AND_MEAN)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMarker::CMarker(MarkerType const &Type) : m_Type(Type), m_Counter(0)
{
    // When m_Counter is zero, the m_GUID need not be defined.
}

CMarker::CMarker(CMarker const &Marker)
{
    m_Type = Marker.m_Type;
    m_Counter = Marker.m_Counter;
    m_GUID = Marker.m_GUID;
}

CMarker::CMarker(MarkerType Type, UUID const &Guid, MarkerCounter const &Counter) :
                 m_Type(Type), m_GUID(Guid), m_Counter(Counter)
{
}

CMarker::~CMarker()
{

}

CMarker& CMarker::operator=(const CMarker &rhs)
{
    if(m_Type != rhs.m_Type) throw Exception(ccInvalidParameter);

    m_Counter = rhs.m_Counter;
    m_GUID = rhs.m_GUID;
    return *this;
}

bool IOPDLL_API __cdecl operator==(const CMarker &lhs, const CMarker &rhs)
{

    if(lhs.m_Type != rhs.m_Type) return false;
    if(lhs.m_Counter != rhs.m_Counter) return false;
    if(lhs.m_Counter) return ((lhs.m_GUID==rhs.m_GUID) ? true : false);
    else return true;  // Both counters are zero, ignore m_GUID

}

bool IOPDLL_API __cdecl operator!=(const CMarker &lhs, const CMarker &rhs)
{
    return !(lhs==rhs);
}

} // namespace iop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\nowarning.h ===
// NoWarning.h - Turn off compiler warnings that may be safely
// ignored.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBIOP_NOWARNING_H)
#define SLBIOP_NOWARNING_H

//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

//  Warning emitted by new compiler in MS' build
//      operator= recursive call on all control paths, function will
//      cause run-time stack overflow.
//  The compiler generated this in reference to iop::CSmartCard::Exception::operator=
//  It's bogus since all the members of this class and its parents have simple
//  member variables.
#pragma warning(disable : 4717)

//  Identifier truncated to 255 in debugger/browser info
#pragma warning(disable : 4786)

#endif // SLBIOP_NOWARNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\securityattributes.cpp ===
// SecurityAttributes.cpp: implementation of the CSecurityAttributes class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2001. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "SecurityAttributes.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSecurityAttributes::CSecurityAttributes()
{
	pACL = NULL;
	pEveryoneSID = NULL;
	sa.bInheritHandle = false;
	sa.lpSecurityDescriptor = NULL;
	sa.nLength = 0;
}

CSecurityAttributes::~CSecurityAttributes()
{
	if (NULL != pACL)
	{
		LocalFree(pACL);
		pACL = NULL;
	}
 	if (NULL != sa.lpSecurityDescriptor)
	{
		LocalFree(sa.lpSecurityDescriptor);
		sa.lpSecurityDescriptor = NULL;
	}
	if (NULL != pEveryoneSID)
	{
		FreeSid(pEveryoneSID);
		pEveryoneSID = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\sharedmarker.h ===
// SharedMarker.h: interface for the CSharedMarker class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SHAREDMARKER_H__8B7450C4_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_)
#define AFX_SHAREDMARKER_H__8B7450C4_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_

#include <string>
#include <rpc.h>
#include <scuOsExc.h>
#include "Marker.h"

namespace iop
{

class CSharedMarker
{

public:
	CSharedMarker(std::string const &strName);
	virtual ~CSharedMarker();

    CMarker Marker(CMarker::MarkerType const &Type);
	CMarker	UpdateMarker(CMarker::MarkerType const &Type);

private:
    void Initialize();
	void VerifyCheckSum(bool bRecover = false);
	void UpdateCheckSum();
    DWORD SharedMemorySize() {return sizeof(SharedMemoryData);};

    typedef struct {
	    UUID ShMemID;
        CMarker::MarkerCounter CounterList[CMarker::MaximumMarker];
	    __int32 CheckSum;
    } SharedMemoryData;

    SharedMemoryData *m_pShMemData;

	HANDLE m_hFileMap;
	HANDLE m_hMutex;

    // The Transaction class is is used to mutex protect critial sections
    // cross process boundaries.

    class Transaction {
    public:
        Transaction(HANDLE hMutex) : m_hMutex(hMutex)
        {
            if(WaitForSingleObject(m_hMutex,INFINITE)==WAIT_FAILED)
                throw scu::OsException(GetLastError());
        };

        ~Transaction() {
            try {
                ReleaseMutex(m_hMutex);
            }
            catch(...) {};
        };

    private:
        HANDLE m_hMutex;

    };
};

}

#endif // !defined(AFX_SHAREDMARKER_H__8B7450C4_A2FD_11D3_A5D7_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\smartcard.cpp ===
// CSmartCard.cpp: implementation of the CSmartCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include <string>
#include <wtypes.h>

#include <scuOsExc.h>
#include <scuExcHelp.h>
#include <scuArrayP.h>
#include <scuSecureArray.h>

#include "iopExc.h"
#include "SmartCard.h"
#include "LockWrap.h"

using namespace std;
using namespace scu;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//////////////////// Begin CSmartCard::Exception //////////////////////////

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    using namespace iop;

    // Transfer data to/from the card.  The data to read/write is
    // broken up into cMaxBlock sized chunks when calling rsc's
    // (CSmartCard) member procedure pbtm (pointer to member routine)
    // to actually do the read/write.
    template<class BlockType, class PBlockTransferMember>
    void
    TransferData(const WORD wOffset,              // file offset to start
                 const WORD wDataLength,          // amount to transfer
                 BlockType  bData,                // data buffer to read/write
                 CSmartCard &rsc,                 // card object to use
                 PBlockTransferMember pbtm,       // member proc to read/write
                 WORD cMaxBlock)                  // max size transfer at once
    {
        WORD wBytesTransferred  = 0;
        WORD wFullRounds = wDataLength / cMaxBlock;

        /////////////////////////////////////////////////
        //  Transfer maximum bytes at each full round  //
        /////////////////////////////////////////////////
        for (WORD wCurrentRound = 0; wCurrentRound < wFullRounds; wCurrentRound++)
        {
            (rsc.*pbtm)(wOffset + wBytesTransferred,
                        bData + wBytesTransferred, cMaxBlock);

            wBytesTransferred += cMaxBlock;
        }

        // Transfer any leftovers
        BYTE bBytesLeft = wDataLength - wBytesTransferred;
        if (bBytesLeft != 0)
        {
            (rsc.*pbtm)(wOffset + wBytesTransferred,
                        bData + wBytesTransferred, bBytesLeft);
        }
    }

    scu::CauseCodeDescriptionTable<CSmartCard::CauseCode> ccdt[] =
    {
        {
            CSmartCard::ccAccessConditionsNotMet,
            TEXT("Access conditions not met.")
        },
        {
            CSmartCard::ccAlgorithmIdNotSupported,
            TEXT("The algorithm ID is not supported in the card.")
        },
        {
            CSmartCard::ccAskRandomNotLastApdu,
            TEXT("The random number is no longer available.  The "
                 "AskRandom APDU must be sent immediately previous "
                 "to this one.")
        },
        {
            CSmartCard::ccAuthenticationFailed,
            TEXT("Authentication failed (i.e. CHV or key rejected, or "
                 "wrong cryptogram).")
        },
        {
            CSmartCard::ccBadFilePath,
            TEXT("The file path is invalid.  Ensure that each file "
                 "name in the path is 4 characters long and is a valid "
                 "representation of the hexadecimal ID.")
        },
        {
            CSmartCard::ccBadState,
            TEXT("The Application is not in a state permitting this "
                 "operation.")
        },
        {
            CSmartCard::ccCannotReadOutsideFileBoundaries,
            TEXT("Could not read outside the file boundaries.")
        },
        {
            CSmartCard::ccCannotWriteOutsideFileBoundaries,
            TEXT("Could not write outside the file boundaries.")
        },
        {
            CSmartCard::ccCardletNotInRegisteredState,
            TEXT("Cardlet is not in a registered state. It may be "
                 "blocked or not completely installed.")
        },
        {
            CSmartCard::ccChvNotInitialized,
            TEXT("No CHV is initialzed.")
        },
        {
            CSmartCard::ccChvVerificationFailedMoreAttempts,
            TEXT("CHV verification was unsuccessful, at least one "
                 "attempt remains.")
        },
        {
            CSmartCard::ccContradictionWithInvalidationStatus,
            TEXT("Contradiction with invalidation status occured.")
        },
        {
            CSmartCard::ccCurrentDirectoryIsNotSelected,
            TEXT("The current directory is not selected.")
        },
        {
            CSmartCard::ccDataPossiblyCorrupted,
            TEXT("Data possibly corrupted.")

        },
        {
            CSmartCard::ccDefaultLoaderNotSelected,
            TEXT("Cardlet is currently selected and install cannot "
                 "run. Default loader application must be selected.")
        },
        {
            CSmartCard::ccDirectoryNotEmpty,
            TEXT("This directory still contains other files or "
                 "directories and may not be deleted.")
        },
        {
            CSmartCard::ccFileAlreadyInvalidated,
            TEXT("File already invalidated.")
        },
        {
            CSmartCard::ccFileExists,
            TEXT("The file ID requested is already in use.")
        },
        {
            CSmartCard::ccFileIdExistsOrTypeInconsistentOrRecordTooLong,
            TEXT("Either the file ID already exists in the current "
                 "directory, the file type is inconsisent with the "
                 "command or the record length is too long.")
        },
        {
            CSmartCard::ccFileIndexDoesNotExist,
            TEXT("The file index passed does not exist in the current "
                 "directory.")
        },
        {
            CSmartCard::ccFileInvalidated,
            TEXT("The command attempted to operate on an invalidated "
                 "file.")
        },
        {
            CSmartCard::ccFileNotFound,
            TEXT("The file requested for this operation was not "
                 "found.")
        },
        {
            CSmartCard::ccFileNotFoundOrNoMoreFilesInDf,
            TEXT("The file specified was not found or no more files in "
                 "the current DF.")
        },
        {
            CSmartCard::ccFileTypeInvalid,
            TEXT("File type is invalid.")
        },
        {
            CSmartCard::ccIncorrectP1P2,
            TEXT("Incorrect parameter P1 or P2.")
        },
        {
            CSmartCard::ccIncorrectP3,
            TEXT("Incorrect P3.")
        },
        {
            CSmartCard::ccInstallCannotRun,
            TEXT("Cardlet is currently selected and install cannot "
                 "run.  Default loader application must be selected.")
        },
        {
            CSmartCard::ccInstanceIdInUse,
            TEXT("Instance ID is being used by another file.")
        },
        {
            CSmartCard::ccInsufficientSpace,
            TEXT("Insufficient space available.")
        },
        {
            CSmartCard::ccInvalidAnswerReceived,
            TEXT("Invalid answer received from the card.")
        },
        {
            CSmartCard::ccInvalidKey,
            TEXT("CHV verification was unsuccessful; at least one "
                 "attempt remains.")
        },
        {
            CSmartCard::ccInvalidSignature,
            TEXT("Signature is invalid.")
        },
        {
            CSmartCard::ccJava,
            TEXT("Applet exception occured.")
        },
        {
            CSmartCard::ccKeyBlocked,
            TEXT("Key is blocked.  No attempts remain.")
        },
        {
            CSmartCard::ccLimitReached,
            TEXT("Limit has been reached.  Additional value would "
                 "exceed the record's limit.")
        },
        {
            CSmartCard::ccMemoryProblem,
            TEXT("Memory problem occured.")
        },
        {
            CSmartCard::ccNoAccess,
            TEXT("Access conditions not met.")
        },
        {
            CSmartCard::ccNoEfSelected,
            TEXT("No elementary file selected.")
        },
        {
            CSmartCard::ccNoEfExistsOrNoChvKeyDefined,
            TEXT("No EF exists, or no CHV or key defined.")
        },
        {
            CSmartCard::ccNoFileSelected,
            TEXT("No elementary file selected.")
        },
        {
            CSmartCard::ccNoGetChallengeBefore,
            TEXT("A Get Challenge was not performed before this "
                 "operation.")
        },
        {
            CSmartCard::ccOperationNotActivatedForApdu,
            TEXT("Algorithm is supported, but the operation is not "
                 "activated for this APDU.")
        },
        {
            CSmartCard::ccOutOfRangeOrRecordNotFound,
            TEXT("Out of range or record not found.")
        },
        {
            CSmartCard::ccOutOfSpaceToCreateFile,
            TEXT("Not enough space is available to create the file.")
        },
        {
            CSmartCard::ccProgramFileInvalidated,
            TEXT("Program file invalidated.")
        },
        {
            CSmartCard::ccRecordInfoIncompatible,
            TEXT("Record information is incompatible with the file "
                 "size.")
        },
        {
            CSmartCard::ccRecordLengthTooLong,
            TEXT("Record length is too long.")
        },
        {
            CSmartCard::ccRequestedAlgIdMayNotMatchKeyUse,
            TEXT("The requested algorithm ID may not match the key "
                 "used.")
        },
        {
            CSmartCard::ccReturnedDataCorrupted,
            TEXT("Data return from the card is corrupted.")
        },
        {
            CSmartCard::ccRootDirectoryNotErasable,
            TEXT("It is not valid to delete the root directory.")
        },
        {
            CSmartCard::ccTimeOut,
            TEXT("Time-out occured.")
        },
        {
            CSmartCard::ccTooMuchDataForProMode,
            TEXT("Too much data for PRO mode.")
        },
        {
            CSmartCard::ccUnknownInstructionClass,
            TEXT("Unknown instruction class.")
        },
        {
            CSmartCard::ccUnknownInstructionCode,
            TEXT("Unknown instruction code.")
        },
        {
            CSmartCard::ccUnknownStatus,
            TEXT("An unknown error status was returned from the "
                 "card.")
        },
        {
            CSmartCard::ccUnidentifiedTechnicalProblem,
            TEXT("Unidentified technical problem.")
        },
        {
            CSmartCard::ccUpdateImpossible,
            TEXT("Update is impossible.")
        },
        {
            CSmartCard::ccVerificationFailed,
            TEXT("Verification failed.")
        },
    };

} // namespace

namespace iop
{


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
CSmartCard::Exception::Exception(CauseCode cc,
                                 ClassByte cb,
                                 Instruction ins,
                                 StatusWord sw) throw()
    : scu::Exception(scu::Exception::fcSmartCard),
      m_cc(cc),
      m_cb(cb),
      m_ins(ins),
      m_sw(sw)
{}

CSmartCard::Exception::~Exception()
{}


                                                  // Operators
                                                  // Operations
scu::Exception *
CSmartCard::Exception::Clone() const
{
    return new CSmartCard::Exception(*this);
}

void
CSmartCard::Exception::Raise() const
{
    throw *this;
}

                                                  // Access
CSmartCard::Exception::CauseCode
CSmartCard::Exception::Cause() const throw()
{
    return m_cc;
}

CSmartCard::ClassByte
CSmartCard::Exception::Class() const throw()
{
    return m_cb;
}

char const *
CSmartCard::Exception::Description() const
{
    return scu::FindDescription(Cause(), ccdt, sizeof ccdt / sizeof *ccdt);
}

CSmartCard::Exception::ErrorCode
CSmartCard::Exception::Error() const throw()
{
    return m_cc;
}

CSmartCard::Instruction
CSmartCard::Exception::Ins() const throw()
{
    return m_ins;
}

CSmartCard::StatusWord
CSmartCard::Exception::Status() const throw()
{
    return m_sw;
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////// End CSmartCard::Exception ///////////////////////////

CSmartCard::CSmartCard(const SCARDHANDLE  hCardHandle,
                       const char* szReaderName,
                                           const SCARDCONTEXT hContext,
                       const DWORD dwMode)
    : m_hCard(hCardHandle),
      m_hContext(hContext),
      m_CurrentDirectory(),
      m_CurrentFile(),
      m_dwShareMode(dwMode),
      m_fSupportLogout(false),
      m_IOPLock(szReaderName),
      m_vecEvents(),
      m_dwEventCounter(0),
      m_cResponseAvailable(0),
      m_sCardName(),
      m_fDirty(false)
{
    m_IOPLock.Init(this);
    ResetSelect();
}

CSmartCard::~CSmartCard()
{
    try {
        while(m_vecEvents.size())
        {
            delete *(m_vecEvents.begin());
            m_vecEvents.erase(m_vecEvents.begin());
        }

        // Disconnect the card.
        if (m_hCard)
            SCardDisconnect(m_hCard, SCARD_LEAVE_CARD);
    }
    catch(...) {}

}


void CSmartCard::ReConnect()
{

    DWORD dwProtocol;

    HRESULT hr = SCardReconnect(m_hCard, m_dwShareMode, SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &dwProtocol);
    if (hr != SCARD_S_SUCCESS)
        throw scu::OsException(hr);

}

void CSmartCard::ResetCard()
{
//*
    CLockWrap wrap(&m_IOPLock);

    ResetSelect();

    HRESULT hResult;

    hResult = SCardBeginTransaction(m_hCard);

    // We don't apply full logic to handle error detection since
    // this was done in the CLockWrap constructor.

    if (hResult != SCARD_S_SUCCESS)
        throw scu::OsException(hResult);

    hResult = SCardEndTransaction(m_hCard,SCARD_RESET_CARD);
    if (hResult != SCARD_S_SUCCESS)
        throw scu::OsException(hResult);
//*/
}

char const *
CSmartCard::getCardName() const
{
    return m_sCardName.c_str();
}

void
CSmartCard::setCardName(char const *szName)
{
    m_sCardName = string(szName);
}

void
CSmartCard::SendCardAPDU(const BYTE bCLA, const BYTE bINS,
                         const BYTE bP1, const BYTE bP2,
                         const BYTE bLengthIn, const BYTE* bDataIn,
                         const BYTE bLengthOut, BYTE* bDataOut)
{
    CLockWrap wrap(&m_IOPLock);
    HRESULT hResult;
    DWORD   dwRecvLength;
    SecureArray<BYTE> bSW(2);
    StatusWord sw;

    //////////////////
    //  Build APDU  //
    //////////////////

    SecureArray<BYTE> aabInput(5 + bLengthIn);
    SecureArray<BYTE> aabOutput;

    aabInput[0] = bCLA;
    aabInput[1] = bINS;
    aabInput[2] = bP1;
    aabInput[3] = bP2;
    aabInput[4] = bLengthIn;

    ///////////////////////////
    //  Is data being sent?  //
    ///////////////////////////
    if (bLengthIn)
    {
        memcpy(&aabInput[5], bDataIn, bLengthIn);
        dwRecvLength = bSW.size();

        hResult = SCardTransmit(m_hCard, SCARD_PCI_T0,
                                aabInput.data(), aabInput.size(),
                                NULL, bSW.data(), &dwRecvLength);

        if (hResult != SCARD_S_SUCCESS)
        {
            DWORD dwState;
            DWORD dwProtocol;
            SecureArray<BYTE> bATR(cMaxAtrLength);
            DWORD dwATRLen = bATR.size();
            DWORD dwReaderNameLen = 0;

            HRESULT hr = SCardStatus(m_hCard, NULL,
                                     &dwReaderNameLen, &dwState,
                                     &dwProtocol, bATR.data(),
                                     &dwATRLen);
            if (hr == SCARD_W_RESET_CARD)
            {
                ResetSelect();
                ReConnect();
            }
            else
                throw scu::OsException(hr);

            hr=SCardTransmit(m_hCard, SCARD_PCI_T0,
                             aabInput.data(), aabInput.size(), NULL,
                             bSW.data(), &dwRecvLength);
            if (hr != SCARD_S_SUCCESS)
                throw scu::OsException(hr);
        }

        //////////////////////////////////////////////////////////////////////////////////
        //  Rebuffer information so registered functions may not alter data in the IOP  //
        //////////////////////////////////////////////////////////////////////////////////

        SecureArray<BYTE> aabSendData(aabInput);

        SecureArray<BYTE>  bReceiveData(bSW);

        ///////////////////////////////////////
        //  Fire event for information sent  //
        ///////////////////////////////////////

        FireEvents(0, aabSendData.size(), aabSendData.data());
        FireEvents(1, bReceiveData.size(), bReceiveData.data());

        sw = (bSW[0] * 256) + bSW[1];

        ProcessReturnStatus(bCLA, bINS, sw);

            //////////////////////////////////
            // Should we expect data back?  //
            //////////////////////////////////
        if (bLengthOut)
        {
            if (ResponseLengthAvailable())
                GetResponse(bCLA, bLengthOut, bDataOut);
            else
                throw iop::Exception(iop::ccNoResponseAvailable);
        }
    }
    //////////////////////////////
    //  Data is NOT being sent  //
    //////////////////////////////
    else
    {
        aabInput[4]   = bLengthOut;
        dwRecvLength  = bLengthOut + 2;
        aabOutput = SecureArray<BYTE>(dwRecvLength);
        aabOutput = 0; // zero out the data buffer

        hResult = SCardTransmit(m_hCard, SCARD_PCI_T0,
                                aabInput.data(), 5, NULL,
                                aabOutput.data(), &dwRecvLength);

        /////////////////////////////////////////////
        //  if card has been reset, then reconnect //
        /////////////////////////////////////////////

        if (hResult != SCARD_S_SUCCESS)
        {
            DWORD dwState;
            DWORD dwProtocol;
            SecureArray<BYTE> bATR(cMaxAtrLength);
            DWORD dwATRLen = bATR.size();
            DWORD dwReaderNameLen = 0;

            HRESULT hr = SCardStatus(m_hCard, NULL, &dwReaderNameLen, &dwState, &dwProtocol, bATR.data(), &dwATRLen);
            if (hr == SCARD_W_RESET_CARD)
            {
                ResetSelect();
                ReConnect();
            }
            else
                throw scu::OsException(hResult);

            hr=SCardTransmit(m_hCard, SCARD_PCI_T0,
                             aabInput.data(), 5, NULL,
                             aabOutput.data(), &dwRecvLength);
            if (hr != SCARD_S_SUCCESS)
                throw scu::OsException(hResult);

        }
        //////////////////////////////////////////////////////////////////////////////////
        //  Rebuffer information so registered functions may not alter data in the IOP  //
        //////////////////////////////////////////////////////////////////////////////////

        SecureArray<BYTE>  bSendData(aabInput.data(),5);
        SecureArray<BYTE> aabReceiveData(aabOutput.data(),dwRecvLength);

        ////////////////////////////////////////////////////
        //  Fire event for information sent and received  //
        ////////////////////////////////////////////////////

        FireEvents(0, bSendData.size(), bSendData.data());
        FireEvents(1, aabReceiveData.size(),
                   aabReceiveData.data());

        sw = (aabOutput[dwRecvLength - 2] * 256) +
            aabOutput[dwRecvLength - 1];

        ProcessReturnStatus(bCLA, bINS, sw);

        memcpy(bDataOut, aabOutput.data(), bLengthOut);
    }
}

void CSmartCard::RequireSelect()
{
        if ((m_CurrentDirectory.IsEmpty()) || (m_CurrentFile.IsEmpty()))
        throw iop::Exception(iop::ccNoFileSelected);
}

void
CSmartCard::GetResponse(ClassByte cb,
                        BYTE bDataLength,
                        BYTE *bDataOut)
{
    // TO DO: lock redundant??? Wouldn't GetResponse always be called
    // by a routine that establishes a lock?
    CLockWrap wrap(&m_IOPLock);

    if (0 == ResponseLengthAvailable())
        throw iop::Exception(iop::ccNoResponseAvailable);

    struct Command                                // T=0 command bytes
    {
        ClassByte m_cb;
        Instruction m_ins;
        BYTE m_bP1;
        BYTE m_bP2;
        BYTE m_bP3;
    } cmnd = { cb, insGetResponse, 0x00, 0x00, bDataLength };
    DWORD dwRecvLength = bDataLength + sizeof StatusWord;
    BYTE bOutput[cMaxGetResponseLength];

    memset(bOutput, 0, sizeof bOutput);

    HRESULT hr = SCardTransmit(m_hCard, SCARD_PCI_T0,
                               reinterpret_cast<LPCBYTE>(&cmnd),
                               sizeof cmnd, NULL, bOutput,
                               &dwRecvLength);

    if (hr != SCARD_S_SUCCESS)
        throw scu::OsException(hr);

    //////////////////////////////////////////////////////////////////////////////////
    //  Rebuffer information so registered functions may not alter data in the IOP  //
    //////////////////////////////////////////////////////////////////////////////////

    BYTE  bSendData[sizeof cmnd];
    memcpy(static_cast<void *>(bSendData),
           static_cast<void const *>(&cmnd), sizeof cmnd);
    scu::AutoArrayPtr<BYTE> aabReceiveData(new BYTE[dwRecvLength/*bDataLength + 2*/]);
        memcpy((void*)aabReceiveData.Get(), (void*)bOutput,     dwRecvLength/*bDataLength + 2*/);

    ////////////////////////////////////////////////////
    //  Fire event for information sent and received  //
    ////////////////////////////////////////////////////

    FireEvents(0, sizeof bSendData, bSendData);
    FireEvents(1, dwRecvLength/*bDataLength + 2*/, aabReceiveData.Get());

    //////////////////////////////////////////////////////////
    //  Set card's status code and map to IOP status codes  //
    //////////////////////////////////////////////////////////

    StatusWord sw = (bOutput[dwRecvLength - sizeof StatusWord]*256) +
        bOutput[dwRecvLength - (sizeof StatusWord - 1)];

    ProcessReturnStatus(cb, insGetResponse, sw);

    memcpy(bDataOut, bOutput, bDataLength);
}

void
CSmartCard::ReadBinary(const WORD wOffset,
                            const WORD wDataLength,
                            BYTE* bData)
{
    CLockWrap wrap(&m_IOPLock);

    TransferData(wOffset, wDataLength, bData, *this,
                 &CSmartCard::DoReadBlock, cMaxRwDataBlock);

}

void
CSmartCard::WriteBinary(const WORD wOffset,
                        const WORD wDataLength,
                        const BYTE* bData)
{
    CLockWrap wrap(&m_IOPLock);

    Dirty(true);
    
    //m_apSharedMarker->UpdateMarker(CMarker::WriteMarker);

    TransferData(wOffset, wDataLength, bData, *this,
                 &CSmartCard::DoWriteBlock, cMaxRwDataBlock);

}

void CSmartCard::ResetSelect()
{
        m_CurrentDirectory.Clear();
        m_CurrentFile.Clear();
}

void
CSmartCard::GetCurrentDir(char* CurrentDirectory)
{
        if (!m_CurrentDirectory.IsEmpty())
                strcpy(CurrentDirectory,m_CurrentDirectory.GetStringPath().c_str());
    else
        throw iop::Exception(ccInvalidParameter);
}

void
CSmartCard::GetCurrentFile(char* CurrentFile)
{
        if (!m_CurrentFile.IsEmpty())
                strcpy(CurrentFile,m_CurrentFile.GetStringPath().c_str());
    else
        throw iop::Exception(ccInvalidParameter);
}

DWORD CSmartCard::RegisterEvent(void (*FireEvent)(void *pToCard, int
                                                  iEventCode, DWORD
                                                  dwLen, BYTE* bData),
                                void *pToCard)
{
    EventInfo *Event = new EventInfo;
    Event->dwHandle  = ++m_dwEventCounter;
    Event->FireEvent = FireEvent;
    Event->pToCard   = pToCard;

    m_vecEvents.push_back(Event);

    return m_dwEventCounter;
}

bool CSmartCard::UnregisterEvent(DWORD dwHandle)
{
        vector<EventInfo*>::iterator iter;

    for(iter = m_vecEvents.begin(); iter != m_vecEvents.end(); iter++)
    {
        if ((*iter)->dwHandle == dwHandle)
            break;
    }

    if (iter == m_vecEvents.end())
        return false;

    delete (*iter);
    m_vecEvents.erase(iter);

    return true;
}


bool CSmartCard::HasProperty(WORD wPropNumber)
{
    if (wPropNumber > 512)
        return false;

    ////////////////////////////////////
    //  Open path to registered keys  //
    ////////////////////////////////////

    HKEY hkCardKey;
    HKEY hkTestKey;
    char szCardPath[] = "SOFTWARE\\Schlumberger\\Smart Cards and Terminals\\Smart Cards";

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCardPath, NULL, KEY_READ, &hkCardKey);

    //////////////////////////////////////////////
    //  Enumerate subkeys to find an ATR match  //
    //////////////////////////////////////////////

    FILETIME fileTime;
    char  szATR[]        = "ATR";
    char  szMask[]       = "ATR Mask";
    char  szProperties[] = "Properties";
    char  sBuffer[1024];
    BYTE  bATR[cMaxAtrLength];
    BYTE  bATRtest[cMaxAtrLength];
    BYTE  bMask[cMaxAtrLength];
    BYTE  bProperties[512];
        BYTE  bATRLength         = sizeof bATR / sizeof *bATR;
    DWORD dwBufferSize   = sizeof(sBuffer);
    DWORD dwATRSize      = sizeof bATR / sizeof *bATR;
    DWORD dwMaskSize     = sizeof bMask / sizeof *bMask;
        DWORD dwPropSize         = sizeof(bProperties);
        DWORD index                  = 0;

    getATR(bATR, bATRLength);

    LONG iRetVal = RegEnumKeyEx(hkCardKey, index, sBuffer, &dwBufferSize, NULL, NULL, NULL, &fileTime);
    while (iRetVal == ERROR_SUCCESS)
    {
        RegOpenKeyEx(hkCardKey, sBuffer, NULL, KEY_READ, &hkTestKey);

        RegQueryValueEx(hkTestKey, szATR,  NULL, NULL, bATRtest, &dwATRSize);
        RegQueryValueEx(hkTestKey, szMask, NULL, NULL, bMask,    &dwMaskSize);

        if (dwATRSize == bATRLength)
        {
            scu::AutoArrayPtr<BYTE> aabMaskedATR(new BYTE[dwATRSize]);
            for (DWORD count = 0; count < dwATRSize; count++)
                aabMaskedATR[count] = bATR[count] & bMask[count];

            if (!memcmp(aabMaskedATR.Get(), bATRtest, dwATRSize))
                break;
        }

        index++;
        dwBufferSize = sizeof(sBuffer);
        dwATRSize    = cMaxAtrLength;
        dwMaskSize   = cMaxAtrLength;
        RegCloseKey(hkTestKey);
        iRetVal = RegEnumKeyEx(hkCardKey, index, sBuffer, &dwBufferSize, NULL, NULL, NULL, &fileTime);
    }

    //  if loop was broken, iRetVal is still ERROR_SUCCESS, and type holds correct card to use
    if (iRetVal == ERROR_SUCCESS)
    {
        RegQueryValueEx(hkTestKey, szProperties, NULL, NULL, bProperties, &dwPropSize);

        return (bProperties[(wPropNumber - 1) / 8] & (1 << ((wPropNumber - 1) % 8))) ? true : false;
    }
    //  loop wasn't broken, i.e., ATR not found
    else
        return false;
}

void
CSmartCard::getATR(BYTE* bATR, BYTE& iATRLength)
{
    DWORD   dwProtocol;
    LPDWORD pcchReaderLen  = 0;
    DWORD   dwState;
    BYTE    bMyATR[cMaxAtrLength];
    DWORD   dwAtrLen = sizeof bMyATR / sizeof *bMyATR;

    HRESULT hr = SCardStatus(m_hCard, NULL, pcchReaderLen, &dwState, &dwProtocol, bMyATR, &dwAtrLen);

    if (hr == SCARD_W_RESET_CARD)
    {
        ResetSelect();
        ReConnect();
        hr = SCardStatus(m_hCard, NULL, pcchReaderLen, &dwState, &dwProtocol, bMyATR, &dwAtrLen);
    }
    if (hr != SCARD_S_SUCCESS)
        throw scu::OsException(hr);

    if ((BYTE)dwAtrLen > iATRLength)
        throw iop::Exception(ccInvalidParameter);

    memcpy(bATR, bMyATR, dwAtrLen);
    iATRLength = (BYTE)dwAtrLen;
}

void CSmartCard::FireEvents(int iEventCode, DWORD dwLength, BYTE *bsData)
{
        vector<EventInfo*>::iterator iter;

    for (iter = m_vecEvents.begin(); iter != m_vecEvents.end(); iter++)
    {
        EventInfo* pEvent = *iter;

        pEvent->FireEvent(pEvent->pToCard, iEventCode, dwLength, bsData);
    }
}



BYTE CSmartCard::FormatPath(char *szOutputPath, const char *szInputPath)
{
        bool  fResult                   = true;
        BYTE  bIndex                    = 0;
        BYTE  bFileCount                = 1;            // always allocate memory for at least 1 token
    BYTE  bFileIDLength     = 0;
        BYTE  bPathLength               = strlen(szInputPath);
    WORD  wFileHexID;
        char  szPad[]                   = "0";
    char *cTestChar;
    char *szHexID;

    //////////////////////////////////////////////
    //  Count number of tokens in desired path  //
    //////////////////////////////////////////////
    for (bIndex = 0; bIndex < bPathLength - 1; bIndex++)
    {
        if (szInputPath[bIndex] == '/' && szInputPath[bIndex + 1] != '/')
            bFileCount++;
    }


    // Check path size

    if (bFileCount * 5 + 1 > cMaxPathLength)
        throw iop::Exception(iop::ccFilePathTooLong);

    scu::AutoArrayPtr<char> aaszPathIn(new char[bPathLength + 1]);
    memset((void*)aaszPathIn.Get(), 0, bPathLength + 1);
    memset((void*)szOutputPath, 0, bFileCount * 5 + 1);
    strcpy(aaszPathIn.Get(), szInputPath);

    iop::CauseCode cc;
    szHexID = strtok(aaszPathIn.Get(), "/");
    for (bFileCount = 0; szHexID; bFileCount++, szHexID = strtok(NULL, "/"))
    {
        /////////////////////////////////////////////////////////
        //  File ID is too large -- greater than 4 characters  //
        /////////////////////////////////////////////////////////
        if (strlen(szHexID) > 4)
        {
            fResult = false;
            cc = iop::ccFileIdTooLarge;
            break;
        }

        wFileHexID = (WORD)strtoul(szHexID, &cTestChar, 16);
        /////////////////////////////////////////////////////
        //  File ID was not in hexadecimal representation  //
        /////////////////////////////////////////////////////
        if (*cTestChar != NULL)
        {
            fResult = false;
            cc = iop::ccFileIdNotHex;
            break;
        }

        szOutputPath[bFileCount * 5] = '/';
        /////////////////////////////////////////////////////////////////
        //  Pad file ID and put formatted file ID into formatted path  //
        /////////////////////////////////////////////////////////////////
        for (bFileIDLength = strlen(szHexID); bFileIDLength < 4; bFileIDLength++)
            strcat((szOutputPath + (bFileCount * 5) + (4 - bFileIDLength)), szPad);

        strcpy((szOutputPath + (bFileCount * 5) + (5 - strlen(szHexID))), szHexID);
    }

    ///////////////////////////////////////////
    //  If file ID formatting fails, throw  //
    ///////////////////////////////////////////
    if (!fResult)
    {
//              delete [] szOutputPath; // Can not mean to delete this???? HB.
        throw iop::Exception(cc);
    }

    _strupr(szOutputPath);

    return bFileCount;
}


void
CSmartCard::GetState(DWORD &rdwState,
                     DWORD &rdwProtocol)
{
    BYTE bATR[cMaxAtrLength];
    DWORD dwATRLen = sizeof bATR / sizeof *bATR;
    DWORD dwReaderNameLen = 0;

    HRESULT hr = SCardStatus(m_hCard, 0, &dwReaderNameLen, &rdwState,
                             &rdwProtocol, bATR, &dwATRLen);

    if (SCARD_W_RESET_CARD == hr)
    {
        ResetSelect();
        ReConnect();

        // try again...
        hr = SCardStatus(m_hCard, 0, &dwReaderNameLen, &rdwState,
                         &rdwProtocol, bATR, &dwATRLen);
    }

    if (SCARD_S_SUCCESS != hr)
        throw scu::OsException(hr);
}

void
CSmartCard::DefaultDispatchError(ClassByte cb,
                                 Instruction ins,
                                 StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;

    switch (sw)
    {
    case 0x6283:
        cc = ccFileInvalidated;
        break;

    case 0x6581:
        cc = ccMemoryProblem;
        break;

    case 0x6982:
        cc = ccNoAccess;
        break;

    case 0x6983:
        cc = ccKeyBlocked;
        break;

    case 0x6A80:
        cc = ccFileTypeInvalid;
        break;

    case 0x6A82:
        cc = ccFileNotFound;
        break;

    case 0x6A84:
        cc = ccInsufficientSpace;
        break;

    case 0x6B00:
        cc = ccIncorrectP1P2;
        break;

    case 0x6D00:
        cc = ccUnknownInstructionCode;
        break;

    case 0x6E00:
        cc = ccUnknownInstructionClass;
        break;

    case 0x6F00:
        cc = ccUnidentifiedTechnicalProblem;
        break;

    case 0x90FF:
        cc = ccTimeOut;
        break;

    case 0x9002:
        cc = ccInvalidAnswerReceived;
        break;

    default:
        if (0x67 == HIBYTE(sw))
            cc = ccIncorrectP3;
        else
            cc = ccUnknownStatus;
        break;
    }

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);
}

void
CSmartCard::DispatchError(ClassByte cb,
                          Instruction ins,
                          StatusWord sw) const
{
    CauseCode cc;
    bool fDoThrow = true;

    switch (ins)
    {
    case insGetResponse:
        switch (sw)
        {
        case 0x6281:
            cc = ccReturnedDataCorrupted;
            break;

        case 0x6A86:
            cc = ccIncorrectP1P2;
            break;

        default:
            if (0x6C == HIBYTE(sw))
                cc = ccIncorrectP3;
            else
                fDoThrow = false;
            break;
        }

    default:
        fDoThrow = false;
        break;
    }

    if (fDoThrow)
        throw Exception(cc, cb, ins, sw);

    DefaultDispatchError(cb, ins, sw);
}

BYTE
CSmartCard::ResponseLengthAvailable() const
{
    return m_cResponseAvailable;
}

void
CSmartCard::ResponseLengthAvailable(BYTE cResponseLength)
{
    m_cResponseAvailable = cResponseLength;
}

void
CSmartCard::WriteBlock(WORD wOffset,
                       BYTE const *pbBuffer,
                       BYTE cLength)
{
    DoWriteBlock(wOffset, pbBuffer, cLength);

    Dirty(true);
    
    //m_apSharedMarker->UpdateMarker(CMarker::WriteMarker);
}

void
CSmartCard::ProcessReturnStatus(ClassByte cb,
                                Instruction ins,
                                StatusWord sw)
{
    ResponseLengthAvailable(0);
    if (swSuccess != sw)
    {
        if (0x61 == HIBYTE(sw))
            ResponseLengthAvailable(LOBYTE(sw));
        else
            DispatchError(cb, ins, sw);
    }
}

bool
CSmartCard::Dirty() const
{
    return m_fDirty;
}

void
CSmartCard::Dirty(bool fDirty)
{
    m_fDirty = fDirty;
}


} // namespace iop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\sharedmarker.cpp ===
// SharedMarker.cpp: implementation of the CSharedMarker class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include <string>

#include <scuOsVersion.h>
#include <slbCrc32.h>

#include "iop.h"
#include "iopExc.h"
#include "SharedMarker.h"
#include "SecurityAttributes.h"

using std::string;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

namespace iop
{

CSharedMarker::CSharedMarker(string const &strName)
{
	SECURITY_ATTRIBUTES *psa = NULL;
	
#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)

    CSecurityAttributes *sa = new CSecurityAttributes;
    CIOP::InitIOPSecurityAttrs(sa);
	psa = &(sa->sa);

#endif


    // Create/open mutex that protects shared memory

    string MutexName = "SLBIOP_SHMARKER_MUTEX_" + strName;
    if (MutexName.size() >= MAX_PATH)
        throw Exception(ccSynchronizationObjectNameTooLong);
    m_hMutex = CreateMutex(psa, FALSE, MutexName.c_str());
    if (!m_hMutex)
        throw scu::OsException(GetLastError());

    // Map the shared memory, initialize if needed.

    string MappingName = "SLBIOP_SHMARKER_MAP_" + strName;
    if (MappingName.size() >= MAX_PATH)
        throw Exception(ccSynchronizationObjectNameTooLong);


    HANDLE hFile = INVALID_HANDLE_VALUE;

    Transaction foo(m_hMutex);

    m_hFileMap = CreateFileMapping(hFile,psa,PAGE_READWRITE,0,SharedMemorySize(),MappingName.c_str());
    
    if (!m_hFileMap)
        throw scu::OsException(GetLastError());
    
    bool NeedInit = false;  // Flags telling if the memory need to be initialized
	if(GetLastError()!=ERROR_ALREADY_EXISTS) NeedInit = true;

    // Assign pointers to shared memory

    m_pShMemData = (SharedMemoryData*)MapViewOfFile(m_hFileMap,FILE_MAP_WRITE,0,0,0);
    if (!m_pShMemData)
        throw scu::OsException(GetLastError());

    // Initalize shared memory if I'm the first to create it

    if (NeedInit) Initialize();
#if defined(SLBIOP_USE_SECURITY_ATTRIBUTES)

	delete sa;

#endif
}

CSharedMarker::~CSharedMarker()
{
}

CMarker CSharedMarker::Marker(CMarker::MarkerType const &Type)
{   
    const bool bRecover = true;
    if ((Type<0) || (Type>=CMarker::MaximumMarker))
        throw Exception(ccInvalidParameter);

    Transaction foo(m_hMutex);

	VerifyCheckSum(bRecover);

	return CMarker(Type,m_pShMemData->ShMemID,m_pShMemData->CounterList[Type]);
}

CMarker CSharedMarker::UpdateMarker(CMarker::MarkerType const &Type)
{
    const bool bRecover = true;
    if ((Type < 0) || (Type >= CMarker::MaximumMarker))
        throw Exception(ccInvalidParameter);

    Transaction foo(m_hMutex);

	VerifyCheckSum(bRecover);
	(m_pShMemData->CounterList[Type])++;
    UpdateCheckSum();

	return CMarker(Type,m_pShMemData->ShMemID,m_pShMemData->CounterList[Type]);
}

void CSharedMarker::Initialize()
{
    RPC_STATUS status = UuidCreate(&(m_pShMemData->ShMemID));
    if ((status!=RPC_S_OK) && (status!=RPC_S_UUID_LOCAL_ONLY))
        throw scu::OsException(status);
    for (int i=0; i<CMarker::MaximumMarker; i++)
        m_pShMemData->CounterList[i] = 1;
    UpdateCheckSum();
}

void CSharedMarker::VerifyCheckSum(bool bRecover)
{

    unsigned long ChSumLen = (unsigned char*)&m_pShMemData->CheckSum - (unsigned char*)m_pShMemData;
    if(m_pShMemData->CheckSum!=Crc32(m_pShMemData,ChSumLen)) {
        if(bRecover)
            Initialize();
        else
            throw Exception(ccInvalidChecksum);
    }
}

void CSharedMarker::UpdateCheckSum()
{
	
    unsigned long ChSumLen = (unsigned char*)&m_pShMemData->CheckSum - (unsigned char*)m_pShMemData;
    m_pShMemData->CheckSum = Crc32(m_pShMemData,ChSumLen);

}


}   // namespace iop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\unknowncard.cpp ===
// UnknownCard.cpp: implementation of the CUnknownCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "NoWarning.h"

#include "UnknownCard.h"

namespace iop
{

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUnknownCard::CUnknownCard(SCARDHANDLE hCardHandle, char* szReaderName, SCARDCONTEXT hContext, DWORD dwMode)
                    : CSmartCard(hCardHandle, szReaderName, hContext, dwMode)
{

}

CUnknownCard::~CUnknownCard()
{

}

} // namespace iop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\statusword.h ===
// StatusWord.h -- StatusWord

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(IOP_STATUSWORD_H)
#define IOP_STATUSWORD_H

namespace iop
{

enum
{
    swNull    = 0x0000,                           // special value
    swSuccess = 0x9000,
};

typedef WORD StatusWord;

} // namespace iop

#endif // IOP_STATUSWORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\unknowncard.h ===
// UnknownCard.h: interface for the CUnknownCard class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UNKNOWNCARD_H__58BC7D21_12C3_11D3_A587_00104BD32DA8__INCLUDED_)
#define AFX_UNKNOWNCARD_H__58BC7D21_12C3_11D3_A587_00104BD32DA8__INCLUDED_

#include "NoWarning.h"

#include "SmartCard.h"

namespace iop
{

const char szCardName[] = "Unknown Card";

class CUnknownCard : public CSmartCard
{
public:
    CUnknownCard(SCARDHANDLE hCardHandle, char* szReaderName, SCARDCONTEXT hContext, DWORD dwMode);
    virtual ~CUnknownCard();

    virtual const char* getCardName() const { return szCardName; };

};

} // namespace iop

#endif // !defined(AFX_UNKNOWNCARD_H__58BC7D21_12C3_11D3_A587_00104BD32DA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbiop\smartcard.h ===
// SmartCard.h: interface for the CSmartCard class.
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CSmartCard_H__INCLUDED_)
#define AFX_CSmartCard_H__INCLUDED_

#include <vector>
#include <string>
#include <memory>                                 // for auto_ptr
#include <windows.h>
#include <winscard.h>
#include <scuExc.h>
#include <scuArrayP.h>
#include "iopExc.h"
#include "iopPubBlob.h"
#include "iopPriBlob.h"
#include "IOPLock.h"
#include "SharedMarker.h"
#include "Marker.h"
#include "FilePath.h"

#include "DllSymDefn.h"

/////////////////////////
//  MACRO DEFINITIONS  //
/////////////////////////
// only compile these for the iopdll project
#ifdef IOPDLL_EXPORTS

#define LSB(a)			(BYTE)((a)%256)
#define MSB(a)			(BYTE)((a)/256)

#endif //IOPDLL_EXPORTS
/////////////////////////////
//  END MACRO DEFINITIONS  //
/////////////////////////////

namespace iop
{

enum FileType

{
    directory,
    Binary_File,
    Cyclic_File,
    Variable_Record_File,
    Fixed_Record_File,
    Instance,
    Program_File,
    Unknown
};

typedef IOPDLL_API struct 
{
    WORD			file_size;			// Size of the file / remaining space in directory
    WORD			file_id;			// Logical file Id of the DF
	FileType		file_type;			// Type of the file   
    BYTE            file_status;		// Validated == 1 or Invalidated == 0
    BYTE            nb_sub_dir;			// Nuber of sub-directory/ record_length        
    BYTE            nb_file;			// Number of EF files in dir/ nb of records     
    BYTE			access_cond[8];		// Access condition matrix 
	BYTE			applicationID[16];	// AID of cyberflex application files
	BYTE			AIDLength;			// length in bytes of the application ID
	BYTE			CryptoflexACL[7];	// A Cryptoflex ACL.
}   FILE_HEADER;

enum IOPDLL_API KeyType       {ktRSA512 = 1, ktRSA768 = 2, ktRSA1024 = 3, ktDES = 0};
enum IOPDLL_API CardOperation {coEncryption, coDecryption, coKeyGeneration};

typedef struct
{
	DWORD dwHandle;
	void (*FireEvent)(void *pToCard, int iEventCode, DWORD dwLen, BYTE* bData);	
	void *pToCard;
}	EventInfo;

// Instantiate the templates so they will be properly accessible
// as data members to the exported class CSmartCard in the DLL.  See
// MSDN Knowledge Base Article Q168958 for more information.

#pragma warning(push)
//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API std::auto_ptr<CSharedMarker>;
IOPDLL_EXPIMP_TEMPLATE template class IOPDLL_API std::vector<EventInfo *>;

#pragma warning(pop)

class IOPDLL_API CSmartCard  
{
	public:
        typedef BYTE ClassByte;
        typedef BYTE Instruction;

        enum 
        {
            cMaxAtrLength = 32,
        };

        enum
        {
            swSuccess = 0x9000,
        };
        typedef WORD StatusWord;

        enum CauseCode
        {
            ccAccessConditionsNotMet,
            ccAlgorithmIdNotSupported,
            ccAskRandomNotLastApdu,
            ccAuthenticationFailed,
            ccBadFilePath,
            ccBadState,
            ccCannotReadOutsideFileBoundaries,
            ccCannotWriteOutsideFileBoundaries,
            ccCardletNotInRegisteredState,
            ccChvNotInitialized,
            ccChvVerificationFailedMoreAttempts,
            ccContradictionWithInvalidationStatus,
            ccCurrentDirectoryIsNotSelected,
            ccDataPossiblyCorrupted,
            ccDefaultLoaderNotSelected,
            ccDirectoryNotEmpty,
            ccFileAlreadyInvalidated,
            ccFileExists,
            ccFileIdExistsOrTypeInconsistentOrRecordTooLong,
            ccFileIndexDoesNotExist,
            ccFileInvalidated,
            ccFileNotFound,
            ccFileNotFoundOrNoMoreFilesInDf,
            ccFileTypeInvalid,
            ccIncorrectKey,
            ccIncorrectP1P2,
            ccIncorrectP3,
            ccInstallCannotRun,
            ccInstanceIdInUse,
            ccInsufficientSpace,
            ccInvalidAnswerReceived,
            ccInvalidKey,
            ccInvalidSignature,
            ccJava,
            ccKeyBlocked,
            ccLimitReached,
            ccMemoryProblem,
            ccNoAccess,
            ccNoEfSelected,
            ccNoEfExistsOrNoChvKeyDefined,
            ccNoFileSelected,
            ccNoGetChallengeBefore,
            ccOperationNotActivatedForApdu,
            ccOutOfRangeOrRecordNotFound,
            ccOutOfSpaceToCreateFile,
            ccProgramFileInvalidated,
            ccRecordInfoIncompatible,
            ccRecordLengthTooLong,
            ccRequestedAlgIdMayNotMatchKeyUse,
            ccReturnedDataCorrupted,
            ccRootDirectoryNotErasable,
            ccTimeOut,
            ccTooMuchDataForProMode,
            ccUnknownInstructionClass,
            ccUnknownInstructionCode,
            ccUnknownStatus,
            ccUnidentifiedTechnicalProblem,
            ccUpdateImpossible,
            ccVerificationFailed,
        };

        // Note: scu::ExcTemplate isn't used here because of problems
        // getting the DLL to compile and link properly.  Instead, the
        // Exception class inherits directly from scu::Exception and
        // fills in what ExcTemplate provides to complete the implementation.
        class IOPDLL_API Exception
            : public scu::Exception
        {
        public:
                                                  // Types
            typedef Exception::CauseCode CauseCode;
            
                                                  // C'tors/D'tors
            Exception(CauseCode cc,
                      ClassByte cb,
                      Instruction ins,
                      StatusWord sw) throw();

            virtual
            ~Exception() throw();
    
                                                  // Operators
                                                  // Operations
            virtual scu::Exception *
            Clone() const;

            virtual void
            Raise() const;

                                                  // Access
            CauseCode
            Cause() const throw();
            
            ClassByte
            Class() const throw();

            char const *
            Description() const;
            
            ErrorCode
            Error() const throw();
            
            Instruction
            Ins() const throw();
            
            StatusWord
            Status() const throw();

    
    
                                                  // Predicates

        protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

        private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
            CauseCode m_cc;
            ClassByte m_cb;
            Instruction m_ins;
            StatusWord m_sw;
        };

        CSmartCard(const SCARDHANDLE  hCardHandle,
                   const char* szReader, 
			       const SCARDCONTEXT hContext,
                   const DWORD dwMode);
		
        virtual ~CSmartCard();
        void ReConnect();
        void ResetCard();

        void SendCardAPDU(const BYTE bCLA,		 const BYTE bINS,	   const BYTE bP1,  
						  const BYTE bP2,		 const BYTE bLenghtIn, const BYTE* bDataIn,
						  const BYTE bLengthOut, BYTE* bDataOut);

		void getATR(BYTE* bATR, BYTE& iATRLength);

        virtual void DeleteFile(const WORD wFileID)
            { throw iop::Exception(ccNotImplemented); };
    
		virtual void CreateFile(const FILE_HEADER* pMyFile) 
            { throw iop::Exception(ccNotImplemented); };
	    virtual void SelectParent()
            { throw iop::Exception(ccNotImplemented); };
		virtual void SelectCardlet(const BYTE *bAID,
                                   const BYTE bAIDLen)
            { throw iop::Exception(ccNotImplemented); };

		virtual void SelectLoader()
            { throw iop::Exception(ccNotImplemented); };
        void ResetSelect();
        
		virtual void GetSerial(BYTE* bSerial, size_t &SerialLength)
			{ throw iop::Exception(ccNotImplemented); };
		virtual void DeleteApplet()
            { throw iop::Exception(ccNotImplemented); };
		virtual void ResetInstance()
            { throw iop::Exception(ccNotImplemented); };
		virtual void SetCurrentAsLoader()
            { throw iop::Exception(ccNotImplemented); };
		virtual void SetDefaultAsLoader()
            { throw iop::Exception(ccNotImplemented); };
		virtual void BlockApplet()
            { throw iop::Exception(ccNotImplemented); };

		virtual void ValidateProgram(const BYTE *bSig,
                                     const BYTE bSigLength)
            { throw iop::Exception(ccNotImplemented); };

		virtual void ResetProgram()
            { throw iop::Exception(ccNotImplemented); };

		virtual void GetACL(BYTE *bData)
			{ throw iop::Exception(ccNotImplemented); };
		


		virtual void ExecuteMain()
            { throw iop::Exception(ccNotImplemented); };
		virtual void ExecuteInstall(const BYTE *bBlock,
                                    const BYTE bLen)
            { throw iop::Exception(ccNotImplemented); };

		virtual void Directory  (const BYTE  bFile_Nb,
                                 FILE_HEADER* pMyFile)
            { throw iop::Exception(ccNotImplemented); };
		virtual void Select	    (const char* szFileFullPath,
                                 FILE_HEADER* pMyFile = NULL, 
							     const bool  fSelectAll = false)
            { throw iop::Exception(ccNotImplemented); };
        virtual void GetResponse(ClassByte cb, const BYTE  bDataLength,
                                 BYTE* bDataOut);
        virtual void ReadBinary (const WORD wOffset,
                                 const WORD wDataLength,
                                 BYTE* bDATA);
        virtual void WriteBinary(const WORD wOffset,
                                 const WORD wDataLength,
                                 const BYTE* bDATA);

        virtual void ReadRecord(const BYTE bRecNum, const BYTE bMode,
                                const BYTE bDataLen, BYTE *bData)
            { throw iop::Exception(ccNotImplemented); };
        virtual void UpdateRecord(const BYTE bRecNum, const BYTE
                                  bMode, const BYTE bDataLen,
                                  BYTE *bData)
            { throw iop::Exception(ccNotImplemented); };

        virtual void VerifyKey  (const BYTE bKeyNumber,
                                 const BYTE bKeyLength, const BYTE* bKey)
            { throw iop::Exception(ccNotImplemented); };
    
        virtual void VerifyCHV  (const BYTE bCHVNumber,
                                 const BYTE* bCHV)
            { throw iop::Exception(ccNotImplemented); };
		virtual void VerifyTransportKey(const BYTE *bKey)
            { throw iop::Exception(ccNotImplemented); };

        virtual void GetChallenge(const DWORD dwNumberLength,
                                  BYTE* bRandomNumber)
            { throw iop::Exception(ccNotImplemented); };
        virtual void ExternalAuth(const KeyType kt, const BYTE  bKeyNb, 
								  const BYTE bDataLength,
                                  const BYTE* bData)
            { throw iop::Exception(ccNotImplemented); };
        virtual void InternalAuth(const KeyType kt, const BYTE bKeyNb,
								  const BYTE bDataLength,
                                  const BYTE* bDataIn,
                                  BYTE* bDataOut)
            { throw iop::Exception(ccNotImplemented); };

		virtual void ReadPublicKey  (CPublicKeyBlob *aKey,
                                     const BYTE bKeyNum)
            { throw iop::Exception(ccNotImplemented); };
        virtual void WritePublicKey (const CPublicKeyBlob aKey,
                                     const BYTE bKeyNum)
            { throw iop::Exception(ccNotImplemented); };
        virtual void WritePrivateKey(const CPrivateKeyBlob aKey,
                                     const BYTE bKeyNum)
            { throw iop::Exception(ccNotImplemented); };
		
        virtual CPublicKeyBlob GenerateKeyPair(const BYTE *bpPublExp,
                                               const WORD wPublExpLen,
                                               const BYTE bKeyNum,
                                               const KeyType kt)
            { throw iop::Exception(ccNotImplemented); }

		virtual void ChangeACL		   (const BYTE *bACL)
            { throw iop::Exception(ccNotImplemented); };
		virtual void ChangeCHV		   (const BYTE bKey_nb,
                                        const BYTE *bOldCHV,
                                        const BYTE *bNewCHV)
            { throw iop::Exception(ccNotImplemented); };
        virtual void ChangeCHV         (const BYTE bKey_nb,
                                        const BYTE *bNewCHV)
            { throw iop::Exception(ccNotImplemented); };
		virtual void UnblockCHV        (const BYTE bKey_nb, const BYTE
                                        *bUnblockPIN,
                                        const BYTE *bNewPin)
            { throw iop::Exception(ccNotImplemented); };
    
		virtual void ChangeUnblockKey  (const BYTE bKey_nb,
                                        const BYTE *bNewPIN)
            { throw iop::Exception(ccNotImplemented); };
		virtual void ChangeTransportKey(const BYTE *bNewKey)
            { throw iop::Exception(ccNotImplemented); };
		virtual void LogoutAll()
            { throw iop::Exception(ccNotImplemented); };
		
		void GetCurrentDir (char*);
        void GetCurrentFile(char*);
		char const *getCardName() const;
		void setCardName(char const *);

		DWORD RegisterEvent(void (*FireEvent)(void *pToCard, int iEventCode, DWORD dwLen, BYTE* bData), void *pToCard);
		bool  UnregisterEvent(DWORD dwHandle);

		bool  HasProperty(WORD wPropNumber);

		CIOPLock* Lock() { return &m_IOPLock; };

		void FireEvents(int iEventCode, DWORD dwLength, BYTE* bsData);

		SCARDHANDLE getCardHandle() { return m_hCard; };		

        void
        GetState(DWORD &rdwState,
                 DWORD &rdwProtocol);
        bool
        Dirty() const;

        void
        Dirty(bool);
    

    protected:		
        enum                                      // size_t/counter
        {
            cMaxApduLength        = 255,
            cMaxRwDataBlock       = /*cMaxApduLength*/ 160 /*until SCM fixes their reader*/,
            cMaxGetResponseLength = cMaxApduLength + sizeof StatusWord,

            cMaxPathLength        = 1024,
        };

        enum                                      // Instruction
        {
            insCreateFile   = 0xE0,
            insGetResponse  = 0xC0,
            insInternalAuth = 0x88,
            insReadBinary   = 0xB0,
            insUpdateBinary = 0xD6,
            insVerifyChv    = 0x20,
        };
    
        virtual void
        DefaultDispatchError(ClassByte cb,
                             Instruction ins,
                             StatusWord sw) const;

        virtual void
        DispatchError(ClassByte cb,
                      Instruction ins,
                      StatusWord sw) const;

        virtual void
        DoReadBlock(WORD wOffset,
                    BYTE *pbBuffer,
                    BYTE bLength) = 0;

        virtual void
        DoWriteBlock(WORD wOffset,
                     BYTE const *pbBuffer,
                     BYTE cLength) = 0;
        virtual bool
        SupportLogout() = 0;
    
        BYTE
        ResponseLengthAvailable() const;

        void
        ResponseLengthAvailable(BYTE cResponseLength);
        
		BYTE FormatPath(char *szOutputPath, const char *szInputPath);
		
		void RequireSelect();

		SCARDHANDLE  m_hCard;
		SCARDCONTEXT m_hContext;  

		
		FilePath	m_CurrentDirectory;
		FilePath	m_CurrentFile;

		DWORD		 m_dwShareMode;
        bool         m_fSupportLogout;

		CIOPLock m_IOPLock;

        bool         m_fDirty;  

	private:

        void
        ProcessReturnStatus(ClassByte cb,
                            Instruction ins,
                            StatusWord sw);
    
        void
        WriteBlock(WORD wOffset,
                   BYTE const *pbBuffer,
                   BYTE cLength);
    
		std::vector<EventInfo*> m_vecEvents;
		DWORD m_dwEventCounter;
        BYTE m_cResponseAvailable;
		std::string m_sCardName;
};

} // namespace iop

#endif // !defined(AFX_CSmartCard_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbmodver\autobuildcount.h ===
// 38
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 38
#define BUILDCOUNT_STR "38"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbmodver\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
/*
#ifndef _WIN32_WINNT
        #define _WIN32_WINNT            0x0400
#endif
*/

#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

/*
#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT
*/
// Include the template class(s)
#include <afxtempl.h>
#include <afxmt.h>


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>                      // MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>                     // MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>                     // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbmodver\modver.cpp ===
////////////////////////////////////////////////////////////////
// 1998 Microsoft Systems Journal
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// CModuleVersion provides an easy way to get version info
// for a module.(DLL or EXE).
//
// This code appeard in April 1998 edition of Microsoft Systems
// Journal.
//
// 27-July-1998 -- Adapted by James A. McLaughiln (Schlumberger
// Technology Corp.) for Smart Cards.  Merged with the concepts from
// CFileVersion class contributed by Manuel Laflamme on a posting to
// www.codeguru.com.  If these mods don't work, then you can blame me.

#include "StdAfx.h"
#include "slbModVer.h"

CModuleVersion::CModuleVersion()
    : m_pVersionInfo(NULL)
{
}

//////////////////
// Destroy: delete version info
//
CModuleVersion::~CModuleVersion()
{
    delete [] m_pVersionInfo;
}

BOOL CModuleVersion::GetFileVersionInfo(LPCTSTR modulename)
{
    // get module handle
    HMODULE hModule = ::GetModuleHandle(modulename);
    if (hModule==NULL && modulename!=NULL)
        return FALSE;

    return GetFileVersionInfo(hModule);
}

//////////////////
// Get file version info for a given module
// Allocates storage for all info, fills "this" with
// VS_FIXEDFILEINFO, and sets codepage.
//
BOOL CModuleVersion::GetFileVersionInfo(HMODULE hModule)
{
    m_translation.charset = 1252;               // default = ANSI code page
    memset((VS_FIXEDFILEINFO*)this, 0, sizeof(VS_FIXEDFILEINFO));

    // get module file name
    TCHAR filename[_MAX_PATH+1];// Space for null termination
    DWORD len = GetModuleFileName(hModule, filename,
        sizeof(filename)/sizeof(filename[0]));
    if (len <= 0)
        return FALSE;

    // Zero terminate buffer.
    if(len <=_MAX_PATH)
        filename[len] = 0;
    else
        filename[_MAX_PATH] = 0;

    // read file version info
    DWORD dwDummyHandle; // will always be set to zero
    len = GetFileVersionInfoSize(filename, &dwDummyHandle);
    if (len <= 0)
        return FALSE;

    m_pVersionInfo = new BYTE[len]; // allocate version info
    if (!::GetFileVersionInfo(filename, 0, len, m_pVersionInfo))
        return FALSE;

    // copy fixed info to myself, which am derived from VS_FIXEDFILEINFO
    if (!GetFixedInfo(*(VS_FIXEDFILEINFO*)this))
        return FALSE;

    // Get translation info
    LPVOID lpvi;
    UINT iLen;
    if (VerQueryValue(m_pVersionInfo,
        TEXT("\\VarFileInfo\\Translation"), &lpvi, &iLen) && iLen >= 4) {
        m_translation = *(TRANSLATION*)lpvi;
        TRACE(TEXT("code page = %d\n"), m_translation.charset);
    }

    return dwSignature == VS_FFI_SIGNATURE;
}

//////////////////
// Get string file info.
// Key name is something like "CompanyName".
// returns the value as a CString.
//
CString CModuleVersion::GetValue(LPCTSTR lpKeyName)
{
    CString sVal;
    if (m_pVersionInfo) {

        // To get a string value must pass query in the form
        //
        //    "\StringFileInfo\<langID><codepage>\keyname"
        //
        // where <lang-codepage> is the languageID concatenated with the
        // code page, in hex. Wow.
        //
        CString query;
        query.Format(_T("\\StringFileInfo\\%04x%04x\\%s"),
            m_translation.langID,
            m_translation.charset,
            lpKeyName);

        LPCTSTR pVal;
        UINT iLenVal;
        if (VerQueryValue(m_pVersionInfo, (LPTSTR)(LPCTSTR)query,
                (LPVOID*)&pVal, &iLenVal)) {

            sVal = pVal;
        }
    }
    return sVal;
}

// typedef for DllGetVersion proc
typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

/////////////////
// Get DLL Version by calling DLL's DllGetVersion proc
//
BOOL CModuleVersion::DllGetVersion(LPCTSTR modulename, DLLVERSIONINFO& dvi)
{
    HINSTANCE hinst = LoadLibrary(modulename);
    if (!hinst)
        return FALSE;

    // Must use GetProcAddress because the DLL might not implement
    // DllGetVersion. Depending upon the DLL, the lack of implementation of the
    // function may be a version marker in itself.
    //
    DLLGETVERSIONPROC pDllGetVersion =
        (DLLGETVERSIONPROC)GetProcAddress(hinst, reinterpret_cast<const char *>(_T("DllGetVersion")));

    if (!pDllGetVersion)
        return FALSE;

        memset(&dvi, 0, sizeof(dvi));                    // clear
        dvi.cbSize = sizeof(dvi);                                // set size for Windows

    return SUCCEEDED((*pDllGetVersion)(&dvi));
}

BOOL CModuleVersion::GetFixedInfo(VS_FIXEDFILEINFO& vsffi)
{
    // Must furst call GetFileVersionInfo or constructor with arg
    ASSERT(m_pVersionInfo != NULL);
    if ( m_pVersionInfo == NULL )
        return FALSE;

    UINT nQuerySize;
    VS_FIXEDFILEINFO* pVsffi;
    if ( ::VerQueryValue((void **)m_pVersionInfo, _T("\\"),
                         (void**)&pVsffi, &nQuerySize) )
    {
        vsffi = *pVsffi;
        return TRUE;
    }

    return FALSE;
}

CString CModuleVersion::GetFixedFileVersion()
{
    CString strVersion;
    VS_FIXEDFILEINFO vsffi;

    if (GetFixedInfo(vsffi))
    {
        strVersion.Format (_T("%u,%u,%u,%u"),HIWORD(dwFileVersionMS),
            LOWORD(dwFileVersionMS),
            HIWORD(dwFileVersionLS),
            LOWORD(dwFileVersionLS));
    }
    return strVersion;
}

CString CModuleVersion::GetFixedProductVersion()
{
    CString strVersion;
    VS_FIXEDFILEINFO vsffi;

    if (GetFixedInfo(vsffi))
    {
        strVersion.Format (_T("%u,%u,%u,%u"), HIWORD(dwProductVersionMS),
            LOWORD(dwProductVersionMS),
            HIWORD(dwProductVersionLS),
            LOWORD(dwProductVersionLS));
    }
    return strVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\autobuildcount.h ===
// 4
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 4
#define BUILDCOUNT_STR "4"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbmodver\slbmodver.h ===
////////////////////////////////////////////////////////////////
// 1998 Microsoft Systems Journal
//
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// This code appeard in April 1998 edition of Microsoft Systems
// Journal.
//
// 27-July-1998 -- Adapted by James A. McLaughiln (Schlumberger
// Technology Corp.) for Smart Cards.  Merged with the concepts from
// CFileVersion class contributed by Manuel Laflamme on a posting to
// www.codeguru.com.  If these mods don't work, then you can blame me.

#ifndef SLBMODVER_H
#define SLBMODVER_H

// tell linker to link with version.lib for VerQueryValue, etc.
#pragma comment(linker, "/defaultlib:version.lib")

#ifndef DLLVERSIONINFO
// following is from shlwapi.h, in November 1997 release of the Windows SDK

typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#endif // DLLVERSIONINFO



//////////////////
// CModuleVersion version info about a module.
// To use:
//
// CModuleVersion ver
// if (ver.GetFileVersionInfo("_T("mymodule))) {
//              // info is in ver, you can call GetValue to get variable info like
//              CString s = ver.GetValue(_T("CompanyName"));
// }
//
// You can also call the static fn DllGetVersion to get DLLVERSIONINFO.
//
class CModuleVersion : public VS_FIXEDFILEINFO {
protected:
    BYTE* m_pVersionInfo;   // all version info

    struct TRANSLATION {
                WORD langID;                    // language ID
                WORD charset;                   // character set (code page)
    } m_translation;

public:
    CModuleVersion();
    virtual ~CModuleVersion();

    BOOL GetFileVersionInfo(LPCTSTR modulename);
    BOOL GetFileVersionInfo(HMODULE hModule);
    CString GetValue(LPCTSTR lpKeyName);
    static BOOL DllGetVersion(LPCTSTR modulename, DLLVERSIONINFO& dvi);

    BOOL GetFixedInfo(VS_FIXEDFILEINFO& vsffi);

    CString GetFileDescription()  {return GetValue(_T("FileDescription")); };
    CString GetFileVersion()      {return GetValue(_T("FileVersion"));     };
    CString GetInternalName()     {return GetValue(_T("InternalName"));    };
    CString GetCompanyName()      {return GetValue(_T("CompanyName"));     };
    CString GetLegalCopyright()   {return GetValue(_T("LegalCopyright"));  };
    CString GetOriginalFilename() {return GetValue(_T("OriginalFilename"));};
    CString GetProductName()      {return GetValue(_T("ProductName"));     };
    CString GetProductVersion()   {return GetValue(_T("ProductVersion"));  };

    CString GetFixedFileVersion();
    CString GetFixedProductVersion();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\pkiexc.h ===
// pkiExc.h -- PKI Exception class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(PKI_EXC_H)
#define PKI_EXC_H

#include "scuExc.h"

namespace pki
{

enum CauseCode
{
    ccBERDataLengthOverflow,
    ccBEREmptyOctet,
    ccBERInconsistentDataLength,
    ccBEROIDSubIdentifierOverflow,
    ccBERTagValueOverflow,
    ccBERUnexpectedEndOfOctet,
    ccBERUnexpectedIndefiniteLength,
    ccX509CertExtensionNotPresent,
    ccX509CertFormatError,

};

typedef scu::ExcTemplate<scu::Exception::fcPKI, CauseCode> Exception;

///////////////////////////    HELPERS    /////////////////////////////////
char const *
Description(Exception const &rExc);

} // namespace pki

inline char const *
pki::Exception::Description() const
{
    return pki::Description(*this);
}

#endif // PKI_EXC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\pkiberoctet.h ===
// pkiBEROctet.h - Interface to BEROctet class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////////
#ifndef SLBPKI_BEROCTET_H
#define SLBPKI_BEROCTET_H

#if defined(WIN32)
#pragma warning(disable : 4786) // Suppress VC++ warnings
#endif

#include <string>
#include <vector>

#include "pkiExc.h"

namespace pki {

class BEROctet
{

public:
    BEROctet();
    BEROctet(const BEROctet &oct);
    BEROctet(const unsigned char *buffer, const unsigned long length);
    ~BEROctet();
    BEROctet& operator=(const BEROctet &oct);

    unsigned char *Octet() const;
    unsigned long OctetSize() const;

    bool Constructed() const;

    unsigned long Class() const;
    unsigned long Tag() const;
    unsigned char *Data() const;
    unsigned long DataSize() const;

    std::vector<BEROctet*> SubOctetList() const;

    std::string ObjectID() const;
    void SearchOID(std::string const &OID, std::vector<BEROctet const*> &result) const;
    void SearchOIDNext(std::string const &OID, std::vector<BEROctet const*> &result) const;

private:
    void Decode();

    unsigned char *m_Octet;     // Full octet buffer
    unsigned long m_OctetSize;  // Size of octet buffer
    unsigned long m_Class;
    unsigned long m_PrimConst;
    unsigned long m_Tag;
    unsigned char *m_Data;      // Start of data part of octet
    unsigned long m_DataSize;   // Size of data part of octet as decoded from data.
    std::vector<BEROctet*> m_SubOctetList;

};

} // namespace pki

#endif // SLBPKI_BEROCTET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\beroctet.cpp ===
// BEROctet.cpp - Implementation of BEROctet class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#include "pkiBEROctet.h"

using namespace pki;

BEROctet::BEROctet() : m_Octet(0)
{
}

BEROctet::BEROctet(const BEROctet &oct)
{
    m_Octet = 0;
    *this = oct;
}

BEROctet::BEROctet(const unsigned char *Buffer, const unsigned long Size)
{
    m_Octet = new unsigned char[Size];
    memcpy(m_Octet,Buffer,Size);
    m_OctetSize = Size;
    Decode();
}

BEROctet::~BEROctet(void)
{
    for(int i=0; i<m_SubOctetList.size(); i++) delete m_SubOctetList[i];
    if(m_Octet) delete[] m_Octet;
}

BEROctet& BEROctet::operator=(const BEROctet &Oct)
{

    if(m_Octet) delete[] m_Octet;
    for(int i=0; i<m_SubOctetList.size(); i++) delete m_SubOctetList[i];
    m_SubOctetList.resize(0);

    if(Oct.m_Octet) {
        m_Octet = new unsigned char[Oct.m_OctetSize];
        memcpy(m_Octet,Oct.m_Octet,Oct.m_OctetSize);
        m_OctetSize = Oct.m_OctetSize;
        Decode();
    }
    else {
        m_Octet = 0;
    }

    return *this;
}

// Returns the octet data

unsigned char *BEROctet::Octet() const
{
    return m_Octet;
}


unsigned long BEROctet::OctetSize() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_OctetSize;
}

// Returns true if the octet is constructet, false otherwise

bool BEROctet::Constructed() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_PrimConst ? true : false;
}

// Returns the class of the octet

unsigned long BEROctet::Class() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_Class;
}

// Returns the tag of the octet

unsigned long BEROctet::Tag() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_Tag;
}

// Returns a the data part of the octet

unsigned char *BEROctet::Data() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_Data;
}

// Returns a the size of the data part of the octet

unsigned long BEROctet::DataSize() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_DataSize;
}

// If the octet is a constructed type, this returns list of sub-octets

std::vector<BEROctet*> BEROctet::SubOctetList() const
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    return m_SubOctetList;
}


// If the octet is an OID, this returns the decoded version, otherwise an empty string

std::string BEROctet::ObjectID() const
{


    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    std::string OID;

    if(m_Class==0 && m_Tag==6) {

        char text[40];
        unsigned long subid;
        unsigned char *c = m_Data;
        unsigned char *Last = m_Octet + m_OctetSize;
        bool First = true;

        while(c<Last) {
            subid = (*c)&0x7F;
            while((*c)&0x80) {
                c++; if(c>=Last) throw Exception(ccBERUnexpectedEndOfOctet);
                if(subid>0x01FFFFFF) throw Exception(ccBEROIDSubIdentifierOverflow);
                subid = (subid<<7) | ((*c)&0x7F);
            }
            if(First) {
                unsigned long X,Y;
                if(subid<40) X=0;
                else if(subid<80) X=1;
                else X=2;
                Y = subid-X*40;
                sprintf(text,"%d %d",X,Y);
                OID = text;
                First = false;
            }
            else {
                sprintf(text," %d",subid);
                OID += text;
            }
        c++;
        }
    }

    return OID;
}

// SearchOID returns all the constructed octets that contain a particular OID

void BEROctet::SearchOID(std::string const &OID, std::vector<BEROctet const*> &result) const
{

    for(int i=0; i<m_SubOctetList.size(); i++) {

        if(m_SubOctetList[i]->Class()==0 && m_SubOctetList[i]->Tag()==6) {
            if(OID==m_SubOctetList[i]->ObjectID()) {
                result.push_back(this);
            }
        }
        else if(m_SubOctetList[i]->Constructed()) {
            m_SubOctetList[i]->SearchOID(OID,result);
        }
    }

    return;

}

// SearchOIDNext returns all the octets following a particular OID

void BEROctet::SearchOIDNext(std::string const &OID, std::vector<BEROctet const*> &result) const
{
    for(int i=0; i<m_SubOctetList.size(); i++) {

        if(m_SubOctetList[i]->Class()==0 && m_SubOctetList[i]->Tag()==6) {
            if(OID==m_SubOctetList[i]->ObjectID()) {
                if((i+1) < m_SubOctetList.size()) result.push_back(m_SubOctetList[i+1]);
            }
        }
        else if(m_SubOctetList[i]->Constructed()) {
            m_SubOctetList[i]->SearchOIDNext(OID,result);
        }
    }

    return;

}

// Decodes recursively a BER octet.

void BEROctet::Decode()
{

    if(!m_Octet) throw Exception(ccBEREmptyOctet);

    long BufferSize = m_OctetSize;

    m_PrimConst = (m_Octet[0]>>5) & 0x1;
    m_Class = (m_Octet[0]>>6) & 0x3;
    unsigned char *c = m_Octet;
    unsigned char *Last = c + BufferSize - 1;
    m_Tag = *c & 0x1F;

    if(m_Tag>30) {
        m_Tag = 0;

        c++;
        if(c>Last) throw Exception(ccBERUnexpectedEndOfOctet);

        while (*c & 0x80) {
            m_Tag = (m_Tag << 7) | ((*c) & 0x7F);
            c++;
            if(c>Last) throw Exception(ccBERUnexpectedEndOfOctet);
        }

        if(m_Tag > 0x01FFFFFF) throw Exception(ccBERTagValueOverflow);

        m_Tag = (m_Tag << 7) | ((*c) & 0x7F);

    }

    c++;
    if(c>Last) throw Exception(ccBERUnexpectedEndOfOctet);

    long DataSize;

    if((*c)&0x80) {
        int n = (*c) & 0x7F;
        if(n) {
            DataSize = 0;
            for(int i=0; i<n; i++) {
                c++; if(c>Last) throw Exception(ccBERUnexpectedEndOfOctet);
                if(DataSize>0x007FFFFF) throw Exception(ccBERDataLengthOverflow);
                DataSize = (DataSize<<8) | (*c);
            }
        }
        else throw Exception(ccBERUnexpectedIndefiniteLength);
    }
    else DataSize = *c;

    c++;
    m_Data = c;
    m_DataSize = DataSize;
    unsigned long OctetSize = DataSize + (m_Data-m_Octet);
    if(OctetSize>BufferSize) throw Exception(ccBERInconsistentDataLength);
    m_OctetSize = OctetSize;

    for(int i=0; i<m_SubOctetList.size(); i++) delete m_SubOctetList[i];
    m_SubOctetList.resize(0);

    if(m_PrimConst) {

        // Constructed type

        unsigned char *TmpData = m_Data;
        unsigned long TmpDataSize = m_DataSize;

        while(TmpDataSize) {

            BEROctet *oct = new BEROctet(TmpData,TmpDataSize);

            m_SubOctetList.push_back(oct);

            TmpData += oct->OctetSize();
            TmpDataSize -=oct->OctetSize();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\exception.cpp ===
// pkiException.cpp -- Exception class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "scuExcHelp.h"
#include "pkiExc.h"

/////////////////////////// LOCAL/HELPER  /////////////////////////////////
namespace
{
    using namespace pki;

    scu::CauseCodeDescriptionTable<CauseCode> ccdt[] =
    {
        {
            ccBERDataLengthOverflow,
            TEXT("Data length overflow in BER octet.")
        },
        {
            ccBEREmptyOctet,
            TEXT("BER octet is empty.")
        },
        {
            ccBERInconsistentDataLength,
            TEXT("Inconsistent data length in BER octet.")
        },
        {
            ccBEROIDSubIdentifierOverflow,
            TEXT("OID subidentifier overflow in BER octet.")
        },
        {
            ccBERTagValueOverflow,
            TEXT("Tag overflow in BER octet.")
        },
        {
            ccBERUnexpectedEndOfOctet,
            TEXT("Unexpected end of BER octet encountered.")
        },
        {
            ccBERUnexpectedIndefiniteLength,
            TEXT("Unexpected instance of indefinite length in BER octet.")
        },
        {
            ccX509CertExtensionNotPresent,
            TEXT("X509 certificate extension not present.")
        },
        {
            ccX509CertFormatError,
            TEXT("Format error encountered when parsing X509 certificate.")
        },

    };
}

char const *
pki::Description(pki::Exception const &rExc)
{
    return scu::FindDescription(rExc.Cause(), ccdt,
                                sizeof ccdt / sizeof *ccdt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\pkiwinregcertstore.h ===
// pkiWinRegCertStore.h - Interface to CWinRegCertStore class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////////
#if !defined(SLBPKI_WINREGISTRY_H)
#define SLBPKI_WINREGISTRY_H

#include <wincrypt.h>
#include <string>
#include "scuArrayP.h"

namespace pki {

class CWinRegCertStore
{
public:
    CWinRegCertStore(std::string strCertStore);

    ~CWinRegCertStore();

    void StoreUserCert(std::string const &strCert, DWORD const dwKeySpec, 
                       std::string const &strContName, std::string const &strProvName,
                       std::string const &strFriendlyName);

    void StoreCACert(std::string const &strCert, std::string const &strFriendlyName);

private:
    HCERTSTORE m_hCertStore;

    CWinRegCertStore() {};

    static std::string FriendlyName(std::string const CertValue);
    static scu::AutoArrayPtr<WCHAR> ToWideChar(std::string const strChar);

};

} // namespace pki

#endif // SLBPKI_WINREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\pkix509cert.h ===
// pkiX509Cert.h - Interface to X509Cert class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////

#ifndef SLBPKI_X509CERT_H
#define SLBPKI_X509CERT_H

#if defined(WIN32)
#pragma warning(disable : 4786) // Suppress VC++ warnings
#endif

#include <string>
#include <vector>

#include "pkiBEROctet.h"

namespace pki {

class X509Cert
{

public:
    X509Cert();
    X509Cert(const X509Cert &cert);
    X509Cert(const std::string &buffer);
    X509Cert(const unsigned char *buffer, const unsigned long size);
    X509Cert& operator=(const X509Cert &cert);
    X509Cert& operator=(const std::string &buffer);

    std::string SerialNumber() const;
    std::string Issuer() const;
    std::vector<std::string> IssuerOrg() const;
    std::string Subject() const;
    std::vector<std::string> SubjectCommonName() const;
    std::string Modulus() const;
    std::string RawModulus() const;
    std::string PublicExponent() const;
    std::string RawPublicExponent() const;

    unsigned long KeyUsage() const;

private:
    pki::BEROctet m_Cert;
    pki::BEROctet m_SerialNumber;
    pki::BEROctet m_Issuer;
    pki::BEROctet m_Subject;
    pki::BEROctet m_SubjectPublicKeyInfo;
    pki::BEROctet m_Extensions;

    void Decode();

};

// Key Usage flags from X.509 spec

const unsigned long digitalSignature = 0x80000000;
const unsigned long nonRepudiation   = 0x40000000;
const unsigned long keyEncipherment  = 0x20000000;
const unsigned long dataEncipherment = 0x10000000;
const unsigned long keyAgreement     = 0x08000000;
const unsigned long keyCertSign      = 0x04000000;
const unsigned long cRLSign          = 0x02000000;
const unsigned long encipherOnly     = 0x01000000;
const unsigned long decipherOnly     = 0x00800000;

} // namespace pki

#endif /* SLBPKI_X509CERT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrccsp\autobuildcount.h ===
// 13
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 13
#define BUILDCOUNT_STR "13"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrccsp\slbrccsp.cpp ===
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "slbRcCsp.h"
static int nIgnoreMe = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\winregcertstore.cpp ===
// WinRegCertStore.cpp - Implementation of CWinRegCertStore class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include "scuOsExc.h"
#include "pkiWinRegCertStore.h"
#include "pkiX509Cert.h"

using namespace pki;
using namespace std;

CWinRegCertStore::CWinRegCertStore(string strCertStore) : m_hCertStore(0)
{

    // Open certificate store

    scu::AutoArrayPtr<WCHAR> aapWCertStore = ToWideChar(strCertStore);

    HCRYPTPROV hProv = 0;
    m_hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, hProv,
                               CERT_SYSTEM_STORE_CURRENT_USER, aapWCertStore.Get());
    if(!m_hCertStore)
        throw scu::OsException(GetLastError());

}

CWinRegCertStore::~CWinRegCertStore()
{
    try
    {
        // Close certificate store

        if(m_hCertStore)
            CertCloseStore(m_hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    catch(...) {}

}

void CWinRegCertStore::StoreUserCert(string const &strCert, DWORD const dwKeySpec,
                       string const &strContName, string const &strProvName,
                       string const &strFriendlyName)
{

    // Create cert context

    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING,(BYTE*)strCert.c_str(),strCert.size());
    if(!pCertContext)
        throw scu::OsException(GetLastError());

    // Set the cert context properties

    CRYPT_KEY_PROV_INFO KeyProvInfo;

    scu::AutoArrayPtr<WCHAR> aapWContainerName = ToWideChar(strContName);
    scu::AutoArrayPtr<WCHAR> aapWProvName      = ToWideChar(strProvName);

    KeyProvInfo.pwszContainerName = aapWContainerName.Get();
    KeyProvInfo.pwszProvName      = aapWProvName.Get();
    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
    KeyProvInfo.dwFlags           = 0;
    KeyProvInfo.cProvParam        = 0;
    KeyProvInfo.rgProvParam       = NULL;
    KeyProvInfo.dwKeySpec         = dwKeySpec;

    BOOL ok = CertSetCertificateContextProperty(pCertContext,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                0, (void *)&KeyProvInfo);
    if(!ok)
        throw scu::OsException(GetLastError());

    // Set a friendly name. If it is not specified, try to derive one

    string strFN;
    if(strFriendlyName.size())
        strFN = strFriendlyName;
    else
        strFN = FriendlyName(strCert);

    if(strFN.size()) {
        scu::AutoArrayPtr<WCHAR> aapWFriendlyName = ToWideChar(strFN);

        CRYPT_DATA_BLOB DataBlob;

        DataBlob.pbData = (BYTE*)aapWFriendlyName.Get();
        DataBlob.cbData = (wcslen(aapWFriendlyName.Get())+1)*sizeof(WCHAR);
        ok = CertSetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID,0,&DataBlob);
        if(!ok)
            throw scu::OsException(GetLastError());
    }

    // Store the certificate

    ok = CertAddCertificateContextToStore(m_hCertStore, pCertContext,
                                          CERT_STORE_ADD_REPLACE_EXISTING, NULL);
    if(!ok)
        throw scu::OsException(GetLastError());

}


void CWinRegCertStore::StoreCACert(string const &strCert, string const &strFriendlyName)
{

    // Create cert context

    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING,(BYTE*)strCert.c_str(),strCert.size());
    if(!pCertContext)
        throw scu::OsException(GetLastError());

    // Set the different Enhanced Key usage flags. On one side, one could be
    // more conservative and set fewer flags, after all the user may set
    // these afterwards. On the other side, most users will not know how to
    // to that and if the attributes are not set, various signature verifications
    // will fail..... The four below are quite common.

    BOOL ok;
    CRYPT_DATA_BLOB DataBlob;

    CERT_ENHKEY_USAGE EnKeyUsage;

    LPSTR UsageOIDs[4];
    UsageOIDs[0] = szOID_PKIX_KP_SERVER_AUTH;
    UsageOIDs[1] = szOID_PKIX_KP_CLIENT_AUTH;
    UsageOIDs[2] = szOID_PKIX_KP_CODE_SIGNING;
    UsageOIDs[3] = szOID_PKIX_KP_EMAIL_PROTECTION;

    EnKeyUsage.rgpszUsageIdentifier = UsageOIDs;
    EnKeyUsage.cUsageIdentifier = sizeof(UsageOIDs)/sizeof(*UsageOIDs);

    DWORD cbEncoded;

    // First call to find size for memory allocation

    ok = CryptEncodeObject(CRYPT_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &EnKeyUsage,NULL, &cbEncoded);
    if(!ok)
        throw scu::OsException(GetLastError());

    scu::AutoArrayPtr<BYTE> aapEncoded(new BYTE[cbEncoded]);
    ok = CryptEncodeObject(CRYPT_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &EnKeyUsage,aapEncoded.Get(), &cbEncoded);
    if(!ok)
        throw scu::OsException(GetLastError());

    DataBlob.pbData = aapEncoded.Get();
    DataBlob.cbData = cbEncoded;

    ok = CertSetCertificateContextProperty(pCertContext, CERT_ENHKEY_USAGE_PROP_ID,0,&DataBlob);
    if(!ok)
        throw scu::OsException(GetLastError());

    // Set a friendly name. If it is not specified, try to derive one

    string strFN;
    if(strFriendlyName.size())
        strFN = strFriendlyName;
    else
        strFN = FriendlyName(strCert);

    if(strFN.size()) {
        scu::AutoArrayPtr<WCHAR> aapWFriendlyName = ToWideChar(strFN);

        CRYPT_DATA_BLOB DataBlob;

        DataBlob.pbData = (BYTE*)aapWFriendlyName.Get();
        DataBlob.cbData = (wcslen(aapWFriendlyName.Get())+1)*sizeof(WCHAR);
        ok = CertSetCertificateContextProperty(pCertContext,
                                               CERT_FRIENDLY_NAME_PROP_ID,0,&DataBlob);
        if(!ok)
            throw scu::OsException(GetLastError());
    }

    // Store the certificate

    ok = CertAddCertificateContextToStore(m_hCertStore, pCertContext,
                                          CERT_STORE_ADD_NEW, NULL);
    if(!ok)
    {
        DWORD err = GetLastError();
        if(err!=CRYPT_E_EXISTS)
            throw scu::OsException(GetLastError());
    }

}

scu::AutoArrayPtr<WCHAR> CWinRegCertStore::ToWideChar(string const strChar)
{

    int nwc = MultiByteToWideChar(CP_ACP, NULL, strChar.c_str(),-1, 0, 0);
    if (0 == nwc)
        throw scu::OsException(GetLastError());

    scu::AutoArrayPtr<WCHAR> aapWChar(new WCHAR[nwc]);
    if (0 == MultiByteToWideChar(CP_ACP, NULL, strChar.c_str(),
                                     -1, aapWChar.Get(), nwc))
        throw scu::OsException(GetLastError());

    return aapWChar;

}

string CWinRegCertStore::FriendlyName(string const CertValue)
{

    string strFriendlyName;

    // Derive a friendly name for the certificate

    try
    {

        bool IsCACert = false;

        X509Cert X509CertObject(CertValue);

        try
        {
            unsigned long KeyUsage = X509CertObject.KeyUsage();
            if(KeyUsage & (keyCertSign | cRLSign)) IsCACert = true;
        }
        catch (...) {};

        if(IsCACert)
        {
            vector<string> orglist = X509CertObject.IssuerOrg();
            if(orglist.size()>0)
                strFriendlyName = orglist[0];
        }
        else
        {
            vector<string> cnlist = X509CertObject.SubjectCommonName();
            if(cnlist.size()>0)
                strFriendlyName = cnlist[0] + "'s ";

            vector<string> orglist = X509CertObject.IssuerOrg();
            if(orglist.size()>0)
                strFriendlyName += orglist[0] + " ";

            strFriendlyName += "ID";
        }
    }
    catch (...) {};

    return strFriendlyName;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrccsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slbrccsp.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbpki\x509cert.cpp ===
// X509Cert.cpp - Implementation of X509Cert class
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.


#include "pkiX509Cert.h"

using namespace pki;

X509Cert::X509Cert()
{
}

X509Cert::X509Cert(const X509Cert &cert)
{
    *this = cert;
}

X509Cert::X509Cert(const std::string &buffer)
{
    *this = buffer;
}

X509Cert::X509Cert(const unsigned char *buffer, const unsigned long size)
{
    m_Cert = BEROctet(buffer,size);
    Decode();
}

X509Cert& X509Cert::operator=(const X509Cert &cert)
{
    m_Cert = cert.m_Cert;
    Decode();

    return *this;
}

X509Cert& X509Cert::operator=(const std::string &buffer)
{
    m_Cert = BEROctet((unsigned char*)buffer.data(),buffer.size());
    Decode();

    return *this;
}

// Returns Serial Number (long) integer value.

std::string X509Cert::SerialNumber() const
{
    std::string RetVal((char*)m_SerialNumber.Data(),m_SerialNumber.DataSize());
    return RetVal;
}

// Returns whole DER string of Issuer

std::string X509Cert::Issuer() const
{
    std::string RetVal((char*)m_Issuer.Octet(),m_Issuer.OctetSize());
    return RetVal;
}

// Returns list of attributes in Issuer matching id-at-organizationName.
// List will be invalidated when object changes.

std::vector<std::string> X509Cert::IssuerOrg() const
{

    std::vector<std::string> orgNames;
    std::vector<BEROctet const*> orgOcts;

    m_Issuer.SearchOIDNext("2 5 4 10",orgOcts); // Issuer's id-at-organizationName
    
    for(long i=0; i<orgOcts.size(); i++) {
        
        std::string oName((char*)orgOcts[i]->Data(), orgOcts[i]->DataSize());
        orgNames.push_back(oName);
    }

    return orgNames;

}

// Returns whole DER string of Subject

std::string X509Cert::Subject() const
{
    std::string RetVal((char*)m_Subject.Octet(),m_Subject.OctetSize());
    return RetVal;
}

// Returns list of attributes in Subject matching id-at-commonName
// List will be invalidated when object changes.

std::vector<std::string> X509Cert::SubjectCommonName() const
{

    std::vector<std::string> cnNames;
    std::vector<BEROctet const*> cnOcts;

    m_Subject.SearchOIDNext("2 5 4 3",cnOcts); // Subject's id-at-commonName
    
    for(long i=0; i<cnOcts.size(); i++) {
        
        std::string cnName((char*)cnOcts[i]->Data(), cnOcts[i]->DataSize());
        cnNames.push_back(cnName);

    }

    return cnNames;

}

// Returns modulus from SubjectPublicKeyInfo, stripped for any leading zero(s).

std::string X509Cert::Modulus() const
{

    std::string RawMod = RawModulus();

    unsigned long i = 0;
    while(!RawMod[i] && i<RawMod.size()) i++; // Skip leading zero(s).

    return std::string(&RawMod[i],RawMod.size()-i);

}

// Returns public exponent from SubjectPublicKeyInfo, possibly with leading zero(s).

std::string X509Cert::RawModulus() const
{

    if(m_SubjectPublicKeyInfo.SubOctetList().size()!=2) throw Exception(ccX509CertFormatError);

    BEROctet PubKeyString = *(m_SubjectPublicKeyInfo.SubOctetList()[1]);

    unsigned char *KeyBlob = PubKeyString.Data();
    unsigned long KeyBlobSize = PubKeyString.DataSize();

    if(KeyBlob[0]) throw Exception(ccX509CertFormatError);   // Expect number of unused bits in 
                                                             // last octet to be zero.
    KeyBlob++;
    KeyBlobSize--;
        
    BEROctet PubKeyOct(KeyBlob,KeyBlobSize);

    if(PubKeyOct.SubOctetList().size()!=2) throw Exception(ccX509CertFormatError);

    unsigned char *Mod = PubKeyOct.SubOctetList()[0]->Data();
    unsigned long ModSize = PubKeyOct.SubOctetList()[0]->DataSize();

    return std::string((char*)Mod,ModSize);

}

// Returns public exponent from SubjectPublicKeyInfo, stripped for any leading zero(s).

std::string X509Cert::PublicExponent() const
{

    std::string RawPubExp = RawPublicExponent();

    unsigned long i = 0;
    while(!RawPubExp[i] && i<RawPubExp.size()) i++; // Skip leading zero(s).

    return std::string(&RawPubExp[i],RawPubExp.size()-i);

}
// Returns public exponent from SubjectPublicKeyInfo, possibly with leading zero(s).

std::string X509Cert::RawPublicExponent() const
{

    if(m_SubjectPublicKeyInfo.SubOctetList().size()!=2) throw Exception(ccX509CertFormatError);

    BEROctet PubKeyString = *(m_SubjectPublicKeyInfo.SubOctetList()[1]);

    unsigned char *KeyBlob = PubKeyString.Data();
    unsigned long KeyBlobSize = PubKeyString.DataSize();

    if(KeyBlob[0]) throw Exception(ccX509CertFormatError);   // Expect number of unused bits 
                                                             // in last octet to be zero.
    KeyBlob++;
    KeyBlobSize--;

    BEROctet PubKeyOct(KeyBlob,KeyBlobSize);

    if(PubKeyOct.SubOctetList().size()!=2) throw Exception(ccX509CertFormatError);

    unsigned char *PubExp = PubKeyOct.SubOctetList()[1]->Data();
    unsigned long PubExpSize = PubKeyOct.SubOctetList()[1]->DataSize();

    return std::string((char*)PubExp,PubExpSize);

}

// Returns KeyUsage attribute, left justified with most significant bit as first bit (BER convention)

unsigned long X509Cert::KeyUsage() const
{

    if(!m_Extensions.Octet()) throw Exception(ccX509CertExtensionNotPresent);

    unsigned long ReturnKeyUsage = 0;

    const unsigned char UnusedBitsMask[]  = {0xFF,0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

    std::vector<BEROctet const*> ExtensionList;

    m_Extensions.SearchOID("2 5 29 15",ExtensionList); // "Extensions" octets containing id-ce-keyUsage

    if(ExtensionList.size()!=1) throw Exception(ccX509CertExtensionNotPresent); // One and only one instance
            
    BEROctet const* Extension = ExtensionList[0];
    BEROctet* extnValue = 0;
    if(Extension->SubOctetList().size()==2) extnValue = Extension->SubOctetList()[1];  // No "critical" attribute present
    else if(Extension->SubOctetList().size()==3) extnValue = Extension->SubOctetList()[2];  // A "critical" attribute present
    else throw Exception(ccX509CertFormatError); // "Extensions" must contain either 2 or 3 octets

    unsigned char *KeyUsageBlob = extnValue->Data();
    unsigned long KeyUsageBlobSize = extnValue->DataSize();

    BEROctet KeyUsage(KeyUsageBlob,KeyUsageBlobSize);
    unsigned char *KeyUsageBitString = KeyUsage.Data();
    unsigned long KeyUsageBitStringSize = KeyUsage.DataSize();


    unsigned char UnusedBits = KeyUsageBitString[0];
    unsigned long NumBytes = KeyUsageBitStringSize-1;
    if(NumBytes>4) {
        NumBytes = 4; // Truncate to fit the ulong, should be plenty though
        UnusedBits = 0;
    }

    unsigned long Shift = 24;
    for(unsigned long i=0; i<NumBytes-1; i++) {
        ReturnKeyUsage |= (KeyUsageBitString[i+1] << Shift);
        Shift -= 8;
    }     

    ReturnKeyUsage |= ( (KeyUsageBitString[NumBytes] & UnusedBitsMask[UnusedBits]) << Shift );
    
    return ReturnKeyUsage;

}

void X509Cert::Decode()
{

    if(m_Cert.SubOctetList().size()!=3)  throw Exception(ccX509CertFormatError);

    BEROctet *tbsCert = m_Cert.SubOctetList()[0];
	unsigned long Size = tbsCert->SubOctetList().size();
    if(!Size) throw Exception(ccX509CertFormatError);

	int i = 0;
    BEROctet *first = tbsCert->SubOctetList()[i];
    if((first->Class()==2) && (first->Tag()==0)) i++;			 // Version

    if(Size < (6+i)) throw Exception(ccX509CertFormatError);

    m_SerialNumber = *(tbsCert->SubOctetList()[i]); i++;	     // SerialNumber
	i++;													     // Signature (algorithm)
    m_Issuer = *(tbsCert->SubOctetList()[i]); i++;			     // Issuer
	i++;													     // Validity
    m_Subject = *(tbsCert->SubOctetList()[i]); i++;			     // Subject
    m_SubjectPublicKeyInfo = *(tbsCert->SubOctetList()[i]);	i++; // SubjectPublicKeyInfo

    m_Extensions = BEROctet();
    while(i<Size) {
        BEROctet *oct = tbsCert->SubOctetList()[i];
        if((oct->Class()==2) && (oct->Tag()==3)) {
            m_Extensions = *oct;
            break;
        }
		i++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\autobuildcount.h ===
// 6
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 6
#define BUILDCOUNT_STR "6"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrccsp\slbrccsp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by slbRcCsp.rc
//
#define IDS_SCARDFIL_DESC               1
#define IDS_SCARDVER_DESC               2
#define IDS_SCARDMAN_DESC               3
#define IDS_SCARDATH_DESC               4
#define IDS_READERBUSY                  5
#define IDS_ENTER_16HEX                 6
#define IDS_READERINACTIVE              7
#define IDS_ENTER_8TXT                  8
#define IDS_READEREMPTY                 9
#define IDS_ADM_HEX_KEY_LEN             10
#define IDS_PINLENGTH                   11
#define IDS_ADM_TXT_KEY_LEN             12
#define IDS_PINNOMATCH                  13
#define IDS_MAX_PIN_LEN                 14
#define IDS_SIGNATURE                   15
#define IDS_PIN_VER_NO_MATCH            16
#define IDS_EXCHANGE                    17
#define IDS_MAX_UNBLOCK_LEN             18
#define IDS_WRONGCARD                   19
#define IDS_UNBLOCK_VER_NO_MATCH        20
#define IDS_ENTERPIN                    21
#define IDS_SEL_SLB_CRYPTO_CARD         22
#define IDS_ADMINISTRATOR               23
#define IDS_BAD_PIN_ENTERED             24
#define IDS_PIN_CHANGE_FAILED           25
#define IDS_PROB_READING_CARD           26
#define IDS_CARD_NOT_INIT               27
#define IDS_CONTAINER_NOT_FOUND         28
#define IDS_CONTAINER_ALREADY_EXISTS    29
#define IDS_REPLACE_CREDENTIALS         30
#define IDS_NO_KEY_GEN                  31
#define IDS_ENTER_PIN                   32
#define IDS_ENTER_MANUFACTURER_KEY      33
#define IDS_ENTER_ADMIN_KEY             34
#define IDS_PIN_CHAR_LIMIT              35
#define IDS_PIN_HEX_LIMIT               36
#define IDS_MIN_PIN_LENGTH              37
#define IDS_MIN_NEW_PIN_LENGTH          38
#define IDS_MIN_OLD_PIN_LENGTH          39
#define IDS_INS_SLB_CRYPTO_CARD         40
#define IDS_PIN_BLOCKED                 41
#define IDS_DELETE_CREDENTIALS          43
#define IDS_PIN_NONASCII                44
#define IDS_REPLACE_LOGON               45
#define IDS_PROJNAME                    100
#define IDS_CANT_INITIALIZE             101
#define IDR_SCARDSSP                    102
#define IDR_SCARDAUTH                   103
#define IDR_SCARDFILEACCESS             104
#define IDR_SCARDMANAGE                 105
#define IDR_SCARDVERIFY                 106
#define IDS_NOT_CAPI_ENABLED            107
#define IDS_READER_NOT_MATCH            108
#define IDS_CSP_NAME                    109
#define IDS_PIN_NOT_CONFORM             110
#define IDD_GETCARD                     129
#define IDD_DIALOG1                     131
#define IDD_INITCARD                    132
#define IDD_INITKEY                     133
#define IDD_LOGIN                       134
#define IDD_KEYGENERATION               135
#define IDB_BITMAP_SLBLOGO              136
#define IDD_DIALOG_INITCARD             137
#define IDD_DIALOG_MSG                  138
#define IDD_DIALOG_YESNO                139
#define IDD_DIALOG_CHANGE_PIN           141
#define IDC_MESSAGE                     1000
#define IDC_ACCOUNT                     1002
#define IDC_PASSWD1                     1003
#define IDC_PASSWD2                     1004
#define IDC_REMEMBER                    1005
#define IDC_KEYTYPE                     1006
#define IDC_PASSWORD                    1007
#define IDC_HEXCODE                     1008
#define IDC_GENPROGRESS                 1009
#define IDC_STATIC_SLBLOGO              1011
#define IDC_CHANGEPIN                   1012
#define IDC_EDIT_NEWPIN                 1013
#define IDC_EDIT_VERNEWPIN              1014
#define IDC_STATIC_NEWPIN               1015
#define IDC_STATIC_VERNEWPIN            1016
#define IDC_CHECK_HEX_CODE              1018
#define IDC_EDIT_USER_PIN               1019
#define IDC_STATIC_ADMINKEY_MSG         1020
#define IDC_EDIT_CONT_NAME              1021
#define IDC_STATIC_MSG                  1021
#define IDC_EDIT_ADMIN_KEY              1022
#define IDC_EDIT_OLDPIN                 1022
#define IDC_EDIT_UNBLOCK_PIN            1023
#define IDC_STATIC_CONFIRM_OLDPIN_LABEL 1023
#define IDC_EDIT_VERIFY_USER_PIN        1024
#define IDC_EDIT_VERIFY_UNBLOCK_PIN     1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\rcobject.cpp ===
// RCObject.cpp -- Reference counted abstract base class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include <stdexcept>                              // for over/under flow
#include "windows.h"
#include "winbase.h"
#include "slbRCObj.h"

using namespace std;
using namespace slbRefCnt;

void
RCObject::AddReference()
{
    // guard against overflow
    if (0 > InterlockedIncrement(&m_cRefCount))
        throw std::overflow_error("SLB: Reference Count overflow");
}

void
RCObject::RemoveReference()
{
    LONG count = InterlockedDecrement(&m_cRefCount);
    if (0 > count)
        throw std::overflow_error("SLB: Reference Count underflow");

    if (0 == count)
        delete this;
}

RCObject::RCObject()
    : m_cRefCount(0)
{
}

RCObject::RCObject(RCObject const&)
    : m_cRefCount(0)
{
}

RCObject::~RCObject()
{
}

RCObject &
RCObject::operator=(RCObject const&)
{
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\autobuildcount.h ===
// 32
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 32
#define BUILDCOUNT_STR "32"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\slbgrcptr.h ===
// slbGRCPtr.h -- Generic Reference counting smart pointer.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLB_GRCPTR_H)
#define SLB_GRCPTR_H

#include "slbRCComp.h"
#include "slbRCObj.h"

namespace slbRefCnt {

// template class GRCPtr -- Generic Reference Counting Pointer
//
// GRCPtr is a template class that implements a variant of the
// "Counted Pointer" idiom.  GRCPtr is a reference counting smart
// pointer-to-T object where T can be any class.  GRCPtr provides a
// "wrapper" to encapsulate reference counting of any object without
// having to modify the class of the object being referenced.  This
// would be used when you can't change the class T to be derived from
// RCObject (reference counted objects, see slbRCObject.h); otherwise
// the RCPtr template may be better (see slbRCPtr.h).
//
// C is the comparator class to use in performing the pointer
// comparison operations.  The template defaults to the
// ShallowComparator.  See slbRComp.h for more information.
//
// The template's original design was inspired by the reference
// counting idiom described by Item #29 in the book "More Effective
// C++," Scott Meyers, Addison-Wesley, 1996.
//
// CONSTRAINTS: RCPtr should not be used as a base class.
//
// CAVEATS: The client should not use the Dummy * conversion
// operator.  The definition allows smart pointer comparisons.  See
// slbRCComp.h for more information.

template<class T, typename C = ShallowComparator<T> >
class GRCPtr
{
public:
                                                  // Types

    // PrivateDummy is a helper class to support validity testing of a
    // pointer.  This class together with the conversion operator
    // PrivateDummy const *() below allows smart pointers to be tested
    // for nullness (validity tests).  In other words, comparing
    // pointers in a syntactically natural way without allowing
    // heterogeneous comparisons and that won't violate the
    // protections that RCPtr provides.  The technique is from an
    // article by Don Box in "Com Smart Pointers Also Considered
    // Harmful," 1996, C++ Report.
    //
    // CAVEAT: There is a defect in the at least with MSVC++ 6.0 where
    // constructs testing the pointer for nullness will fail to
    // compile with a error message in the Release configuration but
    // compile successfully in Debug.  For example,
    //
    // if (p) ...
    //
    // where p is an RCPtr or GRCPtr may fail to compile in the
    // Release configuration.
    //
    // CAVEAT: Although the PrivateDummy and the conversion operator
    // has public access to the pointer of the object being counted
    // (RCObject *), a C-style or reinterpret_cast cast would have to
    // be used.  As in all cases using those cast
    // constructs--programmer beware.
    //
    // DESIGN NOTE: The helper class is functionally the same as the
    // one in the RCPtr template.  In a previous release, this dummy
    // class was made into a template and shared with both RCPtr and
    // GRCPtr.  However, casual compilation tests with MSVC++ 6.0 indicate
    // compilation with a dummy local to each class resulted in
    // noticable faster compilations using a test suite.  Rather than
    // suffer repeatedly slower compilations, the helper was made
    // local to each user.
    class PrivateDummy
    {};

                                                  // Constructors/Destructors
    GRCPtr(T *pReal = 0);
    GRCPtr(GRCPtr<T, C> const &rhs);
    ~GRCPtr();
                                                  // Operators
    GRCPtr<T, C> &operator=(GRCPtr<T, C> const &rhs);

    // Not for direct client use.  This conversion operator enables
    // validity test of RGCPtr.  See the explanation of PrivateDummy
    // above.
    operator PrivateDummy const *() const
    { return reinterpret_cast<PrivateDummy *>(m_holder->m_pointee); }

                                                  // Access
    T *operator->();
    T &operator*();

private:
                                                  // Operations
    void Init();

                                                  // Variables
    struct Holder : public RCObject
    {
        ~Holder() { delete m_pointee; }

        T *m_pointee;
    };

    Holder *m_holder;

                                                  // Friends
    // The friendship is necessary to get m_pointee, since
    // using operator-> doesn't work. Curiously, a similar frienship
    // is not needed for RCPtrs.
    friend bool operator==(GRCPtr<T, C> const &lhs,
                           GRCPtr<T, C> const &rhs);
    friend bool operator!=(GRCPtr<T, C> const &lhs,
                           GRCPtr<T, C> const &rhs);
    friend bool operator<(GRCPtr<T, C> const &lhs,
                          GRCPtr<T, C> const &rhs);
    friend bool operator>(GRCPtr<T, C> const &lhs,
                          GRCPtr<T, C> const &rhs);
    friend bool operator<=(GRCPtr<T, C> const &lhs,
                           GRCPtr<T, C> const &rhs);
    friend bool operator>=(GRCPtr<T, C> const &lhs,
                           GRCPtr<T, C> const &rhs);
};

template<class T, typename C>
GRCPtr<T, C>::GRCPtr(T *pReal)
    : m_holder(new Holder)
{
    m_holder->m_pointee = pReal;
    Init();
}

template<class T, typename C>
GRCPtr<T, C>::GRCPtr(GRCPtr<T, C> const &rhs)
    : m_holder(rhs.m_holder)
{
    Init();
}

template<class T, typename C>
GRCPtr<T, C>::~GRCPtr()
{
    try
    {
        m_holder->RemoveReference();
    }

    catch (...)
    {
        // don't allow exceptions to propagate out of destructor
    }
}

template<class T, typename C>
GRCPtr<T, C> &
GRCPtr<T, C>::operator=(GRCPtr<T, C> const &rhs)
{
    if (m_holder != rhs.m_holder)
    {
        m_holder->RemoveReference();
        m_holder = rhs.m_holder;
        Init();
    }

    return *this;
}

template<class T, typename C>
T *
GRCPtr<T, C>::operator->()
{
    return m_holder->m_pointee;
}

template<class T, typename C>
T &
GRCPtr<T, C>::operator*()
{
    return *(m_holder->m_pointee);
}

template<class T, typename C>
void
GRCPtr<T, C>::Init()
{
    m_holder->AddReference();
}

template<class T, typename C>
bool
operator==(GRCPtr<T, C> const &lhs,
           GRCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.Equates(lhs.m_holder->m_pointee, rhs.m_holder->m_pointee);
}

template<class T, typename C>
bool
operator!=(GRCPtr<T, C> const &lhs,
           GRCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.Equates(lhs.m_holder->m_pointee, rhs.m_holder->m_pointee);
}

template<class T, typename C>
bool
operator<(GRCPtr<T, C> const &lhs,
          GRCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.IsLess(lhs.m_holder->m_pointee, rhs.m_holder->m_pointee);
}

template<class T, typename C>
bool
operator>(GRCPtr<T, C> const &lhs,
          GRCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.IsLess(rhs.m_holder->m_pointee, lhs.m_holder->m_pointee);
}

template<class T, typename C>
bool
operator<=(GRCPtr<T, C> const &lhs,
           GRCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.IsLess(rhs.m_holder->m_pointee, lhs.m_holder->m_pointee);
}

template<class T, typename C>
bool
operator>=(GRCPtr<T, C> const &lhs,
           GRCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.IsLess(lhs.m_holder->m_pointee, rhs.m_holder->m_pointee);
}

} // namespace

#endif // SLB_GRCPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\dllsymdefn.h ===
// DllSymDefn.h -- DLL SYMbol DEFinitioN helpers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SCU_DLLSYMDEFN_H)
#define SCU_DLLSYMDEFN_H

#if defined(SCU_IN_DLL)
#if defined(SCU_EXPORTING)
#define SCU_DLLAPI __declspec(dllexport)
#define SCU_EXPIMP_TEMPLATE
#else
#define SCU_DLLAPI __declspec(dllimport)
#define SCU_EXPIMP_TEMPLATE extern
#endif // SCU_EXPORTING
#else
#define SCU_DLLAPI
#define SCU_EXPIMP_TEMPLATE
#endif // SCU_IN_DLL

#endif // SCU_DLLSYMDEFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\slbrcobj.h ===
// slbRCObj.h -- Reference counted abstract base class

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLB_RCOBJ_H)
#define SLB_RCOBJ_H

#include "windows.h"                               // for LONG

namespace slbRefCnt {

// RCObject -- Abstract base class for reference-counted object.
//
// All objects that need to be reference counted through RCPtr should be
// derived from this class (see slbRCPtr.h for more info on RCPtr).
//
// CONSTRAINTS: Objects derived from RCObject must be allocated from
// the heap and not the stack.
//
class RCObject {
public:
                                                  // Operations
    void AddReference();
    void RemoveReference();

protected:
                                                  // Contructors/Destructors
    RCObject();
    RCObject(RCObject const &rhs);
    virtual ~RCObject() = 0;

                                                  // Operators
    RCObject &operator=(RCObject const &rhs);

private:
                                                  // Variables
    LONG m_cRefCount;
};

} // namespace

#endif // SLB_RCOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\slbrccomp.h ===
// slbRCComp.h -- Comparator helpers for reference counting smart pointer.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLB_RCCOMP_H)
#define SLB_RCCOMP_H

#include <functional>                             // for binary_function

namespace slbRefCnt {

// slbRCComp.h declares several helpers to deal with smart pointer
// testing and comparisons as if they were real pointers.
//
// Testing and comparing pointer smart pointers to one another is
// problematic.  A smart pointer (reference couting pointer)
// represents a handle to the actual (dumb) pointer of interest.
// There is no straight-forward way to compare the dumb pointers
// without allowing the clients direct access to the dump pointer and
// bypassing all the features the smart pointer is trying keep intact.
// There are solutions but they usually require constructs that aren't
// natural for pointers.
//
// The facilities defined in this header provide the primitives for
// the smart pointers to be compared in a syntactically natural way
// without allowing heterogeneous comparisons and that won't violate
// the protections the smart pointers provide.
//
// Meyers describes some of these peculiar pointer comparisons in
// Item #28 found in the book "More Effective C++," Scott Meyers,
// Addison-Wesley, 1996.

// Problem: Comparing pointer values of the smart pointers to one
// another is problematic.  A smart pointer (reference couting
// pointer) represents a handle to the actual (dumb) pointer of
// interest.  There is no straight-forward way to compare the dumb
// pointers without allowing the clients direct access to the dump
// pointer and bypassing all the features the smart pointer is trying
// keep intact.

// Solution: Provide a set of comparators, or comparison functors
// (function objects), that perform the appropriate comparisons.
// These comparators are referenced by the RCPtr and GRCPtr classes to
// carryout the pointer comparisons.
//
// An abstract Predicate struct is defined to establish the functor
// interface.  All predicates used by Comparators must be derived from
// this class.  These predicate functors are passed const versions of
// the dumb pointers the smart pointer represents.  The functor
// performs the comparison returning the bool result.  Since const
// versions of the dumb pointers are used, then exposure of the dumb
// pointer is limited.
//
// Two sets of comparators are defined which should handle most of the
// cases.  The first is a shallow comparator which compares the two
// dumb pointer values using ==.  The second is deep comparator which
// compares the objects the dumb pointers reference, testing for
// equivalence.
//
// WARNING: Using the DeepComparator, any complex object being being
// compared to another will have to define either an operator==,
// operator< or both to carry out the comparison.

// template struct Predicate -- abstract functor definition for
// elements of Comparator.
template<class T>
struct Predicate : public std::binary_function<T const *, T const *, bool>
{
public:
    result_type operator()(first_argument_type lhs,
                           second_argument_type rhs) const;
};

template<class T>
struct ShallowEquatesTester : public Predicate<T>
{
public:
    result_type operator()(first_argument_type lhs, second_argument_type rhs)
    const { return lhs == rhs; };
};

template<class T>
struct DeepEquatesTester : public Predicate<T>
{
public:
    result_type operator()(first_argument_type lhs, second_argument_type rhs)
    const { return *lhs == *rhs; };
};

template<class T>
struct ShallowLessTester : public Predicate<T>
{
public:
    result_type operator()(first_argument_type lhs, second_argument_type rhs)
    const { return lhs < rhs; };
};

template<class T>
struct DeepLessTester : public Predicate<T>
{
public:
    result_type operator()(first_argument_type lhs, second_argument_type rhs)
    const { return *lhs < *rhs; };
};

// template struct Comparator -- Aggregation of comparison predicate
// functors
//
// Comparator is a template defining the aggregation of the comparison
// functors (function objects) used by the pointer comparison
// operators ==, !=, <, >, <= and >= in the RCPtr and GRCPtr classes
// (see slbRCPtr.h and slbGRCPtr.h).  The RCPtr and GRCPtr reference
// the specified comparator to access the appropriate predicate
// functor to compare the pointer values these reference counting
// (smart) pointers represent.
//
// Two comparators are predefined.  First is ShallowComparator for
// testing relative equality.  Second is DeepComparator for testing
// relative equivalency of the pointers by calling operator== of the
// object being reference counted.
//
// The DeepComparator is provided since smart pointers can be used as
// "handles" to other "body" objects.  As such, one needs to be able
// to compare their bodies as if there was a direct reference to the
// body while maintaining syntactic integrity without exposing the
// body to the client code.
//
// CONSTRAINTS: When using DeepComparator, the body class (the
// derivation of RCObject) must have the corresponding comparison operator
// defined for that class, operator== and/or operator<.
//
// Clients may define their own comparator by deriving from Comparator
// and specifying derived class when instantiating an RCPtr or GRCPtr
// template.
template<class EquatesTester, class LessTester>
struct Comparator
{
public:
                                                  // Predicates
    EquatesTester Equates;
    LessTester IsLess;
};

// template struct ShallowComparator -- minimal set of comparison
// functors for testing equality.
template<class T>
struct ShallowComparator : public Comparator<ShallowEquatesTester<T>,
                                             ShallowLessTester<T> >
{
};

// template struct DeepComparator -- minimal set of comparison
// functors for testing equivalency.
template<class T>
struct DeepComparator : public Comparator<DeepEquatesTester<T>,
                                          DeepLessTester<T> >
{
};

} // namespace

#endif // SLB_RCCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbrefcnt\slbrcptr.h ===
// slbRCPtr.h -- Reference counting smart pointer.

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLB_RCPTR_H)
#define SLB_RCPTR_H

#include "slbRCComp.h"
#include "slbRCObj.h"

namespace slbRefCnt {

// template class RCPtr -- Reference Counting Pointer
//
// The RCPtr template implements a variant of the "Counted Pointer"
// idiom.  RCPtr is a reference counting smart pointer-to-T object
// where T must inherit from RCObject (reference counted objects, see
// slbRCObj.h).
//
// C is the comparator class to use in performing the pointer
// comparison operations, defaulting to ShallowComparator.  See
// slbRComp.h for more information.
//
// The template's original design was inspired by the reference
// counting idiom described by Item #29 in the book "More Effective
// C++," Scott Meyers, Addison-Wesley, 1996.
//
// CONTRAINTS: RCPtr can only be used for reference counting those
// objects for which you have the source because RCPtr only reference
// objects derived from RCObject.  See GRCPtr in slbGRCPtr.h for
// reference counting objects when you don't have access to the source
// of the class to reference count.
//
// RCPtr should not be used as a base class.
//
// CAVEATS: The client should not use the Dummy * conversion
// operator.  The definition allows smart pointer comparisons.  See
// slbRCComp.h for more information.

template<class T, typename C = ShallowComparator<T> >
class RCPtr
{
public:
                                                  // Types
    typedef T ValueType;

    // PrivateDummy is a helper class to support validity testing of a
    // pointer.  This class together with the conversion operator
    // PrivateDummy const *() below allows smart pointers to be tested
    // for nullness (validity tests).  In other words, comparing
    // pointers in a syntactically natural way without allowing
    // heterogeneous comparisons and that won't violate the
    // protections that RCPtr provides.  The technique is from an
    // article by Don Box in "Com Smart Pointers Also Considered
    // Harmful," 1996, C++ Report.
    //
    // CAVEAT: There is a defect in the at least with MSVC++ 6.0 where
    // constructs testing the pointer for nullness will fail to
    // compile with a error message in the Release configuration but
    // compile successfully in Debug.  For example,
    //
    // if (p) ...
    //
    // where p is an RCPtr or GRCPtr may fail to compile in the
    // Release configuration.
    //
    // CAVEAT: Although the PrivateDummy and the conversion operator
    // has public access to the pointer of the object being counted
    // (RCObject *), a C-style or reinterpret_cast cast would have to
    // be used.  As in all cases using those cast
    // constructs--programmer beware.
    //
    // DESIGN NOTE: The helper class is functionally the same as the
    // one in the RCPtr template.  In a previous release, this dummy
    // class was made into a template and shared with both RCPtr and
    // GRCPtr.  However, casual compilation tests with MSVC++ 6.0 indicate
    // compilation with a dummy local to each class resulted in
    // noticable faster compilations using a test suite.  Rather than
    // suffer repeatedly slower compilations, the helper was made
    // local to each user.

    class PrivateDummy
    {};

                                                  // Constructors/Destructors
    RCPtr(T *pReal = 0);
    RCPtr(RCPtr<T, C> const &rhs);
    ~RCPtr();

                                                  // Operators
    RCPtr<T, C> &operator=(RCPtr<T, C> const &rhs);

    // Enable validity test of RCPtr.  See the explanation in
    // slbRCComp.h.
    operator PrivateDummy const *() const
    { return reinterpret_cast<PrivateDummy *>(m_pointee); }


                                                  // Access
    T *operator->() const;
    T &operator*() const;

private:
                                                  // Operations
    void Init();

                                                  // Variables
    T *m_pointee;
};

template<class T, typename C>
RCPtr<T, C>::RCPtr(T *pReal)
    : m_pointee(pReal)
{
    Init();
}

template<class T, typename C>
RCPtr<T, C>::RCPtr(RCPtr<T, C> const &rhs)
    : m_pointee(rhs.m_pointee)
{
    Init();
}

template<class T, typename C>
RCPtr<T, C>::~RCPtr()
{
    try
    {
        if (m_pointee)
            m_pointee->RemoveReference();
    }

    catch (...)
    {
        // don't allow exceptions to propagate out of destructor
    }
}

template<class T, typename C>
RCPtr<T, C> &
RCPtr<T, C>::operator=(RCPtr<T, C> const &rhs)
{
    if (m_pointee != rhs.m_pointee)
    {
        if (m_pointee)
            m_pointee->RemoveReference();
        m_pointee = rhs.m_pointee;
        Init();
    }

    return *this;
}

template<class T, typename C>
T *
RCPtr<T, C>::operator->() const
{
    return m_pointee;
}

template<class T, typename C>
T &
RCPtr<T, C>::operator*() const
{
    return *m_pointee;
}

template<class T, typename C>
bool
operator==(RCPtr<T, C> const &lhs,
           RCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.Equates(lhs.operator->(), rhs.operator->());
}

template<class T, typename C>
bool
operator!=(RCPtr<T, C> const &lhs,
           RCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.Equates(lhs.operator->(), rhs.operator->());
}

template<class T, typename C>
bool
operator<(RCPtr<T, C> const &lhs,
          RCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.IsLess(lhs.operator->(), rhs.operator->());
}

template<class T, typename C>
bool
operator>(RCPtr<T, C> const &lhs,
          RCPtr<T, C> const &rhs)
{
    C Comp;

    return Comp.IsLess(rhs.operator->(), lhs.operator->());
}

template<class T, typename C>
bool
operator<=(RCPtr<T, C> const &lhs,
           RCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.IsLess(rhs.operator->(), lhs.operator->());
}

template<class T, typename C>
bool
operator>=(RCPtr<T, C> const &lhs,
           RCPtr<T, C> const &rhs)
{
    C Comp;

    return !Comp.IsLess(lhs.operator->(), rhs.operator->());
}

template<class T, typename C>
void
RCPtr<T, C>::Init()
{
    if (m_pointee)
        m_pointee->AddReference();
}

} // namespace

#endif // SLB_RCPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scucast.h ===
// scuCast.h -- Miscellaneous casting helpers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBSCU_CAST_H)
#define SLBSCU_CAST_H

namespace scu
{

// Use are your own risk.
template<class T, class E>
T
DownCast(E expr)
{
// For some reason, _CPPRTTI is defined when
// in Microsoft's builds which causes access
// violations later when runing, so it's commented
// out.
//#if defined(_CPPRTTI)
//#error Compiling with RTTI turned on.
//    return dynamic_cast<T>(expr);
//#else
    return static_cast<T>(expr);
//#endif
}

} // namespace

#endif // SLBSCU_CAST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\osexc.cpp ===
// OsExc.cpp -- Operating System Exception template class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "scuOsExc.h"

using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
OsException::OsException(CauseCode cc) throw()
    : ExcTemplate<Exception::fcOS, DWORD>(cc),
      m_lpDescription(0)
{}

OsException::OsException(HRESULT hr) throw()
    : ExcTemplate<Exception::fcOS, DWORD>(static_cast<DWORD>(hr)),
      m_lpDescription(0)
{}

OsException::OsException(OsException const &rhs)
    : ExcTemplate<Exception::fcOS, DWORD>(rhs),
      m_lpDescription(0) // force the copy to cache it's own description.
{}

OsException::~OsException() throw()
{
    try
    {
        if (m_lpDescription)
            LocalFree(m_lpDescription);
    }

    catch (...)
    {
    }
}

                                                  // Operators
                                                  // Operations
Exception *
OsException::Clone() const
{
    return new OsException(*this);
}

void
OsException::Raise() const
{
    throw *this;
}

                                                  // Access
char const *
OsException::Description() const
{
    if (!m_lpDescription)
    {
        // cache the description
        DWORD const dwBaseFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_IGNORE_INSERTS;
        CauseCode const cc = Cause();
        DWORD const dwLanguageId = LANG_NEUTRAL;

        DWORD cMsgLength;
        // Note: The compiler complains without the
        // reinterpret_cast<LPTSTR> even though the declarations appear
        // compatible.  Something strange in the declaration of LPTSTR and
        // LPSTR used by FormatMessageA.
        cMsgLength = FormatMessage(dwBaseFlags | FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL, cc, dwLanguageId,
                                   reinterpret_cast<LPTSTR>(&m_lpDescription),
                                   0, NULL);
        if (0 == cMsgLength)
        {
            cMsgLength = FormatMessage(dwBaseFlags |
                                       FORMAT_MESSAGE_FROM_HMODULE,
                                       GetModuleHandle(NULL), cc,
                                       dwLanguageId,
                                       reinterpret_cast<LPTSTR>(&m_lpDescription),
                                       0, NULL);
            if (0 == cMsgLength)
            {
                // if this fails, assume a message doesn't exist
                cMsgLength = FormatMessage(dwBaseFlags |
                                           FORMAT_MESSAGE_FROM_HMODULE,
                                           GetModuleHandle(TEXT("winscard")),
                                           cc, dwLanguageId,
                                           reinterpret_cast<LPTSTR>(&m_lpDescription),
                                           0, NULL);
            }
        }
    }

    return m_lpDescription;
}
                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scudbgtracer.h ===
// scuDbgTracer.h -- Debug trace helpers

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBSCU_DBGTRACE_H)
#define SLBSCU_DBGTRACE_H

#if defined(_DEBUG)

#include <stdio.h>
#include <windows.h>

#include "scuExc.h"

namespace scu
{

    inline void
    TraceRoutine(char const *szRoutineName,
                 char const *szAction)
    {
        FILE *pf = fopen("C:\\slbTrace.log", "a");
        pf = fopen("C:\\slbTrace.log", "a");
        if (pf)
        {
            fprintf(pf,
                    "Routine: %s Action: %s\n",
                    szRoutineName, szAction);
            fclose(pf);
        }
    }

    inline void
    TraceCatch(char const *szRoutineName,
               Exception const &rExc)
    {
        FILE *pf = fopen("C:\\slbTrace.log", "a");
        pf = fopen("C:\\slbTrace.log", "a");
        if (pf)
        {
            fprintf(pf,
                    "Routine: %s Action: Catching Type: scu::Exception Facility: %u Cause: %08u (0x%08x) Description %s\n",
                    szRoutineName, rExc.Facility(), rExc.Error(), rExc.Error(), rExc.Description());
            fclose(pf);
        }
    }

    inline void
    Trace(char const *szRoutineName,
          char const *szAction,
          char const *szType,
          DWORD dwValue)
    {
        FILE *pf = fopen("C:\\slbTrace.log", "a");
        pf = fopen("C:\\slbTrace.log", "a");
        if (pf)
        {
            fprintf(pf,
                    "Routine: %s Action: %s Type: %s Value: 0x%08x\n",
                    szRoutineName, szAction, szType, dwValue);
            fclose(pf);
        }
    }
}

#define SCUTRACE(RoutineName, Action, Type, dwValue) scu::Trace(RoutineName, Action, Type, (dwValue))
#define SCUTRACE_RTN(RoutineName, Action) scu::TraceRoutine(RoutineName, Action)
#define SCUTRACE_CATCH(RoutineName, rExc) scu::TraceCatch(RoutineName, rExc)
#define SCUTRACE_THROW(RoutineName, Type, dwValue) scu::Trace(RoutineName, "Throwing", Type, dwValue)
#else

#define SCUTRACE(RoutineName, Action, Type, dwValue)
#define SCUTRACE_RTN(RoutineName, Action)
#define SCUTRACE_CATCH(RoutineName, rExc)
#define SCUTRACE_THROW(RoutineName, Type, dwValue)

#endif // !defined(_DEBUG)

#endif // !defined(SLBSCU_DBGTRACE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scuarrayp.h ===
// scuArrayP.h -- implementation of AutoArrayPtr template

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SLBSCU_ARRAYP_H)
#define SLBSCU_ARRAYP_H

namespace scu
{

// AutoArrayPtr is like std::auto_ptr but for arrays.  It will
// automatically release the array resource it owns.
template<class T>
class AutoArrayPtr
{
public:
                                                  // Types
    typedef T ElementType;

                                                  // C'tors/D'tors
    explicit
    AutoArrayPtr(T *p = 0) throw()
        : m_fOwns(p != 0),
          m_p(p)
    {}

    AutoArrayPtr(AutoArrayPtr<T> const &raap) throw()
        : m_fOwns(raap.m_fOwns),
          m_p(raap.Release())
    {}

    ~AutoArrayPtr() throw()
    {
        if (m_fOwns)
            delete [] m_p;
    }

                                                  // Operators
    AutoArrayPtr<T> &
    operator=(AutoArrayPtr<T> const &rhs) throw()
    {
        if (&rhs != this)
        {
            if (rhs.Get() != m_p)
            {
                if (m_fOwns)
                    delete [] m_p;
                m_fOwns = rhs.m_fOwns;
            }
            else
                if (rhs.m_fOwns)
                    m_fOwns = true;
            m_p = rhs.Release();
        }

        return *this;
    }

    T &
    operator*()
    {
        return *Get();
    }

    T const &
    operator*() const
    {
        return *Get();
    }

    T &
    operator[](size_t index)
    {
        return m_p[index];
    }

    T const &
    operator[](size_t index) const
    {
        return m_p[index];
    }
                                                  // Operations
    T *
    Get() const throw()
    {
        return m_p;
    }

    T *
    Release() const throw()
    {
        // workaround function const.
        m_fOwns = false;
        return m_p;
    }

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    bool mutable m_fOwns;
    T *m_p;
};

} // namespace scu

#endif // SLBSCU_ARRAYP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\exception.cpp ===
// Exception.cpp -- Smart Card Utility Exception class definition

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#include "scuExc.h"

using namespace scu;

/////////////////////////// LOCAL/HELPER  /////////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
scu::Exception::~Exception() throw()
{}

                                                  // Operators
                                                  // Operations
                                                  // Access
char const *
scu::Exception::Description() const
{
    return 0;
}

Exception::FacilityCode
scu::Exception::Facility() const throw()
{
    return m_fc;
}



                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
scu::Exception::Exception(FacilityCode fc) throw()
    : m_fc(fc)
{}


                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scuexchelp.h ===
// scuExcHelp.h -- Exception helper for clients defining exceptions

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SCU_EXCHELP_H)
#define SCU_EXCHELP_H

#include <string>
#include <wtypes.h>

namespace scu
{

template<class CauseCode>
struct CauseCodeDescriptionTable
{
    typename CauseCode m_cc;
    LPCTSTR m_lpDescription;
};

template<class CauseCode>
LPCTSTR
FindDescription(typename CauseCode cc,
                CauseCodeDescriptionTable<typename CauseCode> const *ccdt,
                size_t cTableLength)
{
    bool fFound = false;
    LPCTSTR lpDescription = 0;
    for (size_t i = 0; !fFound && (i < cTableLength); i++)
    {
        if (cc == ccdt[i].m_cc)
        {
            lpDescription = ccdt[i].m_lpDescription;
            fFound = true;
        }
    }

    return lpDescription;
}

} // namespace scu

#endif // SCU_EXCHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scuexc.h ===
// scuExc.h -- Smart Card Utility EXCeption declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SCU_EXCEPTION_H)
#define SCU_EXCEPTION_H

#include "DllSymDefn.h"

namespace scu
{

// Exception is a virtual root class for exceptions and cannot be
// instantiated directly.  Rather, specializations of Exception are
// defined by a facility and instantiated.  Given a reference to an
// instance of Exception, it's facility can be obtained by the
// Facility member function.  Specializations of the Exception class
// are typically defined by the responsible facility using the
// convenience template ExcTemplate.
//
// Each specialization of an exception typically has, but is not
// required to have, a cause code that uniquely identifies the reason
// for the exception within the facility it represents.  Each
// Exception does have an error code that is a generic version of the
// cause code (if it exists).  This error code could overlap error
// codes of other facilities.  The specialization implements Error
// routine.

class SCU_DLLAPI Exception
{
public:
                                                  // Types
    enum FacilityCode
    {
        fcCCI,
        fcIOP,
        fcOS,
        fcSmartCard,
        fcPKI,
    };

    typedef unsigned long ErrorCode;
        // ErrorCode must be the largest integer that any facility
        // needs to translate their native codes into a generic
        // error code.

                                                  // C'tors/D'tors
    virtual
    ~Exception() throw() = 0;

                                                  // Operators
                                                  // Operations
    virtual Exception *
    Clone() const = 0;

    virtual void
    Raise() const = 0;
                                                  // Access

    virtual char const *
    Description() const;
        // Textual description of the exception.

    virtual ErrorCode
    Error() const throw() = 0;
         // generic code

    FacilityCode
    Facility() const throw();
        // Facility that threw the exception


                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    Exception(FacilityCode fc) throw();

                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    FacilityCode m_fc;
};

// ExcTemplate is a convenience template to define new exceptions by
// facility.  To define a new specialization, add the facility to the
// Exception class, then reference it when declaring the new
// exception.  E.g.
//
// typedef ExcTemplate<OS, DWORD> OsException;
//
// The helper routine AsErrorCode is defined as a template to convert
// a cause code into a error code.  The helper templates operator==
// and operator!= are also defined.  These as well as the class
// methods can be overriden in the usual C++ fashion.

template<Exception::FacilityCode FC, class CC>
class ExcTemplate
    : public Exception
{
public:
                                                  // Types
    typedef CC CauseCode;
                                                  // C'tors/D'tors
    explicit
    ExcTemplate(CauseCode cc) throw();

    virtual
    ~ExcTemplate() throw();

                                                  // Operations
    virtual Exception *
    Clone() const;

    virtual void
    Raise() const;

                                                  // Access

    CauseCode
    Cause() const throw();
        // facility-specific code indicating the cause of the
        // exception.  The value is unique to facility.

    virtual char const *
    Description() const;

    ErrorCode
    Error() const throw();
                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    CauseCode m_cc;
};

/////////////////////////  TEMPLATE METHODS  //////////////////////////////

///////////////////////////    PUBLIC     /////////////////////////////////

                                                  // Types
                                                  // C'tors/D'tors
template<Exception::FacilityCode FC, class CC>
ExcTemplate<FC, CC>::ExcTemplate(CauseCode cc) throw()
    : Exception(FC),
      m_cc(cc)
{}

template<Exception::FacilityCode FC, class CC>
ExcTemplate<FC, CC>::~ExcTemplate() throw()
{}

                                                  // Operators
                                                  // Operations
template<Exception::FacilityCode FC, class CC>
scu::Exception *
ExcTemplate<FC, CC>::Clone() const
{
    return new ExcTemplate<FC, CC>(*this);
}

template<Exception::FacilityCode FC, class CC>
void
ExcTemplate<FC, CC>::Raise() const
{
    throw *this;
}
                                                  // Access
template<Exception::FacilityCode FC, class CC>
typename ExcTemplate<FC, CC>::CauseCode
ExcTemplate<FC, CC>::Cause() const throw()
{
    return m_cc;
}

template<Exception::FacilityCode FC, class CC>
char const *
ExcTemplate<FC, CC>::Description() const
{
    return Exception::Description();
}

template<Exception::FacilityCode FC, class CC>
typename ExcTemplate<FC, CC>::ErrorCode
ExcTemplate<FC, CC>::Error() const throw()
{
    return AsErrorCode(Cause());
}

                                                  // Predicates
                                                  // Static Variables

///////////////////////////   PROTECTED   /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    PRIVATE    /////////////////////////////////

                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Static Variables


///////////////////////////    HELPERS    /////////////////////////////////
template<class CC>
Exception::ErrorCode
AsErrorCode(typename CC cc) throw()
{
    return cc;
}

} // namespace

#endif // SCU_EXCEPTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scuosexc.h ===
// scuOsExc.h -- Operating System EXCeption class declaration

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1999. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#if !defined(SCU_OSEXC_H)
#define SCU_OSEXC_H

#include <windows.h>
#include <winerror.h>

#include "scuExc.h"

namespace scu
{

// Instantiate ExcTemplate so that OsException can be derived from it
// and properly exported in a DLL.  See MSDN Knowledge Base Article
// Q168958 for more information.
#if defined(SCU_IN_DLL)
#pragma warning(push)
//  Non-standard extension used: 'extern' before template explicit
//  instantiation
#pragma warning(disable : 4231)

SCU_EXPIMP_TEMPLATE template class SCU_DLLAPI
    ExcTemplate<Exception::fcOS, DWORD>;

#pragma warning(pop)
#endif

// A general exception class to represent OS error codes as
// exceptions.  For example, on the Windows platform a DWORD is
// returned by a Windows routine (usually through GetLastError).  The
// value could be translated into an OsException with value as the
// CauseCode.
//
// On Windows, the error return codes are found in WINERROR.H
// and other header files as described by the Windows function.
// OsException will take an HRESULT, mapping it to a DWORD (which is
// what GetLastError returns).
class SCU_DLLAPI OsException
    : public ExcTemplate<Exception::fcOS, DWORD>
{
public:
                                                  // Types
                                                  // C'tors/D'tors
    explicit
    OsException(CauseCode cc) throw();

    explicit
    OsException(HRESULT hr) throw();

    OsException(OsException const &rhs);

    virtual
    ~OsException() throw();

                                                  // Operators
    virtual scu::Exception *
    Clone() const;

    virtual void
    Raise() const;

                                                  // Operations
                                                  // Access
    virtual char const *
    Description() const;

                                                  // Predicates

protected:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables

private:
                                                  // Types
                                                  // C'tors/D'tors
                                                  // Operators
                                                  // Operations
                                                  // Access
                                                  // Predicates
                                                  // Variables
    LPTSTR mutable m_lpDescription; // cached description
};

} // namespace

#endif // SCU_OSEXC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scuosversion.h ===
// scuOsVersion: Defines macros for representing the target OS
// interface and platform build being used
//
// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2000. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(SLBSCU_OSVERSION_H)
#define SLBSCU_OSVERSION_H

#if !defined(WINVER)
#error WINVER must be defined
#endif

// Define the OS interterfaces for this compile
// Selected SLBSCU_<platform>_SERIES macros are defined based on the
// Platform SDK macros defined, where <platform> is
//
// WIN95SIMPLE - Windows 95
// WIN95SR2    - Windows 95 OEM Service Release 2
// WIN98
// WINNT       - Windows NT 4.x and 2000
// WINNT4      - Windows NT 4.x
// WIN2K       - Windows 2000
// WINNT_ONLY  - not Windows 2000 or Windows 98
//

#if (defined(_WIN32_WINDOWS) && (_WIN32_WINDOWS == 0x0410) && (WINVER == 0x0400)) || (!defined(_WIN32_WINNT) && (WINVER == 0x0500))
#define SLBSCU_WIN98_SERIES           1
#else
#define SLBSCU_WIN98_SERIES           0
#endif

#if defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0400)
#define SLBSCU_WIN95SIMPLE_SERIES     1  // not Service Pack 2

#define SLBSCU_WIN95SR2_SERIES        0  // with Service Pack 2
#define SLBSCU_WINNT4_SERIES          0
#define SLBSCU_WINNT_SERIES           0
#define SLBSCU_WINNT_ONLY_SERIES      0
#define SLBSCU_WIN2K_SERIES           0
#else // defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0400)

#define SLBSCU_WIN95SIMPLE_SERIES     0

#if defined(_WIN32_WINNT) && (_WIN32_WINNT == 0x0400)
#define SLBSCU_WIN95SR2_SERIES        1  // with Service Pack 2
#else
#define SLBSCI_WIN95SR2_SERIES        0
#endif

#if (WINVER >= 0x0400)
#define SLBSCU_WINNT_SERIES           1
#else
#define SLBSCU_WINNT_SERIES           0
#endif

#if ((WINVER >= 0x0400) && (WINVER < 0x0500))
#define SLBSCU_WINNT4_SERIES          1
#else
#define SLBSCU_WINNT4_SERIES          0
#endif

#if (WINVER >= 0x0500)
#define SLBSCU_WIN2K_SERIES           1
#else
#define SLBSCU_WIN2K_SERIES           0
#endif

#if !SLBSCU_WIN98_SERIES && SLBSCU_WINNT_SERIES
#define SLBSCU_WINNT_ONLY_SERIES      1
#else
#define SLBSCU_WINNT_ONLY_SERIES      0
#endif

#endif // defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0400)

// Define any SLB_<platform>_BUILD and SLB_NO<platform>_BUILD macros
// which haven't already been defined, as appropriate.
//
// These build macros can be defined at compile time to define what
// are the target platforms for the build.  There are two sets of
// macros.  The first is in the form of SLB_<platform>_BUILD:
//
// SLB_WIN95_BUILD - for either 95 and 95 OEM Service Pack 2 depeding
//                   on the Platform SDK macro settings.
// SLB_WIN98_BUILD
// SLB_WINNT_BUILD - only NT 4.x
// SLB_WIN2K_BUILD - Windows 2000
//
// These can be set at compile time in which case they override any
// inference taken from the Platform SDK macros and
// SLBSCU_<platform>_SERIES macros.  When non of these is defined at
// compile time, then they are defined here based on the
// SLBSCU_<platform>_SERIES macros taken from the Platform SDK macro
// definitions.  Where these build macros override the platform series
// macros, another provide a way to filter the target platform settings.
//
// The SLBSCU_NO<platform>_BUILD are used to "turn off" building for a
// target platform that would otherwise be indicated  from platform
// series.  Since the Platform SDK macros specify a mininum system
// configuration, you may want to filter out some specific target
// platforms without having to specify each one.  The filtering macros
// are:
//
// SLB_NOWIN95_BUILD
// SLB_NOWIN98_BUILD
// SLB_NOWINNT_BUILD
// SLB_NOWIN2K_BUILD
//
// Defining any one of these will indicate the corresponding platform
// isn't supported in this build.
//
// This header file defines both sets for any which haven't been
// defined at build time.  In this way, the build can specify the
// minimum build macros based on the Platform SDK settings.  All the
// macros will be defined as appropriate so the source code can
// conditionally compile according to the settings.

#if defined(SLB_NOWIN95_BUILD) && defined(SLB_WIN95_BUILD)
#error SLB_NOWIN95_BUILD and SLB_WIN95_BUILD conflict, define one or the other.
#endif

#if defined(SLB_NOWIN98_BUILD) && defined(SLB_WIN98_BUILD)
#error SLB_NOWIN98_BUILD and SLB_WIN98_BUILD conflict, define one or the other.
#endif

#if defined(SLB_NOWINNT_BUILD) && defined(SLB_WINNT_BUILD)
#error SLB_NOWINNT_BUILD and SLB_WINNT_BUILD conflict, define one or the other.
#endif

#if defined(SLB_NOWIN2K_BUILD) && defined(SLB_WIN2K_BUILD)
#error SLB_NOWIN2K_BUILD and SLB_WIN2K_BUILD conflict, define one or the other.
#endif

#if !defined(SLB_WIN95_BUILD) && !defined(SLB_WIN98_BUILD) && !defined(SLB_WINNT_BUILD) && !defined(SLB_WIN2K_BUILD)

// Check for NT/W2K builds to guard against _WIN32_WINNT being set
// for Windows 95 OEM Service Release 2 but being confused with minimum
// Windows NT 4.0 system requirement.
#if !defined(SLB_NOWIN95_BUILD)
#if (SLBSCU_WIN95SR2_SERIES || SLBSCU_WIN95SIMPLE_SERIES)
#define SLB_WIN95_BUILD
#else
#define SLB_NOWIN95_BUILD
#endif
#endif

#if !defined(SLB_NOWIN98_BUILD)
#if SLBSCU_WIN98_SERIES
#define SLB_WIN98_BUILD
#else
#define SLB_NOWIN98_BUILD
#endif
#endif

#if !defined(SLB_NOWINNT_BUILD)
#if SLBSCU_WINNT4_SERIES
#define SLB_WINNT_BUILD
#else
#define SLB_NOWINNT_BUILD
#endif
#endif

#if !defined(SLB_NOWIN2K_BUILD)
#if (SLBSCU_WIN2K_SERIES || SLBSCU_WINNT_SERIES)
#define SLB_WIN2K_BUILD
#else
#define SLB_NOWIN2K_BUILD
#endif
#endif

#endif // !defined(SLB_WIN95_BUILD) && !defined(SLB_...)

#endif // !defined(SLBSCU_OSVERSION_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\autobuildcount.h ===
// 49
#ifndef AUTOBUILDCOUNT_H
#define AUTOBUILDCOUNT_H
#define BUILDCOUNT_NUM 49
#define BUILDCOUNT_STR "49"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scusecurearray.h ===
// scuSecureArray.h -- implementation of a SecureArray template

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2002. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if !defined(SLBSCU_SECUREARRAY_H)
#define SLBSCU_SECUREARRAY_H
#include "DllSymDefn.h"
namespace scu
{
    // SecureArray is a simple template for arrays of basic types
    // (e.g. char, BYTE, int, DWORD, float, string, etc.) which
    // ensures that the buffer allocated 
    // for the array is zeroed out before it is freed in order to
    // icrease the security of protecting sensitive information
    // scattered throughout the heap. This template assumes that the
    // parameter T provides an implementation of the assignment
    // operator and a constructor for T(0), which is used as a zero
    // element to clear the bufer up with.

    // USAGE NOTE: it is important to note that this template is
    // secure in the sense defined above if and only if T zeroes out
    // its store before freeing. This is the case with the
    // built in C++ types (char, BYTE, int, DWORD, float,
    // etc). However, it is NOT guaranteed to be secure with STL
    // objects, such as string, because such objects do not zero out
    // its buffer upon freeing it. 

    template<class  T> 
    class SCU_DLLAPI SecureArray 
    {
    public:
                                                 // Types
        typedef T ElementType;
                                                 // C'tors/D'tors
        SecureArray(const size_t nCount)
            :m_pDataStore(0),
             m_nSize(0)
        {
            if(nCount)
                m_pDataStore = new T[nCount];
            m_nSize = nCount;
        }

        SecureArray(T* pBuffer, size_t nCount)
            :m_pDataStore(0),
             m_nSize(0)
        {
            SetupFromBuffer(reinterpret_cast<T const *>(pBuffer),
                            nCount);
        }

        SecureArray(T const * pBuffer, size_t nCount)
            :m_pDataStore(0),
             m_nSize(0)
        {
            SetupFromBuffer(pBuffer, nCount);
        }

        SecureArray(size_t nCount, T const & rt)
            :m_pDataStore(0),
             m_nSize(0)
        {
            m_pDataStore = new T[nCount];
            for(size_t nIdx=0; nIdx<nCount; nIdx++)
                m_pDataStore[nIdx] = rt;

            m_nSize = nCount;
        }

        SecureArray()
            :m_pDataStore(0),
             m_nSize(0)
        {}

        SecureArray(SecureArray<T> const &rsa)
            :m_pDataStore(0),
             m_nSize(0)
        {
            *this = rsa;
        }

        ~SecureArray() throw()
        {
            try
            {
                ClearDataStore();
            }
            catch(...)
            {
            }
        }
        
                    
                                                 // Operators
        
        SecureArray<T> &
        operator=(SecureArray<T> const &rother)
        {
            if(this != &rother)
            {
                // Deep copy
                ClearDataStore();
                if(rother.size())
                {
                    m_pDataStore = new T[rother.size()];
                    for(size_t nIdx=0; nIdx<rother.size(); nIdx++)
                        this->operator[](nIdx)=rother[nIdx];
                }
                m_nSize = rother.size();
            }
            return *this;
        }

        SecureArray<T> &
        operator=(T const &rt)
        {
            for(size_t nIdx=0; nIdx<m_nSize; nIdx++)
                m_pDataStore[nIdx]=rt;
            return *this;
        }

        T&
        operator[](size_t nIdx)
        {
            return m_pDataStore[nIdx];
        }

        T const &
        operator[](size_t nIdx) const
        {
            return m_pDataStore[nIdx];
        }
        
        T&
        operator*()
        {
            return *data();
        }

        T const &
        operator*() const
        {
            return *data();
        }

                                                  // Operations        
        T*
        data()
        {
            return m_pDataStore;
        }

        T const *
        data() const
        {
            return m_pDataStore;
        }

        size_t 
        size() const
        {
            return m_nSize;
        }

        size_t
        length() const
        {
            return size();
        }
        
        size_t
        length_string() const
        {
            if(size())
                return size()-1;
            else
                return 0;
        }

        SecureArray<T> &
        append(size_t nAddSize, T const & rval)
        {
            size_t nNewSize = size()+nAddSize;
            
            T* pTemp = new T[nNewSize];
            size_t nIdx=0;
            
            for(nIdx=0; nIdx<size(); nIdx++)
                pTemp[nIdx] = m_pDataStore[nIdx];
            for(nIdx=size(); nIdx<nNewSize; nIdx++)
                pTemp[nIdx] = rval;

            ClearDataStore();
            m_pDataStore = pTemp;
            m_nSize = nNewSize;
            return *this;
        }

        SecureArray<T> &
        append( T const * pBuf, size_t nAddSize)
        {
            size_t nNewSize = size()+nAddSize;
            
            T* pTemp = new T[nNewSize];
            size_t nIdx=0;
            
            for(nIdx=0; nIdx<size(); nIdx++)
                pTemp[nIdx] = m_pDataStore[nIdx];
            for(nIdx=size(); nIdx<nNewSize; nIdx++)
                pTemp[nIdx] = *pBuf++;

            ClearDataStore();
            m_pDataStore = pTemp;
            m_nSize = nNewSize;
            return *this;
        }

        SecureArray<T> &
        append_string(size_t nAddSize, T const & rval)
        {
            // Assumptions: the buffer contains a null terminated
            // string or is empty. The addional size is for the
            // non-null characters only, may be zero. 
            size_t nNewSize = 0;
            size_t nEndIdx = 0;
            size_t nIdx=0;
            if(size())
                nNewSize = size()+nAddSize;
            else
                nNewSize = nAddSize+1;// space for the null terminator
            
            T* pTemp = new T[nNewSize];
            if(size())
            {
                // Copy the existing string to the new location
                nEndIdx = size()-1;//rhs guaranteed non-negative
                for(nIdx=0; nIdx<nEndIdx; nIdx++)
                    pTemp[nIdx] = m_pDataStore[nIdx];
            }
            
            // Append it with the new characters
            for(nIdx=0; nIdx<nAddSize; nIdx++)
                pTemp[nEndIdx++] = rval;
            // Terminate the buffer
            pTemp[nEndIdx]=T(0);
            

            ClearDataStore();
            m_pDataStore = pTemp;
            m_nSize = nNewSize;
            return *this;
        }
        
    private:
        void
        ClearDataStore()
        {
            for(size_t nIdx=0; nIdx<m_nSize; nIdx++)
                m_pDataStore[nIdx]=T(0);
            delete [] m_pDataStore;
            m_pDataStore = 0;
            m_nSize = 0;
        }
        
        void
        SetupFromBuffer(T const * pBuffer, size_t nCount)
        {
            m_pDataStore = new T[nCount];
            for(size_t nIdx=0; nIdx<nCount; nIdx++)
                m_pDataStore[nIdx] = pBuffer[nIdx]; 
            m_nSize = nCount;
        }
        
        T * m_pDataStore;
        size_t m_nSize;
    };
}
#endif //SLBSCU_SECUREARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scumarker.h ===
// scuMarker.h -- implementation of a Marker template

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 2002. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.
#if !defined(SLBSCU_MARKER_H)
#define SLBSCU_MARKER_H
//#include "DllSymDefn.h"
namespace scu
{
    // Marker is a simple template for markers on card. It is used
    // with built in types (int, unsigned int, etc) to store marker
    // data retrieved from a smart card. 
    template<class  T> 
    class Marker 
    {
    public:
        Marker()
            :m_fSet(false),
             m_Value(0)
        {}
        
        Marker(Marker<T> const &rm)
            :m_fSet(false),
             m_Value(0)
        {
            *this = rm;
        }

        Marker(T const & rval)
            :m_Value(rval),
             m_fSet(true)
        {}
        
        ~Marker()
        {}
        

        Marker<T> &
        operator=(T const & val)
        {
            m_Value = val;
            m_fSet = true;
            return *this;
        }
        
        Marker<T> &
        operator=(Marker<T> const & rother)
        {
            if(this != &rother)
            {
                m_Value = rother.Value();
                m_fSet = rother.Set();
            }
            
            return *this;
        }
        
        bool
        operator==(Marker<T> const &other)
        {
            bool fResult = false;
            if(Set() && other.Set())
            {
                if(Value() == other.Value())
                {
                    fResult = true;
                }
            }
            return fResult;
        }
        
        bool
        operator!=(Marker<T> const &other)
        {
            return !(this->operator==(other));
        }
        
        
        T
        Value() const
        {
            return m_Value;
        }
        
        bool
        Set() const
        {
            return m_fSet;
        }
        
    private:
        T m_Value;
        bool m_fSet;
    };
}
#endif //SLBSCU_MARKER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbscu\scurcversion.h ===
// scuRcVersion.h -- Schlumberger Resource Versioning

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1998. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

// Common header file to include in resource (.rc) files for version
// definitions. This header file defines the product version, name,
// company information, etc. and supports components built in the
// Schlumberger Smart Card and Microsoft build environment

// If SLB_BUILD is defined, then it's assumed the package is being
// built by Schlumberger in which case a custom set of versioning
// information is (re)defined.  Otherwise it's being built by
// Microsoft for Windows 2000, so the default version numbering is
// used and "(Microsoft Build)" appears in product version string.

// To use, do the following in the package's resource file,
//     1. define the macros as described below
//     2. include this file
//     3. include <common.ver> provided by Microsoft
//
// Then the version resource information should be created as desired
// when compiling.
//
// When Schlumberger is building, the following must be defined:
//      VER_PRODUCT_MAJOR      - major version number
//      VER_PRODUCT_MINOR      - minor version number, less than 1,000.
//      SLBSCU_BUILDCOUNT_NUM  - build number, less than 10,000.
//
//  SLBSCU_BUILDCOUNT_NUM could be defined in terms of BUILDCOUNT_NUM
//  defined by AutoBuildCount.h.  In which case, AutoBuildCount.h would be
//  included before this file.

// To build on all platforms, the following must be defined:
//      VER_INTERNALNAME_STR        - name of the DLL, LIB, or EXE
//      VER_FILETYPE                - file type
//      VER_FILEDESCRIPTION_STR     - full product description.
//      SLBSCU_ROOT_PRODUCTNAME_STR - product name description which
//                                    will have the platform
//                                    description appended by this module.
//      VER_LEGALCOPYRIGHT_YEARS    - string of the copyright years,
//                                    e.g. "1997-2000"
//
// The following defintions are optional:
//      VER_FILESUBTYPE         - defaults to VFT2_UNKNOWN
//      VER_PRODUCTNAME_STR     - defaults to VER_FILEDESCRIPTION_STR
//                                with the platform.
//      _DEBUG                  - when defined, VER_DEBUG is set to
//                                VS_FF_DEBUG, otherwise it's set to 0
//
//
// The header file "scuOsVersion.h" is used to determine the
// platform(s) the build is targeting.  To restrict or override the
// symbols defined in scuOsVersion.h, the following optional
// definitions are recognized:
//      SLB_WIN95_BUILD         - targeting Windows 95
//      SLB_WIN95SR2_BUILD      - targeting Windows 95 Service Release 2
//      SLB_NOWIN95_BUILD       - specifies that although the Platform SDK
//                                macros may indicate Win95SR2,
//                                neither Win95 nor Service Release 2
//                                is being targeted.
//      SLB_WINNT_BUILD         - targeting Windows NT
//      SLB_WIN2K_BUILD         - targeting Windows 2000
//
// The following are defined by this header file:
//      VER_LEGALCOPYRIGHT_STR
//      VER_COMPANYNAME_STR
//      VER_LEGALTRADEMARKS_STR
//
// To override any of these, redefine them just after including this file.

#ifndef SLBSCU_VERSION_H
#define SLBSCU_VERSION_H

#include <WinVer.h>
#include <ntverp.h>

#include "scuOsVersion.h"

// If Schlumberger is building; otherwise Microsoft is building so don't
// override their version numbers.
#if defined(SLB_BUILD)

#ifndef VER_PRODUCT_MAJOR
    #error VER_PRODUCT_MAJOR must be defined.
#endif
#ifndef VER_PRODUCT_MINOR
    #error VER_PRODUCT_MINOR must be defined.
#endif
#ifndef SLBSCU_BUILDCOUNT_NUM
    #error SLBSCU_BUILDCOUNT_NUM must be defined.
#endif

#ifdef VER_DEBUG
#undef VER_DEBUG
#endif

#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

#if     (VER_PRODUCT_MINOR < 10)
#define VER_PMNR_PAD "00"
#elif   (VER_PRODUCT_MINOR < 100)
#define VER_PMNR_PAD "0"
#elif
#define VER_PMNR_PAD
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif
#define VER_PRODUCTBUILD             SLBSCU_BUILDCOUNT_NUM

#ifdef VER_BPAD
#undef VER_BPAD
#endif
#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#ifdef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION_STRING
#endif
#define VER_PRODUCTVERSION_STRING2(x,y) #x "." VER_PMNR_PAD #y
#define VER_PRODUCTVERSION_STRING1(x,y) VER_PRODUCTVERSION_STRING2(x, y)
#define VER_PRODUCTVERSION_STRING       VER_PRODUCTVERSION_STRING1(VER_PRODUCT_MAJOR, VER_PRODUCT_MINOR)

#ifndef VER_FILESUBTYPE
#define VER_FILESUBTYPE VFT2_UNKNOWN
#endif

// Force to use VER_PRODUCTVERSION
#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif
#define VER_PRODUCTVERSION           VER_PRODUCT_MAJOR,VER_PRODUCT_MINOR,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#ifdef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_W
#endif
#define VER_PRODUCTVERSION_W         (VER_PRODUCT_MAJOR##u)

#ifdef VER_PRODUCTVERSION_DW
#undef VER_PRODUCTVERSION_DW
#endif
#define VER_PRODUCTVERSION_DW        (((VER_PRODUCT_MAJOR##ul) << 32) | (VER_PRODUCT_MINOR##ul))


#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif
#define VER_FILEVERSION_STR          VER_PRODUCTVERSION_STR

#endif // defined(SLB_BUILD)

//
// Common to both Schlumberger and Microsoft build procedures.
//
#ifndef VER_INTERNALNAME_STR
   #error VER_INTERNALNAME_STR must be defined.
#endif
#ifndef VER_FILETYPE
   #error VER_FILETYPE must be defined.
#endif
#ifndef VER_FILEDESCRIPTION_STR
   #error VER_FILEDESCRIPTION_STR must be defined.
#endif
#ifndef VER_LEGALCOPYRIGHT_YEARS
   #error VER_LEGALCOPYRIGHT_YEARS must be defined.
#endif

#ifdef VER_LEGALCOPYRIGHT_STR
#undef VER_LEGALCOPYRIGHT_STR
#endif
#define VER_LEGALCOPYRIGHT_STR " Copyright Schlumberger Technology Corp. "\
                            VER_LEGALCOPYRIGHT_YEARS ". All Rights Reserved. "

#ifdef VER_COMPANYNAME_STR
#undef VER_COMPANYNAME_STR
#endif
#define VER_COMPANYNAME_STR         "Schlumberger Technology Corporation"

// Define the platform suffix to the product name description
#if defined(SLB_WIN2K_BUILD)
#define SLBSCU_WIN2K_PRODUCT_STR    "2000"
#endif

#if defined(SLB_WINNT_BUILD)
#if defined(SLBSCU_WIN2K_PRODUCT_STR)
#define SLBSCU_WINNT_PRODUCT_STR    "NT, "
#else
#define SLBSCU_WINNT_PRODUCT_STR    "NT"
#endif
#endif

#if defined(SLB_WIN98_BUILD)
#if defined(SLBSCU_WINNT_PRODUCT_STR) || defined(SLBSCU_WIN2K_PRODUCT_STR)
#define SLBSCU_WIN98_PRODUCT_STR    "98, "
#else
#define SLBSCU_WIN98_PRODUCT_STR    "98"
#endif
#endif

#if defined(SLB_WIN95_BUILD) && SLBSCU_WIN95SR2_SERIES
#if defined(SLBSCU_WIN98_PRODUCT_STR) || defined(SLBSCU_WINNT_PRODUCT_STR) || defined(SLBSCU_WIN2K_PRODUCT_STR)
#define SLBSCU_WIN95_PRODUCT_STR    "95SR2, "
#else
#define SLBSCU_WIN95_PRODUCT_STR    "95SR2"
#endif
#endif

#if defined(SLB_WIN95_BUILD) && SLBSCU_WIN95SIMPLE_SERIES
#if defined(SLBSCU_WIN98_PRODUCT_STR) || defined(SLBSCU_WINNT_PRODUCT_STR) || defined(SLBSCU_WIN2K_PRODUCT_STR) || defined(SLBSCU_WIN95_PRODUCT_STR)
#define SLBSCU_WIN95_PRODUCT_STR    "95, "
#else
#define SLBSCU_WIN95_PRODUCT_STR    "95"
#endif
#endif


#ifndef SLBSCU_WIN2K_PRODUCT_STR
#define SLBSCU_WIN2K_PRODUCT_STR    ""
#endif

#ifndef SLBSCU_WINNT_PRODUCT_STR
#define SLBSCU_WINNT_PRODUCT_STR    ""
#endif

#ifndef SLBSCU_WIN98_PRODUCT_STR
#define SLBSCU_WIN98_PRODUCT_STR    ""
#endif

#ifndef SLBSCU_WIN95_PRODUCT_STR
#define SLBSCU_WIN95_PRODUCT_STR    ""
#endif

#if defined(VER_PRODUCTNAME_STR)
#undef VER_PRODUCTNAME_STR
#endif

#if !defined(SLBSCU_ROOT_PRODUCTNAME_STR)
    #error SLBSCU_ROOT_PRODUCTNAME_STR must be defined.
#else
#if !defined(SLB_BUILD)
#define SLBSCU_BUILD_SYSTEM_STR "(Microsoft Build)"
#else
#define SLBSCU_BUILD_SYSTEM_STR ""
#endif

#define SLBSCU_PLATFORM_STR         " for Windows "  \
                            SLBSCU_WIN95_PRODUCT_STR \
                            SLBSCU_WIN98_PRODUCT_STR \
                            SLBSCU_WINNT_PRODUCT_STR \
                            SLBSCU_WIN2K_PRODUCT_STR \
                            SLBSCU_BUILD_SYSTEM_STR


#define VER_PRODUCTNAME_STR         SLBSCU_ROOT_PRODUCTNAME_STR \
                            SLBSCU_PLATFORM_STR

#endif // !defined(SLBSCU_ROOT_PRODUCTNAME_STR)

#ifdef VER_LEGALTRADEMARKS_STR
#undef VER_LEGALTRADEMARKS_STR
#endif
#define VER_LEGALTRADEMARKS_STR     "Cyberflex Access, Cryptoflex and Cryptoflex e-gate are registered trademarks of Schlumberger Technology Corporation."

#endif // SLBSCU_VERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\bits.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element BITS.C */
/*  *1    14-NOV-1996 10:25:36 ANIGBOGU "[113914]Functions to output variable-length bit strings" */
/*  DEC/CMS REPLACEMENT HISTORY, Element BITS.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/bits.c
**
**  PURPOSE
**
**    Output variable-length bit strings.  Compression can be done
**    to a buffer or to memory. (The latter is not supported in this version.)
**
**  CLASSIFICATION TERMS
**
**  DISCUSSION
**
**      The PKZIP "deflate" format interprets compressed data
**      as a sequence of bits.  Multi-bit strings in the data may cross
**      byte boundaries without restriction.
**
**      The first bit of each byte is the low-order bit.
**
**      The routines in this file allow a variable-length bit value to
**      be output right-to-left (useful for literal values). For
**      left-to-right output (useful for code strings from the tree routines),
**      the bits must have been reversed first with ReverseBits().
**
**  INTERFACE
**
**      void InitializeBits(LocalBits_t *Bits)
**          Initialize the bit string routines.
**
**      void SendBits(int Value, int Length, LocalBits_t *Bits,
**                    CompParam_t *Comp)
**          Write out a bit string, taking the source bits right to
**          left.
**
**      int ReverseBits(int Value, int Length)
**          Reverse the bits of a bit string, taking the source bits left to
**          right and emitting them right to left.
**
**      void WindupBits(LocalBits_t *Bits, CompParam_t *Comp)
**          Write out any remaining bits in an incomplete byte.
**
**      void CopyBlock(char *Input, unsigned Length, int Header, LocalBits_t *Bits
**                     CompParam_t *Comp)
**          Copy a stored block to the zip buffer, storing first the length and
**          its one's complement if requested.
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include "comppriv.h"

#define BufSize (8 * 2*sizeof(char))
/* Number of bits used within ValidBits. (ValidBits might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Initialize the bit string routines.
 */
void
InitializeBits(
               LocalBits_t *Bits
              )
{
    Bits->BitBuffer = 0;
    Bits->ValidBits = 0;

}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
void
SendBits(
         int           Value,       /* value to send */
         int           Length,      /* number of bits */
         LocalBits_t  *Bits,
         CompParam_t  *Comp
        )
{
    /* If not enough room in BitBuffer, use (valid) bits from BitBuffer and
     * (16 - ValidBits) bits from value, leaving (width - (16-ValidBits))
     * unused bits in value.
     */
    if (Bits->ValidBits > (unsigned int)(BufSize - Length))
    {
        Bits->BitBuffer |= ((unsigned int)Value << Bits->ValidBits);
        PutShort(Bits->BitBuffer, Comp);
        Bits->BitBuffer = (unsigned int)Value >> (BufSize - Bits->ValidBits);
        Bits->ValidBits += (unsigned int)(Length - BufSize);
    }
    else
    {
        Bits->BitBuffer |= ((unsigned int)Value << Bits->ValidBits);
        Bits->ValidBits += (unsigned int)Length;
    }
}

/* ===========================================================================
 * Reverse the first length bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
unsigned int
ReverseBits(
            unsigned int Code,      /* the value to invert */
            int          Length     /* its bit length */
           )
{
    unsigned int Result = 0;

    do
    {
        Result |= Code & 1;
        Code >>= 1;
        Result <<= 1;
    } while (--Length > 0);
    return Result >> 1;
}

/* ===========================================================================
 * Write out any remaining bits in an incomplete byte.
 */
void
WindupBits(
           LocalBits_t  *Bits,
           CompParam_t  *Comp
          )
{
    if (Bits->ValidBits > 8)
    {
        PutShort(Bits->BitBuffer, Comp);
    }
    else if (Bits->ValidBits > 0)
    {
        PutByte(Bits->BitBuffer, Comp);
    }
    Bits->BitBuffer = 0;
    Bits->ValidBits = 0;
}

/* ===========================================================================
 * Copy a stored block to the zip buffer, storing first the length and its
 * one's complement if requested.
 */
void
CopyBlock(
          char            *Input,    /* the input data */
          unsigned int     Length,     /* its length */
          int              Header,  /* true if block header must be written */
          LocalBits_t     *Bits,
          CompParam_t     *Comp
         )
{
    WindupBits(Bits, Comp);              /* align on byte boundary */

    if (Header)
    {
        PutShort((unsigned short)Length, Comp);
        PutShort((unsigned short)~Length, Comp);
    }

    while (Length--)
    {
        PutByte(*Input++, Comp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\comppriv.h ===
/*  DEC/CMS REPLACEMENT HISTORY, Element CompPirv.H */
/*  *1    14-NOV-1996 10:26:00 ANIGBOGU "[113914]Private declarations for all compression/decompression functions" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CompPirv.H */
/* PUBLIC FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/CompPirv.h
**
**  PURPOSE
**
**    Common declarations for all compression/decompression modules
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include "CompPub.h"

#include "slbCrc32.h"

#if defined(VMS)
#define OS_CODE  0x02
#endif

#if defined(Unix)
#define OS_CODE  0x03
#endif

    /* Common defaults */

#ifndef OS_CODE
#define OS_CODE  0x0b  /* assume WindowsNT or Windows95*/
#endif

#include <string.h>

#define memzero(String, Size)     memset ((void *)(String), 0, (Size))

#define STORED      0
/* methods 1 to 7 reserved */
#define DEFLATED    8
#define MAX_METHODS 9

/*
 * For compression, input is done in window[]. For decompression, output
 * is done in window.
 */

#ifndef INBUFSIZ
#define INBUFSIZ  0x8000  /* input buffer size */
#endif

#ifndef OUTBUFSIZ
#define OUTBUFSIZ  16384  /* output buffer size */
#endif

#ifndef DISTBUFSIZE
#define DISTBUFSIZE 0x8000 /* buffer for distances, see Trees.c */
#endif

#ifndef WSIZE
#define WSIZE 0x8000     /* window size--must be a power of two, and */
#endif                     /*  at least 32K for zip's deflate method */

#ifndef DWSIZE
#define DWSIZE 0x10000   /* 2L * WSIZE */
#endif

#ifndef BITS
#define BITS 16
#endif

typedef struct CompData
{
    unsigned char   *Data;
    int              Size;
    struct CompData *next;
} CompData_t;

typedef struct CompParam
{
    unsigned long   InputSize;          /* valid bytes in inbuf */
    unsigned long   Index;              /* index of next byte to be processed in inbuf */
    unsigned long   OutBytes;           /* bytes in output buffer */
    unsigned long   GlobalSize;         /* bytes in inbut g_inbuf */
    unsigned long   BytesIn;            /* number of input bytes */
    unsigned long   BytesOut;           /* number of output bytes */
    unsigned long   HeaderBytes;        /* number of bytes in gzip header */
    unsigned long   WindowSize;         /* window size, 2*WSIZE */
    Crc32          *pCRC;               /* Cyclic Redundancy Check */
    unsigned long   BitBuffer;          /* Global bit buffer */
    unsigned int    BitsInBitBuffer;    /* bits in global bit buffer */
    unsigned short  DistBuffer[DISTBUFSIZE]; /* buffer for distances, see trees.c */
    unsigned short  HashLink[1L<<BITS];      /* hash link (see deflate.c) */
    unsigned char   InputBuffer[INBUFSIZ];   /* input buffer */
    unsigned char  *Input;               /* pointer to input buffer */
    unsigned char   Output[OUTBUFSIZ];   /* output buffer */
    unsigned char   Window[DWSIZE];      /* Sliding window */
    unsigned char  *GlobalInput;         /* global input buffer */
    CompData_t     *CompressedOutput;    /* compressed output list */
    CompData_t     *PtrOutput;           /* pointer to compressed output list */
} CompParam_t;

typedef struct DeflateParam
{
    long            BlockStart;
    unsigned int    PrevLength;
    unsigned int    StringStart;       /* start of string to insert */
    unsigned int    MatchStart;        /* start of matching string */
    unsigned int    MaxChainLength;
    unsigned int    MaxLazyMatch;
    unsigned int    GoodMatch;
    int             NiceMatch; /* Stop searching when current match exceeds this */
} DeflateParam_t;

/*  long BlockStart:
 * window position at the beginning of the current output block. Gets
 * negative when the window is moved backwards.
 */

/* PrevLength:
 * Length of the best match at previous step. Matches not greater than this
 * are discarded. This is used in the lazy match evaluation.
 */

/* MaxChainLength:
 * To speed up deflation, hash chains are never searched beyond this length.
 * A higher limit improves compression ratio but degrades the speed.
 */

/* MaxLazyMatch:
 * Attempt to find a better match only when the current match is strictly
 * smaller than this value. This mechanism is used only for compression
 * levels >= 4.
 */

/* GoodMatch: */
/* Use a faster search when the previous match is longer than this */


/* Values for MaxLazyMatch, GoodMatch and MaxChainLength, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological data. Better values may be
 * found for specific data.
 */

/* ===========================================================================
 * Data used by the "bit string" routines (Bits.c) and zip (Zip.c)
 */

typedef struct LocalBits
{
    unsigned int    BitBuffer;
    unsigned int    ValidBits;
} LocalBits_t;

/* BitBuffer: Output buffer. bits are inserted starting at the bottom
 * (least significant bits).
 */
/* ValidBits: Number of valid bits in BitBuffer.  All bits above the last valid bit
 * are always zero.
 */

typedef struct LocalDef
{
    unsigned int HashIndex;  /* hash index of string to be inserted */
    int          EndOfInput; /* flag set at end of input buffer */
    unsigned int Lookahead;  /* number of valid bytes ahead in window */
    int          CompLevel;  /* compression level (1..9) */
} LocalDef_t;

/* for compatibility with old zip sources (to be cleaned) */

#define GZIP_MAGIC     "\037\213" /* Magic header for gzip format, 1F 8B */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See Deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define GetByte(c)  \
(c->Index < c->InputSize ? c->Input[c->Index++] : FillInputBuffer(0,c))
#define TryByte(c)  \
(c->Index < c->InputSize ? c->Input[c->Index++] : FillInputBuffer(1,c))

/* PutByte is used for the compressed output
 */
#define PutByte(c,o) {o->Output[o->OutBytes++]=(unsigned char)(c); \
if (o->OutBytes==OUTBUFSIZ) \
   FlushOutputBuffer(o);}

/* Output a 16 bit value, lsb first */
#define PutShort(w,c) \
{ if (c->OutBytes < OUTBUFSIZ-2) { \
    c->Output[c->OutBytes++] = (unsigned char) ((w) & 0xff); \
    c->Output[c->OutBytes++] = (unsigned char) ((unsigned short)(w) >> 8); \
  } else { \
    PutByte((unsigned char)((w) & 0xff),c); \
    PutByte((unsigned char)((unsigned short)(w) >> 8),c); \
  } \
}

/* Output a 32 bit value to the bit stream, LSB first */
#define PutLong(n,c) { \
    PutShort(((n) & 0xffff),c); \
    PutShort(((unsigned long)(n)) >> 16,c); \
}

/* Macros for getting two-byte and four-byte header values */
#define SH(p) ((unsigned short)(unsigned char)((p)[0]) | ((unsigned short)(unsigned char)((p)[1]) << 8))
#define LG(p) ((unsigned long)(SH(p)) | ((unsigned long)(SH((p)+2)) << 16))

/* Diagnostic functions */
#ifdef DEBUG
#  define Assert(cond,msg) {if(!(cond)) error(msg);}
#else
#  define Assert(cond,msg)
#endif

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif

    /* in Zip.c: */
extern CompressStatus_t Zip(int Level, CompParam_t *Comp);
extern int FillBuffer(unsigned char *Buffer, unsigned int Size, CompParam_t *Comp);
int        ReadBuffer(char *Buffer, unsigned int Size, CompParam_t *Comp);

    /* in Unzip.c */
extern CompressStatus_t Unzip(int Method, CompParam_t *Comp);

        /* in Deflate.c */
CompressStatus_t InitLongestMatch(int PackLevel, unsigned short
                                  *Flags, DeflateParam_t *Defl,
                                  LocalDef_t *Deflt, CompParam_t *Comp);
unsigned long Deflate(int Level, LocalBits_t *Bits, DeflateParam_t *Defl,
                      LocalDef_t *Deflt, CompParam_t *Comp);

        /* in Trees.c */
void InitMatchBuffer(void);
int  TallyFrequencies(int Dist, int LengthC, int Level,
                      DeflateParam_t *Defl, CompParam_t *Comp);
unsigned long FlushBlock(char *Buffer, unsigned long stored_len, int Eof,
                         LocalBits_t *Bits, CompParam_t *Comp);

        /* in Bits.c */
void            InitializeBits(LocalBits_t *Bits);
void            SendBits(int Value, int Length, LocalBits_t *Bits,
                         CompParam_t *Comp);
unsigned int    ReverseBits(unsigned int Value, int Length);
void            WindupBits(LocalBits_t *Bits, CompParam_t *Comp);
void            CopyBlock(char *Input, unsigned int Length, int Header,
                          LocalBits_t *Bits, CompParam_t *Comp);

    /* in Util.c: */
extern unsigned long UpdateCRC(CompParam_t *Comp, unsigned char *Input,
                               unsigned int Size);
extern void ClearBuffers(CompParam_t *Comp);
extern int  FillInputBuffer(int EOF_OK, CompParam_t *Comp);
extern CompressStatus_t FlushOutputBuffer(CompParam_t *Comp);
extern CompressStatus_t FlushWindow(CompParam_t *Comp);
extern CompressStatus_t WriteBuffer(CompParam_t *Comp, void *Buffer,
                                    unsigned int Count);

    /* in Inflate.c */
extern CompressStatus_t Inflate(CompParam_t *Comp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\comppub.h ===
/*  DEC/CMS REPLACEMENT HISTORY, Element CompPub.H */
/*  *1    14-NOV-1996 10:26:09 ANIGBOGU "[113914]Prototype definitions of exported compression/decompression functions" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CompPub.H */
/* PUBLIC FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/CompPub.h
**
**  PURPOSE
**
**    Prototype definitions for the compression/decompression interfaces
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

/* Return codes */
typedef enum {
    COMPRESS_OK,
    BAD_COMPRESSION_LEVEL,
    BAD_MAGIC_HEADER,
    BAD_COMPRESSED_DATA,
    BAD_BLOCK_TYPE,
    BAD_CODE_LENGTHS,
    BAD_INPUT,
    EXTRA_BITS,
    UNKNOWN_COMPRESSION_METHOD,
    INCOMPLETE_CODE_SET,
    END_OF_BLOCK,
    BLOCK_VANISHED,
    FORMAT_VIOLATED,
    CRC_ERROR,
    LENGTH_ERROR,
    INSUFFICIENT_MEMORY
} CompressStatus_t;

#ifdef __cplusplus
extern "C" {
#endif
    CompressStatus_t     Compress(unsigned char  *Input,
                                     unsigned int    InputSize,
                                     unsigned char **Output,
                                     unsigned int   *OutputSize,
                                     unsigned int    CompLevel);

    CompressStatus_t     Decompress(unsigned char   *Input,
                                       unsigned int     InputSize,
                                       unsigned char  **Output,
                                       unsigned int    *OutputSize);

    void                 TranslateErrorMsg(char              *Message,
                                              CompressStatus_t   ErrorCode);

    void                *CompressMalloc(unsigned int      Size,
                                           CompressStatus_t *ErrorCode);

    void                 CompressFree(void   *Address);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\slbzip.h ===
// slbZip.h
//
// Purpose: fn prototypes for public compression/decompression routines

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1997. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.

#ifndef SLBZIP_H

#define SLBZIP_H

void __stdcall CompressBuffer(BYTE *pData, UINT uDataLen, BYTE **ppCompressedData, UINT * puCompressedDataLen);
void __stdcall DecompressBuffer(BYTE *pData, UINT uDataLen, BYTE **ppDecompressedData, UINT * puDecompressedDataLen);

#endif /* SLBZIP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\compress.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element COMPRESS.C */
/*  *1    14-NOV-1996 10:25:46 ANIGBOGU "[113914]Entry to compression/decompression library via Compress/Decompress" */
/*  DEC/CMS REPLACEMENT HISTORY, Element COMPRESS.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                             All Rights Reserved.
**
******************************************************************************
**
**  compress/compress.c
**
**  PURPOSE
**
** Compress/Decompress files with zip/unzip algorithm.
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/


/* Compress files with zip algorithm and 'compress' interface.
 *
 */

#include "comppriv.h"

/* ========================================================================
 * Check the magic number of the input buffer.
 * Return the compression method, -1 for error.
 */

int
GetMethod(
          CompParam_t *Comp,
          CompressStatus_t *Status
         )
{
    char Magic[2]; /* magic header */
    int  Method;    /* compression method */

    Magic[0] = (char)GetByte(Comp);
    Magic[1] = (char)GetByte(Comp);

    Comp->HeaderBytes = 0;

   if (memcmp(Magic, GZIP_MAGIC, 2) == 0)
   {
       Method = (int)GetByte(Comp);
       if (Method != DEFLATED && Method != STORED)
       {
           *Status = UNKNOWN_COMPRESSION_METHOD;
           return -1;
       }

       (void)GetByte(Comp);  /* Ignore flags */
       (void)GetByte(Comp);  /* Ignore stamp */
       (void)GetByte(Comp);  /*     ,,     */
       (void)GetByte(Comp);  /*     ,,     */
       (void)GetByte(Comp);  /*     ,,     */
       (void)GetByte(Comp);  /* Ignore extra flags for the moment */
       (void)GetByte(Comp);  /* Ignore OS type for the moment */

       Comp->HeaderBytes = Comp->Index + 2*sizeof(long); /* include crc and size */

    }
    else
    {
        *Status = BAD_MAGIC_HEADER;
        return -1;
    }

    return Method;
}

/* ========================================================================
 * Compress input
 */
CompressStatus_t
Compress(
         unsigned char  *Input,
         unsigned int    InputSize,
         unsigned char **Output,
         unsigned int   *OutputSize,
         unsigned int    Level /* compression level */
        )
{
    int                 Length;
    CompData_t         *Ptr;
    CompParam_t        *Comp;
    CompressStatus_t    Status;

    Comp = (CompParam_t *)CompressMalloc(sizeof(CompParam_t), &Status);
    if (Status != COMPRESS_OK)
        return Status;

    Crc32 crcGenerator(0);                        // for backward compatibility
    Comp->pCRC = &crcGenerator;

    Length = FillBuffer(Input, InputSize, Comp);

    /* Do the compression
     */

    if ((Status = Zip((int)Level, Comp)) != COMPRESS_OK)
    {
        CompressFree(Comp);
        return Status;
    }

    *OutputSize = Comp->BytesOut;

    *Output = (unsigned char *)CompressMalloc(*OutputSize, &Status);
    if (Status != COMPRESS_OK)
    {
        CompressFree(Comp);
        return Status;
    }

    Length = 0;
    while (Comp->PtrOutput != NULL)
    {
        Ptr = Comp->PtrOutput;
        memcpy((char *)*Output+Length, (char *)Comp->PtrOutput->Data,
               Comp->PtrOutput->Size);
        Length += Comp->PtrOutput->Size;
        Comp->PtrOutput = Comp->PtrOutput->next;
        CompressFree(Ptr->Data);
        CompressFree(Ptr);
    }
    CompressFree(Comp);

    return COMPRESS_OK;
}


/* ========================================================================
 * Decompress input
 */
CompressStatus_t
Decompress(
           unsigned char  *Input,
           unsigned int    InputSize,
           unsigned char **Output,
           unsigned int   *OutputSize
          )
{
    int                 Length;
    int                 Method;
    CompData_t         *Ptr;
    CompParam_t        *Comp;
    CompressStatus_t    Status;

    Comp = (CompParam_t *)CompressMalloc(sizeof(CompParam_t), &Status);
    if (Status != COMPRESS_OK)
        return Status;

    Crc32 crcGenerator(0);                        // for backward compatibility
    Comp->pCRC = &crcGenerator;

    Length = FillBuffer(Input, InputSize, Comp);

    /* Do the decompression
     */

    Method = GetMethod(Comp, &Status);
    if (Status != COMPRESS_OK)
    {
        CompressFree(Comp);
        return Status;
    }

    if ((Status = Unzip(Method, Comp)) != COMPRESS_OK)
    {
       CompressFree(Comp);
        return Status;
    }
    *OutputSize = Comp->BytesOut;

    *Output = (unsigned char *)CompressMalloc(*OutputSize, &Status);
    if (Status != COMPRESS_OK)
    {
        CompressFree(Comp);
        return Status;
    }
    Length = 0;
    while (Comp->PtrOutput != NULL)
    {
        Ptr = Comp->PtrOutput;
        memcpy((char *)*Output+Length, (char *)Comp->PtrOutput->Data,
               Comp->PtrOutput->Size);
        Length += Comp->PtrOutput->Size;
        Comp->PtrOutput = Comp->PtrOutput->next;
        CompressFree(Ptr->Data);
        CompressFree(Ptr);
    }
    CompressFree(Comp);

    return COMPRESS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\slbzip.cpp ===
// slbZip.cpp
//
// Purpose: implement the public fns exported by this library

// (c) Copyright Schlumberger Technology Corp., unpublished work, created
// 1997. This computer program includes Confidential, Proprietary
// Information and is a Trade Secret of Schlumberger Technology Corp. All
// use, disclosure, and/or reproduction is prohibited unless authorized
// in writing.  All Rights Reserved.


#include <basetsd.h>
#include <windows.h>
#include <stdlib.h>
#include "slbZip.h"
#include "comppub.h"

namespace
{
    DWORD
    AsError(CompressStatus_t cs)
    {
        if (INSUFFICIENT_MEMORY == cs)
            return E_OUTOFMEMORY;
        else
            return ERROR_INVALID_PARAMETER;
    }

    struct AutoLPBYTE
    {
        explicit
        AutoLPBYTE(LPBYTE p = 0)
            : m_p(p)
        {}

        ~AutoLPBYTE()
        {
            if (m_p)
                free(m_p);
        }

        LPBYTE m_p;
    };
} // namespace

void __stdcall CompressBuffer(
                    BYTE *pData,
                    UINT uDataLen,
                    BYTE **ppCompressedData,
                    UINT * puCompressedDataLen)
{
    AutoLPBYTE alpTemp;
    UINT uTempLen = 0;

    // Check parameters
    if(NULL==pData)
        throw ERROR_INVALID_PARAMETER;

    if(NULL==ppCompressedData)
        throw ERROR_INVALID_PARAMETER;

    if(NULL==puCompressedDataLen)
        throw ERROR_INVALID_PARAMETER;

    // Reset compressed data len
    *puCompressedDataLen = 0;

    // Compress the data
    CompressStatus_t cs =
        Compress(pData, uDataLen, &alpTemp.m_p, &uTempLen, 9);
    if (COMPRESS_OK != cs)
    {
        DWORD Error = AsError(cs);
        throw Error;
    }

    // Create a task memory bloc
    AutoLPBYTE
        alpCompressedData(reinterpret_cast<LPBYTE>(malloc(uTempLen)));
    if (0 == alpCompressedData.m_p)
        throw static_cast<HRESULT>(E_OUTOFMEMORY);

    // Copy the data to the created memory bloc
    CopyMemory(alpCompressedData.m_p, alpTemp.m_p, uTempLen);

    // Transfer ownership
    *ppCompressedData = alpCompressedData.m_p;
    alpCompressedData.m_p = 0;

    // Update the compressed data len
    *puCompressedDataLen = uTempLen;
}

void __stdcall DecompressBuffer(BYTE *pData,
                      UINT uDataLen,
                      BYTE **ppDecompressedData,
                      UINT * puDecompressedDataLen)
{
    AutoLPBYTE alpTemp;
    UINT uTempLen = 0;

    // Check parameters
    if(NULL==pData)
        throw ERROR_INVALID_PARAMETER;

    if(NULL==ppDecompressedData)
        throw ERROR_INVALID_PARAMETER;

    if(NULL==puDecompressedDataLen)
        throw ERROR_INVALID_PARAMETER;

    // Reset decompressed data len
    *puDecompressedDataLen = 0;

    // Decompress the data
    CompressStatus_t cs =
        Decompress(pData, uDataLen, &alpTemp.m_p, &uTempLen);
    if (COMPRESS_OK != cs)
    {
        DWORD Error = AsError(cs);
        throw Error;
    }

    // Create a task memory bloc
    AutoLPBYTE
        alpDecompressedData(reinterpret_cast<LPBYTE>(malloc(uTempLen)));
    if (0 == alpDecompressedData.m_p)
        throw static_cast<HRESULT>(E_OUTOFMEMORY);

    // Copy the data to the created memory bloc
    CopyMemory(alpDecompressedData.m_p, alpTemp.m_p, uTempLen);

    // Transfer ownership
    *ppDecompressedData = alpDecompressedData.m_p;
    alpDecompressedData.m_p = 0;

    // Update the compressed data len
    *puDecompressedDataLen = uTempLen;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\inflate.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element INFLATE.C */
/*  *1    14-NOV-1996 10:26:23 ANIGBOGU "[113914]Data decompression functions using the inflate algorithm" */
/*  DEC/CMS REPLACEMENT HISTORY, Element INFLATE.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Tehnology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/inflate.c
**
**  PURPOSE
**
**
**
**   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
**   method searches for as much of the current string of bytes (up to a
**   length of 258) in the previous 32K bytes  If it doesn't find any
**   matches (of at least length 3), it codes the next byte.  Otherwise, it
**   codes the length of the matched string and its distance backwards from
**   the current position.  There is a single Huffman code that codes both
**   single bytes (called "literals") and match lengths.  A second Huffman
**   code codes the distance information, which follows a length code.  Each
**   length or distance code actually represents a base value and a number
**   of "extra" (sometime zero) bits to get to add to the base value.  At
**   the end of each deflated block is a special end-of-block (EOB) literal/
**   length code.  The decoding process is basically: get a literal/length
**   code; if EOB then done; if a literal, emit the decoded byte; if a
**   length then get the distance and emit the referred-to bytes from the
**   sliding window of previously emitted data.
**
**   There are (currently) three kinds of inflate blocks: stored, fixed, and
**   dynamic.  The compressor deals with some chunk of data at a time, and
**   decides which method to use on a chunk-by-chunk basis.  A chunk might
**   typically be 32K or 64K.  If the chunk is uncompressible, then the
**   "stored" method is used.  In this case, the bytes are simply stored as
**   is, eight bits per byte, with none of the above coding.  The bytes are
**   preceded by a count, since there is no longer an EOB code.
**
**   If the data is compressible, then either the fixed or dynamic methods
**   are used.  I the dynamic method, the compressed data is preceded by
**   an encoding of the literal/length and distance Huffman codes that are
**   to be used to decode this block.  The representation is itself Huffman
**   coded, and so is preceded by a description of that code.  These code
**   descriptions take up a little space, and so for small blocks, there is
**   a predefined set of codes, called the fixed codes.  The fixed method is
**   used if the block codes up smaller that way (usually for quite small
**   chunks), otherwise the dynamic method is used.  In the latter case, the
**   codes are customized to the probabilities in the current block, and so
**   can code it much better than the pre-determined fixed codes.
**
**   The Huffman codes themselves are decoded using a multi-level table
**   lookup, in order to maximize the speed of decoding plus the speed of
**   building the decoding tables.  See the comments below that precede the
**   LBits and DBits tuning parameters.
**
**  SPECIALREQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

/*
   Notes beyond the 193a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarly, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), wheras to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
     . 258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */

#include "comppriv.h"

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model).
   Valid extra bits are 0..13.  Extra == 15 is EOB (end of block), Extra == 16
   means that HuftUnion is a literal, 16 < Extra < 32 means that HuftUnion is
   a pointer to the next table, which codes Extra - 16 bits, and lastly
   Extra == 99 indicates an unused code.  If a code with Extra == 99 is looked
   up, this implies an error in the data.
*/

typedef struct HuffmanTree
{
    unsigned char Extra;       /* number of extra bits or operation */
    unsigned char Bits;        /* number of bits in this code or subcode */
    union
    {
        unsigned short LBase;  /* literal, length base, or distance base */
        struct HuffmanTree *next;     /* pointer to next level of table */
    } HuftUnion;
} HuffmanTree_t;


/* Function prototypes */
int BuildHuffmanTree(unsigned int *, unsigned int, unsigned int,
               unsigned short *, unsigned short *,
               HuffmanTree_t **, int *);
void FreeHuffmanTree(HuffmanTree_t *);
CompressStatus_t InflateCodes(HuffmanTree_t *, HuffmanTree_t *, int, int,
                 CompParam_t *Comp);
CompressStatus_t InflateStored(CompParam_t *Comp);
int InflateFixed(CompParam_t *Comp);
CompressStatus_t InflateDynamic(CompParam_t *Comp);
CompressStatus_t InflateBlock(int *, CompParam_t *Comp);


/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
   stream to find repeated byte strings.  This is implemented here as a
   circular buffer.  The index is updated simply by incrementing and then
   and'ing with 0x7fff (32K-1). */
/* It is left to other modules to supply the 32K area.  It is assumed
   to be usable as if it were declared "unsigned char slide[32768];" or as just
   "unsigned char *slide;" and then malloc'ed in the latter case. */
/* unsigned c->OutBytes;             current position in slide */
#define FlushOutput(w,c) (c->OutBytes = (w),FlushWindow(c))

/* Tables for deflate from PKZIP's appnote.txt. */
static unsigned int Border[] =
{    /* Order of the bit length code lengths */
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
};

static unsigned short CopyLengths[] =
{         /* Copy lengths for literal codes 257..285 */
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
};

/* note: see note #13 above about the 258 in this list. */
static unsigned short CopyExtraBits[] =
{         /* Extra bits for literal codes 257..285 */
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
}; /* 99==invalid */

static unsigned short CopyDistOffset[] =
{         /* Copy offsets for distance codes 0..29 */
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577
};

static unsigned short CopyDistExtra[] =
{         /* Extra bits for distance codes */
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
    12, 12, 13, 13
};

/* Macros for Inflate() bit peeking and grabbing.
   The usage is:

        NEEDBITS(j,comp)
        x = b & MaskBits[j];
        DUMPBITS(j)

   where NEEDBITS makes sure that b has at least j bits in it, and
   DUMPBITS removes the bits from b.  The macros use the variable k
   for the number of bits in b.  Normally, b and k are register
   variables for speed, and are initialized at the beginning of a
   routine that uses these macros from a global bit buffer and count.

   If we assume that EOB will be the longest code, then we will never
   ask for bits with NEEDBITS that are beyond the end of the stream.
   So, NEEDBITS should not read any more bytes than are needed to
   meet the request.  Then no bytes need to be "returned" to the buffer
   at the end of the last block.

   However, this assumption is not true for fixed blocks--the EOB code
   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
   (The EOB code is shorter than other codes because fixed blocks are
   generally short.  So, while a block always has an EOB, many other
   literal/length codes have a significantly lower probability of
   showing up at all.)  However, by making the first table have a
   lookup of seven bits, the EOB code will be found in that first
   lookup, and so will not require tat too many bits be pulled from
   the stream.
 */

unsigned short MaskBits[] =
{
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};

#define NEXTBYTE(c)  (unsigned char)GetByte(c)
#define NEEDBITS(n,c) {while (LocalBitBufferSize < (n)) \
{ LocalBitBuffer |= ((unsigned long)NEXTBYTE(c))<< LocalBitBufferSize; \
LocalBitBufferSize += 8; }}
#define DUMPBITS(n) {LocalBitBuffer >>= (n); LocalBitBufferSize -= (n);}

/*
   Huffmancode decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probabl codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   The results of this trade are in the variables LBits and DBits
   below.  LBits is the number of bits the first level table for literal/
   length codes can decode in one step, and DBits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may b adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so LBits is 8+1 and DBits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */

int LBits = 9;          /* bits in base literal/length lookup table */
int DBits = 6;          /* bits in base distance lookup table */

/* If BMAX needs to be larger than 16, then h and x[] should be unsigned long. */
#define BMAX 16         /* maximum bit length of any code (16 for explode) */
#define N_MAX 288       /* maximum number of codes in any set */

unsigned int HuftMemory;    /* track memory usage */

int
BuildHuffmanTree(
                 unsigned int    *CodeLengths, /* code lengths in bits (all assumed <= BMAX) */
                 unsigned int     Codes,       /* number of codes (assumed <= N_MAX) */
                 unsigned int     SimpleCodes, /* number of simple-valued codes (0..s-1) */
                 unsigned short  *BaseValues,  /* list of base values for non-simple codes */
                 unsigned short  *ExtraBits,   /* list of extra bits for non-simple codes */
                 HuffmanTree_t  **StartTable,  /* result: starting table */
                 int             *MaxBits      /* maximum lookup bits, returns actual */
                )
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return zero on success, one if
   the given code set is incomplete (the tables are still built in this
   case), two if the input is invalid (all zero length codes or an
   oversubscribed set of lengths), and three if not enough memory. */
{
    unsigned int    CodeCounter;         /* counter for codes of length k */
    unsigned int    CurrentCount;        /* counter, current code */
    unsigned int    LengthTable[BMAX+1]; /* bit length count table */
    unsigned int    CurrentTotal;  /* CurrentCount repeats in table every CurrentTotal entries*/
    unsigned int    MaxCodeLength;       /* maximum code length */
    int             TableLevel;
    unsigned int    Counter;
    unsigned int    CurrentBitCount;  /* number of bits in current code */
    unsigned int    BitsPerTable;     /* bits per table (returned in MaxBits) */
    unsigned int   *Pointer;          /* pointer into LengthTable[], CodeLengths[], or BitValues[] */
    HuffmanTree_t  *CurrentPointer;   /* points to current table */
    HuffmanTree_t   TableEntry;       /* table entry for structure assignment */
    HuffmanTree_t  *TableStack[BMAX]; /* table stack */
    unsigned int    BitValues[N_MAX]; /* values in order of bit length */
    int             BitsBeforeTable;  /* bits before this table == (BitsPerTable * TableLevel) */
    unsigned int    BitOffsets[BMAX+1]; /* bit offsets, then code stack */
    unsigned int   *BitOffsetsPointer;  /* pointer into BitOffsets */
    int             DummyCodes;         /* number of dummy codes added */
    unsigned int    TableSize;          /* number of entries in current table */
    unsigned int    TmpDummyCodes;      /* unsigned DummyCodes */
    CompressStatus_t  Status;

    /* Generate counts for each bit length */
    memzero(LengthTable, sizeof(LengthTable));
    Pointer = CodeLengths;
    CurrentCount = Codes;
    do
    {
        LengthTable[*Pointer]++;   /* assume all entries <= BMAX */
        Pointer++;                 /* Can't combine with above line (Solaris bug) */
    } while (--CurrentCount);

    if (LengthTable[0] == Codes)   /* null input--all zero length codes */
    {
        *StartTable = (HuffmanTree_t *)NULL;
        *MaxBits = 0;
        return COMPRESS_OK;
    }

    /* Find minimum and maximum length, bound *MaxBits by those */
    BitsPerTable = (unsigned int)*MaxBits;
    for (Counter = 1; Counter <= BMAX; Counter++)
        if (LengthTable[Counter])
            break;
    CurrentBitCount = Counter;                        /* minimum code length */
    if (BitsPerTable < Counter)
        BitsPerTable = Counter;
    for (CurrentCount = BMAX; CurrentCount; CurrentCount--)
        if(LengthTable[CurrentCount])
            break;
    MaxCodeLength = CurrentCount;                     /* maximum code length */
    if ((unsigned int)BitsPerTable > CurrentCount)
        BitsPerTable = CurrentCount;
    *MaxBits = (int)BitsPerTable;

    /* Adjust last length count to fill out codes, if needed */
    for (TmpDummyCodes = 1 << Counter; Counter < CurrentCount; Counter++, TmpDummyCodes <<= 1)
    {
        DummyCodes = (int)TmpDummyCodes;
        if ((DummyCodes -= (int)LengthTable[Counter]) < 0)
            return BAD_INPUT;                 /* bad input: more codes than bits */
        TmpDummyCodes = (unsigned int)DummyCodes;
    }

    DummyCodes = (int)TmpDummyCodes;
    if ((DummyCodes -= (int)LengthTable[CurrentCount]) < 0)
        return BAD_INPUT;
    LengthTable[CurrentCount] += (unsigned int)DummyCodes;

    /* Generate starting offsets into the value table for each length */
    BitOffsets[1] = Counter = 0;
    Pointer = LengthTable + 1;
    BitOffsetsPointer = BitOffsets + 2;
    while (--CurrentCount)
    {        /* note that CurrentCount == MaxCodeLength from above */
        *BitOffsetsPointer++ = (Counter += *Pointer++);
    }

    /* Make a table of values in order of bit lengths */
    Pointer = CodeLengths;
    CurrentCount = 0;
    do
    {
        if ((Counter = *Pointer++) != 0)
            BitValues[BitOffsets[Counter]++] = CurrentCount;
    } while (++CurrentCount < Codes);

    /* Generate the Huffman codes and for each, make the table entries */
    BitOffsets[0] = CurrentCount = 0;  /* first Huffman code is zero */
    Pointer = BitValues;               /* grab values in bit order */
    TableLevel = -1;                   /* no tables yet--level -1 */
    BitsBeforeTable = -(int)BitsPerTable; /* bits decoded == (BitsPerTable * TableLevel) */
    TableStack[0] = (HuffmanTree_t *)NULL; /* just to keep compilers happy */
    CurrentPointer = (HuffmanTree_t *)NULL;/* ditto */
    TableSize = 0;                         /* ditto */

    /* go through the bit lengths (CurrentBitCount already is bits in shortest code) */
    for (; CurrentBitCount <= MaxCodeLength; CurrentBitCount++)
    {
        CodeCounter = LengthTable[CurrentBitCount];
        while (CodeCounter--)
        {
            /* here MaxCodeLength is the Huffman code of length CurrentBitCount bits */
            /* for value *p. make tables up to required level */
            while (CurrentBitCount > (unsigned int)BitsBeforeTable + BitsPerTable)
            {
                TableLevel++;
                BitsBeforeTable += (int)BitsPerTable; /* previous table always BitsPerTable bits */

                /* compute minimum size table less than or equal to BitsPerTable bits */
                TableSize = (TableSize = MaxCodeLength - (unsigned int)BitsBeforeTable) >
                    (unsigned int)BitsPerTable ? BitsPerTable : TableSize;
                /* upper limit on table size */
                if ((CurrentTotal = 1 << (Counter = CurrentBitCount -
                    (unsigned int)BitsBeforeTable)) > CodeCounter + 1)
                /* try a CurrentBitCount-BitsBeforeTable bit table */
                {   /* too few codes for CurrentBitCount-BitsBeforeTable bit table */
                    CurrentTotal -= CodeCounter + 1; /* deduct codes from patterns left */
                    BitOffsetsPointer = LengthTable + CurrentBitCount;
                    while (++Counter < TableSize) /* try smaller tables up to TableSize bits */
                    {
                        if ((CurrentTotal <<= 1) <= *++BitOffsetsPointer)
                            break;        /* enough codes to use up j bits */
                        CurrentTotal -= *BitOffsetsPointer; /* else deduct codes from patterns */
                    }
                }
                TableSize = 1 << Counter;  /* table entries for Counter-bit table */

                /* allocate and link in new table */
                if ((CurrentPointer = (HuffmanTree_t *)CompressMalloc((TableSize + 1)*sizeof(HuffmanTree_t),
                    &Status)) == (HuffmanTree_t *)NULL)
                {
                    if (TableLevel)
                        FreeHuffmanTree(TableStack[0]);
                    return INSUFFICIENT_MEMORY;             /* not enough memory */
                }
                HuftMemory += TableSize + 1;         /* track memory usage */
                *StartTable = CurrentPointer + 1;             /* link to list for FreeHuffmanTree() */
                *(StartTable = &(CurrentPointer->HuftUnion.next)) = (HuffmanTree_t *)NULL;
                TableStack[TableLevel] = ++CurrentPointer;             /* table starts after link */

                /* connect to last table, if there is one */
                if (TableLevel)
                {
                    BitOffsets[TableLevel] = CurrentCount;             /* save pattern for backing up */
                    TableEntry.Bits = (unsigned char)BitsPerTable;     /* bits to dump before this table */
                    TableEntry.Extra = (unsigned char)(16 + Counter);  /* bits in this table */
                    TableEntry.HuftUnion.next = CurrentPointer;            /* pointer to this table */
                    Counter = CurrentCount >> ((unsigned int)BitsBeforeTable - BitsPerTable);
                    TableStack[TableLevel-1][Counter] = TableEntry;        /* connect to last table */
                }
            }

            /* set up table entry in r */
            TableEntry.Bits = (unsigned char)(CurrentBitCount - (unsigned int)BitsBeforeTable);
            if (Pointer >= BitValues + Codes)
                TableEntry.Extra = 99;               /* out of values--invalid code */
            else if (*Pointer < SimpleCodes)
            {
                TableEntry.Extra = (unsigned char)(*Pointer < 256 ? 16 : 15); /* 256 is end-of-block code */
                TableEntry.HuftUnion.LBase = (unsigned short)(*Pointer);       /* simple code is just the value */
                Pointer++;                     /* one compiler does not like *Pointer++ */
            }
            else
            {
                /* non-simple--look up in lists */
                TableEntry.Extra = (unsigned char)ExtraBits[*Pointer - SimpleCodes];
                TableEntry.HuftUnion.LBase = BaseValues[*Pointer++ - SimpleCodes];
            }

            /* fill code-like entries with TableEntry */
            CurrentTotal = 1 << (CurrentBitCount - (unsigned int)BitsBeforeTable);
            for (Counter = CurrentCount >> BitsBeforeTable; Counter < TableSize; Counter += CurrentTotal)
                CurrentPointer[Counter] = TableEntry;

            /* backwards increment the CurrentBitCount - bit code i */
            for (Counter = 1 << (CurrentBitCount - 1); CurrentCount & Counter; Counter >>= 1)
                CurrentCount ^= Counter;
            CurrentCount ^= Counter;

            /* backup over finished tables */
            while ((CurrentCount & ((1 << BitsBeforeTable) - 1)) != BitOffsets[TableLevel])
            {
                TableLevel--;                    /* don't need to update CurrentPointer */
                BitsBeforeTable -= (int)BitsPerTable;
            }
        }
    }

    /* Return true (1) if we were given an incomplete table */
    return DummyCodes != 0 && MaxCodeLength != 1;
}

void
FreeHuffmanTree(
                HuffmanTree_t *Table         /* table to free */
               )
/* Free the malloc'ed tables built by BuildHuffmanTree(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
    HuffmanTree_t *Pointer, *CurrentPointer;

    /* Go through linked list, freeing from the malloc'd (t[-1]) address. */
    Pointer = Table;
    while (Pointer != (HuffmanTree_t *)NULL)
    {
        CurrentPointer = (--Pointer)->HuftUnion.next;
        CompressFree((char *)Pointer);
        Pointer = CurrentPointer;
    }
}

CompressStatus_t
InflateCodes(
             HuffmanTree_t *LitLengthTable,
             HuffmanTree_t *DistCodeTable, /* literal/length and dist. decoder tables */
             int            LLTLookup,
             int            DCTLookup, /* number of bits decoded by LitLengthTable[] and DistCodeTable[] */
             CompParam_t   *Comp
            )
/* inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok. */
{
    unsigned int    ExtraBits;  /* table entry flag/number of extra bits */
    unsigned int    Length, Index;    /* length and index for copy */
    unsigned int    WindowPosition;   /* current window position */
    HuffmanTree_t  *TableEntry;       /* pointer to table entry */
    unsigned int    LLTLookupMask, DCTLookupMask; /* masks for LLT and DCT bits */
    unsigned long   LocalBitBuffer;     /* bit buffer */
    unsigned int    LocalBitBufferSize; /* number of bits in bit buffer */

    /* make local copies of globals */
    LocalBitBuffer = Comp->BitBuffer;            /* initialize bit buffer */
    LocalBitBufferSize = Comp->BitsInBitBuffer;
    WindowPosition = Comp->OutBytes;             /* initialize window position */

    /* inflate the coded data */
    LLTLookupMask = MaskBits[LLTLookup];           /* precompute masks for speed */
    DCTLookupMask = MaskBits[DCTLookup];
    for (;;)                      /* do until end of block */
    {
        NEEDBITS((unsigned int)LLTLookup, Comp)
        if ((ExtraBits = (TableEntry = LitLengthTable +
            ((unsigned int)LocalBitBuffer & LLTLookupMask))->Extra) > 16)
        do
        {
            if (ExtraBits == 99)
                return EXTRA_BITS;
            DUMPBITS(TableEntry->Bits)
            ExtraBits -= 16;
            NEEDBITS(ExtraBits, Comp)
        } while ((ExtraBits = (TableEntry = TableEntry->HuftUnion.next +
                 ((unsigned int)LocalBitBuffer & MaskBits[ExtraBits]))->Extra) > 16);
        DUMPBITS(TableEntry->Bits)
        if (ExtraBits == 16)                /* then it's a literal */
        {
            Comp->Window[WindowPosition++] = (unsigned char)TableEntry->HuftUnion.LBase;
            if (WindowPosition == WSIZE)
            {
                CompressStatus_t Status;
                Status = FlushOutput(WindowPosition, Comp);
                if (COMPRESS_OK != Status)
                    return Status;

                WindowPosition = 0;
            }
        }
        else                        /* it's an EOF or a length */
        {
            /* exit if end of block */
            if (ExtraBits == 15)
                break;

            /* get length of block tocopy */
            NEEDBITS(ExtraBits, Comp)
            Length = TableEntry->HuftUnion.LBase +
                     ((unsigned int)LocalBitBuffer & MaskBits[ExtraBits]);
            DUMPBITS(ExtraBits)

            /* decode distance of block to copy */
            NEEDBITS((unsigned int)DCTLookup, Comp)
            if ((ExtraBits = (TableEntry = DistCodeTable +
                ((unsigned int)LocalBitBuffer & DCTLookupMask))->Extra) > 16)
            do
            {
                if (ExtraBits == 99)
                    return EXTRA_BITS;
                DUMPBITS(TableEntry->Bits)
                ExtraBits -= 16;
                NEEDBITS(ExtraBits, Comp)
            } while ((ExtraBits = (TableEntry = TableEntry->HuftUnion.next +
                     ((unsigned int)LocalBitBuffer & MaskBits[ExtraBits]))->Extra) > 16);
            DUMPBITS(TableEntry->Bits)
            NEEDBITS(ExtraBits, Comp)
            Index = WindowPosition - TableEntry->HuftUnion.LBase -
                                 ((unsigned int)LocalBitBuffer & MaskBits[ExtraBits]);
            DUMPBITS(ExtraBits)

            /* do the copy */
            do
            {
                Length -= (ExtraBits = (ExtraBits = WSIZE - ((Index &= WSIZE-1) >
                    WindowPosition ? Index : WindowPosition)) > Length ? Length : ExtraBits);

                if (WindowPosition - Index >= ExtraBits) /* (this test assumes unsigned comparison) */
                {
                    memcpy((char *)Comp->Window + WindowPosition,
                           (char *)Comp->Window + Index, (int)ExtraBits);
                    WindowPosition += ExtraBits;
                    Index += ExtraBits;
                }
                else    /* do it slow to avoid memcpy() overlap */
                    do
                    {
                        Comp->Window[WindowPosition++] = Comp->Window[Index++];
                    } while (--ExtraBits);
                if (WindowPosition == WSIZE)
                {
                    CompressStatus_t Status;
                    Status = FlushOutput(WindowPosition, Comp);
                    if (COMPRESS_OK != Status)
                        return Status;

                    WindowPosition = 0;
                }
            } while (Length);
        }
    }


    /* restore the globals from the locals */
    Comp->OutBytes = WindowPosition;        /* restore global window pointer */
    Comp->BitBuffer = LocalBitBuffer;       /* restore global bit buffer */
    Comp->BitsInBitBuffer = LocalBitBufferSize;

    /* done */
    return COMPRESS_OK;
}

CompressStatus_t
InflateStored(
              CompParam_t *Comp
             )
/* "decompress" an inflated type 0 (stored) block. */
{
    unsigned int  BytesInBlock;       /* number of bytes in block */
    unsigned int  WindowPosition;     /* current window position */
    unsigned long LocalBitBuffer;     /* bit buffer */
    unsigned int  LocalBitBufferSize; /* number of bits in bit buffer */

    /* make local copies of globals */
    LocalBitBuffer = Comp->BitBuffer;   /* initialize bit buffer */
    LocalBitBufferSize = Comp->BitsInBitBuffer;
    WindowPosition = Comp->OutBytes;             /* initialize window position */


    /* go to byte boundary */
    BytesInBlock = LocalBitBufferSize & 7;
    DUMPBITS(BytesInBlock)


    /* get the length and its complement */
    NEEDBITS(16, Comp)
    BytesInBlock = ((unsigned int)LocalBitBuffer & 0xffff);
    DUMPBITS(16)
    NEEDBITS(16, Comp)
    if (BytesInBlock != (unsigned int)((~LocalBitBuffer) & 0xffff))
        return BAD_COMPRESSED_DATA;                   /* error in compressed data */
    DUMPBITS(16)

    /* read and output the compressed data */
    while (BytesInBlock--)
    {
        NEEDBITS(8, Comp)
        Comp->Window[WindowPosition++] = (unsigned char)LocalBitBuffer;
        if (WindowPosition == WSIZE)
        {
            CompressStatus_t Status;
            Status = FlushOutput(WindowPosition, Comp);
            if (COMPRESS_OK != Status)
                return Status;

            WindowPosition = 0;
        }
        DUMPBITS(8)
    }

    /* restore the globals from the locals */
    Comp->OutBytes = WindowPosition;         /* restore global window pointer */
    Comp->BitBuffer = LocalBitBuffer;            /* restore global bit buffer */
    Comp->BitsInBitBuffer = LocalBitBufferSize;
    return COMPRESS_OK;
}

int
InflateFixed(
             CompParam_t *Comp
            )
/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
   either replace this with a custom decoder, or at least precompute the
   Huffman tables. */
{
    int             Index;          /* temporary variable */
    HuffmanTree_t  *LitLengthTable; /* literal/length code table */
    HuffmanTree_t  *DistCodeTable;  /* distance code table */
    int             LLTLookup;      /* lookup bits for LitLengthTable */
    int             DCTLookup;      /* lookup bits for DistCodeTable */
    unsigned int    Length[288];    /* length list for BuildHuffmanTree */

    /* set up literal table */
    for (Index = 0; Index < 144; Index++)
        Length[Index] = 8;
    for (; Index < 256; Index++)
        Length[Index] = 9;
    for (; Index < 280; Index++)
        Length[Index] = 7;
    for (; Index < 288; Index++)          /* make a complete, but wrong code set */
        Length[Index] = 8;
    LLTLookup = 7;

    if ((Index = BuildHuffmanTree(Length, 288, 257, CopyLengths,
         CopyExtraBits, &LitLengthTable, &LLTLookup)) != 0)
        return Index;

    /* set up distance table */
    for (Index = 0; Index < 30; Index++)      /* make an incomplete code set */
        Length[Index] = 5;
    DCTLookup = 5;
    if ((Index = BuildHuffmanTree(Length, 30, 0, CopyDistOffset, CopyDistExtra,
        &DistCodeTable, &DCTLookup)) > 1)
    {
        FreeHuffmanTree(LitLengthTable);
        return Index;
    }

    /* decompress until an end-of-block code */
    if (InflateCodes(LitLengthTable, DistCodeTable, LLTLookup, DCTLookup, Comp))
        return END_OF_BLOCK;

    /* free the decoding tables, return */
    FreeHuffmanTree(LitLengthTable);
    FreeHuffmanTree(DistCodeTable);
    return static_cast<int>(COMPRESS_OK);
}

CompressStatus_t
InflateDynamic(
               CompParam_t *Comp
              )
/* decompress an inflated type 2 (dynamic Huffman codes) block. */
{
    int             TmpVar1;     /* temporary variables */
    unsigned int    TmpVar2;
    unsigned int    LastLength;  /* last length */
    unsigned int    TableMask;   /* mask for bit lengths table */
    unsigned int    Lengths;     /* number of lengths to get */
    HuffmanTree_t  *LitLengthTable;     /* literal/length code table */
    HuffmanTree_t  *DistCodeTable;      /* distance code table */
    int             LLTLookup;          /* lookup bits for LitLengthTable */
    int             DCTLookup;          /* lookup bits for DistCodeTable */
    unsigned int    BitCodes;           /* number of bit length codes */
    unsigned int    LitLenCodes;        /* number of literal/length codes */
    unsigned int    DistCodes;          /* number of distance codes */
    unsigned int    CodeLength[286+30]; /* literal/length and distance code lengths */
    unsigned long   LocalBitBuffer;     /* bit buffer */
    unsigned int    LocalBitBufferSize; /* number of bits in bit buffer */

    /* make local bit buffer */
    LocalBitBuffer = Comp->BitBuffer;
    LocalBitBufferSize = Comp->BitsInBitBuffer;

    /* read in table lengths */
    NEEDBITS(5, Comp)
    LitLenCodes = 257 + ((unsigned int)LocalBitBuffer & 0x1f); /* number of literal/length codes */
    DUMPBITS(5)
    NEEDBITS(5, Comp)
    DistCodes = 1 + ((unsigned int)LocalBitBuffer & 0x1f); /* number of distance codes */
    DUMPBITS(5)
    NEEDBITS(4, Comp)
    BitCodes = 4 + ((unsigned int)LocalBitBuffer & 0xf); /* number of bit length codes */
    DUMPBITS(4)
    if (LitLenCodes > 286 || DistCodes > 30)
        return BAD_CODE_LENGTHS;                   /* bad lengths */

    /* read in bit-length-code lengths */
    for (TmpVar2 = 0; TmpVar2 < BitCodes; TmpVar2++)
    {
        NEEDBITS(3, Comp)
        CodeLength[Border[TmpVar2]] = (unsigned int)LocalBitBuffer & 7;
        DUMPBITS(3)
    }

    for (; TmpVar2 < 19; TmpVar2++)
        CodeLength[Border[TmpVar2]] = 0;

    /* build decoding table for trees--single level, 7 bit lookup */
    LLTLookup = 7;
    if ((TmpVar1 = BuildHuffmanTree(CodeLength, 19, 19, NULL, NULL,
        &LitLengthTable, &LLTLookup)) != 0)
    {
        if (TmpVar1 == 1)
            FreeHuffmanTree(LitLengthTable);
        return INCOMPLETE_CODE_SET; /* incomplete code set */
    }

    /* read in literal and distance code lengths */
    Lengths = LitLenCodes + DistCodes;
    TableMask = MaskBits[LLTLookup];
    TmpVar1 = LastLength = 0;
    while ((unsigned int)TmpVar1 < Lengths)
    {
        NEEDBITS((unsigned int)LLTLookup, Comp)
        TmpVar2 = (DistCodeTable = LitLengthTable +
                   ((unsigned int)LocalBitBuffer & TableMask))->Bits;
        DUMPBITS(TmpVar2)
        TmpVar2 = DistCodeTable->HuftUnion.LBase;
        if (TmpVar2 < 16)                 /* length of code in bits (0..15) */
            CodeLength[TmpVar1++] = LastLength = TmpVar2;          /* save last length in l */
        else if (TmpVar2 == 16)           /* repeat last length 3 to 6 times */
        {
            NEEDBITS(2, Comp)
            TmpVar2 = 3 + ((unsigned int)LocalBitBuffer & 3);
            DUMPBITS(2)
            if ((unsigned int)TmpVar1 + TmpVar2 > Lengths)
                return EXTRA_BITS;
            while (TmpVar2--)
                CodeLength[TmpVar1++] = LastLength;
        }
        else if (TmpVar2 == 17)           /* 3 to 10 zero length codes */
        {
            NEEDBITS(3, Comp)
            TmpVar2 = 3 + ((unsigned int)LocalBitBuffer & 7);
            DUMPBITS(3)
            if ((unsigned int)TmpVar1 + TmpVar2 > Lengths)
                return INCOMPLETE_CODE_SET;
            while (TmpVar2--)
            CodeLength[TmpVar1++] = 0;
            LastLength = 0;
        }
        else                        /* TmpVar2 == 18: 11 to 138 zero length codes */
        {
            NEEDBITS(7, Comp)
            TmpVar2 = 11 + ((unsigned int)LocalBitBuffer & 0x7f);
            DUMPBITS(7)
            if ((unsigned int)TmpVar1 + TmpVar2 > Lengths)
                return INCOMPLETE_CODE_SET;
            while (TmpVar2--)
            CodeLength[TmpVar1++] = 0;
            LastLength = 0;
        }
    }

    /* free decoding table for trees */
    FreeHuffmanTree(LitLengthTable);

    /* restore the global bit buffer */
    Comp->BitBuffer = LocalBitBuffer;
    Comp->BitsInBitBuffer = LocalBitBufferSize;

    /* build the decoding tables for literal/length and distance codes */
    LLTLookup = LBits;
    if ((TmpVar1 = BuildHuffmanTree(CodeLength, LitLenCodes, 257,
        CopyLengths, CopyExtraBits, &LitLengthTable, &LLTLookup)) != 0)
    {
        if (TmpVar1 == 1)
        {
            fprintf(stderr, " incomplete literal tree\n");
            FreeHuffmanTree(LitLengthTable);
        }
        return INCOMPLETE_CODE_SET; /* incomplete code set */
    }
    DCTLookup = DBits;
    if ((TmpVar1 = BuildHuffmanTree(CodeLength + LitLenCodes, DistCodes, 0,
        CopyDistOffset, CopyDistExtra, &DistCodeTable, &DCTLookup)) != 0)
    {
        if (TmpVar1 == 1)
        {
            fprintf(stderr, " incomplete distance tree\n");
            FreeHuffmanTree(DistCodeTable);
        }
        FreeHuffmanTree(LitLengthTable);
        return INCOMPLETE_CODE_SET; /* incomplete code set */
    }

    /* decompress until an end-of-block code */
    if (InflateCodes(LitLengthTable, DistCodeTable, LLTLookup, DCTLookup, Comp))
        return END_OF_BLOCK;

    /* free the decoding tables, return */
    FreeHuffmanTree(LitLengthTable);
    FreeHuffmanTree(DistCodeTable);
    return COMPRESS_OK;
}

CompressStatus_t
InflateBlock(
             int         *LastBlock,                 /* last block flag */
             CompParam_t *Comp
            )
/* decompress an inflated block */
{
    unsigned int    BlockType;           /* block type */
    unsigned long   LocalBitBuffer;       /* bit buffer */
    unsigned int    LocalBitBufferSize;  /* number of bits in bit buffer */


    /* make local bit buffer */
    LocalBitBuffer = Comp->BitBuffer;
    LocalBitBufferSize = Comp->BitsInBitBuffer;

    /* read in last block bit */
    NEEDBITS(1, Comp)
    *LastBlock = (int)LocalBitBuffer & 1;
    DUMPBITS(1)


    /* read in block type */
    NEEDBITS(2, Comp)
    BlockType = (unsigned)LocalBitBuffer & 3;
    DUMPBITS(2)


    /* restore the global bit buffer */
    Comp->BitBuffer = LocalBitBuffer;
    Comp->BitsInBitBuffer = LocalBitBufferSize;


    /* inflate that block type */
    if (BlockType == DYN_TREES)
        return InflateDynamic(Comp);
    if (BlockType == STORED_BLOCK)
        return InflateStored(Comp);
    if (BlockType == STATIC_TREES)
        return static_cast<CompressStatus_t>(InflateFixed(Comp));
                                                  // this is an
                                                  // anomaly cast but
                                                  // don't know what
                                                  // else to do.

    /* bad block type */
    return BAD_BLOCK_TYPE;
}

CompressStatus_t
Inflate(
        CompParam_t *Comp
       )
/* decompress an inflated entry */
{
    int             LastBlock;        /* last block flag */
    CompressStatus_t Status;          /* result code */
    unsigned int    MaxHuft;          /* maximum struct huft's malloc'ed */

    /* initialize window, bit buffer */
    Comp->OutBytes = 0;
    Comp->BitsInBitBuffer = 0;
    Comp->BitBuffer = 0;

    /* decompress until the last block */
    MaxHuft = 0;
    do
    {
        HuftMemory = 0;
        if ((Status = InflateBlock(&LastBlock, Comp)) != COMPRESS_OK)
            return Status;
        if (HuftMemory > MaxHuft)
            MaxHuft = HuftMemory;
    } while (!LastBlock);

    /* Undo too much lookahead. The next read will be byte aligned so we
     * can discard unused bits in the last meaningful byte.
     */
    while (Comp->BitsInBitBuffer >= 8)
    {
        Comp->BitsInBitBuffer -= 8;
        Comp->Index--;
    }

    /* flush out slide */
    return FlushOutput(Comp->OutBytes, Comp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\deflate.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element DEFLATE.C */
/*  *1    14-NOV-1996 10:26:16 ANIGBOGU "[113914]Data compression functions using the deflate algorithm" */
/*  DEC/CMS REPLACEMENT HISTORY, Element DEFLATE.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberg.er Technology Cop., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/deflate.c
**
**  PURPOSE
**
** Compress data using the def.lation algorithm.
**      Identify new text as repetitions of old text within a fixed-
**      length sliding window trailing behind the new text.
**
**  DISCUSSION
**
**      The "deflation" process depends on being able to identify portions
**      of the input data which are identical to earlier input (within a
**      sliding window trailing behind the input currently being processed).
**
**      The most straightforward technique turns out to be the fastest for
**      most input files: try all possible matches and select the longest.
**      The key feature of this algorithm is that insertions into the string
**      dictionary are very simple and thus fast, and deletions are avoided
**      completely. Insertions are performed at each input character, whereas
**      string matches are performed only when the previous match ends. So it
**      is preferable to spend more time in matches to allow very fast string
**      insertions and avoid deletions. The matching algorithm for small
**      strings is inspired from that of Rabin & Karp. A brute force approach
**      is used to find longer strings when a small match has been found.
**      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
**      (by Leonid Broukhis).
**         A previous version of this file used a more sophisticated algorithm
**      (by Fiala and Greene) which is guaranteed to run in linear amortized
**      time, but has a larger average cost, uses more memory and is patented.
**      However the F&G algorithm may be faster for some highly redundant
**      data if the parameter MaxChainLength (described below) is too large.
**
**  ACKNOWLEDGEMENTS
**
**      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
**      I found it in 'freeze' written by Leonid Broukhis.
**
**  REFERENCES
**
**      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
**
**      A description of the Rabin and .Karp algorithm is given in the book
**         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
**
**      Fiala,E.R., and Greene,D.H.
**         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
**
**  INTERFACE
**
**      int InitLongestMatch(int PackLevel, unsigned short *flags, DeflateParam_t
**                           *Defl, LocalDef_t *Deflt, CompParam_t *Comp)
**          Initialize the "longest match" routines for a new buffer
**
**      unsigned long Deflate(int Level, LocalBits_t *Bits, DeflateParam_t *Defl,
**                             LocalDef_t *Deflt, CompParam_t *Comp)
**          Processes a new input buffer and return its compressed length. Sets
**          the compressed length, crc, deflate flags and internal buffer
**          attributes.
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include "comppriv.h"

/* ===========================================================================
 * Configuration parameters
 */

#ifndef HASH_BITS
#define HASH_BITS  15
#endif

#define HASH_SIZE (unsigned int)(1<<HASH_BITS)
#define HASH_MASK (HASH_SIZE-1)
#define WMASK     (WSIZE-1)
/* HASH_SIZE and WSIZE must be powers of two */

#define NIL 0
/* Tail of hash chains */

#define FAST 4
#define SLOW 2
/* speed options for the general purpose bit flag */

#ifndef TOO_FAR
#define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

/* ===========================================================================
 * Local data used by the "longest match" routines.
 */

typedef unsigned short Pos;
typedef unsigned int IPos;
/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

/* unsigned char Window[2L*WSIZE]; */
/* Sliding window. Input bytes are read into the second half of the window,
 * and moved to the first half later to keep a dictionary of at least WSIZE
 * bytes. With this organization, matches are limited to a distance of
 * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
 * performed with a length multiple of the block size.
 */

/* Pos HashLink[WSIZE]; */
/* Link to older string with same hash index. To limit the size of this
 * array to 64K, this link is maintained only for the last 32K strings.
 * An index in this array is thus a window index modulo 32K.
 */

/* Pos head[1<<HASH_BITS]; */
/* Heads of the hash chains or NIL. */

#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
/* Number of bits by which ins_h and del_h must be shifted at each
 * input step. It must be such that after MIN_MATCH steps, the oldest
 * byte no longer takes part in the hash key, that is:
 *   H_SHIFT * MIN_MATCH >= HASH_BITS
 */

typedef struct Configuration
{
    unsigned short GoodLength; /* reduce lazy search above this match length */
    unsigned short MaxLazy;    /* do not perform lazy search above this match length */
    unsigned short NiceLength; /* quit search above this match length */
    unsigned short MaxChain;
} Configuration_t;

static Configuration_t ConfigTable[10] =
{
/*  good lazy nice chain */
/* 0 */
{
    0,    0,  0,    0
},  /* store only */
/* 1 */
{
    4,    4,  8,    4
},  /* maximum speed, no lazy matches */
/* 2 */
{
    4,    5, 16,    8
},
/* 3 */
{
    4,    6, 32,   32
},
/* 4 */
{
    4,    4, 16,   16
},  /* lazy matches */
/* 5 */
{
    8,   16, 32,   32
},
/* 6 */
{
    8,   16, 128, 128
},
/* 7 */
{
    8,   32, 128, 256
},
/* 8 */
{
    32, 128, 258, 1024
},
/* 9 */
{
    32, 258, 258, 4096
}
}; /* maximum compression */

/* Note: the Deflate() code requires max_lazy >= MIN_ATCH and max_chain >= 4
 * For DeflateFast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

/* ===========================================================================
 *  Prototypes for local functions.
 */
static void FillWindow(DeflateParam_t *Defl, LocalDef_t *Deflt,
                       CompParam_t *Comp);
static unsigned long DeflateFast(int Level, LocalBits_t *Bits, DeflateParam_t *Defl,
                                  LocalDef_t *Deflt, CompParam_t *Comp);

int  LongestMatch(IPos CurMatch, DeflateParam_t *Defl, CompParam_t *Comp);


/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)

/* ===========================================================================
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of String are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#define INSERT_STRING(s, MatchHead, h, Window, HashLink, Head) \
(UPDATE_HASH(h, Window[(int)(s) + MIN_MATCH-1]), \
 HashLink[(int)(s) & WMASK] = Head[h], \
 MatchHead = (unsigned int)Head[h], \
 Head[h] = (unsigned short)(s))

/* ===========================================================================
 * Initialize the "longest match" routines for new data
 */
CompressStatus_t
InitLongestMatch(
                 int             PackLevel, /* 0: store, 1: best speed, 9: best compression */
                 unsigned short *Flags,     /* general purpose bit flag */
                 DeflateParam_t *Defl,
                 LocalDef_t     *Deflt,
                 CompParam_t    *Comp
                )
{
    unsigned int Counter;

    if (PackLevel < 1 || PackLevel > 9)
        return BAD_COMPRESSION_LEVEL;

    Deflt->CompLevel = PackLevel;

    /* Initialize the hash table. */

    memzero((char *)(Comp->HashLink+WSIZE), HASH_SIZE*sizeof(*(Comp->HashLink+WSIZE)));

    /* HashLink will be initialized on the fly */

    /* Set the default configuration parameters: */

    Defl->MaxLazyMatch   = ConfigTable[PackLevel].MaxLazy;
    Defl->GoodMatch      = ConfigTable[PackLevel].GoodLength;
    Defl->NiceMatch      = ConfigTable[PackLevel].NiceLength;
    Defl->MaxChainLength = ConfigTable[PackLevel].MaxChain;

    Defl->MatchStart = WSIZE;
    if (PackLevel == 1)
        *Flags |= FAST;
    else if (PackLevel == 9)
        *Flags |= SLOW;

    /* ??? reduce MaxChainLength for binary data */

    Defl->StringStart = 0;
    Defl->BlockStart = 0L;
    Defl->PrevLength = 0;
    Defl->MatchStart = 0;

    Deflt->Lookahead = (unsigned int)ReadBuffer((char *)Comp->Window,
                       (unsigned int)(sizeof(int) <= 2 ? WSIZE : 2*WSIZE), Comp);

    if (Deflt->Lookahead == 0 || Deflt->Lookahead == (unsigned int)EOF)
    {
        Deflt->EndOfInput = 1;
        Deflt->Lookahead = 0;
        return COMPRESS_OK;
    }
    Deflt->EndOfInput = 0;
    /* Make sure that we always have enough lookahead. */
    while (Deflt->Lookahead < MIN_LOOKAHEAD && !Deflt->EndOfInput)
        FillWindow(Defl, Deflt, Comp);

    Deflt->HashIndex = 0;
    for (Counter=0; Counter<MIN_MATCH-1; Counter++)
        UPDATE_HASH(Deflt->HashIndex, Comp->Window[Counter]);
    /* If Lookahead < MIN_MATCH, Deflt->HashIndex is garbage, but this is
     * not important since only literal bytes will be emitted.
     */
    return COMPRESS_OK;
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to PrevLength are discarded,
 * in which case the result is equal to PrevLength and MatchStart is
 * garbage.
 * IN assertions: CurMatch is the head of the hash chain for the current
 *   string (StringStart) and its distance is <= MAX_DIST, and PrevLength >= 1
 */

int
LongestMatch(
             IPos              CurMatch,                             /* current match */
             DeflateParam_t   *Defl,
             CompParam_t      *Comp
            )
{
    unsigned int    ChainLength = Defl->MaxChainLength; /* max hash chain length */
    unsigned char  *Scan = Comp->Window + Defl->StringStart;   /* current string */
    unsigned char  *Match;                            /* matched string */
    int             Length;                           /* length of current match */
    int             BestLength = (int)Defl->PrevLength;      /* best match length so far */
    IPos            Limit = Defl->StringStart > (IPos)MAX_DIST ? Defl->StringStart - (IPos)MAX_DIST : NIL;
    /* Stop when CurMatch becomes <= Limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */

/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
 * It is easy to get rid of this optimization if necessary.
 */
#if HASH_BITS < 8 || MAX_MATCH != 258
 error: Code too clever
#endif

    unsigned char *Strend   = Comp->Window + Defl->StringStart + MAX_MATCH;
    unsigned char ScanEnd1  = Scan[BestLength-1];
    unsigned char ScanEnd   = Scan[BestLength];

    /* Do not waste too much time if we already have a good match: */
    if (Defl->PrevLength >= Defl->GoodMatch)
    {
        ChainLength >>= 2;
    }
    Assert(Defl->StringStart <= Comp->WindowSize - MIN_LOOKAHEAD, "insufficient lookahead");

    do
    {
        Assert(CurMatch < Defl->StringStart, "no future");
        Match = Comp->Window + CurMatch;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */

        if (Match[BestLength] != ScanEnd  || Match[BestLength-1] != ScanEnd1 ||
            *Match            != *Scan    || *++Match            != Scan[1])
            continue;

        /* The check at BestLength-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare Scan[2] and Match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        Scan += 2;
        Match++;

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at StringStart+258.
         */
        do
        {
        } while (*++Scan == *++Match && *++Scan == *++Match &&
                 *++Scan == *++Match && *++Scan == *++Match &&
                 *++Scan == *++Match && *++Scan == *++Match &&
                 *++Scan == *++Match && *++Scan == *++Match &&
                 Scan < Strend);

        Length = MAX_MATCH - (int)(Strend - Scan);
        Scan = Strend - MAX_MATCH;

        if (Length > BestLength)
        {
            Defl->MatchStart = CurMatch;
            BestLength = Length;
            if (Length >= Defl->NiceMatch)
                break;
            ScanEnd1  = Scan[BestLength-1];
            ScanEnd   = Scan[BestLength];
        }
    } while ((CurMatch = Comp->HashLink[CurMatch & WMASK]) > Limit
             && --ChainLength != 0);

    return BestLength;
}

/* ===========================================================================
 * Fill the window when the Lookahead becomes insufficient.
 * Updates StringStart and Lookahead, and sets EndOfInput if end of input buffer.
 * IN assertion: Lookahead < MIN_LOOKAHEAD && StringStart + Lookahead > 0
 * OUT assertions: at least one byte has been read, or EndOfInput is set;
 *    buffer reads are performed for at least two bytes
 */
static void
FillWindow(
           DeflateParam_t  *Defl,
           LocalDef_t      *Deflt,
           CompParam_t     *Comp
          )
{
    unsigned int Tmp1, Tmp2;
    unsigned int More = (unsigned int)(Comp->WindowSize -
                        (unsigned long)Deflt->Lookahead -
                        (unsigned long)Defl->StringStart);
    /* Amount of free space at the end of the window. */

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (More == (unsigned int)EOF)
    {
        /* Very unlikely, but possible on 16 bit machine if StringStart == 0
         * and lookahead == 1 (input done one byte at a time)
         */
        More--;
    }
    else if (Defl->StringStart >= (unsigned int)(WSIZE+MAX_DIST))
    {
        /* By the IN assertion, the window is not empty so we can't confuse
         * More == 0 with More == 64K on a 16 bit machine.
         */
        Assert(Comp->WindowSize == (unsigned long)(2*WSIZE), "no sliding");

        memcpy((char *)Comp->Window, (char *)Comp->Window+WSIZE, WSIZE);
        Defl->MatchStart -= (unsigned int)WSIZE;
        Defl->StringStart -= (unsigned int)WSIZE;
        /* we now have StringStart >= MAX_DIST: */

        Defl->BlockStart -= (long) WSIZE;

        for (Tmp1 = 0; Tmp1 < (unsigned int)HASH_SIZE; Tmp1++)
        {
            Tmp2 = (Comp->HashLink+WSIZE)[Tmp1];
            (Comp->HashLink+WSIZE)[Tmp1] = (Pos)(Tmp2 >= (unsigned int)WSIZE ?
                Tmp2-(unsigned int)WSIZE : NIL);
        }

        for (Tmp1 = 0; Tmp1 < WSIZE; Tmp1++)
        {
            Tmp2 = Comp->HashLink[Tmp1];
            Comp->HashLink[Tmp1] = (Pos)(Tmp2 >= WSIZE ? Tmp2-WSIZE : NIL);
            /* If n is not on any hash chain, HashLink[n] is garbage but
             * its value will never be used.
             */
        }
        More += (unsigned int)WSIZE;
    }
    /* At this point, more >= 2 */

    if (!Deflt->EndOfInput)
    {
        Tmp1 = (unsigned int)ReadBuffer((char*)Comp->Window + Defl->StringStart +
                               Deflt->Lookahead, More, Comp);
        if (Tmp1 == 0 || Tmp1 == (unsigned int)EOF)
            Deflt->EndOfInput = 1;
        else
            Deflt->Lookahead += Tmp1;
    }
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: StringStart is set to the end of the current match.
 */
#define FLUSH_BLOCK(Eof, Bits, Defl, Comp) \
FlushBlock(Defl->BlockStart >= 0L ? (char *)&Comp->Window[(unsigned int)Defl->BlockStart] : \
        (char *)NULL, (unsigned long)((long)Defl->StringStart - Defl->BlockStart), \
        Eof, Bits, Comp)

/* ===========================================================================
 * Processes a new input buffer and return its compressed length. This
 * function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for umatched strings or for short
 * matches. It is used only for the fast compression options.
 */
static unsigned long
DeflateFast(
            int               Level,
            LocalBits_t      *Bits,
            DeflateParam_t   *Defl,
            LocalDef_t       *Deflt,
            CompParam_t      *Comp
           )
{
    IPos            HashHead; /* head of the hash chain */
    int             Flush;      /* set if current block must be flushed */
    unsigned int    MatchLength = 0;  /* length of best match */

    Defl->PrevLength = MIN_MATCH-1;
    while (Deflt->Lookahead != 0)
    {
        /* Insert the string Window[StringStart .. StringStart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        INSERT_STRING(Defl->StringStart, HashHead, Deflt->HashIndex, Comp->Window,
                      Comp->HashLink, (Comp->HashLink + WSIZE));

        /* Find the longest match, discarding those <= PrevLength.
         * At this point we have always MatchLength < MIN_MATCH
         */
        if (HashHead != NIL && Defl->StringStart - HashHead <=  MAX_DIST)
        {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input buffer).
             */
            MatchLength = (unsigned int)LongestMatch(HashHead, Defl, Comp);
            /* longest_match() sets match_start */
            if (MatchLength > Deflt->Lookahead)
                MatchLength = Deflt->Lookahead;
        }

        if (MatchLength >= MIN_MATCH)
        {
            Flush = TallyFrequencies((int)(Defl->StringStart-Defl->MatchStart),
                                     (int)MatchLength - MIN_MATCH, Level, Defl, Comp);

            Deflt->Lookahead -= MatchLength;

            /* Insert new strings in the hash table only if the match length
             * is not greater than this length. This saves time but degrades
             * compression. MaxLazyMatch is used only for compression levels <= 3.
             */

            if (MatchLength <= Defl->MaxLazyMatch)
            {
                MatchLength--; /* string at StringStart already in hash table */
                do
                {
                    Defl->StringStart++;
                    INSERT_STRING(Defl->StringStart, HashHead, Deflt->HashIndex,
                                  Comp->Window, Comp->HashLink,
                                  (Comp->HashLink + WSIZE));
                    /* StringStart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
                     * these bytes are garbage, but it does not matter since
                     * the next lookahead bytes will be emitted as literals.
                     */
                } while (--MatchLength != 0);
                Defl->StringStart++;
            }
            else
            {
                Defl->StringStart += MatchLength;
                MatchLength = 0;
                Deflt->HashIndex = Comp->Window[Defl->StringStart];
                UPDATE_HASH(Deflt->HashIndex, Comp->Window[Defl->StringStart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
            }
        }
        else
        {
            /* No match, output a literal byte */
            Flush = TallyFrequencies(0, Comp->Window[Defl->StringStart], Level, Defl, Comp);
            Deflt->Lookahead--;
            Defl->StringStart++;
        }

        if (Flush)
        {
            (void)FLUSH_BLOCK(0, Bits, Defl, Comp);
            Defl->BlockStart = (long)Defl->StringStart;
        }

        /* Make sure that we always have enough lookahead, except
         * at the end of the input buffer. We need MAX_MATCH bytes
         * for the next match, pls MIN_MATCH bytes to insert the
         * string following the next match.
         */
        while (Deflt->Lookahead < MIN_LOOKAHEAD && !Deflt->EndOfInput)
            FillWindow(Defl, Deflt, Comp);

    }
    return FLUSH_BLOCK(1, Bits, Defl, Comp); /* end of buffer (eof) */
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no beter match at the next window position.
 */
unsigned long
Deflate(
        int             Level,
        LocalBits_t    *Bits,
        DeflateParam_t *Defl,
        LocalDef_t     *Deflt,
        CompParam_t    *Comp
       )
{
    IPos         HashHead;          /* head of hash chain */
    IPos         PrevMatch;         /* previous match */
    int          Flush;               /* set if current block must be flushed */
    int          MatchAvailable = 0; /* set if previous match exists */
    unsigned int MatchLength = MIN_MATCH-1; /* length of best match */

    if (Deflt->CompLevel <= 3)
        return DeflateFast(Level, Bits, Defl, Deflt, Comp); /* optimized for speed */

    /* Process the input block. */
    while (Deflt->Lookahead != 0)
    {
        /* Insert the string Window[StringStart .. StringStart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        INSERT_STRING(Defl->StringStart, HashHead, Deflt->HashIndex,
                      Comp->Window, Comp->HashLink, (Comp->HashLink + WSIZE));

        /* Find the longest match, discarding those<= PrevLength.
         */
        Defl->PrevLength = MatchLength;
        PrevMatch = Defl->MatchStart;
        MatchLength = MIN_MATCH-1;

        if (HashHead != NIL && Defl->PrevLength < Defl->MaxLazyMatch &&
            Defl->StringStart - HashHead <= MAX_DIST)
        {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input buffer).
            */
            MatchLength = (unsigned int)LongestMatch(HashHead, Defl, Comp);
            /* LongestMatch() sets MatchStart */
            if (MatchLength > Deflt->Lookahead)
                MatchLength = Deflt->Lookahead;

            /* Ignore a length 3 match if it is too distant: */
            if (MatchLength == MIN_MATCH &&
                Defl->StringStart - Defl->MatchStart > TOO_FAR)
            {
                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                MatchLength--;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (Defl->PrevLength >= MIN_MATCH && MatchLength <= Defl->PrevLength)
        {
            Flush = TallyFrequencies((int)(Defl->StringStart - 1 - PrevMatch),
                                     (int)((int)Defl->PrevLength - MIN_MATCH),
                                     Level, Defl, Comp);

            /* Insert in hash table all strings up to the end of the match.
             * StringStart-1 and StringStart are already inserted.
             */
            Deflt->Lookahead -= Defl->PrevLength-1;
            Defl->PrevLength -= 2;
            do
            {
                Defl->StringStart++;
                INSERT_STRING(Defl->StringStart, HashHead, Deflt->HashIndex,
                              Comp->Window, Comp->HashLink, (Comp->HashLink + WSIZE));
                /* StringStart never exceeds WSIZE-MAX_MATCH, so there are
                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
                 * these bytes are garbage, but it does not matter since the
                 * next lookahead bytes will always be emitted as literals.
                 */
            } while (--Defl->PrevLength != 0);
            MatchAvailable = 0;
            MatchLength = MIN_MATCH-1;
            Defl->StringStart++;
            if (Flush)
            {
                (void)FLUSH_BLOCK(0, Bits, Defl, Comp);
                Defl->BlockStart = (long)Defl->StringStart;
            }

        }
        else if (MatchAvailable)
        {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            if (TallyFrequencies(0, Comp->Window[Defl->StringStart-1], Level, Defl, Comp))
            {
                (void)FLUSH_BLOCK(0, Bits, Defl, Comp);
                Defl->BlockStart = (long)Defl->StringStart;
            }
            Defl->StringStart++;
            Deflt->Lookahead--;
        }
        else
        {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            MatchAvailable = 1;
            Defl->StringStart++;
            Deflt->Lookahead--;
        }

        Assert (Defl->StringStart <= Comp->BytesIn && Deflt->Lookahead
                <= Comp->BytesIn, "a bit too far");

        /* Make sure that we always have enough lookahead, except
         * at the end of the input buffer. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        while (Deflt->Lookahead < MIN_LOOKAHEAD && !Deflt->EndOfInput)
            FillWindow(Defl, Deflt, Comp);
    }
    if (MatchAvailable)
        (void)TallyFrequencies(0, Comp->Window[Defl->StringStart-1], Level, Defl, Comp);

    return FLUSH_BLOCK(1, Bits, Defl, Comp); /* end of buffer (eof) */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\unzip.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element UNZIP.C */
/*  *1    14-NOV-1996 10:26:58 ANIGBOGU "[113914]Decompress data in zip format using the inflate algorithm" */
/*  DEC/CMS REPLACEMENT HISTORY, Element UNZIP.C */
/*  DEC/CMS REPLACEMENT HISTORY, Element UNZIP.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/unzip.c
**
**  PURPOSE
**
** Decompress data using the inflate algorithm.
**
** The code in this file is derived from the file funzip.c written
** and put in the public domain by Mark Adler.
**
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/


#include "comppriv.h"

#define EXTHDR 16   /* size of extended local header, inc sig */

/* ===========================================================================
 *
 * IN assertions: the buffer Input contains already the beginning of
 *   the compressed data, from offsets inptr to InputSize-1 included.
 *   The magic header has already been checked. The output buffer is cleared.
 */
CompressStatus_t
Unzip(
      int          Method,
      CompParam_t *Comp
     )
{
    unsigned long OriginalCRC = 0;       /* original crc */
    unsigned long OriginalLength = 0;    /* original uncompressed length */
    unsigned long Count;                 /* counter */
    int Pos;
    unsigned char LocalBuffer[EXTHDR];   /* extended local header */
    unsigned char *Buffer, *Ptr;
    CompressStatus_t  Status;

    Comp->pCRC->Compute(NULL, 0);              /* initialize crc */

    /* Decompress */

    if (Method == STORED)
    {
        /* Get the crc and original length */
        /* crc32  (see algorithm.doc)
         * uncompressed input size modulo 2^32
         */

        LocalBuffer[0] = 0; /* To get around lint error 771 */

        for (Pos = 0; Pos < 8; Pos++)
        {
            LocalBuffer[Pos] = (unsigned char)GetByte(Comp); /* may cause an error if EOF */
        }
        OriginalCRC = LG(LocalBuffer);
        OriginalLength = LG(LocalBuffer+4);

        Ptr = Buffer = (unsigned char *)CompressMalloc((unsigned int)OriginalLength, &Status);
        if (Status != COMPRESS_OK)
            return Status;
        for (Count = 0; Count < OriginalLength; Count++)
            *(Ptr++) = (unsigned char)GetByte(Comp);
        WriteBuffer(Comp, Buffer, (unsigned int)OriginalLength);
        Comp->BytesOut = OriginalLength;
        CompressFree((char *)Buffer);
        return COMPRESS_OK;
    }

    if ((Status = Inflate(Comp)) != COMPRESS_OK)
        return Status;

    /* Get the crc and original length */
    /* crc32  (see algorithm.doc)
     * uncompressed input size modulo 2^32
     */
    LocalBuffer[0] = 0; /* To skirt around lint error 771 */
    for (Pos = 0; Pos < 8; Pos++)
    {
        LocalBuffer[Pos] = (unsigned char)GetByte(Comp); /* may cause an error if EOF */
    }
    OriginalCRC = LG(LocalBuffer);
    OriginalLength = LG(LocalBuffer+4);

    /* Validate decompression */
    if (OriginalCRC != (unsigned __int32)(*Comp->pCRC))
        return CRC_ERROR;

    if (OriginalLength != (unsigned long)Comp->BytesOut)
        return LENGTH_ERROR;
    return COMPRESS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\trees.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element TREES.C */
/*  *1    14-NOV-1996 10:26:31 ANIGBOGU "[113914]Functions to output deflated data using Huffman encoding" */
/*  DEC/CMS REPLACEMENT HISTORY, Element TREES.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/trees.c
**
**  PURPOSE
**
**      Output deflated data using Huffman coding
**
**  DISCUSSION
**
**      The PKZIP "deflation" process uses several Huffman trees. The more
**      common source values are represented by shorter bit sequences.
**
**      Each code tree is stored in the ZIP file in a compressed form
**      which is itself a Huffman encoding of the lengths of
**      all the code strings (in ascending order by source values).
**      The actual code strings are reconstructed from the lengths in
**      the UNZIP process, as described in the "application note"
**      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
**
**  REFERENCES
**
**      Lynch, Thomas J.
**          Data Compression:  Techniques and Applications, pp. 53-55.
**          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
**
**      Storer, James A.
**          Data Compression:  Methods and Theory, pp. 49-50.
**          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
**
**      Sedgewick, R.
**          Algorithms, p290.
**          Addison-Wesley, 1983. ISBN 0-201-06672-6.
**
**  INTERFACE
**
**      void InitMatchBuffer(void)
**          Allocate the match buffer, initialize the various tables.
**
**      void TallyFrequencies(int Dist, int MatchLength, int Level, DeflateParam_t
**                            *Defl, CompParam_t *Comp);
**          Save the match info and tally the frequency counts.
**
**      long FlushBlock(char *buf, ulg stored_len, int Eof,
**                        LocalBits_t *Bits, CompParam_t *Comp)
**          Determine the best encoding for the current block: dynamic trees,
**          static trees or store, and output the encoded block to the zip
**          file. Returns the total compressed length for the file so far.
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include "comppriv.h"

/* ===========================================================================
 * Constants
 */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define END_BLOCK 256
/* end of block literal code */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

/* extra bits for each length code */
static unsigned ExtraLBits[LENGTH_CODES]  =
{
    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0
};

/* extra bits for each distance code */
static unsigned ExtraDBits[D_CODES] =
{
    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13
};

/* extra bits for each bit length code */
static unsigned ExtraBlBits[BL_CODES] =
{
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7
};

#define LIT_BUFSIZE  0x8000

#ifndef DIST_BUFSIZE
#  define DIST_BUFSIZE  LIT_BUFSIZE
#endif
/* Sizes of match buffers for literals/lengths and distances.  There are
 * 4 reasons for limiting LIT_BUFSIZE to 64K:
 *   - frequencies can be kept in 16 bit counters
 *   - if compression is not successful for the first block, all input data is
 *     still in the window so we can still emit a stored block even when input
 *     comes from standard input.  (This can also be done for all blocks if
 *     LIT_BUFSIZE is not greater than 32K.)
 *   - if compression is not successful for a file smaller than 64K, we can
 *     even emit a stored file instead of a stored block (saving 5 bytes).
 *   - creating new Huffman trees less frequently may not provide fast
 *     adaptation to changes in the input data statistics. (Take for
 *     example a binary file with poorly compressible code followed by
 *     a highly compressible string table.) Smaller buffer sizes give
 *     fast adaptation but have of course the overhead of transmitting trees
 *     more frequently.
 *   - I can't count above 4
 * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
 * memory at the expense of compression). Some optimizations would be possible
 * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
 */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* ===========================================================================
 * Local data
 */

/* Data structure describing a single value and its code string. */
typedef struct ValueCodeString
{
    union
    {
        unsigned short  Frequency;  /* frequency count */
        unsigned short  Code;       /* bit string */
    } FrequencyCode;
    union
    {
        unsigned short  Father;        /* father node in Huffman tree */
        unsigned short  Length;        /* length of bit string */
    } FatherLength;
} ValueCodeString_t;

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

static ValueCodeString_t DynLiteralTree[HEAP_SIZE];   /* literal and length tree */
static ValueCodeString_t DynDistanceTree[2*D_CODES+1]; /* distance tree */

static ValueCodeString_t StaticLiteralTree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see ct_init
 * below).
 */

static ValueCodeString_t StaticDistanceTree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

static ValueCodeString_t BitLengthsTree[2*BL_CODES+1];
/* Huffman tree for the bit lengths */

typedef struct TreeDesc
{
    ValueCodeString_t  *DynamicTree; /* the dynamic tree */
    ValueCodeString_t  *StaticTree;  /* corresponding static tree or NULL */
    unsigned int       *ExtraBits;   /* extra bits for each code or NULL */
    int                 ExtraBase;   /* base index for Extrabits */
    int                 Elements;    /* max number of elements in the tree */
    int                 MaxLength;   /* max bit length for the codes */
    int                 MaxCode;     /* largest code with non zero frequency */
} TreeDesc_t;

static TreeDesc_t LengthDesc =
{
    DynLiteralTree, StaticLiteralTree, ExtraLBits, LITERALS+1, L_CODES,
    MAX_BITS, 0
};

static TreeDesc_t DistanceDesc =
{
    DynDistanceTree, StaticDistanceTree, ExtraDBits, 0, D_CODES,  MAX_BITS, 0
};

static TreeDesc_t BitLengthsDesc =
{
    BitLengthsTree, (ValueCodeString_t *)0, ExtraBlBits, 0,  BL_CODES, MAX_BL_BITS, 0
};


static unsigned short BitLengthsCount[MAX_BITS+1];
/* number of codes at each bit length for an optimal tree */

static unsigned char BitLengthsOrder[BL_CODES] =
{
    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15
};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

static unsigned int Heap[2*L_CODES+1]; /* heap used to build the Huffman trees */
static unsigned int HeapLength;        /* number of elements in the heap */
static unsigned int HeapMax;           /* element of largest frequency */
/* The sons of Heap[n] are Heap[2*n] and Heap[2*n+1]. Heap[0] is not used.
 * The same heap array is used to build all trees.
 */

static unsigned char Depth[2*L_CODES+1];
/* Depth of each subtree used as tie breaker for trees of equal frequency */

static unsigned char LengthCode[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

static unsigned char DistanceCode[512];
/* distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

static int BaseLength[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

static unsigned int BaseDistance[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

/* unsigned char Input[LIT_BUFSIZE];  buffer for literals or lengths */

/* unsigned short DistBuffer[DIST_BUFSIZE]; buffer for distances */

static unsigned char FlagBuffer[(LIT_BUFSIZE/8)];
/* FlagBuffer is a bit array distinguishing literals from lengths in
 * Input, thus indicating the presence or absence of a distance.
 */

typedef struct LocalTree
{
    unsigned int    InputIndex;       /* running index in Input */
    unsigned int    DistIndex;      /* running index in DistBuffer */
    unsigned int    FlagIndex;     /* running index in FlagBuffer */
    unsigned char   Flags;          /* current flags not yet saved in FlagBuffer */
    unsigned char   FlagBit;       /* current bit used in Flags */
    unsigned long   OptimalLength;        /* bit length of current block with optimal trees */
    unsigned long   StaticLength;     /* bit length of current block with static trees */
    unsigned long   CompressedLength; /* total bit length of compressed file */
    unsigned long   InputLength;      /* total byte length of input file */
} LocalTree_t;

/* InputLength is for debugging only since we can get it by other means. */

/* bits are filled in Flags starting at bit 0 (least significant).
 * Note: these flags are overkill in the current code since we don't
 * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
 */

static LocalTree_t Xtree;

/* ===========================================================================
 * Local (static) routines in this file.
 */

static void InitializeBlock(void);
static void RestoreHeap(ValueCodeString_t *Tree, int Node);
static void GenerateBitLengths(TreeDesc_t *Desc);
static void GenerateCodes(ValueCodeString_t *Tree, int MaxCode);
static void BuildTree(TreeDesc_t *Desc);
static void ScanTree(ValueCodeString_t *Tree, int MaxCode);
static void SendTree(ValueCodeString_t *Tree, int MaxCode,
                     LocalBits_t *Bits, CompParam_t *Comp);
static int  BuildBitLengthsTree(void);
static void SendAllTrees(int LCodes, int DCodes, int BlCodes,
                         LocalBits_t *Bits, CompParam_t *Comp);
static void CompressBlock(ValueCodeString_t *LTree, ValueCodeString_t *DTree,
                          LocalBits_t *Bits, CompParam_t *Comp);


#define SendCode(c, Tree, Bits, Comp) \
    SendBits(Tree[c].FrequencyCode.Code, Tree[c].FatherLength.Length, Bits, Comp)
   /* Send a code of the given tree. c and Tree must not have side effects */

#define DistCode(Dist) \
   ((Dist) < 256 ? DistanceCode[Dist] : DistanceCode[256+((Dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. DistanceCode[256] and DistanceCode[257] are never
 * used.
 */

/* ===========================================================================
 * Allocate the match buffer, initialize the various tables
 */
void
InitMatchBuffer(
                void
               )
{
    unsigned int Count;    /* iterates over tree elements */
    int          Bits;     /* bit counter */
    int          Length;   /* length value */
    unsigned int Code;     /* code value */
    unsigned int Dist;     /* distance index */

    Xtree.CompressedLength = Xtree.InputLength = 0L;

    if (StaticDistanceTree[0].FatherLength.Length != 0)
        return; /* InitMatchBuffer already called */

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    Length = 0;
    for (Code = 0; Code < LENGTH_CODES-1; Code++)
    {
        BaseLength[Code] = Length;
        for (Count = 0; Count < (unsigned int)(1<<ExtraLBits[Code]); Count++)
        {
            LengthCode[Length++] = (unsigned char)Code;
        }
    }
    Assert (Length == 256, "InitMatchBuffer: Length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite LengthCode[255] to use the best encoding:
     */
    LengthCode[Length-1] = (unsigned char)Code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    Dist = 0;
    for (Code = 0 ; Code < 16; Code++)
    {
        BaseDistance[Code] = Dist;
        for (Count = 0; Count < (unsigned int)(1<<ExtraDBits[Code]); Count++)
        {
            DistanceCode[Dist++] = (unsigned char)Code;
        }
    }
    Assert (Dist == 256, "InitMatchBuffer: Dist != 256");
    Dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; Code < D_CODES; Code++)
    {
        BaseDistance[Code] = Dist << 7;
        for (Count = 0; Count < (unsigned int)(1<<(ExtraDBits[Code]-7)); Count++)
        {
            DistanceCode[256 + Dist++] = (unsigned char)Code;
        }
    }
    Assert (Dist == 256, "InitMatchBuffer: 256+Dist != 512");

    /* Construct the codes of the static literal tree */
    for (Bits = 0; Bits <= MAX_BITS; Bits++)
        BitLengthsCount[Bits] = 0;
    Count = 0;
    while (Count <= 143)
    {
        StaticLiteralTree[Count++].FatherLength.Length = 8;
        BitLengthsCount[8]++;
    }
    while (Count <= 255)
    {
        StaticLiteralTree[Count++].FatherLength.Length = 9;
        BitLengthsCount[9]++;
    }
    while (Count <= 279)
    {
        StaticLiteralTree[Count++].FatherLength.Length = 7;
        BitLengthsCount[7]++;
    }
    while (Count <= 287)
    {
        StaticLiteralTree[Count++].FatherLength.Length = 8;
        BitLengthsCount[8]++;
    }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    GenerateCodes((ValueCodeString_t *)StaticLiteralTree, L_CODES+1);

    /* The static distance tree is trivial: */
    for (Count = 0; Count < D_CODES; Count++)
    {
        StaticDistanceTree[Count].FatherLength.Length = 5;
        StaticDistanceTree[Count].FrequencyCode.Code =
            (unsigned short)ReverseBits(Count, 5);
    }

    /* Initialize the first block of the first file: */
    InitializeBlock();
}

/* ===========================================================================
 * Initialize a new block.
 */
static void
InitializeBlock(
                void
               )
{
    int Count; /* iterates over tree elements */

    /* Initialize the trees. */
    for (Count = 0; Count < L_CODES;  Count++)
        DynLiteralTree[Count].FrequencyCode.Frequency = 0;
    for (Count = 0; Count < D_CODES;  Count++)
        DynDistanceTree[Count].FrequencyCode.Frequency = 0;
    for (Count = 0; Count < BL_CODES; Count++)
        BitLengthsTree[Count].FrequencyCode.Frequency = 0;

    DynLiteralTree[END_BLOCK].FrequencyCode.Frequency = 1;
    Xtree.OptimalLength = Xtree.StaticLength = 0L;
    Xtree.InputIndex = Xtree.DistIndex = Xtree.FlagIndex = 0;
    Xtree.Flags = 0; Xtree.FlagBit = 1;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates Heap and HeapLength.
 */
#define RecreateHeap(Tree, Top) \
{\
     Top = Heap[SMALLEST]; \
     Heap[SMALLEST] = Heap[HeapLength--]; \
     RestoreHeap(Tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define Smaller(Tree, Tmp1, Tmp2) \
 (Tree[Tmp1].FrequencyCode.Frequency < Tree[Tmp2].FrequencyCode.Frequency || \
 (Tree[Tmp1].FrequencyCode.Frequency == Tree[Tmp2].FrequencyCode.Frequency \
 && Depth[Tmp1] <= Depth[Tmp2]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node Node,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
static void
RestoreHeap(
            ValueCodeString_t *Tree,  /* the tree to restore */
            int Node                  /* node to move down */
           )
{
    unsigned int Father = Heap[Node];
    unsigned int LeftSon = (unsigned int)Node << 1;  /* left son of Node */
    while (LeftSon <= HeapLength)
    {
        /* Set LeftSon to the smallest of the two sons: */
        if (LeftSon < HeapLength && (unsigned int)Smaller(Tree, Heap[LeftSon+1], Heap[LeftSon]))
            LeftSon++;

        /* Exit if Father is smaller than both sons */
        if (Smaller(Tree, Father, Heap[LeftSon]))
            break;

        /* Exchange Father with the smallest son */
        Heap[Node] = Heap[LeftSon];  Node = (int)LeftSon;

        /* And continue down the tree, setting LeftSon to the left son of Node */
        LeftSon <<= 1;
    }
    Heap[Node] = Father;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields FrequencyCode.Frequency and FatherLength.Father are set, heap[HeapMax] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array BitLengthsCount contains the frequencies for each bit length.
 *     The length OptimalLength is updated; StaticLength is also updated if stree is
 *     not null.
 */
static void
GenerateBitLengths(
                   TreeDesc_t *Desc /* the tree descriptor */
                  )
{
    ValueCodeString_t  *Tree      = Desc->DynamicTree;
    int                *Extra     = (int *)Desc->ExtraBits;
    int                 Base      = Desc->ExtraBase;
    int                 MaxCode   = Desc->MaxCode;
    int                 MaxLength = Desc->MaxLength;
    ValueCodeString_t  *Stree     = Desc->StaticTree;
    unsigned int        HeapIndex;              /* heap index */
    unsigned int        Tmp1, Tmp2;           /* iterate over the tree elements */
    int                 Bits;           /* bit length */
    int                 Xbits;          /* extra bits */
    unsigned short      Frequency;              /* frequency */
    int                 Overflow  = 0;   /* number of elements with bit length too large */

    for (Bits = 0; Bits <= MAX_BITS; Bits++)
        BitLengthsCount[Bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    Tree[Heap[HeapMax]].FatherLength.Length = 0; /* root of the heap */

    for (HeapIndex = HeapMax+1; HeapIndex < HEAP_SIZE; HeapIndex++)
    {
        Tmp1 = Heap[HeapIndex];
        Bits = Tree[Tree[Tmp1].FatherLength.Father].FatherLength.Length + 1;
        if (Bits > MaxLength)
            Bits = MaxLength, Overflow++;
        Tree[Tmp1].FatherLength.Length = (unsigned short)Bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (Tmp1 > (unsigned int)MaxCode)
            continue; /* not a leaf node */

        BitLengthsCount[Bits]++;
        Xbits = 0;
        if (Tmp1 >= (unsigned int)Base)
            Xbits = (int)Extra[Tmp1-(unsigned int)Base];
        Frequency = Tree[Tmp1].FrequencyCode.Frequency;
        Xtree.OptimalLength += (unsigned long)(Frequency * (Bits + Xbits));
        if (Stree)
            Xtree.StaticLength += (unsigned long)(Frequency * (Stree[Tmp1].FatherLength.Length + Xbits));
    }
    if (Overflow == 0)
        return;

    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do
    {
        Bits = MaxLength - 1;
        while (BitLengthsCount[Bits] == 0)
            Bits--;
        BitLengthsCount[Bits]--;      /* move one leaf down the tree */
        BitLengthsCount[Bits+1] += 2; /* move one overflow item as its brother */
        BitLengthsCount[MaxLength]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect BitLengthsCount[MaxLength]
         */
        Overflow -= 2;
    } while (Overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (Bits = MaxLength; Bits != 0; Bits--)
    {
        Tmp1 = BitLengthsCount[Bits];
        while (Tmp1 != 0)
        {
            Tmp2 = Heap[--HeapIndex];
            if (Tmp2 > (unsigned int)MaxCode)
                continue;
            if (Tree[Tmp2].FatherLength.Length != (unsigned int) Bits)
            {
                Xtree.OptimalLength += (unsigned long)((long)Bits -
                    (long)Tree[Tmp2].FatherLength.Length)*(long)Tree[Tmp2].FrequencyCode.Frequency;
                Tree[Tmp2].FatherLength.Length = (unsigned short)Bits;
            }
            Tmp1--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array BitLengthsCount contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
static void
GenerateCodes(
              ValueCodeString_t *Tree,        /* the tree to decorate */
              int MaxCode              /* largest code with non zero frequency */
             )
{
    unsigned short NextCode[MAX_BITS+1]; /* next code value for each bit length */
    unsigned short Code = 0;              /* running code value */
    int            BitIndex;                  /* bit index */
    int            CodeIndex;                 /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    NextCode[0] = 0; /* For lint error 771 */
    for (BitIndex = 1; BitIndex <= MAX_BITS; BitIndex++)
    {
        NextCode[BitIndex] = Code = (unsigned short)((Code + BitLengthsCount[BitIndex-1]) << 1);
    }
    /* Check that the bit counts in BitLengthsCount are consistent. The last code
     * must be all ones.
     */
    Assert(Code + BitLengthsCount[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");

    for (CodeIndex = 0;  CodeIndex <= MaxCode; CodeIndex++)
    {
        int Length = Tree[CodeIndex].FatherLength.Length;
        if (Length == 0)
            continue;
        /* Now reverse the bits */
        Tree[CodeIndex].FrequencyCode.Code = (unsigned short)ReverseBits((unsigned int)NextCode[Length]++, Length);
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assign the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field FrequencyCode.Frequency is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length OptimalLength is updated; StaticLength is
 *     also updated if stree is not null. The field MaxCode is set.
 */
static void
BuildTree(
          TreeDesc_t *Desc /* the tree descriptor */
         )
{
    ValueCodeString_t  *Tree        = Desc->DynamicTree;
    ValueCodeString_t  *Stree       = Desc->StaticTree;
    int                 Elements    = Desc->Elements;
    unsigned int        Tmp1, Tmp2;       /* iterate over heap elements */
    int                 MaxCode     = -1;   /* largest code with non zero frequency */
    int                 Node        = Elements;  /* next internal node of the tree */

    /* Construct the initial heap, with least frequent element in
     * Heap[SMALLEST]. The sons of Heap[n] are Heap[2*n] and Heap[2*n+1].
     * Heap[0] is not used.
     */
    HeapLength = 0;
    HeapMax = HEAP_SIZE;

    for (Tmp1 = 0; Tmp1 < (unsigned int)Elements; Tmp1++)
    {
        if (Tree[Tmp1].FrequencyCode.Frequency != 0)
        {
            Heap[++HeapLength] = Tmp1;
            MaxCode = (int)Tmp1;
            Depth[Tmp1] = 0;
        }
        else
        {
            Tree[Tmp1].FatherLength.Length = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (HeapLength < 2)
    {
        unsigned int New = Heap[++HeapLength] = (unsigned int)(MaxCode < 2 ? ++MaxCode : 0);
        Tree[New].FrequencyCode.Frequency = 1;
        Depth[New] = 0;
        Xtree.OptimalLength--;
        if (Stree)
            Xtree.StaticLength -= Stree[New].FatherLength.Length;
        /* new is 0 or 1 so it does not have extra bits */
    }
    Desc->MaxCode = MaxCode;

    /* The elements Heap[HeapLength/2+1 .. HeapLength] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (Tmp1 = HeapLength/2; Tmp1 >= 1; Tmp1--)
        RestoreHeap(Tree, (int)Tmp1);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    do
    {
        RecreateHeap(Tree, Tmp1);  /* Tmp1 = node of least frequency */
        Tmp2 = Heap[SMALLEST];     /* Tmp2 = node of next least frequency */

        Heap[--HeapMax] = Tmp1; /* keep the nodes sorted by frequency */
        Heap[--HeapMax] = Tmp2;

        /* Create a new node father of Tmp1 and Tmp2 */
        Tree[Node].FrequencyCode.Frequency = (unsigned short)(Tree[Tmp1].FrequencyCode.Frequency +
                                             Tree[Tmp2].FrequencyCode.Frequency);
        Depth[Node] = (unsigned char) (MAX(Depth[Tmp1], Depth[Tmp2]) + 1);
        Tree[Tmp1].FatherLength.Father = Tree[Tmp2].FatherLength.Father = (unsigned short)Node;

        /* and insert the new node in the Heap */
        Heap[SMALLEST] = (unsigned int)Node++;
        RestoreHeap(Tree, SMALLEST);

    } while (HeapLength >= 2);

    Heap[--HeapMax] = Heap[SMALLEST];

    /* At this point, the fields FrequencyCode.Frequency and FatherLength.Father are set. We can now
     * generate the bit lengths.
     */
    GenerateBitLengths((TreeDesc_t *)Desc);

    /* The field len is now set, we can generate the bit codes */
    GenerateCodes ((ValueCodeString_t *)Tree, MaxCode);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates OptimalLength to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of BitLengthsTree.)
 */
static void
ScanTree(
         ValueCodeString_t *Tree, /* the tree to be scanned */
         int MaxCode       /* and its largest code of non zero frequency */
        )
{
    int Iter;                       /* iterates over all tree elements */
    int PrevLength = -1;            /* last emitted length */
    int CurLength;                  /* length of current code */
    int NextLength = Tree[0].FatherLength.Length;   /* length of next code */
    int Count = 0;                  /* repeat count of the current code */
    int MaxCount = 7;               /* max repeat count */
    int MinCount = 4;               /* min repeat count */

    if (NextLength == 0)
    {
        MaxCount = 138;
        MinCount = 3;
    }
    Tree[MaxCode+1].FatherLength.Length = (unsigned short)0xffff; /* guard */

    for (Iter = 0; Iter <= MaxCode; Iter++)
    {
        CurLength = NextLength;
        NextLength = Tree[Iter+1].FatherLength.Length;
        if (++Count < MaxCount && CurLength == NextLength)
            continue;
        else if (Count < MinCount)
            BitLengthsTree[CurLength].FrequencyCode.Frequency += (unsigned short)Count;
        else if (CurLength != 0)
        {
            if (CurLength != PrevLength)
                BitLengthsTree[CurLength].FrequencyCode.Frequency++;
            BitLengthsTree[REP_3_6].FrequencyCode.Frequency++;
        }
        else if (Count <= 10)
            BitLengthsTree[REPZ_3_10].FrequencyCode.Frequency++;
        else
            BitLengthsTree[REPZ_11_138].FrequencyCode.Frequency++;
        Count = 0;
        PrevLength = CurLength;
        if (NextLength == 0)
        {
            MaxCount = 13;
            MinCount = 3;
        }
        else if (CurLength == NextLength)
        {
            MaxCount = 6;
            MinCount = 3;
        }
        else
        {
            MaxCount = 7;
            MinCount = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * BitLengthsTree.
 */
static void
SendTree(
         ValueCodeString_t  *Tree,     /* the tree to be scanned */
         int                 MaxCode,  /* and its largest code of non zero frequency */
         LocalBits_t        *Bits,
         CompParam_t        *Comp
        )
{
    int Iter;                     /* iterates over all tree elements */
    int PrevLength = -1;          /* last emitted length */
    int CurLength;                /* length of current code */
    int NextLength = Tree[0].FatherLength.Length; /* length of next code */
    int Count = 0;                /* repeat count of the current code */
    int MaxCount = 7;             /* max repeat count */
    int MinCount = 4;             /* min repeat count */

    /* tree[MaxCode+1].FatherLength.Length = -1; */  /* guard already set */
    if (NextLength == 0)
    {
        MaxCount = 138;
        MinCount = 3;
    }

    for (Iter = 0; Iter <= MaxCode; Iter++)
    {
        CurLength = NextLength;
        NextLength = Tree[Iter+1].FatherLength.Length;
        if (++Count < MaxCount && CurLength == NextLength)
            continue;
        else if (Count < MinCount)
        {
            do
            {
                SendCode(CurLength, BitLengthsTree, Bits, Comp);
            } while (--Count != 0);
        }
        else if (CurLength != 0)
        {
            if (CurLength != PrevLength)
            {
                SendCode(CurLength, BitLengthsTree, Bits, Comp);
                Count--;
            }
            Assert(Count >= 3 && Count <= 6, " 3_6?");
            SendCode(REP_3_6, BitLengthsTree, Bits, Comp);
            SendBits(Count-3, 2, Bits, Comp);
        }
        else if (Count <= 10)
        {
            SendCode(REPZ_3_10, BitLengthsTree, Bits, Comp);
            SendBits(Count-3, 3, Bits, Comp);

        }
        else
        {
            SendCode(REPZ_11_138, BitLengthsTree, Bits, Comp);
            SendBits(Count-11, 7, Bits, Comp);
        }
        Count = 0;
        PrevLength = CurLength;
        if (NextLength == 0)
        {
            MaxCount = 138;
            MinCount = 3;
        }
        else if (CurLength == NextLength)
        {
            MaxCount = 6;
            MinCount = 3;
        }
        else
        {
            MaxCount = 7;
            MinCount = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * BitLengthsOrder of the last bit length code to send.
 */
static int
BuildBitLengthsTree(
                    void
                   )
{
    int MaxIndex;  /* index of last bit length code of non zero FrequencyCode.Frequency */

    /* Determine the bit length frequencies for literal and distance trees */
    ScanTree((ValueCodeString_t *)DynLiteralTree, LengthDesc.MaxCode);
    ScanTree((ValueCodeString_t *)DynDistanceTree, DistanceDesc.MaxCode);

    /* Build the bit length tree: */
    BuildTree((TreeDesc_t *)(&BitLengthsDesc));
    /* OptimalLength now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (MaxIndex = BL_CODES-1; MaxIndex >= 3; MaxIndex--)
    {
        if (BitLengthsTree[BitLengthsOrder[MaxIndex]].FatherLength.Length != 0)
            break;
    }
    /* Update OptimalLength to include the bit length tree and counts */
    Xtree.OptimalLength += (unsigned long)(3*(MaxIndex+1) + 5+5+4);

    return MaxIndex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: LCodes >= 257, DCodes >= 1, BlCodes >= 4.
 */
static void
SendAllTrees(
             int            LCodes,
             int            DCodes,
             int            BlCodes, /* number of codes for each tree */
             LocalBits_t   *Bits,
             CompParam_t   *Comp
            )
{
    int Rank;                    /* index in BitLengthsOrder */

    Assert (LCodes >= 257 && DCodes >= 1 && BlCodes >= 4,
            "not enough codes");
    Assert (LCodes <= L_CODES && DCodes <= D_CODES && BlCodes <= BL_CODES,
            "too many codes");

    SendBits(LCodes-257, 5, Bits, Comp); /* not +255 as stated in appnote.txt */
    SendBits(DCodes-1,   5, Bits, Comp);
    SendBits(BlCodes-4,  4, Bits, Comp); /* not -3 as stated in appnote.txt */
    for (Rank = 0; Rank < BlCodes; Rank++)
    {
        SendBits(BitLengthsTree[BitLengthsOrder[Rank]].FatherLength.Length, 3, Bits, Comp);
    }

    SendTree((ValueCodeString_t *)DynLiteralTree, LCodes-1, Bits, Comp);
    /* send the literal tree */

    SendTree((ValueCodeString_t *)DynDistanceTree, DCodes-1, Bits, Comp); /* send the distance tree */
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip buffer. This function
 * returns the total compressed length for the data so far.
 */
unsigned long
FlushBlock(
           char          *Input,       /* input block, or NULL if too old */
           unsigned long  StoredLength,  /* length of input block */
           int            Eof,         /* true if this is the last block for a buffer */
           LocalBits_t   *Bits,
           CompParam_t   *Comp
          )
{
    unsigned long OptLengthb, StaticLengthb;
    /* OptLength and StaticLength in bytes */
    int MaxIndex;  /* index of last bit length code of non zero FrequencyCode.Frequency */

    FlagBuffer[Xtree.FlagIndex] = Xtree.Flags; /* Save the flags for the last 8 items */

    /* Construct the literal and distance trees */
    BuildTree((TreeDesc_t *)(&LengthDesc));

    BuildTree((TreeDesc_t *)(&DistanceDesc));
    /* At this point, OptimalLength and StaticLength are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in BitLengthsOrder of the last bit length code to send.
     */
    MaxIndex = BuildBitLengthsTree();

    /* Determine the best encoding. Compute first the block length in bytes */
    OptLengthb = (Xtree.OptimalLength+3+7)>>3;
    StaticLengthb = (Xtree.StaticLength+3+7)>>3;
    Xtree.InputLength += StoredLength; /* for debugging only */

    if (StaticLengthb <= OptLengthb)
        OptLengthb = StaticLengthb;

    /* If compression failed and this is the first and last block,
     * the whole buffer is transformed into a stored buffer:
     */

    if (StoredLength <= OptLengthb && Eof && Xtree.CompressedLength == 0L)
    {
        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        if (Input == (char *)0)
            return BLOCK_VANISHED;

        CopyBlock(Input, (unsigned int)StoredLength, 0, Bits, Comp);
        /* without header */
        Xtree.CompressedLength = StoredLength << 3;

    }
    else if (StoredLength+4 <= OptLengthb && Input != (char *)0)
    {
        /* 4: two words for the lengths */

        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        SendBits((STORED_BLOCK<<1)+Eof, 3, Bits, Comp);  /* send block type */
        Xtree.CompressedLength = (Xtree.CompressedLength + 3 + 7) & ~7L;
        Xtree.CompressedLength += (StoredLength + 4) << 3;

        CopyBlock(Input, (unsigned int)StoredLength, 1, Bits, Comp); /* with header */

    }
    else if (StaticLengthb == OptLengthb)
    {
        SendBits((STATIC_TREES<<1)+Eof, 3, Bits, Comp);
        CompressBlock((ValueCodeString_t *)StaticLiteralTree, (ValueCodeString_t *)StaticDistanceTree, Bits,
                       Comp);
        Xtree.CompressedLength += 3 + Xtree.StaticLength;
    }
    else
    {
        SendBits((DYN_TREES<<1)+Eof, 3, Bits, Comp);
        SendAllTrees(LengthDesc.MaxCode+1, DistanceDesc.MaxCode+1,
               MaxIndex+1, Bits, Comp);
        CompressBlock((ValueCodeString_t *)DynLiteralTree, (ValueCodeString_t *)DynDistanceTree,
               Bits, Comp);
        Xtree.CompressedLength += 3 + Xtree.OptimalLength;
    }
    Assert (Xtree.CompressedLength == bits_sent, "bad compressed size");
    InitializeBlock();

    if (Eof)
    {
        Assert (Xtree.InputLength == Comp->InputSize, "bad input size");
        WindupBits(Bits, Comp);
        Xtree.CompressedLength += 7;  /* align on byte boundary */
    }

    return Xtree.CompressedLength >> 3;
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int
TallyFrequencies(
                 int             Dist,  /* distance of matched string */
                 int             LengthC,   /* match length-MIN_MATCH or unmatched char (if dist==0) */
                 int             Level, /* compression level */
                 DeflateParam_t *Defl,
                 CompParam_t    *Comp
                )
{
    Comp->Input[Xtree.InputIndex++] = (unsigned char)LengthC;
    if (Dist == 0)
    {
        /* LengthC is the unmatched char */
        DynLiteralTree[LengthC].FrequencyCode.Frequency++;
    }
    else
    {
        /* Here, LengthC is the match length - MIN_MATCH */
        Dist--;             /* dist = match distance - 1 */
        Assert((unsigned short)Dist < (unsigned short)MAX_DIST &&
               (unsigned short)LengthC <= (unsigned short)(MAX_MATCH-MIN_MATCH) &&
               (unsigned short)DistCode(Dist) < (unsigned short)D_CODES,
               "TallyFrequencies: bad match");

        DynLiteralTree[LengthCode[LengthC]+LITERALS+1].FrequencyCode.Frequency++;
        DynDistanceTree[DistCode((unsigned int)Dist)].FrequencyCode.Frequency++;

        Comp->DistBuffer[Xtree.DistIndex++] = (unsigned short)Dist;
        Xtree.Flags |= Xtree.FlagBit;
    }
    Xtree.FlagBit <<= 1;

    /* Output the flags if they fill a byte: */
    if ((Xtree.InputIndex & 7) == 0)
    {
        FlagBuffer[Xtree.FlagIndex++] = Xtree.Flags;
        Xtree.Flags = 0;
        Xtree.FlagBit = 1;
    }
    /* Try to guess if it is profitable to stop the current block here */
    if (Level > 2 && (Xtree.InputIndex & 0xfff) == 0)
    {
        /* Compute an upper bound for the compressed length */
        unsigned long OutLength = (unsigned long)Xtree.InputIndex*8L;
        unsigned long InLength  = (unsigned long)((long)Defl->StringStart-Defl->BlockStart);
        int DCode;
        for (DCode = 0; DCode < D_CODES; DCode++)
        {
            OutLength += (unsigned long)(DynDistanceTree[DCode].FrequencyCode.Frequency*(5L+ExtraDBits[DCode]));
        }
        OutLength >>= 3;

        if (Xtree.DistIndex < Xtree.InputIndex/2 && OutLength < InLength/2)
            return 1;
    }
    return (Xtree.InputIndex == LIT_BUFSIZE-1 || Xtree.DistIndex == DIST_BUFSIZE);
    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
static void
CompressBlock(
              ValueCodeString_t *LTree, /* literal tree */
              ValueCodeString_t *DTree, /* distance tree */
              LocalBits_t       *Bits,
              CompParam_t       *Comp
             )
{
    unsigned int    Distance;      /* distance of matched string */
    int             MatchLength;             /* match length or unmatched char (if Distance == 0) */
    unsigned int    InputIndex = 0;    /* running index in Input */
    unsigned int    DistIndex = 0;    /* running index in DistBuffer */
    unsigned int    FlagIndex = 0;    /* running index in FlagBuffer */
    unsigned char   Flag = 0;       /* current flags */
    unsigned int    Code;      /* the code to send */
    int             Extra;          /* number of extra bits to send */

    if (Xtree.InputIndex != 0)
    do
    {
        if ((InputIndex & 7) == 0)
            Flag = FlagBuffer[FlagIndex++];
        MatchLength = Comp->Input[InputIndex++];
        if ((Flag & 1) == 0)
        {
            SendCode(MatchLength, LTree, Bits, Comp); /* send a literal byte */
        }
        else
        {
            /* Here, MatchLength is the match length - MIN_MATCH */
            Code = LengthCode[MatchLength];
            /* send the length code */
            SendCode(Code + LITERALS + 1, LTree, Bits, Comp);
            Extra = (int)ExtraLBits[Code];
            if (Extra != 0)
            {
                MatchLength -= BaseLength[Code];
                SendBits(MatchLength, Extra, Bits, Comp);
                /* send the extra length bits */
            }
            Distance = Comp->DistBuffer[DistIndex++];
            /* Here, Distance is the match distance - 1 */
            Code = DistCode(Distance);
            Assert (Code < D_CODES, "bad DistCode");

            /* send the distance code */
            SendCode((int)Code, DTree, Bits, Comp);
            Extra = (int)ExtraDBits[Code];
            if (Extra != 0)
            {
                Distance -= BaseDistance[Code];
                SendBits((int)Distance, Extra, Bits, Comp);
                /* send the extra distance bits */
            }
        } /* literal or match pair ? */
        Flag >>= 1;
    } while (InputIndex < Xtree.InputIndex);

    SendCode(END_BLOCK, LTree, Bits, Comp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gemcomp\ccdef.h ===
/*******************************************************************************
*                       Copyright (c) 1998 Gemplus Development
*
* Name        : CCDEF.H
*
* Description : Common definition for Compert utility.
*
  Author      : Laurent CASSIER

  Compiler    : Microsoft Visual C 1.5x/2.0
                ANSI C UNIX.

  Host        : IBM PC and compatible machines under Windows 3.x.
                UNIX machine.

* Release     : 1.00.001
*
* Last Modif. : 04/03/98: V1.00.001 - First implementation.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/

/*------------------------------------------------------------------------------
Name definition:
   _CCDEF_H is used to avoid multiple inclusion.
------------------------------------------------------------------------------*/
#ifndef _CCDEF_H
#define _CCDEF_H

#ifndef _WINDOWS
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned char   BYTE;
#endif


#define NULL_PTR        0
#define ABSENT_PARAMETER_CHAR    0x7F
#define ESCAPE_CHAR     0xFF

#define TAG_COMPRESSION_FAILED	0xFF

#define ALGO_NONE		0
#define ALGO_ACFX8	1	/* Arithmetic coding, byte oriented, fixed model */
#define ALGO_ACAD8	2	/* Arithmetic coding, byte oriented, adaptative model */
#define ALGO_3			3	/* RFU */
#define ALGO_4			4	/* RFU */
#define ALGO_5			5	/* RFU */
#define ALGO_6			6	/* RFU */
#define ALGO_7			7	/* RFU */

#define MAX_RDN         255
#define MAX_AVA         255
#define MAX_EXTENSION   255

#define TAG_INTEGER              0x02
#define TAG_BIT_STRING           0x03
#define TAG_OBJECT_IDENTIFIER    0x06
#define TAG_UTCT                 0x17
#define TAG_SEQUENCE             0x30
#define TAG_SEQUENCE_OF          0x30
#define TAG_SET                  0x31
#define TAG_SET_OF               0x31
#define TAG_OPTION_VERSION       0xA0
#define TAG_OPTION_ISSUER_UID    0xA1
#define TAG_OPTION_SUBJECT_UID   0xA2
#define TAG_OPTION_EXTENSIONS    0xA3

#define UTCT_YYMMDDhhmmZ         0
#define UTCT_YYMMDDhhmmphhmm     1
#define UTCT_YYMMDDhhmmmhhmm     2
#define UTCT_YYMMDDhhmmssZ       3
#define UTCT_YYMMDDhhmmssphhmm   4
#define UTCT_YYMMDDhhmmssmhhmm   5

#define UTCT_MINUTE_IN_YEAR   525600
#define UTCT_MINUTE_IN_DAY      1440
#define UTCT_MINUTE_IN_HOUR       60

#define UTCT_SECOND_IN_YEAR 31536000
#define UTCT_SECOND_IN_DAY     86400
#define UTCT_SECOND_IN_HOUR     3600
#define UTCT_SECOND_IN_MINUTE     60

/*
*  Define the ASSERT macro
*/
#define ASSERT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gemcomp\gmem.c ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors:
//          Thierry Tremblay
//          Francois Paradis
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////

#include <gmem.h>



///////////////////////////////////////////////////////////////////////////////////////////
//
// Heap memory management
//
///////////////////////////////////////////////////////////////////////////////////////////

void* GMEM_Alloc( size_t size )
{
   return (void*) malloc( size );
}



void* GMEM_ReAlloc( void* pMemory, size_t newSize )
{
   return (void*) realloc( pMemory, newSize );
}



void GMEM_Free( void* pMemory )
{
   if (pMemory)
   {
       free( pMemory );
       pMemory = NULL;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gemcomp\compcert.c ===
/*******************************************************************************
*                       Copyright (c) 1998 Gemplus Development
*
* Name        : COMPCERT.C
*
* Description : Programme de compression de certificat X.509
*
* Author      : Christophe Clavier
*
* Modify      : Laurent CASSIER
*
* Compiler    : Microsoft Visual C 5.0
*
* Host        : IBM PC and compatible machines under Windows 95.
*
* Release     : 1.10.001
*
* Last Modif  : 04/03/98: V1.10.001 - Change dictionary management and add
*                                     CC_Init(), CC_Exit() functions.
*               30/01/98: V1.00.005 - Cancel (_OPT_HEADER) the modification in
*                                     the length of subjectPKInfo and signature
*                                     made in the previous version.
*               28/01/98: V1.00.004 - Allows up to 32767 entries in the dictionary
*                                     and stores the length of the subjectPKInfo
*                                     and signature on one byte instead of two if
*                                     it is less than 128.
*               13/01/98: V1.00.003 - Modify for meta-compression and dictionary
*                                     version ascending compatibility.
*               11/12/97: V1.00.002 - Modify for new dictionary format
*                                     and compatible with CSP and PKCS.
*               27/08/97: V1.00.001 - First implementation.
*
********************************************************************************
*
* Warning     :
*
* Remark      : Flags de compilations :
*
*                - _STUDY : Lorsqu'il est dfini, des fichiers de log utiles
*                           lors de l'tude de l'efficacit des algos
*                           de compression. sont gnrs.
*
*                - _TRICKY_COMPRESSION : Lorsqu'il est dfini, on ne tente pas
*                                        de compresser les champs
*                                        'subjectPublicKey' et 'signature' qui
*                                        sont essentiellement alatoires.
*
*                - _OPT_HEADER : Lorsqu'il est dfini, et si _TRICKY_COMPRESSION
*                                est dfini galement, le header de longueur des
*                                compresss de subjectPKInfo et de signature
*                                sont optimiss pour ne tenir sur un seul octet
*                                si la longueur est infrieure  128 au lieu de
*                                deux octets dans tous les cas sinon.
*                                Ne pas dfinir ce flag permet d'tre compatible
*                                avec les versions infrieures  1.00.005 
*
*                - _GLOBAL_COMPRESSION : Lorsqu'il est dfini, le compress du
*                                        certificat est lui mme envoy  la
*                                        fonction CC_RawEncode afin d'y appliquer
*                                        le meilleur algo de compression dispo.
*
*                - _OPT_HEADER : Lorsqu'il est dfini, l
*                                certificat est lui mme envoy  la
*                                      fonction CC_RawEncode afin d'y appliquer
*                                        le meilleur algo de compression dispo.
*
*                - _ALGO_x (x de 1  7) : Lorsqu'il est dfini, l'algo de
*                                         compression numro x est utilis.
*
*               Conseils pour la version release de GemPASS :
*
*                - _STUDY              : non dfini
*                - _TRICKY_COMPRESSION : dfini
*                - _OPT_HEADER         : non dfini
*                - _GLOBAL_COMPRESSION : non dfini
*                - _ALGO_1             : dfini
*                - _ALGO_2             : dfini
*                - _ALGO_x (x>2)       : non dfini
*
*******************************************************************************/

/*------------------------------------------------------------------------------
                                 Includes files
------------------------------------------------------------------------------*/
#ifdef _WINDOWS
#include <windows.h>
#endif
#include <stdio.h>      
#include <io.h>      
#include <fcntl.h>      
#include <sys/types.h>
#include <sys/stat.h>

#include "ccdef.h"
#include "ac.h"
#include "compcert.h"
#include "gmem.h"
#include "resource.h"

extern HINSTANCE g_hInstRes;

/*------------------------------------------------------------------------------
                             Information section
------------------------------------------------------------------------------*/
#define G_NAME     "COMPCERT"
#define G_RELEASE  "1.10.001"


/*------------------------------------------------------------------------------
                              Static Variables
------------------------------------------------------------------------------*/
                                                
	USHORT NbDaysInMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

   char* AlgorithmTypeDict[] = {
    /* x9-57 */
	"\x2A\x86\x48\xCE\x38\x02\x01", /*x9.57-holdinstruction-none (1 2 840 10040 2 1) */
	"\x2A\x86\x48\xCE\x38\x02\x02", /*x9.57-holdinstruction-callissuer (1 2 840 10040 2 2) */
	"\x2A\x86\x48\xCE\x38\x02\x03", /*x9.57-holdinstruction-reject (1 2 840 10040 2 3) */
	"\x2A\x86\x48\xCE\x38\x04\x01", /*x9.57-dsa (1 2 840 10040 4 1) */
	"\x2A\x86\x48\xCE\x38\x04\x03", /*x9.57-dsaWithSha1 (1 2 840 10040 4 3) */
    
    /* x9-42 */
	"\x2A\x86\x48\xCE\x3E\x02\x01", /*x9.42-dhPublicNumber (1 2 840 10046 2 1) */
	
    /* Nortel Secure Networks */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42",     /*nsn-alg (1 2 840 113533 7 66) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0A", /*nsn-alg-cast5CBC (1 2 840 113533 7 66 10) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0B", /*nsn-alg-cast5MAC (1 2 840 113533 7 66 11) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0C", /*nsn-alg-pbeWithMD5AndCAST5-CBC (1 2 840 113533 7 66 12) */
	
    /* PKCS #1 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01",     /*pkcs-1 (1 2 840 113549 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x01", /*pkcs-1-rsaEncryption (1 2 840 113549 1 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x02", /*pkcs-1-MD2withRSAEncryption (1 2 840 113549 1 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x03", /*pkcs-1-MD4withRSAEncryption (1 2 840 113549 1 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x04", /*pkcs-1-MD5withRSAEncryption (1 2 840 113549 1 1 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x05", /*pkcs-1-SHA1withRSAEncryption (1 2 840 113549 1 1 5) */
	/*need to determine which of the following 2 is correct */
    /*"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x06", pkcs-1-ripemd160WithRSAEncryption (1 2 840 113549 1 1 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x06", /*pkcs-1-rsaOAEPEncryptionSET (1 2 840 113549 1 1 6) */
	
    /* PKCS #3 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x03",     /*pkcs-3 (1 2 840 113549 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x03\x01", /*pkcs-3-dhKeyAgreement (1 2 840 113549 1 3 1) */
	
    /* PKCS #5 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05",     /*pkcs-5 (1 2 840 113549 1 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x01", /*pkcs-5-pbeWithMD2AndDES-CBC (1 2 840 113549 1 5 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x03", /*pkcs-5-pbeWithMD5AndDES-CBC (1 2 840 113549 1 5 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x04", /*pkcs-5-pbeWithMD2AndRC2-CBC (1 2 840 113549 1 5 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x06", /*pkcs-5-pbeWithMD5AndRC2-CBC (1 2 840 113549 1 5 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x09", /*pkcs-5-pbeWithMD5AndXOR (1 2 840 113549 1 5 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x0A", /*pkcs-5-pbeWithSHA1AndDES-CBC (1 2 840 113549 1 5 10) */
	
    /* PKCS #12 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C",         /*pkcs-12 (1 2 840 113549 1 12) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01",     /*pkcs-12-modeID (1 2 840 113549 1 12 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01\x01", /*pkcs-12-OfflineTransportMode (1 2 840 113549 1 12 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01\x02", /*pkcs-12-OnlineTransportMode (1 2 840 113549 1 12 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x02",     /*pkcs-12-ESPVKID (1 2 840 113549 1 12 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x02\x01", /*pkcs-12-PKCS8KeyShrouding (1 2 840 113549 1 12 2 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03",     /*pkcs-12-BagID (1 2 840 113549 1 12 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x01", /*pkcs-12-KeyBagID (1 2 840 113549 1 12 3 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x02", /*pkcs-12-CertAndCRLBagID (1 2 840 113549 1 12 3 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x03", /*pkcs-12-SecretBagID (1 2 840 113549 1 12 3 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04",     /*pkcs-12-CertBagID (1 2 840 113549 1 12 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04\x01", /*pkcs-12-X509CertCRLBag (1 2 840 113549 1 12 4 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04\x02", /*pkcs-12-SDSICertBag (1 2 840 113549 1 12 4 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05",     /*pkcs-12-OID (1 2 840 113549 1 12 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01", /*pkcs-12-PBEID (1 2 840 113549 1 12 5 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x01", /*pkcs-12-PBEWithSha1And128BitRC4 (1 2 840 113549 1 12 5 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x02", /*pkcs-12-PBEWithSha1And40BitRC4 (1 2 840 113549 1 12 5 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x03", /*pkcs-12-PBEWithSha1AndTripleDESCBC (1 2 840 113549 1 12 5 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x04", /*pkcs-12-PBEWithSha1And128BitRC2CBC (1 2 840 113549 1 12 5 1 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x05", /*pkcs-12-PBEWithSha1And40BitRC2CBC (1 2 840 113549 1 12 5 1 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x06", /*pkcs-12-PBEWithSha1AndRC4 (1 2 840 113549 1 12 5 1 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x07", /*pkcs-12-PBEWithSha1AndRC2CBC (1 2 840 113549 1 12 5 1 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02",     /*pkcs-12-EnvelopingID (1 2 840 113549 1 12 5 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x01", /*pkcs-12-RSAEncryptionWith128BitRC4 (1 2 840 113549 1 12 5 2 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x02", /*pkcs-12-RSAEncryptionWith40BitRC4 (1 2 840 113549 1 12 5 2 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x03", /*pkcs-12-RSAEncryptionWithTripleDES (1 2 840 113549 1 12 5 2 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x03",     /*pkcs-12-SignatureID (1 2 840 113549 1 12 5 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x03\x01", /*pkcs-12-RSASignatureWithSHA1Digest (1 2 840 113549 1 12 5 3 1) */

    /* RSADSI digest algorithms */
	"\x2A\x86\x48\x86\xF7\x0D\x02",     /*RSADSI-digestAlgorithm (1 2 840 113549 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x02", /*RSADSI-md2 (1 2 840 113549 2 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x04", /*RSADSI-md4 (1 2 840 113549 2 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x05", /*RSADSI-md5 (1 2 840 113549 2 5) */
	
    /* RSADSI encryption algorithms */
	"\x2A\x86\x48\x86\xF7\x0D\x03",     /*RSADSI-encryptionAlgorithm (1 2 840 113549 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x02", /*RSADSI-rc2CBC (1 2 840 113549 3 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x03", /*RSADSI-rc2ECB (1 2 840 113549 3 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x04", /*RSADSI-rc4 (1 2 840 113549 3 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x05", /*RSADSI-rc4WithMAC (1 2 840 113549 3 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x06", /*RSADSI-DESX-CBC (1 2 840 113549 3 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x07", /*RSADSI-DES-EDE3-CBC (1 2 840 113549 3 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x08", /*RSADSI-RC5CBC (1 2 840 113549 3 8) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x09", /*RSADSI-RC5CBCPad (1 2 840 113549 3 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x0A", /*RSADSI-CDMFCBCPad (1 2 840 113549 3 10) */
	
    /* cryptlib */
	"\x2B\x06\x01\x04\x01\x97\x55\x20\x01", /*cryptlibEnvelope (1 3 6 1 4 1 3029 32 1) */

    /* Not sure about these ones: */
	/*"\x2B\x0E\x02\x1A\x05",     sha (1 3 14 2 26 5) */
	/*"\x2B\x0E\x03\x02\x01\x01", rsa (1 3 14 3 2 1 1) */            //X-509
	/*"\x2B\x0E\x03\x02\x02\x01", sqmod-N (1 3 14 3 2 2 1) */        //X-509
	/*"\x2B\x0E\x03\x02\x03\x01", sqmod-NwithRSA (1 3 14 3 2 3 1) */ //X-509

   /* Miscellaneous partially-defunct OIW semi-standards aka algorithms */
	"\x2B\x0E\x03\x02\x02",     /*ISO-algorithm-md4WitRSA (1 3 14 3 2 2) */
	"\x2B\x0E\x03\x02\x03",     /*ISO-algorithm-md5WithRSA (1 3 14 3 2 3) */
	"\x2B\x0E\x03\x02\x04",     /*ISO-algorithm-md4WithRSAEncryption (1 3 14 3 2 4) */
	"\x2B\x0E\x03\x02\x06",     /*ISO-algorithm-desECB (1 3 14 3 2 6) */
	"\x2B\x0E\x03\x02\x07",     /*ISO-algorithm-desCBC (1 3 14 3 2 7) */
	"\x2B\x0E\x03\x02\x08",     /*ISO-algorithm-desOFB (1 3 14 3 2 8) */
	"\x2B\x0E\x03\x02\x09",     /*ISO-algorithm-desCFB (1 3 14 3 2 9) */
	"\x2B\x0E\x03\x02\x0A",     /*ISO-algorithm-desMAC (1 3 14 3 2 10) */
	"\x2B\x0E\x03\x02\x0B",     /*ISO-algorithm-rsaSignature (1 3 14 3 2 11) */   //ISO 9796
	"\x2B\x0E\x03\x02\x0C",     /*ISO-algorithm-dsa (1 3 14 3 2 12) */
	"\x2B\x0E\x03\x02\x0D",     /*ISO-algorithm-dsaWithSHA (1 3 14 3 2 13) */
	"\x2B\x0E\x03\x02\x0E",     /*ISO-algorithm-mdc2WithRSASignature (1 3 14 3 2 14) */
	"\x2B\x0E\x03\x02\x0F",     /*ISO-algorithm-shaWithRSASignature (1 3 14 3 2 15) */
	"\x2B\x0E\x03\x02\x10",     /*ISO-algorithm-dhWithCommonModulus (1 3 14 3 2 16) */
	"\x2B\x0E\x03\x02\x11",     /*ISO-algorithm-desEDE (1 3 14 3 2 17) */
	"\x2B\x0E\x03\x02\x12",     /*ISO-algorithm-sha (1 3 14 3 2 18) */
	"\x2B\x0E\x03\x02\x13",     /*ISO-algorithm-mdc-2 (1 3 14 3 2 19) */
	"\x2B\x0E\x03\x02\x14",     /*ISO-algorithm-dsaCommon (1 3 14 3 2 20) */
	"\x2B\x0E\x03\x02\x15",     /*ISO-algorithm-dsaCommonWithSHA (1 3 14 3 2 21) */
	"\x2B\x0E\x03\x02\x16",     /*ISO-algorithm-rsaKeyTransport (1 3 14 3 2 22) */
	"\x2B\x0E\x03\x02\x17",     /*ISO-algorithm-keyed-hash-seal (1 3 14 3 2 23) */
	"\x2B\x0E\x03\x02\x18",     /*ISO-algorithm-md2WithRSASignature (1 3 14 3 2 24) */
	"\x2B\x0E\x03\x02\x19",     /*ISO-algorithm-md5WithRSASignature (1 3 14 3 2 25) */
	"\x2B\x0E\x03\x02\x1A",     /*ISO-algorithm-sha1 (1 3 14 3 2 26) */
	"\x2B\x0E\x03\x02\x1B",     /*ISO-algorithm-ripemd160 (1 3 14 3 2 27) */
	"\x2B\x0E\x03\x02\x1D",     /*ISO-algorithm-sha-1WithRSAEncryption (1 3 14 3 2 29) */
	"\x2B\x0E\x03\x03\x01",     /*ISO-algorithm-simple-strong-auth-mechanism (1 3 14 3 3 1) */
    /* Not sure about these ones:
	/*"\x2B\x0E\x07\x02\x01\x01", ElGamal (1 3 14 7 2 1 1) */
	/*"\x2B\x0E\x07\x02\x03\x01", md2WithRSA (1 3 14 7 2 3 1) */
	/*"\x2B\x0E\x07\x02\x03\x02", md2WithElGamal (1 3 14 7 2 3 2) */
	
    /* X500 algorithms */
	"\x55\x08",         /*X500-Algorithms (2 5 8) */
	"\x55\x08\x01",     /*X500-Alg-Encryption (2 5 8 1) */
	"\x55\x08\x01\x01", /*rsa (2 5 8 1 1) */
	
    /* DMS-SDN-702 */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x01", /*id-sdnsSignatureAlgorithm (2 16 840 1 101 2 1 1 1) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x02", /*id-mosaicSignatureAlgorithm (2 16 840 1 101 2 1 1 2) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x03", /*id-sdnsConfidentialityAlgorithm (2 16 840 1 101 2 1 1 3) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x04", /*id-mosaicConfidentialityAlgorithm (2 16 840 1 101 2 1 1 4) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x05", /*id-sdnsIntegrityAlgorithm (2 16 840 1 101 2 1 1 5) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x06", /*id-mosaicIntegrityAlgorithm (2 16 840 1 101 2 1 1 6) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x07", /*id-sdnsTokenProtectionAlgorithm (2 16 840 1 101 2 1 1 7) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x08", /*id-mosaicTokenProtectionAlgorithm (2 16 840 1 101 2 1 1 8) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x09", /*id-sdnsKeyManagementAlgorithm (2 16 840 1 101 2 1 1 9) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0A", /*id-mosaicKeyManagementAlgorithm (2 16 840 1 101 2 1 1 10) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0B", /*id-sdnsKMandSigAlgorithm (2 16 840 1 101 2 1 1 11) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0C", /*id-mosaicKMandSigAlgorithm (2 16 840 1 101 2 1 1 12) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0D", /*id-SuiteASignatureAlgorithm (2 16 840 1 101 2 1 1 13) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0E", /*id-SuiteAConfidentialityAlgorithm (2 16 840 1 101 2 1 1 14) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0F", /*id-SuiteAIntegrityAlgorithm (2 16 840 1 101 2 1 1 15) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x10", /*id-SuiteATokenProtectionAlgorithm (2 16 840 1 101 2 1 1 16) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x11", /*id-SuiteAKeyManagementAlgorithm (2 16 840 1 101 2 1 1 17) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x12", /*id-SuiteAKMandSigAlgorithm (2 16 840 1 101 2 1 1 18) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x13", /*id-mosaicUpdatedSigAlgorithm (2 16 840 1 101 2 1 1 19) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x14", /*id-mosaicKMandUpdSigAlgorithms (2 16 840 1 101 2 1 1 20) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x15", /*id-mosaicUpdatedIntegAlgorithm (2 16 840 1 101 2 1 1 21) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x16", /*id-mosaicKeyEncryptionAlgorithm (2 16 840 1 101 2 1 1 22) */
	
   NULL	
   };


	char* AttributeTypeDict[] = {
    /* x9-57 */
	"\x2A\x86\x48\xCE\x38\x02\x01", /*x9.57-holdinstruction-none (1 2 840 10040 2 1) */
	"\x2A\x86\x48\xCE\x38\x02\x02", /*x9.57-holdinstruction-callissuer (1 2 840 10040 2 2) */
	"\x2A\x86\x48\xCE\x38\x02\x03", /*x9.57-holdinstruction-reject (1 2 840 10040 2 3) */
	"\x2A\x86\x48\xCE\x38\x04\x01", /*x9.57-dsa (1 2 840 10040 4 1) */
	"\x2A\x86\x48\xCE\x38\x04\x03", /*x9.57-dsaWithSha1 (1 2 840 10040 4 3) */
    
    /* x9-42 */
	"\x2A\x86\x48\xCE\x3E\x02\x01", /*x9.42-dhPublicNumber (1 2 840 10046 2 1) */
	
    /* Nortel Secure Networks */
	"\x2A\x86\x48\x86\xF6\x7D\x07",         /*nsn (1 2 840 113533 7) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x41\x00", /*nsn-ce-entrustVersInfo (1 2 840 113533 7 65 0) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x41",     /*nsn-ce (1 2 840 113533 7 65) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42",     /*nsn-alg (1 2 840 113533 7 66) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0A", /*nsn-alg-cast5CBC (1 2 840 113533 7 66 10) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0B", /*nsn-alg-cast5MAC (1 2 840 113533 7 66 11) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0C", /*nsn-alg-pbeWithMD5AndCAST5-CBC (1 2 840 113533 7 66 12) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x43",     /*nsn-oc (1 2 840 113533 7 67) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x43\x0C", /*nsn-oc-entrustUser (1 2 840 113533 7 67 0) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x44\x00", /*nsn-at-entrustCAInfo (1 2 840 113533 7 68 0) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x44\x0A", /*nsn-at-attributeCertificate (1 2 840 113533 7 68 10) */
	"\x2A\x86\x48\x86\xF6\x7D\x07\x44",     /*nsn-at (1 2 840 113533 7 68) */
	
    /* PKCS #1 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01",     /*pkcs-1 (1 2 840 113549 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x01", /*pkcs-1-rsaEncryption (1 2 840 113549 1 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x02", /*pkcs-1-MD2withRSAEncryption (1 2 840 113549 1 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x03", /*pkcs-1-MD4withRSAEncryption (1 2 840 113549 1 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x04", /*pkcs-1-MD5withRSAEncryption (1 2 840 113549 1 1 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x05", /*pkcs-1-SHA1withRSAEncryption (1 2 840 113549 1 1 5) */
	/*need to determine which of the following 2 is correct */
    /*"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x06", pkcs-1-ripemd160WithRSAEncryption (1 2 840 113549 1 1 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x01\x06", /*pkcs-1-rsaOAEPEncryptionSET (1 2 840 113549 1 1 6) */
	
    /* PKCS #3 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x03",     /*pkcs-3 (1 2 840 113549 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x03\x01", /*pkcs-3-dhKeyAgreement (1 2 840 113549 1 3 1) */
	
    /* PKCS #5 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05",     /*pkcs-5 (1 2 840 113549 1 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x01", /*pkcs-5-pbeWithMD2AndDES-CBC (1 2 840 113549 1 5 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x03", /*pkcs-5-pbeWithMD5AndDES-CBC (1 2 840 113549 1 5 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x04", /*pkcs-5-pbeWithMD2AndRC2-CBC (1 2 840 113549 1 5 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x06", /*pkcs-5-pbeWithMD5AndRC2-CBC (1 2 840 113549 1 5 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x09", /*pkcs-5-pbeWithMD5AndXOR (1 2 840 113549 1 5 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x05\x0A", /*pkcs-5-pbeWithSHA1AndDES-CBC (1 2 840 113549 1 5 10) */
	
    /* PKCS #7 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07",     /*pkcs-7 (1 2 840 113549 1 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x01", /*pkcs-7-data (1 2 840 113549 1 7 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x02", /*pkcs-7-signedData (1 2 840 113549 1 7 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x03", /*pkcs-7-envelopedData (1 2 840 113549 1 7 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x04", /*pkcs-7-signedAndEnvelopedData (1 2 840 113549 1 7 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x05", /*pkcs-7-digestData (1 2 840 113549 1 7 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x06", /*pkcs-7-encryptedData (1 2 840 113549 1 7 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x07", /*pkcs-7-dataWithAttributes (1 2 840 113549 1 7 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x07\x08", /*pkcs-7-encryptedPrivateKeyInfo (1 2 840 113549 1 7 8) */
	
    /* PKCS #9 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09",     /*pkcs-9 (1 2 840 113549 1 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x01", /*pkcs-9-emailAddress (1 2 840 113549 1 9 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x02", /*pkcs-9-unstructuredName (1 2 840 113549 1 9 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x03", /*pkcs-9-contentType (1 2 840 113549 1 9 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x04", /*pkcs-9-messageDigest (1 2 840 113549 1 9 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x05", /*pkcs-9-signingTime (1 2 840 113549 1 9 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x06", /*pkcs-9-countersignature (1 2 840 113549 1 9 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x07", /*pkcs-9-challengePassword (1 2 840 113549 1 9 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x08", /*pkcs-9-unstructuredAddress (1 2 840 113549 1 9 8) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x09", /*pkcs-9-extendedCertificateAttributes (1 2 840 113549 1 9 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0A", /*pkcs-9-issuerAndSerialNumber (1 2 840 113549 1 9 10) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0B", /*pkcs-9-passwordCheck (1 2 840 113549 1 9 11) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0C", /*pkcs-9-publicKey (1 2 840 113549 1 9 12) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0D", /*pkcs-9-signingDescription (1 2 840 113549 1 9 13) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0E", /*pkcs-9-X.509 extension (1 2 840 113549 1 9 14) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x09\x0F", /*pkcs-9-SMIMECapabilities (1 2 840 113549 1 9 15) */
	
    /* PKCS #12 */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C",         /*pkcs-12 (1 2 840 113549 1 12) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01",     /*pkcs-12-modeID (1 2 840 113549 1 12 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01\x01", /*pkcs-12-OfflineTransportMode (1 2 840 113549 1 12 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x01\x02", /*pkcs-12-OnlineTransportMode (1 2 840 113549 1 12 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x02",     /*pkcs-12-ESPVKID (1 2 840 113549 1 12 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x02\x01", /*pkcs-12-PKCS8KeyShrouding (1 2 840 113549 1 12 2 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03",     /*pkcs-12-BagID (1 2 840 113549 1 12 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x01", /*pkcs-12-KeyBagID (1 2 840 113549 1 12 3 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x02", /*pkcs-12-CertAndCRLBagID (1 2 840 113549 1 12 3 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x03\x03", /*pkcs-12-SecretBagID (1 2 840 113549 1 12 3 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04",     /*pkcs-12-CertBagID (1 2 840 113549 1 12 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04\x01", /*pkcs-12-X509CertCRLBag (1 2 840 113549 1 12 4 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x04\x02", /*pkcs-12-SDSICertBag (1 2 840 113549 1 12 4 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05",     /*pkcs-12-OID (1 2 840 113549 1 12 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01", /*pkcs-12-PBEID (1 2 840 113549 1 12 5 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x01", /*pkcs-12-PBEWithSha1And128BitRC4 (1 2 840 113549 1 12 5 1 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x02", /*pkcs-12-PBEWithSha1And40BitRC4 (1 2 840 113549 1 12 5 1 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x03", /*pkcs-12-PBEWithSha1AndTripleDESCBC (1 2 840 113549 1 12 5 1 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x04", /*pkcs-12-PBEWithSha1And128BitRC2CBC (1 2 840 113549 1 12 5 1 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x05", /*pkcs-12-PBEWithSha1And40BitRC2CBC (1 2 840 113549 1 12 5 1 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x06", /*pkcs-12-PBEWithSha1AndRC4 (1 2 840 113549 1 12 5 1 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x01\x07", /*pkcs-12-PBEWithSha1AndRC2CBC (1 2 840 113549 1 12 5 1 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02",     /*pkcs-12-EnvelopingID (1 2 840 113549 1 12 5 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x01", /*pkcs-12-RSAEncryptionWith128BitRC4 (1 2 840 113549 1 12 5 2 1) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x02", /*pkcs-12-RSAEncryptionWith40BitRC4 (1 2 840 113549 1 12 5 2 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x02\x03", /*pkcs-12-RSAEncryptionWithTripleDES (1 2 840 113549 1 12 5 2 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x03",     /*pkcs-12-SignatureID (1 2 840 113549 1 12 5 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x01\x0C\x05\x03\x01", /*pkcs-12-RSASignatureWithSHA1Digest (1 2 840 113549 1 12 5 3 1) */

    /* RSADSI digest algorithms */
	"\x2A\x86\x48\x86\xF7\x0D\x02",     /*RSADSI-digestAlgorithm (1 2 840 113549 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x02", /*RSADSI-md2 (1 2 840 113549 2 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x04", /*RSADSI-md4 (1 2 840 113549 2 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x02\x05", /*RSADSI-md5 (1 2 840 113549 2 5) */
	
    /* RSADSI encryption algorithms */
	"\x2A\x86\x48\x86\xF7\x0D\x03",     /*RSADSI-encryptionAlgorithm (1 2 840 113549 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x02", /*RSADSI-rc2CBC (1 2 840 113549 3 2) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x03", /*RSADSI-rc2ECB (1 2 840 113549 3 3) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x04", /*RSADSI-rc4 (1 2 840 113549 3 4) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x05", /*RSADSI-rc4WithMAC (1 2 840 113549 3 5) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x06", /*RSADSI-DESX-CBC (1 2 840 113549 3 6) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x07", /*RSADSI-DES-EDE3-CBC (1 2 840 113549 3 7) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x08", /*RSADSI-RC5CBC (1 2 840 113549 3 8) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x09", /*RSADSI-RC5CBCPad (1 2 840 113549 3 9) */
	"\x2A\x86\x48\x86\xF7\x0D\x03\x0A", /*RSADSI-CDMFCBCPad (1 2 840 113549 3 10) */
	
    /* Microsoft OIDs */
	"\x2A\x86\x48\x86\xF7\x14\x04\x03", /*microsoftExcel (1 2 840 113556 4 3) */
	"\x2A\x86\x48\x86\xF7\x14\x04\x04", /*titledWithOID (1 2 840 113556 4 4) */
	"\x2A\x86\x48\x86\xF7\x14\x04\x05", /*microsoftPowerPoint (1 2 840 113556 4 5) */

    /* cryptlib */
	"\x2B\x06\x01\x04\x01\x97\x55\x20\x01", /*cryptlibEnvelope (1 3 6 1 4 1 3029 32 1) */

    /* PKIX */
	"\x2B\x06\x01\x05\x05\x07",     /*pkix-oid (1 3 6 1 5 5 7) */
	"\x2B\x06\x01\x05\x05\x07\x01", /*pkix-subjectInfoAccess (1 3 6 1 5 5 7 1) */
	"\x2B\x06\x01\x05\x05\x07\x02", /*pkix-authorityInfoAccess (1 3 6 1 5 5 7 2) */
	"\x2B\x06\x01\x05\x05\x07\x04", /*pkix-cps (1 3 6 1 5 5 7 4) */
	"\x2B\x06\x01\x05\x05\x07\x05", /*pkix-userNotice (1 3 6 1 5 5 7 5) */

    /* Not sure about these ones: */
	/*"\x2B\x0E\x02\x1A\x05",     sha (1 3 14 2 26 5) */
	/*"\x2B\x0E\x03\x02\x01\x01", rsa (1 3 14 3 2 1 1) */            //X-509
	/*"\x2B\x0E\x03\x02\x02\x01", sqmod-N (1 3 14 3 2 2 1) */        //X-509
	/*"\x2B\x0E\x03\x02\x03\x01", sqmod-NwithRSA (1 3 14 3 2 3 1) */ //X-509

   /* Miscellaneous partially-defunct OIW semi-standards aka algorithms */
	"\x2B\x0E\x03\x02\x02",     /*ISO-algorithm-md4WitRSA (1 3 14 3 2 2) */
	"\x2B\x0E\x03\x02\x03",     /*ISO-algorithm-md5WithRSA (1 3 14 3 2 3) */
	"\x2B\x0E\x03\x02\x04",     /*ISO-algorithm-md4WithRSAEncryption (1 3 14 3 2 4) */
	"\x2B\x0E\x03\x02\x06",     /*ISO-algorithm-desECB (1 3 14 3 2 6) */
	"\x2B\x0E\x03\x02\x07",     /*ISO-algorithm-desCBC (1 3 14 3 2 7) */
	"\x2B\x0E\x03\x02\x08",     /*ISO-algorithm-desOFB (1 3 14 3 2 8) */
	"\x2B\x0E\x03\x02\x09",     /*ISO-algorithm-desCFB (1 3 14 3 2 9) */
	"\x2B\x0E\x03\x02\x0A",     /*ISO-algorithm-desMAC (1 3 14 3 2 10) */
	"\x2B\x0E\x03\x02\x0B",     /*ISO-algorithm-rsaSignature (1 3 14 3 2 11) */   //ISO 9796
	"\x2B\x0E\x03\x02\x0C",     /*ISO-algorithm-dsa (1 3 14 3 2 12) */
	"\x2B\x0E\x03\x02\x0D",     /*ISO-algorithm-dsaWithSHA (1 3 14 3 2 13) */
	"\x2B\x0E\x03\x02\x0E",     /*ISO-algorithm-mdc2WithRSASignature (1 3 14 3 2 14) */
	"\x2B\x0E\x03\x02\x0F",     /*ISO-algorithm-shaWithRSASignature (1 3 14 3 2 15) */
	"\x2B\x0E\x03\x02\x10",     /*ISO-algorithm-dhWithCommonModulus (1 3 14 3 2 16) */
	"\x2B\x0E\x03\x02\x11",     /*ISO-algorithm-desEDE (1 3 14 3 2 17) */
	"\x2B\x0E\x03\x02\x12",     /*ISO-algorithm-sha (1 3 14 3 2 18) */
	"\x2B\x0E\x03\x02\x13",     /*ISO-algorithm-mdc-2 (1 3 14 3 2 19) */
	"\x2B\x0E\x03\x02\x14",     /*ISO-algorithm-dsaCommon (1 3 14 3 2 20) */
	"\x2B\x0E\x03\x02\x15",     /*ISO-algorithm-dsaCommonWithSHA (1 3 14 3 2 21) */
	"\x2B\x0E\x03\x02\x16",     /*ISO-algorithm-rsaKeyTransport (1 3 14 3 2 22) */
	"\x2B\x0E\x03\x02\x17",     /*ISO-algorithm-keyed-hash-seal (1 3 14 3 2 23) */
	"\x2B\x0E\x03\x02\x18",     /*ISO-algorithm-md2WithRSASignature (1 3 14 3 2 24) */
	"\x2B\x0E\x03\x02\x19",     /*ISO-algorithm-md5WithRSASignature (1 3 14 3 2 25) */
	"\x2B\x0E\x03\x02\x1A",     /*ISO-algorithm-sha1 (1 3 14 3 2 26) */
	"\x2B\x0E\x03\x02\x1B",     /*ISO-algorithm-ripemd160 (1 3 14 3 2 27) */
	"\x2B\x0E\x03\x02\x1D",     /*ISO-algorithm-sha-1WithRSAEncryption (1 3 14 3 2 29) */
	"\x2B\x0E\x03\x03\x01",     /*ISO-algorithm-simple-strong-auth-mechanism (1 3 14 3 3 1) */
    /* Not sure about these ones:
	/*"\x2B\x0E\x07\x02\x01\x01", ElGamal (1 3 14 7 2 1 1) */
	/*"\x2B\x0E\x07\x02\x03\x01", md2WithRSA (1 3 14 7 2 3 1) */
	/*"\x2B\x0E\x07\x02\x03\x02", md2WithElGamal (1 3 14 7 2 3 2) */
	
    /* X.520 id-at = 2 5 4*/
	"\x55\x04\x00", /*X.520-at-objectClass (2 5 4 0) */
	"\x55\x04\x01", /*X.520-at-aliasObjectName (2 5 4 1) */
	"\x55\x04\x02", /*X.520-at-knowledgeInformation (2 5 4 2) */
	"\x55\x04\x03", /*X.520-at-commonName (2 5 4 3) */
	"\x55\x04\x04", /*X.520-at-surname (2 5 4 4) */
	"\x55\x04\x05", /*X.520-at-serialNumber (2 5 4 5) */
	"\x55\x04\x06", /*X.520-at-countryName (2 5 4 6) */
	"\x55\x04\x07", /*X.520-at-localityName (2 5 4 7) */
	"\x55\x04\x08", /*X.520-at-stateOrProvinceName (2 5 4 8) */
	"\x55\x04\x09", /*X.520-at-streetAddress (2 5 4 9) */
	"\x55\x04\x0A", /*X.520-at-organizationName (2 5 4 10) */
	"\x55\x04\x0B", /*X.520-at-organizationalUnitName (2 5 4 11) */
	"\x55\x04\x0C", /*X.520-at-title (2 5 4 12) */
	"\x55\x04\x0D", /*X.520-at-description (2 5 4 13) */
	"\x55\x04\x0E", /*X.520-at-searchGuide (2 5 4 14) */
	"\x55\x04\x0F", /*X.520-at-businessCategory (2 5 4 15) */
	"\x55\x04\x10", /*X.520-at-postalAddress (2 5 4 16) */
	"\x55\x04\x11", /*X.520-at-postalCode (2 5 4 17) */
	"\x55\x04\x12", /*X.520-at-postOfficeBox (2 5 4 18) */
	"\x55\x04\x13", /*X.520-at-physicalDeliveryOfficeName (2 5 4 19) */
	"\x55\x04\x14", /*X.520-at-telephoneNumber (2 5 4 20) */
	"\x55\x04\x15", /*X.520-at-telexNumber (2 5 4 21) */
	"\x55\x04\x16", /*X.520-at-teletexTerminalIdentifier (2 5 4 22) */
	"\x55\x04\x17", /*X.520-at-facsimileTelephoneNumber (2 5 4 23) */
	"\x55\x04\x18", /*X.520-at-x121AddreX.520-at-ss (2 5 4 24) */
	"\x55\x04\x19", /*X.520-at-internationalISNNumber (2 5 4 25) */
	"\x55\x04\x1A", /*X.520-at-registeredAddress (2 5 4 26) */
	"\x55\x04\x1B", /*X.520-at-destinationIndicator (2 5 4 27) */
	"\x55\x04\x1C", /*X.520-at-preferredDeliveryMehtod (2 5 4 28) */
	"\x55\x04\x1D", /*X.520-at-presentationAddress (2 5 4 29) */
	"\x55\x04\x1E", /*X.520-at-supportedApplicationContext (2 5 4 30) */
	"\x55\x04\x1F", /*X.520-at-member (2 5 4 31) */
	"\x55\x04\x20", /*X.520-at-owner (2 5 4 32) */
	"\x55\x04\x21", /*X.520-at-roleOccupant (2 5 4 33) */
	"\x55\x04\x22", /*X.520-at-seeAlso (2 5 4 34) */
	"\x55\x04\x23", /*X.520-at-userPassword (2 5 4 35) */
	"\x55\x04\x24", /*X.520-at-userCertificate (2 5 4 36) */
	"\x55\x04\x25", /*X.520-at-CAcertificate (2 5 4 37) */
	"\x55\x04\x26", /*X.520-at-authorityRevocationList (2 5 4 38) */
	"\x55\x04\x27", /*X.520-at-certifcateRevocationList (2 5 4 39) */
	"\x55\x04\x28", /*X.520-at-crossCertificatePair (2 5 4 40) */
	"\x55\x04\x34", /*X.520-at-supportedAlgorithms (2 5 4 52) */
	"\x55\x04\x35", /*X.520-at-deltaRevocationList (2 5 4 53) */
	"\x55\x04\x3A", /*X.520-at-crossCertificatePair (2 5 4 58) */
	
    /* X500 algorithms */
	"\x55\x08",         /*X500-Algorithms (2 5 8) */
	"\x55\x08\x01",     /*X500-Alg-Encryption (2 5 8 1) */
	"\x55\x08\x01\x01", /*rsa (2 5 8 1 1) */
	
    /* X.509   id-ce = 2 5 29*/
	"\x55\x1D\x01", /*X.509-ce-authorityKeyIdentifier (2 5 29 1) */
	"\x55\x1D\x02", /*X.509-ce-keyAttributes (2 5 29 2) */
	"\x55\x1D\x03", /*X.509-ce-certificatePolicies (2 5 29 3) */
	"\x55\x1D\x04", /*X.509-ce-keyUsageRestriction (2 5 29 4) */
	"\x55\x1D\x05", /*X.509-ce-policyMapping (2 5 29 5) */
	"\x55\x1D\x06", /*X.509-ce-subtreesConstraint (2 5 29 6) */
	"\x55\x1D\x07", /*X.509-ce-subjectAltName (2 5 29 7) */
	"\x55\x1D\x08", /*X.509-ce-issuerAltName (2 5 29 8) */
	"\x55\x1D\x09", /*X.509-ce-subjectDirectoryAttributes (2 5 29 9) */
	"\x55\x1D\x0A", /*X.509-ce-basicConstraints  x.509 (2 5 29 10) */
	"\x55\x1D\x0B", /*X.509-ce-nameConstraints (2 5 29 11) */
	"\x55\x1D\x0C", /*X.509-ce-policyConstraints (2 5 29 12) */
	"\x55\x1D\x0D", /*X.509-ce-basicConstraints  9.55 (2 5 29 13) */
	"\x55\x1D\x0E", /*X.509-ce-subjectKeyIdentifier (2 5 29 14) */
	"\x55\x1D\x0F", /*X.509-ce-keyUsage (2 5 29 15) */
	"\x55\x1D\x10", /*X.509-ce-privateKeyUsagePeriod (2 5 29 16) */
	"\x55\x1D\x11", /*X.509-ce-subjectAltName (2 5 29 17) */
	"\x55\x1D\x12", /*X.509-ce-issuerAltName (2 5 29 18) */
	"\x55\x1D\x13", /*X.509-ce-basicConstraints (2 5 29 19) */
	"\x55\x1D\x14", /*X.509-ce-cRLNumber (2 5 29 20) */
	"\x55\x1D\x15", /*X.509-ce-reasonCode (2 5 29 21) */
	"\x55\x1D\x17", /*X.509-ce-instructionCode (2 5 29 23) */
	"\x55\x1D\x18", /*X.509-ce-invalidityDate (2 5 29 24) */
	"\x55\x1D\x1B", /*X.509-ce-deltaCRLIndicator (2 5 29 27) */
	"\x55\x1D\x1C", /*X.509-ce-issuingDistributionPoint (2 5 29 28) */
	"\x55\x1D\x1D", /*X.509-ce-certificateIssuer (2 5 29 29) */
	"\x55\x1D\x1E", /*X.509-ce-nameConstraints (2 5 29 30) */
	"\x55\x1D\x1F", /*X.509-ce-cRLDistPoints (2 5 29 31) */
	"\x55\x1D\x20", /*X.509-ce-certificatePolicies (2 5 29 32) */
	"\x55\x1D\x21", /*X.509-ce-policyMappings (2 5 29 33) */
	"\x55\x1D\x23", /*X.509-ce-authorityKeyIdentifier (2 5 29 35) */
	"\x55\x1D\x24", /*X.509-ce-policyConstraints (2 5 29 36) */
	
    /* DMS-SDN-702 */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x01", /*id-sdnsSignatureAlgorithm (2 16 840 1 101 2 1 1 1) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x02", /*id-mosaicSignatureAlgorithm (2 16 840 1 101 2 1 1 2) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x03", /*id-sdnsConfidentialityAlgorithm (2 16 840 1 101 2 1 1 3) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x04", /*id-mosaicConfidentialityAlgorithm (2 16 840 1 101 2 1 1 4) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x05", /*id-sdnsIntegrityAlgorithm (2 16 840 1 101 2 1 1 5) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x06", /*id-mosaicIntegrityAlgorithm (2 16 840 1 101 2 1 1 6) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x07", /*id-sdnsTokenProtectionAlgorithm (2 16 840 1 101 2 1 1 7) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x08", /*id-mosaicTokenProtectionAlgorithm (2 16 840 1 101 2 1 1 8) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x09", /*id-sdnsKeyManagementAlgorithm (2 16 840 1 101 2 1 1 9) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0A", /*id-mosaicKeyManagementAlgorithm (2 16 840 1 101 2 1 1 10) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0B", /*id-sdnsKMandSigAlgorithm (2 16 840 1 101 2 1 1 11) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0C", /*id-mosaicKMandSigAlgorithm (2 16 840 1 101 2 1 1 12) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0D", /*id-SuiteASignatureAlgorithm (2 16 840 1 101 2 1 1 13) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0E", /*id-SuiteAConfidentialityAlgorithm (2 16 840 1 101 2 1 1 14) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x0F", /*id-SuiteAIntegrityAlgorithm (2 16 840 1 101 2 1 1 15) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x10", /*id-SuiteATokenProtectionAlgorithm (2 16 840 1 101 2 1 1 16) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x11", /*id-SuiteAKeyManagementAlgorithm (2 16 840 1 101 2 1 1 17) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x12", /*id-SuiteAKMandSigAlgorithm (2 16 840 1 101 2 1 1 18) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x13", /*id-mosaicUpdatedSigAlgorithm (2 16 840 1 101 2 1 1 19) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x14", /*id-mosaicKMandUpdSigAlgorithms (2 16 840 1 101 2 1 1 20) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x15", /*id-mosaicUpdatedIntegAlgorithm (2 16 840 1 101 2 1 1 21) */
	"\x60\x86\x48\x01\x65\x02\x01\x01\x16", /*id-mosaicKeyEncryptionAlgorithm (2 16 840 1 101 2 1 1 22) */

	/* Netscape */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x01", /*netscape-cert-type (2 16 840 1 113730 1 1) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x02", /*netscape-base-url (2 16 840 1 113730 1 2) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x03", /*netscape-revocation-url (2 16 840 1 113730 1 3) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x04", /*netscape-ca-revocation-url (2 16 840 1 113730 1 4) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x05", /*netscape-cert-sequence (2 16 840 1 113730 2 5) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x06", /*netscape-cert-url (2 16 840 1 113730 2 6) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x07", /*netscape-renewal-url (2 16 840 1 113730 1 7) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x08", /*netscape-ca-policy-url (2 16 840 1 113730 1 8) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x09", /*netscape-HomePage-url (2 16 840 1 113730 1 9) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x0A", /*netscape-EntityLogo (2 16 840 1 113730 1 10) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x0B", /*netscape-UserPicture (2 16 840 1 113730 1 11) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x0C", /*netscape-ssl-server-name (2 16 840 1 113730 1 12) */
	"\x60\x86\x48\x01\x86\xF8\x42\x01\x0D", /*netscape-comment (2 16 840 1 113730 1 13) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02",     /*netscape-data-type (2 16 840 1 113730 2) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x01", /*netscape-dt-GIF (2 16 840 1 113730 2 1) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x02", /*netscape-dt-JPEG (2 16 840 1 113730 2 2) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x03", /*netscape-dt-URL (2 16 840 1 113730 2 3) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x04", /*netscape-dt-HTML (2 16 840 1 113730 2 4) */
	"\x60\x86\x48\x01\x86\xF8\x42\x02\x05", /*netscape-dt-CertSeq (2 16 840 1 113730 2 5) */
	"\x60\x86\x48\x01\x86\xF8\x42\x03",     /*netscape-directory (2 16 840 1 113730 3) */
	
    /* SET */
	"\x86\x8D\x6F\x02", /*hashedRootKey (2 54 1775 2) */
	"\x86\x8D\x6F\x03", /*certificateType (2 54 1775 3) */
	"\x86\x8D\x6F\x04", /*merchantData (2 54 1775 4) */
	"\x86\x8D\x6F\x05", /*cardCertRequired (2 54 1775 5) */
	"\x86\x8D\x6F\x06", /*tunneling (2 54 1775 6) */
	"\x86\x8D\x6F\x07", /*setQualifier (2 54 1775 7) */
	"\x86\x8D\x6F\x63", /*set-data (2 54 1775 99) */
	
   NULL	
   };
/*------------------------------------------------------------------------------
                              Global Variables
------------------------------------------------------------------------------*/

BYTE
   *pDictMemory = NULL_PTR,
   DictVersion = 0;

BYTE*
   dwPtrMax = 0;

USHORT
   usDictCount = 0;

#ifdef _STUDY
FILE
   *pfdLog,
   *pfdLogFreq,
	*pfdBinAc256,
	*pfdBinAc16,
	*pfdBinAc4,
	*pfdBinAc2;
int
	sum, i,
   Ac256[256],
   Ac16[16],
   Ac4[4],
   Ac2[2];
#endif

/*------------------------------------------------------------------------------
                       Static Functions Declaration 
------------------------------------------------------------------------------*/

static int CC_Comp(BLOC *pCertificate,
                   BLOC *pCompressedCertificate
                  );

static int CC_Uncomp(BLOC *pCompressedCertificate,
                     BLOC *pUncompressedCertificate
                    );

static int CC_ExtractContent(ASN1 *pAsn1
                            );

static int CC_BuildAsn1(ASN1 *pAsn1
                       );

static int SearchDataByIndex(USHORT usIndex,
                             BYTE   *pDict,
                             BLOC   *pOutBloc
                            );

static int CC_RawEncode(BLOC *pInBloc,
                        BLOC *pOutBloc,
								BOOL bUseDictionnary
                       );

static int CC_RawDecode(BYTE     *pInData,
                        BLOC     *pOutBloc,
                        USHORT   *pLength,
								BOOL		bUseDictionnary
                       );

static int CC_GenericCompress(BLOC *pUncompBloc,
                              BLOC *pCompBloc,
                              BYTE AlgoID
                             );

static int CC_GenericUncompress(BLOC *pCompBloc,
                                BLOC *pUncompBloc,
                                BYTE AlgoID
                               );

static int CC_Encode_TBSCertificate(BLOC *pInBloc,
                                    BLOC *pOutBloc
                                   );

static int CC_Encode_CertificateSerialNumber(BLOC *pInBloc,
                                             BLOC *pOutBloc
                                            );

static int CC_Encode_AlgorithmIdentifier(BLOC *pInBloc,
                                         BLOC *pOutBloc
                                        );

static int CC_Encode_Name(BLOC *pInBloc,
                          BLOC *pOutBloc
                         );

static int CC_Encode_RDN(BLOC *pInBloc,
                         BLOC *pOutBloc
                        );

static int CC_Encode_AVA(BLOC *pInBloc,
                         BLOC *pOutBloc
                        );

static int CC_Encode_Validity(BLOC *pInBloc,
                              BLOC *pOutBloc
                             );

static int CC_Encode_UTCTime(BLOC *pInBloc,
                             BLOC *pOutBloc,
                             BYTE *pFormat
                            );

static int CC_Encode_SubjectPKInfo(BLOC *pInBloc,
                                   BLOC *pOutBloc
                                  );

static int CC_Encode_UniqueIdentifier(BLOC *pInBloc,
                                      BLOC *pOutBloc
                                     );

static int CC_Encode_Extensions(BLOC *pInBloc,
                                BLOC *pOutBloc
                               );

static int CC_Encode_Extension(BLOC *pInBloc,
                               BLOC *pOutBloc
                              );

static int CC_Encode_Signature(BLOC *pInBloc,
                               BLOC *pOutBloc
                              );

static int CC_Decode_TBSCertificate(BYTE    *pInData,
                                    BLOC    *pOutBloc,
                                    USHORT  *pLength
                                   );

static int CC_Decode_CertificateSerialNumber(BYTE    *pInData,
                                             BLOC    *pOutBloc,
                                             USHORT  *pLength
                                            );

static int CC_Decode_AlgorithmIdentifier(BYTE    *pInData,
                                         BLOC    *pOutBloc,
                                         USHORT  *pLength
                                        );

static int CC_Decode_Name(BYTE    *pInData,
                          BLOC    *pOutBloc,
                          USHORT  *pLength
                         );

static int CC_Decode_RDN(BYTE    *pInData,
                         BLOC    *pOutBloc,
                         USHORT  *pLength
                        );

static int CC_Decode_AVA(BYTE    *pInData,
                         BLOC    *pOutBloc,
                         USHORT  *pLength
                        );

static int CC_Decode_Validity(BYTE    *pInData,
                              BLOC    *pOutBloc,
                              USHORT  *pLength
                             );

static int CC_Decode_UTCTime(BYTE   *pInData,
                             BYTE   Format,
                             BLOC   *pOutBloc,
                             USHORT *pLength
                            );

static int CC_Decode_SubjectPKInfo(BYTE    *pInData,
                                   BLOC    *pOutBloc,
                                   USHORT  *pLength
                                  );

static int CC_Decode_UniqueIdentifier(BYTE    *pInData,
                                      BLOC    *pOutBloc,
                                      USHORT  *pLength
                                     );

static int CC_Decode_Extensions(BYTE    *pInData,
                                BLOC    *pOutBloc,
                                USHORT  *pLength
                               );

static int CC_Decode_Extension(BYTE    *pInData,
                               BLOC    *pOutBloc,
                               USHORT  *pLength
                              );

static int CC_Decode_Signature(BYTE    *pInData,
                               BLOC    *pOutBloc,
                               USHORT  *pLength
                              );

/*------------------------------------------------------------------------------
* static DWORD get_file_len(BYTE *lpszFileName)
* 
* Description : Get length of file.
*
* Remarks     : Nothing.
*
* In          : lpszFileName = Name of file.
*
* Out         : Nothing.
*
* Responses   : size of file, -1 if error occur.
*
------------------------------------------------------------------------------*/                                    
static DWORD get_file_len(BYTE *lpszFileName)
{                                             
   int    fp;
   DWORD  nLen;

   fp = _open(lpszFileName, O_RDONLY);
   if (fp != 0)
   {
	   nLen = _filelength(fp);
	   _close(fp);
   }
   else
   {
	   nLen = -1;
   }

   return(nLen);
} 



/*******************************************************************************
* int CC_Init(BYTE  bDictMode, BYTE *pszDictName)
*
* Description : Lit le dictionnaire et son numro de version depuis la base de
*               registre vers la mmoire.
*
* Remarks     :
*
* In          : 
*
* Out         : 
*
* Responses   : 
*
*******************************************************************************/
int CC_Init(BYTE  bDictMode, BYTE *pszDictName)
{
   switch (bDictMode)
   {
#ifndef _STATIC
      /* Dictionary read as resource data GPK_X509_DICTIONARY                 */
      case DICT_STANDARD:
      {
         LPBYTE pbDict;
         DWORD cbDict;
         HRSRC hRsrc;
         HGLOBAL hDict;

         hRsrc = FindResource(g_hInstRes, 
                              //MAKEINTRESOURCE(GPK_X509_DICTIONARY), 
                              TEXT("GPK_X509_DICTIONARY"),
                              RT_RCDATA
                             );
         if (NULL == hRsrc)
         {
           goto ERROR_INIT;
         }
         cbDict = SizeofResource(g_hInstRes, hRsrc);
         if (0 == cbDict)
         {
           goto ERROR_INIT;
         }
         hDict = LoadResource(g_hInstRes, hRsrc);
         if (NULL == hDict)
         {
           goto ERROR_INIT;
         }
         pbDict = LockResource(hDict);
         if (NULL == pbDict)
         {
           goto ERROR_INIT;
         }

         DictVersion = *pbDict;
         usDictCount = (WORD)cbDict - 1;
         pDictMemory = GMEM_Alloc(usDictCount);
		 if (pDictMemory == NULL)
		 {
           goto ERROR_INIT;
         }
         memcpy(pDictMemory, &pbDict[1], usDictCount);
    
         return(RV_SUCCESS);
      }  
      break;
#endif
      
      /* Dictionary read as registyry entry in HKEY_LOCAL_MACHINE with key as */
      /* pszDictName parameter                                                */
      case DICT_REGISTRY:
      {
         DWORD  
            err,
            dwIgn;
         HKEY   
            hRegKey;
         BYTE
            *ptr;

         if (pszDictName == NULL_PTR)
         {
            goto ERROR_INIT;
         }

         err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              (const char *) pszDictName,
                              0L, 
                              "", 
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS, 
                              NULL, 
                              &hRegKey,
                              &dwIgn
                             );
         if(err != ERROR_SUCCESS)
         {
            goto ERROR_INIT;
         }
 
         dwIgn = 0;
         err = RegQueryValueEx(hRegKey,  
                               "X509 Dictionary", 
                               NULL,    
                               NULL,   
                               NULL,   
                               &dwIgn   
                              );
         if(err != ERROR_SUCCESS)
         {
			 RegCloseKey(hRegKey);
			 goto ERROR_INIT;
         }

         ptr = GMEM_Alloc(dwIgn);
		 if (ptr == NULL)
		 {
           RegCloseKey(hRegKey);
		   goto ERROR_INIT;
         }

         err = RegQueryValueEx(hRegKey,  
                               "X509 Dictionary", 
                               NULL,    
                               NULL,   
                               ptr,   
                               &dwIgn   
                              );
         if(err != ERROR_SUCCESS)
         {
            RegCloseKey(hRegKey);
			GMEM_Free(ptr);
            goto ERROR_INIT;
         }

	      DictVersion = (BYTE)ptr[0];

         usDictCount = (WORD)dwIgn - 1;
         pDictMemory = GMEM_Alloc(usDictCount);

		 if (pDictMemory == NULL)
		 {
			RegCloseKey(hRegKey);
			GMEM_Free(ptr);
            goto ERROR_INIT;
		 }

         memcpy(pDictMemory, &ptr[1], usDictCount);

         RegCloseKey(hRegKey);
		 GMEM_Free(ptr);
         return(RV_SUCCESS);
      }
      break;

      /* Dictionary read as file in path pszDictName parameter                */
      case DICT_FILE:
      {
         DWORD  
            dwFileLen;
         BYTE
            *ptr;
         FILE
            *fp;

         if (pszDictName == NULL_PTR)
         {
            goto ERROR_INIT;
         }
         dwFileLen = get_file_len(pszDictName);
         ptr = GMEM_Alloc(dwFileLen);
		 if (ptr == NULL)
		 {
			 goto ERROR_INIT;
         }
            
         fp = fopen(pszDictName, "rb");
         if (fp == NULL)
         {
            GMEM_Free(ptr);
			goto ERROR_INIT;
         }

         if (!fread(ptr, dwFileLen, 1, fp))
         {
            fclose(fp);
			GMEM_Free(ptr);
            goto ERROR_INIT;
         }
         fclose(fp);
            
	     DictVersion = (BYTE)ptr[0];

         usDictCount = (WORD)dwFileLen - 1;
         pDictMemory = GMEM_Alloc(usDictCount);

		 if (pDictMemory == NULL)
		 {
			 GMEM_Free(ptr);
			 goto ERROR_INIT;
		 }

         memcpy(pDictMemory, &ptr[1], usDictCount);

         GMEM_Free(ptr);

         return(RV_SUCCESS);
      }
      break;

      default:
         break;
   }

ERROR_INIT:
   DictVersion = 0;
   usDictCount = 0;
   pDictMemory = NULL_PTR;
   return(RV_BAD_DICTIONARY);
}


/*******************************************************************************
* int CC_Exit(void)
*
* Description : Free dictionary.
*
* Remarks     :
*
* In          : 
*
* Out         : 
*
* Responses   : 
*
*******************************************************************************/
int CC_Exit(void)
{
   DictVersion = 0;
   usDictCount = 0;
   if (pDictMemory != NULL_PTR)
   {
      GMEM_Free(pDictMemory);
   }
   pDictMemory = NULL_PTR;
   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Compress(BLOC *pCertificate,
*                 BLOC *pCompressedCertificate
*                )
*
* Description : Fonction de mta-compression visible depuis l'extrieur.
*					 Adapte la sortie en fonction de la faisabilit d'une compression
*               suivie d'une dcompression.
*
* Remarks     : Le champ pData du bloc d'entre a t allou par la fonction appelant.
*               Le champ pData du bloc de sortie est allou ici. Il doit tre
*               dsallou par la fonction appelant (sauf si RV_MALLOC_FAILED).
*
* In          : *pCert : Bloc  mta-compresser
*
* Out         : *pCompCert : Bloc 'meta-compress'
*               Si problme lors de la compression/decompression : Renvoie le bloc
*               d'entre prcd d'un tag spcifique.
*               Sinon : Renvoie le bloc compress prcd du numro de version
*               du dictionnaire.
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_COMPRESSION_FAILED : Un problme a eu lieu lors de l'tape
*                                       de compression/dcompression donc le
*                                       bloc de sortie contient le bloc d'entre
*                                       prcd du tag TAG_COMPRESSION_FAILED.
*               RV_BLOC_TOO_LONG : Le bloc d'entre *commence* par un certificat
*                                  dont la compression a pu tre inverse.
*                                  Le bloc de sortie contient donc le compress
*                                  de cette partie initiale seulement.
*               RV_MALLOC_FAILED : Un malloc a chou au niveau 'mta'. C'est le
*                                  seul rel retour d'erreur.
*
*******************************************************************************/
int CC_Compress(BLOC *pCert,
                BLOC *pCompCert
               )

{
   BLOC
      TryCompCert,
      TryUncompCert;

	TryCompCert.pData = NULL_PTR;
	TryCompCert.usLen = 0;
	TryUncompCert.pData = NULL_PTR;
	TryUncompCert.usLen = 0;

#ifdef _STUDY

   /* Ouverture des fichiers de log                                           */

   if ((pfdLog = fopen("CompCert.log", "a+")) == 0)
   {
      return(RV_FILE_OPEN_FAILED);
   }
	fprintf(pfdLog, "\n*****************************************************\n");

   if ((pfdBinAc256 = fopen("Freq256.bin", "r+b")) == 0)
	{
		if ((pfdBinAc256 = fopen("Freq256.bin", "w+b")) == 0)
		{
			return(RV_FILE_OPEN_FAILED);
		}
		memset(Ac256, 0x00, 256 * sizeof(int));
   }
	else
	{
		fread(Ac256, sizeof(int), 256, pfdBinAc256);
	}

   if ((pfdBinAc16 = fopen("Freq016.bin", "r+b")) == 0)
	{
		if ((pfdBinAc16 = fopen("Freq016.bin", "w+b")) == 0)
		{
			return(RV_FILE_OPEN_FAILED);
		}
		memset(Ac16, 0x00, 16 * sizeof(int));
   }
	else
	{
		fread(Ac16, sizeof(int), 16, pfdBinAc16);
	}

   if ((pfdBinAc4 = fopen("Freq004.bin", "r+b")) == 0)
	{
		if ((pfdBinAc4 = fopen("Freq004.bin", "w+b")) == 0)
		{
			return(RV_FILE_OPEN_FAILED);
		}
		memset(Ac4, 0x00, 4 * sizeof(int));
   }
	else
	{
		fread(Ac4, sizeof(int), 4, pfdBinAc4);
	}

   if ((pfdBinAc2 = fopen("Freq002.bin", "r+b")) == 0)
	{
		if ((pfdBinAc2 = fopen("Freq002.bin", "w+b")) == 0)
		{
			return(RV_FILE_OPEN_FAILED);
		}
		memset(Ac2, 0x00, 2 * sizeof(int));
   }
	else
	{
		fread(Ac2, sizeof(int), 2, pfdBinAc2);
	}

#endif

	if (CC_Comp(pCert, &TryCompCert) != RV_SUCCESS)
	{
		/* Si la compression s'est mal passe alors on renvoie le fichier
		   d'entre en indiquant que le fichier n'est pas compress             */

		if (TryCompCert.pData) 
      {
         GMEM_Free(TryCompCert.pData);
         TryCompCert.pData = NULL_PTR;
      }

      /* Allocation de la mmoire pour le certificat compress                */
      if (pCompCert->usLen < pCert->usLen + 1)
      {
         pCompCert->usLen = pCert->usLen + 1;
         if (pCompCert->pData)
         {
            return(RV_BUFFER_TOO_SMALL);
         }
         else
         {
            return(RV_SUCCESS);
         }
      }

      pCompCert->usLen = pCert->usLen + 1;
		pCompCert->pData[0] = TAG_COMPRESSION_FAILED;
      if (pCompCert->pData)
      {
   		memcpy(&pCompCert->pData[1], pCert->pData, pCert->usLen);
      }
		return(RV_COMPRESSION_FAILED);
	}


	if (   (  (CC_Uncomp(&TryCompCert, &TryUncompCert) != RV_SUCCESS)
		    || (pCert->usLen != TryUncompCert.usLen)
		    || (memcmp(TryUncompCert.pData, pCert->pData, pCert->usLen) != 0)
			 )
		 && (memcmp(TryUncompCert.pData, pCert->pData, TryUncompCert.usLen) != 0)
		)
	{
		/* Si la dcompression s'est mal passe ou bien si elle n'est pas fidle
		   alors on renvoie le fichier d'entre en indiquant que le fichier
		   n'est pas compress                                                  */

		if (TryCompCert.pData)
      {
         GMEM_Free(TryCompCert.pData);
         TryCompCert.pData = NULL_PTR;
      }
		if (TryUncompCert.pData) 
      {
         GMEM_Free(TryUncompCert.pData);
         TryUncompCert.pData = NULL_PTR;
      }

      /* Allocation de la mmoire pour le certificat                          */
      if (pCompCert->usLen < pCert->usLen + 1)
      {
         pCompCert->usLen = pCert->usLen + 1;
         if (pCompCert->pData)
         {
            return(RV_BUFFER_TOO_SMALL);
         }
         else
         {
            return(RV_SUCCESS);
         }
      }

      pCompCert->usLen = pCert->usLen + 1;
		pCompCert->pData[0] = TAG_COMPRESSION_FAILED;
      if (pCompCert->pData)
      {
   		memcpy(&pCompCert->pData[1], pCert->pData, pCert->usLen);
      }
		return(RV_COMPRESSION_FAILED);
	}

#ifdef _STUDY

	fseek(pfdBinAc256, 0, SEEK_SET);
	fwrite(Ac256, sizeof(int), 256, pfdBinAc256);
	fseek(pfdBinAc16, 0, SEEK_SET);
	fwrite(Ac16, sizeof(int), 16, pfdBinAc16);
	fseek(pfdBinAc4, 0, SEEK_SET);
	fwrite(Ac4, sizeof(int), 4, pfdBinAc4);
	fseek(pfdBinAc2, 0, SEEK_SET);
	fwrite(Ac2, sizeof(int), 2, pfdBinAc2);

   if ((pfdLogFreq = fopen("Freq.log", "w")) == 0)
   {
      return(RV_FILE_OPEN_FAILED);
   }

	for (sum = 0, i = 0; i < 256; sum += Ac256[i], i++) ;

	fprintf(pfdLogFreq, "\nTotal = %d\n\n", sum * 8);
	for (i = 0; i < 2; i++)
	{
		fprintf(pfdLogFreq, "0x%02X (%03d) '%c' : %8d - %04.2f %%\n",
									i, i, (isgraph(i) ? i : ' '),
									Ac2[i], ((float) 100 * Ac2[i] / (sum * 8)));
	}

	fprintf(pfdLogFreq, "\nTotal = %d\n\n", sum * 4);
	for (i = 0; i < 4; i++)
	{
		fprintf(pfdLogFreq, "0x%02X (%03d) '%c' : %8d - %04.2f %%\n",
									i, i, (isgraph(i) ? i : ' '),
									Ac4[i], ((float) 100 * Ac4[i] / (sum * 4)));
	}

	fprintf(pfdLogFreq, "\nTotal = %d\n\n", sum * 2);
	for (i = 0; i < 16; i++)
	{
		fprintf(pfdLogFreq, "0x%02X (%03d) '%c' : %8d - %04.2f %%\n",
									i, i, (isgraph(i) ? i : ' '),
									Ac16[i], ((float) 100 * Ac16[i] / (sum * 2)));
	}

	fprintf(pfdLogFreq, "\nTotal = %d\n\n", sum);
	for (i = 0; i < 256; i++)
	{
		fprintf(pfdLogFreq, "0x%02X (%03d) '%c' : %8d - %04.2f %%\n",
									i, i, (isgraph(i) ? i : ' '),
									Ac256[i], ((float) 100 * Ac256[i] / sum));
	}

	fclose(pfdBinAc256);
	fclose(pfdBinAc16);
	fclose(pfdBinAc4);
	fclose(pfdBinAc2);

	fclose(pfdLogFreq);
	fclose(pfdLog);

#endif

	/* Si tout s'est bien pass, on renvoie le rsultat en indiquant
	   qu'il est compress (DictVersion != 0xFF)                               */
	
	/* Allocation de la mmoire pour le certificat                             */
   if (pCompCert->usLen < TryCompCert.usLen + 1)
   {
	   if (TryCompCert.pData)
      {
         GMEM_Free(TryCompCert.pData);
         TryCompCert.pData = NULL_PTR;
      }
	   if (TryUncompCert.pData) 
      {
         GMEM_Free(TryUncompCert.pData);
         TryUncompCert.pData = NULL_PTR;
      }

      pCompCert->usLen = TryCompCert.usLen + 1;
      if (pCompCert->pData)
      {
         return(RV_BUFFER_TOO_SMALL);
      }
      else
      {
         return(RV_SUCCESS);
      }
   }

   pCompCert->usLen = TryCompCert.usLen + 1;
   if (pCompCert->pData)
   {
   	pCompCert->pData[0] = DictVersion;
   	memcpy(&pCompCert->pData[1], TryCompCert.pData, TryCompCert.usLen);
   }
	if (TryCompCert.pData)
   {
      GMEM_Free(TryCompCert.pData);
      TryCompCert.pData = NULL_PTR;
   }
	if (TryUncompCert.pData) 
   {
      GMEM_Free(TryUncompCert.pData);
      TryUncompCert.pData = NULL_PTR;
   }

	if (pCert->usLen != TryUncompCert.usLen)
	{
		return(RV_BLOC_TOO_LONG);
	}
   
   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Uncompress(BLOC *pCompCert,
*                   BLOC *pUncompCert
*                  )
*
* Description : Fonction de mta-dcompression visible depuis l'extrieur.
*					 Retourne le bloc original (entre de la fonction CC_Compress)
*               sous rserve toutefois d'une version adquate du dictionnaire.
*
* Remarks     : Le champ pData du bloc d'entre a t allou par la fonction appelant.
*               Le champ pData du bloc de sortie est allou ici. Il doit tre
*               dsallou par la fonction appelant (sauf si erreur).
*               Le comportement est imprvisible dans le cas o le bloc d'entre
*               n'est pas le bloc de sortie d'un appel  la fonction CC_Compress.
*
* In          : *pCompCert : Bloc  mta-dcompresser
*
* Out         : *pUncompCert : Bloc 'mta-dcompress'
*                              (ou vide si RV_BAD_DICTIONARY) 
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_BAD_DICTIONARY : La version du dictionnaire utilise pour la
*                                    dcompression est plus ancienne que celle
*                                    utilise pour la compression.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns lors de
*                       la dcompression.
*
*******************************************************************************/
int CC_Uncompress(BLOC *pCompCert,
                  BLOC *pUncompCert
                 )

{
   int
      resp;

	BLOC
		TempCompCert,
      TempUncompCert;

	if (pCompCert->pData[0] == TAG_COMPRESSION_FAILED)
	{
		/* Allocation de la mmoire pour le certificat
			On  pourrait se contenter de ne retourner que la zone mmoire
			 partir de l'octet 1 mais la fonction de dcompression est sense
			toujours allouer la zone dans laquelle elle renvoie le dcompress */

		if(pUncompCert->usLen < pCompCert->usLen - 1)
      {
   		pUncompCert->usLen = pCompCert->usLen - 1;
         if (pUncompCert->pData)
         {
            return(RV_BUFFER_TOO_SMALL);
         }
         else
         {
            return(RV_SUCCESS);
         }
      }

		pUncompCert->usLen = pCompCert->usLen - 1;
      if (pUncompCert->pData)
      {
		   memcpy(pUncompCert->pData, &pCompCert->pData[1], pUncompCert->usLen);
      }
		return (RV_SUCCESS);
	}
	else if (pCompCert->pData[0] <= DictVersion)
	{
	  TempCompCert.pData = &pCompCert->pData[1];
	  TempCompCert.usLen = pCompCert->usLen - 1;

      TempUncompCert.usLen = 0;		
      resp = CC_Uncomp(&TempCompCert, &TempUncompCert);
      
	  if (resp == RV_SUCCESS)
	  {
		 if(pUncompCert->usLen < TempUncompCert.usLen)
		 {
            GMEM_Free(TempUncompCert.pData);

   		    pUncompCert->usLen = TempUncompCert.usLen;
            if (pUncompCert->pData)
			{
               return(RV_BUFFER_TOO_SMALL);
			}
            else
			{
               return(RV_SUCCESS);
			}
		 }

 		 pUncompCert->usLen = TempUncompCert.usLen;
		 if (pUncompCert->pData)
		 {
		    memcpy(pUncompCert->pData, TempUncompCert.pData, TempUncompCert.usLen);
		 }
         GMEM_Free(TempUncompCert.pData);
	  }
	  return (resp);
	}
	else
	{
		return (RV_BAD_DICTIONARY);
	}
}


/*******************************************************************************
* int CC_Comp(BLOC *pCertificate,
*             BLOC *pCompressedCertificate
*            )
*
* Description : Fonction interne de compression d'un certificat.
*
* Remarks     : Le champ pData du bloc d'entre a t allou par la fonction appelant.
*               Le champ pData du bloc de sortie est allou ici. Il doit tre
*               dsallou par la fonction appelant (sauf si erreur).
*
* In          : *pCertificate : Bloc  compresser
*
* Out         : *pCompressedCertificate : Bloc compress
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Comp(BLOC *pCertificate,
            BLOC *pCompressedCertificate
           )

{
   ASN1
      Cert,
      tbsCert,
      signatureAlgo,
      signature;
   BLOC
		TmpCompCert,
      tbsCertEncoded,
      signatureAlgoEncoded,
      signatureEncoded;
   BYTE
      *pCurrent;
   int
      rv;


   /* Eclatement du certificat en ses trois composants principaux             */
   dwPtrMax = pCertificate->pData + pCertificate->usLen;
   
   Cert.Asn1.pData = pCertificate->pData;
   rv = CC_ExtractContent(&Cert);
   if (rv != RV_SUCCESS) return rv;
   if (Cert.Asn1.usLen != pCertificate->usLen)
   {
      return(RV_INVALID_DATA);
   }

   tbsCert.Asn1.pData = Cert.Content.pData;
   rv = CC_ExtractContent(&tbsCert);
   if (rv != RV_SUCCESS) return rv;

   signatureAlgo.Asn1.pData = tbsCert.Content.pData + tbsCert.Content.usLen;
   rv = CC_ExtractContent(&signatureAlgo);
   if (rv != RV_SUCCESS) return rv;

   signature.Asn1.pData = signatureAlgo.Content.pData + signatureAlgo.Content.usLen;
   rv = CC_ExtractContent(&signature);
   if (rv != RV_SUCCESS) return rv;

   ASSERT(signature.Content.pData + signature.Content.usLen ==
          Cert.Content.pData + Cert.Content.usLen);


   /* Elaboration des composants principaux compresss                        */

	/* Les pData des blocs *Encoded sont allous par les fonctions CC_Encode_*.
	   Ils sont librs dans cette fonction aprs usage                        */

   tbsCertEncoded.pData       = NULL;
   signatureAlgoEncoded.pData = NULL;
   signatureEncoded.pData     = NULL;

   rv = CC_Encode_TBSCertificate(&tbsCert.Content, &tbsCertEncoded);
   if (rv != RV_SUCCESS) goto err;

   rv = CC_Encode_AlgorithmIdentifier(&signatureAlgo.Content, &signatureAlgoEncoded);
   if (rv != RV_SUCCESS) goto err;

   rv = CC_Encode_Signature(&signature.Content, &signatureEncoded);
   if (rv != RV_SUCCESS) goto err;


   /* Reconstruction du certificat compress  partir de ses composants       */

   TmpCompCert.usLen = tbsCertEncoded.usLen
                     + signatureAlgoEncoded.usLen
                     + signatureEncoded.usLen;

   /* A dsallouer par le programme appelant                                  */
   if ((TmpCompCert.pData = GMEM_Alloc(TmpCompCert.usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = TmpCompCert.pData;

   memcpy(pCurrent, tbsCertEncoded.pData, tbsCertEncoded.usLen);
   GMEM_Free(tbsCertEncoded.pData);
   pCurrent += tbsCertEncoded.usLen;

   memcpy(pCurrent, signatureAlgoEncoded.pData, signatureAlgoEncoded.usLen);
   GMEM_Free(signatureAlgoEncoded.pData);
   pCurrent += signatureAlgoEncoded.usLen;

   memcpy(pCurrent, signatureEncoded.pData, signatureEncoded.usLen);
   GMEM_Free(signatureEncoded.pData);
   pCurrent += signatureEncoded.usLen;


	/* Et maintenant on compresse le certificat compress !!                   */

#ifdef _GLOBAL_COMPRESSION
   rv = CC_RawEncode(&TmpCompCert, pCompressedCertificate, FALSE);
   GMEM_Free(TmpCompCert.pData);
   if (rv != RV_SUCCESS) goto err;
#else
	*pCompressedCertificate = TmpCompCert;
#endif

   return(RV_SUCCESS);

err:
   GMEM_Free(tbsCertEncoded.pData);
   GMEM_Free(signatureAlgoEncoded.pData);
   GMEM_Free(signatureEncoded.pData);

   return (rv);


}


/*******************************************************************************
* int CC_Uncomp(BLOC *pCompressedCertificate,
*               BLOC *pUncompressedCertificate
*              )
*
* Description : Fonction interne de dcompression d'un certificat.
*
* Remarks     : Le champ pData du bloc d'entre a t allou par la fonction appelant.
*               Le champ pData du bloc de sortie est allou ici. Il doit tre
*               dsallou par la fonction appelant (sauf si erreur).
*
* In          : *pCertificate : Bloc  compresser
*
* Out         : *pCompressedCertificate : Bloc compress
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Uncomp(BLOC *pCompressedCertificate,
              BLOC *pUncompressedCertificate
             )

{
   ASN1
      Cert,
      tbsCert,
      signatureAlgo,
      signature;
   BLOC
      TmpCompCert;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      Length;

   tbsCert.Asn1.pData       = NULL;
   signatureAlgo.Asn1.pData = NULL;
   signature.Asn1.pData     = NULL;


#ifdef _GLOBAL_COMPRESSION
	/* Length est ici inutile                                                  */
   rv = CC_RawDecode(pCompressedCertificate->pData, &TmpCompCert, &Length, FALSE);
   if (rv != RV_SUCCESS) return rv;
#else
	TmpCompCert = *pCompressedCertificate;
#endif

   /* Dcodage des diffrents composants du certificat                        */
   
	/* CC_Decode_* et cc_BuildAsn1 allouent les pData de leurs arguments de
		sortie. Ces zones sont  dsallouer  ce niveau aprs usage.            */

   pCurrent = TmpCompCert.pData;

   rv = CC_Decode_TBSCertificate(pCurrent, &tbsCert.Content, &Length);
   if (rv != RV_SUCCESS) goto err;
   tbsCert.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&tbsCert);
   GMEM_Free(tbsCert.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;
   
   rv = CC_Decode_AlgorithmIdentifier(pCurrent, &signatureAlgo.Content, &Length);
   if (rv != RV_SUCCESS) goto err;
   signatureAlgo.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&signatureAlgo);
   GMEM_Free(signatureAlgo.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;
   
   rv = CC_Decode_Signature(pCurrent, &signature.Content, &Length);
   if (rv != RV_SUCCESS) goto err;
   signature.Tag = TAG_BIT_STRING;
   rv = CC_BuildAsn1(&signature);
   GMEM_Free(signature.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

	ASSERT(pCurrent == TmpCompCert.pData + TmpCompCert.usLen);

#ifdef _GLOBAL_COMPRESSION
	GMEM_Free(TmpCompCert.pData);
#endif

   /* Reconstruction de l'enveloppe Asn1 du certificat                        */

	/* A dsallouer  ce niveau aprs usage                                    */
   Cert.Content.usLen = tbsCert.Asn1.usLen
                      + signatureAlgo.Asn1.usLen
                      + signature.Asn1.usLen;

   if ((Cert.Content.pData = GMEM_Alloc(Cert.Content.usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = Cert.Content.pData;

   memcpy(pCurrent, tbsCert.Asn1.pData, tbsCert.Asn1.usLen);
   GMEM_Free(tbsCert.Asn1.pData);
   pCurrent += tbsCert.Asn1.usLen;

   memcpy(pCurrent, signatureAlgo.Asn1.pData, signatureAlgo.Asn1.usLen);
   GMEM_Free(signatureAlgo.Asn1.pData);
   pCurrent += signatureAlgo.Asn1.usLen;

   memcpy(pCurrent, signature.Asn1.pData, signature.Asn1.usLen);
   GMEM_Free(signature.Asn1.pData);
   pCurrent += signature.Asn1.usLen;

   Cert.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&Cert);
   GMEM_Free(Cert.Content.pData);
   if (rv != RV_SUCCESS) return rv;

   *pUncompressedCertificate = Cert.Asn1;

   return(RV_SUCCESS);

err:
   GMEM_Free(tbsCert.Asn1.pData);
   GMEM_Free(signatureAlgo.Asn1.pData);
   GMEM_Free(signature.Asn1.pData);

   return(rv);
}


/*******************************************************************************
* int CC_ExtractContent(ASN1 *pAsn1)
*
* Description : Extrait d'un bloc Asn1 (pAsn1->Asn1) son contenu en laguant son
*               enrobage (identifier bytes, length bytes) et le place dans le
*               bloc pAsn1->Content.
*
* Remarks     : Le champ Asn1.pData a t allou par la fonction appelant.
*
* In          : pAsn1->Asn1.pData
*
* Out         : Les champs suivants sont renseigns (si RV_SUCCESS) :
*                - Tag
*                - Asn1.usLen
*                - Content.usLen
*                - Content.pData (pas d'allocation : on fait pointer sur la partie
*                                 adquate du contenu de Asn1.pData)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_INVALID_DATA : Le format du bloc Asn1 n'est pas support.
*
*******************************************************************************/
int CC_ExtractContent(ASN1 *pAsn1)

{
   BYTE
      *pData;
   int
      NbBytes,
      i;

   pData = pAsn1->Asn1.pData;

   if ((pData[0] & 0x1F) == 0x1F)
   {
      /* High-tag-number : non support                                       */
      return(RV_INVALID_DATA);
   }
   else
	{
		pAsn1->Tag = pData[0];
	}

   if (pData[1] == 0x80)
   {
      /* Constructed, indefinite-length method : non support                 */
      return(RV_INVALID_DATA);
   }
   else if (pData[1] > 0x82)
   {
      /* Constructed, definite-length method : longueur trop grande           */
      return(RV_INVALID_DATA);
   }
   else if (pData[1] < 0x80)
   {
      /* Primitive, definite-length method                                    */
      pAsn1->Content.usLen = pData[1];
      pAsn1->Content.pData = &pData[2];

      pAsn1->Asn1.usLen = pAsn1->Content.usLen + 2;

      /* Looking for memory violation                                         */
      if (pData + pAsn1->Content.usLen + 2 > dwPtrMax)
      {
         return(RV_INVALID_DATA);
      }
   }
   else
   {
      /* Constructed, definite-length method                                  */

      NbBytes = pData[1] & 0x7F;
      ASSERT(NbBytes <= 2);

      pAsn1->Content.usLen = 0;
      for (i = 0; i < NbBytes; i++)
      {
          pAsn1->Content.usLen = (pAsn1->Content.usLen << 8) + pData[2+i];
      }

      /* Looking for memory violation                                         */
      if (pData + pAsn1->Content.usLen+2+NbBytes > dwPtrMax)
      {
         return(RV_INVALID_DATA);
      }

      pAsn1->Content.pData = &pData[2+NbBytes];

      pAsn1->Asn1.usLen = pAsn1->Content.usLen + 2 + NbBytes;
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_BuildAsn1(ASN1 *pAsn1)
*
* Description : Reconstruit un bloc Asn1 (pAsn1->Asn1)  partir de son contenu
*               (pAsn1->Content) et de son Tag suppos spcifi (pAsn1->Tag)
*               en synthtisant son enrobage (identifier bytes, length bytes).
*
* Remarks     : Le champ Content.pData a t allou par la fonction appelant.
*               Seulement la forme 'low-tag-number' (tag sur un seul octet) est
*               supporte.
*
* In          : pAsn1->Content.usLen
*               pAsn1->Content.pData
*               pAsn1->Tag
*
* Out         : Les champs suivants sont renseigns (si RV_SUCCESS) :
*                - Asn1.usLen
*                - Asn1.pData (allou ici,  librer par la fonction appelant)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*
*******************************************************************************/
int CC_BuildAsn1(ASN1 *pAsn1)

{
   if (pAsn1->Content.usLen < 0x0080)
   {
      pAsn1->Asn1.usLen = pAsn1->Content.usLen + 2;

      if ((pAsn1->Asn1.pData = GMEM_Alloc(pAsn1->Asn1.usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pAsn1->Asn1.pData[0] = (BYTE) pAsn1->Tag;
      pAsn1->Asn1.pData[1] = (BYTE) pAsn1->Content.usLen;
      memcpy(&(pAsn1->Asn1.pData[2]), pAsn1->Content.pData, pAsn1->Content.usLen); 
   }
   else
   {
      if (pAsn1->Content.usLen < 0x0100)
      {
         pAsn1->Asn1.usLen = pAsn1->Content.usLen + 3;

         if ((pAsn1->Asn1.pData = GMEM_Alloc(pAsn1->Asn1.usLen)) == NULL_PTR)
         {
            return(RV_MALLOC_FAILED);
         }

         pAsn1->Asn1.pData[0] = pAsn1->Tag;
         pAsn1->Asn1.pData[1] = 0x81;
         pAsn1->Asn1.pData[2] = (BYTE)pAsn1->Content.usLen;
         memcpy(&(pAsn1->Asn1.pData[3]), pAsn1->Content.pData, pAsn1->Content.usLen); 
      }
      else
      {
         pAsn1->Asn1.usLen = pAsn1->Content.usLen + 4;

         if ((pAsn1->Asn1.pData = GMEM_Alloc(pAsn1->Asn1.usLen)) == NULL_PTR)
         {
            return(RV_MALLOC_FAILED);
         }

         pAsn1->Asn1.pData[0] = pAsn1->Tag;
         pAsn1->Asn1.pData[1] = 0x82;
         pAsn1->Asn1.pData[2] = pAsn1->Content.usLen >> 8;
         pAsn1->Asn1.pData[3] = pAsn1->Content.usLen & 0x00FF;
         memcpy(&(pAsn1->Asn1.pData[4]), pAsn1->Content.pData, pAsn1->Content.usLen); 
      }
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int SearchDataByIndex(USHORT usIndex,
*                       BYTE   *pDict,
*                       BLOC   *pOutBloc
*                      )
*
* Description : Recherche l'entre (mot/phrase) dans le dictionnaire dont
*               l'index est spcifi en entre.
*
* Remarks     : Le format du dictionnaire est le suivant :
*
*                - 2 octets  : le nombre d'entres
*                - 2 octets  : la longueur totale du dictionnaire
*
*                - 2 octets  : I0, l'index de l'entre 0
*                - 2 octets  : L0, la longueur de l'entre 0
*                - L0 octets : l'entre 0
*
*                - 2 octets  : I1, l'index de l'entre 1
*                - 2 octets  : L1, la longueur de l'entre 1
*                - L1 octets : l'entre 1
*
*                - ........
*
* In          : usIndex : l'index du mot/phrase recherch
*               pDict : pointe sur le dictionnaire charg en mmoire
*
* Out         : pOutBloc : l'entre correspondant  l'index
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_BAD_DICTIONARY : Aucune entre ayant le bon index n'a t
*                                   trouve dans le dictionnaire.
*
*******************************************************************************/
int SearchDataByIndex(USHORT usIndex,
                      BYTE   *pDict,
                      BLOC   *pOutBloc
                      )

{
   BYTE
      *pCurrent;
   BOOL 
      bFound = FALSE;
   USHORT
      i,
      usLength,
      usCount,
      usCurrent;

   usCount = *(USHORT *)pDict; //memcpy(&usCount, pDict, sizeof(usCount));
   pCurrent = pDict + 4;

   bFound = FALSE;

   for (i = 0; i < usCount; i++)
   {
      usCurrent = *(USHORT UNALIGNED *)pCurrent; //memcpy(&usCurrent, (USHORT *) pCurrent, 2);
      pCurrent += 2;
      if (usCurrent == usIndex)
      {
         bFound = TRUE;
         break;
      }   
      usLength = *(USHORT UNALIGNED *)pCurrent; //memcpy(&usLength, (USHORT *) pCurrent, 2);
      pCurrent += (2 + usLength);
   }
   if (!bFound)
   {
      return(RV_BAD_DICTIONARY);
   }

   usLength = *(USHORT UNALIGNED *)pCurrent; //memcpy(&usLength, (USHORT *) pCurrent, 2);
   pCurrent += 2;

   pOutBloc->pData = pCurrent;
   pOutBloc->usLen = usLength;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_RawEncode(BLOC *pInBloc,
*                  BLOC *pOutBloc,
*						 BOOL bUseDictionary
*                 )
*
* Description : Traite le bloc d'entre comme une donne terminale dans le
*               processus d'extractions successives des enrobages Asn1.
*               Le but est ici de compresser au maximum ce bloc sans faire
*               aucune hypothse sur sa structure Asn1. Pour ce faire, on
*               commence (si bUseDictionary == TRUE) par remplacer chaque
*               mot/phrase du dictionnaire rencontr par son index prcd d'un
*               caractre d'chappement, puis on applique  la donne rsiduelle
*               successivement chaque algorithme de compression statistique pour
*               n'en retenir que le meilleur. La sortie est le meilleur
*               compress du rsidu prcd d'un header codant le numro de
*               l'algo ainsi que la longueur du compress.           
*
* Remarks     :
*
* In          : pInBloc : le bloc  encoder
*               bUseDictionary : on peut ne pas utiliser le dictionnaire
*
* Out         : pOutBloc : le bloc encod (mmoire alloue ici  librer par le
*                          programme appelant)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               RV_INVALID_DATA : Le meilleur compress du rsidu est trop long.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_RawEncode(BLOC *pInBloc,
                 BLOC *pOutBloc,
					  BOOL bUseDictionary
                )

{
   BLOC
      OldBloc,
      NewBloc,
      CompBloc,
      BestBloc;
   BOOL
      bFound;
   BYTE
      *pCurrent,
      *pToCurrent,
      *pFromCurrent,
      *pData,
      BestAlgoId;
   int
//	  value,
	  rv;
   USHORT
      pos,
      usEscapeCount,
      usIndex,
      usLength,
      usCount,
      usCurrent;


	/* Il peut tre intressant de ne pas utiliser le dictionnaire si on sait 
	   qu'il ne va pas servir car cela evite de doubler les 0xFF pour rien */

	if (bUseDictionary == FALSE)
	{
		OldBloc.usLen = pInBloc->usLen;
		if ((OldBloc.pData = GMEM_Alloc(OldBloc.usLen)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}
		memcpy(OldBloc.pData, pInBloc->pData, OldBloc.usLen);
	}
	else
	{
		/* On recopie le bloc d'entre dans un bloc de travail en doublant les 'escape' */

		pCurrent = pInBloc->pData;
		usEscapeCount = 0;
		for (pos = 0; pos < pInBloc->usLen; pos++)
		{
			if (*pCurrent == ESCAPE_CHAR)
			{
				usEscapeCount++;
			}
			pCurrent++;
		}

		OldBloc.usLen = pInBloc->usLen + usEscapeCount;
		if ((OldBloc.pData = GMEM_Alloc(OldBloc.usLen)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}

		pFromCurrent = pInBloc->pData;
		pToCurrent = OldBloc.pData;
		for (pos = 0; pos < pInBloc->usLen; pos++)
		{
			if ((*pToCurrent = *pFromCurrent) == ESCAPE_CHAR)
			{
				pToCurrent++; 
				*pToCurrent = ESCAPE_CHAR; 
			}
			pFromCurrent++;
			pToCurrent++;
		}


		/* Si un dictionnaire existe, on l'utilise pour coder ses entres rencontres */

		if (pDictMemory != NULL_PTR)
		{
			pCurrent = pDictMemory;

			memcpy(&usCount, pCurrent, sizeof(usCount));
			pCurrent += 4;

			for (usCurrent = 0; usCurrent < usCount; usCurrent++)
			{
				memcpy(&usIndex, pCurrent, sizeof(usIndex));
				pCurrent += 2;

				memcpy(&usLength, pCurrent, sizeof(usLength));
				pCurrent += 2;

				if (usLength <= OldBloc.usLen)
				{
					bFound = FALSE;
					for (pos = 0; pos < OldBloc.usLen - usLength + 1; pos++)
					{
						if (memcmp(pCurrent, OldBloc.pData + pos, usLength) == 0)
						{
							bFound = TRUE;
							break;
						}
					}

					if (bFound)
					{
						if (usIndex < 0x80)
						{
							NewBloc.usLen = OldBloc.usLen - usLength + 2;
							if ((NewBloc.pData = GMEM_Alloc(NewBloc.usLen)) == NULL_PTR)
							{
								GMEM_Free(OldBloc.pData);
								return(RV_MALLOC_FAILED);
							}
							memcpy(NewBloc.pData, OldBloc.pData, pos);
							NewBloc.pData[pos] = ESCAPE_CHAR;
							NewBloc.pData[pos + 1] = (BYTE) usIndex;
							memcpy(NewBloc.pData + pos + 2,
										 OldBloc.pData + pos + usLength,
										 OldBloc.usLen - pos - usLength);
							GMEM_Free(OldBloc.pData);
						}
						else
						{
							NewBloc.usLen = OldBloc.usLen - usLength + 3;
							if ((NewBloc.pData = GMEM_Alloc(NewBloc.usLen)) == NULL_PTR)
							{
								GMEM_Free(OldBloc.pData);
								return(RV_MALLOC_FAILED);
							}
							memcpy(NewBloc.pData, OldBloc.pData, pos);
							NewBloc.pData[pos] = ESCAPE_CHAR;
							NewBloc.pData[pos + 1] = (BYTE) (usIndex >> 8) | 0x80;
							NewBloc.pData[pos + 2] = (BYTE) (usIndex & 0x00FF);
							memcpy(NewBloc.pData + pos + 3,
										 OldBloc.pData + pos + usLength,
										 OldBloc.usLen - pos - usLength);
							GMEM_Free(OldBloc.pData);
						}

						OldBloc = NewBloc;
					}
				}

				pCurrent += usLength;
			}
		}
	}

#ifdef _STUDY
	for (i = 0; i < OldBloc.usLen; i++)
	{
		value = OldBloc.pData[i];
		Ac256[value]++;

		Ac16[value & 0x0F]++;
		Ac16[(value & 0xF0) >> 4]++;

		Ac4[value & 0x03]++;
		Ac4[(value & 0x0C) >> 2]++;
		Ac4[(value & 0x30) >> 4]++;
		Ac4[(value & 0xC0) >> 6]++;

		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
		Ac2[value & 0x01]++; value >>= 1;
	}

	fprintf(pfdLog, "\n");
	for  (i = 0; i < (OldBloc.usLen <= 8 ? OldBloc.usLen : 8); i++)
	{
		fprintf(pfdLog, "%02X", OldBloc.pData[i]);
	}
	fprintf(pfdLog, " (");
	for  (i = 0; i < (OldBloc.usLen <= 8 ? OldBloc.usLen : 8); i++)
	{
		fprintf(pfdLog, "%c", OldBloc.pData[i]);
	}
	fprintf(pfdLog, ")\n");

#endif

	BestBloc = OldBloc;
	BestAlgoId = ALGO_NONE;

#ifdef _ALGO_1
	rv = CC_GenericCompress(&OldBloc, &CompBloc, ALGO_ACFX8);
	if (rv == RV_MALLOC_FAILED) return rv;
	// The compression algorithm may return RV_COMPRESSION_FAILED when
	// the compression algorithm wants to use MORE space than the input data.
	// In such a case, the algorithm returns the raw data in the compressed block
	if (CompBloc.usLen < BestBloc.usLen)
	{
		/* On prserve OldBloc.pData qui sert pour les autres algos */
		if (BestBloc.pData != OldBloc.pData)
		{
			GMEM_Free(BestBloc.pData);
		}
		BestBloc = CompBloc;
		BestAlgoId = ALGO_ACFX8;
	}
	else
	{
		GMEM_Free(CompBloc.pData);
	}
#endif

#ifdef _ALGO_2
	rv = CC_GenericCompress(&OldBloc, &CompBloc, ALGO_ACAD8);
	if (rv == RV_MALLOC_FAILED) return rv;
	// The compression algorithm may return RV_COMPRESSION_FAILED when
	// the compression algorithm wants to use MORE space than the input data.
	// In such a case, the algorithm returns the raw data in the compressed block
	if (CompBloc.usLen < BestBloc.usLen)
	{
		/* On prserve OldBloc.pData qui sert pour les autres algos */
		if (BestBloc.pData != OldBloc.pData)
		{
			GMEM_Free(BestBloc.pData);
		}
		BestBloc = CompBloc;
		BestAlgoId = ALGO_ACAD8;
	}
	else
	{
		GMEM_Free(CompBloc.pData);
	}
#endif


   if (BestBloc.usLen < 0x1F) /* La valeur 0x1F peut engendrer 0xFF = ESCAPE_CHAR */
   {
      if ((pData = GMEM_Alloc(BestBloc.usLen + 1)) == NULL_PTR)
      {
          GMEM_Free(BestBloc.pData);
		  return(RV_MALLOC_FAILED);
      }
      else
      {
         pData[0] = (BestAlgoId << 5) | BestBloc.usLen;
         memcpy(&pData[1], BestBloc.pData, BestBloc.usLen);

         pOutBloc->usLen = BestBloc.usLen + 1;
         pOutBloc->pData = pData;

		 GMEM_Free(BestBloc.pData);
      }      
   }
   else if (BestBloc.usLen < 0x2000)
   {
      if ((pData = GMEM_Alloc(BestBloc.usLen + 3)) == NULL_PTR)
      {
         GMEM_Free(BestBloc.pData);
		 return(RV_MALLOC_FAILED);
      }
      else
      {
         pData[0] = ESCAPE_CHAR;
         pData[1] = (BestAlgoId << 5) | (BestBloc.usLen >> 8);
         pData[2] = BestBloc.usLen & 0xFF;
         memcpy(&pData[3], BestBloc.pData, BestBloc.usLen);

         pOutBloc->usLen = BestBloc.usLen + 3;
         pOutBloc->pData = pData;

		 GMEM_Free(BestBloc.pData);
      }      
   }
   else
   {
      GMEM_Free(BestBloc.pData);
	  return(RV_INVALID_DATA);
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_RawDecode(BYTE    *pInBloc,
*                  BLOC    *pOutBloc,
*                  USHORT  *pLength,
*				   BOOL		bUseDictionnary
*                 )
*
* Description : Transformation inverse de 'CC_RawEncode'.           
*
* Remarks     :
*
* In          : pInBloc : le bloc  dcoder
*               bUseDictionary : on peut ne pas utiliser le dictionnaire (doit
*                                tre consistent avec l'encodage)
*
* Out         : pOutBloc : le bloc dcod (mmoire alloue ici  librer par le
*                          programme appelant)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_RawDecode(BYTE   *pInData,
                 BLOC   *pOutBloc,
                 USHORT *pLength,
					  BOOL	bUseDictionary
                )

{
   BLOC
      OldBloc,
      NewBloc,
      RecordBloc,
      CompData;
   BYTE
      AlgoId;
   int
      rv;
   USHORT
      pos,
      usIndex;


   if (pInData[0] == ESCAPE_CHAR)
   {
      AlgoId = pInData[1] >> 5;
      CompData.usLen = ((pInData[1] & 0x1F) << 8) + pInData[2];
      CompData.pData = &(pInData[3]);
      *pLength = CompData.usLen + 3;
   }
   else
   {
      AlgoId = pInData[0] >> 5;
      CompData.usLen = pInData[0] & 0x1F;
      CompData.pData = &(pInData[1]);
      *pLength = CompData.usLen + 1;
   }

   rv = CC_GenericUncompress(&CompData, &OldBloc, AlgoId);
   if (rv != RV_SUCCESS) return rv;

	if (bUseDictionary)
	{
		pos = 0;
		while (pos < OldBloc.usLen)
		{
			if (OldBloc.pData[pos] == ESCAPE_CHAR)
			{
				if (OldBloc.pData[pos + 1] == ESCAPE_CHAR)
				{
					NewBloc.usLen = OldBloc.usLen - 1;
					if ((NewBloc.pData = GMEM_Alloc(NewBloc.usLen)) == NULL_PTR)
					{
						GMEM_Free(OldBloc.pData);
						return(RV_MALLOC_FAILED);
					}

					memcpy(NewBloc.pData, OldBloc.pData, pos);
					NewBloc.pData[pos] = ESCAPE_CHAR;
					memcpy(NewBloc.pData + pos + 1,
							 OldBloc.pData + pos + 2,
							 OldBloc.usLen - pos - 2);

					GMEM_Free(OldBloc.pData);
					OldBloc = NewBloc;

					pos++;
				}
				else if (OldBloc.pData[pos + 1] < 0x80)
				{
					usIndex = OldBloc.pData[pos + 1];

					rv = SearchDataByIndex(usIndex, pDictMemory, &RecordBloc);
					if (rv != RV_SUCCESS)
					{
						GMEM_Free(OldBloc.pData);
						return rv;
					}

					NewBloc.usLen = OldBloc.usLen - 2 + RecordBloc.usLen;
					if ((NewBloc.pData = GMEM_Alloc(NewBloc.usLen)) == NULL_PTR)
					{
						GMEM_Free(OldBloc.pData);
						return(RV_MALLOC_FAILED);
					}

					memcpy(NewBloc.pData, OldBloc.pData, pos);
					memcpy(NewBloc.pData + pos, RecordBloc.pData, RecordBloc.usLen);
					memcpy(NewBloc.pData + pos + RecordBloc.usLen,
							 OldBloc.pData + pos + 2,
							 OldBloc.usLen - pos - 2);

					GMEM_Free(OldBloc.pData);
					OldBloc = NewBloc;

					pos += RecordBloc.usLen;
				}
				else
				{
					usIndex = ((OldBloc.pData[pos + 1] & 0x7F) << 8) + OldBloc.pData[pos + 2];

					rv = SearchDataByIndex(usIndex, pDictMemory, &RecordBloc);
					if (rv != RV_SUCCESS)
					{
						GMEM_Free(OldBloc.pData);
						return rv;
					}

					NewBloc.usLen = OldBloc.usLen - 3 + RecordBloc.usLen;
					if ((NewBloc.pData = GMEM_Alloc(NewBloc.usLen)) == NULL_PTR)
					{
						GMEM_Free(OldBloc.pData);
						return(RV_MALLOC_FAILED);
					}

					memcpy(NewBloc.pData, OldBloc.pData, pos);
					memcpy(NewBloc.pData + pos, RecordBloc.pData, RecordBloc.usLen);
					memcpy(NewBloc.pData + pos + RecordBloc.usLen,
							 OldBloc.pData + pos + 3,
							 OldBloc.usLen - pos - 3);

					GMEM_Free(OldBloc.pData);
					OldBloc = NewBloc;

					pos += RecordBloc.usLen;
				}
			}
			else
			{
				pos++;
			}
		}
	}

   *pOutBloc = OldBloc;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_GenericCompress(BLOC *pUncompBloc,
*                        BLOC *pCompBloc,
*                        BYTE AlgoId
*                       )
*
* Description : Effectue une compression statistique sur la donne d'entre en
*               utilisant l'algorithme spcifi dans AlgoId.
*
* Remarks     : Si l'algorithme spcifi n'est pas implment, renvoie la donne
*               originale.
*
* In          : pUncompBloc : la donne  compresser
*               AlgoId : numro de l'algorithme  employer
*
* Out         : pCompBloc : la donne compresse (mmoire alloue ici  librer
*                           par la fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*
*******************************************************************************/
int CC_GenericCompress(BLOC *pUncompBloc,
                       BLOC *pCompBloc,
                       BYTE AlgoId
                      )

{
	switch(AlgoId)
	{
#ifdef _ALGO_1
		case ALGO_ACFX8 :	/* Arithmetic coding, byte oriented, fixed model */
		{
			if (AcFx8_Encode(pUncompBloc, pCompBloc) != RV_SUCCESS)
			{
				return(RV_INVALID_DATA);
			}
			break;
		}
#endif

#ifdef _ALGO_2
		case ALGO_ACAD8 :	/* Arithmetic coding, byte oriented, adaptative model */
		{
			if (AcAd8_Encode(pUncompBloc, pCompBloc) != RV_SUCCESS)
			{
				return(RV_INVALID_DATA);
			}
			break;
		}
#endif

		default :
		{
         if ((pCompBloc->pData = GMEM_Alloc(pUncompBloc->usLen)) == NULL_PTR)
         {
            return(RV_MALLOC_FAILED);
         }
			pCompBloc->usLen = pUncompBloc->usLen;
			memcpy(pCompBloc->pData, pUncompBloc->pData, pCompBloc->usLen);
			break;
		}
	}

#ifdef _STUDY
	fprintf(pfdLog, "Algo : %d | 0x%04x (%04d) -> 0x%04x (%04d)", AlgoId,
						 pUncompBloc->usLen, pUncompBloc->usLen,
						 pCompBloc->usLen, pCompBloc->usLen
			 );
	if (pUncompBloc->usLen > pCompBloc->usLen)
	{
		fprintf(pfdLog, " | %d", pCompBloc->usLen - pUncompBloc->usLen);
	}
	fprintf(pfdLog, "\n");
#endif

	return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_GenericUncompress(BLOC *pCompBloc,
*                          BLOC *pUncompBloc,
*                          BYTE AlgoID
*                         )
*
* Description : Effectue une dcompression statistique sur la donne d'entre en
*               utilisant l'algorithme spcifi dans AlgoId.
*
* Remarks     : 
*
* In          : pUncompBloc : la donne  dcompresser
*               AlgoId : numro de l'algorithme  employer
*
* Out         : pCompBloc : la donne dcompresse (mmoire alloue ici 
*                           librer par la fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               RV_INVALID_DATA : L'algorithme spcifi n'existe pas.
*
*******************************************************************************/
int CC_GenericUncompress(BLOC *pCompBloc,
                         BLOC *pUncompBloc,
                         BYTE AlgoId
                        )

{
   switch(AlgoId)
   {
		case ALGO_NONE :
			pUncompBloc->usLen = pCompBloc->usLen;
			if ((pUncompBloc->pData = GMEM_Alloc(pUncompBloc->usLen)) == NULL_PTR)
			{
				return(RV_MALLOC_FAILED);
			}
			memcpy(pUncompBloc->pData, pCompBloc->pData, pUncompBloc->usLen);
			break;

#ifdef _ALGO_1
		case ALGO_ACFX8 :
			if (AcFx8_Decode(pCompBloc, pUncompBloc) != RV_SUCCESS)
			{
				return(RV_INVALID_DATA);
			}
			break;
#endif

#ifdef _ALGO_2
		case ALGO_ACAD8 :
			if (AcAd8_Decode(pCompBloc, pUncompBloc) != RV_SUCCESS)
			{
				return(RV_INVALID_DATA);
			}
			break;
#endif

		default :
			return(RV_INVALID_DATA);
			break;
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_TBSCertificate(BLOC *pInBloc,
*                              BLOC *pOutBloc
*                             )
*
* Description : Encode une donne de type TBSCertificate.
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : Certaines parties d'un TBSCertificate sont optionnelles. On
*               dtecte pour chacune d'elles si elle est prsente et on
*               l'indique dans des bits rservs d'un octet de contrle plac
*               en dbut du rsultat encod. Cet octet de contrle contient
*               galement le numro de version X.509 du certificat.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_TBSCertificate(BLOC *pInBloc,
                             BLOC *pOutBloc
                            )

{
   ASN1
      serialNumberPart,
      signaturePart,
      issuerPart,
      validityPart,
      subjectPart,
      subjectPKInfoPart,
      issuerUIDPart,
      subjectUIDPart,
      extensionsPart;
   BLOC
      serialNumberEncoded,
      signatureEncoded,
      issuerEncoded,
      validityEncoded,
      subjectEncoded,
      subjectPKInfoEncoded,
      issuerUIDEncoded,
      subjectUIDEncoded,
      extensionsEncoded;
   BOOL
      bVersionPresent = FALSE,
      bIssuerUIDPresent = FALSE,
      bSubjectUIDPresent = FALSE,
      bExtensionsPresent = FALSE;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      usVersion = 0;


   /* Dcomposition du tbsCertificate en ses diffrents composants            */
   
   pCurrent = pInBloc->pData;

   if (pCurrent[0] == TAG_OPTION_VERSION)
   {
      /* On a alors A0 03 02 01 vv  o vv est la version                      */
      bVersionPresent = TRUE;
      usVersion = pCurrent[4];
      pCurrent += 5;
   }

   serialNumberPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&serialNumberPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = serialNumberPart.Content.pData + serialNumberPart.Content.usLen;

   signaturePart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&signaturePart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = signaturePart.Content.pData + signaturePart.Content.usLen;

   issuerPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&issuerPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = issuerPart.Content.pData + issuerPart.Content.usLen;

   validityPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&validityPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = validityPart.Content.pData + validityPart.Content.usLen;

   subjectPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&subjectPart);
#ifdef _STUDY
//	fprintf(pfdLog, "Subject : %d octets\n", subjectPart.Asn1.usLen);
#endif
   if (rv != RV_SUCCESS) return rv;
   pCurrent = subjectPart.Content.pData + subjectPart.Content.usLen;

   subjectPKInfoPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&subjectPKInfoPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = subjectPKInfoPart.Content.pData + subjectPKInfoPart.Content.usLen;

   if (pCurrent[0] == TAG_OPTION_ISSUER_UID)
   {
      bIssuerUIDPresent = TRUE;

      issuerUIDPart.Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&issuerUIDPart);
      if (rv != RV_SUCCESS) return rv;
      pCurrent = issuerUIDPart.Content.pData + issuerUIDPart.Content.usLen;
   }

   if (pCurrent[0] == TAG_OPTION_SUBJECT_UID)
   {
      bSubjectUIDPresent = TRUE;

      subjectUIDPart.Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&subjectUIDPart);
      if (rv != RV_SUCCESS) return rv;
      pCurrent = subjectUIDPart.Content.pData + subjectUIDPart.Content.usLen;
   }

   if (pCurrent[0] == TAG_OPTION_EXTENSIONS)
   {
      bExtensionsPresent = TRUE;

      extensionsPart.Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&extensionsPart);
      if (rv != RV_SUCCESS) return rv;
      pCurrent = extensionsPart.Content.pData + extensionsPart.Content.usLen;
   }


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

	/* Les pData des blocs *Encoded sont allous par les fonctions CC_Encode_*.
	   Ils sont librs dans cette fonction aprs usage                        */

   serialNumberEncoded.pData = NULL;
   signatureEncoded.pData    = NULL;
   issuerEncoded.pData       = NULL;
   validityEncoded.pData     = NULL;
   subjectEncoded.pData      = NULL;
   subjectPKInfoEncoded.pData= NULL;
   issuerUIDEncoded.pData    = NULL;
   subjectUIDEncoded.pData   = NULL;
   extensionsEncoded.pData   = NULL;

   pOutBloc->usLen = 1;

   rv = CC_Encode_CertificateSerialNumber(&serialNumberPart.Content, &serialNumberEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += serialNumberEncoded.usLen;

   rv = CC_Encode_AlgorithmIdentifier(&signaturePart.Content, &signatureEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += signatureEncoded.usLen;

   rv = CC_Encode_Name(&issuerPart.Content, &issuerEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += issuerEncoded.usLen;

   rv = CC_Encode_Validity(&validityPart.Content, &validityEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += validityEncoded.usLen;

   rv = CC_Encode_Name(&subjectPart.Content, &subjectEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += subjectEncoded.usLen;

   rv = CC_Encode_SubjectPKInfo(&subjectPKInfoPart.Content, &subjectPKInfoEncoded);
   if (rv != RV_SUCCESS) goto err;
   pOutBloc->usLen += subjectPKInfoEncoded.usLen;

   if (bIssuerUIDPresent == TRUE)
   {
      rv = CC_Encode_UniqueIdentifier(&issuerUIDPart.Content, &issuerUIDEncoded);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += issuerUIDEncoded.usLen;
   }

   if (bSubjectUIDPresent == TRUE)
   {
      rv = CC_Encode_UniqueIdentifier(&subjectUIDPart.Content, &subjectUIDEncoded);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += subjectUIDEncoded.usLen;
   }

   if (bExtensionsPresent == TRUE)
   {
      rv = CC_Encode_Extensions(&extensionsPart.Content, &extensionsEncoded);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += extensionsEncoded.usLen;
   }


   /* Reconstruction  partir des composants                                  */

   /* A dsallouer par le programme appelant                                  */
   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   *pCurrent = 0x80 * (bVersionPresent == TRUE)
             + 0x40 * (bIssuerUIDPresent == TRUE)
             + 0x20 * (bSubjectUIDPresent == TRUE)
             + 0x10 * (bExtensionsPresent == TRUE)
             + usVersion;
   pCurrent++;

   memcpy(pCurrent, serialNumberEncoded.pData, serialNumberEncoded.usLen);
   GMEM_Free(serialNumberEncoded.pData); 
   pCurrent += serialNumberEncoded.usLen;

   memcpy(pCurrent, signatureEncoded.pData, signatureEncoded.usLen);
   GMEM_Free(signatureEncoded.pData); 
   pCurrent += signatureEncoded.usLen;

   memcpy(pCurrent, issuerEncoded.pData, issuerEncoded.usLen);
   GMEM_Free(issuerEncoded.pData); 
   pCurrent += issuerEncoded.usLen;

   memcpy(pCurrent, validityEncoded.pData, validityEncoded.usLen);
   GMEM_Free(validityEncoded.pData); 
   pCurrent += validityEncoded.usLen;

   memcpy(pCurrent, subjectEncoded.pData, subjectEncoded.usLen);
   GMEM_Free(subjectEncoded.pData); 
   pCurrent += subjectEncoded.usLen;

   memcpy(pCurrent, subjectPKInfoEncoded.pData, subjectPKInfoEncoded.usLen);
   GMEM_Free(subjectPKInfoEncoded.pData); 
   pCurrent += subjectPKInfoEncoded.usLen;

   if (bIssuerUIDPresent == TRUE)
   {
      memcpy(pCurrent, issuerUIDEncoded.pData, issuerUIDEncoded.usLen);
      GMEM_Free(issuerUIDEncoded.pData); 
      pCurrent += issuerUIDEncoded.usLen;
   }

   if (bSubjectUIDPresent == TRUE)
   {
      memcpy(pCurrent, subjectUIDEncoded.pData, subjectUIDEncoded.usLen);
      GMEM_Free(subjectUIDEncoded.pData); 
      pCurrent += subjectUIDEncoded.usLen;
   }

   if (bExtensionsPresent == TRUE)
   {
      memcpy(pCurrent, extensionsEncoded.pData, extensionsEncoded.usLen);
      GMEM_Free(extensionsEncoded.pData); 
      pCurrent += extensionsEncoded.usLen;
   }

   return(RV_SUCCESS);

err:
   GMEM_Free(serialNumberEncoded.pData);
   GMEM_Free(signatureEncoded.pData); 
   GMEM_Free(issuerEncoded.pData);  
   GMEM_Free(validityEncoded.pData); 
   GMEM_Free(subjectEncoded.pData); 
   GMEM_Free(subjectPKInfoEncoded.pData); 
   GMEM_Free(issuerUIDEncoded.pData);
   GMEM_Free(subjectUIDEncoded.pData);
   GMEM_Free(extensionsEncoded.pData);  
   return rv;
}


/*******************************************************************************
* int CC_Encode_CertificateSerialNumber(BLOC *pInBloc,
*                                       BLOC *pOutBloc
*                                      )
*
* Description : Encode une donne de type CertificateSerialNumber.
*               Ceci consiste seulement en l'encodage brute (CC_RawEncode) de la
*               donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_CertificateSerialNumber(BLOC *pInBloc,
                                      BLOC *pOutBloc
                                     )

{
   int
      rv;


   rv = CC_RawEncode(pInBloc, pOutBloc, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_AlgorithmIdentifier(BLOC *pInBloc,
*                                   BLOC *pOutBloc
*                                  )
*
* Description : Encode une donne de type AlgorithmIdentifier.
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : bNullParam sert  coder sur un bit l'information qu'il n'y a pas
*               de paramtre  l'algorithme. Cette information occupe toujours
*               deux octets dans le certificat est vaut toujours {0x05, 0x00}.
*               On utilise un dictionnaire statique (dfini au dbut de ce
*               source) pour remplacer le type d'algorithme par un index.
*               Un octet de contrle (en dbut du rsultat) indique, ou bien que
*               l'on n'a pas trouv le type d'algo dans le dico (valeur 0xFF ->
*               Encodage brut de la donne d'entre intgrale), ou bien un flag
*               prcisant s'il y a des paramtres et l'index du type d'algo.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_AlgorithmIdentifier(BLOC  *pInBloc,
                                  BLOC  *pOutBloc
                                 )

{
    ASN1
        AlgorithmPart,
        ParametersPart;
    BLOC
        AlgorithmIdentifierEncoded,
        ParametersAsn1Encoded;
    BOOL
        bFound,
        bNoParam   = FALSE,
        bNullParam = FALSE;
    int
        rv;
    USHORT
        Index,
        AlgoIndex;


    AlgorithmPart.Asn1.pData = pInBloc->pData;
    rv = CC_ExtractContent(&AlgorithmPart);
    if (rv != RV_SUCCESS) return rv;

    if (AlgorithmPart.Asn1.usLen == pInBloc->usLen)
    {
        bNoParam   = TRUE;
        bNullParam = FALSE;
    }
    else
    {
        ParametersPart.Asn1.pData = AlgorithmPart.Content.pData + AlgorithmPart.Content.usLen;
        rv = CC_ExtractContent(&ParametersPart);
        if (rv != RV_SUCCESS) return rv;

        if (ParametersPart.Content.usLen == 0)
        {
            bNoParam  = TRUE;
            bNullParam = TRUE;
        }
    }

    /* Recherche de l'identifiant de l'algorithme dans le dictionnaire         */

    Index = 0;
    bFound = FALSE;
    while ((bFound == FALSE) && (AlgorithmTypeDict[Index] != NULL))
    {
        if (!memcmp(AlgorithmTypeDict[Index],
                    AlgorithmPart.Content.pData,
                    AlgorithmPart.Content.usLen))
        {
            bFound = TRUE;
            AlgoIndex = Index;
        }
        Index++;
    }

    /* Construction de l'encodage                                              */

    if (bFound == TRUE)
    {
        if (bNoParam == TRUE)
        {
            if (bNullParam == TRUE)
            {
                /* Si on a trouv l'algorithme et il n'y a pas de paramtre          */

                pOutBloc->usLen = 1;
                if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
                {
                    return (RV_MALLOC_FAILED);
                }

                pOutBloc->pData[0] = (AlgoIndex | 0x80);
            }
            else
            {
                pOutBloc->usLen = 2;
                if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
                {
                    return (RV_MALLOC_FAILED);
                }

                pOutBloc->pData[0] = ABSENT_PARAMETER_CHAR;
                pOutBloc->pData[1] = (BYTE) AlgoIndex;
            }
        }
        else
        {

            /* Si on a trouv l'algorithme et il y a des paramtres              */
            /* On RawEncode non pas le contenu des paramtres mais l'Asn1 entier
                              car on n'est pas sr de l'encapsulage                             */

            rv = CC_RawEncode(&(ParametersPart.Asn1), &ParametersAsn1Encoded, TRUE);
            if (rv != RV_SUCCESS) return rv;

            pOutBloc->usLen = 1 + ParametersAsn1Encoded.usLen;
            if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
            {
                GMEM_Free(ParametersAsn1Encoded.pData);
                return (RV_MALLOC_FAILED);
            }

            pOutBloc->pData[0] = (BYTE) AlgoIndex;
            memcpy(&(pOutBloc->pData[1]),
                   ParametersAsn1Encoded.pData,
                   ParametersAsn1Encoded.usLen);

            GMEM_Free(ParametersAsn1Encoded.pData);
        }
    }
    else
    {
        /* Si on n'a pas trouv l'algorithme dans le dictionnaire               */
        /* On RawEncode le contenu de AlgorithmIdentifier c'est  dire la
                     concatnation du asn1 de AlgorithmPart et du asn1 de ParametersPart  */

        rv = CC_RawEncode(pInBloc, &AlgorithmIdentifierEncoded, TRUE);
        if (rv != RV_SUCCESS) return rv;

        pOutBloc->usLen = 1 + AlgorithmIdentifierEncoded.usLen;
        if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
        {
            GMEM_Free(AlgorithmIdentifierEncoded.pData);
            return (RV_MALLOC_FAILED);
        }

        pOutBloc->pData[0] = ESCAPE_CHAR;
        memcpy(&(pOutBloc->pData[1]),
               AlgorithmIdentifierEncoded.pData,
               AlgorithmIdentifierEncoded.usLen);

        GMEM_Free(AlgorithmIdentifierEncoded.pData);
    }

    return (RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_Name(BLOC *pInBloc,
*                    BLOC *pOutBloc
*                   )
*
* Description : Encode une donne de type Name.
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : Un octet de contrle (en dbut du rsultat) indique le nombre
*               de RelativeDistinguishedName dont est compos le Name.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_Name(BLOC *pInBloc,
                   BLOC *pOutBloc
                  )

{
   ASN1
      RDN[MAX_RDN];
   BLOC
      RDNEncoded[MAX_RDN];
   BYTE
      *pCurrent;
   USHORT
      i,
      usNbRDN;
   int
      rv;


   /* Dcomposition du Name en ses diffrents RelativeDistinguishedName       */

   pCurrent = pInBloc->pData;
   usNbRDN = 0;

   while (pCurrent < pInBloc->pData + pInBloc->usLen)
   {
      RDN[usNbRDN].Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&(RDN[usNbRDN]));
      if (rv != RV_SUCCESS) return rv;
      pCurrent = RDN[usNbRDN].Content.pData + RDN[usNbRDN].Content.usLen;
      usNbRDN++;
   }

   ASSERT(pCurrent == pInBloc->pData + pInBloc->usLen);


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

   for (i = 0; i < usNbRDN; i++)
   {
	   RDNEncoded[i].pData = NULL;
   }

   pOutBloc->usLen = 1;
   for (i = 0; i < usNbRDN; i++)
   {
      rv = CC_Encode_RDN(&RDN[i].Content, &RDNEncoded[i]);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += RDNEncoded[i].usLen;
   }
   

   /* Reconstruction  partir des composants                                  */

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   *pCurrent = (BYTE) usNbRDN;
   pCurrent++;

   for (i = 0; i < usNbRDN; i++)
   {
      memcpy(pCurrent, RDNEncoded[i].pData, RDNEncoded[i].usLen);
      GMEM_Free(RDNEncoded[i].pData); 
      pCurrent += RDNEncoded[i].usLen;
   }

   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbRDN; i++)
   {
      GMEM_Free(RDNEncoded[i].pData);
   }
   return (rv);
}


/*******************************************************************************
* int CC_Encode_RDN(BLOC *pInBloc,
*                   BLOC *pOutBloc
*                  )
*
* Description : Encode une donne de type RelativeDistinguishedName (RDN).
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : Un octet de contrle (en dbut du rsultat) indique le nombre
*               de AttributeValueAssertion dont est compos le RDN.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_RDN(BLOC *pInBloc,
                  BLOC *pOutBloc
                 )

{
   ASN1
      AVA[MAX_AVA];
   BLOC
      AVAEncoded[MAX_AVA];
   BYTE
      *pCurrent;
   USHORT
      i,
      usNbAVA;
   int
      rv;


   /* Dcomposition du RDN en ses diffrents AVA                              */

   pCurrent = pInBloc->pData;
   usNbAVA = 0;

   while (pCurrent < pInBloc->pData + pInBloc->usLen)
   {
      AVA[usNbAVA].Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&(AVA[usNbAVA]));
      if (rv != RV_SUCCESS) return rv;
      pCurrent = AVA[usNbAVA].Content.pData + AVA[usNbAVA].Content.usLen;
      usNbAVA++;
   }

   ASSERT(pCurrent == pInBloc->pData + pInBloc->usLen);


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

   for (i = 0; i < usNbAVA; i++)
   {
	   AVAEncoded[i].pData = NULL;
   }

   pOutBloc->usLen = 1;
   for (i = 0; i < usNbAVA; i++)
   {
      rv = CC_Encode_AVA(&AVA[i].Content, &AVAEncoded[i]);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += AVAEncoded[i].usLen;
   }
   

   /* Reconstruction  partir des composants                                  */

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   *pCurrent = (BYTE) usNbAVA;
   pCurrent++;

   for (i = 0; i < usNbAVA; i++)
   {
      memcpy(pCurrent, AVAEncoded[i].pData, AVAEncoded[i].usLen);
      GMEM_Free(AVAEncoded[i].pData); 
      pCurrent += AVAEncoded[i].usLen;
   }

   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbAVA; i++)
   {
      GMEM_Free(AVAEncoded[i].pData);
   }

   return(rv);

}


/*******************************************************************************
* int CC_Encode_AVA(BLOC *pInBloc,
*                   BLOC *pOutBloc
*                  )
*
* Description : Encode une donne de type AttributeValueAssertion (AVA).
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : On utilise un dictionnaire statique (dfini au dbut de ce
*               source) pour remplacer le type d'attribut par un index.
*               Un octet de contrle (en dbut du rsultat) indique, ou bien que
*               l'on n'a pas trouv le type d'attribut dans le dico (0xFF)
*               ou l'index du type d'attribut.
*               On ne code pas le Content de AttributeValue mais son Asn1 car on
*               n'est pas sr du tag employ.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_AVA(BLOC *pInBloc,
                  BLOC *pOutBloc
                 )

{
   ASN1
      AttributeTypePart,
      AttributeValuePart;
   BLOC
      AttributeTypeEncoded,
      AttributeValueEncoded;
   BOOL
      bFound;
   USHORT
      Index,
      AttributeTypeIndex;
   int
      rv;


   /* Dcomposition                                                           */

   AttributeTypePart.Asn1.pData = pInBloc->pData;
   rv = CC_ExtractContent(&AttributeTypePart);
   if (rv != RV_SUCCESS) return rv;

   AttributeValuePart.Asn1.pData = AttributeTypePart.Content.pData
                                 + AttributeTypePart.Content.usLen;
   rv = CC_ExtractContent(&AttributeValuePart);   /* Pas ncessaire */
   if (rv != RV_SUCCESS) return rv;


   /* Recherche de l'identifiant de l'AttributeType dans le dictionnaire      */

   Index = 0;
   bFound = FALSE;
	while((bFound == FALSE) && (AttributeTypeDict[Index] != NULL))
	{
		if (!memcmp(AttributeTypeDict[Index],
                  AttributeTypePart.Content.pData,
                  AttributeTypePart.Content.usLen))
      {
         bFound = TRUE;
         AttributeTypeIndex = Index;
      }
		Index++;
   }


   /* Construction de l'encodage                                              */

   /* Attention : on encode aussi l'enrobage de AttributeValue !              */

   if (bFound == TRUE)
   {
      /* Il nous faut la longueur enrobage compris mais cette ligne est-elle
		   vraiment ncessaire ?                                                */
      AttributeValuePart.Asn1.usLen = (unsigned short) (DWORD)((pInBloc->pData + pInBloc->usLen)
                                    - AttributeValuePart.Asn1.pData);

      rv = CC_RawEncode(&(AttributeValuePart.Asn1), &AttributeValueEncoded, TRUE);
		if (rv != RV_SUCCESS) return rv;

      pOutBloc->usLen = 1 + AttributeValueEncoded.usLen;
      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         GMEM_Free(AttributeValueEncoded.pData);
		 return(RV_MALLOC_FAILED);
      }

      pOutBloc->pData[0] = (BYTE) AttributeTypeIndex;
      memcpy(&(pOutBloc->pData[1]), AttributeValueEncoded.pData, AttributeValueEncoded.usLen);

      GMEM_Free(AttributeValueEncoded.pData);
   }
   else
   {
      /* Si on n'a pas trouv l'attribut dans le dictionnaire                 */

      rv = CC_RawEncode(&(AttributeTypePart.Content), &AttributeTypeEncoded, TRUE);
      if (rv != RV_SUCCESS) return rv;

      rv = CC_RawEncode(&(AttributeValuePart.Asn1), &AttributeValueEncoded, TRUE);
      if (rv != RV_SUCCESS)
	  {
		  GMEM_Free(AttributeTypeEncoded.pData);
		  return rv;
	  }

      pOutBloc->usLen = 1
                      + AttributeTypeEncoded.usLen
                      + AttributeValueEncoded.usLen;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         GMEM_Free(AttributeTypeEncoded.pData);
         GMEM_Free(AttributeValueEncoded.pData);
	     return(RV_MALLOC_FAILED);
      }

      pOutBloc->pData[0] = ESCAPE_CHAR;
      memcpy(&(pOutBloc->pData[1]),
                AttributeTypeEncoded.pData,
                AttributeTypeEncoded.usLen);
      memcpy(&(pOutBloc->pData[1 + AttributeTypeEncoded.usLen]),
                AttributeValueEncoded.pData,
                AttributeValueEncoded.usLen);

      GMEM_Free(AttributeTypeEncoded.pData);
      GMEM_Free(AttributeValueEncoded.pData);
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_Validity(BLOC *pInBloc,
*                        BLOC *pOutBloc
*                       )
*
* Description : Encode une donne de type Validity.
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : Un octet de contrle (en dbut du rsultat) indique les formats
*               des deux parties notBefore et notAfter.
*               
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_Validity(BLOC *pInBloc,
                       BLOC *pOutBloc
                      )

{
   ASN1
      notBeforePart,
      notAfterPart;
   BLOC
      notBeforeEncoded,
      notAfterEncoded;
   BYTE
      notBeforeFormat,
      notAfterFormat,
      *pCurrent;
   int
      rv;


   /* Dcomposition                                                           */
   
   pCurrent = pInBloc->pData;

   notBeforePart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&notBeforePart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = notBeforePart.Content.pData + notBeforePart.Content.usLen;

   notAfterPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&notAfterPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = notAfterPart.Content.pData + notAfterPart.Content.usLen;


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

   pOutBloc->usLen = 1;

   rv = CC_Encode_UTCTime(&notBeforePart.Content, &notBeforeEncoded, &notBeforeFormat);
   if (rv != RV_SUCCESS) return rv;
   pOutBloc->usLen += notBeforeEncoded.usLen;

   rv = CC_Encode_UTCTime(&notAfterPart.Content, &notAfterEncoded, &notAfterFormat);
   if (rv != RV_SUCCESS)
   {
	   GMEM_Free(notBeforeEncoded.pData);
	   return rv;
   }
   pOutBloc->usLen += notAfterEncoded.usLen;


   /* Reconstruction  partir des composants                                  */

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      GMEM_Free(notBeforeEncoded.pData); 
	  GMEM_Free(notAfterEncoded.pData);
	  return(RV_MALLOC_FAILED);
   }

   pCurrent = pOutBloc->pData;

   *pCurrent = (notBeforeFormat << 4) + notAfterFormat;
   pCurrent++;

   memcpy(pCurrent, notBeforeEncoded.pData, notBeforeEncoded.usLen);
   GMEM_Free(notBeforeEncoded.pData); 
   pCurrent += notBeforeEncoded.usLen;

   memcpy(pCurrent, notAfterEncoded.pData, notAfterEncoded.usLen);
   GMEM_Free(notAfterEncoded.pData); 
   pCurrent += notAfterEncoded.usLen;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_UTCTime(BLOC *pInBloc,
*                       BLOC *pOutBloc,
*                       BYTE *pFormat
*                      )
*
* Description : Encode une donne de type UTCTime.
*               Suivant le format dtect, l'encodage consiste en :
*                - sur 32 bits : le nombre de minutes ou de secondes depuis une
*                                date de rfrence.
*                - sur 16 bits : le nombre de minutes de dcalage UTC
*                                s'il y a lieu.
*
* Remarks     : 
*               
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pFormat : indique au quel format tait la donne d'entre
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_UTCTime(BLOC *pInBloc,
                      BLOC *pOutBloc,
                      BYTE *pFormat
                     )

{
   BYTE
      *pData;
   ULONG
      ulNbMinute,
      ulNbSecond;
   USHORT
      usNbDeltaMinute,
      usYear,
      usMonth,
      usDay,
      usHour,
      usMinute,
      usSecond,
      usDeltaHour,
      usDeltaMinute,
      usDayInYear;


   pData = pInBloc->pData;


   /* Calcul du nombre de minutes                                             */

   usYear   = 10 * (pData[0] - '0') + (pData[1] - '0');
   usMonth  = 10 * (pData[2] - '0') + (pData[3] - '0');
   usDay    = 10 * (pData[4] - '0') + (pData[5] - '0');
   usHour   = 10 * (pData[6] - '0') + (pData[7] - '0');
   usMinute = 10 * (pData[8] - '0') + (pData[9] - '0');

   ASSERT((usYear >= 0) && (usYear <= 99));
   ASSERT((usMonth >= 1) && (usMonth <= 12));
   ASSERT((usDay >= 1) && (usDay <= 31));
   ASSERT((usHour >= 0) && (usHour <= 23));
   ASSERT((usMinute >= 0) && (usMinute <= 59));

   /* Le nombre de jours dans l'anne vaut 0 le 1er janvier                   */

   usDayInYear = NbDaysInMonth[usMonth - 1] + (usDay - 1);
   if (((usYear % 4) == 0) && (usMonth >= 3)) usDayInYear++;

   /* L'anne 00 est compte bissextile ci-dessous                            */
   /* L'anne courante si elle l'est a dj t compte dans usDayInYear      */

	/*
	Problme sur l'valuation de (usYear - 1) / 4 :
				usYear = 8 -> 1
				usYear = 4 -> 0
				usYear = 0 -> 0 !!

	ulNbMinute = usYear * UTCT_MINUTE_IN_YEAR
              + (1 + (usYear - 1) / 4) * UTCT_MINUTE_IN_DAY
              + usDayInYear * UTCT_MINUTE_IN_DAY
              + usHour * UTCT_MINUTE_IN_HOUR
              + usMinute;
	*/

   ulNbMinute = usYear * UTCT_MINUTE_IN_YEAR
              + (usYear + 3) / 4 * UTCT_MINUTE_IN_DAY		// Annes bissextiles
              + usDayInYear * UTCT_MINUTE_IN_DAY
              + usHour * UTCT_MINUTE_IN_HOUR
              + usMinute;


   /* Le format et la suite des calculs en fonction de la longueur            */

   switch(pInBloc->usLen)
   {
   case 11 :
      *pFormat = UTCT_YYMMDDhhmmZ;

      ASSERT(pData[10] == 'Z');

      pOutBloc->usLen = 4;
      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }
      *(ULONG *)pOutBloc->pData = ulNbMinute;

      break;

   case 13 :
      *pFormat = UTCT_YYMMDDhhmmssZ;

      usSecond = 10 * (pData[10] - '0') + (pData[11] - '0');
      ASSERT((usSecond >= 0) && (usSecond <= 59));
      ASSERT(pData[12] == 'Z');

      ulNbSecond = 60 * ulNbMinute + usSecond;
      
      pOutBloc->usLen = 4;
      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }
      *(ULONG *)pOutBloc->pData = ulNbSecond;

      break;

   case 15 :
      if (pData[10] == '+')
      {
         *pFormat = UTCT_YYMMDDhhmmphhmm;
      }
      else if (pData[10] == '-')
      {
         *pFormat = UTCT_YYMMDDhhmmmhhmm;
      }
      else
      {
         return(RV_INVALID_DATA);
      }

      usDeltaHour   = 10 * (pData[11] - '0') + (pData[12] - '0');
      usDeltaMinute = 10 * (pData[13] - '0') + (pData[14] - '0');
      ASSERT((usDeltaHour >= 0) && (usDeltaHour <= 23));
      ASSERT((usDeltaMinute >= 0) && (usDeltaMinute <= 59));

      usNbDeltaMinute = 60 * usDeltaHour + usDeltaMinute;
      
      pOutBloc->usLen = 4 + 2;
      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }
      *(ULONG *)pOutBloc->pData = ulNbMinute;
      *(USHORT *)(pOutBloc->pData + sizeof(ulNbMinute)) = usNbDeltaMinute;

      break;

   case 17 :
      if (pData[12] == '+')
      {
         *pFormat = UTCT_YYMMDDhhmmphhmm;
      }
      else if (pData[12] == '-')
      {
         *pFormat = UTCT_YYMMDDhhmmmhhmm;
      }
      else
      {
         return(RV_INVALID_DATA);
      }

      usSecond = 10 * (pData[10] - '0') + (pData[11] - '0');
      ASSERT((usSecond >= 0) && (usSecond <= 59));

      ulNbSecond = 60 * ulNbMinute + usSecond;
      
      usDeltaHour   = 10 * (pData[13] - '0') + (pData[14] - '0');
      usDeltaMinute = 10 * (pData[15] - '0') + (pData[16] - '0');
      ASSERT((usDeltaHour >= 0) && (usDeltaHour <= 23));
      ASSERT((usDeltaMinute >= 0) && (usDeltaMinute <= 59));

      usNbDeltaMinute = 60 * usDeltaHour + usDeltaMinute;
      
      pOutBloc->usLen = 4 + 2;
      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }
      *(ULONG *)pOutBloc->pData = ulNbSecond;
      *(USHORT *)(pOutBloc->pData + sizeof(ulNbSecond)) = usNbDeltaMinute;

      break;

   default :
      return(RV_INVALID_DATA);
   }

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_SubjectPKInfo(BLOC *pInBloc,
*                             BLOC *pOutBloc
*                            )
*
* Description : Encode une donne de type SubjectPublicKeyInfo.
*               Ceci consiste en l'clatement en ses diffrents composants,
*               leurs dsenrobages Asn1 et leurs encodages respectifs, et la
*               concatnation de ces rsultats.
*
* Remarks     : 
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_SubjectPKInfo(BLOC *pInBloc,
                            BLOC *pOutBloc
                           )

{
   ASN1
      algorithmPart,
      subjectPKPart;
   BLOC
      algorithmEncoded,
      subjectPKEncoded;
   BYTE
//      *pData,
      *pCurrent;
   int
      rv;


   /* Dcomposition du SubjectPKInfo en ses diffrents composants             */
   
   pCurrent = pInBloc->pData;

   algorithmPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&algorithmPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = algorithmPart.Content.pData + algorithmPart.Content.usLen;

   subjectPKPart.Asn1.pData = pCurrent;
   rv = CC_ExtractContent(&subjectPKPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = subjectPKPart.Content.pData + subjectPKPart.Content.usLen;


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

   pOutBloc->usLen = 0;

   rv = CC_Encode_AlgorithmIdentifier(&algorithmPart.Content, &algorithmEncoded);
   if (rv != RV_SUCCESS) return rv;
   pOutBloc->usLen += algorithmEncoded.usLen;

#ifdef _TRICKY_COMPRESSION
	/* Ne pas faire le RawEncode permet de gagner l'octet 0xFF et ventuellement plus */
#ifdef _OPT_HEADER
	if (subjectPKPart.Content.usLen < 0x80)
	{
		if ((pData = GMEM_Alloc(pInBloc->usLen + 1)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}
		else
		{
			pData[0] = subjectPKPart.Content.usLen;
			memcpy(&pData[1],
					 subjectPKPart.Content.pData,
					 subjectPKPart.Content.usLen);

			subjectPKEncoded.usLen = subjectPKPart.Content.usLen + 1;
			subjectPKEncoded.pData = pData;
		}
		pOutBloc->usLen += subjectPKEncoded.usLen;
	}
	else
	{
		if ((pData = GMEM_Alloc(pInBloc->usLen + 2)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}
		else
		{
			pData[0] = 0x80 | (subjectPKPart.Content.usLen >> 8);
			pData[1] = subjectPKPart.Content.usLen & 0x00FF;
			memcpy(&pData[2],
					 subjectPKPart.Content.pData,
					 subjectPKPart.Content.usLen);

			subjectPKEncoded.usLen = subjectPKPart.Content.usLen + 2;
			subjectPKEncoded.pData = pData;
		} 
		pOutBloc->usLen += subjectPKEncoded.usLen;
	}
#else	/* _OPT_HEADER */
	if ((pData = GMEM_Alloc(pInBloc->usLen + 2)) == NULL_PTR)
	{
		return(RV_MALLOC_FAILED);
	}
	else
	{
		pData[0] = subjectPKPart.Content.usLen >> 8;
		pData[1] = subjectPKPart.Content.usLen & 0x00FF;
		memcpy(&pData[2],
				 subjectPKPart.Content.pData,
				 subjectPKPart.Content.usLen);

		subjectPKEncoded.usLen = subjectPKPart.Content.usLen + 2;
		subjectPKEncoded.pData = pData;
	} 
	pOutBloc->usLen += subjectPKEncoded.usLen;
#endif
#else /* _TRICKY_COMPRESSION */
   rv = CC_RawEncode(&subjectPKPart.Content, &subjectPKEncoded, FALSE);
   if (rv != RV_SUCCESS)
   {
	   GMEM_Free(algorithmEncoded.pData);
	   return rv;
   }
   pOutBloc->usLen += subjectPKEncoded.usLen;
#endif


   /* Reconstruction  partir des composants                                  */

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      GMEM_Free(algorithmEncoded.pData); 
	  GMEM_Free(subjectPKEncoded.pData);
	  return(RV_MALLOC_FAILED);
   }

   pCurrent = pOutBloc->pData;

   memcpy(pCurrent, algorithmEncoded.pData, algorithmEncoded.usLen);
   GMEM_Free(algorithmEncoded.pData); 
   pCurrent += algorithmEncoded.usLen;

   memcpy(pCurrent, subjectPKEncoded.pData, subjectPKEncoded.usLen);
   GMEM_Free(subjectPKEncoded.pData); 
   pCurrent += subjectPKEncoded.usLen;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_UniqueIdentifier(BLOC *pInBloc,
*                                BLOC *pOutBloc
*                               )
*
* Description : Encode une donne de type UniqueIdentifier.
*               Ceci consiste seulement en l'encodage brute (CC_RawEncode) de la
*               donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_UniqueIdentifier(BLOC *pInBloc,
                               BLOC *pOutBloc
                              )

{
   int
      rv;


   rv = CC_RawEncode(pInBloc, pOutBloc, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_Extensions(BLOC *pInBloc,
*                          BLOC *pOutBloc
*                         )
*
* Description : Encode une donne de type Extensions.
*               Ceci consiste seulement en l'encodage brute (CC_RawEncode) de la
*               donne d'entre.
*
* Remarks     : Un dsenrobage supplmentaire (context specific) est requis. 
*               Un octet de contrle (en dbut du rsultat) indique le nombre
*               de Extension dont est compos le Extensions.
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_Extensions(BLOC *pInBloc,
                         BLOC *pOutBloc
                        )

{
   ASN1
      ExtensionPart[MAX_EXTENSION],
      InInAsn1;
   BLOC
      ExtensionEncoded[MAX_EXTENSION],
      *pInInBloc;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      i,
      usNbExtension;


   /* On enlve l'enrobage 'context specific' supplmentaire                  */
   /* et on travaille avec pInInBloc au lieu de pInBloc                       */

   InInAsn1.Asn1.pData = pInBloc->pData;
   rv = CC_ExtractContent(&InInAsn1);
   if (rv != RV_SUCCESS) return rv;

   pInInBloc = &(InInAsn1.Content);

   
   /* Dcomposition de Extensions en ses diffrents Extension                 */

   pCurrent = pInInBloc->pData;
   usNbExtension = 0;

   while (pCurrent < pInInBloc->pData + pInInBloc->usLen)
   {
      ExtensionPart[usNbExtension].Asn1.pData = pCurrent;
      rv = CC_ExtractContent(&(ExtensionPart[usNbExtension]));
      if (rv != RV_SUCCESS) return rv;
      pCurrent = ExtensionPart[usNbExtension].Content.pData
               + ExtensionPart[usNbExtension].Content.usLen;
      usNbExtension++;
   }

   ASSERT(pCurrent == pInInBloc->pData + pInInBloc->usLen);


   /* Encodages des diffrents composants et calcul de la longueur ncessaire */

   for (i = 0; i < usNbExtension; i++)
   {
	   ExtensionEncoded[i].pData = NULL;
   }

   pOutBloc->usLen = 1;
   for (i = 0; i < usNbExtension; i++)
   {
      rv = CC_Encode_Extension(&ExtensionPart[i].Content, &ExtensionEncoded[i]);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += ExtensionEncoded[i].usLen;
   }
   

   /* Reconstruction  partir des composants                                  */

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   *pCurrent = (BYTE) usNbExtension;
   pCurrent++;

   for (i = 0; i < usNbExtension; i++)
   {
      memcpy(pCurrent, ExtensionEncoded[i].pData, ExtensionEncoded[i].usLen);
      GMEM_Free(ExtensionEncoded[i].pData); 
      pCurrent += ExtensionEncoded[i].usLen;
   }

   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbExtension; i++)
   {
      GMEM_Free(ExtensionEncoded[i].pData);
   }

   return(rv);
}


/*******************************************************************************
* int CC_Encode_Extension(BLOC *pInBloc,
*                         BLOC *pOutBloc
*                        )
*
* Description : Encode une donne de type Extension.
*               Ceci consiste seulement en l'encodage brute (CC_RawEncode) de la
*               donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_Extension(BLOC *pInBloc,
                        BLOC *pOutBloc
                       )

{
   int
      rv;


   rv = CC_RawEncode(pInBloc, pOutBloc, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Encode_Signature(BLOC *pInBloc,
*                         BLOC *pOutBloc
*                        )
*
* Description : Encode la signature du certificat.
*               Ceci consiste seulement en l'encodage brute (CC_RawEncode) de la
*               donne d'entre.
*
* Remarks     : On peut viter de tenter de compresser (CC_RawEncode) si on
*               estime que cela ne sera pas efficace (donne alatoire).
*               Cela permet de gagner un octet (0xFF) pour les donnes de taille
*               suprieure  30 octets (cas gnral).
*
* In          : pInBloc : la partie  encoder (champ Content)
*
* Out         : pOutBloc : l'encod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Encode_Signature(BLOC *pInBloc,
                        BLOC *pOutBloc
                       )

{
//	BYTE
//		*pData;
   int
      rv;


#ifdef _TRICKY_COMPRESSION
	/* Ne pas faire le RawEncode permet de gagner l'octet 0xFF */
#ifdef _OPT_HEADER
	if (pInBloc->usLen < 0x80)
	{
		if ((pData = GMEM_Alloc(pInBloc->usLen + 1)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}
		else
		{
			pData[0] = pInBloc->usLen;
			memcpy(&pData[1], pInBloc->pData, pInBloc->usLen);

			pOutBloc->usLen = pInBloc->usLen + 1;
			pOutBloc->pData = pData;
		}
	}
	else
	{
		if ((pData = GMEM_Alloc(pInBloc->usLen + 2)) == NULL_PTR)
		{
			return(RV_MALLOC_FAILED);
		}
		else
		{
			pData[0] = 0x80 | (pInBloc->usLen >> 8);
			pData[1] = pInBloc->usLen & 0x00FF;
			memcpy(&pData[2], pInBloc->pData, pInBloc->usLen);

			pOutBloc->usLen = pInBloc->usLen + 2;
			pOutBloc->pData = pData;
		}
	}
#else	/* _OPT_HEADER */
	if ((pData = GMEM_Alloc(pInBloc->usLen + 2)) == NULL_PTR)
	{
		return(RV_MALLOC_FAILED);
	}
	else
	{
		pData[0] = pInBloc->usLen >> 8;
		pData[1] = pInBloc->usLen & 0x00FF;
		memcpy(&pData[2], pInBloc->pData, pInBloc->usLen);

		pOutBloc->usLen = pInBloc->usLen + 2;
		pOutBloc->pData = pData;
	}
#endif
#else	/* _TRICKY_COMPRESSION */
   rv = CC_RawEncode(pInBloc, pOutBloc, TRUE);
   if (rv != RV_SUCCESS) return rv;
#endif

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Decode_TBSCertificate(BYTE    *pInData,
*                              BLOC    *pOutBloc,
*                              USHORT  *pLength
*                             )
*
* Description : Dcode une donne de type TBSCertificate.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : 
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_TBSCertificate(BYTE    *pInData,
                             BLOC    *pOutBloc,
                             USHORT  *pLength
                            )

{
   ASN1
      serialNumberPart,
      signaturePart,
      issuerPart,
      validityPart,
      subjectPart,
      subjectPKInfoPart,
      issuerUIDPart,
      subjectUIDPart,
      extensionsPart;
   BOOL
      bVersionPresent,
      bIssuerUIDPresent,
      bSubjectUIDPresent,
      bExtensionsPresent;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      usVersion = 0,
      Length;

   serialNumberPart.Asn1.pData  = NULL;
   signaturePart.Asn1.pData     = NULL;
   issuerPart.Asn1.pData        = NULL;
   validityPart.Asn1.pData      = NULL;
   subjectPart.Asn1.pData       = NULL;
   subjectPKInfoPart.Asn1.pData = NULL;
   issuerUIDPart.Asn1.pData     = NULL;
   subjectUIDPart.Asn1.pData    = NULL;
   extensionsPart.Asn1.pData    = NULL;


   pCurrent = pInData;
   
   bVersionPresent = ((*pCurrent & 0x80) != 0);
   bIssuerUIDPresent = ((*pCurrent & 0x40) != 0);
   bSubjectUIDPresent = ((*pCurrent & 0x20) != 0);
   bExtensionsPresent = ((*pCurrent & 0x10) != 0);
   usVersion = *pCurrent & 0x03;
   pCurrent++;

   rv = CC_Decode_CertificateSerialNumber(pCurrent, &(serialNumberPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   serialNumberPart.Tag = TAG_INTEGER;
   rv = CC_BuildAsn1(&serialNumberPart);
   GMEM_Free(serialNumberPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_AlgorithmIdentifier(pCurrent, &(signaturePart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   signaturePart.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&signaturePart);
   GMEM_Free(signaturePart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_Name(pCurrent, &(issuerPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   issuerPart.Tag = TAG_SEQUENCE_OF;
   rv = CC_BuildAsn1(&issuerPart);
   GMEM_Free(issuerPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_Validity(pCurrent, &(validityPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   validityPart.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&validityPart);
   GMEM_Free(validityPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_Name(pCurrent, &(subjectPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   subjectPart.Tag = TAG_SEQUENCE_OF;
   rv = CC_BuildAsn1(&subjectPart);
   GMEM_Free(subjectPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_SubjectPKInfo(pCurrent, &(subjectPKInfoPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   subjectPKInfoPart.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&subjectPKInfoPart);
   GMEM_Free(subjectPKInfoPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   if (bIssuerUIDPresent == TRUE)
   {
      rv = CC_Decode_UniqueIdentifier(pCurrent, &(issuerUIDPart.Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      issuerUIDPart.Tag = TAG_OPTION_ISSUER_UID;
      rv = CC_BuildAsn1(&issuerUIDPart);
      GMEM_Free(issuerUIDPart.Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pCurrent += Length;
   }

   if (bSubjectUIDPresent == TRUE)
   {
      rv = CC_Decode_UniqueIdentifier(pCurrent, &(subjectUIDPart.Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      subjectUIDPart.Tag = TAG_OPTION_SUBJECT_UID;
      rv = CC_BuildAsn1(&subjectUIDPart);
      GMEM_Free(subjectUIDPart.Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pCurrent += Length;
   }

   if (bExtensionsPresent == TRUE)
   {
      rv = CC_Decode_Extensions(pCurrent, &(extensionsPart.Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      extensionsPart.Tag = TAG_OPTION_EXTENSIONS;
      rv = CC_BuildAsn1(&extensionsPart);
      GMEM_Free(extensionsPart.Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pCurrent += Length;
   }

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


   /* Calcul de la longueur du tbsCertificate dcod et allocation            */
   
   pOutBloc->usLen = (bVersionPresent ? 5 : 0)
                   + serialNumberPart.Asn1.usLen
                   + signaturePart.Asn1.usLen
                   + issuerPart.Asn1.usLen
                   + validityPart.Asn1.usLen
                   + subjectPart.Asn1.usLen
                   + subjectPKInfoPart.Asn1.usLen
                   + (bIssuerUIDPresent ? issuerUIDPart.Asn1.usLen : 0)
                   + (bSubjectUIDPresent ? subjectUIDPart.Asn1.usLen : 0)
                   + (bExtensionsPresent ? extensionsPart.Asn1.usLen : 0);

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }


   /* Reconstruction du tbsCertificate dcod                                 */
   
   pCurrent = pOutBloc->pData;

   if (bVersionPresent == TRUE)
   {
      pCurrent[0] = TAG_OPTION_VERSION;
      pCurrent[1] = 0x03;
      pCurrent[2] = 0x02;
      pCurrent[3] = 0x01;
      pCurrent[4] = (BYTE)usVersion;
      pCurrent += 5;
   }

   memcpy(pCurrent, serialNumberPart.Asn1.pData, serialNumberPart.Asn1.usLen);
   GMEM_Free(serialNumberPart.Asn1.pData);
   pCurrent += serialNumberPart.Asn1.usLen;

   memcpy(pCurrent, signaturePart.Asn1.pData, signaturePart.Asn1.usLen);
   GMEM_Free(signaturePart.Asn1.pData);
   pCurrent += signaturePart.Asn1.usLen;

   memcpy(pCurrent, issuerPart.Asn1.pData, issuerPart.Asn1.usLen);
   GMEM_Free(issuerPart.Asn1.pData);
   pCurrent += issuerPart.Asn1.usLen;

   memcpy(pCurrent, validityPart.Asn1.pData, validityPart.Asn1.usLen);
   GMEM_Free(validityPart.Asn1.pData);
   pCurrent += validityPart.Asn1.usLen;

   memcpy(pCurrent, subjectPart.Asn1.pData, subjectPart.Asn1.usLen);
   GMEM_Free(subjectPart.Asn1.pData);
   pCurrent += subjectPart.Asn1.usLen;

   memcpy(pCurrent, subjectPKInfoPart.Asn1.pData, subjectPKInfoPart.Asn1.usLen);
   GMEM_Free(subjectPKInfoPart.Asn1.pData);
   pCurrent += subjectPKInfoPart.Asn1.usLen;

   if (bIssuerUIDPresent == TRUE)
   {
      memcpy(pCurrent, issuerUIDPart.Asn1.pData, issuerUIDPart.Asn1.usLen);
      GMEM_Free(issuerUIDPart.Asn1.pData);
      pCurrent += issuerUIDPart.Asn1.usLen;
   }

   if (bSubjectUIDPresent == TRUE)
   {
      memcpy(pCurrent, subjectUIDPart.Asn1.pData, subjectUIDPart.Asn1.usLen);
      GMEM_Free(subjectUIDPart.Asn1.pData);
      pCurrent += subjectUIDPart.Asn1.usLen;
   }

   if (bExtensionsPresent == TRUE)
   {
      memcpy(pCurrent, extensionsPart.Asn1.pData, extensionsPart.Asn1.usLen);
      GMEM_Free(extensionsPart.Asn1.pData);
      pCurrent += extensionsPart.Asn1.usLen;
   }

   return(RV_SUCCESS);

err:
   GMEM_Free(serialNumberPart.Asn1.pData);
   GMEM_Free(signaturePart.Asn1.pData);
   GMEM_Free(issuerPart.Asn1.pData);
   GMEM_Free(validityPart.Asn1.pData);
   GMEM_Free(subjectPart.Asn1.pData);
   GMEM_Free(subjectPKInfoPart.Asn1.pData);
   GMEM_Free(issuerUIDPart.Asn1.pData);
   GMEM_Free(subjectUIDPart.Asn1.pData);
   GMEM_Free(extensionsPart.Asn1.pData);

   return (rv);
}


/*******************************************************************************
* int CC_Decode_CertificateSerialNumber(BYTE    *pInData,
*                                       BLOC    *pOutBloc,
*                                       USHORT  *pLength
*                                      )
*
* Description : Dcode une donne de type CertificateSerialNumber.
*               Ceci consiste seulement en le dcodage brute (CC_RawDecode) de
*               la donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_CertificateSerialNumber(BYTE    *pInData,
                                      BLOC    *pOutBloc,
                                      USHORT  *pLength
                                     )

{
   int
      rv;


   rv = CC_RawDecode(pInData, pOutBloc, pLength, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Decode_AlgorithmIdentifier(BYTE    *pInData,
*                                   BLOC    *pOutBloc,
*                                   USHORT  *pLength
*                                  )
*
* Description : Dcode une donne de type AlgorithmIdentifier.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_AlgorithmIdentifier(BYTE    *pInData,
                                  BLOC    *pOutBloc,
                                  USHORT  *pLength
                                 )

{
    ASN1
        AlgorithmPart,
        ParametersPart;
    BOOL
        bNullParam = FALSE,
        bNoParam   = FALSE;
    int
        rv;
    USHORT
        AlgoIndex,
        Length;

    AlgorithmPart.Asn1.pData  = NULL;
    ParametersPart.Asn1.pData = NULL;

    if (pInData[0] == ESCAPE_CHAR)
    {
        rv = CC_RawDecode(&pInData[1], pOutBloc, &Length, TRUE);
        *pLength = 1 + Length;
    }
    else
    {
        if (pInData[0] == ABSENT_PARAMETER_CHAR)
        {
            bNoParam   = TRUE;
            bNullParam = FALSE;
            AlgoIndex  = pInData[1];
        }
        else
        {
            bNoParam   = ((pInData[0] & 0x80) != 0);
            bNullParam = bNoParam;
            AlgoIndex  = pInData[0] & 0x7F;
        }

        if (bNoParam == TRUE)
        {
            AlgorithmPart.Content.usLen = (USHORT)strlen(AlgorithmTypeDict[AlgoIndex]);
            if ((AlgorithmPart.Content.pData = GMEM_Alloc(AlgorithmPart.Content.usLen)) == NULL_PTR)
            {
                return (RV_MALLOC_FAILED);
            }
            memcpy(AlgorithmPart.Content.pData,
                   AlgorithmTypeDict[AlgoIndex],
                   AlgorithmPart.Content.usLen);

            AlgorithmPart.Tag = TAG_OBJECT_IDENTIFIER;
            rv = CC_BuildAsn1(&AlgorithmPart);
            GMEM_Free(AlgorithmPart.Content.pData);
            if (rv != RV_SUCCESS) goto err;

            if (bNullParam == FALSE)
            {
                pOutBloc->usLen = AlgorithmPart.Asn1.usLen;
                if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
                {
                    rv = RV_MALLOC_FAILED;
                    goto err;
                }

                memcpy(pOutBloc->pData, AlgorithmPart.Asn1.pData, AlgorithmPart.Asn1.usLen);

                *pLength = 2;

                GMEM_Free(AlgorithmPart.Asn1.pData);
            }
            else
            {
                pOutBloc->usLen = AlgorithmPart.Asn1.usLen + 2;
                if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
                {
                    rv = RV_MALLOC_FAILED;
                    goto err;
                }

                memcpy(pOutBloc->pData, AlgorithmPart.Asn1.pData, AlgorithmPart.Asn1.usLen);

                pOutBloc->pData[AlgorithmPart.Asn1.usLen]   = 0x05;
                pOutBloc->pData[AlgorithmPart.Asn1.usLen+1] = 0x00;

                *pLength = 1;

                GMEM_Free(AlgorithmPart.Asn1.pData);

            }
        }
        else
        {
            AlgorithmPart.Content.usLen = (USHORT)strlen(AlgorithmTypeDict[AlgoIndex]);
            if ((AlgorithmPart.Content.pData = GMEM_Alloc(AlgorithmPart.Content.usLen)) == NULL_PTR)
            {
                return (RV_MALLOC_FAILED);
            }
            memcpy(AlgorithmPart.Content.pData,
                   AlgorithmTypeDict[AlgoIndex],
                   AlgorithmPart.Content.usLen);

            AlgorithmPart.Tag = TAG_OBJECT_IDENTIFIER;
            rv = CC_BuildAsn1(&AlgorithmPart);
            GMEM_Free(AlgorithmPart.Content.pData);
            if (rv != RV_SUCCESS) goto err;

            /* On recupre directement l'asn1 des paramtres                     */
            rv = CC_RawDecode(&pInData[1], &(ParametersPart.Asn1), &Length, TRUE);
            if (rv != RV_SUCCESS) goto err;

            pOutBloc->usLen = AlgorithmPart.Asn1.usLen + ParametersPart.Asn1.usLen;
            if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
            {
                rv = RV_MALLOC_FAILED;
                goto err;
            }
            memcpy(pOutBloc->pData,
                   AlgorithmPart.Asn1.pData,
                   AlgorithmPart.Asn1.usLen);
            memcpy(pOutBloc->pData + AlgorithmPart.Asn1.usLen,
                   ParametersPart.Asn1.pData,
                   ParametersPart.Asn1.usLen);

            *pLength = 1 + Length;

            GMEM_Free(AlgorithmPart.Asn1.pData);
            GMEM_Free(ParametersPart.Asn1.pData);
        }
    }

    return (RV_SUCCESS);

    err:
    GMEM_Free(AlgorithmPart.Asn1.pData);
    GMEM_Free(ParametersPart.Asn1.pData);

    return rv;
}


/*******************************************************************************
* int CC_Decode_Name(BYTE    *pInData,
*                    BLOC    *pOutBloc,
*                    USHORT  *pLength
*                   )
*
* Description : Dcode une donne de type Name.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_Name(BYTE    *pInData,
                   BLOC    *pOutBloc,
                   USHORT  *pLength
                  )

{
   ASN1
      RDN[MAX_RDN];
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      i,
      usNbRDN,
      Length;


   /* Dcodage des diffrents composants et calcul de la longueur ncessaire  */

   pCurrent = pInData;
   pOutBloc->usLen = 0;
   
   usNbRDN = (USHORT) *pCurrent;
   pCurrent++;
   
   for (i = 0; i < usNbRDN; i++)
   {
	  RDN[i].Asn1.pData = NULL;
   }


   for (i = 0; i < usNbRDN; i++)
   {
      rv = CC_Decode_RDN(pCurrent, &(RDN[i].Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      RDN[i].Tag = TAG_SET_OF;
      rv = CC_BuildAsn1(&RDN[i]);
      GMEM_Free(RDN[i].Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += RDN[i].Asn1.usLen;
      pCurrent += Length;
   }

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


   /* Reconstruction du Name dcod                                           */
   
   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   for (i = 0; i < usNbRDN; i++)
   {
      memcpy(pCurrent, RDN[i].Asn1.pData, RDN[i].Asn1.usLen);
      GMEM_Free(RDN[i].Asn1.pData);
      pCurrent += RDN[i].Asn1.usLen;
   }

   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbRDN; i++)
   {
	   GMEM_Free(RDN[i].Asn1.pData);
   }

   return rv;
}


/*******************************************************************************
* int CC_Decode_RDN(BYTE    *pInData,
*                   BLOC    *pOutBloc,
*                   USHORT  *pLength
*                  )
*
* Description : Dcode une donne de type RelativeDistinguishedName.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_RDN(BYTE    *pInData,
                  BLOC    *pOutBloc,
                  USHORT  *pLength
                 )

{
   ASN1
      AVA[MAX_AVA];
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      i,
      usNbAVA,
      Length;


   /* Dcodage des diffrents composants et calcul de la longueur ncessaire  */

   pCurrent = pInData;
   pOutBloc->usLen = 0;
   
   usNbAVA = *pCurrent;
   pCurrent++;
   
   for (i = 0; i < usNbAVA; i++)
   {
	  AVA[i].Asn1.pData = NULL;
   }
	  
   for (i = 0; i < usNbAVA; i++)
   {
      rv = CC_Decode_AVA(pCurrent, &(AVA[i].Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      AVA[i].Tag = TAG_SEQUENCE;
      rv = CC_BuildAsn1(&AVA[i]);
      GMEM_Free(AVA[i].Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pOutBloc->usLen += AVA[i].Asn1.usLen;
      pCurrent += Length;
   }

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


   /* Reconstruction du Name dcod                                           */
   
   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = pOutBloc->pData;

   for (i = 0; i < usNbAVA; i++)
   {
      memcpy(pCurrent, AVA[i].Asn1.pData, AVA[i].Asn1.usLen);
      GMEM_Free(AVA[i].Asn1.pData);
      pCurrent += AVA[i].Asn1.usLen;
   }

   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbAVA; i++)
   {  
      GMEM_Free(AVA[i].Asn1.pData);
   }

   return rv;
}


/*******************************************************************************
* int CC_Decode_AVA(BYTE    *pInData,
*                   BLOC    *pOutBloc,
*                   USHORT  *pLength
*                  )
*
* Description : Dcode une donne de type AttributeValueAssertion.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_AVA(BYTE    *pInData,
                  BLOC    *pOutBloc,
                  USHORT  *pLength
                 )

{
   ASN1
      AttributeTypePart,
      AttributeValuePart;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      AttributeTypeIndex,
      Length;

   AttributeTypePart.Asn1.pData  = NULL;
   AttributeValuePart.Asn1.pData = NULL;
   
   if (pInData[0] == ESCAPE_CHAR)
   {
      pCurrent = &pInData[1];

      rv = CC_RawDecode(pCurrent, &(AttributeTypePart.Content), &Length, TRUE);
      if (rv != RV_SUCCESS) goto err;
      AttributeTypePart.Tag = TAG_OBJECT_IDENTIFIER;
      rv = CC_BuildAsn1(&AttributeTypePart);
      GMEM_Free(AttributeTypePart.Content.pData);
      if (rv != RV_SUCCESS) goto err;
      pCurrent += Length;

      /* Ce que l'on dcode contient dj l'enrobage                          */
      rv = CC_RawDecode(pCurrent, &(AttributeValuePart.Asn1), &Length, TRUE);
      if (rv != RV_SUCCESS) goto err;
      pCurrent += Length;

      *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


      pOutBloc->usLen = AttributeTypePart.Asn1.usLen
                      + AttributeValuePart.Asn1.usLen;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         rv = RV_MALLOC_FAILED;
		 goto err;
      }

      pCurrent = pOutBloc->pData;

      memcpy(pCurrent, AttributeTypePart.Asn1.pData, AttributeTypePart.Asn1.usLen);
      GMEM_Free(AttributeTypePart.Asn1.pData);
      pCurrent += AttributeTypePart.Asn1.usLen;

      memcpy(pCurrent, AttributeValuePart.Asn1.pData, AttributeValuePart.Asn1.usLen);
      GMEM_Free(AttributeValuePart.Asn1.pData);
      pCurrent += AttributeValuePart.Asn1.usLen;
   }
   else
   {
      AttributeTypeIndex = pInData[0];

      AttributeTypePart.Content.usLen = (USHORT)strlen(AttributeTypeDict[AttributeTypeIndex]);
      if ((AttributeTypePart.Content.pData = GMEM_Alloc(AttributeTypePart.Content.usLen))
           == NULL_PTR)
      {
         rv = RV_MALLOC_FAILED;
		 goto err;
      }
      memcpy(AttributeTypePart.Content.pData,
                AttributeTypeDict[AttributeTypeIndex],
                AttributeTypePart.Content.usLen);

      AttributeTypePart.Tag = TAG_OBJECT_IDENTIFIER;
      rv = CC_BuildAsn1(&AttributeTypePart);
      GMEM_Free(AttributeTypePart.Content.pData);
      if (rv != RV_SUCCESS) goto err;

      rv = CC_RawDecode(&pInData[1], &(AttributeValuePart.Asn1), &Length, TRUE);
      if (rv != RV_SUCCESS) goto err;

      pOutBloc->usLen = AttributeTypePart.Asn1.usLen
                      + AttributeValuePart.Asn1.usLen;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         rv = RV_MALLOC_FAILED;
		 goto err;
      }

      pCurrent = pOutBloc->pData;

      memcpy(pCurrent, AttributeTypePart.Asn1.pData, AttributeTypePart.Asn1.usLen);
      GMEM_Free(AttributeTypePart.Asn1.pData);
      pCurrent += AttributeTypePart.Asn1.usLen;

      memcpy(pCurrent, AttributeValuePart.Asn1.pData, AttributeValuePart.Asn1.usLen);
      GMEM_Free(AttributeValuePart.Asn1.pData);
      pCurrent += AttributeValuePart.Asn1.usLen;

      *pLength = 1 + Length;
   }
   
   return(RV_SUCCESS);

err:
   GMEM_Free(AttributeTypePart.Asn1.pData);
   GMEM_Free(AttributeValuePart.Asn1.pData);

   return rv;
}


/*******************************************************************************
* int CC_Decode_Validity(BYTE    *pInData,
*                        BLOC    *pOutBloc,
*                        USHORT  *pLength
*                       )
*
* Description : Dcode une donne de type Validity.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_Validity(BYTE    *pInData,
                       BLOC    *pOutBloc,
                       USHORT  *pLength
                      )

{
   ASN1
      notBeforePart,
      notAfterPart;
   BYTE
      notBeforeFormat,
      notAfterFormat,
      *pCurrent;
   int
      rv;
   USHORT
      Length;

   notBeforePart.Asn1.pData = NULL;
   notAfterPart.Asn1.pData  = NULL;

   pCurrent = pInData;

   notBeforeFormat = (*pCurrent & 0xF0) >> 4;
   notAfterFormat  = *pCurrent & 0x0F;
   pCurrent++;

   rv = CC_Decode_UTCTime(pCurrent, notBeforeFormat, &(notBeforePart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   notBeforePart.Tag = TAG_UTCT;
   rv = CC_BuildAsn1(&notBeforePart);
   GMEM_Free(notBeforePart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   rv = CC_Decode_UTCTime(pCurrent, notAfterFormat, &(notAfterPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   notAfterPart.Tag = TAG_UTCT;
   rv = CC_BuildAsn1(&notAfterPart);
   GMEM_Free(notAfterPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


   /* Calcul de la longueur de Validity dcod et allocation                  */
   
   pOutBloc->usLen = notBeforePart.Asn1.usLen
                   + notAfterPart.Asn1.usLen;

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }


   /* Reconstruction de Validity dcod                                       */
   
   pCurrent = pOutBloc->pData;

   memcpy(pCurrent, notBeforePart.Asn1.pData, notBeforePart.Asn1.usLen);
   GMEM_Free(notBeforePart.Asn1.pData);
   pCurrent += notBeforePart.Asn1.usLen;

   memcpy(pCurrent, notAfterPart.Asn1.pData, notAfterPart.Asn1.usLen);
   GMEM_Free(notAfterPart.Asn1.pData);
   pCurrent += notAfterPart.Asn1.usLen;

   return(RV_SUCCESS);

err:
   GMEM_Free(notBeforePart.Asn1.pData);
   GMEM_Free(notAfterPart.Asn1.pData);

   return rv;
}


/*******************************************************************************
* int CC_Decode_UTCTime(BYTE     *pInData,
*                       BYTE     Format,    
*                       BLOC     *pOutBloc,
*                       USHORT   *pLength
*                      )
*
* Description : Dcode une donne de type UTCTime.
*               Ceci consiste en la reconstruction de la chaine initiale suivant
*               le format au quel elle tait exprime.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*               Format : indique au quel format tait la donne d'entre
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               RV_INVALID_DATA : Le format spcifi en entre est invalide.
*
*******************************************************************************/
int CC_Decode_UTCTime(BYTE    *pInData,
                      BYTE    Format,
                      BLOC    *pOutBloc,
                      USHORT  *pLength
                     ) 

{
   BOOL
      bBissextile = FALSE;
   BYTE
      *pCurrent;
   ULONG
      ulTime,
      ulNbHour,
      ulNbMinute;
   USHORT
      usNbDeltaMinute,
      usNbDay,
      usNbFourYears,
      usNbDayInYear,
      usYear,
      usMonth,
      usDay,
      usHour,
      usMinute,
      usSecond,
      usDeltaHour,
      usDeltaMinute;


   ulTime = *(ULONG UNALIGNED *)pInData; //memcpy( &ulTime, (ULONG *) &pInData[0],4);

   switch(Format)
   {
   case UTCT_YYMMDDhhmmssZ :
   case UTCT_YYMMDDhhmmssphhmm :
   case UTCT_YYMMDDhhmmssmhhmm :

      usSecond   = (USHORT) (ulTime % 60);
      ulNbMinute = ulTime / 60;

      break;

   default :

      ulNbMinute = ulTime;

      break;
   }

   switch(Format)
   {
   case UTCT_YYMMDDhhmmphhmm :
   case UTCT_YYMMDDhhmmmhhmm :
   case UTCT_YYMMDDhhmmssphhmm :
   case UTCT_YYMMDDhhmmssmhhmm :

      *pLength = 6;

      usNbDeltaMinute = *(USHORT UNALIGNED *)&pInData[4]; //memcpy(&usNbDeltaMinute, (USHORT *) &pInData[4], 2);

      ASSERT((usNbDeltaMinute >= 0) && (usNbDeltaMinute < 3600));

      usDeltaMinute = usNbDeltaMinute % 60;
      usDeltaHour   = usNbDeltaMinute / 60;

      break;

   default :

      *pLength = 4;

      break;
   }

   usMinute = (USHORT) (ulNbMinute % 60);
   ulNbHour = ulNbMinute / 60;

   usHour   = (USHORT) (ulNbHour % 24);
   usNbDay  = (USHORT) (ulNbHour / 24);

   usNbFourYears = usNbDay / 1461;
   usNbDay       = usNbDay % 1461;
   usYear = 4 * usNbFourYears;


   if ((usNbDay >= 0) && (usNbDay <= 365))
   {
      bBissextile = TRUE;
      usNbDayInYear = usNbDay;
   }
   if ((usNbDay >= 366) && (usNbDay <= 730))
   {
      usYear += 1;
      usNbDayInYear = usNbDay - 366;
   }
   if ((usNbDay >= 731) && (usNbDay <= 1095))
   {
      usYear += 2;
      usNbDayInYear = usNbDay - 731;
   }
   if ((usNbDay >= 1096) && (usNbDay <= 1460))
   {
      usYear += 3;
      usNbDayInYear = usNbDay - 1096;
   }


   usMonth = 1;
   while (usNbDayInYear >= (((usMonth >= 2) && (bBissextile)) ?
                            NbDaysInMonth[usMonth] + 1 :
                            NbDaysInMonth[usMonth]))
   {
      usMonth++;
   }

   usDay = usNbDayInYear - (((usMonth - 1 >= 2) && (bBissextile)) ?
                            NbDaysInMonth[usMonth - 1] + 1 :
                            NbDaysInMonth[usMonth - 1])
                         + 1;
   
   switch(Format)
   {
   case UTCT_YYMMDDhhmmZ :

      pOutBloc->usLen = 11;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent = 'Z';

      break;

   case UTCT_YYMMDDhhmmphhmm :

      pOutBloc->usLen = 15;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent++ = '+';
      *pCurrent++ = '0' + usDeltaHour / 10;
      *pCurrent++ = '0' + usDeltaHour % 10;
      *pCurrent++ = '0' + usDeltaMinute / 10;
      *pCurrent++ = '0' + usDeltaMinute % 10;

      break;

   case UTCT_YYMMDDhhmmmhhmm :

      pOutBloc->usLen = 15;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent++ = '-';
      *pCurrent++ = '0' + usDeltaHour / 10;
      *pCurrent++ = '0' + usDeltaHour % 10;
      *pCurrent++ = '0' + usDeltaMinute / 10;
      *pCurrent++ = '0' + usDeltaMinute % 10;

      break;

   case UTCT_YYMMDDhhmmssZ :

      pOutBloc->usLen = 13;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent++ = '0' + usSecond / 10;
      *pCurrent++ = '0' + usSecond % 10;
      *pCurrent++ = 'Z';

      break;

   case UTCT_YYMMDDhhmmssphhmm :

      pOutBloc->usLen = 17;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent++ = '0' + usSecond / 10;
      *pCurrent++ = '0' + usSecond % 10;
      *pCurrent++ = '+';
      *pCurrent++ = '0' + usDeltaHour / 10;
      *pCurrent++ = '0' + usDeltaHour % 10;
      *pCurrent++ = '0' + usDeltaMinute / 10;
      *pCurrent++ = '0' + usDeltaMinute % 10;

      break;

   case UTCT_YYMMDDhhmmssmhhmm :

      pOutBloc->usLen = 17;

      if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
      {
         return(RV_MALLOC_FAILED);
      }

      pCurrent = pOutBloc->pData;

      *pCurrent++ = '0' + usYear / 10;
      *pCurrent++ = '0' + usYear % 10;
      *pCurrent++ = '0' + usMonth / 10;
      *pCurrent++ = '0' + usMonth % 10;
      *pCurrent++ = '0' + usDay / 10;
      *pCurrent++ = '0' + usDay % 10;
      *pCurrent++ = '0' + usHour / 10;
      *pCurrent++ = '0' + usHour % 10;
      *pCurrent++ = '0' + usMinute / 10;
      *pCurrent++ = '0' + usMinute % 10;
      *pCurrent++ = '0' + usSecond / 10;
      *pCurrent++ = '0' + usSecond % 10;
      *pCurrent++ = '-';
      *pCurrent++ = '0' + usDeltaHour / 10;
      *pCurrent++ = '0' + usDeltaHour % 10;
      *pCurrent++ = '0' + usDeltaMinute / 10;
      *pCurrent++ = '0' + usDeltaMinute % 10;

      break;

   default :

      return(RV_INVALID_DATA);

      break;
   }


   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Decode_SubjectPKInfo(BYTE    *pInData,
*                             BLOC    *pOutBloc,
*                             USHORT  *pLength
*                            )
*
* Description : Dcode une donne de type SubjectPublicKeyInfo.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_SubjectPKInfo(BYTE    *pInData,
                            BLOC    *pOutBloc,
                            USHORT  *pLength
                           )

{
   ASN1
      algorithmPart,
      subjectPKPart;
//   BLOC
//      CompData;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      Length;

   algorithmPart.Asn1.pData = NULL;
   subjectPKPart.Asn1.pData = NULL;

   pCurrent = pInData;
   
   rv = CC_Decode_AlgorithmIdentifier(pCurrent, &(algorithmPart.Content), &Length);
   if (rv != RV_SUCCESS) goto err;
   algorithmPart.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&algorithmPart);
   GMEM_Free(algorithmPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;

#ifdef _TRICKY_COMPRESSION
	/* Ne pas faire le RawDecode a permis de gagner l'octet 0xFF */
#ifdef _OPT_HEADER
	if (pCurrent[0] < 0x80)
	{
		CompData.usLen = pCurrent[0];
		CompData.pData = &(pCurrent[1]);
		Length = CompData.usLen + 1;
	}
	else
	{
		CompData.usLen = ((pCurrent[0] & 0x7F) << 8) + pCurrent[1];
		CompData.pData = &(pCurrent[2]);
		Length = CompData.usLen + 2;
	}
#else	/* _OPT_HEADER */
	CompData.usLen = (pCurrent[0] << 8) + pCurrent[1];
	CompData.pData = &(pCurrent[2]);
	Length = CompData.usLen + 2;
#endif
	subjectPKPart.Content.usLen = CompData.usLen;
	if ((subjectPKPart.Content.pData = 
		  GMEM_Alloc(subjectPKPart.Content.usLen)) == NULL_PTR)
	{
		rv = RV_MALLOC_FAILED;
		goto err;
	}
	memcpy(subjectPKPart.Content.pData,
			 CompData.pData,
			 subjectPKPart.Content.usLen
			);

   subjectPKPart.Tag = TAG_BIT_STRING;
   rv = CC_BuildAsn1(&subjectPKPart);
   GMEM_Free(subjectPKPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;
#else	/* _TRICKY_COMPRESSION */
	rv = CC_RawDecode(pCurrent, &(subjectPKPart.Content), &Length, FALSE);
   if (rv != RV_SUCCESS) goto err;
   subjectPKPart.Tag = TAG_BIT_STRING;
   rv = CC_BuildAsn1(&subjectPKPart);
   GMEM_Free(subjectPKPart.Content.pData);
   if (rv != RV_SUCCESS) goto err;
   pCurrent += Length;
#endif

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);

   /* Calcul de la longueur du dcod et allocation                           */
   
   pOutBloc->usLen = algorithmPart.Asn1.usLen
                   + subjectPKPart.Asn1.usLen;

   if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }


   /* Reconstruction                                                          */
   
   pCurrent = pOutBloc->pData;

   memcpy(pCurrent, algorithmPart.Asn1.pData, algorithmPart.Asn1.usLen);
   GMEM_Free(algorithmPart.Asn1.pData);
   pCurrent += algorithmPart.Asn1.usLen;

   memcpy(pCurrent, subjectPKPart.Asn1.pData, subjectPKPart.Asn1.usLen);
   GMEM_Free(subjectPKPart.Asn1.pData);
   pCurrent += subjectPKPart.Asn1.usLen;

   return(RV_SUCCESS);

err:
   GMEM_Free(algorithmPart.Asn1.pData);
   GMEM_Free(subjectPKPart.Asn1.pData);

   return rv;
}


/*******************************************************************************
* int CC_Decode_UniqueIdentifier(BYTE    *pInData,
*                                BLOC    *pOutBloc,
*                                USHORT  *pLength
*                               )
*
* Description : Dcode une donne de type UniqueIdentifier.
*               Ceci consiste seulement en le dcodage brute (CC_RawDecode) de
*               la donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_UniqueIdentifier(BYTE    *pInData,
                               BLOC    *pOutBloc,
                               USHORT  *pLength
                              )

{
   int
      rv;


   rv = CC_RawDecode(pInData, pOutBloc, pLength, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Decode_Extensions(BYTE    *pInData,
*                          BLOC    *pOutBloc,
*                          USHORT  *pLength
*                         )
*
* Description : Dcode une donne de type Extensions.
*               Ceci consiste en le dcodage des diffrentes parties encodes
*               successives, leurs enrobages respectifs (tags uniquement
*               par la spec X.509), et la concatnation de ces rsultats.
*
* Remarks     : Voir l'encodage
*               L'ajout d'un enrobage 'context spcifique' est requis
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*               pLength : la longueur de donnes encods utilise
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_Extensions(BYTE    *pInData,
                         BLOC    *pOutBloc,
                         USHORT  *pLength
                        )

{
   ASN1
      ExtensionPart[MAX_AVA],
      InOutAsn1;
   BYTE
      *pCurrent;
   int
      rv;
   USHORT
      i,
      usNbExtension,
      Length;


   /* Dcodage des diffrents composants et calcul de la longueur ncessaire  */

   pCurrent = pInData;
   InOutAsn1.Content.usLen = 0;
   
   usNbExtension = *pCurrent;
   pCurrent++;

   for (i = 0; i < usNbExtension; i++)
   {
	  ExtensionPart[i].Asn1.pData = NULL;
   }

   for (i = 0; i < usNbExtension; i++)
   {
      rv = CC_Decode_Extension(pCurrent, &(ExtensionPart[i].Content), &Length);
      if (rv != RV_SUCCESS) goto err;
      ExtensionPart[i].Tag = TAG_SEQUENCE;
      rv = CC_BuildAsn1(&ExtensionPart[i]);
      GMEM_Free(ExtensionPart[i].Content.pData);
      if (rv != RV_SUCCESS) goto err;
      InOutAsn1.Content.usLen += ExtensionPart[i].Asn1.usLen;
      pCurrent += Length;
   }

   *pLength = (unsigned short)(DWORD) (pCurrent - pInData);


   /* Reconstruction de la partie intrieure au 'context specific'            */
   
   if ((InOutAsn1.Content.pData = GMEM_Alloc(InOutAsn1.Content.usLen)) == NULL_PTR)
   {
      rv = RV_MALLOC_FAILED;
	  goto err;
   }

   pCurrent = InOutAsn1.Content.pData;

   for (i = 0; i < usNbExtension; i++)
   {
      memcpy(pCurrent, ExtensionPart[i].Asn1.pData, ExtensionPart[i].Asn1.usLen);
      GMEM_Free(ExtensionPart[i].Asn1.pData);
      pCurrent += ExtensionPart[i].Asn1.usLen;
   }

   /* Ajout de l'enrobage 'context specific'                                  */

   InOutAsn1.Tag = TAG_SEQUENCE;
   rv = CC_BuildAsn1(&InOutAsn1);
   GMEM_Free(InOutAsn1.Content.pData);
   if (rv != RV_SUCCESS) return rv;

   *pOutBloc = InOutAsn1.Asn1;
   
   return(RV_SUCCESS);

err:
   for (i = 0; i < usNbExtension; i++)
   {
      GMEM_Free(ExtensionPart[i].Asn1.pData);
   }

   return rv;
}


/*******************************************************************************
* int CC_Decode_Extension(BYTE    *pInData,
*                         BLOC    *pOutBloc,
*                         USHORT  *pLength
*                        )
*
* Description : Dcode une donne de type Extension.
*               Ceci consiste seulement en le dcodage brute (CC_RawDecode) de
*               la donne d'entre.
*
* Remarks     : 
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_Extension(BYTE    *pInData,
                        BLOC    *pOutBloc,
                        USHORT  *pLength
                       )

{
   int
      rv;


   rv = CC_RawDecode(pInData, pOutBloc, pLength, TRUE);
   if (rv != RV_SUCCESS) return rv;

   return(RV_SUCCESS);
}


/*******************************************************************************
* int CC_Decode_Signature(BYTE    *pInData,
*                         BLOC    *pOutBloc,
*                         USHORT  *pLength
*                        )
*
* Description : Dcode la signature du certificat.
*               Ceci consiste seulement en le dcodage brute (CC_RawDecode) de
*               la donne d'entre.
*
* Remarks     : Voir l'encodage
*
* In          : pInBloc : la partie  dcoder (champ Content)
*
* Out         : pOutBloc : le dcod (mmoire alloue ici  librer par la
*                          fonction appelante)
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_MALLOC_FAILED : Un malloc a chou.
*               Autre : D'autres codes d'erreur peuvent tre retourns par des
*                       fonctions d'un niveau infrieur.
*
*******************************************************************************/
int CC_Decode_Signature(BYTE    *pInData,
                        BLOC    *pOutBloc,
                        USHORT  *pLength
                       )

{
//	BLOC
//		CompData;
   int
      rv;


#ifdef _TRICKY_COMPRESSION
	/* Ne pas faire le RawDecode a permis de gagner l'octet 0xFF */
#ifdef _OPT_HEADER
	if (pInData[0] < 0x80)
	{
		CompData.usLen = pInData[0];
		CompData.pData = &(pInData[1]);
		*pLength = CompData.usLen + 1;
	}
	else
	{
		CompData.usLen = ((pInData[0] & 0x7F) << 8) + pInData[1];
		CompData.pData = &(pInData[2]);
		*pLength = CompData.usLen + 2;
	}
#else	/* _OPT_HEADER */
	CompData.usLen = (pInData[0] << 8) + pInData[1];
	CompData.pData = &(pInData[2]);
	*pLength = CompData.usLen + 2;
#endif
	pOutBloc->usLen = CompData.usLen;
	if ((pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen)) == NULL_PTR)
	{
		return(RV_MALLOC_FAILED);
	}
	memcpy(pOutBloc->pData, CompData.pData, pOutBloc->usLen);
#else	/* _TRICKY_COMPRESSION */
   rv = CC_RawDecode(pInData, pOutBloc, pLength, TRUE);
   if (rv != RV_SUCCESS) return rv;
#endif

   return(RV_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gemcomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GpkCsp.rc
//
#define GPK_X509_DICTIONARY             101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\util.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element UTIL.C */
/*  *1    14-NOV-1996 10:27:03 ANIGBOGU "[113914]Utility functions to support the compression/decompression library" */
/*  DEC/CMS REPLACEMENT HISTORY, Element UTIL.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/util.c
**
**  PURPOSE
**
**  Utility functions for compress/decompression support
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include "comppriv.h"

/* ===========================================================================
 * Clear input and output buffers
 */
void
ClearBuffers(
             CompParam_t *Comp
            )
{
    Comp->OutBytes = 0;
    Comp->InputSize = Comp->Index = 0;
    Comp->BytesIn = Comp->BytesOut = 0L;
}

/* ===========================================================================
 * Fill the input buffer. This is called only when the buffer is empty.
 */
int
FillInputBuffer(
                int          EOF_OK,          /* set if EOF acceptable as a result */
                CompParam_t *Comp
               )
{
    unsigned long Length;

    /* Read as much as possible */
    Comp->InputSize = 0;
    Length = MIN(Comp->GlobalSize - Comp->BytesIn,
                 (unsigned long)INBUFSIZ);

    Comp->Input = Comp->GlobalInput + Comp->BytesIn;
    Comp->InputSize += Length;
    if ((Comp->InputSize == 0) && (EOF_OK == 1))
        return EOF;
    Comp->BytesIn += Comp->InputSize;
    Comp->Index = 1;
    return (int)Comp->Input[0];
}

/* ===========================================================================
 * Write the output buffer Output[0..OutBytes-1] and update BytesOut.
 * (used for the compressed data only)
 */
CompressStatus_t
FlushOutputBuffer(
                  CompParam_t *Comp
                 )
{
    CompressStatus_t Status = COMPRESS_OK;

    if (Comp->OutBytes == 0)
        return Status;

    Status = WriteBuffer(Comp, (char *)Comp->Output, Comp->OutBytes);
    if (COMPRESS_OK != Status)
        return Status;

    Comp->BytesOut += (unsigned long)Comp->OutBytes;
    Comp->OutBytes = 0;

    return Status;

}

/* ===========================================================================
 * Write the output window Window[0..OutBytes-1] and update crc and BytesOut.
 * (Used for the decompressed data only.)
 */
CompressStatus_t
FlushWindow(
            CompParam_t *Comp
           )
{
    CompressStatus_t Status = COMPRESS_OK;

    if (Comp->OutBytes == 0)
        return Status;

    Comp->pCRC->Compute(Comp->Window, Comp->OutBytes);
    Status = WriteBuffer(Comp, (char *)Comp->Window,
                         Comp->OutBytes);
    if (COMPRESS_OK != Status)
        return Status;

    Comp->BytesOut += (unsigned long)Comp->OutBytes;
    Comp->OutBytes = 0;

    return Status;
}

/* ===========================================================================
 * Flushes output buffer
 */
CompressStatus_t
WriteBuffer(
            CompParam_t *Comp,
            void        *Buffer,
            unsigned int Size
           )
{
    CompressStatus_t Status;
    unsigned char *temp =
        (unsigned char *)CompressMalloc(Size, &Status);

    if (COMPRESS_OK != Status)
        return Status;

    if (Comp->PtrOutput == NULL)
    {
        Comp->CompressedOutput =
            (CompData_t *)CompressMalloc(sizeof(CompData_t), &Status);

        if (COMPRESS_OK == Status)
            Comp->PtrOutput = Comp->CompressedOutput;
    }
    else
    {
        Comp->CompressedOutput->next =
            (CompData_t *)CompressMalloc(sizeof(CompData_t), &Status);

        if (COMPRESS_OK == Status)
            Comp->CompressedOutput = Comp->CompressedOutput->next;
    }

    if (COMPRESS_OK != Status)
    {
        CompressFree(temp);
        return Status;
    }

    Comp->CompressedOutput->Data = temp;

    Comp->CompressedOutput->next = NULL;
    memcpy((char *)Comp->CompressedOutput->Data, Buffer, (int)Size);
    Comp->CompressedOutput->Size = (int)Size;

    return COMPRESS_OK;
}

/* ========================================================================
 * Error translator.
 */
void
TranslateErrorMsg(
                  char             *Message,
                  CompressStatus_t  ErrorCode
                 )
{
    switch(ErrorCode)
    {
    case COMPRESS_OK:
        strcpy(Message, "This is not an error message.");
        break;
    case BAD_COMPRESSION_LEVEL:
         strcpy(Message, "Invalid compression level--valid values are 0-9.");
         break;
    case BAD_MAGIC_HEADER:
        strcpy(Message, "Bad magic header.");
        break;
    case BAD_COMPRESSED_DATA:
        strcpy(Message, "Bad compressed data.");
        break;
    case BAD_BLOCK_TYPE:
        strcpy(Message, "Invalid block type.");
        break;
    case BAD_CODE_LENGTHS:
        strcpy(Message, "Bad code lengths.");
        break;
    case BAD_INPUT:
        strcpy(Message, "Bad input--more codes than bits.");
        break;
    case EXTRA_BITS:
        strcpy(Message, "Too many bits.");
        break;
    case UNKNOWN_COMPRESSION_METHOD:
        strcpy(Message, "Unknown compression method.");
        break;
    case INCOMPLETE_CODE_SET:
        strcpy(Message, "Incomplete code set.");
        break;
    case END_OF_BLOCK:
        strcpy(Message, "End of block.");
        break;
    case BLOCK_VANISHED:
        strcpy(Message, "Block to compress disappeared--memory trashed.");
        break;
    case FORMAT_VIOLATED:
        strcpy(Message, "Invalid compressed data--format violated.");
        break;
    case CRC_ERROR:
        strcpy(Message, "Invalid compressed data--crc error.");
        break;
    case LENGTH_ERROR:
        strcpy(Message, "Invalid compressed data--length error.");
        break;
    case INSUFFICIENT_MEMORY:
        strcpy(Message, "Insufficient memory--ould not allocate space requested.");
        break;
    default:  sprintf(Message, "Unknown error code %d", ErrorCode);
    }
}

/* ========================================================================
 * Semi-safe malloc -- never returns NULL.
 */
void *
CompressMalloc(
       unsigned int      Size,
       CompressStatus_t *Status
      )
{
    void *DynamicSpace = malloc ((int)Size);


    if (DynamicSpace == NULL)
        *Status = INSUFFICIENT_MEMORY;
    else
        *Status = COMPRESS_OK;
    return DynamicSpace;
}

void
CompressFree(void   *Address)
{
    free(Address);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\cryptoflex\slbzip\zip.cpp ===
/*  DEC/CMS REPLACEMENT HISTORY, Element ZIP.C */
/*  *1    14-NOV-1996 10:27:08 ANIGBOGU "[113914]Compress data to zip format using the deflate algorithm" */
/*  DEC/CMS REPLACEMENT HISTORY, Element ZIP.C */
/* PRIVATE FILE
******************************************************************************
**
** (c) Copyright Schlumberger Technology Corp., unpublished work, created 1996.
**
** This computer program includes Confidential, Proprietary Information and is
** a Trade Secret of Schlumberger Technology Corp. All use, disclosure, and/or
** reproduction is prohibited unless authorized in writing by Schlumberger.
**                              All Rights Reserved.
**
******************************************************************************
**
**  compress/zip.c
**
**  PURPOSE
**
** Compress data using the deflate algorithm
**
**  SPECIAL REQUIREMENTS & NOTES
**
**  AUTHOR
**
**    J. C. Anigbogu
**    Austin Systems Center
**    Nov 1996
**
******************************************************************************
*/

#include <ctype.h>
#include <sys/types.h>

#include "comppriv.h"

CompressStatus_t Copy(CompParam_t *comp);

/* ===========================================================================
 * Deflate in to out.
 * IN assertions: the input and output buffers are cleared.
 */
CompressStatus_t
Zip(
    int          CompLevel, /* compression level */
    CompParam_t *Comp
   )
{
    unsigned char       Flags = 0;        /* general purpose bit flags */
    unsigned short      DeflateFlags = 0; /* pkzip -es, -en or -ex equivalent */
    long                TimeStamp = 0;    /* time_stamp */
    LocalBits_t        *Bits;
    DeflateParam_t     *Defl;  /* window offset of current block */
    LocalDef_t         *Deflt;
    int                 Method = CompLevel ? DEFLATED : STORED;
    CompressStatus_t    Status = COMPRESS_OK;

    Comp->OutBytes = 0;

    /* Write the header to the gzip buffer. See algorithm.doc for the format */

    PutByte(GZIP_MAGIC[0], Comp); /* magic header */
    PutByte(GZIP_MAGIC[1], Comp);
    PutByte(Method, Comp);      /* compression method */

    PutByte(Flags, Comp);         /* general flags */
    PutLong(TimeStamp, Comp);

    Comp->pCRC->Compute(NULL, 0);

    Comp->HeaderBytes = Comp->OutBytes;

    if (Method == STORED)
    {
        PutByte((unsigned char)0, Comp); /* extra flags */
        PutByte(OS_CODE, Comp);            /* OS identifier */

        Status = Copy(Comp);
        if (COMPRESS_OK != Status)
            return Status;
    }
    else
    {
        Bits = (LocalBits_t *)CompressMalloc(sizeof(LocalBits_t), &Status);
        if (Status != COMPRESS_OK)
            return Status;

        InitializeBits(Bits);
        InitMatchBuffer();
        Defl = (DeflateParam_t *)CompressMalloc(sizeof(DeflateParam_t), &Status);
        if (Status != COMPRESS_OK)
        {
            CompressFree(Bits);
            return Status;
        }

        Deflt = (LocalDef_t *)CompressMalloc(sizeof(LocalDef_t), &Status);
        if (Status != COMPRESS_OK)
        {
            CompressFree(Bits);
            CompressFree(Defl);
            return Status;
        }

        if ((Status = InitLongestMatch(CompLevel, &DeflateFlags,
            Defl, Deflt, Comp)) != COMPRESS_OK)
        {
            CompressFree(Bits);
            CompressFree(Defl);
            CompressFree(Deflt);
            return Status;
        }

        PutByte((unsigned char)DeflateFlags, Comp); /* extra flags */
        PutByte(OS_CODE, Comp);            /* OS identifier */

        (void)Deflate(CompLevel, Bits, Defl, Deflt, Comp);

        CompressFree(Bits);
        CompressFree(Defl);
        CompressFree(Deflt);

        PutLong((unsigned __int32)(*Comp->pCRC), Comp);
        PutLong(Comp->BytesIn, Comp);
        Comp->HeaderBytes += 2*sizeof(unsigned long);

        Status = FlushOutputBuffer(Comp);
        if (COMPRESS_OK != Status)
            return Status;
    }
    /* Write the crc and uncompressed size */
    return Status;
}


/* ===========================================================================
 * Read new data from the current input buffer and
 * update the crc and input data size.
 * IN assertion: size >= 2 (for end-of-line translation)
 */
int
ReadBuffer(
           char          *Input,
           unsigned int   Size,
           CompParam_t   *Comp
          )
{
    unsigned long Length;
    Assert(Comp->InputSize == 0, "input buffer not empty");

    /* Read as much as possible */
    Length = MIN(Comp->GlobalSize - Comp->BytesIn, (unsigned long)Size);

    if (Length == 0)
        return (int)Length;

    memcpy((char *)Input, (char *)Comp->GlobalInput + Comp->BytesIn,
           (int)Length);

    Comp->pCRC->Compute((unsigned char *)Input, (unsigned int)Length);
    Comp->BytesIn += Length;
    return (int)Length;
}

/* ===========================================================================
 * Read a new buffer from the current input.
 */
int
FillBuffer(
           unsigned char *Input,
           unsigned int   Size,
           CompParam_t   *Comp
          )
{
    /* Point to the input buffer */

    Comp->Input = Comp->InputBuffer;
    Comp->GlobalInput = Input;
    Comp->GlobalSize = Size;
    Comp->WindowSize = (unsigned long) DWSIZE;
    ClearBuffers(Comp); /* clear input and output buffers */
    Comp->PtrOutput = NULL;
    return (int)Size;
}


/* ===========================================================================
 * Copy input to output unchanged
 * IN assertion: comp->GlobalSize bytes have already been read in comp->GlobalInput.
 */
CompressStatus_t
Copy(
     CompParam_t *Comp
    )
{
    CompressStatus_t Status = COMPRESS_OK;

    Comp->pCRC->Compute(Comp->GlobalInput, (unsigned int)Comp->GlobalSize);

    PutLong((unsigned __int32)(*Comp->pCRC), Comp);
    PutLong(Comp->GlobalSize, Comp);
    Status = FlushOutputBuffer(Comp);
    if (COMPRESS_OK != Status)
        return Status;

    Status = WriteBuffer(Comp, Comp->GlobalInput,
                         (unsigned int)Comp->GlobalSize);
    if (COMPRESS_OK != Status)
        return Status;

    Comp->BytesOut += Comp->GlobalSize;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gemcomp\compalg.c ===
#ifdef _WINDOWS
#include <windows.h>
#endif

#include        <stdio.h>
#include        <stdlib.h>

#include        "ccdef.h"
#include        "compcert.h"
#include        "gmem.h"

#define FIXED_MODEL                     1
#define ADAPTATIVE_MODEL        2
#define Code_value_bits     16
#define No_of_chars                 256
#define Max_frequency       16383
#define EOF_symbol              (No_of_chars+1)
#define No_of_symbols   (No_of_chars+1)

#define Top_value       (( (long) 1 << Code_value_bits) - 1)
#define First_qtr       (Top_value / 4 + 1)
#define Half            (2 * First_qtr)
#define Third_qtr       (3 * First_qtr)

typedef long    code_value;

static  code_value      value_dc;
static  code_value      low_dc, high_dc;
static  code_value      low_enc, high_enc;

static  long                bits_to_follow;
static  unsigned  int   buffer_in;
static  unsigned  int   bits_to_go_in;
static  unsigned  int   garbage_bits_in;
static  unsigned  int   buffer_out;
static  unsigned  int   bits_to_go_out;

static  int             Error;

unsigned int            char_to_index[No_of_chars];
unsigned char               index_to_char[No_of_symbols+1];
unsigned int            cum_freq[No_of_symbols+1];

unsigned char           *Memory;
static   unsigned       MemoSize;

unsigned int    FixedFreqA[No_of_symbols+1] =
{
        0,
  63, 260, 180, 216, 254,  63, 268,  95,  43,  62,  33,  28,  14,   6,  45,  38,

  33,  35,  13, 303,  41,  37,  41,   8,  15,  81,  25,   2,  15,  88,  20,   6,

/*      !    =    #    $    %    &    '    (    )    *    +    ,    -    .    /         */
 662,   3,  35,  18,  12,   3,  11,   3,  16,  12,   2,  34,  42,  32,  56,  31,

/* 0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?  */
 300, 118,  42,  40,  21,  37,  63,  46,  10,  90,  33,   3,   1,   9,  15,   3,

/* @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O  */
  27, 158,  73, 122,  82,  31,  20,  14,  26,  56,   1,   2,  27,  20,  12,  31,

/* P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _  */
  64,   4,  65, 114, 106, 195,  10,  27,   3,  18,  25,   2,   3,   1,   2,  12,

/* `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o  */
  24, 271,  44, 171, 158, 439,  44,  50,  71, 308,   2,   5,  60,  73, 234, 280,

/* p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~       */
  76,  44, 274, 273, 358, 100,  36,  43,  12,  79,   2,   1,   1,   1,   1,   1,

  48,  48,  30,   1,   1,   5, 100,   5,   1,   3,   1,   1,   1,  50,   1,   1,
   1,   4,   2,  14,   1,   5,  12,   1,   4,   1,   1,   1,   1,   1,   1,   1,
   6,  14,   1,   1,  24,   1,   1,   4,   1,  11,   1,   2,  23,   1,   1,   4,
   1,   1,   1,   1,   5,   1,   1,  12,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   2,   1,   1,   1,   1,   1,   4,   1,   1,   1,   1,   1,   1,
   1,   2,   1,   2,   1,   1,   1,   1,   1,   1,   1,   4,   1,   1,   4,   1,
   1,   1,   1,  13,  12,   1,   1,   1,   1,   1,   1,   2,   1,  13,   1,   1,
   5,   1,   2,   1,  12,   1,   1,   1,  24,   2,   1,   1,   1,   4,   1, 308,
 250
};

unsigned int    AdaptativeFreqA[No_of_symbols+1] =
{
        0,
  12,  24,  19,  18,  19,   6,  20,   7,   4,   5,   3,   3,   2,   2,   4,   4,

   3,   4,   2,  23,   4,   4,   4,   2,   2,   7,   3,   1,   2,   7,   3,   1,

/*      !    =    #    $    %    &    '    (    )    *    +    ,    -    .    /         */
  49,   1,   3,   2,   2,   2,   2,   1,   2,   2,   1,   3,   4,   3,   5,   3,

/* 0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?  */
  25,   9,   3,   3,   2,   3,   5,   4,   2,   7,   3,   1,   1,   1,   2,   1,

/* @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O  */
   3,  14,   6,  10,   7,   3,   3,   2,   3,   5,   1,   1,   3,   2,   1,   3,

/* P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _  */
   5,   2,   6,   9,   9,  15,   2,   3,   1,   2,   3,   2,   1,   1,   1,   2,

/* `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o  */
   2,  20,   4,  13,  12,  32,   4,   5,   6,  24,   1,   1,   5,   7,  18,  21,

/* p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~       */
   6,   4,  20,  21,  27,   8,   3,   4,   2,   7,   1,   1,   1,   1,   1,   1,

   4,   9,   3,   1,   1,   1,   8,   1,   1,   3,   1,   1,   1,   5,   1,   1,
   1,   2,   1,   2,   1,   1,   2,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   2,   1,   1,   3,   1,   1,   1,   1,   2,   1,   1,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   2,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   2,   2,   1,   1,   1,   1,   1,   1,   1,   1,   2,   1,   2,
   1,   1,   1,   1,   2,   1,   1,   1,   2,   1,   1,   1,   1,   1,   1,  24,
  25
};

unsigned int    freq[No_of_symbols+1];

/******************************************************************************/

void    start_model(int ModelType)

{
        int    i;


        for (i = 0; i < No_of_chars; i++)
        {
                char_to_index[i] = i+1;
                index_to_char[i+1] = (BYTE)i;
        }

        if (ModelType == FIXED_MODEL)
        {
                for (i = 0; i <= No_of_symbols; i++)
                {
                        freq[i] = FixedFreqA[i];
                }

                cum_freq[No_of_symbols] = 0;
                for(i = No_of_symbols; i > 0; i--)
                {
                        cum_freq[i-1] = cum_freq[i] + freq[i];
                }
        }

        if (ModelType == ADAPTATIVE_MODEL)
        {
                for (i = 0; i <= No_of_symbols; i++)
                {
                        freq[i] = AdaptativeFreqA[i];
                }

                cum_freq[No_of_symbols] = 0;
                for(i = No_of_symbols; i > 0; i--)
                {
                        cum_freq[i-1] = cum_freq[i] + freq[i];
                }
        }
}


/******************************************************************************/

void    update_model(int ModelType, unsigned int symbol)

{
        unsigned int    i;
        unsigned int    cum;
        unsigned int    ch_i;
        unsigned int    ch_symbol;


        if (ModelType == ADAPTATIVE_MODEL)
        {
                if (cum_freq[0] == Max_frequency)
                {
                        cum = 0;
                        
                        for (i = No_of_symbols + 1; i != 0; /**/)
                        {
                                --i;
                                freq[i] = (freq[i] + 1) / 2;
                                cum_freq[i] = cum;
                                cum += freq[i];
                        }
                }

                for (i = symbol; freq[i] == freq[i-1]; i--)
                {
                }

                if (i < symbol)
                {
                        ch_i = index_to_char[i];
                        ch_symbol = index_to_char[symbol];
                        index_to_char[i] = (BYTE)ch_symbol;
                        index_to_char[symbol] = (BYTE)ch_i;
                        char_to_index[ch_i] = symbol;
                        char_to_index[ch_symbol] = i;
                }

                freq[i] += 1;

                while (i > 0)
                {
                        i -= 1;
                        cum_freq[i] += 1;
                }
        }
}

/******************************************************************************/

void    start_outputing_bits(void)

{
        buffer_out = 0;
        bits_to_go_out = 8;
}


/******************************************************************************/

int     output_bit(unsigned short int   *pOutCount, unsigned int bit)
{
        buffer_out >>= 1;
        if (bit)
        {
                buffer_out |= 0x80;
        }

        bits_to_go_out -= 1;
        if (bits_to_go_out == 0)
        {
                if (*pOutCount == MemoSize)
                {
                        return RV_COMPRESSION_FAILED;
                }

                Memory[(*pOutCount)++] = (BYTE)buffer_out;
                bits_to_go_out = 8;
        }

        return RV_SUCCESS;
}

/******************************************************************************/

int done_outputing_bits(unsigned short int      *pOutCount)
{
        if (*pOutCount == MemoSize)
        {
                return RV_COMPRESSION_FAILED;
        }

        Memory[(*pOutCount)++] = buffer_out>>bits_to_go_out;

        return RV_SUCCESS;
}

/******************************************************************************/

void    start_inputing_bits(void)
{
        bits_to_go_in   = 0;
        garbage_bits_in = 0;
        Error           = RV_SUCCESS;
}

/******************************************************************************/

unsigned  int   input_bit(BLOC InBloc, unsigned short int *pusInCount)

{
        unsigned  int   t;

        if (bits_to_go_in == 0)
        {
                if (*pusInCount < InBloc.usLen)
                {
                        buffer_in = InBloc.pData[(*pusInCount)++];
                }
                else
                {
                        buffer_in = 0x00;
                }

            if (*pusInCount == InBloc.usLen)
                {
                        garbage_bits_in += 1;
                if (garbage_bits_in > Code_value_bits - 2)
                        {
                                Error = RV_INVALID_DATA;
                        }
                }

                bits_to_go_in = 8;
        }

        t = buffer_in & 1;
        buffer_in >>= 1;
        bits_to_go_in -= 1;

        return (t);
}


/******************************************************************************/

int bit_plus_follow(unsigned short int  *pOutCount, unsigned  int bit)

{
        if (output_bit(pOutCount, bit) != RV_SUCCESS)
        {
                return RV_COMPRESSION_FAILED;
        }
        while (bits_to_follow > 0)
        {
                if (output_bit(pOutCount, !bit) != RV_SUCCESS)
                {
                        return RV_COMPRESSION_FAILED;
                }
                bits_to_follow -= 1;
        }

        return RV_SUCCESS;
}

/******************************************************************************/

void    start_encoding(void)

{
        low_enc        = 0;
        high_enc       = Top_value;
        bits_to_follow = 0;
}

/******************************************************************************/
int     encode_symbol(unsigned short int        *pOutCount,
                                                  unsigned  int symbol,
                                                  unsigned  int cum_freq[]
                                                 )

{
        long    range;


        range = (long) (high_enc-low_enc) + 1;
        high_enc = low_enc + (range * cum_freq[symbol-1]) / cum_freq[0] - 1;
        low_enc = low_enc + (range * cum_freq[symbol]) / cum_freq[0];

        for ( ; ; )
        {
                if (high_enc < Half)
                {
                        if (bit_plus_follow(pOutCount, 0) != RV_SUCCESS)
                        {
                                return RV_COMPRESSION_FAILED;
                        }
                }
                else if (low_enc >= Half)
                {
                        if (bit_plus_follow(pOutCount, 1) != RV_SUCCESS)
                        {
                                return RV_COMPRESSION_FAILED;
                        }
                        low_enc -= Half;
                        high_enc -= Half;
                }
                else if ((low_enc >= First_qtr) && (high_enc < Third_qtr))
                {
                        bits_to_follow += 1;
                        low_enc -= First_qtr;
                        high_enc -= First_qtr;
                }
                else
                {
                        break;
                }

                low_enc = 2 * low_enc;
                high_enc = 2 * high_enc + 1;
        }

        return RV_SUCCESS;
}


/******************************************************************************/

int done_encoding(unsigned short int    *pOutCount)

{
        bits_to_follow += 1;
        if (low_enc < First_qtr)
        {
                if (bit_plus_follow(pOutCount, 0) != RV_SUCCESS)
                {
                        return RV_COMPRESSION_FAILED;
                }
        }
        else
        {
                if (bit_plus_follow(pOutCount, 1) != RV_SUCCESS)
                {
                        return RV_COMPRESSION_FAILED;
                }
        }

        return RV_SUCCESS;
}

/******************************************************************************/

void    start_decoding(BLOC InBloc, unsigned short int *pusInCount)

{
        unsigned  int   i;


        value_dc = 0;

        for (i = 1; i <= Code_value_bits; i++)
        {
                value_dc = 2 * value_dc + input_bit(InBloc, pusInCount);
                if (Error != RV_SUCCESS)
                {
                        break;
                }
        }

        low_dc = 0;
        high_dc = Top_value;
}


/******************************************************************************/

unsigned  int   decode_symbol(BLOC InBloc,
                                                                          unsigned short int *pusInCount,
                                                                          unsigned  int cum_freq[]
                                                                         )

{
        long    range;
        unsigned  int   cum;
        unsigned  int   symbol;


        range = (long) (high_dc-low_dc) + 1;
        cum = (((long) (value_dc-low_dc) + 1) * cum_freq[0] - 1) / range;

        for (symbol = 1; cum_freq[symbol] > cum; symbol++)
        {
        }

        high_dc = low_dc + (range * cum_freq[symbol-1]) / cum_freq[0] - 1;
        low_dc = low_dc + (range * cum_freq[symbol]) / cum_freq[0];

        for ( ; ; )
        {
                if (high_dc < Half)
                {
                }
                else if (low_dc >= Half)
                {
                        value_dc -= Half;
                        low_dc -= Half;
                        high_dc -= Half;
                }
                else if ((low_dc >= First_qtr) && (high_dc < Third_qtr))
                {
                        value_dc -= First_qtr;
                        low_dc -= First_qtr;
                        high_dc -= First_qtr;
                }
                else
                {
                        break;
                }

                low_dc = 2 * low_dc;
                high_dc = 2 * high_dc + 1;
                value_dc = 2 * value_dc + input_bit(InBloc, pusInCount);
                if (Error != RV_SUCCESS)
                {
                        break;
                }
        }

        return (symbol);
}

/******************************************************************************/

int AcAd8_Encode(BLOC *pInBloc, BLOC *pOutBloc)
{
        int                     i, ch;
        unsigned int        symbol;
        unsigned short int      usInCount = 0;
        unsigned short int      usOutCount = 0;

        MemoSize = pInBloc->usLen;
        Memory   = GMEM_Alloc (MemoSize);

        if (Memory == NULL)
        {
                return (RV_MALLOC_FAILED);
        }

        start_model(ADAPTATIVE_MODEL);
        start_outputing_bits();
        start_encoding();

        for (usInCount = 0; usInCount < pInBloc->usLen; usInCount++)
        {
           ch = pInBloc->pData[usInCount];
           symbol = char_to_index[ch];
           if (encode_symbol(&usOutCount, symbol, cum_freq) != RV_SUCCESS)
           {
                   goto err;
           }
           update_model(ADAPTATIVE_MODEL, symbol);
        }

        if (encode_symbol(&usOutCount, EOF_symbol, cum_freq) != RV_SUCCESS)
        {
                goto err;
        }
        if (done_encoding(&usOutCount) != RV_SUCCESS)
        {
                goto err;
        }
        if (done_outputing_bits(&usOutCount) != RV_SUCCESS)
        {
                goto err;
        }

        pOutBloc->usLen = usOutCount;
        pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen);

        if (pOutBloc->pData != NULL)
        {
           for (i=0; i < pOutBloc->usLen; i++)
           {
                   pOutBloc->pData[i] = Memory[i];
           }

           GMEM_Free(Memory);
           return (RV_SUCCESS);
        }
        else
        {
           pOutBloc->usLen = 0;
           pOutBloc->pData = NULL;

           GMEM_Free(Memory);
           return (RV_MALLOC_FAILED);
        }

err:
        GMEM_Free(Memory);

        pOutBloc->usLen = pInBloc->usLen;
        pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen);

        if (pOutBloc->pData != NULL)
        {
           for (i=0; i < pOutBloc->usLen; i++)
           {
                   pOutBloc->pData[i] = pInBloc->pData[i];
           }

           return (RV_COMPRESSION_FAILED);
        }
        else
        {
           pOutBloc->usLen = 0;
           pOutBloc->pData = NULL;

           return (RV_MALLOC_FAILED);
        }
}

/******************************************************************************/

int AcFx8_Encode(BLOC *pInBloc, BLOC *pOutBloc)
{
        int                     i, ch;
        unsigned int        symbol;
        unsigned short int      usInCount = 0;
        unsigned short int      usOutCount = 0;

        MemoSize = pInBloc->usLen;
        Memory   = GMEM_Alloc (MemoSize);

        if (Memory == NULL)
        {
                return (RV_MALLOC_FAILED);
        }

        start_model(FIXED_MODEL);
        start_outputing_bits();
        start_encoding();

        for (usInCount = 0; usInCount < pInBloc->usLen; usInCount++)
        {
           ch = pInBloc->pData[usInCount];
           symbol = char_to_index[ch];
           if (encode_symbol(&usOutCount, symbol, cum_freq) != RV_SUCCESS)
           {
                   goto err;
           }
           update_model(FIXED_MODEL, symbol);
        }

        if (encode_symbol(&usOutCount, EOF_symbol, cum_freq))
        {
                goto err;
        }
        if (done_encoding(&usOutCount) != RV_SUCCESS)
        {
                goto err;
        }
        if (done_outputing_bits(&usOutCount) != RV_SUCCESS)
        {
                goto err;
        }

        pOutBloc->usLen = usOutCount;
        pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen);

        if (pOutBloc->pData != NULL)
        {
           for (i=0; i < pOutBloc->usLen; i++)
           {
                   pOutBloc->pData[i] = Memory[i];
           }

           GMEM_Free(Memory);
           return (RV_SUCCESS);
        }
        else
        {
           pOutBloc->usLen = 0;
           pOutBloc->pData = NULL;

           GMEM_Free(Memory);
           return (RV_MALLOC_FAILED);
        }

err:
        GMEM_Free(Memory);

        pOutBloc->usLen = pInBloc->usLen;
        pOutBloc->pData = GMEM_Alloc(pOutBloc->usLen);

        if (pOutBloc->pData != NULL)
        {
           for (i=0; i < pOutBloc->usLen; i++)
           {
                   pOutBloc->pData[i] = pInBloc->pData[i];
           }

           return (RV_COMPRESSION_FAILED);
        }
        else
        {
           pOutBloc->usLen = 0;
           pOutBloc->pData = NULL;

           return (RV_MALLOC_FAILED);
        }
}


/******************************************************************************/

int AcAd8_Decode(BLOC *pInBloc, BLOC *pOutBloc)
{
        unsigned  int   ch;
        unsigned  int   symbol;
        unsigned short int      usInCount = 0;
        unsigned short int      usOutCount = 0;

        MemoSize = 2*pInBloc->usLen;
        Memory   = GMEM_Alloc(MemoSize);
        if (Memory == NULL)
        {
                pOutBloc->pData = NULL;
                pOutBloc->usLen = 0;
                return (RV_MALLOC_FAILED);
        }

        start_model(ADAPTATIVE_MODEL);
        start_inputing_bits();
        start_decoding(*pInBloc, &usInCount);

        while(1)
        {
                symbol = decode_symbol(*pInBloc, &usInCount, cum_freq);
            if ((symbol == EOF_symbol) || (Error != RV_SUCCESS))
                {
                   break;
                }

                ch = index_to_char[symbol];

                if (usOutCount >= MemoSize)
                {
                        Memory = GMEM_ReAlloc (Memory, 2*MemoSize);
                        if (Memory == NULL)
                        {
                                pOutBloc->pData = NULL;
                                pOutBloc->usLen = 0;
                                return (RV_MALLOC_FAILED);
                        }
                        MemoSize = MemoSize*2;
                }

                Memory[usOutCount++] = (BYTE)ch;
                update_model(ADAPTATIVE_MODEL, symbol);
        }

        if (Error != RV_SUCCESS)
        {
                GMEM_Free (Memory);
                pOutBloc->pData = NULL;
                pOutBloc->usLen = 0;
                return (Error);
        }

        pOutBloc->pData = GMEM_Alloc(usOutCount);
        if (pOutBloc->pData == NULL)
        {
                GMEM_Free (Memory);
                pOutBloc->usLen = 0;
                return (RV_MALLOC_FAILED);
        }

        pOutBloc->usLen = usOutCount;
        memcpy(pOutBloc->pData, Memory, usOutCount);
        GMEM_Free (Memory);

        return (RV_SUCCESS);
}

/******************************************************************************/

int AcFx8_Decode(BLOC *pInBloc, BLOC *pOutBloc)
{
        unsigned  int   i, ch;
        unsigned  int   symbol;
        unsigned short int      usInCount = 0;
        unsigned short int      usOutCount = 0;

        MemoSize = 2*pInBloc->usLen;
        Memory   = GMEM_Alloc(MemoSize);
        if (Memory == NULL)
        {
                pOutBloc->pData = NULL;
                pOutBloc->usLen = 0;
                return (RV_MALLOC_FAILED);
        }

        start_model(FIXED_MODEL);
        start_inputing_bits();
        start_decoding(*pInBloc, &usInCount);

        while(1)
        {
                symbol = decode_symbol(*pInBloc, &usInCount, cum_freq);
            if ((symbol == EOF_symbol) || (Error != RV_SUCCESS))
                {
                   break;
                }

                ch = index_to_char[symbol];

                if (usOutCount >= MemoSize)
                {
                        Memory = GMEM_ReAlloc (Memory, 2*MemoSize);
                        if (Memory == NULL)
                        {
                                pOutBloc->pData = NULL;
                                pOutBloc->usLen = 0;
                                return (RV_MALLOC_FAILED);
                        }
                        MemoSize = MemoSize*2;
                }

                Memory[usOutCount++] = (BYTE)ch;
                update_model(FIXED_MODEL, symbol);
        }

        if (Error != RV_SUCCESS)
        {
                GMEM_Free (Memory);
                pOutBloc->pData = NULL;
                pOutBloc->usLen = 0;
                return (Error);
        }

        pOutBloc->pData = GMEM_Alloc(usOutCount);
        if (pOutBloc->pData == NULL)
        {
                GMEM_Free (Memory);
                pOutBloc->usLen = 0;
                return (RV_MALLOC_FAILED);
        }

        pOutBloc->usLen = usOutCount;
        for (i=0; i<pOutBloc->usLen; i++)
        {
                pOutBloc->pData[i] = Memory[i];
        }
        GMEM_Free (Memory);

        return (RV_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\autoreg.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    autoreg

Abstract:

    This module provides autoregistration capabilities to a CSP.  It allows
    regsvr32 to call the DLL directly to add and remove Registry settings.

Author:

    Doug Barlow (dbarlow) 3/11/1998
	Update for gemplus  PY Roy	22/03/00

Environment:

    Win32

Notes:

    Look for "?vendor?" tags and edit appropriately.

--*/
#ifdef _UNICODE
#define UNICODE
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifdef _AFXDLL
#include "stdafx.h"
#else
#include <windows.h>
#endif
#include <wincrypt.h>
#include <winscard.h>
#include <tchar.h>
#include <malloc.h>
#include <cspdk.h>


struct CardInfo
{
   PTCHAR		  szCardName;
   int            lenATR;
   const BYTE*    ATR;
   const BYTE*    ATRMask;
};



///////////////////////////////////////////////////////////////////////////////////////////
//
// Constants
//
///////////////////////////////////////////////////////////////////////////////////////////

static const TCHAR l_szProviderName[]
#ifdef MS_BUILD
    = TEXT("Gemplus GemSAFE Card CSP v1.0");
#else
    = TEXT("Gemplus GemSAFE Card CSP");
#endif
//        = TEXT("?vendor? <Add your Provider Name Here>");

const BYTE c_GPK4000ATR[]     = { 0x3B, 0x27, 0x00, 0x80, 0x65, 0xA2, 0x04, 0x01, 0x01, 0x37 };
const BYTE c_GPK4000ATRMask[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE5, 0xFF, 0xFF, 0xFF };

const BYTE c_GPK8000ATR[]     = { 0x3B, 0xA7, 0x00, 0x40, 0x00, 0x80, 0x65, 0xA2, 0x08, 0x00, 0x00, 0x00 };
const BYTE c_GPK8000ATRMask[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00 };

//    l_rgbATR[]     = { ?vendor? <Add your ATR here> },
//    l_rgbATRMask[] = { ?vendor? <Add your ATR Mask here> };


CardInfo c_cards[] =
{
   { TEXT("GemSAFE Smart Card (4K)"), sizeof(c_GPK4000ATR), c_GPK4000ATR, c_GPK4000ATRMask },
   { TEXT("GemSAFE Smart Card (8K)"), sizeof(c_GPK8000ATR), c_GPK8000ATR, c_GPK8000ATRMask }
};



// = ( TEXT("?vendor? <Add your Smart Card Friendly Name Here>");

static HMODULE
GetInstanceHandle(
    void);

static const DWORD
    l_dwCspType
// ?vendor?  Change this to match your CSP capabilities
    = PROV_RSA_FULL;

typedef DWORD
    (__stdcall *LPSETCARDTYPEPROVIDERNAME)(
                                IN SCARDCONTEXT hContext,
                                IN LPCTSTR szCardName,
                                IN DWORD dwProviderId,
                                IN LPCTSTR szProvider);

///////////////////////////////////////////////////////////////////////////////////////////
//
// IntroduceCard
//
// Introduce the vendor card.  Try various techniques until one works.
//
//
///////////////////////////////////////////////////////////////////////////////////////////

namespace
{
   HRESULT ForgetCard(const PTCHAR szCardName)
   {
      bool    bCardForgeted = false;
      HRESULT hReturnStatus = NO_ERROR;

      // Try different methods until one works
      for ( int method = 0; !bCardForgeted; ++method )
      {
         switch (method)
         {
            case 0:
            {
               SCARDCONTEXT hContext = 0;
               DWORD dwStatus;

               dwStatus = SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hContext);
               if (ERROR_SUCCESS != dwStatus)
                  continue;

               dwStatus = SCardForgetCardType(hContext, szCardName);

               if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_FILE_NOT_FOUND)
               {
                  if (0 == (dwStatus & 0xffff0000))
                     hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                  else
                     hReturnStatus = (HRESULT)dwStatus;
                  return hReturnStatus;
               }

               dwStatus = SCardReleaseContext(hContext);
               hContext = 0;
               
               if (dwStatus != ERROR_SUCCESS)
               {
                  if (0 == (dwStatus & 0xffff0000))
                     hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
                  else
                     hReturnStatus = (HRESULT)dwStatus;
                  return hReturnStatus;
               }

               bCardForgeted = true;
            }            
            break;

            case 1:
            {
               HKEY  hCalais = NULL;
               DWORD dwDisp;
               LONG  nStatus;

               nStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
                                        0,
                                        TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hCalais,
                                        &dwDisp);

               if (ERROR_SUCCESS != nStatus)
                  continue;

               nStatus = RegDeleteKey(hCalais,
                                      szCardName);

               if (nStatus != ERROR_SUCCESS && nStatus != ERROR_FILE_NOT_FOUND)
               {
                  hReturnStatus = HRESULT_FROM_WIN32(nStatus);

                  if (NULL != hCalais)
                     RegCloseKey(hCalais);

                  return hReturnStatus;
               }

               nStatus = RegCloseKey(hCalais);
               hCalais = NULL;

               if (ERROR_SUCCESS != nStatus)
               {
                  hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                  return hReturnStatus;
               }

               bCardForgeted = true;
            }
            break;

            default:
               hReturnStatus = ERROR_ACCESS_DENIED;
               return hReturnStatus;
         }
      }

      return hReturnStatus;
   }
   
   HRESULT IntroduceCard( const PTCHAR szCardName, int lenATR, const BYTE* ATR, const BYTE* ATRMask )
   {
      bool bCardIntroduced = false;
      HRESULT hReturnStatus = NO_ERROR;
      HKEY hCalais = NULL;
      HKEY hVendor = NULL;
	   DWORD dwDisp;
      LONG nStatus;


     
      // Try different methods until one works
      for ( int method = 0; !bCardIntroduced; ++method )
      {
         switch (method)
         {
         case 0:
            {
               HINSTANCE hWinSCard                                 = 0;
               LPSETCARDTYPEPROVIDERNAME pfSetCardTypeProviderName = 0;
               DWORD     dwStatus;
               
               hWinSCard = GetModuleHandle(TEXT("WinSCard.DLL"));
               if (hWinSCard==0)
                  continue;

#if defined(UNICODE)
               pfSetCardTypeProviderName = (LPSETCARDTYPEPROVIDERNAME)GetProcAddress( hWinSCard, "SCardSetCardTypeProviderNameW"); //TEXT("SCardSetCardTypeProviderNameW") );		
#else
               pfSetCardTypeProviderName = (LPSETCARDTYPEPROVIDERNAME)GetProcAddress( hWinSCard, "SCardSetCardTypeProviderNameA");
#endif
               if (pfSetCardTypeProviderName==0)
                  continue;
               
               dwStatus = SCardIntroduceCardType( 0, szCardName, 0, 0, 0, ATR, ATRMask, lenATR );
               
               if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_ALREADY_EXISTS)
                  continue;

               dwStatus = (*pfSetCardTypeProviderName)( 0, szCardName, SCARD_PROVIDER_CSP, l_szProviderName );

               if (dwStatus != ERROR_SUCCESS)
			   {
					if (0 == (dwStatus & 0xffff0000))
						hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
					else
						hReturnStatus = (HRESULT)dwStatus;
					return hReturnStatus;
			   }

               bCardIntroduced = true;
            }
            break;
            

         case 1:
            {
               SCARDCONTEXT   hContext = 0;
               DWORD          dwStatus;

               dwStatus = SCardEstablishContext( SCARD_SCOPE_SYSTEM, 0, 0, &hContext );
               if (ERROR_SUCCESS != dwStatus)
                  continue;

               dwStatus = SCardIntroduceCardType( hContext, szCardName, 0, 0, 0, ATR, ATRMask, lenATR );

               if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_ALREADY_EXISTS)
			   {
					if (0 == (dwStatus & 0xffff0000))
						hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
					else
						hReturnStatus = (HRESULT)dwStatus;
					return hReturnStatus;
			   }

               dwStatus = SCardReleaseContext(hContext);
               hContext = 0;
               
               if (dwStatus != ERROR_SUCCESS)
			   {
					if (0 == (dwStatus & 0xffff0000))
						hReturnStatus = HRESULT_FROM_WIN32(dwStatus);
					else
						hReturnStatus = (HRESULT)dwStatus;
					return hReturnStatus;
			   }

			   nStatus = RegCreateKeyEx(
										HKEY_LOCAL_MACHINE,
										TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
										0,
										TEXT(""),
										REG_OPTION_NON_VOLATILE,
										KEY_ALL_ACCESS,
										NULL,
										&hCalais,
										&dwDisp);
			   if (ERROR_SUCCESS != nStatus)
			   {
					hReturnStatus = HRESULT_FROM_WIN32(nStatus);
					if (NULL != hCalais)
						RegCloseKey(hCalais);
 					return hReturnStatus;
			   }
			   nStatus = RegCreateKeyEx(
										hCalais,
										szCardName,
										0,
										TEXT(""),
										REG_OPTION_NON_VOLATILE,
										KEY_ALL_ACCESS,
										NULL,
										&hVendor,
										&dwDisp);
			   if (ERROR_SUCCESS != nStatus)
			   {
					hReturnStatus = HRESULT_FROM_WIN32(nStatus);
					if (NULL != hCalais)
						RegCloseKey(hCalais);
					if (NULL != hVendor)
						RegCloseKey(hVendor);
					return hReturnStatus;
			   }
			   nStatus = RegCloseKey(hCalais);
			   hCalais = NULL;
			   if (ERROR_SUCCESS != nStatus)
			   {
					hReturnStatus = HRESULT_FROM_WIN32(nStatus);
					if (NULL != hVendor)
						RegCloseKey(hVendor);
					return hReturnStatus;
			   }
			   nStatus = RegSetValueEx(
									   hVendor,
									   TEXT("Crypto Provider"),
									   0,
									   REG_SZ,
									   (LPBYTE)l_szProviderName,
									   (_tcslen(l_szProviderName) + 1) * sizeof(TCHAR));
			   if (ERROR_SUCCESS != nStatus)
			   {
					hReturnStatus = HRESULT_FROM_WIN32(nStatus);
					if (NULL != hVendor)
						RegCloseKey(hVendor);
					return hReturnStatus;
			   }

			   nStatus = RegCloseKey(hVendor);
			   hVendor = NULL;
			   if (ERROR_SUCCESS != nStatus)
			   {
					hReturnStatus = HRESULT_FROM_WIN32(nStatus);
					return hReturnStatus;
			   }

               bCardIntroduced = true;
            }            
            break;

		 case 2:
            nStatus = RegCreateKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
                                    0,
                                    TEXT(""),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hCalais,
                                    &dwDisp);
            if (ERROR_SUCCESS != nStatus)
                continue;
            nStatus = RegCreateKeyEx(
                                    hCalais,
                                    szCardName,
                                    0,
                                    TEXT(""),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hVendor,
                                    &dwDisp);
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hCalais)
					RegCloseKey(hCalais);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
            nStatus = RegCloseKey(hCalais);
            hCalais = NULL;
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
/*
            nStatus = RegSetValueEx(
                            hVendor,
                            TEXT("Primary Provider"),
                            0,
                            REG_BINARY,
                            (LPCBYTE)&l_guidPrimaryProv,
                            sizeof(l_guidPrimaryProv));
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
*/
            nStatus = RegSetValueEx(
                                   hVendor,
                                   TEXT("ATR"),
                                   0,
                                   REG_BINARY,
                                   ATR,
                                   lenATR);
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
            nStatus = RegSetValueEx(
                                   hVendor,
                                   TEXT("ATRMask"),
                                   0,
                                   REG_BINARY,
                                   ATRMask,
                                   lenATR);
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
            nStatus = RegSetValueEx(
                                   hVendor,
                                   TEXT("Crypto Provider"),
                                   0,
                                   REG_SZ,
                                   (LPBYTE)l_szProviderName,
                                   (_tcslen(l_szProviderName) + 1) * sizeof(TCHAR));
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
				if (NULL != hVendor)
					RegCloseKey(hVendor);
                return hReturnStatus;
            }
            nStatus = RegCloseKey(hVendor);
            hVendor = NULL;
            if (ERROR_SUCCESS != nStatus)
            {
                hReturnStatus = HRESULT_FROM_WIN32(nStatus);
                return hReturnStatus;
            }
            bCardIntroduced = TRUE;
            break;
            
         default:
            hReturnStatus = ERROR_ACCESS_DENIED;
            return hReturnStatus;
         }
      }

	return hReturnStatus;
   }
}



/*++

DllUnregisterServer:

    This service removes the registry entries associated with this CSP.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 3/11/1998

--*/

STDAPI
    DllUnregisterServer(
                       void)
{
    LONG nStatus;
    DWORD dwDisp;
    HRESULT hReturnStatus = NO_ERROR;
    HKEY hProviders = NULL;
    SCARDCONTEXT hCtx = NULL;

#ifdef _AFXDLL
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif


    //
    // Delete the Registry key for this CSP.
    //

    nStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hProviders,
                            &dwDisp);
    if (ERROR_SUCCESS == nStatus)
    {
        RegDeleteKey(hProviders, l_szProviderName);
        RegCloseKey(hProviders);
        hProviders = NULL;
    }


    //
    // Forget the card type.
    //

    //hCtx = NULL;
    //SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCtx);
    
    //if (NULL != hCtx)
    //{
	 //	int nbCard = sizeof(c_cards) / sizeof(c_cards[0]);

	 //	for (int i = 0; i < nbCard; ++i)
	 //	{
	 //		 SCardForgetCardType( hCtx, c_cards[i].szCardName );
	 //	}
	 //}

    //if (NULL != hCtx)
    //{
    //    SCardReleaseContext(hCtx);
    //    hCtx = NULL;
    //}
    int nbCard = sizeof(c_cards) / sizeof(c_cards[0]);
    int i = 0;
    while ( (i < nbCard) && (hReturnStatus == NO_ERROR) )
    {
       hReturnStatus &= ForgetCard(c_cards[i].szCardName);
       i++;
    }

    //
    // ?vendor?
    // Delete vendor specific registry entries.
    //

    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Gemplus"));


    //
    // All done!
    //

    return hReturnStatus;
}


/*++

DllRegisterServer:

    This function installs the proper registry entries to enable this CSP.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 3/11/1998

--*/

STDAPI
    DllRegisterServer(
                     void)
{
    TCHAR szModulePath[MAX_PATH+1];
    BYTE pbSignature[136];  // Room for a 1024 bit signature, with padding.
    OSVERSIONINFO osVer;
    LPTSTR szFileName, szFileExt;
    HINSTANCE hThisDll;
    HRSRC hSigResource;
    DWORD dwStatus;
    LONG nStatus;
    BOOL fStatus;
    DWORD dwDisp;
    DWORD dwIndex;
    DWORD dwSigLength;
    HRESULT hReturnStatus = NO_ERROR;
    HKEY hProviders = NULL;
    HKEY hMyCsp = NULL;
    BOOL fSignatureFound = FALSE;
    HANDLE hSigFile = INVALID_HANDLE_VALUE;
    SCARDCONTEXT hCtx = NULL;
    HKEY hGpk = NULL;

#ifdef _AFXDLL
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif


    //
    // Figure out the file name and path.
    //

    hThisDll = GetInstanceHandle();
    if (NULL == hThisDll)
    {
        hReturnStatus = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        goto ErrorExit;
    }

    dwStatus = GetModuleFileName(
                                hThisDll,
                                szModulePath,
                                sizeof(szModulePath) / sizeof(TCHAR)-1);
    szModulePath[dwStatus]=0;
    if (0 == dwStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    szFileName = _tcsrchr(szModulePath, TEXT('\\'));
    if (NULL == szFileName)
        szFileName = szModulePath;
    else
        szFileName += 1;
    szFileExt = _tcsrchr(szFileName, TEXT('.'));
    if ((NULL == szFileExt) || (_tcslen(szFileExt)<4))
    {
        hReturnStatus = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        goto ErrorExit;
    }
    else
        szFileExt += 1;


    //
    // Create the Registry key for this CSP.
    //

    nStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hProviders,
                            &dwDisp);
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }
    nStatus = RegCreateKeyEx(
                            hProviders,
                            l_szProviderName,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hMyCsp,
                            &dwDisp);
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }
    nStatus = RegCloseKey(hProviders);
    hProviders = NULL;
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }


    //
    // Install the trivial registry values.
    //

    nStatus = RegSetValueEx(
                           hMyCsp,
                           TEXT("Image Path"),
                           0,
                           REG_SZ,
                           (LPBYTE)szFileName,
                           (_tcslen(szFileName) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }

    nStatus = RegSetValueEx(
                           hMyCsp,
                           TEXT("Type"),
                           0,
                           REG_DWORD,
                           (LPBYTE)&l_dwCspType,
                           sizeof(DWORD));
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }


    //
    // See if we're self-signed.  On NT5, CSP images can carry their own
    // signatures.
    //

    hSigResource = FindResource(
                               hThisDll,
                               MAKEINTRESOURCE(CRYPT_SIG_RESOURCE_NUMBER),
                               RT_RCDATA);


    //
    // Install the file signature.
    //

    ZeroMemory(&osVer, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    fStatus = GetVersionEx(&osVer);
    if (fStatus
        && (VER_PLATFORM_WIN32_NT == osVer.dwPlatformId)
        && (5 <= osVer.dwMajorVersion)
        && (NULL != hSigResource))
    {

        //
        // Signature in file flag is sufficient.
        //

        dwStatus = 0;
        nStatus = RegSetValueEx(
                               hMyCsp,
                               TEXT("SigInFile"),
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwStatus,
                               sizeof(DWORD));
        if (ERROR_SUCCESS != nStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(nStatus);
            goto ErrorExit;
        }
    }
    else
    {

        //
        // We have to install a signature entry.
        // Try various techniques until one works.
        //

        for (dwIndex = 0; !fSignatureFound; dwIndex += 1)
        {
            switch (dwIndex)
            {

            //
            // Look for an external *.sig file and load that into the registry.
            //

            case 0:
                _tcscpy(szFileExt, TEXT("sig"));
                hSigFile = CreateFile(
                                     szModulePath,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);
                if (INVALID_HANDLE_VALUE == hSigFile)
                    continue;
                dwSigLength = GetFileSize(hSigFile, NULL);
                if ((dwSigLength > sizeof(pbSignature))
                    || (dwSigLength < 72))      // Accept a 512-bit signature
                {
                    hReturnStatus = NTE_BAD_SIGNATURE;
                    goto ErrorExit;
                }

                fStatus = ReadFile(
                                  hSigFile,
                                  pbSignature,
                                  sizeof(pbSignature),
                                  &dwSigLength,
                                  NULL);
                if (!fStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }
                fStatus = CloseHandle(hSigFile);
                hSigFile = NULL;
                if (!fStatus)
                {
                    hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }
                fSignatureFound = TRUE;
                break;


            //
            // Other cases may be added in the future.
            //

            default:
                hReturnStatus = NTE_BAD_SIGNATURE;
                goto ErrorExit;
            }

            if (fSignatureFound)
            {
                for (dwIndex = 0; dwIndex < dwSigLength; dwIndex += 1)
                {
                    if (0 != pbSignature[dwIndex])
                        break;
                }
                if (dwIndex >= dwSigLength)
                    fSignatureFound = FALSE;
            }
        }


        //
        // We've found a signature somewhere!  Install it.
        //

        nStatus = RegSetValueEx(
                               hMyCsp,
                               TEXT("Signature"),
                               0,
                               REG_BINARY,
                               pbSignature,
                               dwSigLength);
        if (ERROR_SUCCESS != nStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(nStatus);
            goto ErrorExit;
        }
    }

    nStatus = RegCloseKey(hMyCsp);
    hMyCsp = NULL;
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }


    //
    // Introduce the vendor card.  Try various techniques until one works.
    //
	{
	   int nbCard = sizeof(c_cards) / sizeof(c_cards[0]);
	   int i = 0;
	   while ( (i < nbCard) && (hReturnStatus == NO_ERROR) )
	   {
		  hReturnStatus &= IntroduceCard( c_cards[i].szCardName, c_cards[i].lenATR, c_cards[i].ATR, c_cards[i].ATRMask );
		  i++;
	   }
	}

   if (hReturnStatus != NO_ERROR)
      goto ErrorExit;


    //
    // ?vendor?
    // Add any additional initialization required here.
    //
	// Add the GemSAFE card list and Dictionary name

    nStatus = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Gemplus\\Cryptography\\SmartCards\\GemSAFE"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hGpk,
                            &dwDisp);
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }

    // prepare the card list
	{
		int nbCard = sizeof(c_cards) / sizeof(c_cards[0]);
		int i;
		int sizeofCardList = 0;
		int CardListLen = 0;
		BYTE *pmszCardList ;
		BYTE *ptmpCardList ;

		for ( i = 0; i < nbCard; ++i)
		{
			sizeofCardList += (_tcslen(c_cards[i].szCardName) + 1);						
		}
		sizeofCardList++;

		pmszCardList = (BYTE *) malloc(sizeofCardList);
		if(!pmszCardList)
		{
			hReturnStatus=HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
			goto ErrorExit;
		}
		ptmpCardList= pmszCardList;
		for ( i = 0; i < nbCard; ++i)
		{
#ifndef UNICODE
			strcpy((char*)ptmpCardList, c_cards[i].szCardName);
#else
			WideCharToMultiByte(CP_ACP, 0, c_cards[i].szCardName, -1, (char*)ptmpCardList, sizeofCardList - CardListLen, 0, 0);
#endif
			CardListLen += _tcslen(c_cards[i].szCardName) + 1;
			ptmpCardList += _tcslen(c_cards[i].szCardName);
			*ptmpCardList = 0;
			ptmpCardList ++;
			
		}
		*ptmpCardList = 0;

		nStatus = RegSetValueEx(hGpk,
							   TEXT("Card List"),
							   0,
							   REG_BINARY,
							   pmszCardList,
							   sizeofCardList);
		free(pmszCardList);
	}

    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
		RegCloseKey(hGpk);
		hGpk = NULL;
        goto ErrorExit;
    }

    nStatus = RegCloseKey(hGpk);
    hGpk = NULL;
    if (ERROR_SUCCESS != nStatus)
    {
        hReturnStatus = HRESULT_FROM_WIN32(nStatus);
        goto ErrorExit;
    }



    // Forget "GemSAFE card"

    //hCtx = NULL;
    //SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCtx);
    
    //if (NULL != hCtx)
    //{
	 //	 SCardForgetCardType( hCtx, "GemSAFE" );
    //}

    //if (NULL != hCtx)
    //{
    //    SCardReleaseContext(hCtx);
    //    hCtx = NULL;
    //}
    hReturnStatus = ForgetCard(TEXT("GemSAFE"));

    if (hReturnStatus != NO_ERROR)
       goto ErrorExit;

    //
    // All done!
    //

    return hReturnStatus;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

    ErrorExit:
    if (NULL != hGpk)
        RegCloseKey(hGpk);
    if (NULL != hCtx)
        SCardReleaseContext(hCtx);
    if (INVALID_HANDLE_VALUE != hSigFile)
        CloseHandle(hSigFile);
    if (NULL != hMyCsp)
        RegCloseKey(hMyCsp);
    if (NULL != hProviders)
        RegCloseKey(hProviders);
    DllUnregisterServer();
    return hReturnStatus;
}


/*++

GetInstanceHandle:

    This routine is CSP dependant.  It returns the DLL instance handle.  This
    is typically provided by the DllMain routine and stored in a global
    location.

Arguments:

    None

Return Value:

    The DLL Instance handle provided to the DLL when DllMain was called.

Author:

    Doug Barlow (dbarlow) 3/11/1998

--*/

extern "C" HINSTANCE g_hInstMod;

static HINSTANCE
    GetInstanceHandle(
                     void)
{
#ifdef _AFXDLL
    return AfxGetInstanceHandle();
#else
    return g_hInstMod;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gpkcsp.rc
//
#define IDS_GPKCSP_NAME                 1
#define IDS_GPKCSP_TITLE                2
#define IDS_GPKCSP_OPENDLGTITLE         3
#define IDS_GPKCSP_CARDLIST             4
//#define IDS_GPKCSP_MUTEX                5
#define IDS_GPKCSP_ENTRY                6
#define IDS_GPKCSP_NOGUI                7
#define IDR_RCDATA1                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\gpkgui.c ===
/*******************************************************************************
*           Copyright (C) 1997 Gemplus International   All Rights Reserved
*
* Name        : GPKGUI.C
*
* Description : GUI used by Cryptographic Service Provider for GPK Card.
*
* Author      : Laurent CASSIER
*
*  Compiler    : Microsoft Visual C 6.0
*
* Host        : IBM PC and compatible machines under Windows 32 bit
*
* Release     : 2.00.000
*
* Last Modif. :
*               19/11/99: V2.xx.000 - Fixed bug #1797
*               30/07/99: V2.xx.000 - Added function DisplayMessage()
*                                   - Added code to compile with UNICODE
*                                   - Renamed some resources ID, FP
*               20/04/99: V2.00.000 - Merged versions of PKCS#11 and CSP, FJ
*               20/04/99: V1.00.005 - Modification on supporting MBCS, JQ
*               23/03/99: V1.00.004 - Replace KeyLen7 and KeyLen8 with KeyLen[], JQ
*               05/01/98: V1.00.003 - Add Unblock PIN management.
*               02/11/97: V1.00.002 - Separate code from GpkCsp Code.
*               27/08/97: V1.00.001 - Begin implementation based on CSP kit.
*
********************************************************************************
*
* Warning     : This Version use the RsaBase CSP for software cryptography.
*
* Remark      :
*
*******************************************************************************/
#ifdef _UNICODE
#define UNICODE
#endif
#include "gpkcsp.h"


#define UM_CHANGE_TEXT   WM_USER+1

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "../gpkrsrc/resource.h"
#include "gpkgui.h"




/*-----------------------------------------------------------------------------
  Global Variable and Declaration for PIN an Progress DialogBox management
------------------------------------------------------------------------------*/
HINSTANCE g_hInstMod = 0;
HINSTANCE g_hInstRes = 0;
HWND      g_hMainWnd = 0;

/* PIN DialogBox                                                              */
char    szGpkPin[PIN_MAX+2];     // [JMR 02-04]
TCHAR   szGpkPinGUI[PIN_MAX+2];
DWORD   dwGpkPinLen;
char    szGpkNewPin[PIN_MAX+2];  // [JMR 02-04]
TCHAR   szGpkNewPinGUI[PIN_MAX+2];
WORD    wGpkNewPinLen;

BOOL    bChangePin  = FALSE;
BOOL    NoDisplay   = FALSE;
BOOL    bNewPin     = FALSE;
BOOL    bHideChange = FALSE;//TRUE - Don't display change button
BOOL    bUnblockPin = FALSE;        // Unblock admin pin
BOOL    bUser       = TRUE;         // User pin

// Dialogue Management: share with gpkgui.c !! it was defined in gpkcsp.c

BYTE              KeyLenFile[MAX_REAL_KEY] = {64, 128}; // version 2.00.002
BYTE              KeyLenChoice;
TCHAR             szKeyType[20];
TCHAR             s1[MAX_STRING], s2[MAX_STRING], s3[MAX_STRING];
DWORD             CspFlags;
DWORD             ContainerStatus;

/* ProgressText DialogBox                                                     */
TCHAR   szProgTitle[MAX_STRING];
TCHAR   szProgText[MAX_STRING];
HWND    hProgressDlg = NULL;
FARPROC lpProgressDlg = NULL;
HCURSOR hCursor, hCursor2;

/* Progress DialogBox cancel button, PKCS#11 specific */
TCHAR   szProgButton[32];
BOOL    IsProgButtoned = FALSE;
BOOL    IsProgButtonClick = FALSE;

// not used... [FP]
/*static void wait(DWORD TimeOut)
{
   DWORD begin, end, now;

   begin = GetTickCount();
   end = begin + TimeOut;

   do
   {
      now = GetTickCount();
   }
   while(now < end);
}*/

// This function is used for cosmetic purpose
// It erase text displayed on DialogBox by strink,
// and display new text with "camera" effect
static void set_effect(HWND  hDlg,
                       DWORD Id,
                       TCHAR  *szText
                      )
{
#ifdef _CAMERA_EFFECT_
   TCHAR Buff[256];
   TCHAR Text[256];
   long i, j;

   GetDlgItemText(hDlg, Id, Buff, sizeof(Buff) / sizeof(TCHAR));
   j = _tcslen(Buff);
   for (i = 0; i < (long)(_tcsclen(Buff)/2); i++)
   {
      _tcsset(Text, 0x00);
      _tcsncpy(Text, _tcsninc(Buff,i), j);
      j = j - 2;
      SetDlgItemText(hDlg, Id, Text);
//      wait(50);
   }

   _tcscpy(Buff, szText);
   _tcscat(Buff, TEXT(" "));

   j = 2;
   for (i = _tcsclen(Buff)/2; i >= 0; i--)
   {
      _tcsset(Text, 0x00);
      _tcsncpy(Text, _tcsninc(Buff,i), j);
      j = j + 2;
      SetDlgItemText(hDlg, Id, Text);
//      wait(50);
   }
#else
      SetDlgItemText(hDlg, Id, szText);
#endif
}

/*******************************************************************************
    Function to display a message box with a particular text
*******************************************************************************/
void DisplayMessage( LPTSTR szMsg, LPTSTR szCaption, void* pValue)
{
    TCHAR szTmp[MAX_STRING]=TEXT("");
    TCHAR szTmp1[MAX_STRING]=TEXT("");
    TCHAR szTmp2[MAX_STRING]=TEXT("");
    TCHAR szText[MAX_STRING]=TEXT("");

    if (_tcscmp(TEXT("locked"), szMsg) == 0)
    {
        LoadString(g_hInstRes, IDS_GPKUI_CARDLOCKED, szText, sizeof(szText)/sizeof(TCHAR));
    }
    else if (_tcscmp(TEXT("badpin"), szMsg) == 0)
    {
        LoadString(g_hInstRes, IDS_GPKUI_BADPINCODE, szTmp1, sizeof(szTmp1)/sizeof(TCHAR));
        LoadString(g_hInstRes, IDS_GPKUI_NBRTRYLEFT, szTmp2, sizeof(szTmp2)/sizeof(TCHAR));
		_sntprintf(szTmp, (sizeof(szTmp)/sizeof(TCHAR))-1, TEXT("%s\n%s"), szTmp1, szTmp2);
		szTmp[(sizeof(szTmp)/sizeof(TCHAR))-1]=0;
        _sntprintf(szText, (sizeof(szText)/sizeof(TCHAR))-1, szTmp, *(DWORD *)pValue);
		szText[(sizeof(szText)/sizeof(TCHAR))-1]=0;
    }

    MessageBox(NULL, szText, szCaption, MB_OK | MB_ICONEXCLAMATION);
}

#ifdef UNICODE
//return true if all the wide character in szBuff are in the form 0x00XY, where XY 
//is an 8 bits ASCII character.
//len is the number of TCHAR to check from szBuff
int IsTextASCII16( const PTCHAR szBuff, unsigned int len )
{
   unsigned int i;
   
   for( i = 0; i < len; i++ )
   {
      if( szBuff[i] & 0xFF00 )
      {
         return FALSE;
      }
   }

   return TRUE;
}

#endif

/*------------------------------------------------------------------------------
               Functions for PIN Dialog Box Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK PinDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   static TCHAR Buff[PIN_MAX+2];       // [JMR 02-04]
   static TCHAR szPinMemo[PIN_MAX+2];  // [JMR 02-04]
   static WORD wPinMemoLen;   
   TCHAR szCaption[MAX_STRING];

#ifdef UNICODE
   static TCHAR szPreviousPin[PIN_MAX+2];
   static TCHAR szPreviousPin1[PIN_MAX+2];
   unsigned int len, CurOffset;   
#endif

   switch (message)
   {
      case WM_INITDIALOG:
      {
         TCHAR szUserPin[MAX_STRING];
         TCHAR szSOPin[MAX_STRING];
         TCHAR szTitle[MAX_STRING];

         // Sets window title
         LoadString(g_hInstRes, IDS_GPKUI_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
         SetWindowText(hDlg,szTitle);

         /* Returns the size in bytes */
         LoadString(g_hInstRes, IDS_GPKUI_USERPIN, szUserPin, sizeof(szUserPin) / sizeof(TCHAR));
         LoadString(g_hInstRes, IDS_GPKUI_SOPIN, szSOPin, sizeof(szSOPin) / sizeof(TCHAR));
         set_effect(hDlg, IDC_PINDLGTXT1, TEXT(""));

         LoadString (g_hInstRes, IDS_CAPTION_CHANGEPIN, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDB_CHANGE, szCaption);
         LoadString (g_hInstRes, IDS_CAPTION_OK, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDOK, szCaption);
         LoadString (g_hInstRes, IDS_CAPTION_CANCEL, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDCANCEL, szCaption);

         if (bUser)
         {
            set_effect(hDlg, IDC_PINDLGTXT, szUserPin);
         }
         else
         {
            set_effect(hDlg, IDC_PINDLGTXT, szSOPin);
         }

         if (bHideChange)
         {
            ShowWindow(GetDlgItem(hDlg, IDB_CHANGE), FALSE);
         }

         if (bUnblockPin)
         {
            ShowWindow(GetDlgItem(hDlg, IDB_CHANGE), FALSE);
            if (bNewPin)
            {
               TCHAR szNewUserPin[256];
               TCHAR szNewSOPin[256];

               /* Returns the size in bytes */
               LoadString(g_hInstRes, IDS_GPKUI_NEWUSERPIN, szNewUserPin, sizeof(szNewUserPin) / sizeof(TCHAR));
               LoadString(g_hInstRes, IDS_GPKUI_NEWSOPIN, szNewSOPin, sizeof(szNewSOPin) / sizeof(TCHAR));

               ShowWindow(GetDlgItem(hDlg, IDC_PIN1), SW_SHOW);
               if (bUser)
               {
                  set_effect(hDlg, IDC_PINDLGTXT, szNewUserPin);
               }
               else
               {
                  set_effect(hDlg, IDC_PINDLGTXT, szNewSOPin);
               }
               SetDlgItemText(hDlg, IDC_PIN, TEXT(""));
               SetDlgItemText(hDlg, IDC_PIN1, TEXT(""));
               SetFocus(GetDlgItem(hDlg, IDC_PIN));
            }
            else
            {
               TCHAR szPinLocked[256];
               TCHAR szUnblockCode[256];

               /* Returns the size in bytes */
               LoadString(g_hInstRes, IDS_GPKUI_PINLOCKED, szPinLocked, sizeof(szPinLocked) / sizeof(TCHAR));
               LoadString(g_hInstRes, IDS_GPKUI_UNBLOCKCODE, szUnblockCode, sizeof(szUnblockCode) / sizeof(TCHAR));

               set_effect(hDlg, IDC_PINDLGTXT1, szPinLocked);
               set_effect(hDlg, IDC_PINDLGTXT, szUnblockCode);
            }
         }

         SetFocus(GetDlgItem(hDlg, IDC_PIN));
         return(TRUE);
      }

      case WM_COMMAND:
      {
         switch(LOWORD(wParam))
         {
            case IDC_PIN:
            case IDC_PIN1:
            {
               WORD wPin1, wPin2;

               if (  (LOWORD(wParam) == IDC_PIN)
                   &&(HIWORD(wParam) == EN_SETFOCUS)
                   &&(bChangePin)
                  )
               {
                  TCHAR szNewUserPin[MAX_STRING];
                  TCHAR szNewSOPin[MAX_STRING];

                  /* Returns the size in bytes */
                  LoadString(g_hInstRes, IDS_GPKUI_NEWUSERPIN, szNewUserPin, sizeof(szNewUserPin) / sizeof(TCHAR));
                  LoadString(g_hInstRes, IDS_GPKUI_NEWSOPIN, szNewSOPin, sizeof(szNewSOPin) / sizeof(TCHAR));

                  if (bUser)
                  {
                     set_effect(hDlg, IDC_PINDLGTXT, szNewUserPin);
                  }
                  else
                  {
                     set_effect(hDlg, IDC_PINDLGTXT, szNewSOPin);
                  }

                  // + [FP] In the change password case, the confirmation box must be cleared
                  //SetDlgItemText(hDlg, IDC_PIN1, TEXT(""));
                  // - [FP]
                  break;
               }

               if (  (LOWORD(wParam) == IDC_PIN1)
                   &&(HIWORD(wParam) == EN_SETFOCUS)
                  )
               {
                  wPin1 = (WORD)GetDlgItemText(hDlg,
                                              IDC_PIN,
                                              Buff,
                                              sizeof(Buff)/sizeof(TCHAR)
                                             );
                  if (wPin1)
                  {
                     TCHAR szConfirmNewUserPin[MAX_STRING];
                     TCHAR szConfirmNewSOPin[MAX_STRING];

                     memset(Buff, 0, sizeof(Buff));
					 if(Buff[0]) { MessageBeep(0); } // to prevent compiler from optimization
					 LoadString(g_hInstRes, IDS_GPKUI_CONFIRMNEWUSERPIN, szConfirmNewUserPin, sizeof(szConfirmNewUserPin) / sizeof(TCHAR));
                     LoadString(g_hInstRes, IDS_GPKUI_CONFIRMNEWSOPIN, szConfirmNewSOPin, sizeof(szConfirmNewSOPin) / sizeof(TCHAR));

                     if (bUser)
                     {
                        set_effect(hDlg, IDC_PINDLGTXT, szConfirmNewUserPin);
                     }
                     else
                     {
                        set_effect(hDlg, IDC_PINDLGTXT, szConfirmNewSOPin);
                     }
                     // + [FP] This box should never be grayed out
                     // EnableWindow(GetDlgItem(hDlg, IDC_PIN), FALSE);
                     // - [FP]
                  }
				  // [FP] SCR #50 (MS #310718)
                  //else
                  //{
                  //   SetFocus(GetDlgItem(hDlg, IDC_PIN));
                  //}
                  break;
               }               

               if (HIWORD(wParam) == EN_CHANGE)
               {
                  wPin1 = (WORD)GetDlgItemText(hDlg,
                                               IDC_PIN,
                                               Buff,
                                               sizeof(Buff)/sizeof(TCHAR)
                                              );
#ifdef UNICODE       
                  len = _tcsclen( Buff );

                  //get the current offset of the cursor in the entry field
                  SendDlgItemMessage( hDlg, IDC_PIN, EM_GETSEL, (WPARAM) NULL, (WPARAM)(LPDWORD)&CurOffset);

                  //verify if there is a character that is not an ASCII 16 bits
                  if( !IsTextASCII16( Buff, len ) )
                  {           					 
                     //replace the new PIN in the dlg with the previous
                     memcpy( Buff, szPreviousPin, sizeof(szPreviousPin) );
                     MessageBeep( MB_ICONEXCLAMATION );
                     set_effect( hDlg, IDC_PIN, Buff );                     
					      //adjust the offset of the cursor
					      CurOffset = CurOffset - (len - _tcsclen(szPreviousPin));
                     SendDlgItemMessage( hDlg, IDC_PIN, EM_SETSEL, CurOffset, CurOffset );
                     break;
                  }
                  else
                  {
                     //replace the previous PIN with the new 
                     memcpy( szPreviousPin, Buff, sizeof(Buff) );
                  }
#endif
				  memset(Buff, 0, sizeof(Buff));
				  if(Buff[0]) { MessageBeep(0); } // to prevent compiler from optimization

                  if ((bChangePin) || ((bUnblockPin) && (bNewPin)))
                  {
                     wPin2 = (WORD)GetDlgItemText(hDlg,
                                                  IDC_PIN1,
                                                  Buff,
                                                  sizeof(Buff)/sizeof(TCHAR)
                                                 );
#ifdef UNICODE
                     //verify if Buff contains a UNICODE character
                     len = _tcsclen( Buff );

                     //get the current offset of the cursor in the entry field
                     SendDlgItemMessage( hDlg, IDC_PIN1, EM_GETSEL, (WPARAM) NULL, (WPARAM)(LPDWORD)&CurOffset);

                     if( !IsTextASCII16( Buff, len ) )
                     {                        
                        //replace the new PIN in the dlg with the previous
                        memcpy( Buff, szPreviousPin1, sizeof(szPreviousPin1) );
                        MessageBeep( MB_ICONEXCLAMATION );
                        set_effect( hDlg, IDC_PIN1, Buff );
						      //adjust the offset of the cursor
						      CurOffset = CurOffset - (len - _tcsclen(szPreviousPin1));
                        SendDlgItemMessage( hDlg, IDC_PIN1, EM_SETSEL, CurOffset, CurOffset );
                        break;
                     }
                     else
                     {
                        //replace the previous PIN with the new 
                        memcpy( szPreviousPin1, Buff, sizeof(Buff) );
                     }
#endif
					 memset(Buff, 0, sizeof(Buff));
					 if(Buff[0]) { MessageBeep(0); } // to prevent compiler from optimization
                  }
                  else
                  {
                     wPin2 = 4;
                  }

                  if ((wPin1 >= 4) && (wPin2 >= 4) && (wPin1 <= 8) && (wPin2 <= 8))
                  {
                     EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                     EnableWindow(GetDlgItem(hDlg, IDB_CHANGE), TRUE);
                  }
                  else
                  {
                     EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                     EnableWindow(GetDlgItem(hDlg, IDB_CHANGE), FALSE);
                  }
               }
               break;
            }

            case IDB_CHANGE:
            {
               TCHAR szNewUserPin[256];
               TCHAR szNewSOPin[256];

               /* Returns the size in bytes */
               LoadString(g_hInstRes, IDS_GPKUI_NEWUSERPIN, szNewUserPin, sizeof(szNewUserPin) / sizeof(TCHAR));
               LoadString(g_hInstRes, IDS_GPKUI_NEWSOPIN, szNewSOPin, sizeof(szNewSOPin) / sizeof(TCHAR));

               ShowWindow(GetDlgItem(hDlg, IDB_CHANGE), SW_HIDE);
               dwGpkPinLen = (DWORD)GetDlgItemText(hDlg, IDC_PIN, szGpkPinGUI, PIN_MAX+1);
               #ifdef UNICODE
                    wcstombs(szGpkPin, szGpkPinGUI, dwGpkPinLen);
               #else
                    strcpy(szGpkPin, szGpkPinGUI);
               #endif
               bChangePin = TRUE;
               ShowWindow(GetDlgItem(hDlg, IDC_PIN1), SW_SHOW);
               if (bUser)
               {
                  set_effect(hDlg, IDC_PINDLGTXT, szNewUserPin);
               }
               else
               {
                  set_effect(hDlg, IDC_PINDLGTXT, szNewSOPin);
               }
               SetDlgItemText(hDlg, IDC_PIN, TEXT(""));
               SetDlgItemText(hDlg, IDC_PIN1, TEXT(""));
               SetFocus(GetDlgItem(hDlg, IDC_PIN));
               return(TRUE);
            }

            case IDOK:
            {
               if ((bChangePin) || ((bUnblockPin) && (bNewPin)))
               {
                   TCHAR szWrongConfirm[MAX_STRING];
                   TCHAR szChangePin[MAX_STRING];

                  wPinMemoLen = (WORD)GetDlgItemText(hDlg, IDC_PIN, szPinMemo, PIN_MAX+1);
                  wGpkNewPinLen = (WORD)GetDlgItemText(hDlg, IDC_PIN1, szGpkNewPinGUI, PIN_MAX+1);
                  #ifdef UNICODE
                        wcstombs(szGpkNewPin, szGpkNewPinGUI, wGpkNewPinLen);
                  #else
                        strcpy(szGpkNewPin, szGpkNewPinGUI);
                  #endif
                  if (  (wPinMemoLen != wGpkNewPinLen)
                      ||(_tcscmp(szPinMemo, szGpkNewPinGUI))
                     )
                  {
                     /* Returns the size in bytes */


                     LoadString(g_hInstRes, IDS_GPKUI_WRONGCONFIRM, szWrongConfirm, sizeof(szWrongConfirm) / sizeof(TCHAR));
                     LoadString(g_hInstRes, IDS_GPKUI_CHANGEPIN, szChangePin, sizeof(szChangePin) / sizeof(TCHAR));

                     MessageBeep(MB_ICONASTERISK);
                     MessageBox(hDlg,
                                szWrongConfirm,
                                szChangePin,
                                MB_OK | MB_ICONEXCLAMATION
                               );
                     SetDlgItemText(hDlg, IDC_PIN, TEXT(""));
                     SetDlgItemText(hDlg, IDC_PIN1, TEXT(""));
                     // EnableWindow(GetDlgItem(hDlg, IDC_PIN), TRUE);
                     SetFocus(GetDlgItem(hDlg, IDC_PIN));
                     break;
                  }
                  // [JMR 02-04] begin
                  else
                  {
                      TCHAR szPinWrongLength[MAX_STRING];
                      //TCHAR szChangePin[MAX_STRING];

                      TCHAR szText[50];


                      if ((wPinMemoLen > PIN_MAX) || (wPinMemoLen < PIN_MIN))
                      {

                          LoadString (g_hInstRes, IDS_GPKUI_PINWRONGLENGTH, szPinWrongLength, sizeof(szPinWrongLength) / sizeof(TCHAR));





                          _sntprintf(szText, (sizeof(szText)/sizeof(TCHAR))-1, szPinWrongLength, PIN_MIN, PIN_MAX);
						  szText[(sizeof(szText)/sizeof(TCHAR))-1]=0;

                          LoadString (g_hInstRes, IDS_GPKUI_CHANGEPIN, szChangePin, sizeof(szChangePin) / sizeof(TCHAR));

                          MessageBeep(MB_ICONASTERISK);
                          MessageBox(hDlg,
                                     szText,
                                     szChangePin,
                                     MB_OK | MB_ICONEXCLAMATION
                                    );
                          SetDlgItemText(hDlg, IDC_PIN, TEXT(""));
                          SetDlgItemText(hDlg, IDC_PIN1, TEXT(""));
                          // EnableWindow(GetDlgItem(hDlg, IDC_PIN), TRUE);
                          SetFocus(GetDlgItem(hDlg, IDC_PIN));
                          break;
                      }
                  }
               }
               // [JMR 02-04] end

               else
               {
                  dwGpkPinLen = (DWORD)GetDlgItemText(hDlg, IDC_PIN, szGpkPinGUI, PIN_MAX+1);
                  #ifdef UNICODE
                        wcstombs(szGpkPin, szGpkPinGUI, dwGpkPinLen);
                  #else
                        strcpy(szGpkPin, szGpkPinGUI);
                  #endif
               }
               EndDialog(hDlg, wParam);
               return(TRUE);
            }

            case IDCANCEL:
            {
               strcpy(szGpkPin, "");
               dwGpkPinLen = 0;
               strcpy(szGpkNewPin, "");
               wGpkNewPinLen = 0;
               bChangePin = FALSE;
               MessageBeep(MB_ICONASTERISK);
               EndDialog(hDlg, wParam);
               return(TRUE);
            }
         }
      }

      case WM_DESTROY:
      {
         break;
      }
   }
   return(FALSE);
}


/*------------------------------------------------------------------------------
               Functions for Container Dialogue Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK ContDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   TCHAR szContinue[MAX_STRING];
   TCHAR szCaption[MAX_STRING];

   switch (message)
   {
      case WM_INITDIALOG:
      {
         TCHAR szTitle[MAX_STRING];

         // Sets window title
         LoadString(g_hInstRes, IDS_GPKUI_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
         SetWindowText(hDlg,szTitle);

         LoadString (g_hInstRes, IDS_GPKUI_CONTINUE, szContinue, sizeof(szContinue)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDC_CONTDLGTXT, szContinue);
         LoadString (g_hInstRes, IDS_CAPTION_YES, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDYES, szCaption);
         LoadString (g_hInstRes, IDS_CAPTION_NO, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDNO, szCaption);
         SetFocus(GetDlgItem(hDlg, IDNO));
         return(TRUE);
      }

      case WM_COMMAND:
      {
         switch(LOWORD(wParam))
         {
            case IDYES:
            {
                ContainerStatus = ACCEPT_CONTAINER;
                EndDialog(hDlg, wParam);
                return(TRUE);
            }

            case IDNO:
            {
                ContainerStatus = ABORT_OPERATION;
                EndDialog(hDlg, wParam);
                return(TRUE);
            }
         }
      }

      case WM_DESTROY:
      {
         break;
      }
   }
   return(FALSE);
}



/*------------------------------------------------------------------------------
               Functions for Container Dialogue Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK KeyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   TCHAR StrLen07[10];
   TCHAR StrLen08[10];
   TCHAR szMsg[300];
   TCHAR szChooseLength[MAX_STRING];
   TCHAR szCaption[MAX_STRING];

   switch (message)
   {
      case WM_INITDIALOG:
      {
         TCHAR szTitle[MAX_STRING];

         // Sets window title
         LoadString(g_hInstRes, IDS_GPKUI_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
         SetWindowText(hDlg,szTitle);

         LoadString (g_hInstRes, IDS_GPKUI_CHOOSEKEYLENGTH, szChooseLength, sizeof(szChooseLength)/sizeof(TCHAR));
         //_tcscpy(szMsg, szChooseLength);
         //_tcscat(szMsg, szKeyType);
		 _sntprintf(szMsg, (sizeof(szMsg)/sizeof(TCHAR))-1, TEXT("%s%s"), szChooseLength, szKeyType);
		 szMsg[(sizeof(szMsg)/sizeof(TCHAR))-1]=0;

         // TT 12/10/99: If we get here, it means that we have 512 and 1024 bits
         // keys available. Don't use the length of the first two key files!
         //_stprintf(StrLen07, TEXT("%4d"), KeyLenFile[0]*8);
         //_stprintf(StrLen08, TEXT("%4d"), KeyLenFile[1]*8);
         _sntprintf(StrLen07, (sizeof(StrLen07)/sizeof(TCHAR))-1, TEXT("%4d"), 1024 );
		 StrLen07[(sizeof(StrLen07)/sizeof(TCHAR))-1]=0;
         _sntprintf(StrLen08, (sizeof(StrLen08)/sizeof(TCHAR))-1, TEXT("%4d"), 512 );
		 StrLen08[(sizeof(StrLen08)/sizeof(TCHAR))-1]=0;
         // TT: End

         // FP 05/11/99: Write text in the caption of the radio button
         //SetDlgItemText(hDlg, IDC_KEYLENGTH,  StrLen07);
         //SetDlgItemText(hDlg, IDC_KEYLENGTH1,  StrLen08);
         SetWindowText(GetDlgItem(hDlg, IDB_KEYLENGTH), StrLen07);
         SetWindowText(GetDlgItem(hDlg, IDB_KEYLENGTH1), StrLen08);
         // FP: End

         SetDlgItemText(hDlg, IDC_KEYDLGTXT, szMsg);
         KeyLenChoice = 1024/8;//KeyLenFile[0];
         CheckDlgButton(hDlg, IDB_KEYLENGTH, BST_CHECKED);

         LoadString (g_hInstRes, IDS_CAPTION_OK, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDOK, szCaption);
         LoadString (g_hInstRes, IDS_CAPTION_ABORT, szCaption, sizeof(szCaption)/sizeof(TCHAR));
         SetDlgItemText(hDlg, IDABORT, szCaption);
         SetFocus(GetDlgItem(hDlg, IDOK));
         return(TRUE);
      }

      case WM_COMMAND:
      {
         switch(LOWORD(wParam))
         {
            case IDB_KEYLENGTH:
            {
                ShowWindow(GetDlgItem(hDlg, IDB_KEYLENGTH), SW_SHOW);
                KeyLenChoice = 1024/8;//TT 12/10/99 KeyLenFile[0];
                break;
            }

            case IDB_KEYLENGTH1:
            {
                ShowWindow(GetDlgItem(hDlg, IDB_KEYLENGTH1), SW_SHOW);
                KeyLenChoice = 512/8;//KeyLenFile[1];
                break;
            }

            case IDOK:
            {
                EndDialog(hDlg, wParam);
                return(TRUE);
            }

            case IDABORT:
            {
                KeyLenChoice = 0;
                EndDialog(hDlg, wParam);
                return(TRUE);
            }
         }
      }

      case WM_DESTROY:
      {
         break;
      }
   }
   return(FALSE);
}

/*------------------------------------------------------------------------------
               Functions for Progress Dialog Box Management
------------------------------------------------------------------------------*/

/*******************************************************************************
* void Wait (DWORD ulStep,
*            DWORD ulMaxStep,
*            DWORD ulSecond)
*
* Description    : Change Progress Box Text.
*
* Remarks        : Nothing.
*
* In             : ulStep    = Current step number.
*                  ulMaxStep = Maximum step number.
*                  ulSecond  =
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void Wait(DWORD ulStep, DWORD ulMaxStep, DWORD ulSecond)
{
    ULONG ulStart, ulEnd, ulBase, ulCur;
    TCHAR szTitle[MAX_STRING];
    TCHAR szText[MAX_STRING];
    TCHAR szTmp[MAX_STRING];

    LoadString(g_hInstRes, IDS_GPK4K_KEYGEN, szTmp, sizeof(szTmp)/sizeof(TCHAR));
    _sntprintf(szTitle, (sizeof(szTitle)/sizeof(TCHAR))-1, szTmp, ulStep, ulMaxStep);
	szTitle[(sizeof(szTitle)/sizeof(TCHAR))-1]=0;

    LoadString(g_hInstRes, IDS_GPK4K_PROGRESSTITLE, szText, sizeof(szText)/sizeof(TCHAR));
    ShowProgress(NULL, szTitle, szText, NULL);

#ifdef _TEST
    Sleep(1000); // Allow the tester to see the text displayed in the dialog box
#endif

    ulStart = GetTickCount();
    ulEnd = ulStart + (ulSecond * 1000);
    ulBase = ulSecond * 10;
    ulCur = 0;
    while (GetTickCount() < ulEnd)
    {
        Yield();
        if (((GetTickCount() - ulStart) / ulBase) > ulCur)
        {
            ulCur++;

            LoadString(g_hInstRes, IDS_GPK4K_PROGRESSPERCENT, szTmp, sizeof(szTmp)/sizeof(TCHAR));
            _sntprintf(szText, (sizeof(szText)/sizeof(TCHAR))-1, szTmp, ulCur, (ulEnd-GetTickCount())/1000);
			szText[(sizeof(szText)/sizeof(TCHAR))-1]=0;
            ChangeProgressText(szText);
        }
    }
    DestroyProgress();
}

/*******************************************************************************/

void ShowProgressWrapper(WORD wKeySize)
{
   TCHAR szTmp[MAX_STRING]=TEXT("");
   TCHAR szTitle[MAX_STRING];
   TCHAR szText[MAX_STRING]=TEXT("");

   LoadString(g_hInstRes, IDS_GPK4K_PROGRESSTEXT, szTmp, sizeof(szTmp)/sizeof(TCHAR));
   _sntprintf(szTitle, (sizeof(szTitle)/sizeof(TCHAR))-1, szTmp, wKeySize);
   szTitle[(sizeof(szTitle)/sizeof(TCHAR))-1]=0;
   LoadString(g_hInstRes, IDS_GPK4K_PROGRESSTITLE, szText, sizeof(szText)/sizeof(TCHAR));

   ShowProgress(GetActiveWindow(), szTitle, szText, NULL);
}

/*******************************************************************************/

void ChangeProgressWrapper(DWORD dwTime)
{
   TCHAR szTmp[MAX_STRING];
   TCHAR szText[MAX_STRING];
   LoadString(g_hInstRes, IDS_GPK4K_PROGRESSTIME, szTmp, sizeof(szTmp)/sizeof(TCHAR));
   _sntprintf(szText, (sizeof(szText)/sizeof(TCHAR))-1, szTmp, dwTime);
   szText[(sizeof(szText)/sizeof(TCHAR))-1]=0;

   ChangeProgressText(szText);
}

/*******************************************************************************
* void ShowProgress (HWND hWnd,
*                    LPTSTR lpstrTitle,
*                    LPTSTR lpstrText,
*                    LPTSTR lpstrButton
*
* Description    : Initialize Progress dialog box CALLBACK.
*
* Remarks        : If lpstrButton is null, then don't display cancel button
*
* In             : hWnd       = Handle of parent window.
*                  lpstrTitle = Pointer to Title of dialog box.
*                  lpstrText  = Pointer to Text of dialog box.
*                  lpstrButton = Pointer to Text of button.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void ShowProgress (HWND hWnd,
                   LPTSTR lpstrTitle,
                   LPTSTR lpstrText,
                   LPTSTR lpstrButton
                   )
{
   if (!(CspFlags & CRYPT_SILENT))
   {
       if ((!hProgressDlg) && (!NoDisplay))
       {
          _tcscpy(szProgTitle, lpstrTitle);
          _tcscpy(szProgText, lpstrText);

          _tcscpy(szProgButton, TEXT(""));
          if (lpstrButton == NULL)
          {
             IsProgButtoned = FALSE;
             IsProgButtonClick = FALSE;
             //lpProgressDlg = MakeProcInstance((FARPROC)ProgressDlgProc, g_hInstRes);

             hProgressDlg = CreateDialog(g_hInstRes,
                                         TEXT("PROGDIALOG"),
                                        GetActiveWindow(),
                                         ProgressDlgProc
                                        );
             hCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));
          }
          else
          {
             IsProgButtoned = TRUE;
             IsProgButtonClick = FALSE;
             _tcscpy(szProgButton, lpstrButton);
             DialogBox(g_hInstRes,
                       TEXT("PROGDIALOG"),
                       GetActiveWindow(),
                       ProgressDlgProc
                      );
             hProgressDlg = NULL;
          }
       }
   }
}


/*******************************************************************************
* void ChangeProgressText (LPTSTR lpstrText)
*
* Description    : Change Progress Box Text.
*
* Remarks        : Nothing.
*
* In             : lpstrText  = Pointer to Text of dialog box.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void ChangeProgressText (LPTSTR lpstrText)
{
   if (hProgressDlg)
   {
      _tcscpy(szProgText, lpstrText);
      SendMessage(hProgressDlg,UM_CHANGE_TEXT,(WPARAM)NULL,(LPARAM)NULL);
   }
}

/*******************************************************************************
* void DestroyProgress (void)
*
* Description    : Destroy Progress dialog box CALLBACK.
*
* Remarks        : Nothing.
*
* In             : Nothing.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void DestroyProgress (void)
{
    if (!(CspFlags & CRYPT_SILENT))
    {
        if ((hProgressDlg) && (!NoDisplay))
        {
            DestroyWindow(hProgressDlg);
            FreeProcInstance(lpProgressDlg);
            hProgressDlg = NULL;
            SetCursor(hCursor);
        }
    }
}


/*******************************************************************************
* INT_PTR CALLBACK ProgressDlgProc(HWND   hDlg,
*                                  UINT   message,
*                                  WPARAM wParam,
*                                  LPARAM lParam
*                                 )
*
* Description : CALLBACK for management of Progess Dialog Box.
*
* Remarks     : Nothing.
*
* In          : hDlg    = Window handle.
*               message = Type of message.
*               wParam  = Word message-specific information.
*               lParam  = Long message-specific information.
*
* Out         : Nothing.
*
* Responses   : If everything is OK :
*                    G_OK
*               If an condition error is raised:
*
*******************************************************************************/
INT_PTR CALLBACK ProgressDlgProc(HWND   hDlg,
                                 UINT   message,
                                 WPARAM wParam,
                                 LPARAM lParam
                                )
{
#ifdef _DISPLAY
   switch (message)
   {
      /* Initialize Dialog box                                                */
      case WM_INITDIALOG:
      {
         SetWindowText(hDlg,(LPTSTR)szProgTitle);
         SetDlgItemText(hDlg,IDC_PROGDLGTXT,(LPCTSTR)szProgText);
         if (IsProgButtoned)
         {
            hProgressDlg = hDlg;
            ShowWindow(GetDlgItem(hDlg, IDCANCEL), SW_SHOW);
            SetWindowText(GetDlgItem(hDlg, IDCANCEL),(LPTSTR)szProgButton);
         }
         else
         {
            ShowWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
         }
      }
      return(TRUE);
      break;

      case UM_CHANGE_TEXT:
      {
         SetDlgItemText(hDlg,IDC_PROGDLGTXT,(LPTSTR)szProgText);
      }
      break;

      case WM_COMMAND:
      {
         switch(LOWORD(wParam))
         {
            case IDCANCEL:
            {
               IsProgButtonClick = TRUE;
               EndDialog(hDlg, wParam);
               return(TRUE);
            }
         }
      }
      break;

      default:
         return(FALSE);
   }
#endif
   return (FALSE);
}



/*******************************************************************************
    Functions to set/unset cursor in wait mode
*******************************************************************************/
void BeginWait(void)
{
   hCursor2=SetCursor(LoadCursor(NULL,IDC_WAIT));
}

void EndWait(void)
{
   SetCursor(hCursor2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\cspwrap.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors:
//          Thierry Tremblay
//          Francois Paradis
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////
#ifdef _UNICODE
#define UNICODE
#endif
#include <stdio.h>
#include "gpkcsp.h"



///////////////////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
///////////////////////////////////////////////////////////////////////////////////////////

BOOL        Coherent(HCRYPTPROV hProv, bool *cardReinserted=NULL);
HWND        GetAppWindow();
void        GpkLocalLock();
void        GpkLocalUnlock();
DWORD       Select_MF(HCRYPTPROV hProv);

extern Prov_Context*    ProvCont;
extern const DWORD MAX_GPK_OBJ;

#ifdef _DEBUG
   static DWORD dw1, dw2;
#endif



///////////////////////////////////////////////////////////////////////////////////////////
//
// CSP API Wrappers
//
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPAcquireContext( OUT HCRYPTPROV*      phProv,
                              IN  LPCSTR           pszContainer,
                              IN  DWORD            dwFlags,
                              IN  PVTableProvStruc pVTable )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPAcquireContext(phProv:0x%p(0x%08X), pszContainer:%s, dwFlags:0x%08X, pVTable:0x%p)"),
             phProv, *phProv,
			    pszContainer,
			    dwFlags,
			    pVTable);
   DBG_TIME1;

   __try
   {   
      __try
      {
#ifdef MS_BUILD
         // TT-START : MS - Whistler Beta 1 - Certificate overwrite
         if (dwFlags & CRYPT_NEWKEYSET)
         {
            // Extract reader name if any is specified
			   char szReaderName[MAX_PATH];
			   char szNewContainerName[MAX_PATH];
			   ZeroMemory( szReaderName, sizeof(szReaderName) );
			   ZeroMemory( szNewContainerName, sizeof(szNewContainerName) );


            if (pszContainer != 0 && *pszContainer != 0)
            {
            if (strlen(pszContainer) >= 4 && memcmp( pszContainer, "\\\\.\\", 4 )==0)
            {
               // We have a reader name, keep it
               char* pEnd = strchr( pszContainer+4, '\\' );

               if (pEnd==0)
               {
				  //only a reader name
                  //strcpy( szReaderName, pszContainer );
                  //strcat( szReaderName, "\\" );
				  _snprintf(szReaderName, sizeof(szReaderName)-1, "%s%s", pszContainer, "\\");
				  szReaderName[sizeof(szReaderName)-1]=0;
               }
               else
               {
				  //there's also a container name 
				   if(pEnd-pszContainer+1 > sizeof(szReaderName)-1) // check before memcpy
				   {
					 bResult = CRYPT_FAILED;
					 errcode = E_UNEXPECTED;
					 __leave;
				   }
                  memcpy( szReaderName, pszContainer, pEnd - pszContainer + 1 );
				  strncpy(szNewContainerName, pEnd + 1, sizeof(szNewContainerName)-1);
				  szNewContainerName[sizeof(szNewContainerName)-1]=0;
               }
            }
			else
			{
				//no reader name, copy the container name
				strncpy(szNewContainerName, pszContainer, sizeof(szNewContainerName)-1);
				szNewContainerName[sizeof(szNewContainerName)-1]=0;
			}
            }

            // Request with default container, use default name
            if (strlen(szNewContainerName)==0)
            {
                strncpy(szNewContainerName, CSP_DEFAULTKEYSETNAME, sizeof(szNewContainerName)-1);
				szNewContainerName[sizeof(szNewContainerName)-1]=0;
            }


            HCRYPTPROV hProv;
            
            if (MyCPAcquireContext( &hProv, szReaderName, dwFlags & CRYPT_SILENT, pVTable ))
            {
			   // SCR#41
               char szExistingContainerName[MAX_PATH];
               DWORD len = sizeof(szExistingContainerName);
			   ZeroMemory( szExistingContainerName, sizeof(szExistingContainerName) );
			   			   
			   //get the existing container name
               bResult = MyCPGetProvParam( hProv, PP_CONTAINER, (BYTE*)szExistingContainerName, &len, 0 );
               errcode = GetLastError();
			
			   if( bResult )
			   {
				   if( strcmp( szExistingContainerName, szNewContainerName ) == 0 )
				   {
					   //the requested container exist in the token, 
					   bResult = CRYPT_FAILED;
					   errcode = NTE_EXISTS;
				   }
				   else
				   {
					   //there already are a container in the token which isn't the one
					   //requested
					   bResult = CRYPT_FAILED;
					   errcode = NTE_TOKEN_KEYSET_STORAGE_FULL;
				   }
			   }
				   
               MyCPReleaseContext( hProv, 0 );
            }
            else
            {
               if (GetLastError()!=NTE_KEYSET_NOT_DEF)
               {
                  bResult = CRYPT_FAILED;
                  errcode = GetLastError();
               }
            }
         }
         // TT-END: MS - Whistler Beta 1 - Certificate overwrite
#endif // MS_BUILD

         if (bResult)
         {
            bResult = MyCPAcquireContext( phProv, pszContainer, dwFlags, pVTable );
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPAcquireContext(phProv:0x%p(0x%08X), pszContainer:%s, dwFlags:0x%08X, pVTable:0x%p)\n  returns %d in %d msec"),
                phProv, *phProv,
                pszContainer,
                dwFlags,
                pVTable,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }

   RETURN( bResult, errcode );
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGetProvParam( IN HCRYPTPROV hProv,
                            IN DWORD      dwParam,
                            IN BYTE*      pbData,
                            IN DWORD*     pdwDataLen,
                            IN DWORD      dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPGetProvParam(hProv:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)"),
             hProv,
             dwParam,
             pbData,
             pdwDataLen, *pdwDataLen,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {
         // [FP] if we want to load a RSA private key into the GPK card,
         // we have to reconnect in exclusive mode
         if (dwParam == GPP_SESSION_RANDOM)
         {
            DWORD dwProto;            
            errcode = SCardReconnect( ProvCont[hProv].hCard, SCARD_SHARE_EXCLUSIVE,
                                      SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &dwProto );
            bResult = (errcode == SCARD_S_SUCCESS);
         }

         BOOL bDid = FALSE;
         if ((bResult) &&
            (((dwParam == PP_ENUMALGS) || (dwParam == PP_ENUMALGS_EX)) && (/*(Slot[ProvCont[hProv].Slot].GpkMaxSessionKey == 0) ||*/ (dwFlags == CRYPT_FIRST))) ||
             ((dwParam == PP_ENUMCONTAINERS) && (dwFlags == CRYPT_FIRST)) ||
              (dwParam == GPP_SERIAL_NUMBER) ||
              (dwParam == GPP_SESSION_RANDOM))
         {
            bResult = Coherent(hProv);
            errcode = GetLastError();
            bDid = TRUE;
         }
         
         if (bResult)
         {
            bResult = MyCPGetProvParam( hProv, dwParam, pbData, pdwDataLen, dwFlags );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
               
            }
            else if ((!ProvCont[hProv].bCardTransactionOpened) && (bDid))
            {
               // [FP] to be able to load a RSA private key into the GPK card,
               // the transaction should not be closed (only for PP_SESSION_RANDOM)
               // Select_MF(hProv); [NK] PIN not presented
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPGetProvParam(hProv:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                dwParam,
                pbData,
                pdwDataLen, *pdwDataLen,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }

   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPReleaseContext( IN HCRYPTPROV hProv,
                              IN DWORD      dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPReleaseContext(hProv:0x%08X, dwFlags:0x%08X)"),
             hProv,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         //if (Coherent(hProv))
         //{
            bResult = MyCPReleaseContext( hProv, dwFlags );
            errcode = GetLastError();
         //}
         //else
         //{
         //   bResult = CRYPT_FAILED;
         //   errcode = GetLastError();
         //}
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPReleaseContext(hProv:0x%08X, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }

   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPSetProvParam( IN HCRYPTPROV  hProv,
                            IN DWORD       dwParam,
                            IN CONST BYTE* pbData,
                            IN DWORD       dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPSetProvParam(hProv:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)"),
             hProv,
             dwParam,
             pbData,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // [FP] if we want to change the PIN,
         // we have to check the coherence
         if (dwParam == GPP_CHANGE_PIN)
         {
            bResult = Coherent(hProv);
            errcode = GetLastError();
         }
         
         if (bResult)
         {
            bResult = MyCPSetProvParam (hProv, dwParam, pbData, dwFlags);
            errcode = GetLastError();

            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               if (dwParam == GPP_CHANGE_PIN)
               {
                  Select_MF(hProv);
                  SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
               }
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPSetProvParam(hProv:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                dwParam,
                pbData,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }

   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPDeriveKey( IN  HCRYPTPROV   hProv,
                         IN  ALG_ID       Algid,
                         IN  HCRYPTHASH   hHash,
                         IN  DWORD        dwFlags,
                         OUT HCRYPTKEY*   phKey )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPDeriveKey(hProv:0x%08X, Algid:0x%08X, hHash:0x%08X, phKey:0x%p(0x%08X))"),
             hProv,
             Algid,
             hHash,
             dwFlags,
             phKey, *phKey);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPDeriveKey( hProv, Algid, hHash, dwFlags, phKey );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPDeriveKey(hProv:0x%08X, Algid:0x%08X, hHash:0x%08X, phKey:0x%p(0x%08X))\n  returns %d in %d msec"),
            hProv,
            Algid,
            hHash,
            dwFlags,
            phKey, *phKey,
            bResult,
            DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPDestroyKey( IN HCRYPTPROV hProv,
                          IN HCRYPTKEY  hKey )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPDestroyKey(hProv:0x%08X, hKey:0x%08X)"),
             hProv,
             hKey);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPDestroyKey( hProv, hKey );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
	   DBG_TIME2;
      DBG_PRINT(TEXT("<-CPDestroyKey(hProv:0x%08X, hKey:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hKey,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPExportKey( IN  HCRYPTPROV hProv,
                         IN  HCRYPTKEY  hKey,
                         IN  HCRYPTKEY  hPubKey,
                         IN  DWORD      dwBlobType,
                         IN  DWORD      dwFlags,
                         OUT BYTE*      pbData,
                         OUT DWORD*     pdwDataLen )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPExportKey(hProv:0x%08X, hKey:0x%08X, hPubKey:0x%08X, dwBlobType:0x%08X, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d))"),
			    hProv,
			    hKey,
			    hPubKey,
			    dwBlobType,
			    dwFlags,
			    pbData,
			    pdwDataLen, *pdwDataLen);
   DBG_TIME1;

   __try
   {   
      __try
      {   
        if (Coherent(hProv))
        {
            bResult = MyCPExportKey( hProv, hKey, hPubKey, dwBlobType, dwFlags, pbData, pdwDataLen );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               // Select_MF(hProv); [NK] PIN not presented
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
         
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPExportKey(hProv:0x%08X, hKey:0x%08X, hPubKey:0x%08X, dwBlobType:0x%08X, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d))\n  returns %d in %d msec"),
                hProv,
                hKey,
                hPubKey,
                dwBlobType,
                dwFlags,
                pbData,
                pdwDataLen, *pdwDataLen,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGenKey( IN  HCRYPTPROV hProv,
                      IN  ALG_ID     Algid,
                      IN  DWORD      dwFlags,
                      OUT HCRYPTKEY* phKey )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPGenKey(hProv:0x%08X, Algid:0x%08X, dwFlags:0x%08X, phKey:0x%p(0x%08X))"),
             hProv,
             Algid,
             dwFlags,
             dwFlags,
             phKey, *phKey);
   DBG_TIME1;
   __try
   {   
      __try
      {   
         if (Coherent(hProv))
         {
            bResult = MyCPGenKey( hProv, Algid, dwFlags, phKey );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               if ((Algid == AT_KEYEXCHANGE) || (Algid == AT_SIGNATURE))
                  Select_MF(hProv);
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPGenKey(hProv:0x%p, Algid:0x%08X, dwFlags:0x%08X, phKey:0x%p(0x%p))\n  returns %d in %d msec"),
                hProv,
                Algid,
                dwFlags,
                phKey, *phKey,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}

   
   
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGenRandom( IN HCRYPTPROV hProv,
                         IN DWORD      dwLen,
                         IN OUT BYTE*  pbBuffer )
                        
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPGenRandom(hProv:0x%08X, dwLen:%d, pbBuffer:0x%p)"),
             hProv,
             dwLen,
             pbBuffer);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         if (Coherent(hProv))
         {
            bResult = MyCPGenRandom( hProv, dwLen, pbBuffer );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               // Select_MF(hProv); [FP] PIN not presented
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPGenRandom(hProv:0x%08X, dwLen:%d, pbBuffer:0x%p)\n  returns %d in %d msec"),
                hProv,
                dwLen,
                pbBuffer,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGetKeyParam( IN HCRYPTPROV hProv,
                           IN HCRYPTKEY  hKey,
                           IN DWORD      dwParam,
                           IN BYTE*      pbData,
                           IN DWORD*     pdwDataLen,
                           IN DWORD      dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPGetKeyParam(hProv:0x%08X, hKey:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)"),
             hProv,
             hKey,
             dwParam,
             pbData,
             pdwDataLen, *pdwDataLen,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         if (hKey <= MAX_GPK_OBJ)
         {
            bResult = Coherent(hProv);
            errcode = GetLastError();
         }
         
         if (bResult)
         {
            bResult = MyCPGetKeyParam (hProv, hKey, dwParam, pbData, pdwDataLen, dwFlags);
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               if (hKey <= MAX_GPK_OBJ)
               {
                  // Select_MF(hProv); [NK] PIN not presented
                  SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
               }
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPGetKeyParam(hProv:0x%08X, hKey:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hKey,
                dwParam,
                pbData,
                pdwDataLen, *pdwDataLen,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGetUserKey( IN  HCRYPTPROV hProv,
                          IN  DWORD      dwKeySpec,
                          OUT HCRYPTKEY* phUserKey )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPGetUserKey(hProv:0x%08Xp, dwKeySpec:0x%08X, phUserKey:0x%p(0x%08X))"),
             hProv,
             dwKeySpec,
             phUserKey, *phUserKey);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         if (Coherent(hProv))
         {
            bResult = MyCPGetUserKey( hProv, dwKeySpec, phUserKey );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               // Select_MF(hProv); [NK] PIN not presented
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPGetUserKey(hProv:0x%08X, dwKeySpec:0x%08X, phUserKey:0x%p(0x%08X))\n  returns %d in %d msec"),
                hProv,
                dwKeySpec,
                phUserKey, *phUserKey,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPImportKey( IN  HCRYPTPROV  hProv,
                         IN  CONST BYTE* pbData,
                         IN  DWORD       dwDataLen,
                         IN  HCRYPTKEY   hPubKey,
                         IN  DWORD       dwFlags,
                         OUT HCRYPTKEY*  phKey )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPImportKey(hProv:0x%08X, pbData:0x%p, dwDataLen:%d, hPubKey:0x%08X, dwFlags:0x%08X, phKey:0x%p(0x%08X))"),
             hProv,
             pbData,
             dwDataLen,
             hPubKey,
             dwFlags,
             phKey, *phKey);
   DBG_TIME1;

   __try
   {   
      __try
      {
         BLOBHEADER BlobHeader;
         memcpy(&BlobHeader, pbData, sizeof(BLOBHEADER));

         // [FP] if we want to load a RSA private key into the GPK card,
         // the transaction is already opened - do not check the coherence -
         if ((!ProvCont[hProv].bCardTransactionOpened) && (BlobHeader.bType != PUBLICKEYBLOB))
         {
            bResult = Coherent( hProv );
            errcode = GetLastError();
         }
         
         if (bResult)
         {
            bResult = MyCPImportKey( hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               if (BlobHeader.bType != PUBLICKEYBLOB)
               {
                  Select_MF(hProv);
                  SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
               }
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
         
         // [FP] close the transaction and reconnect in shared mode
         if (ProvCont[hProv].bCardTransactionOpened)
         {
            DWORD dwProto;
            
            ProvCont[hProv].bCardTransactionOpened = FALSE;
            errcode = SCardReconnect(ProvCont[hProv].hCard, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &dwProto);
            
            if (errcode != SCARD_S_SUCCESS)
               bResult = CRYPT_FAILED;
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPImportKey(hProv:0x%08X, pbData:0x%p, dwDataLen:%d, hPubKey:0x%08X, dwFlags:0x%08X, phKey:0x%p(0x%08X))\n  returns %d in %d msec"),
                hProv,
                pbData,
                dwDataLen,
                hPubKey,
                dwFlags,
                phKey, *phKey,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPSetKeyParam( IN HCRYPTPROV  hProv,
                           IN HCRYPTKEY   hKey,
                           IN DWORD       dwParam,
                           IN CONST BYTE* pbData,
                           IN DWORD       dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPSetKeyParam(hProv:0x%08X, hKey:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)"),
             hProv,
             hKey,
             dwParam,
             pbData,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
		   if (hKey <= MAX_GPK_OBJ)
		   {
            bResult = Coherent(hProv);
            errcode = GetLastError();
		   }

         if (bResult)
         {
            bResult = MyCPSetKeyParam( hProv, hKey, dwParam, pbData, dwFlags );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
			      if (hKey <= MAX_GPK_OBJ)
               {
                  Select_MF(hProv);
                  SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
               }
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPSetKeyParam(hProv:0x%08X, hKey:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hKey,
                dwParam,
                pbData,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPDecrypt( IN HCRYPTPROV hProv,
                       IN HCRYPTKEY  hKey,
                       IN HCRYPTHASH hHash,
                       IN BOOL       Final,
                       IN DWORD      dwFlags,
                       IN OUT BYTE*  pbData,
                       IN OUT DWORD* pdwDataLen )
                      
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPDecrypt(hProv:0x%08X, hKey:0x%08X, hHash:0x%08X, Final:%d, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d))"),
             hProv,
             hKey,
             hHash,
             Final,
             dwFlags,
             pbData,
             pdwDataLen, *pdwDataLen);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPDecrypt( hProv, hKey, hHash, Final, dwFlags, pbData, pdwDataLen );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPDecrypt(hProv:0x%08X, hKey:0x%08X, hHash:0x%08X, Final:%d, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d))\n  returns %d in %d msec"),
                hProv,
                hKey,
                hHash,
                Final,
                dwFlags,
                pbData,
                pdwDataLen, *pdwDataLen,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPEncrypt( IN HCRYPTPROV hProv,
                       IN HCRYPTKEY  hKey,
                       IN HCRYPTHASH hHash,
                       IN BOOL       Final,
                       IN DWORD      dwFlags,
                       IN OUT BYTE*  pbData,
                       IN OUT DWORD* pdwDataLen,
                       IN DWORD      dwBufLen )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPEncrypt(hProv:0x%08X, hKey:0x%08X, hHash:0x%08X, Final:%d, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwBufLen:%d)"),
             hProv,
             hKey,
             hHash,
             Final,
             dwFlags,
             pbData,
             pdwDataLen, *pdwDataLen,
             dwBufLen);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPEncrypt( hProv, hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPEncrypt(hProv:0x%08X, hKey:0x%08X, hHash:0x%08X, Final:%d, dwFlags:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwBufLen:%d)\n  returns %d in %d msec"),
                hProv,
                hKey,
                hHash,
                Final,
                dwFlags,
                pbData,
                pdwDataLen, *pdwDataLen,
                dwBufLen,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPCreateHash( IN  HCRYPTPROV  hProv,
                          IN  ALG_ID      Algid,
                          IN  HCRYPTKEY   hKey,
                          IN  DWORD       dwFlags,
                          OUT HCRYPTHASH* phHash )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
	DBG_PRINT(TEXT("->CPCreateHash(hProv:0x%08X, Algid:0x%08X, hKey:0x%08X, dwFlags:0x%08X, phHash:0x%p(0x%08X))"),
             hProv,
             Algid,
             hKey,
             dwFlags,
             phHash, *phHash);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPCreateHash( hProv, Algid, hKey, dwFlags, phHash );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPCreateHash(hProv:0x%08X, Algid:0x%08X, hKey:0x%08X, dwFlags:0x%08X, phHash:0x%p(0x%08X))\n  returns %d in %d msec"),
                hProv,
                Algid,
                hKey,
                dwFlags,
                phHash, *phHash,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPDestroyHash( IN HCRYPTPROV hProv,
                           IN HCRYPTHASH hHash )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPDestroyHash(hProv:0x%08X, hHash:0x%08X)"),
             hProv,
             hHash);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPDestroyHash( hProv, hHash );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPDestroyHash(hProv:0x%08X, hHash:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPGetHashParam( IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash,
                            IN DWORD      dwParam,
                            IN BYTE*      pbData,
                            IN DWORD*     pdwDataLen,
                            IN DWORD      dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPGetHashParam(hProv:0x%08X, hHash:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)"),
             hProv,
             hHash,
             dwParam,
             pbData,
             pdwDataLen, *pdwDataLen,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPGetHashParam( hProv, hHash, dwParam, pbData, pdwDataLen, dwFlags );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPGetHashParam(hProv:0x%08X, hHash:0x%08X, dwParam:0x%08X, pbData:0x%p, pdwDataLen:0x%p(%d), dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                dwParam,
                pbData,
                pdwDataLen, *pdwDataLen,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPHashData( IN HCRYPTPROV  hProv,
                        IN HCRYPTHASH  hHash,
                        IN CONST BYTE* pbData,
                        IN DWORD       dwDataLen,
                        IN DWORD       dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPHashData(hProv:0x%08X, hHash:0x%08X, pbData:0x%p, dwDataLen:%d, dwFlags:0x%08X)"),
             hProv,
             hHash,
             pbData,
             dwDataLen,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPHashData( hProv, hHash, pbData, dwDataLen, dwFlags );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPHashData(hProv:0x%08X, hHash:0x%08X, pbData:0x%p, dwDataLen:%d, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                pbData,
                dwDataLen,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPHashSessionKey( IN HCRYPTPROV hProv,
                              IN HCRYPTHASH hHash,
                              IN HCRYPTKEY  hKey,
                              IN DWORD      dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPHashSessionKey(hProv:0x%08X, hHash:0x%08X, hKey:0x%08X, dwFlags:0x%08X)"),
             hProv,
             hHash,
             hKey,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPHashSessionKey( hProv, hHash, hKey, dwFlags );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPHashSessionKey(hProv:0x%08X, hHash:0x%08X, hKey:0x%08X, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                hKey,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPSetHashParam( IN HCRYPTPROV  hProv,
                            IN HCRYPTHASH  hHash,
                            IN DWORD       dwParam,
                            IN CONST BYTE* pbData,
                            IN DWORD       dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPSetHashParam(hProv:0x%08X, hHash:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)"),
             hProv,
             hHash,
             dwParam,
             pbData,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         // We do not have to check the coherence in this case since the operation does not
         // use the card info         
         bResult = MyCPSetHashParam( hProv, hHash, dwParam, pbData, dwFlags );
         errcode = GetLastError();
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
	   DBG_PRINT(TEXT("<-CPSetHashParam(hProv:0x%08X, hHash:0x%08X, dwParam:0x%08X, pbData:0x%p, dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                dwParam,
                pbData,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPSignHash(IN  HCRYPTPROV hProv,
                       IN  HCRYPTHASH hHash,
                       IN  DWORD      dwKeySpec,
                       IN  LPCWSTR    sDescription,
                       IN  DWORD      dwFlags,
                       OUT BYTE*      pbSignature,
                       OUT DWORD*     pdwSigLen )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPSignHash(hProv:0x%08X, hHash:0x%08X, dwKeySpec:0x%08X, sDescription:0x%p('%s'), dwFlags:0x%08X, pbSignature:0x%p, pdwSigLen:0x%p(%d))"),
             hProv,
             hHash,
             dwKeySpec,
             sDescription, sDescription,
             dwFlags,
             pbSignature,
             pdwSigLen, *pdwSigLen);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         if (Coherent(hProv))
         {
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
				ProvCont[hProv].isContNameNullBlank)

            {
               bResult = CRYPT_FAILED;
               errcode = NTE_PERM;
            }
            else
            {            
               bResult = MyCPSignHash( hProv, hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen );
               errcode = GetLastError();
               if (pbSignature != 0)
                  Select_MF(hProv);
               SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
         
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPSignHash(hProv:0x%08X, hHash:0x%08X, dwKeySpec:0x%08X, sDescription:0x%p('%s'), dwFlags:0x%08X, pbSignature:0x%p, pdwSigLen:0x%p(%d))\n  returns %d in %d msec"),
                hProv,
                hHash,
                dwKeySpec,
                sDescription, sDescription,
                dwFlags,
                pbSignature,
                pdwSigLen, *pdwSigLen,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );
}



///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

BOOL WINAPI CPVerifySignature( IN HCRYPTPROV  hProv,
                               IN HCRYPTHASH  hHash,
                               IN CONST BYTE* pbSignature,
                               IN DWORD       dwSigLen,
                               IN HCRYPTKEY   hPubKey,
                               IN LPCWSTR     sDescription,
                               IN DWORD       dwFlags )
{
   BOOL  bResult  = CRYPT_SUCCEED;
   DWORD errcode  = ERROR_SUCCESS;

   GpkLocalLock();
   DBG_PRINT(TEXT("->CPVerifySignature(hProv:0x%08X, hHash:0x%08X, pbSignature:0x%p, dwSigLen:%d, hPubKey:0x%08X, sDescription:0x%p('%s'), dwFlags:0x%08X)"),
             hProv,
             hHash,
             pbSignature,
             dwSigLen,
             hPubKey,
             sDescription, sDescription,
             dwFlags);
   DBG_TIME1;

   __try
   {   
      __try
      {   
         if (hPubKey <= MAX_GPK_OBJ)
         {
            bResult = Coherent(hProv);
            errcode = GetLastError();
         }
         
         if (bResult)
         {
            bResult = MyCPVerifySignature( hProv, hHash, pbSignature, dwSigLen, hPubKey, sDescription, dwFlags );
            errcode = GetLastError();
            
            if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                ProvCont[hProv].isContNameNullBlank)
            {
               // No access to the card has been done in this case
            }
            else
            {
               if (hPubKey <= MAX_GPK_OBJ)
               {
                  // Select_MF(hProv); // NK PIN not presented
                  SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
               }
            }
         }
         else
         {
            bResult = CRYPT_FAILED;
            errcode = GetLastError();
         }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
         bResult = CRYPT_FAILED;
         errcode = E_UNEXPECTED;
      }   
   }
   __finally
   {
      DBG_TIME2;
      DBG_PRINT(TEXT("<-CPVerifySignature(hProv:0x%08X, hHash:0x%08X, pbSignature:0x%p, dwSigLen:%d, hPubKey:0x%08X, sDescription:0x%p('%s'), dwFlags:0x%08X)\n  returns %d in %d msec"),
                hProv,
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                sDescription, sDescription,
                dwFlags,
                bResult,
                DBG_DELTA);
      GpkLocalUnlock();
   }
   
   RETURN( bResult, errcode );   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\debug.c ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors:
//          Thierry Tremblay
//          Francois Paradis
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////
#ifdef _UNICODE
#define UNICODE
#endif
#include "gpkcsp.h"

#ifdef _DEBUG

#include <stdio.h>
#include <stdarg.h>
#include <TCHAR.H> //for _tfopen, _tcscat, _tcschr

///////////////////////////////////////////////////////////////////////////////////////////
//
// Constants
//
///////////////////////////////////////////////////////////////////////////////////////////

static const PTCHAR c_szFilename = TEXT("c:\\temp\\gpkcsp_debug.log");



///////////////////////////////////////////////////////////////////////////////////////////
//
// DBG_PRINT
//
///////////////////////////////////////////////////////////////////////////////////////////

void DBG_PRINT( const PTCHAR szFormat, ... )
{
   static TCHAR buffer[1000];
   va_list  list;
   PTCHAR   pColumn;
   
   FILE* fp = _tfopen( c_szFilename, TEXT("at") );
   
   va_start( list, szFormat );
   _vstprintf( buffer, szFormat, list );
   va_end( list );
   
   _tcscat( buffer, TEXT("\n") );
   
   if (fp)
      _fputts( buffer, fp );
   
   // OutputDebugString() doesn't like columns... Change them to semi columns
   pColumn = _tcschr( buffer, TEXT(':') );
   while (pColumn != NULL)
   {
      *pColumn = TEXT(';');
      pColumn = _tcschr( pColumn+1, TEXT(':') );
   }
   OutputDebugString( buffer );
   
   fclose(fp);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\gpkcsp.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors:
//          Thierry Tremblay
//          Francois Paradis
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////
#ifndef KENNY_GPKCSP_H
#define KENNY_GPKCSP_H

#if defined(MS_BUILD) || defined(SHELL_TS)
   // Microsoft: Target Win2000
   #ifndef _WIN32_WINNT
   #define _WIN32_WINNT 0x0500
   #endif
#else
   // Gemplus: Target Win95 / WINNT 4.0
   #ifndef _WIN32_WINNT
   #define _WIN32_WINNT 0x0400
   #endif

   #ifndef WINVER
   #define WINVER 0x400
   #endif
#endif


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <cspdk.h>

#include "gpkgui.h"



#if !defined(CRYPT_IMPL_REMOVABLE) || !defined(NTE_SILENT_CONTEXT)

#pragma message ("**************************************************************")
#pragma message ("*                                                            *")
#pragma message ("* You need to use the latest available Windows Platform SDK  *")
#pragma message ("* in order to compile this CSP.                              *")
#pragma message ("*                                                            *")
#pragma message ("* Make sure the include and library paths of the SDK are     *")
#pragma message ("* searched first (before your MSDEV paths).                  *")
#pragma message ("*                                                            *")
#pragma message ("**************************************************************")
#error
#endif



#ifdef __cplusplus
extern "C" {
#endif



///////////////////////////////////////////////////////////////////////////////////////////
//
// Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////

// default container name when creating a key set without container name
#define CSP_DEFAULTKEYSETNAME "Gemplus GemSAFE Card CSP Default Container"


#ifdef _DEBUG

extern void DBG_PRINT( const PTCHAR szFormat, ... );

extern DWORD dw1, dw2;
#define DBG_TIME1 dw1 = GetTickCount();
#define DBG_TIME2 dw2 = GetTickCount();
#define DBG_DELTA dw2 - dw1

#else

__inline void NeverCalled666KillKenny( const PTCHAR szFormat, ... ) {}

#define DBG_PRINT if (1) {} else NeverCalled666KillKenny

#define DBG_TIME1
#define DBG_TIME2
#define DBG_DELTA 0

#endif



#define RETURN(r,s) { EndWait(); SetLastError(s); return(r); }



#ifdef __cplusplus

const DWORD GPP_SERIAL_NUMBER    = 0xFFFF0001;
const DWORD GPP_SESSION_RANDOM   = 0xFFFF0002;
const DWORD GPP_IMPORT_MECHANISM = 0xFFFF0003;
const DWORD GPP_CHANGE_PIN       = 0xFFFF0004;

const DWORD GCRYPT_IMPORT_SECURE = 0xFFFF8001;
const DWORD GCRYPT_IMPORT_PLAIN  = 0xFFFF8002;

#endif



typedef struct TAG_Prov_Context
{
   HCRYPTPROV     hProv;
   SCARDHANDLE    hCard;
   DWORD          Flags;
   DWORD          Slot;
   BOOL           isContNameNullBlank;    // [mv - 15/05/98]
   BOOL           bCardTransactionOpened; // [FP] control the begin/end transaction when loading a RSA private key into the GPK card
   char           szContainer[128];
   BYTE           keysetID;               // If Legacy GPK4000, we use 0xFF as the keyset
   HCRYPTKEY      hRSASign;
   HCRYPTKEY      hRSAKEK;
   BOOL           bGPK8000;               // Card is a GPK8000 ?
   BOOL           bGPK_ISO_DF;            // Card has ISO 7816-5 compliant DF name
   BOOL           bLegacyKeyset;          // Use legacy keyset name in IADF
   int            dataUnitSize;
   BOOL           bDisconnected;
   
} Prov_Context;




///////////////////////////////////////////////////////////////////////////////////////////
//
// Globals
//
///////////////////////////////////////////////////////////////////////////////////////////

extern BYTE    KeyLenFile[MAX_REAL_KEY];	 
extern BYTE    KeyLenChoice;
extern DWORD   ContainerStatus;
extern TCHAR   szKeyType[20];
extern TCHAR   s1[MAX_STRING], s2[MAX_STRING], s3[MAX_STRING];
extern DWORD   CspFlags;




///////////////////////////////////////////////////////////////////////////////////////////
//
// Wrappers for the CSP API
//
///////////////////////////////////////////////////////////////////////////////////////////

extern BOOL WINAPI
MyCPAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN  LPCSTR szContainer,
    IN  DWORD dwFlags,
    IN  PVTableProvStruc pVTable);

extern BOOL WINAPI
MyCPAcquireContextW(
    OUT HCRYPTPROV *phProv,
    IN  LPCWSTR szContainer,
    IN  DWORD dwFlags,
    IN  PVTableProvStrucW pVTable);

extern BOOL WINAPI
MyCPReleaseContext(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPGenKey(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
MyCPDeriveKey(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
MyCPDestroyKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey);

extern BOOL WINAPI
MyCPSetKeyParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPGetKeyParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPSetProvParam(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPGetProvParam(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPSetHashParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPGetHashParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPExportKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTKEY hPubKey,
    IN  DWORD dwBlobType,
    IN  DWORD dwFlags,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen);

extern BOOL WINAPI
MyCPImportKey(
    IN  HCRYPTPROV hProv,
    IN  CONST BYTE *pbData,
    IN  DWORD cbDataLen,
    IN  HCRYPTKEY hPubKey,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
MyCPEncrypt(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTHASH hHash,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD cbBufLen);

extern BOOL WINAPI
MyCPDecrypt(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTHASH hHash,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen);

extern BOOL WINAPI
MyCPCreateHash(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwFlags,
    OUT HCRYPTHASH *phHash);

extern BOOL WINAPI
MyCPHashData(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  CONST BYTE *pbData,
    IN  DWORD cbDataLen,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPHashSessionKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPSignHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwKeySpec,
    IN  LPCWSTR szDescription,
    IN  DWORD dwFlags,
    OUT LPBYTE pbSignature,
    IN OUT LPDWORD pcbSigLen);

extern BOOL WINAPI
MyCPDestroyHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash);

extern BOOL WINAPI
MyCPVerifySignature(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  CONST BYTE *pbSignature,
    IN  DWORD cbSigLen,
    IN  HCRYPTKEY hPubKey,
    IN  LPCWSTR szDescription,
    IN  DWORD dwFlags);

extern BOOL WINAPI
MyCPGenRandom(
    IN  HCRYPTPROV hProv,
    IN  DWORD cbLen,
    OUT LPBYTE pbBuffer);

extern BOOL WINAPI
MyCPGetUserKey(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey);

extern BOOL WINAPI
MyCPDuplicateHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  LPDWORD pdwReserved,
    IN  DWORD dwFlags,
    OUT HCRYPTHASH *phHash);

extern BOOL WINAPI
MyCPDuplicateKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  LPDWORD pdwReserved,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey);




#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkrsrc\gpkrsrc.c ===
/*******************************************************************************
*           Copyright (C) 1997 Gemplus International   All Rights Reserved
*
* Name        : GPKGUI.C
*
* Description : GUI used by Cryptographic Service Provider for GPK Card.
*
* Author      : Laurent CASSIER
*
*  Compiler    : Microsoft Visual C 6.0
*
* Host        : IBM PC and compatible machines under Windows 32 bit
*
* Release     : 2.00.000
*
* Last Modif. : 20/04/99  V2.00.000 - Merged versions of PKCS#11 and CSP, FJ
*               20/04/99: V1.00.005 - Modification on supporting MBCS, JQ
*				23/03/99: V1.00.004 - Replace KeyLen7 and KeyLen8 with KeyLen[], JQ
*				05/01/98: V1.00.003 - Add Unblock PIN management.
*               02/11/97: V1.00.002 - Separate code from GpkCsp Code.
*               27/08/97: V1.00.001 - Begin implementation based on CSP kit.
*
********************************************************************************
*
* Warning     : This Version use the RsaBase CSP for software cryptography.
*
* Remark      :
*
*******************************************************************************/

#include <windows.h>

int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
{
     return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\gpkcsp.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors: Laurent   CASSIER
//          Jean-Marc ROBERT
//
// Modifications: Thierry  Tremblay
//                Francois Paradis
// GPK8000 support, key importation, enhancement for Whistler & debug
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////
#ifdef _UNICODE
#define UNICODE
#endif
#include "gpkcsp.h"
#include <tchar.h>
#include <process.h>

#include <cassert>
#include <cstdio>

#include "resource.h"
#include "gmem.h"
#include "compcert.h"
#include "pincache.h"

//////////////////////////////////////////////////////////////////////////
//
// Configuration
//
//////////////////////////////////////////////////////////////////////////

const int MAX_SLOT = 16;



//////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
//////////////////////////////////////////////////////////////////////////

static void zap_gpk_objects( DWORD SlotNb, BOOL IsPrivate );
BOOL SCARDPROBLEM( LONG result, WORD sc_status, BYTE offset );

#ifdef _DEBUG
   static DWORD dw1, dw2;
#endif

//////////////////////////////////////////////////////////////////////////
//
// Macros & Templates
//
//////////////////////////////////////////////////////////////////////////

template<class T>
bool IsNull( const T* p )
{
   return p == 0;
}


template<class T>
bool IsNotNull( const T* p )
{
   return p != 0;
}


template<class T>
bool IsNullStr( const T* p )
{
   return p == 0 || *p == 0;
}


template<class T>
bool IsNotNullStr( const T* p )
{
   return p != 0 && *p != 0;
}



//////////////////////////////////////////////////////////////////////////
//
// Definitions
//
//////////////////////////////////////////////////////////////////////////

const char* SYSTEM_DF         = "SYSTEM";
const char* GPK_DF            = "GTOK1";

const WORD  MAX_SES_KEY_EF    = 0x01FF;
const WORD  GPK_MF            = 0x3F00;
const WORD  GPK_OBJ_PRIV_EF   = 0x0002;
const WORD  GPK_OBJ_PUB_EF    = 0x0004;
const WORD  GPK_IADF_EF       = 0x0005;
const WORD  GPK_PIN_EF        = 0x0006;
const BYTE  GPK_FIRST_KEY     = 0x07;

const BYTE  FILE_CHUNK_SIZE   = 200;

const int   REALLOC_SIZE      = 50;

const int   MAX_FIELD         = 16;
extern const DWORD MAX_GPK_OBJ = 100;  

// Values for a GPK8000 INTL
const int   MAX_GPK_PUBLIC    = 4000;
const int   MAX_GPK_PRIVATE   = 1600;


const int   RC2_40_SIZE       = 0x05;
const int   RC2_128_SIZE      = 0x10;
const int   DES_SIZE          = 0x08;
const int   DES3_112_SIZE     = 0x10;
const int   DES3_SIZE         = 0x18;
const int   DES_BLOCK_SIZE    = 0x08;
const int   RC2_BLOCK_SIZE    = 0x08;

const BYTE  TAG_RSA_PUBLIC    = 0x01;
const BYTE  TAG_DSA_PUBLIC    = 0x02;
const BYTE  TAG_RSA_PRIVATE   = 0x03;
const BYTE  TAG_DSA_PRIVATE   = 0x04;
const BYTE  TAG_CERTIFICATE   = 0x05;
const BYTE  TAG_DATA          = 0x06;
const BYTE  TAG_KEYSET        = 0x20;

const WORD  FLAG_APPLICATION     = 0x0001;
const WORD  FLAG_END_DATE        = 0x0002;
const WORD  FLAG_ID              = 0x0004;
const WORD  FLAG_ISSUER          = 0x0008;
const WORD  FLAG_LABEL           = 0x0010;
const WORD  FLAG_SERIAL_NUMBER   = 0x0020;
const WORD  FLAG_START_DATE      = 0x0040;
const WORD  FLAG_SUBJECT         = 0x0080;
const WORD  FLAG_VALUE           = 0x0100;
const WORD  FLAG_RESERVED        = 0x0200;   // Not used by CSP
const WORD  FLAG_KEY_TYPE        = 0x0400;
const WORD  FLAG_KEYSET          = 0x0800;
const WORD  FLAG_SIGN            = 0x1000;
const WORD  FLAG_EXCHANGE        = 0x2000;
const WORD  FLAG_EXPORT          = 0x4000;
const WORD  FLAG_MODIFIABLE      = 0x8000;

enum
{
   POS_APPLICATION    = 0,
   POS_END_DATE,
   POS_ID,
   POS_ISSUER,
   POS_LABEL,
   POS_SERIAL_NUMBER,
   POS_START_DATE,
   POS_SUBJECT,
   POS_VALUE,
   POS_RESERVED,     // Not used by CSP
   POS_KEY_TYPE,
   POS_KEYSET
};



const int   PIN_LEN           = PIN_MAX;
const int   TIME_GEN_512      = 30;
const int   TIME_GEN_1024     = 35;


// Used for GPK4000 perso (filter)
const WORD  EF_PUBLIC_SIZE    = 1483;
const WORD  EF_PRIVATE_SIZE   = 620;
const WORD  DIFF_US_EXPORT    = 240;

// depend on the GemSAFE mapping
const BYTE  USER_PIN          = 0;




const BYTE  TAG_MODULUS          = 0x01;
const BYTE  TAG_PUB_EXP          = 0x07;
const BYTE  TAG_LEN              = 1;
const BYTE  PUB_EXP_LEN          = 3;



//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct OBJ_FIELD
{
   BYTE *pValue;
   WORD  Len;
   WORD  Reserved1;
   BOOL  bReal;
   WORD  Reserved2;
} OBJ_FIELD;


typedef struct GPK_EXP_KEY
{
   BYTE KeySize;
   BYTE ExpSize;
   WORD Reserved;
   BYTE Exposant[256];
   BYTE Modulus[256];
} GPK_EXP_KEY;


typedef struct GPK_OBJ
{
   BYTE        Tag;
   BYTE        LastField;
   BYTE        ObjId;
   BYTE        FileId;
   WORD        Flags;
   WORD        Reserved1;
   GPK_EXP_KEY PubKey;
   OBJ_FIELD   Field[MAX_FIELD];
   HCRYPTKEY   hKeyBase;
   BOOL        IsPrivate;
   WORD        Reserved2;
   BOOL        IsCreated;
   WORD        Reserved3;
} GPK_OBJ;


typedef struct TMP_OBJ
{
   HCRYPTPROV hProv;
   HCRYPTKEY  hKeyBase;
} TMP_OBJ;


typedef struct TMP_HASH
{
   HCRYPTPROV hProv;
   HCRYPTHASH hHashBase;
} TMP_HASH;




typedef struct Slot_Description
{
   // NK 06.02.2001 - PinCache
   PINCACHE_HANDLE hPinCacheHandle;
   // End NK

   BOOL              Read_Priv;
   BOOL              Read_Public;
   BOOL              InitFlag;
   BOOL              UseFile [MAX_REAL_KEY];
   BYTE              NbGpkObject;
   BYTE              bGpkSerNb[8];
   GPK_EXP_KEY       GpkPubKeys[MAX_REAL_KEY];
   GPK_OBJ           GpkObject[MAX_GPK_OBJ + 1];   // 0 is not used, valid 1-MAX_GPK_OBJ
   DWORD             NbKeyFile;                    // number of key file version 2.00.002
   DWORD             GpkMaxSessionKey;             // Card unwrap capability
   DWORD             ContextCount;
   HANDLE            CheckThread;
   SCARD_READERSTATE ReaderState;
   BOOL              CheckThreadStateEmpty;     // TRUE if card has been removed and detected by checkThread
   TCHAR             szReaderName[128];
   
   // TT - 17/10/2000 - Timestamps on card
   BYTE              m_TSPublic;
   BYTE              m_TSPrivate;
   BYTE              m_TSPIN;

   BOOL ValidateTimestamps( HCRYPTPROV prov );
} Slot_Description;



//////////////////////////////////////////////////////////////////////////
//
// Statics (locals)
//
//////////////////////////////////////////////////////////////////////////

static HINSTANCE        hFirstInstMod        = 0;
static BOOL             bFirstGUILoad        = TRUE;
static HCRYPTPROV       hProvBase            = 0;
static SCARDCONTEXT     hCardContext         = 0;    // mv

static unsigned         l_globalLockCount;


static BYTE             bSendBuffer[512];
static BYTE             bRecvBuffer[512];
static BYTE*            g_pbGpkObj = 0;

static DWORD            cbSendLength;
static DWORD            cbRecvLength;
static DWORD            dwSW1SW2;

static DWORD            countCardContextRef= 0;
static DWORD            NbInst;

static TCHAR            mszCardList[MAX_PATH];

// For dynamic reallocation of TmpObject, hHashGpk and ProvCont
static DWORD            MAX_CONTEXT  = 50;
static DWORD            MAX_TMP_KEY  = 200;
static DWORD            MAX_TMP_HASH = 200;

// Temporary objects in each context
static TMP_OBJ*         TmpObject;     // dynamic allocated/reallocated
static TMP_HASH*        hHashGpk;      // dynamic allocated/reallocated

// Many contexts management
Prov_Context*           ProvCont;      // dynamic allocated/reallocated

// Per slot information
static SCARDCONTEXT     hCardContextCheck[MAX_SLOT];
static volatile BOOL    g_fStopMonitor[MAX_SLOT];
static Slot_Description Slot[MAX_SLOT];
static BOOL             InitSlot[MAX_SLOT];


static DWORD   g_FuncSlotNb      = 0;
static long    g_threadAttach    = 0;

// Gen key time for GPK8000
static int     g_GPK8000KeyGenTime512  = 0;
static int     g_GPK8000KeyGenTime1024 = 0;

// End of the Dialogue Management

static HCRYPTKEY         hRsaIdentityKey          = 0;
static DWORD             AuxMaxSessionKeyLength   = 0;
static DWORD             dwRsaIdentityLen         = 64;
static BYTE              RC2_Key_Size             = 0;
static BYTE              RSA_KEK_Size             = 0;
static BYTE              PrivateBlob[] =
{
   // Blob header
   0x07,                // PRIVATEKEYBLOB
   0x02,                // CUR_BLOB_VERSION
   0x00,0x00,           // RESERVED
   0x00,0xa4,0x00,0x00, // CALG_RSA_KEYX
   // RSA Public Key
   0x52,0x53,0x41,0x32, // "RSA2"
   0x00,0x02,0x00,0x00, // 512 bits
   0x01,0x00,0x00,0x00, // Public Exponent
   // Modulus
   0x6b,0xdf,0x51,0xef,0xdb,0x6f,0x10,0x5c,
   0x32,0xbf,0x87,0x1c,0xd1,0x4c,0x24,0x7e,
   0xe7,0x2a,0x14,0x10,0x6d,0xeb,0x2c,0xd5,
   0x8c,0x0b,0x95,0x7b,0xc7,0x5d,0xc6,0x87,
   0x12,0xea,0xa9,0xcd,0x57,0x7d,0x3e,0xcb,
   0xe9,0x6a,0x46,0xd0,0xe1,0xae,0x2f,0x86,
   0xd9,0x50,0xf9,0x98,0x71,0xdd,0x39,0xfc,
   0x0e,0x60,0xa9,0xd3,0xf2,0x38,0xbb,0x8d,
   // Prime 1
   0x5d,0x2c,0xbc,0x1e,0xc3,0x38,0xfe,0x00,
   0x5e,0xca,0xcf,0xcd,0xb4,0x13,0x89,0x16,
   0xd2,0x07,0xbc,0x9b,0xe1,0x20,0x31,0x0b,
   0x81,0x28,0x17,0x0c,0xc7,0x73,0x94,0xee,
   // Prime 2
   0x67,0xbe,0x7b,0x78,0x4e,0xc7,0x91,0x73,
   0xa8,0x34,0x5a,0x24,0x9d,0x92,0x0d,0xe8,
   0x91,0x61,0x24,0xdc,0xb5,0xeb,0xdf,0x71,
   0x66,0xdc,0xe1,0x77,0xd4,0x78,0x14,0x98,
   // Exponent 1
   0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   // Exponent 2
   0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   // Coefficient
   0xa0,0x51,0xe9,0x83,0xca,0xee,0x4b,0xf0,
   0x59,0xeb,0xa4,0x81,0xd6,0x1f,0x49,0x42,
   0x2b,0x75,0x89,0xa7,0x9f,0x84,0x7f,0x1f,
   0xc3,0x8f,0x70,0xb6,0x7e,0x06,0x5e,0x8b,
   // Private Exponent
   0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};




static BYTE InitValue[2][2*16+2] =
{  
   {
      // 1 key case
      0x01, 0xF0, 0x00, GPK_FIRST_KEY,
      0x01, 0xD0, 0x00, GPK_FIRST_KEY,
      0x03, 0xB0, 0x00, GPK_FIRST_KEY,
      0x03, 0x90, 0x00, GPK_FIRST_KEY,
      0x00,
      0xFF
   },
   {
      // 2 keys case
      0x01, 0xF0,0x00, GPK_FIRST_KEY,
      0x01, 0xD0,0x00, GPK_FIRST_KEY,
      0x03, 0xB0,0x00, GPK_FIRST_KEY,
      0x03, 0x90,0x00, GPK_FIRST_KEY,
      0x01, 0xF0,0x00, GPK_FIRST_KEY+1,   
      0x01, 0xD0,0x00, GPK_FIRST_KEY+1,   
      0x03, 0xB0,0x00, GPK_FIRST_KEY+1,
      0x03, 0x90,0x00, GPK_FIRST_KEY+1,
      0x00,
      0xFF
   }
};


// NK 09.02.2001   PinCache functions
//////////////////////////////////////////////////////////////////////////
//
// PopulatePins()
// Initializes the Pins structure and storea data
//
//////////////////////////////////////////////////////////////////////////

void PopulatePins( PPINCACHE_PINS pPins, 
                       BYTE *szCurPin,
                       DWORD bCurPin,
                       BYTE *szNewPin,
                       DWORD bNewPin ) 
{
    if ( NULL == szCurPin )
       pPins->pbCurrentPin = NULL;
    else
       pPins->pbCurrentPin = szCurPin;  

    pPins->cbCurrentPin = bCurPin;

    if ( NULL == szNewPin )
       pPins->pbNewPin = NULL;
    else 
       pPins->pbNewPin = szNewPin;  

    pPins->cbNewPin = bNewPin;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

DWORD Select_MF(HCRYPTPROV hProv);
BOOL Coherent(HCRYPTPROV hProv, bool *cardReinserted=NULL);
static DWORD OpenCard(CHAR* szContainerAsked, DWORD dwFlags, SCARDHANDLE* hCard, PTCHAR szReaderName, DWORD dwReaderNameLen);
void ReleaseProvider(HCRYPTPROV hProv);
static int get_pin_free(HCRYPTPROV hProv);
static BOOL verify_pin(HCRYPTPROV hProv, const char* pPin, DWORD dwPinLen);
static BOOL change_pin(HCRYPTPROV hProv, BYTE secretCode, const char* a_pOldPin, DWORD dwOldPinLen, const char* a_pNewPin, DWORD dwNewPinLen);
static BOOL Context_exist(HCRYPTPROV hProv);

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

struct CallbackData
{
  HCRYPTPROV hProv;
  BOOL IsCoherent;
};

//////////////////////////////////////////////////////////////////////////
//
// Callbacks for PinCache
//
//////////////////////////////////////////////////////////////////////////
DWORD Callback_VerifyPinLength( PPINCACHE_PINS pPins, PVOID pvCallBackCtx ) 
{
    if ((pPins->cbCurrentPin < PIN_MIN) || (pPins->cbCurrentPin > PIN_MAX))
        return SCARD_E_INVALID_CHV;
  
    if (( pPins->cbNewPin != 0 ) &&
        ((pPins->cbNewPin < PIN_MIN) || (pPins->cbNewPin > PIN_MAX)))
        return SCARD_E_INVALID_CHV;

    return ERROR_SUCCESS; 
}


DWORD Callback_VerifyChangePin( PPINCACHE_PINS pPins, PVOID pvCallBackCtx ) 
{
    DWORD dwStatus;

    if ((dwStatus = Callback_VerifyPinLength(pPins, 0)) != ERROR_SUCCESS)
        return dwStatus;

    if (pvCallBackCtx == 0)
        return NTE_FAIL;

    CallbackData* pCallbackData = (CallbackData*)pvCallBackCtx;
    HCRYPTPROV hProv = pCallbackData->hProv;
    BOOL IsCoherent = pCallbackData->IsCoherent;

    if (!IsCoherent)
    {
        if (!Coherent(hProv))
            return NTE_FAIL;
    }

    DWORD dwPinFree = get_pin_free(hProv);

    if (dwPinFree == -1)
       dwStatus = NTE_FAIL;

    if ((dwStatus == ERROR_SUCCESS) && (dwPinFree == 0))
       dwStatus = SCARD_W_CHV_BLOCKED;

    if ((dwStatus == ERROR_SUCCESS) && (!verify_pin(hProv, (CHAR*)pPins->pbCurrentPin, pPins->cbCurrentPin)))
       dwStatus = SCARD_W_WRONG_CHV;

    if (pPins->cbNewPin != 0)
    {
        if ((dwStatus == ERROR_SUCCESS) && (!change_pin(hProv, USER_PIN, (CHAR*)pPins->pbCurrentPin, pPins->cbCurrentPin, (CHAR*)pPins->pbNewPin, pPins->cbNewPin)))
            dwStatus = SCARD_W_WRONG_CHV;
    }

    if (!IsCoherent)
    {
        Select_MF(hProv);
        SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
    }

    return dwStatus;
}


DWORD Callback_VerifyChangePin2( PPINCACHE_PINS pPins, PVOID pvCallBackCtx ) 
{
    DWORD dwStatus;
    if ((dwStatus = Callback_VerifyPinLength(pPins, 0)) != ERROR_SUCCESS)
        return dwStatus;

    if (pvCallBackCtx == 0)
        return NTE_FAIL;

    HCRYPTPROV hProv = (HCRYPTPROV)pvCallBackCtx;

    if (!verify_pin(hProv, (CHAR*)pPins->pbCurrentPin, pPins->cbCurrentPin))
       return SCARD_W_WRONG_CHV;

    if (pPins->cbNewPin != 0)
    {
        if (!change_pin(hProv, USER_PIN, (CHAR*)pPins->pbCurrentPin, pPins->cbCurrentPin, (CHAR*)pPins->pbNewPin, pPins->cbNewPin))
            return SCARD_W_WRONG_CHV;
    }

    return ERROR_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////
//
// Query_MSPinCache()
// Wrapper for Microsoft PinCacheQuery
//
//////////////////////////////////////////////////////////////////////////
DWORD Query_MSPinCache( PINCACHE_HANDLE hCache, PBYTE pbPin, PDWORD pcbPin ) 
{
   DWORD dwStatus = PinCacheQuery( hCache, pbPin, pcbPin );

   if ( (dwStatus == ERROR_EMPTY) && (*pcbPin == 0) ) 
       return ERROR_EMPTY;         

   if ( (dwStatus == ERROR_SUCCESS) && (*pcbPin == 0) ) 
       return SCARD_E_INVALID_CHV;         

   return ERROR_SUCCESS;
}


//////////////////////////////////////////////////////////////////////////
//
// Flush_MSPinCache()
// Wrapper for Microsoft PinCacheFlush
//
//////////////////////////////////////////////////////////////////////////
void Flush_MSPinCache ( PINCACHE_HANDLE *phCache ) 
{
    PinCacheFlush( phCache );
}

//////////////////////////////////////////////////////////////////////////
//
// Wrapper for SCardConnect
//
//  fix SCR 43 :  Reconnect after the ressource manager had been stopped and
//                restarted.
//
//////////////////////////////////////////////////////////////////////////
DWORD ConnectToCard( IN LPCTSTR szReaderFriendlyName,
                     IN DWORD dwShareMode,
                     IN DWORD dwPreferredProtocols,
                     OUT LPSCARDHANDLE phCard,
                     OUT LPDWORD pdwActiveProtocol
                    )
{
    DWORD dwSts = SCardConnect( hCardContext, szReaderFriendlyName,
                                dwShareMode, dwPreferredProtocols,
                                phCard, pdwActiveProtocol );

    if (dwSts == SCARD_E_SERVICE_STOPPED)
    {
        DBG_PRINT(TEXT("ScardConnect fails because RM has been stopped and restarted"));

        SCardReleaseContext(hCardContext);
        dwSts = SCardEstablishContext( SCARD_SCOPE_SYSTEM, 0, 0, &hCardContext );

        if (dwSts == SCARD_S_SUCCESS)
        {
            dwSts = SCardConnect( hCardContext, szReaderFriendlyName, 
                dwShareMode, dwPreferredProtocols, phCard, pdwActiveProtocol );
        }
    }

    DBG_PRINT(TEXT("SCardConnect"));
    return dwSts;
}


//////////////////////////////////////////////////////////////////////////
//
// Add_MSPinCache()
// Wrapper for Microsoft PinCacheAdd
//
//////////////////////////////////////////////////////////////////////////
DWORD Add_MSPinCache( PINCACHE_HANDLE *phCache,
                      PPINCACHE_PINS pPins,
                      PFN_VERIFYPIN_CALLBACK pfnVerifyPinCallback,
                      PVOID pvCallbackCtx)
{ 
    DWORD dwStatus = PinCacheAdd( phCache,
                                  pPins, 
                                  pfnVerifyPinCallback, 
                                  pvCallbackCtx );

    return dwStatus;

}
// End NK


//////////////////////////////////////////////////////////////////////////
//
// DoSCardTransmit:
//     This function performs an SCardTransmit operation, plus retries the
//     operation should an SCARD_E_COMM_DATA_LOST or similar error be reported.
//
// Arguments:
//     Per SCardTransmit
//
// Return Value:
//     Per SCardTransmit
//
// Author:
//    Doug Barlow (dbarlow) 1/27/1999
//
//////////////////////////////////////////////////////////////////////////

LONG WINAPI
DoSCardTransmit(
    IN SCARDHANDLE hCard,
    IN LPCSCARD_IO_REQUEST pioSendPci,
    IN LPCBYTE pbSendBuffer,
    IN DWORD cbSendLength,
    IN OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT LPBYTE pbRecvBuffer,
    IN OUT LPDWORD pcbRecvLength)
{
    LONG lRet=SCARD_E_UNEXPECTED;
    BOOL fAgain = TRUE;
    DWORD dwRetryLimit = 3;
    DWORD dwLength;

    DBG_TIME1;

    while (fAgain)
    {
        if (0 == dwRetryLimit--)
            break;
        dwLength = *pcbRecvLength;
        lRet = SCardTransmit(
                    hCard,
                    pioSendPci,
                    pbSendBuffer,
                    cbSendLength,
                    pioRecvPci,
                    pbRecvBuffer,
                    &dwLength);
        switch (lRet)
        {
#ifdef SCARD_E_COMM_DATA_LOST
        case SCARD_E_COMM_DATA_LOST:
#endif
        case ERROR_SEM_TIMEOUT:
            break;
        default:
            fAgain = FALSE;
            *pcbRecvLength = dwLength;
        }
    }

    DBG_TIME2;
    DBG_PRINT(TEXT("SCardTransmit(CLA:0x%02X, INS:0x%02X, P1:0x%02X, P2:0x%02X, Li:0x%02X) in %d msec"),
              pbSendBuffer[0],
              pbSendBuffer[1],
              pbSendBuffer[2],
              pbSendBuffer[3],
              pbSendBuffer[4],
              DBG_DELTA);

    return lRet;
}


#define SCardTransmit DoSCardTransmit

//////////////////////////////////////////////////////////////////////////
// TT END: La passe a Doug
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// TT - 17/10/2000 - Inter-process synchronisation using timestamps
//                   stored on the card. There is three timestamps:
//
//    Public objects timestamp:   GemSAFE IADF offset 68
//    Private objects timestamp:  GemSAFE IADF offset 69
//    PIN modification timestamp: GemSAFE IADF offset 70
//
//////////////////////////////////////////////////////////////////////////

BOOL ReadTimestamps( HCRYPTPROV hProv, BYTE* pTSPublic, BYTE* pTSPrivate, BYTE* pTSPIN )
{
   // Issue a read binary command at offset 68 of the IADF
   bSendBuffer[0] = 0x00;
   bSendBuffer[1] = 0xB0;
   bSendBuffer[2] = 0x80 | LOBYTE( GPK_IADF_EF );
   bSendBuffer[3] = 68 / ProvCont[hProv].dataUnitSize;
   bSendBuffer[4] = 3;
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);

   DWORD lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN( CRYPT_FAILED, SCARD_W_EOF );
   }

   *pTSPublic  = bRecvBuffer[0];
   *pTSPrivate = bRecvBuffer[1];
   *pTSPIN     = bRecvBuffer[2];

   RETURN( CRYPT_SUCCEED, 0 );
}



BOOL WriteTimestamps( HCRYPTPROV hProv, BYTE TSPublic, BYTE TSPrivate, BYTE TSPIN )
{
   // Issue a update binary command at offset 68 of the IADF
   bSendBuffer[0] = 0x00;
   bSendBuffer[1] = 0xD6;
   bSendBuffer[2] = 0x80 | LOBYTE( GPK_IADF_EF );
   bSendBuffer[3] = 68 / ProvCont[hProv].dataUnitSize;
   bSendBuffer[4] = 3;
   bSendBuffer[5] = TSPublic;
   bSendBuffer[6] = TSPrivate;
   bSendBuffer[7] = TSPIN;
   cbSendLength = 8;
   
   cbRecvLength = sizeof(bRecvBuffer);
   DWORD lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,0))
   {
      RETURN( CRYPT_FAILED, SCARD_W_EOF );
   }

   RETURN( CRYPT_SUCCEED, 0 );
}



BOOL Slot_Description::ValidateTimestamps( HCRYPTPROV hProv )
{
   BYTE TSPublic, TSPrivate, TSPIN;
   
   if (!ReadTimestamps( hProv, &TSPublic, &TSPrivate, &TSPIN ))
      return CRYPT_FAILED;
   
   if (m_TSPublic != TSPublic)
   {
      Read_Public = FALSE;
      zap_gpk_objects( ProvCont[hProv].Slot, FALSE );
   }
   
   if (m_TSPrivate != TSPrivate)
   {
      Read_Priv = FALSE;
      zap_gpk_objects( ProvCont[hProv].Slot, TRUE );
   }
   
   if (m_TSPIN != TSPIN) 
   {  
      // ClearPin(); // NK 06.02.2001
      Flush_MSPinCache(&hPinCacheHandle);
   }

   m_TSPublic  = TSPublic;
   m_TSPrivate = TSPrivate;
   m_TSPIN     = TSPIN;

   return CRYPT_SUCCEED;
}



//////////////////////////////////////////////////////////////////////////
//
// IsWin2000() - Detect if we are running under Win2000 (and above)
//
//////////////////////////////////////////////////////////////////////////


bool IsWin2000()
{
#if (_WIN32_WINNT >= 0x0500)

   return true;

#else

   OSVERSIONINFO info;
   info.dwOSVersionInfoSize = sizeof(info);

   GetVersionEx( &info );

   if (info.dwPlatformId == VER_PLATFORM_WIN32_NT && info.dwMajorVersion >= 5)
      return true;

   return false;

#endif
}

////////////////////////////////////////////////////////////////////////////////
//
// TT 28/07/2000
//
// Detect GPK4000 ATR instead of GPK8000 ATR. This is to ensure
// that the GPK16000 will work as-is with the CSP.
//
// The return value is the error code from SCardStatus()
//
////////////////////////////////////////////////////////////////////////////////

static DWORD DetectGPK8000( SCARDHANDLE hCard, BOOL* pbGPK8000 )
{   
   const BYTE ATR_GPK4000[]   = { 0x3B, 0x27, 0x00, 0x80, 0x65, 0xA2, 0x04, 0x01, 0x01, 0x37 };
   const BYTE ATR_MASK[]      = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE5, 0xFF, 0xFF, 0xFF };


   DWORD lRet;   
   TCHAR szReaderName[1024];
   DWORD lenReaderName;
   DWORD state;
   DWORD protocol;
   BYTE  ATR[32];
   DWORD lenATR;
   DWORD i;
   
   lenReaderName = sizeof( szReaderName ) / sizeof( TCHAR );
   lenATR = sizeof(ATR);
      
   // Assume we have a GPK4000
   *pbGPK8000 = FALSE;

   // Read the ATR   
   lRet = SCardStatus( hCard, szReaderName, &lenReaderName, &state, &protocol, ATR, &lenATR );  
   if (lRet != SCARD_S_SUCCESS)
      return lRet;

   // Check for GPK4000
   for (i = 0; i < lenATR; ++i)
   {
      if ( (ATR[i] & ATR_MASK[i]) != (ATR_GPK4000[i] & ATR_MASK[i]) )
      {
         // Not a GPK4000
         *pbGPK8000 = TRUE;
         break;
      }
   }
   
   return SCARD_S_SUCCESS;
}




/*------------------------------------------------------------------------------
// Critical section
------------------------------------------------------------------------------*/

static CRITICAL_SECTION l_csLocalLock;


void GpkLocalLock()
{
   EnterCriticalSection(&l_csLocalLock);
}

void GpkLocalUnlock()
{
   LeaveCriticalSection(&l_csLocalLock);
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static void r_memcpy(BYTE *pbOut, BYTE *pbIn, DWORD dwLen)
{
   DWORD i;
   
   for (i = 0; i < dwLen; i++)
   {
      pbOut[i] = pbIn[dwLen - i -1];
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL sw_mask(WORD sw, BYTE x)
{
   if ((sw == 0x0000) || (x == 0xFF))
   {
      return (CRYPT_SUCCEED);
   }
   
   
   dwSW1SW2 = (bRecvBuffer[x]*256) + bRecvBuffer[x+1];
   
   if (LOBYTE(sw) == 0xFF)
   {
      if (bRecvBuffer[x]   != HIBYTE(sw))
      {
         return (CRYPT_FAILED);
      }
   }
   else
   {
      if ((bRecvBuffer[x]   != HIBYTE(sw))
         ||(bRecvBuffer[x+1] != LOBYTE(sw))
         )
      {
         return (CRYPT_FAILED);
      }
   }
   
   return (CRYPT_SUCCEED);
}



BOOL SCARDPROBLEM( LONG result, WORD sc_status, BYTE offset )
{
   if (!sw_mask( sc_status, offset ))
      return TRUE;

   if (result != SCARD_S_SUCCESS)
      return TRUE;

   return FALSE;
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static void conv_hex( const char* pInput, WORD wLen, BYTE* pOut )
{
   BYTE pin[32];
   WORD i;
   
   memcpy( pin, pInput, min(wLen,sizeof(pin)) );
   
   if (wLen & 1)
      pin[wLen] = '0';
   
   
   for (i=0; i < wLen; i+=2)
   {
      pOut[i/2] = ((pin[i] & 0x0F) << 4) + (pin[i+1] & 0x0F);
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

HWND GetAppWindow()
{
   HWND hActWnd = g_hMainWnd;

   if (!IsWindow(hActWnd))
      hActWnd = GetActiveWindow();

   return hActWnd;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static void clean_slot( DWORD SlotNb, Prov_Context* pContext )
{
   Slot_Description* pSlot;
   
   pSlot = &Slot[ SlotNb ];
   
   pSlot->Read_Priv        = FALSE;
   pSlot->Read_Public      = FALSE;
   pSlot->ContextCount     = 0;
   pSlot->GpkMaxSessionKey = 0;
   pSlot->NbKeyFile        = 0;  
   
   // pSlot->ClearPin(); NK 06.02.2001
   Flush_MSPinCache(&(pSlot->hPinCacheHandle));
   
   if (pContext->hRSASign != 0)
   {
      CryptDestroyKey( pContext->hRSASign );
      pContext->hRSASign = 0;
   }
   
   if (pContext->hRSAKEK != 0)
   {
      CryptDestroyKey( pContext->hRSAKEK );
      pContext->hRSAKEK = 0;
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static int multistrlen( const PTCHAR mszString )
{
   int res, tmp;
   PTCHAR ptr = mszString; 
   
   res = 0;
   
   if (IsNullStr(ptr))
   {
      ptr++;
      res++;
   }
   
   while (IsNotNullStr(ptr))      
   {        
      tmp = _tcslen(ptr) + 1;
     res = res + tmp;
     ptr = ptr + tmp;
   }
   
   return (res);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static LONG BeginTransaction(SCARDHANDLE hCard)
{
   DWORD lRet, dwProtocol;

   lRet = SCardBeginTransaction(hCard);

   if (lRet == SCARD_W_UNPOWERED_CARD || lRet == SCARD_W_RESET_CARD)
   {
       DBG_PRINT(TEXT("ScardBeginTransaction fails, try to reconnect"));
      lRet = SCardReconnect(hCard,
                            SCARD_SHARE_SHARED,
                            SCARD_PROTOCOL_T0,
                            SCARD_LEAVE_CARD,
                            &dwProtocol);

      if (lRet == SCARD_S_SUCCESS)
      {
         lRet = SCardBeginTransaction(hCard);
      }
   }

   DBG_PRINT(TEXT("SCardBeginTransaction"));
   return(lRet);
}
/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

DWORD Select_MF(HCRYPTPROV hProv)
{
   DWORD lRet;
   // This function is used to make sure to reset the access condition
   // on the sensitive files
   
   /* Select GPK Card MF                                                   */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x00;   //P1
   bSendBuffer[3] = 0x0C;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_MF);
   bSendBuffer[6] = LOBYTE(GPK_MF);
   cbSendLength = 7;

   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
     DBG_PRINT(TEXT("Select MF failed, lRet = 0x%08X, SW1 = %X%X, SW2 = %X%X"), lRet, (bRecvBuffer[0] & 0xF0) >> 4, (bRecvBuffer[0] & 0x0F), (bRecvBuffer[1] & 0xF0) >> 4, (bRecvBuffer[1] & 0x0F));
      RETURN (CRYPT_FAILED, SCARD_E_DIR_NOT_FOUND);
   }   

   if (ProvCont[hProv].dataUnitSize == 0)
   {
      // TT 03/11/99: Check data unit size
      bSendBuffer[0] = 0x80;
      bSendBuffer[1] = 0xC0;
      bSendBuffer[2] = 0x02;
      bSendBuffer[3] = 0xA4;
      bSendBuffer[4] = 0x0D;
      cbSendLength = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength);
      
      if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      {
         DBG_PRINT(TEXT("Check data unit size failed"));
         RETURN (CRYPT_FAILED, SCARD_E_DIR_NOT_FOUND);
      }   
      
      if (bRecvBuffer[11] & 0x40)      // LOCK1 & 0x40
         ProvCont[hProv].dataUnitSize = 1;
      else
         ProvCont[hProv].dataUnitSize = 4;
   }
   
   
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static int get_pin_free(HCRYPTPROV hProv)
{
   DWORD lRet;
   int nPinFree,
      nb, val;    // [JMR 02-04]
   
   /* Select GPK PIN EF                                                       */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x0C;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_PIN_EF);
   bSendBuffer[6] = LOBYTE(GPK_PIN_EF);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      SetLastError(lRet);
      return (-1);
   }
   
   /* Get EF information for User PIN Code (code 0)                           */
   bSendBuffer[0] = 0x80;   //CLA
   bSendBuffer[1] = 0xC0;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x05;   //P2
   bSendBuffer[4] = 0x0C;   //Lo 4*number of secret codes
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
   {
      SetLastError(SCARD_E_UNEXPECTED);
      return (-1);
   }
   
   // [JMR 02-04] begin
   nb = 0;
   val = bRecvBuffer[1];
   
   while (val > 0)
   {
      nb++;
      val = val >> 1;
   }
   
   nPinFree = bRecvBuffer[0] - nb;
   // [JMR 02-04] end
   
   SetLastError(0);
   return (max(0, nPinFree));
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL verify_pin( HCRYPTPROV  hProv,
                        const char* pPin,
                        DWORD       dwPinLen
                       )
{
   DWORD lRet;
 
   /* Verify User PIN Code (code 0)                                        */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0x20;   //INS
   bSendBuffer[2] = 0x00;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x08;   //Li
   
   // TT 22/09/99: New PIN padding for GPK8000
   if (ProvCont[hProv].bGPK_ISO_DF)
   {
      memset(&bSendBuffer[5], 0xFF, 8 );
      memcpy(&bSendBuffer[5], pPin, min(strlen(pPin)+1,8) );
   }
   else
   {
      memset(&bSendBuffer[5], 0x00, 8);
      memcpy(&bSendBuffer[5], pPin, dwPinLen);
   }
   // TT - END -
   
   cbSendLength = 5 + bSendBuffer[4];
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (ProvCont[hProv].bGPK_ISO_DF)
   {
      memset(&bSendBuffer[5], 0, min(strlen(pPin)+1,8) );
   }
   else
   {
      memset(&bSendBuffer[5], 0, dwPinLen);
   }

   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN(CRYPT_FAILED, SCARD_W_WRONG_CHV);
   }
   
   RETURN(CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL change_pin(HCRYPTPROV   hProv,
                       BYTE         secretCode,
                       const char*  a_pOldPin,
                       DWORD        dwOldPinLen,
                       const char*  a_pNewPin,
                       DWORD        dwNewPinLen
                       )
{
   DWORD lRet;

   // TT - 17/10/2000 - Update the timestamps
   Slot_Description* pSlot = &Slot[ProvCont[hProv].Slot];
   
   ++pSlot->m_TSPIN;
   
   if (0 == pSlot->m_TSPIN)
      pSlot->m_TSPIN = 1;

   if (!WriteTimestamps( hProv, pSlot->m_TSPublic, pSlot->m_TSPrivate, pSlot->m_TSPIN ))
      return CRYPT_FAILED;
   // TT - END -


   // TT 22/09/99: New PIN padding for GPK8000
   char pOldPin[PIN_MAX+1];
   char pNewPin[PIN_MAX+1];

   strncpy( pOldPin, a_pOldPin, PIN_MAX );
   pOldPin[sizeof(pOldPin)-1]=0;
   strncpy( pNewPin, a_pNewPin, PIN_MAX );
   pNewPin[sizeof(pNewPin)-1]=0;
   
   if (ProvCont[hProv].bGPK_ISO_DF)
   {       
      if (dwOldPinLen < PIN_MAX)
      {
         pOldPin[dwOldPinLen] = 0;
         ++dwOldPinLen;
         
         while (dwOldPinLen != PIN_MAX)
         {
            pOldPin[dwOldPinLen] = '\xFF';
            ++dwOldPinLen;
         }
      }
      
      if (dwNewPinLen < PIN_MAX)
      {
         pNewPin[dwNewPinLen] = 0;
         ++dwNewPinLen;
         
         while (dwNewPinLen != PIN_MAX)
         {
            pNewPin[dwNewPinLen] = '\xFF';
            ++dwNewPinLen;
         }
      }
   }
   // TT - END -
   
   
      
   /* Change User PIN Code (code 0)                                        */
   bSendBuffer[0] = 0x80;                       //CLA
   bSendBuffer[1] = 0x24;                       //INS
   bSendBuffer[2] = 0x00;                       //P1
   bSendBuffer[3] = secretCode;                 //P2
   bSendBuffer[4] = 0x08;                       //Li
   memset(&bSendBuffer[5], 0x00, 8);
   conv_hex(pOldPin, (WORD)dwOldPinLen, &bSendBuffer[5]);
   conv_hex(pNewPin, (WORD)dwNewPinLen, &bSendBuffer[9]);
   cbSendLength = 5 + bSendBuffer[4];
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   memset(bSendBuffer, 0, sizeof(bSendBuffer));   
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN(CRYPT_FAILED, SCARD_W_WRONG_CHV);
   }
      
   RETURN(CRYPT_SUCCEED, 0);
}

/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/

BOOL StopMonitor( DWORD SlotNb, DWORD* pThreadExitCode )
{
   
   
   
   HANDLE hThread;
   DWORD threadExitCode;
   DWORD dwStatus;

   if (SlotNb >= MAX_SLOT)
   {
      SetLastError( NTE_FAIL );
      return FALSE;
   }

   hThread = Slot[SlotNb].CheckThread;
   Slot[SlotNb].CheckThread = NULL;
   Slot[SlotNb].CheckThreadStateEmpty = FALSE;

   if (hThread==NULL)
   {
       return TRUE;
   }

   g_fStopMonitor[SlotNb] = TRUE;
   SCardCancel( hCardContextCheck[SlotNb] );
   dwStatus = WaitForSingleObject( hThread, 30000 );

   if (dwStatus == WAIT_TIMEOUT)
   {
      DBG_PRINT( TEXT("THREAD: ...WaitForSingleObject() timeout, thread handle: %08x"), hThread );
      // + [FP]      
      // TerminateThread( hThread, 0 );
      // - [FP]
   }
   else
   if (dwStatus == WAIT_FAILED)
   {
      DBG_PRINT( TEXT("THREAD: ...WaitForSingleObject() failed!, thread handle: %08x"), hThread );
      return FALSE;
   }
      
   GetExitCodeThread( hThread, &threadExitCode );
   if (pThreadExitCode) *pThreadExitCode = threadExitCode;
   
   CloseHandle( hThread );
   return TRUE;

}


/* -----------------------------------------------------------------------------
Function: CheckReaderThead
Out:
    ExitCode: 
        0 = any scard error
        1 = scard context has been cancelled
        2 = card has been removed
Global variables
    g_fStopMonitor[SlotNb] can stops the thread

--------------------------------------------------------------------------------*/

unsigned WINAPI CheckReaderThread( void* lpParameter )
{
   DWORD lRet, ExitCode;   
   DWORD SlotNb = (DWORD)((DWORD_PTR)lpParameter);
   
   ExitCode = 0;
   

   if (SlotNb >= MAX_SLOT)
   {
      return ExitCode;
   }
   
   DBG_PRINT(TEXT("CheckReaderThread on Slot %d\n"),SlotNb);

   if (hCardContextCheck[SlotNb] == 0)
   {
      lRet = SCardEstablishContext (SCARD_SCOPE_SYSTEM, 0, 0, &hCardContextCheck[SlotNb]);
      if (lRet != SCARD_S_SUCCESS)
      {
         DBG_PRINT(TEXT("CheckReaderThread. SCardEstablishContext returns 0x%x\n"),lRet);
         return ExitCode;
      }
   }

   while (( !ExitCode)  && (!g_fStopMonitor[SlotNb]))
   {
      lRet = SCardGetStatusChange(hCardContextCheck[SlotNb], INFINITE, &Slot[SlotNb].ReaderState, 1);
      if (lRet == SCARD_E_CANCELLED)
      {
         ExitCode = 1;
      }
      else
      {
         if (lRet == SCARD_S_SUCCESS)
         {
            if (Slot[SlotNb].ReaderState.dwEventState & SCARD_STATE_EMPTY)
            {

                   DBG_PRINT(TEXT("Card has been removed"));
               Slot[SlotNb].CheckThreadStateEmpty = TRUE;
               GpkLocalLock();
               // TT 19/11/99: When the card is removed, reset the PIN
               // Slot[SlotNb].ClearPin();NK 06.02.2001
               Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle));

               Slot[SlotNb].Read_Public = FALSE;
               Slot[SlotNb].Read_Priv   = FALSE;
               zap_gpk_objects( SlotNb, FALSE );
               zap_gpk_objects( SlotNb, TRUE );
               Slot[SlotNb].NbKeyFile   = 0;
               Slot[SlotNb].GpkMaxSessionKey = 0;
               GpkLocalUnlock();
 
               // the thread has done is job, exit.
               ExitCode = 2 ;
            }
            else
            {
               Slot[SlotNb].ReaderState.dwCurrentState = Slot[SlotNb].ReaderState.dwEventState;
            }
         }
         // [FP] stop the thread on any other error returned by
         //SCardGetStatusChange to avoid endless loop
         else
         {
            DBG_PRINT(TEXT("Problem with RM"));

            Slot[SlotNb].CheckThreadStateEmpty = TRUE;
            GpkLocalLock();
            // Slot[SlotNb].ClearPin();NK 06.02.2001
            Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle));

            Slot[SlotNb].Read_Public = FALSE;
            Slot[SlotNb].Read_Priv   = FALSE;
            zap_gpk_objects( SlotNb, FALSE );
            zap_gpk_objects( SlotNb, TRUE );
            Slot[SlotNb].NbKeyFile   = 0;
            Slot[SlotNb].GpkMaxSessionKey = 0;
            //Slot[SlotNb].CheckThread = 0;
            GpkLocalUnlock();

            ExitCode = 2;
         }
      }
   } 
   
   if (hCardContextCheck[SlotNb] != 0)
   {
      SCardReleaseContext( hCardContextCheck[SlotNb] );
      hCardContextCheck[SlotNb] = 0;
   }
      
   
   return ExitCode;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
BOOL   BeginCheckReaderThread(DWORD SlotNb)
{
   unsigned  checkThreadId;
   DWORD lRet;   
   SCARDCONTEXT     hCardContextThread;

   if (SlotNb >= MAX_SLOT)
   {
      SetLastError( NTE_FAIL );
      return FALSE;
   }

   // Monitoring thread
   if (Slot[SlotNb].CheckThread == NULL)
   {
        // In this case, use an auxiliairy thread to check if the card has
        // been removed from this reader.

        // checks the initial state
        lRet = SCardEstablishContext (SCARD_SCOPE_SYSTEM, 0, 0, &hCardContextThread);
        if (lRet != SCARD_S_SUCCESS)
        {
         return FALSE;
        }
        Slot[SlotNb].ReaderState.szReader       = Slot[SlotNb].szReaderName;
        Slot[SlotNb].ReaderState.dwCurrentState = SCARD_STATE_UNAWARE;
        lRet = SCardGetStatusChange(hCardContextThread, 1, &Slot[SlotNb].ReaderState, 1);
        if (hCardContextThread != 0)
        {
          SCardReleaseContext( hCardContextThread );
          hCardContextCheck[SlotNb] = 0;
        }

        if (lRet != SCARD_S_SUCCESS)
        {
           return FALSE;
        }
        Slot[SlotNb].ReaderState.dwCurrentState = Slot[SlotNb].ReaderState.dwEventState;

        // Allocate and trigger the thread, if there is a card
        g_fStopMonitor[SlotNb]   = FALSE;
        Slot[SlotNb].CheckThreadStateEmpty = FALSE;

        if (Slot[SlotNb].ReaderState.dwEventState & SCARD_STATE_PRESENT)
        {

            Slot[SlotNb].CheckThread = (HANDLE)_beginthreadex( 0, 0, CheckReaderThread,
                                (LPVOID)((DWORD_PTR)SlotNb), 0, &checkThreadId );
        }

    }

    return TRUE;
}

static BOOL PIN_Validation(HCRYPTPROV hProv)
{
   BOOL          CryptResp;
   DWORD         nPinFree;
   DWORD         SlotNb;
   TCHAR         szCspTitle[MAX_STRING];
   PINCACHE_PINS Pins;
   DWORD         dwStatus;     

   SlotNb = ProvCont[hProv].Slot;
   
   // Get PIN free presentation number
   nPinFree = get_pin_free(hProv);
   
   // The flags of the context should be passed to the GUI functions with the global variable
   CspFlags = ProvCont[hProv].Flags;

   // Failure to retreive PIN free presentation count (-1)
   if ( nPinFree == DWORD(-1) )
   {
      // Slot[SlotNb].ClearPin();
      Flush_MSPinCache( &(Slot[SlotNb].hPinCacheHandle) );
      RETURN ( CRYPT_FAILED, NTE_FAIL );
   }

   // PIN is locked
   if ( nPinFree == 0 )
   {
      // Slot[SlotNb].ClearPin();
      Flush_MSPinCache( &(Slot[SlotNb].hPinCacheHandle) );

      if ( ProvCont[hProv].Flags & CRYPT_SILENT )
      {
         RETURN ( CRYPT_FAILED, SCARD_W_CHV_BLOCKED );
      }
      else
      {
         LoadString( g_hInstMod, IDS_GPKCSP_TITLE, szCspTitle, sizeof(szCspTitle)/sizeof(TCHAR) );
         DisplayMessage( TEXT("locked"), szCspTitle, 0 );
         RETURN ( CRYPT_FAILED, SCARD_W_CHV_BLOCKED );
      }
   }

   // Normal PIN verification   

   // dwGpkPinLen  = strlen(Slot[SlotNb].GetPin());
   dwGpkPinLen = PIN_LEN + 1;
   dwStatus = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                                (BYTE*)szGpkPin,  
                                &dwGpkPinLen );

   if ( (dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_EMPTY) )
      RETURN (CRYPT_FAILED, dwStatus);

   bNewPin    = FALSE;
   bChangePin = FALSE;
   
   if ( dwStatus == ERROR_EMPTY )
   {
      if (ProvCont[hProv].Flags & CRYPT_SILENT)
      {
         RETURN ( CRYPT_FAILED, NTE_SILENT_CONTEXT );
      }
      
            for(;;)
            {
                Select_MF( hProv );
                SCardEndTransaction( ProvCont[hProv].hCard, SCARD_LEAVE_CARD );
      
                DialogBox( g_hInstRes, TEXT("PINDIALOG"), GetAppWindow(), PinDlgProc );
      
                if ( dwGpkPinLen == 0 )
                {
                     RETURN( CRYPT_FAILED, SCARD_W_CANCELLED_BY_USER );
                }
                else
                {
                    bool    bCardReinserted=false;

                    if( !Coherent(hProv, &bCardReinserted) )
                        RETURN ( CRYPT_FAILED, NTE_FAIL );
                    if(bCardReinserted)
                        continue;

                    // Slot[SlotNb].SetPin( szGpkPin );
                    if (!bChangePin)
                            PopulatePins( &Pins, (BYTE *)szGpkPin, dwGpkPinLen, 0, 0 );
                    else
                            PopulatePins( &Pins, (BYTE *)szGpkPin, dwGpkPinLen, (BYTE *)szGpkNewPin, wGpkNewPinLen );

                    dwStatus = Add_MSPinCache( &(Slot[SlotNb].hPinCacheHandle),
                                                                            &Pins, 
                                                                            Callback_VerifyChangePin2, 
                                                                            (void*)hProv );

                    memset(szGpkPin, 0, sizeof(szGpkPin));
                    dwGpkPinLen=0;
                    memset(szGpkNewPin, 0, sizeof(szGpkNewPin));
                    wGpkNewPinLen=0;
                    if( dwStatus != ERROR_SUCCESS && dwStatus != SCARD_W_WRONG_CHV )
                    {
                            RETURN ( CRYPT_FAILED, dwStatus );
                    }
                }
                break;
            } // for
   }
   else
   {
       CryptResp = verify_pin( hProv, szGpkPin, dwGpkPinLen );

       if ( CryptResp )
       {
           dwStatus = ERROR_SUCCESS;
       }
       else
       {
           Flush_MSPinCache( &(Slot[SlotNb].hPinCacheHandle) );
           dwStatus = SCARD_W_WRONG_CHV;
       }
       memset(szGpkPin, 0, sizeof(szGpkPin));
       dwGpkPinLen=0;
   }
   
   if ( dwStatus != ERROR_SUCCESS )
   {
      if ( ProvCont[hProv].Flags & CRYPT_SILENT )
      {
         // Slot[SlotNb].ClearPin();
         //Flush_MSPinCache( &(Slot[SlotNb].hPinCacheHandle) );
         RETURN ( CRYPT_FAILED, SCARD_W_WRONG_CHV );
      }

      do
      {
         bNewPin     = FALSE;
         bChangePin  = FALSE;
         
         nPinFree = get_pin_free(hProv);

         // Failure to retrieve PIN free presentation count (-1)
         if ( nPinFree == DWORD(-1) )
         {
            // Slot[SlotNb].ClearPin();
            //Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle));
            RETURN ( CRYPT_FAILED, NTE_FAIL );
         }
         else if ( nPinFree > 0 )
         {
            LoadString( g_hInstMod, IDS_GPKCSP_TITLE, szCspTitle, sizeof(szCspTitle)/sizeof(TCHAR) );
            DisplayMessage( TEXT("badpin"), szCspTitle, &nPinFree );

                        for(;;)
                        {
                            Select_MF( hProv );
                            SCardEndTransaction( ProvCont[hProv].hCard, SCARD_LEAVE_CARD );

                            DialogBox( g_hInstRes, TEXT("PINDIALOG"), GetAppWindow(), PinDlgProc );

                            if (dwGpkPinLen != 0)
                            {
                                    bool    bCardReinserted=false;

                                    if ( !Coherent(hProv, &bCardReinserted) )
                                         RETURN ( CRYPT_FAILED, NTE_FAIL );
                                    if(bCardReinserted)
                                        continue;

                                    if (!bChangePin)
                                            PopulatePins( &Pins, (BYTE *)szGpkPin, dwGpkPinLen, 0, 0 );
                                    else
                                            PopulatePins( &Pins, (BYTE *)szGpkPin, dwGpkPinLen, (BYTE *)szGpkNewPin, wGpkNewPinLen );

                                    dwStatus = Add_MSPinCache( &(Slot[SlotNb].hPinCacheHandle),
                                                                                         &Pins, 
                                                                                         Callback_VerifyChangePin2,
                                                                                         (void*)hProv );

                                    memset(szGpkPin, 0, sizeof(szGpkPin));
                                    dwGpkPinLen=0;
                                    memset(szGpkNewPin, 0, sizeof(szGpkNewPin));
                                    wGpkNewPinLen=0;
                                    if ( dwStatus != ERROR_SUCCESS && dwStatus != SCARD_W_WRONG_CHV )
                                    {
                                            RETURN ( CRYPT_FAILED, dwStatus );
                                    }
                            }
                            break;
                        } // for
         }
         
      }
      while ( dwStatus != ERROR_SUCCESS && dwGpkPinLen != 0 && nPinFree > 0 );

      if ( dwStatus != ERROR_SUCCESS )
      {
         if ( nPinFree == 0 )
         {
            // Slot[SlotNb].ClearPin();
            //Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle));

            if ( ProvCont[hProv].Flags & CRYPT_SILENT )
            {
               RETURN ( CRYPT_FAILED, SCARD_W_CHV_BLOCKED );
            }
            else
            {
               LoadString( g_hInstMod, IDS_GPKCSP_TITLE, szCspTitle, sizeof(szCspTitle)/sizeof(TCHAR) );
               DisplayMessage( TEXT("locked"), szCspTitle, 0 );
               RETURN( CRYPT_FAILED, SCARD_W_CHV_BLOCKED );
            }
         }
         else
         {
            // Slot[SlotNb].ClearPin();
            //Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle));
            RETURN( CRYPT_FAILED, SCARD_W_CANCELLED_BY_USER );
         }
      }
   }

   memset(szGpkPin, 0x00, PIN_MAX+2);
   memset(szGpkNewPin, 0x00, PIN_MAX+2);
   dwGpkPinLen   = 0;
   wGpkNewPinLen = 0;

   RETURN(CRYPT_SUCCEED, 0);
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

BOOL VerifyDivPIN(HCRYPTPROV hProv, BOOL Local)
{
   DWORD lRet;
   BYTE MKey[9] = "F1961ACF";
   BYTE ChipSN[8];
   BYTE Data[16];
   BYTE hashData[20];
   DWORD cbData = 20;
   
   BYTE DivPIN[8];
   
   HCRYPTHASH hHash = 0;
   
   // Get Chip Serial Number
   bSendBuffer[0] = 0x80;   //CLA
   bSendBuffer[1] = 0xC0;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0xA0;   //P2
   bSendBuffer[4] = 0x08;   //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
   {
      RETURN (CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   ZeroMemory( ChipSN, sizeof(ChipSN) );
   memcpy(ChipSN, bRecvBuffer, min(bSendBuffer[4], sizeof(ChipSN)));
   
   
   // Create Data buffer
   memcpy(&Data[0], MKey, 8);
   memcpy(&Data[8], ChipSN, 8);
   
   // Create a hash object
   if (!CryptCreateHash(hProvBase, CALG_SHA, 0, 0, &hHash))
      return CRYPT_FAILED;
   
   // hash data
   if (!CryptHashData(hHash, Data, 16, 0))
   {
      lRet = GetLastError();
      CryptDestroyHash(hHash);
      RETURN (CRYPT_FAILED, lRet);
   }
   
   // get the hash value
   ZeroMemory( hashData, sizeof(hashData) );
   if (!CryptGetHashParam(hHash, HP_HASHVAL, hashData, &cbData, 0))
   {
      lRet = GetLastError();
      CryptDestroyHash(hHash);
      RETURN (CRYPT_FAILED, lRet);
   }
   
   
   // get the last 8 bytes of the hash value as diversified PIN
   memcpy(DivPIN, &hashData[20-8], 8);
   
   CryptDestroyHash(hHash);
   
   // Send the VERIFY COMMAND to the card
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0x20;   //INS
   bSendBuffer[2] = 0x00;   //P1
   if (Local)
   {
      bSendBuffer[3] = 0x02;   //P2 -> Locally it is the second PIN
   }
   else
   {
      bSendBuffer[3] = 0x00;   //P2 -> At the MF level it is the first PIN
   }
   bSendBuffer[4] = 0x08;   //Li
   memset(&bSendBuffer[5], 0x00, 8);
   memcpy(&bSendBuffer[5], DivPIN, 8);
   cbSendLength = 5 + bSendBuffer[4];
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN( CRYPT_FAILED, SCARD_E_INVALID_CHV );
   }
   
   RETURN( CRYPT_SUCCEED, 0 );
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static DWORD Select_Crypto_DF(HCRYPTPROV hProv)
{
   static BYTE GPK8000_ISO_DF[] = { 0xA0,0,0,0,0x18,0xF,0,1,0x63,0,1 };
   
   DWORD lRet;
   BOOL  CryptResp;
   
   // This function is used to avoid to presuppose the state in which the
   // card might be in

   BOOL fAgain = TRUE;
   int iRetryLimit = 3;

   while (fAgain)
   {
      if (0 == iRetryLimit--)
         fAgain = FALSE;
      else
      {
         CryptResp = Select_MF(hProv);
         if (CryptResp)
            fAgain = FALSE;
         else
            Sleep(250);
      }
   }

   if (iRetryLimit < 0)
   {
      DBG_PRINT(TEXT("Select_MF failed"));
      return CRYPT_FAILED;
   }

   // TT 22/09/99 : We now check for ISO 7816-5 compliant GPK8000
      
   ProvCont[hProv].bGPK_ISO_DF = FALSE;
   
   bSendBuffer[0] = 0x00;
   bSendBuffer[1] = 0xA4;  // Select File
   bSendBuffer[2] = 0x04;  // Select DF by name
   bSendBuffer[3] = 0x00;  // We want a response
   bSendBuffer[4] = sizeof(GPK8000_ISO_DF);
   memcpy( &bSendBuffer[5], GPK8000_ISO_DF, sizeof(GPK8000_ISO_DF) );
   cbSendLength = sizeof(GPK8000_ISO_DF) + 5;
   cbRecvLength = sizeof(bRecvBuffer);
   
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   // TT 17/11/99: Must check the status bytes
   if (!(SCARDPROBLEM(lRet,0x61FF,0x00)))
   {
      ProvCont[hProv].bGPK_ISO_DF = TRUE;
   }
   else
   {   
      // Select Dedicated Application DF on GPK Card
      BYTE lenDF = strlen(GPK_DF);
      bSendBuffer[0] = 0x00;                 //CLA
      bSendBuffer[1] = 0xA4;                 //INS
      bSendBuffer[2] = 0x04;                 //P1
      bSendBuffer[3] = 0x00;                 //P2
      bSendBuffer[4] = lenDF;
      memcpy( &bSendBuffer[5], GPK_DF, lenDF );
      cbSendLength = 5 + lenDF;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x61FF,0x00))
      {
         DBG_PRINT(TEXT("Select DF failed"));
         RETURN (CRYPT_FAILED, SCARD_E_DIR_NOT_FOUND);
      }
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL card_is_present (HCRYPTPROV hProv)
{
    DWORD lRet;
    DWORD SlotNb;

    SlotNb = ProvCont[hProv].Slot;

   /* Read Serial number to check if card is present                          */
    bSendBuffer[0] = 0x80;   //CLA
    bSendBuffer[1] = 0xC0;   //INS
    bSendBuffer[2] = 0x02;   //P1
    bSendBuffer[3] = 0xA0;   //P2
    bSendBuffer[4] = 0x08;   //Lo
    cbSendLength = 5;

    cbRecvLength = sizeof(bRecvBuffer);
    lRet = SCardTransmit(ProvCont[hProv].hCard,
                         SCARD_PCI_T0,
                         bSendBuffer,
                         cbSendLength,
                         NULL,
                         bRecvBuffer,
                         &cbRecvLength
                        );

    if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
    {
        RETURN (CRYPT_FAILED, SCARD_E_UNEXPECTED);
    }

    if (memcmp(bRecvBuffer, Slot[SlotNb].bGpkSerNb, bSendBuffer[4]))
    {
        RETURN (CRYPT_FAILED, SCARD_W_REMOVED_CARD);
    }

    RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static DWORD Auxiliary_CSP_key_size (DWORD AlgId)
{
   DWORD i, dwFlags, cbData,dwBits, res;
   BYTE pbData[1000], *ptr;
   ALG_ID aiAlgid;
   
   res = 0;
   
   // Enumerate Algo.
   for (i=0 ; ; i++)
   {
      if (i == 0)
         dwFlags = CRYPT_FIRST;
      else
         dwFlags = 0;
      
      // Retrieve information about an algorithm.
      cbData = sizeof (pbData);
      SetLastError(0);
      if (!CryptGetProvParam(hProvBase, PP_ENUMALGS, pbData, &cbData, dwFlags))
      {
         break;
      }
      
      // Extract algorithm information from the pbData buffer.
      ptr = pbData;
      aiAlgid = *(ALG_ID UNALIGNED *)ptr;
      if (aiAlgid == AlgId)
      {
         ptr += sizeof(ALG_ID);
         dwBits = *(DWORD UNALIGNED *)ptr;
         res = dwBits;
         break;
      }
   }
   return res;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL copy_gpk_key( HCRYPTPROV hProv, HCRYPTKEY hKey, DWORD dwAlgid )
{
   BOOL  CryptResp;
   DWORD dwDataLen;
   BYTE  pbData[1024];
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   NoDisplay = TRUE;
   
   if ((hKey >= 1) && (hKey <= MAX_GPK_OBJ))
   {
      dwDataLen = sizeof(pbData);
      ZeroMemory( pbData, sizeof(pbData) );
      if (MyCPExportKey(hProv, hKey, 0, PUBLICKEYBLOB, 0, pbData, &dwDataLen))
      {
         if (dwAlgid == AT_KEYEXCHANGE)
         {
            if (ProvCont[hProv].hRSAKEK != 0)
            {
               CryptResp = CryptDestroyKey (ProvCont[hProv].hRSAKEK);
               if (!CryptResp)
               {
                  NoDisplay = FALSE;
                  return CRYPT_FAILED;
               }
               ProvCont[hProv].hRSAKEK = 0;
            }
            
            CryptResp = CryptImportKey( hProvBase, pbData, dwDataLen, 0, 0,
                                        &ProvCont[hProv].hRSAKEK );
            
            //Slot[SlotNb].GpkObject[hKey].hKeyBase = ProvCont[hProv].hRSAKEK;
         }
         else
         {
            if (ProvCont[hProv].hRSASign!= 0)
            {
               CryptResp = CryptDestroyKey (ProvCont[hProv].hRSASign);
               if (!CryptResp)
               {
                  NoDisplay = FALSE;
                  return CRYPT_FAILED;
               }
               ProvCont[hProv].hRSASign = 0;
            }
            
            CryptResp = CryptImportKey( hProvBase, pbData, dwDataLen, 0, 0,
                                        &ProvCont[hProv].hRSASign );
            
            //Slot[SlotNb].GpkObject[hKey].hKeyBase = ProvCont[hProv].hRSASign;
         }
         
         if (!CryptResp)
         {
            NoDisplay = FALSE;
            return CRYPT_FAILED;
         }
      }
      else
      {
         NoDisplay = FALSE;
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }
   }
   else
   {
      NoDisplay = FALSE;
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   
   NoDisplay = FALSE;
   RETURN(CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL Select_Key_File(HCRYPTPROV hProv, int KeyFileId)
{
   DWORD lRet;
   BOOL  CryptResp;
   
   CryptResp = Select_Crypto_DF(hProv);
   if (!CryptResp)
      return CRYPT_FAILED;
   
   /* Select Key File on GPK Card                          */
   bSendBuffer[0] = 0x00;              //CLA
   bSendBuffer[1] = 0xA4;              //INS
   bSendBuffer[2] = 0x02;              //P1
   bSendBuffer[3] = 0x0C;              //P2
   bSendBuffer[4] = 0x02;          //Li
   bSendBuffer[5] = HIBYTE(KeyFileId);
   bSendBuffer[6] = LOBYTE(KeyFileId);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN (CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND);
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static DWORD Read_NbKeyFile(HCRYPTPROV hProv)
{
   
   DWORD i = 0;
   
   while ((i<MAX_REAL_KEY) && Select_Key_File(hProv, GPK_FIRST_KEY + i))
      i++;
   return i;
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static void perso_public(HCRYPTPROV hProv, int Start)
{
   DWORD i, j;
   DWORD SlotNb; 
   
   SlotNb = ProvCont[hProv].Slot;
   
   for (i = 0; i < Slot[SlotNb].NbKeyFile; i++)
   {
      Slot[SlotNb].GpkObject[Start+4*i+1].IsPrivate = FALSE;
      Slot[SlotNb].GpkObject[Start+4*i+1].Tag       = TAG_RSA_PUBLIC;
      Slot[SlotNb].GpkObject[Start+4*i+1].Flags     = 0xF000;         // Verify + Encrypt + Export + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+1].FileId    = LOBYTE(GPK_FIRST_KEY + i);
      
      Slot[SlotNb].GpkObject[Start+4*i+2].IsPrivate = FALSE;
      Slot[SlotNb].GpkObject[Start+4*i+2].Tag       = TAG_RSA_PUBLIC;
      Slot[SlotNb].GpkObject[Start+4*i+2].Flags     = 0xD000;         // Verify + Export + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+2].FileId    = LOBYTE(GPK_FIRST_KEY + i);
      
      Slot[SlotNb].GpkObject[Start+4*i+3].IsPrivate = FALSE;
      Slot[SlotNb].GpkObject[Start+4*i+3].Tag       = TAG_RSA_PRIVATE;
      Slot[SlotNb].GpkObject[Start+4*i+3].Flags     = 0xB000;         // Sign + Decrypt + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+3].FileId    = LOBYTE(GPK_FIRST_KEY + i);
      
      Slot[SlotNb].GpkObject[Start+4*i+4].IsPrivate = FALSE;
      Slot[SlotNb].GpkObject[Start+4*i+4].Tag       = TAG_RSA_PRIVATE;
      Slot[SlotNb].GpkObject[Start+4*i+4].Flags     = 0x9000;         // Sign + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+4].FileId    = LOBYTE(GPK_FIRST_KEY + i);
   }
   
   Slot[SlotNb].NbGpkObject = Start+LOBYTE(4*Slot[SlotNb].NbKeyFile);
   
   for (i = Start+1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      for (j = 0; j < MAX_FIELD; j++)
      {
         Slot[SlotNb].GpkObject[i].Field[j].bReal = TRUE;
      }
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static void perso_priv(HCRYPTPROV hProv, int Start)
{
   DWORD i, j;
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   for (i = 0; i < Slot[SlotNb].NbKeyFile; i++)
   {
      Slot[SlotNb].GpkObject[Start+4*i+1].IsPrivate = TRUE;
      Slot[SlotNb].GpkObject[Start+4*i+1].Tag       = TAG_RSA_PUBLIC;
      Slot[SlotNb].GpkObject[Start+4*i+1].Flags     = 0xF000;         // Verify + Encrypt + Export + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+1].FileId    = LOBYTE(GPK_FIRST_KEY+i);
      
      Slot[SlotNb].GpkObject[Start+4*i+2].IsPrivate = TRUE;
      Slot[SlotNb].GpkObject[Start+4*i+2].Tag       = TAG_RSA_PUBLIC;
      Slot[SlotNb].GpkObject[Start+4*i+2].Flags     = 0xD000;         // Verify + Export + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+2].FileId    = LOBYTE(GPK_FIRST_KEY+i);
      
      Slot[SlotNb].GpkObject[Start+4*i+3].IsPrivate = TRUE;
      Slot[SlotNb].GpkObject[Start+4*i+3].Tag       = TAG_RSA_PRIVATE;
      Slot[SlotNb].GpkObject[Start+4*i+3].Flags     = 0xB000;         // Sign + Decrypt + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+3].FileId    = LOBYTE(GPK_FIRST_KEY+i);
      
      Slot[SlotNb].GpkObject[Start+4*i+4].IsPrivate = TRUE;
      Slot[SlotNb].GpkObject[Start+4*i+4].Tag       = TAG_RSA_PRIVATE;
      Slot[SlotNb].GpkObject[Start+4*i+4].Flags     = 0x9000;         // Sign + Modifiable
      Slot[SlotNb].GpkObject[Start+4*i+4].FileId    = LOBYTE(GPK_FIRST_KEY+i);
   }
   
   Slot[SlotNb].NbGpkObject = Start+LOBYTE(4*Slot[SlotNb].NbKeyFile);
   
   for (i = Start+1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      for (j = 0; j < MAX_FIELD; j++)
      {
         Slot[SlotNb].GpkObject[i].Field[j].bReal = TRUE;
      }
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static void perso_card(HCRYPTPROV hProv, int Start)
{
   perso_public (hProv, Start);
   perso_priv   (hProv, Slot[ProvCont[hProv].Slot].NbGpkObject);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static void zap_gpk_objects( DWORD SlotNb, BOOL IsPrivate)
{
   WORD
      i, j;
   
   if (IsPrivate)
   {
      for (i = 0; i <= MAX_GPK_OBJ; i++)
      {
         if ((Slot[SlotNb].GpkObject[i].IsPrivate) &&
            (Slot[SlotNb].GpkObject[i].Tag > 0))
         {
            for (j = 0; j < MAX_FIELD; j++)
            {
               if (IsNotNull(Slot[SlotNb].GpkObject[i].Field[j].pValue))
               {
                  GMEM_Free(Slot[SlotNb].GpkObject[i].Field[j].pValue);
               }
            }
            
            for (j = i; j < Slot[SlotNb].NbGpkObject; j++)
            {
               Slot[SlotNb].GpkObject[j] = Slot[SlotNb].GpkObject[j+1];
            }
            
            ZeroMemory( &Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject], sizeof(GPK_OBJ));
            
            // Since the object i+1 is now at position i, the new object i has to
            // process again.
            
            i--;
            Slot[SlotNb].NbGpkObject--;
         }
      }
   }
   else
   {
      for (i = 0; i <= MAX_GPK_OBJ; i++)
      {
         for (j = 0; j < MAX_FIELD; j++)
         {
            if (IsNotNull(Slot[SlotNb].GpkObject[i].Field[j].pValue))
            {
               GMEM_Free(Slot[SlotNb].GpkObject[i].Field[j].pValue);
            }
         }
         
      }
      ZeroMemory( Slot[SlotNb].GpkObject,  sizeof(Slot[SlotNb].GpkObject) );
      ZeroMemory( Slot[SlotNb].GpkPubKeys, sizeof(Slot[SlotNb].GpkPubKeys) );
      
      Slot[SlotNb].NbGpkObject = 0;
      
      for (i = 0; i < MAX_REAL_KEY; i++)  // version 2.00.002
         Slot[SlotNb].UseFile[i] = FALSE;
      
   }
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static void clean_card(HCRYPTPROV hProv)
{
   /* Erase the GemSAFE objects of the cards BUT keep the other PKCS#11 objects */
   
   WORD i, j;
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   for (i = 0; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      if ((Slot[SlotNb].GpkObject[i].Tag <= TAG_CERTIFICATE) &&
         (Slot[SlotNb].GpkObject[i].Tag > 0))
      {
         for (j = 0; j < MAX_FIELD; j++)
         {
            if (IsNotNull(Slot[SlotNb].GpkObject[i].Field[j].pValue))
            {
               GMEM_Free(Slot[SlotNb].GpkObject[i].Field[j].pValue);
            }
         }
         
         for (j = i; j < Slot[SlotNb].NbGpkObject; j++)
         {
            Slot[SlotNb].GpkObject[j] = Slot[SlotNb].GpkObject[j+1];
         }
         
         ZeroMemory( &Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject], sizeof(GPK_OBJ) );
         
         // Since the object i+1 is now at position i, the new object i has to
         // process again.
         
         i--;
         Slot[SlotNb].NbGpkObject--;
      }
   }
   
   perso_card (hProv, Slot[SlotNb].NbGpkObject);// value of Slot[SlotNb].NbGpkObject?0?
   ZeroMemory( Slot[SlotNb].GpkPubKeys, sizeof(Slot[SlotNb].GpkPubKeys) );
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BYTE get_gpk_object_nb(HCRYPTPROV hProv, BYTE ObjId, BOOL IsPrivate)
{
   BYTE i;
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   for (i = 1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      if ((Slot[SlotNb].GpkObject[i].IsPrivate == IsPrivate)
         &&(Slot[SlotNb].GpkObject[i].ObjId == ObjId)
         )
      {
         break;
      }
   }
   
   return (i);
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BYTE calc_gpk_field(HCRYPTPROV hProv, BYTE ObjId)
{
   BYTE i;
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   for (i = Slot[SlotNb].GpkObject[ObjId].LastField; i <= 15; i++)
   {
      if (Slot[SlotNb].GpkObject[ObjId].Flags & 1<<i)
      {
         Slot[SlotNb].GpkObject[ObjId].LastField = i+1;
         break;
      }
   }
   
   return (i);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BYTE find_gpk_obj_tag_type( HCRYPTPROV hProv,
                                  BYTE  KeyTag,
                                  BYTE  KeyType,
                                  BYTE  KeyLen,
                                  BOOL  IsExchange,
                                  BOOL  IsPrivate
                                  )
{
   BYTE     i, tmp;
   DWORD    SlotNb;
   BYTE     keysetID;
   GPK_OBJ* pObject;
   
   SlotNb = ProvCont[hProv].Slot;
   
   tmp = 0;
   
   for (i = 1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      pObject = &Slot[SlotNb].GpkObject[i];
      
      if ( pObject->Tag != KeyTag )
         continue;
      
      if ( pObject->IsPrivate != IsPrivate )
         continue;
      
      if (IsExchange && !(pObject->Flags & FLAG_EXCHANGE))
         continue;
      
      if ( (KeyType == 0xFF)
         || (KeyType == 0x00 && !pObject->IsCreated && pObject->PubKey.KeySize == KeyLen)
         || (KeyType != 0x00 &&  pObject->IsCreated && pObject->Field[POS_KEY_TYPE].pValue[0] == KeyType)
         )
      {
         // Key file...
         if (!Slot[SlotNb].UseFile[pObject->FileId - GPK_FIRST_KEY])
         {
            // If the file never has been used, use it. Otherwise, keep on the search
            return i;
         }
         else
         {
            // Not a key file...
            // Keep this possible choice. The file has already been
            // used but another one may exist.
            if (ProvCont[hProv].bLegacyKeyset)
            {
               tmp = i;
            }
            else
            {
               if ( (pObject->Flags & FLAG_KEYSET)
                  && (pObject->Field[POS_KEYSET].pValue))
               {
                  keysetID = pObject->Field[POS_KEYSET].pValue[0];
                  if (keysetID == ProvCont[hProv].keysetID)
                  {
                     tmp = i;
                  }
               }               
            }
         }
      }
   }
   
   return tmp;
}



/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BYTE find_gpk_obj_tag_file(HCRYPTPROV hProv, BYTE KeyTag, BYTE FileId, BOOL IsExchange)
{
   BYTE i;
   DWORD SlotNb;   
   GPK_OBJ* pObject;
   
   SlotNb = ProvCont[hProv].Slot;    
   
   for (i = 1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      pObject = &Slot[SlotNb].GpkObject[i];
      
      if (pObject->Tag != KeyTag)
         continue;
      
      if (pObject->FileId != FileId)
         continue;
      
      if (pObject->IsPrivate == FALSE)
         continue;
      
      if (IsExchange && !(pObject->Flags & FLAG_EXCHANGE))
         continue;
      
      if (!pObject->IsCreated)
      {
         return i;
      }
   }
   return 0;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL read_gpk_pub_key(HCRYPTPROV  hProv,
                             HCRYPTKEY   hKey,
                             GPK_EXP_KEY *PubKey
                             )
{
   
   DWORD     lRet;
   BYTE      Sfi, RecLen, RecNum;
   BOOL      IsLast = FALSE;
   DWORD     SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   ZeroMemory( PubKey, sizeof(GPK_EXP_KEY) );
   
   /* Check if Public Key file already read to avoid new access if possible   */
   if (Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY].KeySize > 0)
   {
      memcpy(PubKey,
         &(Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY]),
         sizeof(GPK_EXP_KEY)
         );
      RETURN(CRYPT_SUCCEED, 0);
   }
   
   /* Initialize Default Public key value                                     */
   memcpy(PubKey->Exposant, "\x01\x00\x01", 3);
   PubKey->ExpSize = 3;
   
   /* Calculate Short File id of PK file for P2 parameter                     */
   Sfi = 0x04 | (Slot[SlotNb].GpkObject[hKey].FileId<<3);
   
   /* First record to read is number 2, number 1 is reserved for TAG_INFO     */
   RecNum = 2;
   do
   {
      /* Read Record (RecNum) to get size                                     */
      bSendBuffer[0] = 0x00;   //CLA
      bSendBuffer[1] = 0xB2;   //INS
      bSendBuffer[2] = RecNum; //P1
      bSendBuffer[3] = Sfi;    //P2
      bSendBuffer[4] = 0xFB;   //Lo
      cbSendLength   = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x0000,0xFF))
      {
         RETURN (CRYPT_FAILED, SCARD_W_EOF);
      }

      if (2 == cbRecvLength)
      {
          // 
          // If the receive length is two bytes, we know there's an error
          // condition.
          //

          if (bRecvBuffer[0] == 0x6C) // Communication bufer exceeded
          {
              // Re-send the request for the same record, this time with
              // the correct record length.

              RecLen = bRecvBuffer[1];
    
              /* Read Record (RecNum) to get value                                    */
              bSendBuffer[0] = 0x00;     //CLA
              bSendBuffer[1] = 0xB2;     //INS
              bSendBuffer[2] = RecNum;   //P1
              bSendBuffer[3] = Sfi;      //P2
              bSendBuffer[4] = RecLen;   //Lo
              cbSendLength   = 5;
              
              cbRecvLength = sizeof(bRecvBuffer);
              lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                                    cbSendLength, 0, bRecvBuffer, &cbRecvLength );
              if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
              {
                 RETURN (CRYPT_FAILED, SCARD_W_EOF);
              }
          }
          else
          {
              // Some other error occurred.  We're done.
              IsLast = TRUE;
              break;
          }
      }
      else
      {
          // Received a valid response from the card.  Set the correct
          // record length for this case.

          RecLen = (BYTE) (cbRecvLength - 2); // subtract length of status bytes
      }

      /* Which Record is it?                                               */
      switch (bRecvBuffer[0])
      {
         /* This is the Modulus                                               */
      case 0x01:
         {
            ZeroMemory( PubKey->Modulus, PubKey->KeySize );
            PubKey->KeySize = RecLen-1;
            r_memcpy(PubKey->Modulus, &bRecvBuffer[1],RecLen-1);
         }
         break;
         
         /* This is the Public Exposant                                       */
      case 0x06:
      case 0x07:
         {
            ZeroMemory( PubKey->Exposant, PubKey->ExpSize );
            PubKey->ExpSize = RecLen-1;
            r_memcpy(PubKey->Exposant, &bRecvBuffer[1],RecLen-1);
         }
         break;
         
         /* This is an unknown or not signifiant record, ignore it            */
      default:
         break;
      }
      
      RecNum++;
   }
   while (!IsLast);
   
   if ((PubKey->KeySize == 0) || (PubKey->ExpSize == 0))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_PUBLIC_KEY);
   }
   
   /* Store Public key to avoid new read if requested                         */
   memcpy(&(Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY]),
      PubKey,
      sizeof(GPK_EXP_KEY)
      );
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL read_gpk_objects(HCRYPTPROV hProv, BOOL IsPrivate)
{
   DWORD lRet;
   DWORD
      dwGpkObjLen,
      dwNumberofCommands,
      dwLastCommandLen,
      dwCommandLen,
      i, j,
      dwLen,
      dwNb,
      FirstObj;
   BYTE
      curId,
      EmptyBuff[512];
   DWORD SlotNb;
   WORD offset;
   
   
   
   ZeroMemory( EmptyBuff, sizeof(EmptyBuff) );
   
   SlotNb = ProvCont[hProv].Slot;
   
   BeginWait();
   
   zap_gpk_objects( SlotNb, IsPrivate);
   FirstObj = Slot[SlotNb].NbGpkObject;
   
   /* Select Dedicated Object storage EF on GPK Card                */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   if (IsPrivate)
   {
      bSendBuffer[5] = HIBYTE(GPK_OBJ_PRIV_EF);
      bSendBuffer[6] = LOBYTE(GPK_OBJ_PRIV_EF);
   }
   else
   {
      bSendBuffer[5] = HIBYTE(GPK_OBJ_PUB_EF);
      bSendBuffer[6] = LOBYTE(GPK_OBJ_PUB_EF);
   }
   cbSendLength = 7;
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
   {
      if (IsPrivate)
      {
         perso_priv (hProv, Slot[SlotNb].NbGpkObject);
      }
      else
      {
         perso_public (hProv, Slot[SlotNb].NbGpkObject);
      }
      RETURN (CRYPT_SUCCEED, 0);
   }
   
   /* Get Response                                                            */
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );

   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN (CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   dwGpkObjLen = bRecvBuffer[8]*256 + bRecvBuffer[9];
   
   if (IsNotNull(g_pbGpkObj))
   {
      GMEM_Free(g_pbGpkObj);
   }
   g_pbGpkObj = (BYTE*)GMEM_Alloc(dwGpkObjLen);
   if (IsNull(g_pbGpkObj))
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   /* Read the Objects EF                                                     */
   dwNumberofCommands = (dwGpkObjLen-1)/FILE_CHUNK_SIZE + 1;
   dwLastCommandLen   = dwGpkObjLen%FILE_CHUNK_SIZE;
   
   if (dwLastCommandLen == 0)
   {
      dwLastCommandLen = FILE_CHUNK_SIZE;
   }
   
   dwCommandLen = FILE_CHUNK_SIZE;
   for (i=0; i < dwNumberofCommands ; i++)
   {
      if (i == dwNumberofCommands - 1)
      {
         dwCommandLen = dwLastCommandLen;
      }
      /* Read FILE_CHUCK_SIZE bytes or last bytes                             */
      bSendBuffer[0] = 0x00;                          //CLA
      bSendBuffer[1] = 0xB0;                          //INS
      offset = (WORD)(i * FILE_CHUNK_SIZE) / ProvCont[hProv].dataUnitSize;
      bSendBuffer[2] = HIBYTE( offset );
      bSendBuffer[3] = LOBYTE( offset );
      bSendBuffer[4] = (BYTE) dwCommandLen;           //Lo
      cbSendLength = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      
      if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
         RETURN( CRYPT_FAILED, SCARD_W_EOF );

      memcpy( &g_pbGpkObj[i*FILE_CHUNK_SIZE], bRecvBuffer, cbRecvLength - 2 );
      
      if (memcmp(bRecvBuffer, EmptyBuff, cbRecvLength -2) == 0)
         break;
   }
   
   // Fill Gpk Fixed Objects structure with read Buffer
   i = 0;
   while (i < dwGpkObjLen)
   {
      // No more fixed object
      if (g_pbGpkObj[i] == 0x00)
      {
         i++;
         break;
      }
      
      if (Slot[SlotNb].NbGpkObject >= MAX_GPK_OBJ)
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);

      Slot[SlotNb].NbGpkObject++;
      
      // Initalize fields
      for (j = 0; j < MAX_FIELD; j++)
      {
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Field[j].bReal = TRUE;
      }
      
      // Tag
      Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Tag = g_pbGpkObj[i];
      
      i++;
      
      if (i > dwGpkObjLen-1)
         RETURN( CRYPT_FAILED, SCARD_W_EOF );
      
      // Flags
      Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Flags = (g_pbGpkObj[i]*256) + g_pbGpkObj[i+1];
      i = i + 2;
      
      // IsPrivate
      Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].IsPrivate = IsPrivate;
      
      // IsCreated
      if (Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Tag >= TAG_CERTIFICATE)
      {
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].IsCreated = TRUE;
      }
      else if ((Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Tag <= TAG_DSA_PRIVATE)
            &&(Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Flags & FLAG_KEY_TYPE)
         )
      {
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].IsCreated = TRUE;
      }
      else
      {
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].IsCreated = FALSE;
      }
      
      // Object Id ?
      if ((Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Flags & 0x0FFF) != 0x0000)
      {
         if (i > dwGpkObjLen)
         {
            RETURN (CRYPT_FAILED, SCARD_W_EOF);
         }
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].ObjId = g_pbGpkObj[i];
         i++;
      }
      else
      {
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].ObjId = 0xFF;
      }
      
      // File Id ?
      if (Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].Tag <= TAG_CERTIFICATE)
      {
         if (i > dwGpkObjLen)
         {
            RETURN (CRYPT_FAILED, SCARD_W_EOF);
         }
         Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].FileId = g_pbGpkObj[i];
         i++;
         
         if (Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].IsCreated)
         {
            // If the object has been created, the corresponding key file is used
            Slot[SlotNb].UseFile[ Slot[SlotNb].GpkObject[Slot[SlotNb].NbGpkObject].FileId - GPK_FIRST_KEY] = TRUE;
         }
      }
   }
   
   // Fill Gpk Variable Objects structure with read Buffer
   curId = 0;
   dwNb = 0;
   while (i < dwGpkObjLen)
   {
      if (g_pbGpkObj[i] == 0xFF)
      {
         break;
      }
      
      // Field length
      dwLen = 0;
      if (g_pbGpkObj[i] & 0x80)
      {
         dwLen = (g_pbGpkObj[i] & 0x7F) * 256;
         i++;
      }
      
      if (i > dwGpkObjLen)
      {
         RETURN (CRYPT_FAILED, SCARD_W_EOF);
      }
      
      dwLen = dwLen + g_pbGpkObj[i];
      i++;
      
      /* Object Id for retrieve object number                                 */
      if (i > dwGpkObjLen)
      {
         RETURN (CRYPT_FAILED, SCARD_W_EOF);
      }
      
      curId = g_pbGpkObj[i];
      i++;
      dwNb = get_gpk_object_nb(hProv, curId, IsPrivate);
      j = calc_gpk_field(hProv, (BYTE)dwNb);
      
      /* Object Field length                                                  */
      Slot[SlotNb].GpkObject[dwNb].Field[j].Len = (WORD)dwLen;
      
      /* Object Field value                                                   */
      if (dwLen > 0)
      {
         if ((i + dwLen - 1)> dwGpkObjLen)
         {
            RETURN (CRYPT_FAILED, SCARD_W_EOF);
         }
         
         Slot[SlotNb]. GpkObject[dwNb].Field[j].pValue = (BYTE*)GMEM_Alloc(dwLen);
         if (IsNull(Slot[SlotNb].GpkObject[dwNb].Field[j].pValue))
         {
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         memcpy(Slot[SlotNb].GpkObject[dwNb].Field[j].pValue, &g_pbGpkObj[i], dwLen);
         i = i + dwLen;
         Slot[SlotNb].GpkObject[dwNb].Field[j].bReal = TRUE;
      }
      else
      {
         Slot[SlotNb].GpkObject[dwNb].Field[j].bReal = FALSE;
      }
   }
   
   /* Read Extra objects attributes                                           */
   for (i = FirstObj+1; i <= Slot[SlotNb].NbGpkObject; i++)
   {
      /* RSA Public or Private keys                                           */
      if ((Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PUBLIC)
         ||(Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PRIVATE)
         )
      {
         /* Modulus and Public Exponant                                       */
         if (!read_gpk_pub_key(hProv, i, &(Slot[SlotNb].GpkObject[i].PubKey)))
            return CRYPT_FAILED;
         
         //if ((Slot[SlotNb].GpkObject[i].Flags & FLAG_EXCHANGE) == FLAG_EXCHANGE)
         //{
         //   Slot[SlotNb].GpkObject[i].hKeyBase = ProvCont[hProv].hRSAKEK;
         //}
         //else
         //{
         //   Slot[SlotNb].GpkObject[i].hKeyBase = ProvCont[hProv].hRSASign;
         //}
      }
      
      /* X509 Certificate                                                     */
      if (Slot[SlotNb].GpkObject[i].Tag == TAG_CERTIFICATE)
      {
         /* Uncompress Certificate Value if necessary                         */
         if ((Slot[SlotNb].GpkObject[i].Field[POS_VALUE].Len > 0)
            &&(Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue[0] != 0x30)
            )
         {
            BLOC InpBlock, OutBlock;
            
            InpBlock.usLen = (USHORT)Slot[SlotNb].GpkObject[i].Field[POS_VALUE].Len;
            InpBlock.pData = Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue;
            
            OutBlock.usLen = 0;
            OutBlock.pData = 0;
            
            if (CC_Uncompress(&InpBlock, &OutBlock) != RV_SUCCESS)
            {
               RETURN(CRYPT_FAILED, SCARD_E_CERTIFICATE_UNAVAILABLE);
            }
            
            OutBlock.pData = (BYTE*)GMEM_Alloc (OutBlock.usLen);
            if (IsNull(OutBlock.pData))
            {
               RETURN(CRYPT_FAILED, NTE_NO_MEMORY);
            }
            
            if (CC_Uncompress(&InpBlock, &OutBlock) != RV_SUCCESS)
            {
               GMEM_Free (OutBlock.pData);
               RETURN(CRYPT_FAILED, SCARD_E_CERTIFICATE_UNAVAILABLE);
            }
            
            GMEM_Free(Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue);
            
            Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue = (BYTE*)GMEM_Alloc(OutBlock.usLen);
            if (IsNull(Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue))
            {
               GMEM_Free (OutBlock.pData);
               RETURN(CRYPT_FAILED, NTE_NO_MEMORY);
            }
            
            memcpy(Slot[SlotNb].GpkObject[i].Field[POS_VALUE].pValue,
               OutBlock.pData,
               OutBlock.usLen
               );
            Slot[SlotNb].GpkObject[i].Field[POS_VALUE].Len = OutBlock.usLen;
            GMEM_Free(OutBlock.pData);
         }
         
         /* Associated RSA key                                                */
         if (Slot[SlotNb].GpkObject[i].FileId != 0)
         {
            if (!read_gpk_pub_key(hProv, i, &(Slot[SlotNb].GpkObject[i].PubKey)))
               return CRYPT_FAILED;
         }
      }
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL prepare_write_gpk_objects(HCRYPTPROV hProv, BYTE *pbGpkObj, DWORD *dwGpkObjLen, BOOL IsPrivate)
{
   DWORD lRet;
   DWORD
      i, j, dwNb;
   WORD
      FieldLen;
   BYTE
      ObjId;
   BLOC
      InpBlock,
      OutBlock;
   DWORD SlotNb;
   DWORD FileLen;
   
   
   SlotNb = ProvCont[hProv].Slot;
   
   i = 0;
   
   
   /* Remap Internal GPK ObjId                                                */
   ObjId = 0;
   for (dwNb = 1; dwNb <= Slot[SlotNb].NbGpkObject; dwNb++)
   {
      if (((Slot[SlotNb].GpkObject[dwNb].Flags & 0x0FFF) != 0x0000) &&
         (Slot[SlotNb].GpkObject[dwNb].IsPrivate == IsPrivate)
         )
      {
         Slot[SlotNb].GpkObject[dwNb].ObjId = ObjId;
         ObjId++;
      }
   }
   
   /* Fixed Object part                                                       */
   for (dwNb = 1; dwNb <=  Slot[SlotNb].NbGpkObject; dwNb++)
   {
      
      if (Slot[SlotNb].GpkObject[dwNb].IsPrivate != IsPrivate)
      {
         continue;
      }
      
      /* Tag */
      if (i > *dwGpkObjLen)
      {
         *dwGpkObjLen = 0;
         RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
      }
      
      pbGpkObj[i] =  Slot[SlotNb].GpkObject[dwNb].Tag;
      
      i++;
      
      /* Flag */
      if (i > *dwGpkObjLen)
      {
         *dwGpkObjLen = 0;
         RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
      }
      
      pbGpkObj[i] = HIBYTE(Slot[SlotNb].GpkObject[dwNb].Flags);
      
      i++;
      
      if (i > *dwGpkObjLen)
      {
         *dwGpkObjLen = 0;
         RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
      }
      
      pbGpkObj[i] = LOBYTE(Slot[SlotNb].GpkObject[dwNb].Flags);
      
      if (i > *dwGpkObjLen)
      {
         *dwGpkObjLen = 0;
         RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
      }
      
      i++;
      
      /* Object Id ?                                                          */
      if (((Slot[SlotNb].GpkObject[dwNb].Flags & 0x0FFF) != 0x0000) &&
         (Slot[SlotNb].GpkObject[dwNb].IsPrivate == IsPrivate)
         )
      {
         if (i > *dwGpkObjLen)
         {
            *dwGpkObjLen = 0;
            RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
         }
         pbGpkObj[i] = Slot[SlotNb].GpkObject[dwNb].ObjId;
         
         i++;
      }
      
      /* File Id ?                                                            */
      if (Slot[SlotNb].GpkObject[dwNb].Tag <= TAG_CERTIFICATE)
      {
         if (i > *dwGpkObjLen)
         {
            *dwGpkObjLen = 0;
            RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
         }
         pbGpkObj[i] = Slot[SlotNb].GpkObject[dwNb].FileId;
         i++;
      }
   }
   if (i > *dwGpkObjLen)
   {
      *dwGpkObjLen = 0;
      RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
   }
   pbGpkObj[i] = 0x00;
   i++;
   
   /* Variable Object part                                                    */
   for (dwNb = 1; dwNb <= Slot[SlotNb].NbGpkObject; dwNb++)
   {
      if (Slot[SlotNb].GpkObject[dwNb].IsPrivate != IsPrivate)
      {
         continue;
      }
      
      for (j = 0; j < MAX_FIELD; j++)
      {
         if ((  (Slot[SlotNb].GpkObject[dwNb].Field[j].Len != 0) &&
            (Slot[SlotNb].GpkObject[dwNb].Field[j].bReal)
            ) ||
            (   (Slot[SlotNb].GpkObject[dwNb].Field[j].Len == 0) &&
            (!Slot[SlotNb].GpkObject[dwNb].Field[j].bReal)
            )
            )
         {
            OutBlock.usLen = 0;
            
            /* Field Length                                                   */
            if (Slot[SlotNb].GpkObject[dwNb].Field[j].bReal)
            {
               FieldLen = Slot[SlotNb].GpkObject[dwNb].Field[j].Len;
               
               /* Try to Compress Certificate Value                           */
               if ((j == POS_VALUE)
                  &&(Slot[SlotNb].GpkObject[dwNb].Tag == TAG_CERTIFICATE)
                  &&(Slot[SlotNb].GpkObject[dwNb].Field[POS_VALUE].Len > 0)
                  &&(Slot[SlotNb].GpkObject[dwNb].Field[POS_VALUE].pValue[0] == 0x30)
                  )
               {
                  InpBlock.usLen = (USHORT)Slot[SlotNb].GpkObject[dwNb].Field[POS_VALUE].Len;
                  InpBlock.pData = Slot[SlotNb].GpkObject[dwNb].Field[POS_VALUE].pValue;
                  
                  OutBlock.usLen = InpBlock.usLen+1;
                  OutBlock.pData = (BYTE*)GMEM_Alloc(OutBlock.usLen);
                  
                  if (IsNull(OutBlock.pData))
                  {
                     RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
                  }
                  
                  if (CC_Compress(&InpBlock, &OutBlock) != RV_SUCCESS)
                  {
                     OutBlock.usLen = 0;
                  }
                  else
                  {
                     FieldLen = OutBlock.usLen;
                  }
               }
               
               if (FieldLen > 0x7F)
               {
                  if (i > *dwGpkObjLen)
                  {
                     GMEM_Free(OutBlock.pData);
                     *dwGpkObjLen = 0;
                     RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
                  }
                  pbGpkObj[i] = HIBYTE(FieldLen) | 0x80;
                  i++;
               }
               
               if (i > *dwGpkObjLen)
               {
                  GMEM_Free(OutBlock.pData);
                  *dwGpkObjLen = 0;
                  RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
               }
               pbGpkObj[i] = LOBYTE(FieldLen);
               i++;
            }
            else
            {
               if (i > *dwGpkObjLen)
               {
                  GMEM_Free(OutBlock.pData);
                  *dwGpkObjLen = 0;
                  RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
               }
               pbGpkObj[i] = 0x00;
               i++;
            }
            
            /* Object Id                                                      */
            if (i > *dwGpkObjLen)
            {
               GMEM_Free(OutBlock.pData);
               *dwGpkObjLen = 0;
               RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
            }
            pbGpkObj[i] = Slot[SlotNb].GpkObject[dwNb].ObjId;
            i++;
            
            /* Field Value                                                    */
            if (Slot[SlotNb].GpkObject[dwNb].Field[j].bReal)
            {
               if ((j == POS_VALUE)
                  &&(Slot[SlotNb].GpkObject[dwNb].Tag == TAG_CERTIFICATE)
                  &&(OutBlock.usLen > 0)
                  )
               {
                  if ((i+OutBlock.usLen-1) > *dwGpkObjLen)
                  {
                     GMEM_Free(OutBlock.pData);
                     *dwGpkObjLen = 0;
                     RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
                  }
                  memcpy(&pbGpkObj[i],
                     OutBlock.pData,
                     OutBlock.usLen
                     );
                  
                  i = i + OutBlock.usLen;
                  
                  GMEM_Free(OutBlock.pData);
                  OutBlock.usLen = 0;
               }
               else
               {
                  if ((i+Slot[SlotNb].GpkObject[dwNb].Field[j].Len-1) > *dwGpkObjLen)
                  {
                     *dwGpkObjLen = 0;
                     RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
                  }
                  
                  memcpy(&pbGpkObj[i],
                     Slot[SlotNb].GpkObject[dwNb].Field[j].pValue,
                     Slot[SlotNb].GpkObject[dwNb].Field[j].Len
                     );
                  i = i + Slot[SlotNb].GpkObject[dwNb].Field[j].Len;
               }
            }
            }
        }
    }
    
    if (i > *dwGpkObjLen)
    {
       RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
    }
    
    pbGpkObj[i]  = 0xFF;
    *dwGpkObjLen = i+1;
    
    /* Select Dedicated Object storage EF on GPK Card                          */
    bSendBuffer[0] = 0x00;   //CLA
    bSendBuffer[1] = 0xA4;   //INS
    bSendBuffer[2] = 0x02;   //P1
    bSendBuffer[3] = 0x00;   //P2
    bSendBuffer[4] = 0x02;   //Li
    if (IsPrivate)
    {
       bSendBuffer[5] = HIBYTE(GPK_OBJ_PRIV_EF);
       bSendBuffer[6] = LOBYTE(GPK_OBJ_PRIV_EF);
    }
    else
    {
       bSendBuffer[5] = HIBYTE(GPK_OBJ_PUB_EF);
       bSendBuffer[6] = LOBYTE(GPK_OBJ_PUB_EF);
    }
    cbSendLength = 7;
    
    cbRecvLength = sizeof(bRecvBuffer);
    lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                          cbSendLength, 0, bRecvBuffer, &cbRecvLength );
    
    if (SCARDPROBLEM(lRet,0x61FF,0x00))
       RETURN( CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND );
    
    /* Get Response                                                            */
    bSendBuffer[0] = 0x00;           //CLA
    bSendBuffer[1] = 0xC0;           //INS
    bSendBuffer[2] = 0x00;           //P1
    bSendBuffer[3] = 0x00;           //P2
    bSendBuffer[4] = bRecvBuffer[1]; //Lo
    cbSendLength = 5;
    
    cbRecvLength = sizeof(bRecvBuffer);
    lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                          cbSendLength, 0, bRecvBuffer, &cbRecvLength );
    
    if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
       RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
    
    FileLen = bRecvBuffer[8]*256 + bRecvBuffer[9];
    
    if (*dwGpkObjLen < FileLen)
    {
       RETURN( CRYPT_SUCCEED, 0 );
    }
    else
    {
       *dwGpkObjLen = 0;
       RETURN( CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY );
    }
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL write_gpk_objects(HCRYPTPROV hProv, BYTE *pbGpkObj, DWORD dwGpkObjLen, BOOL IsErase, BOOL IsPrivate)
{
   DWORD lRet,
      i,
      dwCommandLen,
      dwNumberofCommands,
      dwLastCommandLen,
      FileLen;
   DWORD SlotNb;
   BYTE              EmptyBuff[512];
   WORD offset;
   
   
   SlotNb = ProvCont[hProv].Slot;
   
   ZeroMemory( EmptyBuff, sizeof(EmptyBuff) );
   
   BeginWait();

   // TT - 17/10/2000 - Update the timestamps
   Slot_Description* pSlot = &Slot[SlotNb];
   BYTE& refTimestamp = (IsPrivate) ? pSlot->m_TSPrivate : pSlot->m_TSPublic;

   ++refTimestamp;

   if (0 == refTimestamp)
      refTimestamp = 1;

   if (!WriteTimestamps( hProv, pSlot->m_TSPublic, pSlot->m_TSPrivate, pSlot->m_TSPIN ))
      return CRYPT_FAILED;
   
   /* Select Dedicated Object storage EF on GPK Card                          */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   if (IsPrivate)
   {
      bSendBuffer[5] = HIBYTE(GPK_OBJ_PRIV_EF);
      bSendBuffer[6] = LOBYTE(GPK_OBJ_PRIV_EF);
   }
   else
   {
      bSendBuffer[5] = HIBYTE(GPK_OBJ_PUB_EF);
      bSendBuffer[6] = LOBYTE(GPK_OBJ_PUB_EF);
   }
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      RETURN( CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND );
   
   /* Get Response                                                            */
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN (CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   FileLen = bRecvBuffer[8]*256 + bRecvBuffer[9];
   
   /* Write the Objects EF                                                    */
   dwNumberofCommands = (dwGpkObjLen-1)/FILE_CHUNK_SIZE + 1;
   dwLastCommandLen   = dwGpkObjLen%FILE_CHUNK_SIZE;
   
   if (dwLastCommandLen == 0)
   {
      dwLastCommandLen = FILE_CHUNK_SIZE;
   }
   
   dwCommandLen = FILE_CHUNK_SIZE;

   
   for (i=0; i < dwNumberofCommands ; i++)
   {
      if (i == dwNumberofCommands - 1)
      {
         dwCommandLen = dwLastCommandLen;
      }
      
      // Write FILE_CHUCK_SIZE bytes or last bytes
      bSendBuffer[0] = 0x00;                          //CLA
      bSendBuffer[1] = 0xD6;                          //INS
      offset = (WORD)(i * FILE_CHUNK_SIZE) / ProvCont[hProv].dataUnitSize;
      bSendBuffer[2] = HIBYTE( offset );
      bSendBuffer[3] = LOBYTE( offset );
      bSendBuffer[4] = (BYTE)dwCommandLen;            //Li
      memcpy( &bSendBuffer[5], &pbGpkObj[i*FILE_CHUNK_SIZE], dwCommandLen );
      cbSendLength = 5 + dwCommandLen;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000,0x00))
      {
         RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
      }
   }
   
   if (IsErase)
   {
      // Align the info on a word (4 bytes) boundary
      
      if ((dwGpkObjLen % 4) != 0)
         dwGpkObjLen = dwGpkObjLen + 4 - (dwGpkObjLen % 4);
      
      dwNumberofCommands = ((FileLen - dwGpkObjLen)-1)/FILE_CHUNK_SIZE + 1;
      dwLastCommandLen   = (FileLen - dwGpkObjLen)%FILE_CHUNK_SIZE;
      
      if (dwLastCommandLen == 0)
      {
         dwLastCommandLen = FILE_CHUNK_SIZE;
      }
      
      dwCommandLen = FILE_CHUNK_SIZE;
      
      for (i=0; i < dwNumberofCommands ; i++)
      {
         if (i == dwNumberofCommands - 1)
         {
            dwCommandLen = dwLastCommandLen;
         }
         
         // Write FILE_CHUCK_SIZE bytes or last bytes
         bSendBuffer[0] = 0x00;                          //CLA
         bSendBuffer[1] = 0xD6;                          //INS                        
         offset = (WORD)(i * FILE_CHUNK_SIZE + dwGpkObjLen) / ProvCont[hProv].dataUnitSize;
         bSendBuffer[2] = HIBYTE( offset );
         bSendBuffer[3] = LOBYTE( offset );
         bSendBuffer[4] = (BYTE)dwCommandLen;            //Li
         memcpy(&bSendBuffer[5], EmptyBuff, dwCommandLen );
         cbSendLength = 5 + dwCommandLen;
         
         cbRecvLength = sizeof(bRecvBuffer);
         lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
         if (SCARDPROBLEM(lRet,0x9000,0x00))
         {
            RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
         }
      }
   }   
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static DWORD find_tmp_free(void)
{
   DWORD i;
   TMP_OBJ* aTemp;
   
   for (i = 1; i <= MAX_TMP_KEY; i++)
   {
      if (TmpObject[i].hKeyBase == 0x00)
      {
         return (i);
      }
   }
   
   // realloc TmpObject
   // use aTemp pointer in case of failure
   aTemp = (TMP_OBJ*)GMEM_ReAlloc( TmpObject,
      (MAX_TMP_KEY + REALLOC_SIZE + 1)*sizeof(TMP_OBJ));
   
   if (IsNotNull(aTemp))
   {
      TmpObject = aTemp;
      MAX_TMP_KEY += REALLOC_SIZE;
      return (MAX_TMP_KEY - REALLOC_SIZE + 1);
   }
   
   return (0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL Context_exist(HCRYPTPROV hProv)
{
   if ((hProv > 0) && (hProv <= MAX_CONTEXT) && (ProvCont[hProv].hProv != 0))
      return (TRUE);
   else
      return (FALSE);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL hash_exist(HCRYPTHASH hHash, HCRYPTPROV hProv)
{
   if ((hHash > 0) && (hHash <= MAX_TMP_HASH) &&
      (hHashGpk[hHash].hHashBase != 0) && (hHashGpk[hHash].hProv == hProv))
      return (TRUE);
   else
      if (hHash == 0)       // Special case. The NULL Handle exits
         return (TRUE);      // It corresponds to the NULL Handle in the RSA Base
      else
         return (FALSE);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL key_exist(HCRYPTKEY hKey, HCRYPTPROV hProv)
{
   if ((hKey > 0) && (hKey <= MAX_TMP_KEY) &&
      (TmpObject[hKey].hKeyBase != 0) &&  (TmpObject[hKey].hProv == hProv))
      return (TRUE);
   else
      return (FALSE);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static DWORD find_context_free(void)
{
   DWORD i;
   Prov_Context* aTemp;
   
   for (i = 1; i <= MAX_CONTEXT; i++)
   {
      if (ProvCont[i].hProv == 0x00)
      {
         return (i);
      }
   }
   
   // realloc TmpObject
   // use aTemp pointer in case of failure
   aTemp = (Prov_Context*)GMEM_ReAlloc(ProvCont,
      (MAX_CONTEXT + REALLOC_SIZE + 1)*sizeof(Prov_Context));
   
   if (IsNotNull(aTemp))
   {
      ProvCont = aTemp;
      MAX_CONTEXT += REALLOC_SIZE;
      return (MAX_CONTEXT - REALLOC_SIZE + 1);
   }
   
   return (0);
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static DWORD find_hash_free(void)
{
   DWORD i;
   TMP_HASH* aTemp;
   
   for (i = 1; i <= MAX_TMP_HASH; i++)
   {
      if (hHashGpk[i].hHashBase == 0x00)
      {
         return (i);
      }
   }
   
   // realloc TmpObject
   // use aTemp pointer in case of failure
   aTemp = (TMP_HASH*)GMEM_ReAlloc(hHashGpk,
      (MAX_TMP_HASH + REALLOC_SIZE + 1)*sizeof(TMP_HASH));
   
   if (IsNotNull(aTemp))
   {
      hHashGpk = aTemp;
      MAX_TMP_HASH += REALLOC_SIZE;
      return (MAX_TMP_HASH - REALLOC_SIZE + 1);
   }
   
   return (0);
}

static BOOL find_reader( DWORD *SlotNb, const PTCHAR szReaderName )
{
   int i, j;
   DWORD dwReturnSlot = (DWORD)(-1);
   DWORD cchReaders, dwSts;
   LPCTSTR mszReaders = 0, szRdr;
   BOOL fFreedSlot;
   
   for (;;)
   {
      
      //
      // Look for an existing slot with this reader name.
      //
      
      for (i = 0; i < MAX_SLOT; i++)
      {
         if (0 == _tcsnicmp( Slot[i].szReaderName, szReaderName, sizeof(Slot[i].szReaderName) / sizeof(TCHAR)))
         {
            dwReturnSlot = i;
            break;
         }
      }
      if ((DWORD)(-1) != dwReturnSlot)
         break;  // All Done!
      
      
      //
      // Look for an empty reader slot.
      //
      
      for (i = 0; i < MAX_SLOT; i++)
      {
         if (IsNullStr(Slot[i].szReaderName))
         {
            _tcsncpy(Slot[i].szReaderName, szReaderName, (sizeof(Slot[i].szReaderName) / sizeof(TCHAR)) - 1);
            Slot[i].szReaderName[(sizeof(Slot[i].szReaderName)/sizeof(TCHAR))-1]=0;
            dwReturnSlot = i;
            break;
         }
      }
      if ((DWORD)(-1) != dwReturnSlot)
         break;  // All Done!
      
      
      //
      // Look for an existing unused reader, and replace it.
      //
      
      for (i = 0; i < MAX_SLOT; i++)
      {
         if (0 == Slot[i].ContextCount)
         {
            _tcsncpy( Slot[i].szReaderName, szReaderName, (sizeof(Slot[i].szReaderName) / sizeof(TCHAR)) - 1);
            Slot[i].szReaderName[(sizeof(Slot[i].szReaderName)/sizeof(TCHAR))-1]=0;
            dwReturnSlot = i;
            break;
         }
      }

      if ((DWORD)(-1) != dwReturnSlot)
         break;  // All Done!
               
      //
      // Eliminate any duplicate entries.
      //
      
      fFreedSlot = FALSE;
      for (i = 0; i < MAX_SLOT; i++)
      {
         if (0 != *Slot[i].szReaderName)
         {
            for (j = i + 1; j < MAX_SLOT; j++)
            {
               if (0 == _tcsnicmp(Slot[i].szReaderName, Slot[j].szReaderName, sizeof(Slot[i].szReaderName) / sizeof(TCHAR)))
               {
                  ZeroMemory(&Slot[j], sizeof(Slot_Description));
                  fFreedSlot = TRUE;
               }
            }
         }
      }
      if (fFreedSlot)
         continue;
      
      
      //
      // Make sure all the entries are valid.
      //
      
      cchReaders = SCARD_AUTOALLOCATE;
      fFreedSlot = FALSE;
      assert(0 != hCardContext);
      assert(0 == mszReaders);
      dwSts = SCardListReaders( hCardContext, 0, (LPTSTR)&mszReaders, &cchReaders );
      if (SCARD_S_SUCCESS != dwSts)
         goto ErrorExit;
      for (i = 0; i < MAX_SLOT; i++)
      {
         for (szRdr = mszReaders; 0 != *szRdr; szRdr += lstrlen(szRdr) + 1)
         {
            if (0 == _tcsnicmp(szRdr, Slot[i].szReaderName, sizeof(Slot[i].szReaderName) / sizeof(TCHAR)))
               break;
         }
         if (0 == *szRdr)
         {
            ZeroMemory(&Slot[i], sizeof(Slot_Description));
            fFreedSlot = TRUE;
         }
      }
      
      if (!fFreedSlot)
         goto ErrorExit;
      dwSts = SCardFreeMemory(hCardContext, mszReaders);
      assert(SCARD_S_SUCCESS == dwSts);
      mszReaders = 0;
   }
   
   *SlotNb = dwReturnSlot;
   return TRUE;
   
ErrorExit:
   if (0 != mszReaders)
      SCardFreeMemory(hCardContext, mszReaders);
   return FALSE;
}


/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL copy_tmp_key(HCRYPTPROV hProv,HCRYPTKEY hKey,
                         DWORD dwFlags,   int Algid,
                         BYTE KeyBuff[],  DWORD KeyLen,
                         BYTE SaltBuff[], DWORD SaltLen)
{
   BOOL        CryptResp;
   DWORD       i, dwDataLen, dwAlgid;
   BLOBHEADER  BlobHeader;
   BYTE        *pbTmp;
   BYTE        pbData[1024];
   
   NoDisplay = TRUE;
   
   dwDataLen = sizeof(pbData);
   ZeroMemory( pbData, sizeof(pbData) );
   
   /* Make the Blob for Session key                                        */
   BlobHeader.bType    = SIMPLEBLOB;
   BlobHeader.bVersion = CUR_BLOB_VERSION;
   BlobHeader.reserved = 0x0000;
   BlobHeader.aiKeyAlg = Algid;
   
   memcpy(pbData,
      &BlobHeader,
      sizeof(BlobHeader)
      );
   dwAlgid = CALG_RSA_KEYX;
   memcpy( &pbData[sizeof(BlobHeader)], &dwAlgid, sizeof(DWORD) );
   
   pbTmp = (BYTE*)GMEM_Alloc(dwRsaIdentityLen);
   
   if (IsNull(pbTmp))
   {
      RETURN(CRYPT_FAILED, NTE_NO_MEMORY);
   }
   
   pbTmp[0] = 0x00;
   pbTmp[1] = 0x02;
   CryptGenRandom(hProvBase, dwRsaIdentityLen-KeyLen-3, &pbTmp[2]);
   for (i = 2; i < dwRsaIdentityLen-KeyLen-1; i++)
   {
      if (pbTmp[i] == 0x00)
      {
         pbTmp[i]  = 0x01;
      }
   }
   
   pbTmp[dwRsaIdentityLen-KeyLen-1] = 0x00;
   memcpy( &pbTmp[dwRsaIdentityLen-KeyLen], KeyBuff, KeyLen );
   
   r_memcpy( &pbData[sizeof(BlobHeader)+sizeof(DWORD)], pbTmp, dwRsaIdentityLen );
   GMEM_Free(pbTmp);
   
   dwDataLen = sizeof(BLOBHEADER) + sizeof(DWORD) + dwRsaIdentityLen;
   
   /* Import Session key blob in RSA Base without the SALT, if presents     */
   
   CryptResp = CryptImportKey(hProvBase,
      pbData,
      dwDataLen,
      hRsaIdentityKey,
      dwFlags,
      &(TmpObject[hKey].hKeyBase));

   if (!CryptResp)
      return CRYPT_FAILED;

   TmpObject[hKey].hProv = hProv;
   
   if (SaltLen > 0)
   {
      // In this case, the key has been created with a SALT
      CRYPT_DATA_BLOB  sCrypt_Data_Blob;
      
      sCrypt_Data_Blob.cbData = SaltLen;
      
      sCrypt_Data_Blob.pbData = (BYTE*)GMEM_Alloc (sCrypt_Data_Blob.cbData);
      
      if (IsNull(sCrypt_Data_Blob.pbData))
      {
         RETURN(CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      memcpy( sCrypt_Data_Blob.pbData, SaltBuff, SaltLen );
      
      CryptResp = CryptSetKeyParam( TmpObject[hKey].hKeyBase, KP_SALT_EX, (BYTE*)&sCrypt_Data_Blob, 0 );
      
      GMEM_Free (sCrypt_Data_Blob.pbData);
      
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   
   NoDisplay = FALSE;
   RETURN( CRYPT_SUCCEED, 0 );
}



/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL key_unwrap( HCRYPTPROV hProv,
                        HCRYPTKEY  hKey,
                        BYTE*      pIn,
                        DWORD      dwInLen,
                        BYTE*      pOut,
                        DWORD*     pdwOutLen )
{
   DWORD lRet;
   BYTE  GpkKeySize;
   DWORD SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (hKey < 1 || hKey > MAX_GPK_OBJ)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   }
   
   if (!(Slot[SlotNb].GpkObject[hKey].Flags & FLAG_EXCHANGE))
   {
      RETURN( CRYPT_FAILED, NTE_PERM );
   }
   
   GpkKeySize = Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY].KeySize;
   if (GpkKeySize == 0)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   }
   
   if (dwInLen != GpkKeySize)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_DATA );
   }
   
   // Card Select Context for enveloppe opening
   bSendBuffer[0] = 0x80;                    //CLA
   bSendBuffer[1] = 0xA6;                    //INS
   bSendBuffer[2] = Slot[SlotNb].GpkObject[hKey].FileId;  //P1
   bSendBuffer[3] = 0x77;                    //P2
   cbSendLength   = 4;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEY_STATE );
   }
   
   // Open the enveloppe containing the session key
   bSendBuffer[0] = 0x80;            //CLA
   bSendBuffer[1] = 0x1C;            //INS
   bSendBuffer[2] = 0x00;            //P1
   bSendBuffer[3] = 0x00;            //P2
   bSendBuffer[4] = (BYTE) dwInLen;  //Lo
   
   memcpy(&bSendBuffer[5], pIn, dwInLen);
   
   cbSendLength = dwInLen + 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      RETURN( CRYPT_FAILED, SCARD_E_UNSUPPORTED_FEATURE );
   
   // Get Response
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
   
   *pdwOutLen = cbRecvLength - 2;
   r_memcpy(pOut, bRecvBuffer, *pdwOutLen);
   
   RETURN( CRYPT_SUCCEED, 0 );
}



/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BYTE GPKHashMode (HCRYPTHASH hHash)
{
   BOOL CryptResp;
   DWORD dwLen, dwTypeAlg;
   
   // This function is called only if the hHash exists
   
   dwLen = sizeof (DWORD);
   CryptResp = CryptGetHashParam( hHashGpk[hHash].hHashBase, HP_ALGID, (BYTE *)&dwTypeAlg, &dwLen, 0 );
   
   if (CryptResp)
   {
      switch (dwTypeAlg)
      {
      case CALG_MD5         : return 0x11; break;
      case CALG_SHA         : return 0x12; break;
      case CALG_SSL3_SHAMD5 : return 0x18; break;
      }
   }
   
   return 0;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL PublicEFExists(HCRYPTPROV hProv)
{
   // The DF Crypto has been already selected
   
   DWORD lRet;
   
   if (ProvCont[hProv].bGPK8000)
      return TRUE;  // Public object EF always exists on GPK8000
   
   // Select Dedicated Object storage EF on GPK Card
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_OBJ_PUB_EF);
   bSendBuffer[6] = LOBYTE(GPK_OBJ_PUB_EF);
   cbSendLength   = 7;
   cbRecvLength   = sizeof(bRecvBuffer);
   
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      return FALSE;
   
   return TRUE;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/
static BOOL Read_MaxSessionKey_EF( HCRYPTPROV hProv, DWORD* ptrMaxSessionKey )
{
   DWORD lRet;
   
   *ptrMaxSessionKey = 0; // default, nothing supported
   
   // Select System DF on GPK Card
   BYTE lenDF = strlen(SYSTEM_DF);
   bSendBuffer[0] = 0x00;                 //CLA
   bSendBuffer[1] = 0xA4;                 //INS
   bSendBuffer[2] = 0x04;                 //P1
   bSendBuffer[3] = 0x00;                 //P2
   bSendBuffer[4] = lenDF;
   memcpy( &bSendBuffer[5], SYSTEM_DF, lenDF );
   cbSendLength = 5 + lenDF;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      RETURN( CRYPT_FAILED, SCARD_E_DIR_NOT_FOUND );
   
   
   // Select Max Session key EF on GPK Card  
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(MAX_SES_KEY_EF);
   bSendBuffer[6] = LOBYTE(MAX_SES_KEY_EF);
   cbSendLength   = 7;
   cbRecvLength   = sizeof(bRecvBuffer);
   
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
   {
      RETURN (CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND);
   }
   
   // Read Max Session key data on GPK Card  
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xB0;   //INS
   bSendBuffer[2] = 0x00;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x01;   //Li
   cbSendLength   = 5;
   cbRecvLength   = sizeof(bRecvBuffer);
   
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
   {
      RETURN(CRYPT_FAILED, NTE_BAD_DATA);
   }
   
   *ptrMaxSessionKey = (bRecvBuffer[0] * 8);
   
   
   RETURN (CRYPT_SUCCEED, 0);
}



/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL init_key_set(HCRYPTPROV hProv, const char* szContainerName)
{
   
   BYTE* pbBuff1 = 0;
   WORD  wIadfLen;
   DWORD lRet, dwBuff1Len, SlotNb;
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (Slot[SlotNb].NbKeyFile == 0)
      Slot[SlotNb].NbKeyFile = Read_NbKeyFile(hProv);
   
   if (Slot[SlotNb].NbKeyFile == 0 || Slot[SlotNb].NbKeyFile > MAX_REAL_KEY)
   {
      RETURN( CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND );
   }
   
   // Select GPK EF_IADF
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_IADF_EF);
   bSendBuffer[6] = LOBYTE(GPK_IADF_EF);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );

   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      RETURN( CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND );
   
   // Get Response
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
   }
   
   wIadfLen = bRecvBuffer[8]*256 + bRecvBuffer[9];
   
   // Update GPK EF_IADF with Container Name
   memset(bSendBuffer, 0x00, sizeof(bSendBuffer));
   bSendBuffer[0] = 0x00;              //CLA
   bSendBuffer[1] = 0xD6;              //INS
   bSendBuffer[2] = 0x00;              //P1
   bSendBuffer[3] = 8 / ProvCont[hProv].dataUnitSize;
   bSendBuffer[4] = (BYTE)wIadfLen - 8;//Li
   
   ZeroMemory( &bSendBuffer[5], wIadfLen-8 );

   if (IsNullStr(szContainerName))
   {
      bSendBuffer[5]        = 0x30;
      Slot[SlotNb].InitFlag = FALSE;
   }
   else
   {
      bSendBuffer[5]        = 0x31;
      Slot[SlotNb].InitFlag = TRUE;
   }
   
   strncpy( (char*)&bSendBuffer[6], szContainerName, sizeof(bSendBuffer)-7);
   cbSendLength = wIadfLen - 8 + 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   if (!Select_Crypto_DF(hProv))
      return CRYPT_FAILED;
   
   // Get Response
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   // Initialize New Container Name
   ZeroMemory( ProvCont[hProv].szContainer, sizeof(ProvCont[hProv].szContainer) );
   memcpy(ProvCont[hProv].szContainer, &bRecvBuffer[5], cbRecvLength - 7);
   
   if (!PublicEFExists(hProv))
   {
      // The GPK4000suo still has its generation on-board filter. No key has been
      // generated yet.
      RETURN( CRYPT_SUCCEED, 0 );
   }

   // New verify Pin code because DF reselected   
   if (!PIN_Validation(hProv))
   {
      lRet = GetLastError();
      Select_MF(hProv);
      RETURN( CRYPT_FAILED, lRet );
   }
   
   if (read_gpk_objects( hProv, FALSE ))
   {
      if (read_gpk_objects( hProv, TRUE ))
      {
         /* Re-personalize the card BUT keep the PKCS#11 objects not related
            to the GemSAFE application                                      */
         Slot[SlotNb].Read_Public = FALSE;
         Slot[SlotNb].Read_Priv   = FALSE;
         clean_card(hProv);
      }
      else
      {
         /* An error occured in the card; ERASE all the objects  */
         Slot[SlotNb].Read_Public = FALSE;
         zap_gpk_objects(SlotNb, FALSE);
         
         /* Re-personalize the card                                        */
         perso_card(hProv, 0);
      }
   }
   else
   {
      /* An error occured in the card; ERASE all the objects  */
      Slot[SlotNb].Read_Public = FALSE;
      zap_gpk_objects(SlotNb, FALSE);
      
      /* Re-personalize the card                                           */
      perso_card(hProv, 0);
   }
   
   pbBuff1 = (BYTE*)GMEM_Alloc(MAX_GPK_PUBLIC);

   if (IsNull(pbBuff1))
      RETURN( CRYPT_FAILED, NTE_NO_MEMORY );

   bool bErrorInTryOccured=false;
   __try
   {
      dwBuff1Len = MAX_GPK_PUBLIC;
      if (prepare_write_gpk_objects( hProv, pbBuff1, &dwBuff1Len, FALSE ))
      {
          if (!write_gpk_objects( hProv, pbBuff1, dwBuff1Len, TRUE, FALSE ))
             bErrorInTryOccured=true;
      }
      else bErrorInTryOccured=true;
   }
   __finally
   {   
      GMEM_Free( pbBuff1 );
   }
   if(bErrorInTryOccured)
       return CRYPT_FAILED;

   pbBuff1 = (BYTE*)GMEM_Alloc( MAX_GPK_PRIVATE );

   if (IsNull(pbBuff1))
      RETURN( CRYPT_FAILED, NTE_NO_MEMORY );

   __try
   {   
      dwBuff1Len = MAX_GPK_PRIVATE;
      if (prepare_write_gpk_objects( hProv, pbBuff1, &dwBuff1Len, TRUE ))
      {
          if (!write_gpk_objects( hProv, pbBuff1, dwBuff1Len, TRUE, TRUE ))
             bErrorInTryOccured=true;
      }
      else bErrorInTryOccured=true;
   }
   __finally
   {
      GMEM_Free( pbBuff1 );
   }
   if(bErrorInTryOccured)
       return CRYPT_FAILED;

   RETURN( CRYPT_SUCCEED, 0 );
}

/*------------------------------------------------------------------------------
* static int ExtractContent(ASN1 *pAsn1)
*
* Description : Extract contents of a Asn1 block 'pAsn1->Asn1' and place it
*               in 'pAsn1->Content'.
*
* Remarks     : Field Asn1.pData is allocated by calling function.
*
* In          : pAsn1->Asn1.pData
*
* Out         : This fileds are filled (if RV_SUCCESS) :
*                - Tag
*                - Asn1.usLen
*                - Content.usLen
*                - Content.pData
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_INVALID_DATA : Asn1 block format not supported.
*
------------------------------------------------------------------------------*/
static int ExtractContent(ASN1 *pAsn1)

{
   BYTE* pData;
   int   NbBytes, i;
   
   
   pData = pAsn1->Asn1.pData;
   
   if ((pData[0] & 0x1F) == 0x1F)
   {
      // High-tag-number: not supported
      return RV_INVALID_DATA;
   }
   else
   {
      pAsn1->Tag = pData[0];
   }
   
   if (pData[1] == 0x80)
   {
      // Constructed, indefinite-length method : not supported
      return (RV_INVALID_DATA);
   }
   else if (pData[1] > 0x82)
   {
      // Constructed, definite-length method : too long
      return (RV_INVALID_DATA);
   }
   else if (pData[1] < 0x80)
   {
      // Primitive, definite-length method
      pAsn1->Content.usLen = pData[1];
      pAsn1->Content.pData = &pData[2];
      
      pAsn1->Asn1.usLen = pAsn1->Content.usLen + 2;
   }
   else
   {
      // Constructed, definite-length method
      NbBytes = pData[1] & 0x7F;
      
      pAsn1->Content.usLen = 0;
      for (i = 0; i < NbBytes; i++)
      {
         pAsn1->Content.usLen = (pAsn1->Content.usLen << 8) + pData[2+i];
      }
      pAsn1->Content.pData = &pData[2+NbBytes];
      
      pAsn1->Asn1.usLen = pAsn1->Content.usLen + 2 + NbBytes;
   }
   
   return RV_SUCCESS;
}

/**********************************************************************************/
static BOOL Read_Priv_Obj (HCRYPTPROV hProv)
{
   DWORD lRet;
   
   if (!PIN_Validation(hProv))
   {
      lRet = GetLastError();
      Select_MF(hProv);
      SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
      RETURN( CRYPT_FAILED, lRet );
   }
      
   if (!Slot[ProvCont[hProv].Slot].Read_Priv)
   {
      if (!read_gpk_objects(hProv, TRUE))
      {
         lRet = GetLastError();
         Select_MF(hProv);
         SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
         RETURN( CRYPT_FAILED, lRet );
      }
            
      Slot[ProvCont[hProv].Slot].Read_Priv = TRUE;
   }
   
   
   RETURN( CRYPT_SUCCEED, 0 );
}

/**********************************************************************************/
BOOL Coherent(HCRYPTPROV hProv, bool *bCardReinserted)
{
   DWORD  lRet, SlotNb;

   if(bCardReinserted)
     {
            *bCardReinserted=false;
     }
     if (!Context_exist(hProv))
      RETURN( CRYPT_FAILED, NTE_BAD_UID );
   
   
   // [mv - 15/05/98]
   // No access to the card in this case
   if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
        ProvCont[hProv].isContNameNullBlank )
   {
      RETURN( CRYPT_SUCCEED, 0 );
   }
   
   SlotNb = ProvCont[hProv].Slot;

   // The thread is stopping, wait for it
   if ( Slot[SlotNb].CheckThreadStateEmpty)
   {
        DWORD  threadExitCode;
        StopMonitor(SlotNb,&threadExitCode);
       
        // TT 19/11/99: When the card is removed, reset the PIN
        //Slot[SlotNb].ClearPin(); [FP] already cleared

        Slot[SlotNb].Read_Public = FALSE;
        Slot[SlotNb].Read_Priv   = FALSE;
        zap_gpk_objects( SlotNb, FALSE );
        zap_gpk_objects( SlotNb, TRUE );
        Slot[SlotNb].NbKeyFile   = 0;
        Slot[SlotNb].GpkMaxSessionKey = 0;
        
        // [FP] req for Whistler, if card has been removed, ask card to continue
        SCARDHANDLE hCard = 0;
        TCHAR szReaderName[512];
          DWORD dwFlags = ProvCont[hProv].Flags;
          if (dwFlags & CRYPT_NEWKEYSET) dwFlags = dwFlags^CRYPT_NEWKEYSET; // always find the keyset on the card
        DWORD dwStatus = OpenCard(ProvCont[hProv].szContainer, dwFlags, &hCard, szReaderName, sizeof(szReaderName)/sizeof(TCHAR));
        if ((hCard == 0) || (dwStatus != SCARD_S_SUCCESS))
        {
            if ((dwStatus == SCARD_E_CANCELLED) && (dwFlags & CRYPT_SILENT))
            {
                    // Silent reconnection to the card failed
                dwStatus = SCARD_W_REMOVED_CARD;
            }
           //ReleaseProvider(hProv);
           Slot[SlotNb].CheckThreadStateEmpty = TRUE;
           RETURN (CRYPT_FAILED, dwStatus);
        }
        else
        {
            if (ProvCont[hProv].Slot != g_FuncSlotNb)
            {
                DWORD OldSlotNb = SlotNb;
                SlotNb = ProvCont[hProv].Slot = g_FuncSlotNb;

                //copy slot info
                //Slot[SlotNb].SetPin(Slot[OldSlotNb].GetPin());                

                Slot[SlotNb].InitFlag = Slot[OldSlotNb].InitFlag;
                memcpy(Slot[SlotNb].bGpkSerNb, Slot[OldSlotNb].bGpkSerNb, 8);
                Slot[SlotNb].ContextCount = Slot[OldSlotNb].ContextCount;
                //Slot[SlotNb].CheckThread = Slot[OldSlotNb].CheckThread;

                // clean old slot
                Slot[OldSlotNb].ContextCount = 0;
                // Slot[OldSlotNb].ClearPin();

                // synchronize other contexts
                for (DWORD i = 1; i < MAX_CONTEXT; i++)
                {
                    if (Context_exist(i))
                    {
                        if (ProvCont[i].Slot == OldSlotNb)
                        {
                            ProvCont[i].Slot = SlotNb;
                            ProvCont[i].hCard = 0;
                            ProvCont[i].bDisconnected = TRUE;
                        }
                    }
                }

            }
            else
            {
                // synchronize other contexts
                for (DWORD i = 1; i < MAX_CONTEXT; i++)
                {
                    if (Context_exist(i))
                    {
                        if ((ProvCont[i].Slot == SlotNb) && (i != hProv))
                        {
                            ProvCont[i].hCard = 0;
                            ProvCont[i].bDisconnected = TRUE;
                        }
                    }
                }
            }

            // compare SN
            bSendBuffer[0] = 0x80;   //CLA
            bSendBuffer[1] = 0xC0;   //INS
            bSendBuffer[2] = 0x02;   //P1
            bSendBuffer[3] = 0xA0;   //P2
            bSendBuffer[4] = 0x08;   //Lo
            cbSendLength = 5;
            
            cbRecvLength = sizeof(bRecvBuffer);
            lRet = SCardTransmit(hCard,
                                 SCARD_PCI_T0,
                                 bSendBuffer,
                                 cbSendLength,
                                 NULL,
                                 bRecvBuffer,
                                 &cbRecvLength);
            
            if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
            {
                //ReleaseProvider(hProv);
                RETURN (CRYPT_FAILED, (SCARD_S_SUCCESS == lRet) ? NTE_FAIL : lRet);
            }

            if (memcmp(Slot[SlotNb].bGpkSerNb, bRecvBuffer, bSendBuffer[4]) != 0)
            {
                //ReleaseProvider(hProv);
                RETURN (CRYPT_FAILED, NTE_FAIL);
            }
        }
        
        ProvCont[hProv].hCard = hCard;
        if(bCardReinserted)
        {
          *bCardReinserted=true;
        }

        // reassign hKeyBase
        //BOOL CryptResp;
        //HCRYPTKEY hPubKey = 0;
        //CryptResp = MyCPGetUserKey(hProv, AT_KEYEXCHANGE, &hPubKey);
 
        //if (CryptResp && hPubKey !=0 && ProvCont[hProv].hRSAKEK!=0)
        //  Slot[SlotNb].GpkObject[hPubKey].hKeyBase = ProvCont[hProv].hRSAKEK;
  
        //CryptResp = MyCPGetUserKey(hProv, AT_SIGNATURE, &hPubKey);
 
        //if (CryptResp && hPubKey !=0 && ProvCont[hProv].hRSASign!=0)
        //  Slot[SlotNb].GpkObject[hPubKey].hKeyBase = ProvCont[hProv].hRSASign;
   }

   if (ProvCont[hProv].bDisconnected)
   {
       DWORD dwProto;
       DWORD dwSts = ConnectToCard( Slot[SlotNb].szReaderName,
                                  SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0,
                                  &ProvCont[hProv].hCard, &dwProto );
         
      if (dwSts != SCARD_S_SUCCESS)
      {
         //ReleaseProvider(hProv);
         RETURN( CRYPT_FAILED, dwSts );
      } 
      
      ProvCont[hProv].bDisconnected = FALSE;
   }

   //////////////////////////////////////////////////////////
   /*if (!Prepare_CardBeginTransaction(hProv))
      return CRYPT_FAILED;
   
   lRet = SCardBeginTransaction(ProvCont[hProv].hCard);

   if (SCARDPROBLEM(lRet,0x0000,0xFF))
   {
      RETURN (CRYPT_FAILED, lRet);
   }*/

   lRet = BeginTransaction(ProvCont[hProv].hCard);
   if (lRet != SCARD_S_SUCCESS)
   {
      RETURN (CRYPT_FAILED, lRet);
   }

   // Monitoring thread
   BeginCheckReaderThread(SlotNb);

   // Make sure that the card has not been replaced by another one [JMR 27-07]
   if (!Select_Crypto_DF(hProv))
   {
      lRet = GetLastError();
      clean_slot(SlotNb, &ProvCont[hProv]);
      
      SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
      RETURN (CRYPT_FAILED, lRet);
   }
   
   // TT - START 17/10/2000 - Check the card's timestamps
   if (!Slot[SlotNb].ValidateTimestamps(hProv))
   {
      SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
      return CRYPT_FAILED;
   }
   // TT - END 17/10/2000

   // Check modif flags
   if (!Slot[SlotNb].Read_Public)
   {
      if (!read_gpk_objects(hProv, FALSE))
      {
         lRet = GetLastError();
         Select_MF(hProv);
         SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
         RETURN (CRYPT_FAILED, lRet);
      }
            
      Slot[SlotNb].Read_Public = TRUE;
      Slot[SlotNb].Read_Priv   = FALSE;
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*------------------------------------------------------------------------------
* int MakeLabel(BYTE *pValue, USHORT usValueLen,
*                   BYTE *pLabel, USHORT *pusLabelLen
*               )
*
* In          : pValue : Certificat value
*               usValueLen : Value length
*
* Out         : pLabel : Certificate Label
*               pLabelLen : Field length
*
* Responses   : RV_SUCCESS : All is OK.
*               RV_INVALID_DATA : Bad certificate value format.
*               RV_BUFFER_TOO_SMALL : At least one buffer is to small.
*
------------------------------------------------------------------------------*/
int MakeLabel(BYTE *pValue, USHORT usValueLen,
              BYTE *pLabel, USHORT *pusLabelLen
              )
              
{
   ASN1
      AttributeTypePart,
      AttributeValuePart,
      AVA,
      RDN,
      Value,
      tbsCert,
      serialNumberPart,
      signaturePart,
      issuerPart,
      validityPart,
      subjectPart;
   BLOC
      OrganizationName,
      CommonName;
   BOOL
      bValuesToBeReturned;
   BYTE
      *pCurrentRDN,
      *pCurrent;
   int
      rv;
   
   OrganizationName.pData = 0;
   OrganizationName.usLen = 0;
   CommonName.pData = 0;
   CommonName.usLen = 0;
   
   bValuesToBeReturned = (pLabel != 0);
   
   Value.Asn1.pData = pValue;
   rv = ExtractContent(&Value);
   if (rv != RV_SUCCESS) return rv;
   
   tbsCert.Asn1.pData = Value.Content.pData;
   rv = ExtractContent(&tbsCert);
   if (rv != RV_SUCCESS) return rv;
   
   pCurrent = tbsCert.Content.pData;
   if (pCurrent[0] == 0xA0)
   {
      // We have A0 03 02 01 vv  where vv is the version
      pCurrent += 5;
   }
   
   serialNumberPart.Asn1.pData = pCurrent;
   rv = ExtractContent(&serialNumberPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = serialNumberPart.Content.pData + serialNumberPart.Content.usLen;
   
   signaturePart.Asn1.pData = pCurrent;
   rv = ExtractContent(&signaturePart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = signaturePart.Content.pData + signaturePart.Content.usLen;
   
   issuerPart.Asn1.pData = pCurrent;
   rv = ExtractContent(&issuerPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = issuerPart.Content.pData + issuerPart.Content.usLen;
   
   validityPart.Asn1.pData = pCurrent;
   rv = ExtractContent(&validityPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = validityPart.Content.pData + validityPart.Content.usLen;
   
   subjectPart.Asn1.pData = pCurrent;
   rv = ExtractContent(&subjectPart);
   if (rv != RV_SUCCESS) return rv;
   pCurrent = subjectPart.Content.pData + subjectPart.Content.usLen;
   
   // Search field 'OrganizationName' in 'Issuer'
   pCurrent = issuerPart.Content.pData;
   
   while (pCurrent < issuerPart.Content.pData + issuerPart.Content.usLen)
   {
      RDN.Asn1.pData = pCurrent;
      rv = ExtractContent(&RDN);
      if (rv != RV_SUCCESS) return rv;
      
      pCurrentRDN = RDN.Content.pData;
      
      while (pCurrentRDN < RDN.Content.pData + RDN.Content.usLen)
      {
         AVA.Asn1.pData = pCurrentRDN;
         rv = ExtractContent(&AVA);
         if (rv != RV_SUCCESS) return rv;
         
         AttributeTypePart.Asn1.pData = AVA.Content.pData;
         rv = ExtractContent(&AttributeTypePart);
         if (rv != RV_SUCCESS) return rv;
         
         AttributeValuePart.Asn1.pData = AttributeTypePart.Content.pData
            + AttributeTypePart.Content.usLen;
         rv = ExtractContent(&AttributeValuePart);
         if (rv != RV_SUCCESS) return rv;
         
         // Search 'OrganisationName'
         if (!memcmp("\x55\x04\x0A",
            AttributeTypePart.Content.pData,
            AttributeTypePart.Content.usLen)
            )
         {
            OrganizationName = AttributeValuePart.Content;
         }
         
         pCurrentRDN = AVA.Content.pData + AVA.Content.usLen;
      }
      
      pCurrent = RDN.Content.pData + RDN.Content.usLen;
   }
   
   // Search 'CommonName' in 'Subject'
   pCurrent = subjectPart.Content.pData;
   
   while (pCurrent < subjectPart.Content.pData + subjectPart.Content.usLen)
   {
      RDN.Asn1.pData = pCurrent;
      rv = ExtractContent(&RDN);
      if (rv != RV_SUCCESS) return rv;
      
      pCurrentRDN = RDN.Content.pData;
      
      while (pCurrentRDN < RDN.Content.pData + RDN.Content.usLen)
      {
         AVA.Asn1.pData = pCurrentRDN;
         rv = ExtractContent(&AVA);
         if (rv != RV_SUCCESS) return rv;
         
         AttributeTypePart.Asn1.pData = AVA.Content.pData;
         rv = ExtractContent(&AttributeTypePart);
         if (rv != RV_SUCCESS) return rv;
         
         AttributeValuePart.Asn1.pData = AttributeTypePart.Content.pData
            + AttributeTypePart.Content.usLen;
         rv = ExtractContent(&AttributeValuePart);
         if (rv != RV_SUCCESS) return rv;
         
         // Search 'CommonName'
         if (!memcmp("\x55\x04\x03",
            AttributeTypePart.Content.pData,
            AttributeTypePart.Content.usLen)
            )
         {
            CommonName = AttributeValuePart.Content;
         }
         
         pCurrentRDN = AVA.Content.pData + AVA.Content.usLen;
      }
      
      pCurrent = RDN.Content.pData + RDN.Content.usLen;
   }
   
   if (bValuesToBeReturned)
   {
      if ((*pusLabelLen < OrganizationName.usLen + CommonName.usLen + 6)
         )
      {
         return (RV_BUFFER_TOO_SMALL);
      }
      memcpy(pLabel,
         CommonName.pData,
         CommonName.usLen
         );
      memcpy(&pLabel[CommonName.usLen],
         "'s ",
         3
         );
      memcpy(&pLabel[CommonName.usLen+3],
         OrganizationName.pData,
         OrganizationName.usLen
         );
      memcpy(&pLabel[CommonName.usLen+3+OrganizationName.usLen],
         " ID",
         3
         );
      *pusLabelLen = OrganizationName.usLen + CommonName.usLen + 6;
   }
   else
   {
      *pusLabelLen = OrganizationName.usLen + CommonName.usLen + 6;
   }
   
   return RV_SUCCESS;
}

/* -----------------------------------------------------------------------------
[DCB3] vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv [DCB3]
--------------------------------------------------------------------------------*/
static LPCSTR read_gpk_keyset(SCARDHANDLE hLocalCard)
{
   DWORD lRet;
   BYTE lenDF;
   
   /*lRet = SCardBeginTransaction(hLocalCard);
   if (SCARD_S_SUCCESS != lRet)
      goto ErrorExit;*/

   lRet = BeginTransaction(hLocalCard);
   if (lRet != SCARD_S_SUCCESS)
      goto ErrorExit;

   /* Select GPK Card MF                                                   */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x00;   //P1
   bSendBuffer[3] = 0x0C;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_MF);
   bSendBuffer[6] = LOBYTE(GPK_MF);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hLocalCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
      goto ErrorExit;
   
   /* Select Dedicated Application DF on GPK Card                          */
   lenDF = strlen(GPK_DF);
   bSendBuffer[0] = 0x00;                 //CLA
   bSendBuffer[1] = 0xA4;                 //INS
   bSendBuffer[2] = 0x04;                 //P1
   bSendBuffer[3] = 0x00;                 //P2
   bSendBuffer[4] = lenDF;
   memcpy( &bSendBuffer[5], GPK_DF, lenDF );
   cbSendLength = 5 + lenDF;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hLocalCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
      goto ErrorExit;
   
   /* Get Response of the Select DF to obtain the IADF         */
   bSendBuffer[0] = 0x00;           //CLA
   bSendBuffer[1] = 0xC0;           //INS
   bSendBuffer[2] = 0x00;           //P1
   bSendBuffer[3] = 0x00;           //P2
   bSendBuffer[4] = bRecvBuffer[1]; //Lo
   cbSendLength = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hLocalCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      goto ErrorExit;
      
   bRecvBuffer[cbRecvLength - 2] = 0;
   SCardEndTransaction(hLocalCard, SCARD_LEAVE_CARD);
   
   return (LPCSTR)&bRecvBuffer[5];
   
ErrorExit:
   SCardEndTransaction(hLocalCard, SCARD_LEAVE_CARD);
   return 0;
}


/* -----------------------------------------------------------------------------
[DCB3] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [DCB3]
--------------------------------------------------------------------------------*/



/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/

GPK_OBJ* FindKeySet( Slot_Description* pSlot, LPCSTR szDesiredContainer )
{
   GPK_OBJ* pFirstObject = &pSlot->GpkObject[1];
   GPK_OBJ* pLastObject  = pFirstObject + pSlot->NbGpkObject;
   GPK_OBJ* pObject;
   int      len;
   
   if (IsNullStr( szDesiredContainer))
      return 0;
   
   len = strlen( szDesiredContainer );
   
   for (pObject = pFirstObject; pObject != pLastObject; ++pObject)
   {
      if ( (pObject->Tag & 0x7F) == TAG_KEYSET )
      {
         if ( pObject->Field[POS_LABEL].Len == len )
         {
            if (0==memcmp( szDesiredContainer, pObject->Field[POS_LABEL].pValue, len))
            {
               // Found the keyset
               return pObject;
            }
         }
      }
   }
   
   return 0;
}



GPK_OBJ* FindKeySetByID( Slot_Description* pSlot, BYTE keysetID )
{
   GPK_OBJ* pFirstObject = &pSlot->GpkObject[1];
   GPK_OBJ* pLastObject  = pFirstObject + pSlot->NbGpkObject;
   GPK_OBJ* pObject;
   
   for (pObject = pFirstObject; pObject != pLastObject; ++pObject)
   {
      if ( (pObject->Tag & 0x7F) == TAG_KEYSET )
      {
         if (pObject->Field[POS_ID].Len > 0)
         {
            if (keysetID == pObject->Field[POS_ID].pValue[0])
            {
               // Found the keyset
               return pObject;
            }
         }
      }
   }
   
   return 0;
}


GPK_OBJ* FindFirstKeyset( Slot_Description* pSlot )
{
   GPK_OBJ* pFirstObject = &pSlot->GpkObject[1];
   GPK_OBJ* pLastObject  = pFirstObject + pSlot->NbGpkObject;
   GPK_OBJ* pObject;
   
   for (pObject = pFirstObject; pObject != pLastObject; ++pObject)
   {
      if ( (pObject->Tag & 0x7F) == TAG_KEYSET )
      {
         return pObject;
      }
   }
   
   return 0;
}



BOOL DetectLegacy( Slot_Description* pSlot )
{
   BOOL bHasPublicKey      = FALSE;
   BOOL bHasKeyset         = FALSE;
   GPK_OBJ* pFirstObject   = &pSlot->GpkObject[1];
   GPK_OBJ* pLastObject    = pFirstObject + pSlot->NbGpkObject;
   GPK_OBJ* pObject;
   
   for (pObject = pFirstObject; pObject != pLastObject; ++pObject)
   {
      if (((pObject->Tag & 0x7F) == TAG_RSA_PUBLIC) &&
          ( pObject->IsCreated   == TRUE))
         bHasPublicKey = TRUE;
      if ( (pObject->Tag & 0x7F) == TAG_KEYSET )
         bHasKeyset = TRUE;
   }
   
   if (bHasPublicKey && !bHasKeyset)
      return TRUE;
   else
      return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the specified slot
//
//////////////////////////////////////////////////////////////////////////////////////

void InitializeSlot( DWORD SlotNb )
{
   if (SlotNb >= MAX_SLOT)
   {
      SetLastError( NTE_FAIL );
      return;
   }

   if (!InitSlot[SlotNb])
   {
      TCHAR szBuff[128];

      _tcsncpy(szBuff, Slot[SlotNb].szReaderName, 127);
      szBuff[127]=0;
      ZeroMemory(&Slot[SlotNb], sizeof(Slot_Description));
      _tcsncpy(Slot[SlotNb].szReaderName, szBuff, 127);
      Slot[SlotNb].szReaderName[127]=0;
      InitSlot[SlotNb] = TRUE;
   }

   if (Slot[SlotNb].CheckThreadStateEmpty)
   {
      DBG_PRINT(TEXT("Thread had stopped, wait for it"));
      DWORD threadExitCode;
      StopMonitor(SlotNb,&threadExitCode);

      // TT 19/11/99: When the card is removed, reset the PIN
      // Slot[SlotNb].ClearPin();

      Flush_MSPinCache(&(Slot[SlotNb].hPinCacheHandle)); // NK 06.02.2001  #5  5106
      Slot[SlotNb].Read_Public = FALSE;
      Slot[SlotNb].Read_Priv   = FALSE;
      zap_gpk_objects( SlotNb, FALSE );
      zap_gpk_objects( SlotNb, TRUE );
      Slot[SlotNb].NbKeyFile   = 0;
      Slot[SlotNb].GpkMaxSessionKey = 0;

      // [FP] +
      /*
      for (DWORD i = 1; i < MAX_CONTEXT; i++)
      {
         if (Context_exist(i))
         {
            if (ProvCont[i].Slot == SlotNb)
            {
                ProvCont[i].hCard = 0;
                ProvCont[i].bDisconnected = TRUE;
            }
        }
    }
    */
    // [FP] -
   }
   
   // Monitoring thread
   BeginCheckReaderThread(SlotNb);

}



/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/

SCARDHANDLE WINAPI funcConnect (SCARDCONTEXT hSCardContext, LPTSTR szReader, LPTSTR mszCards, PVOID pvUserData)
{
   SCARDHANDLE hCard;
   DWORD       dwProto, dwSts;
   
   GpkLocalLock();

   hCard = 0;
   dwSts = ConnectToCard( szReader, SCARD_SHARE_SHARED,
                         SCARD_PROTOCOL_T0, &hCard, &dwProto );

   if (dwSts != SCARD_S_SUCCESS)
   {
      hCard =0;
      GpkLocalUnlock();
      return 0;
   }

   if (!find_reader( &g_FuncSlotNb, szReader ))
   {
      GpkLocalUnlock();
      return 0;
   }
   
   GpkLocalUnlock();
   return hCard;
}


/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/

// TT 05/10/99
BOOL WINAPI funcCheck( SCARDCONTEXT hSCardContext, SCARDHANDLE hCard, void* pvUserData )
{
   GPK_OBJ* pKeySet = 0;
   int      hProv   = 0;
   int      SlotNb  = g_FuncSlotNb;
   BOOL     bGPK8000;
   BOOL     bResult;

   GpkLocalLock();
   
   ProvCont[hProv].hCard        = hCard;
   ProvCont[hProv].Slot         = SlotNb;
   ProvCont[hProv].dataUnitSize = 0;

   //GpkLocalLock();

   /*if (!Prepare_CardBeginTransaction(0))
   {
      GpkLocalUnlock();
      return FALSE;
   }*/

   if (BeginTransaction(hCard) != SCARD_S_SUCCESS)
   {
      GpkLocalUnlock();
      return FALSE;
   }

   LPCSTR  szDesiredContainer = (char*)pvUserData;
/*
   GPK_OBJ* pKeySet = 0;
   int      hProv   = 0;
   int      SlotNb  = g_FuncSlotNb;
   BOOL     bGPK8000;
   BOOL     bResult;
*/
   InitializeSlot( SlotNb );
      
   // If we are acquiring a new keyset, we return TRUE
   if ( szDesiredContainer == 0 || *szDesiredContainer == 0)
   {
      SCardEndTransaction(hCard, SCARD_LEAVE_CARD);
      GpkLocalUnlock();
      return TRUE;
   }

   // Read the public objects
/*
   ProvCont[hProv].hCard        = hCard;
   ProvCont[hProv].Slot         = SlotNb;
   ProvCont[hProv].dataUnitSize = 0;
*/
   bResult = Select_Crypto_DF( hProv );
   if (bResult)
   { 
      bResult = Slot[SlotNb].ValidateTimestamps(hProv);
      
      if (bResult && !Slot[SlotNb].Read_Public)
      {
         bResult = read_gpk_objects( hProv, FALSE );
         
         if (bResult)
         {
            Slot[SlotNb].Read_Public   = TRUE;
            Slot[SlotNb].Read_Priv     = FALSE;
         }
      }
      
      if (bResult)
      {
         pKeySet = FindKeySet( &Slot[SlotNb], szDesiredContainer );
         if (pKeySet==0)
         {
            if (DetectGPK8000( hCard, &bGPK8000 ) == SCARD_S_SUCCESS)
            {
               bResult = FALSE;
               if (!bGPK8000)
               {
                  BOOL bLegacy = DetectLegacy( &Slot[SlotNb] );
                  if (bLegacy)
                  {
                     LPCSTR szCardContainer = read_gpk_keyset( hCard );
                     if (szCardContainer!=0)
                     {
                        bResult = (0 == strcmp(szCardContainer, szDesiredContainer));
                     }
                  }
               }
            }
         }
         else
         {
            bResult = TRUE;
         }
      }
   }

   ZeroMemory( &ProvCont[hProv], sizeof(ProvCont[hProv]) );
   
   SCardEndTransaction(hCard, SCARD_LEAVE_CARD);
   GpkLocalUnlock();

   return bResult;
}
// TT: END



/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
void WINAPI funcDisconnect( SCARDCONTEXT hSCardContext, SCARDHANDLE hCard, PVOID pvUserData )
{
   SCardDisconnect( hCard, SCARD_LEAVE_CARD );
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static DWORD OpenCard(CHAR* szContainerAsked, DWORD dwFlags, SCARDHANDLE* hCard, PTCHAR szReaderName, DWORD dwReaderNameLen)
{
    OPENCARDNAME open_card;
    TCHAR        szCardName[512],
                  szOpenDlgTitle[MAX_STRING];

    ZeroMemory( szReaderName, dwReaderNameLen * sizeof(TCHAR) );
    ZeroMemory( szCardName,   sizeof(szCardName) );
    
    open_card.dwStructSize     = sizeof(open_card);
    open_card.hwndOwner        = GetAppWindow();
    open_card.hSCardContext    = hCardContext;
    open_card.lpstrGroupNames  = 0;
    open_card.nMaxGroupNames   = 0;
    open_card.lpstrCardNames   = mszCardList;
    open_card.nMaxCardNames    = multistrlen(mszCardList)+1;
    open_card.rgguidInterfaces = 0;
    open_card.cguidInterfaces  = 0;
    open_card.lpstrRdr         = szReaderName;
    open_card.nMaxRdr          = dwReaderNameLen;
    open_card.lpstrCard        = szCardName;
    open_card.nMaxCard         = sizeof(szCardName) / sizeof(TCHAR);
    LoadString(g_hInstRes, 1017, szOpenDlgTitle, sizeof(szOpenDlgTitle)/sizeof(TCHAR));
    open_card.lpstrTitle       = szOpenDlgTitle;
    if (dwFlags & CRYPT_SILENT)
       open_card.dwFlags = SC_DLG_NO_UI;
    else
       open_card.dwFlags = SC_DLG_MINIMAL_UI;
    if (dwFlags & CRYPT_NEWKEYSET)                              // [DCB3]
       open_card.pvUserData    = 0;                             // [DCB3]
    else                                                        // [DCB3]
       open_card.pvUserData    = szContainerAsked;              // [DCB3]
    open_card.dwShareMode      = SCARD_SHARE_SHARED;
    open_card.dwPreferredProtocols = SCARD_PROTOCOL_T0;
    open_card.dwActiveProtocol = 0;
    open_card.lpfnConnect      = funcConnect;
    open_card.lpfnCheck        = funcCheck;
    open_card.lpfnDisconnect   = funcDisconnect;
    open_card.hCardHandle      = 0;
    
    GpkLocalUnlock();
    DWORD dwStatus = GetOpenCardName (&open_card);  
    DBG_PRINT(TEXT("dwStatus = 0x%08X, open_card.hCardHandle = 0x%08X"), dwStatus, open_card.hCardHandle);
    GpkLocalLock();
    *hCard = open_card.hCardHandle;

    return(dwStatus);
}

/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
void ReleaseProvider(HCRYPTPROV hProv)
{
   BOOL CryptResp;
   DWORD i;
   DWORD dwProto; //[FP]
   
   /* Release Hash parameters                                      */
   for (i = 1; i <= MAX_TMP_HASH; i++)
   {
      if ((hHashGpk[i].hHashBase != 0) && (hHashGpk[i].hProv == hProv))
      {
         CryptResp = CryptDestroyHash(hHashGpk[i].hHashBase);
         hHashGpk[i].hHashBase = 0;
         hHashGpk[i].hProv     = 0;
      }
   }
   
   /* Release Key parameters                                      */
   for (i = 1; i <= MAX_TMP_KEY; i++)
   {
      if ((TmpObject[i].hKeyBase != 0) && (TmpObject[i].hProv == hProv))
      {
         CryptResp = CryptDestroyKey(TmpObject[i].hKeyBase);
         TmpObject[i].hKeyBase = 0;
         TmpObject[i].hProv    = 0;
      }
   }
   
   ProvCont[hProv].hProv = 0;
   
   if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
      (ProvCont[hProv].isContNameNullBlank))
   {
      
   }
   else
   {
      // + [FP] if a transaction is opened, close it and reconnect in shared mode
      if (ProvCont[hProv].bCardTransactionOpened) 
      {
         // Select_MF(hProv); [FP] PIN not presented
         SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
         SCardReconnect(ProvCont[hProv].hCard, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &dwProto);
         ProvCont[hProv].bCardTransactionOpened = FALSE;
      }
      // - [FP]

      if (ProvCont[hProv].hRSAKEK != 0)
      {
          CryptDestroyKey( ProvCont[hProv].hRSAKEK );
          ProvCont[hProv].hRSAKEK = 0;
      }

      if (ProvCont[hProv].hRSASign != 0)
      {
          CryptDestroyKey( ProvCont[hProv].hRSASign );
          ProvCont[hProv].hRSASign = 0;
      }

      if (ProvCont[hProv].hCard != 0)
      {
         SCardDisconnect(ProvCont[hProv].hCard, SCARD_LEAVE_CARD);
         ProvCont[hProv].hCard = 0;
      }
      
      if (countCardContextRef == 0)
      {
         if (hCardContext != 0)
            SCardReleaseContext(hCardContext);
         
         hCardContext = 0;
      }
   }
   
   ProvCont[hProv].Flags               = 0;
   ProvCont[hProv].isContNameNullBlank = TRUE;
   ProvCont[hProv].hCard               = 0;
   ProvCont[hProv].Slot                = 0;
}



DWORD getAuxMaxKeyLength(HCRYPTPROV hProv)
{
   BYTE *ptr = 0;
   DWORD i;
   ALG_ID aiAlgid;
   DWORD dwBits;
   
   BYTE pbData[1000];
   DWORD cbData;
   DWORD dwFlags = 0;
   
   DWORD maxLength = 0;
   
   // Enumerate the supported algorithms.
   
   for (i=0 ; ; i++)
   {
      if (i == 0)
         dwFlags = CRYPT_FIRST;
      else
         dwFlags = 0;
      
      cbData = 1000;
      
      if (!CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &cbData, dwFlags))
         break;
      
      // Extract algorithm information from the pbData buffer.
      ptr = pbData;
      aiAlgid = *(ALG_ID UNALIGNED *)ptr;
      ptr += sizeof(ALG_ID);
      dwBits = *(DWORD UNALIGNED *)ptr;
      
      switch (aiAlgid)
      {
      case CALG_DES:          dwBits += 8;
         break;
      case CALG_3DES_112:     dwBits += 16;
         break;
      case CALG_3DES:         dwBits += 24;
         break;
      }
      
      if (GET_ALG_CLASS(aiAlgid) == ALG_CLASS_DATA_ENCRYPT)
      {
         maxLength = max(maxLength, dwBits);
      }
      
   }
   
   return maxLength;
   
}

/* -----------------------------------------------------------------------------
[FP] used in the case of PRIVATEKEYBLOB in MyCPImportKey
--------------------------------------------------------------------------------*/
BOOL LoadPrivateKey(SCARDHANDLE hCard,
                    BYTE        Sfi,
                    WORD        ElementLen,
                    CONST BYTE* pbData,
                    DWORD       dwDataLen
                    )
{
   DWORD lRet;
   
   /* Load SK APDU command                                                    */
   bSendBuffer[0] = 0x80;                 //CLA
   bSendBuffer[1] = 0x18;                 //INS
   bSendBuffer[2] = Sfi;                  //P1
   bSendBuffer[3] = (BYTE)ElementLen;     //P2
   bSendBuffer[4] = (BYTE)dwDataLen;      //Li
   memcpy(&bSendBuffer[5], pbData, dwDataLen);
   cbSendLength = 5 + dwDataLen;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   memset(bSendBuffer, 0, sizeof(bSendBuffer));
   if(SCARDPROBLEM(lRet, 0x9000, 0x00))
   {
      SetLastError(lRet);
      return (FALSE);
   }
   
   return (TRUE);
}

/*******************************************************************************
* BOOL WINAPI DllMain (HINSTANCE hInstDLL,
*                      DWORD     fdwRaison,
*                      LPVOID    lpReserved
*                     )
*
* Description :
*
* Remarks     :
*
* In          :
*
* Out         :
*
* Responses   :
*
*******************************************************************************/

BOOL WINAPI DllMain (HINSTANCE hInstDLL,
                     DWORD     fdwRaison,
                     LPVOID    lpReserved
                     )
{
   int   i;
   BOOL  ReturnValue = TRUE;
   
   switch (fdwRaison)
   {
   case DLL_PROCESS_ATTACH:
      {
         DBG_PRINT(TEXT("DLL_PROCESS_ATTACH [start]..."));
         
         g_hInstMod = hInstDLL;
         
                  
         // Allocation of TmpObject, hHashGpk and ProvCont       
         TmpObject= (TMP_OBJ*)GMEM_Alloc((MAX_TMP_KEY + 1)*sizeof(TMP_OBJ));
         hHashGpk = (TMP_HASH*)GMEM_Alloc((MAX_TMP_HASH + 1)*sizeof(TMP_HASH));
         ProvCont = (Prov_Context*)GMEM_Alloc((MAX_CONTEXT + 1)*sizeof(Prov_Context));
         
         if (IsNull(TmpObject) || IsNull(hHashGpk) || IsNull (ProvCont))
         {
            ReturnValue = FALSE;
            break;
         }
         
         ZeroMemory( ProvCont,  (MAX_CONTEXT+1) * sizeof(Prov_Context) );
         ZeroMemory( TmpObject, (MAX_TMP_KEY+1) * sizeof(TMP_OBJ) );
         ZeroMemory( hHashGpk,  (MAX_TMP_HASH+1) * sizeof(TMP_HASH) );
         
         try
                 {
                        InitializeCriticalSection(&l_csLocalLock);
                 }
                 catch(...)
                 {
                        ReturnValue=FALSE;
                 }

         
         DBG_PRINT(TEXT("...[end] DLL_PROCESS_ATTACH"));
         
         break;
      }
      
   case DLL_PROCESS_DETACH:
      {
         DBG_PRINT(TEXT("DLL_PROCESS_DETACH [start]..."));
         
         ReturnValue = TRUE;
                  
         // Deallocation of TmpObject, hHashGpk and ProvCont
         
         if (TmpObject != 0)
            GMEM_Free(TmpObject);
         if (hHashGpk != 0)
            GMEM_Free(hHashGpk);
         if (ProvCont != 0)
            GMEM_Free(ProvCont);
         
         for (i=0; i< MAX_SLOT; i++)
         {
            if (Slot[i].CheckThread != NULL)
            {
               // + [FP]
               g_fStopMonitor[i] = TRUE;
               SCardCancel( hCardContextCheck[i] );
               // TerminateThread( Slot[i].CheckThread, 0 );
               // - [FP]
               CloseHandle( Slot[i].CheckThread );
               Slot[i].CheckThread = NULL;
            }
         }
                           
         if (hProvBase != 0)
         {                
            CryptDestroyKey(hRsaIdentityKey);
            CryptReleaseContext(hProvBase, 0);
         }
         
         CC_Exit();
         
         DeleteCriticalSection(&l_csLocalLock);
         
         DBG_PRINT(TEXT("...[end] DLL_PROCESS_DETACH"));
      }
      break;
      
      
   case DLL_THREAD_ATTACH:
      InterlockedIncrement( &g_threadAttach );
      break;
      
   case DLL_THREAD_DETACH:
      InterlockedDecrement( &g_threadAttach );
      break;
    }
    return (ReturnValue);
}

/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/

BOOL InitAcquire()
{
   BOOL     CryptResp;
   DWORD    dwIgn, lRet;
   TCHAR    szCspName[MAX_STRING];
   TCHAR    szCspBaseName[256];
   TCHAR    szDictionaryName[256];
   TCHAR       szEntry[MAX_STRING];
   HKEY     hRegKey;
   int      i;

   // Initialize arrays here instead of using static initializers.
   for (i = 0; i < MAX_SLOT; ++i)
      hCardContextCheck[i] = 0;

   for (i = 0; i < MAX_SLOT; ++i)
      InitSlot[i] = FALSE;

   ZeroMemory( Slot, sizeof(Slot) );

   for (i = 0; i < MAX_SLOT; ++i)
      Slot[i].CheckThreadStateEmpty = FALSE;

   OSVERSIONINFO  osver;
   HCRYPTPROV     hProvTest;
      
   LoadString(g_hInstMod, IDS_GPKCSP_ENTRY, szEntry, sizeof(szEntry)/sizeof(TCHAR));
   DBG_PRINT(TEXT("   Registry entry: \"%s\"\n"), szEntry );
   
   lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szEntry, 0, TEXT(""), REG_OPTION_NON_VOLATILE, 
                          KEY_READ, 0, &hRegKey, &dwIgn );
   
   // Detect provider available
   CryptResp = CryptAcquireContext( &hProvTest, 0, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT );
   if (CryptResp)
   {
      lstrcpy( szCspBaseName, MS_ENHANCED_PROV );
      CryptReleaseContext( hProvTest, 0 );
   }
   else
   {
      lstrcpy( szCspBaseName, MS_DEF_PROV );
   }
   
   DBG_PRINT(TEXT("   Base CSP provider: \"%s\"\n"), szCspBaseName );
   
   hProvBase = 0;
   
   osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx (&osver);
   
   if (osver.dwPlatformId==VER_PLATFORM_WIN32_NT && osver.dwMajorVersion > 4)
   {
      CryptResp = CryptAcquireContext( &hProvBase, 0, szCspBaseName, PROV_RSA_FULL,
                                       CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET );
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   else
   {
      LoadString(g_hInstMod, IDS_GPKCSP_NAME, szCspName, sizeof(szCspName)/sizeof(TCHAR));
      CryptResp = CryptAcquireContext( &hProvBase, szCspName, szCspBaseName,
                                       PROV_RSA_FULL, CRYPT_DELETEKEYSET );
      
      if (0 != hProvBase)
      {
         CryptReleaseContext(hProvBase, 0);
      }
      
      LoadString(g_hInstMod, IDS_GPKCSP_NAME, szCspName, sizeof(szCspName)/sizeof(TCHAR));
      CryptResp = CryptAcquireContext( &hProvBase, szCspName, szCspBaseName,
                                       PROV_RSA_FULL, CRYPT_NEWKEYSET );
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   
   /* Set a Dummy RSA exchange key in RSA Base                             */
   CryptResp = CryptImportKey( hProvBase, PrivateBlob, sizeof(PrivateBlob),
                               0, 0, &hRsaIdentityKey );
   
   if (!CryptResp)
   {
      lRet = GetLastError();      
      CryptReleaseContext( hProvBase, 0 );
      RETURN( CRYPT_FAILED, lRet );
   }
   
   RC2_Key_Size = (BYTE) (Auxiliary_CSP_key_size (CALG_RC2) / 8);
   if (RC2_Key_Size == 0)
   {
      lRet = GetLastError();
      
      CryptDestroyKey(hRsaIdentityKey);       // MV - 13/03/98
      CryptReleaseContext(hProvBase, 0);      // MV - 13/03/98
      
      RETURN( CRYPT_FAILED, lRet );
   }
   
   RSA_KEK_Size = (BYTE) (Auxiliary_CSP_key_size (CALG_RSA_KEYX) / 8);
   if (RSA_KEK_Size == 0)
   {
      lRet = GetLastError();
      
      CryptDestroyKey(hRsaIdentityKey);       // MV - 13/03/98
      CryptReleaseContext(hProvBase, 0);      // MV - 13/03/98
      
      RETURN( CRYPT_FAILED, lRet );
   }
   
   AuxMaxSessionKeyLength = getAuxMaxKeyLength(hProvBase) / 8;
   if (AuxMaxSessionKeyLength == 0)
   {
      lRet = GetLastError();
      
      CryptDestroyKey(hRsaIdentityKey);       // MV - 13/03/98
      CryptReleaseContext(hProvBase, 0);      // MV - 13/03/98
      
      RETURN( CRYPT_FAILED, lRet );
   }
   
   // CARD_LIST UPDATE
   LoadString(g_hInstMod, IDS_GPKCSP_CARDLIST, mszCardList, sizeof(mszCardList)/sizeof(TCHAR));
   DBG_PRINT(TEXT("   Card list entry string: \"%s\"\n"), mszCardList );

#ifndef UNICODE
   dwIgn = sizeof(mszCardList);
   lRet = RegQueryValueEx( hRegKey, "Card List", 0, 0, (BYTE*)mszCardList, &dwIgn );
#else
   BYTE bCardList[MAX_PATH];
   DWORD dwCardListLen = MAX_PATH;

   lRet = RegQueryValueEx( hRegKey, TEXT("Card List"), 0, 0, bCardList, &dwCardListLen  );
   MultiByteToWideChar( CP_ACP, 0, (char*)bCardList, MAX_PATH, mszCardList, MAX_PATH );      
#endif

   // Find in the base registry the name (and the path) for the dictionary
   DBG_PRINT(TEXT("   Reading dictionary name...\n") );      

#ifndef UNICODE
   dwIgn = sizeof(szDictionaryName);
   lRet  = RegQueryValueEx( hRegKey, "X509 Dictionary Name", 0, 0, (BYTE*)szDictionaryName, &dwIgn );
#else
   BYTE bDictName[256];
   DWORD dwDictNameLen = 256;

   lRet  = RegQueryValueEx( hRegKey, TEXT("X509 Dictionary Name"), 0, 0, bDictName, &dwDictNameLen );   
   if (lRet == ERROR_SUCCESS)
   {
       // always use the resource dictionary
       lRet = 2;
       //MultiByteToWideChar( CP_ACP, 0, (char*)bDictName, 256, szDictionaryName, 256);
   }
#endif

   // Try to use registry dict first
  if (lRet == ERROR_SUCCESS && IsNotNull( szDictionaryName ))
  {
     lRet = CC_Init( DICT_FILE, (BYTE*)szDictionaryName );

     if (lRet != RV_SUCCESS)
        lRet = CC_Init( DICT_STANDARD, 0 );
  }
  else
     lRet = CC_Init( DICT_STANDARD, 0 );

   
   RegCloseKey(hRegKey);
   
   if (lRet)
   {
      CryptDestroyKey(hRsaIdentityKey);
      CryptReleaseContext(hProvBase, 0);
      
      RETURN (CRYPT_FAILED, NTE_NOT_FOUND);
   }
   
   // Key gen time for GPK8000
   g_GPK8000KeyGenTime512  = 0;
   g_GPK8000KeyGenTime1024 = 0;
   
   lRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Gemplus\\Cryptography\\SmartCards"),
                          0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_READ, 0, &hRegKey, 0 );
   if (lRet == ERROR_SUCCESS)
   {
      dwIgn = sizeof(g_GPK8000KeyGenTime512);
      lRet = RegQueryValueEx( hRegKey, TEXT("GPK8000KeyGenTime512"), 0, 0, (BYTE*)&g_GPK8000KeyGenTime512, &dwIgn );
      
      dwIgn = sizeof(g_GPK8000KeyGenTime1024);
      lRet = RegQueryValueEx( hRegKey, TEXT("GPK8000KeyGenTime1024"), 0, 0, (BYTE*)&g_GPK8000KeyGenTime1024, &dwIgn );

      RegCloseKey(hRegKey);
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}

/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
BOOL LegacyAcquireDeleteKeySet( HCRYPTPROV*  phProv,
                                const char*  szContainer,
                                const char*  szContainerAsked,
                                DWORD        BuffFlags )
{
   BOOL  CryptResp;
   //DWORD i;
   DWORD SlotNb;
   
   SlotNb = ProvCont[*phProv].Slot;
   
   /*if (Slot[SlotNb].ContextCount > 0)
   {
      fLocked = TRUE;
   }
   else
   {
      // Must have exclusive access to destroy a keyset
      DWORD protocol;
      lRet = SCardReconnect( ProvCont[*phProv].hCard, SCARD_SHARE_EXCLUSIVE,
                             SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &protocol );

      if (lRet==SCARD_S_SUCCESS)
          fLocked = FALSE;
      else if (lRet==SCARD_E_SHARING_VIOLATION)
          fLocked = TRUE;
      else
        RETURN( CRYPT_FAILED, lRet );
   }
      
   if (fLocked)
      RETURN( CRYPT_FAILED, SCARD_E_SHARING_VIOLATION );*/
   
   if (BuffFlags & CRYPT_VERIFYCONTEXT)
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   
   if (IsNotNullStr(szContainer))
   {
       // Accept only if the container asked is the same as the one on the card
       // OR if the container asked is NULL (default key set)
       if (IsNotNullStr(szContainerAsked) && strcmp(szContainer, szContainerAsked))
       {
          RETURN( CRYPT_FAILED, NTE_KEYSET_NOT_DEF );
       }
      
      /* Release Microsoft RSA Base Module                                       */
      //for (i = 1; i <= MAX_GPK_OBJ; i++)
      //{
      //   if (Slot[SlotNb].GpkObject[i].hKeyBase != 0)
      //   {
      //      CryptResp = CryptDestroyKey(Slot[SlotNb].GpkObject[i].hKeyBase);
      //   }
      //}
      
      //ProvCont[*phProv].hRSASign = 0;
      //ProvCont[*phProv].hRSAKEK  = 0;
      if (ProvCont[*phProv].hRSAKEK != 0)
      {
          CryptDestroyKey( ProvCont[*phProv].hRSAKEK );
          ProvCont[*phProv].hRSAKEK = 0;
      }
      if (ProvCont[*phProv].hRSASign != 0)
      {
          CryptDestroyKey( ProvCont[*phProv].hRSASign );
          ProvCont[*phProv].hRSASign = 0;
      }
      ProvCont[*phProv].hProv    = *phProv;
      ProvCont[*phProv].Flags    = BuffFlags;
      
      if (!PIN_Validation(*phProv))
         return CRYPT_FAILED;
      
      ProvCont[*phProv].hProv = 0;
      ProvCont[*phProv].Flags = 0;
      
      CryptResp = init_key_set(*phProv, "");
      
      if (!CryptResp)
         return CRYPT_FAILED;
      
      // Update the container name
      
      strcpy( ProvCont[*phProv].szContainer, "" );
      
      RETURN( CRYPT_SUCCEED, 0 );
   }
   else
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEYSET_PARAM );
   }
}


// TT 12/10/99: Bug #1454
void DeleteGPKObject( Slot_Description* pSlot, int i )
{
   GPK_OBJ* pObject = &pSlot->GpkObject[i];
   int j;
   
   // Delete object #i
   
   // Release Microsoft RSA Base Module
   if (pObject->hKeyBase != 0)
   {
      CryptDestroyKey( pObject->hKeyBase );
      pObject->hKeyBase = 0;
   }
   
   // First free all memory for this object
   for (j=0; j<MAX_FIELD; ++j)
   {
      if (pObject->Field[j].pValue)
      {
         GMEM_Free( pObject->Field[j].pValue );
         pObject->Field[j].pValue = 0;
         pObject->Field[j].Len    = 0;
      }
   }
   
   if (i < pSlot->NbGpkObject)
   {
      // Patch the hole
      memmove( pObject, pObject + 1, (pSlot->NbGpkObject - i) * sizeof(GPK_OBJ) );
   }
   
   // Clear last object
   ZeroMemory( &pSlot->GpkObject[pSlot->NbGpkObject], sizeof(GPK_OBJ) );
   
   --pSlot->NbGpkObject;
}
// TT: End


BOOL AcquireDeleteKeySet( HCRYPTPROV* phProv,
                          const char* szContainer,
                          const char* szContainerAsked,
                          DWORD       BuffFlags )
{   
   Prov_Context*     pContext;
   GPK_OBJ*          pKeySet;
   GPK_OBJ*          pObject;
   Slot_Description* pSlot;
   BYTE              keysetID;
   int               i, j, k;
   BYTE*             pbBuff1;
   DWORD             dwBuff1Len;
   DWORD             lRet;
   
   DWORD SlotNb = ProvCont[*phProv].Slot;
   
   /*if (Slot[SlotNb].ContextCount > 0)
   {
      fLocked = TRUE;
   }
   else
   {
      // Must have exclusive access to destroy a keyset
      DWORD protocol;
      lRet = SCardReconnect( ProvCont[*phProv].hCard, SCARD_SHARE_EXCLUSIVE,
                             SCARD_PROTOCOL_T0, SCARD_LEAVE_CARD, &protocol );
   
      if (lRet==SCARD_S_SUCCESS)
          fLocked = FALSE;
      else if (lRet==SCARD_E_SHARING_VIOLATION)
          fLocked = TRUE;
      else
        RETURN( CRYPT_FAILED, lRet );
   }

   if (fLocked)
   {
      RETURN( CRYPT_FAILED, SCARD_E_SHARING_VIOLATION );
   }*/
   
   if (BuffFlags & CRYPT_VERIFYCONTEXT)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   }
   
   pContext = &ProvCont[*phProv];
   pSlot    = &Slot[ pContext->Slot ];

   // if default keyset,  let's use the first
   // one available =)
   if ( IsNullStr(szContainerAsked) )
   {
      pKeySet = FindFirstKeyset( pSlot );
   }
   else
   {
      // Check if keyset is on the card
      pKeySet = FindKeySet( pSlot, szContainerAsked );
   }
   
   if (!pKeySet)
   {
      RETURN( CRYPT_FAILED, NTE_KEYSET_NOT_DEF );
   }
   
   
   // Must validate PIN to destroy the key objects
   //pContext->hRSASign   = 0;
   //pContext->hRSAKEK    = 0;
   if (pContext->hRSAKEK != 0)
   {
       CryptDestroyKey( pContext->hRSAKEK );
       pContext->hRSAKEK = 0;
   }
   if (pContext->hRSASign != 0)
   {
       CryptDestroyKey( pContext->hRSASign );
       pContext->hRSASign = 0;
   }
   pContext->hProv      = *phProv;
   pContext->Flags      = BuffFlags;
   
   if (!PIN_Validation(*phProv))
   {
      // SetLastError() already used by PIN_Validation()
      return CRYPT_FAILED;
   }
   
   if (!Read_Priv_Obj(*phProv))
      return CRYPT_FAILED;
   
   // TT 12/10/99: Bug #1454
   keysetID = pKeySet->Field[POS_ID].pValue[0];
   
   // Find objects in the keyset and destroy them
   for (i = 1; i <= pSlot->NbGpkObject; ++i)
   {
      pObject = &pSlot->GpkObject[i];
      
      if (pObject->Flags & FLAG_KEYSET && pObject->Field[POS_KEYSET].pValue[0] == keysetID)
      {
         // If we found a key, "zap it"
         if (pObject->Tag >= TAG_RSA_PUBLIC && pObject->Tag <= TAG_DSA_PRIVATE)
         {
            // Zap all keys with the same FileId
            BYTE FileId = pObject->FileId;
            
            for (j = 1; j<= pSlot->NbGpkObject; ++j)
            {
               GPK_OBJ* pObj = &pSlot->GpkObject[j];
               if (pObj->Tag >= TAG_RSA_PUBLIC && pObj->Tag <= TAG_DSA_PRIVATE)
               {
                  if (pObj->FileId == FileId)
                  {
                     pObj->Flags &= 0xF000;
                     pObj->ObjId  = 0xFF;
                     
                     // Release the fields
                     for (k=0; k<MAX_FIELD; ++k)
                     {
                        if (pObj->Field[k].pValue)
                        {
                           GMEM_Free( pObj->Field[k].pValue );
                           pObj->Field[k].pValue = 0;
                           pObj->Field[k].Len    = 0;
                        }
                        pObj->Field[k].bReal  = TRUE;
                     }
                     pObj->LastField = 0;
                     pObj->IsCreated = FALSE; //PYR 00/08/08 ensure that find_gpk_obj_tag_type will still work
                     
                     // Release Microsoft RSA Base Module
                     //if (pObj->hKeyBase != 0)
                     //{
                     //   CryptDestroyKey( pObj->hKeyBase );
                     //   pObj->hKeyBase = 0;
                     //}

                     // PYR 00/08/08. This key becomes available
                     pSlot->UseFile[FileId - GPK_FIRST_KEY] = FALSE;

                  }
               }
            }
         }
         else
         {
            // Not a key, destroy the object
            DeleteGPKObject( pSlot, i );
            --i;
         }
      }
   }
   
   // Destroy the keyset object
   DeleteGPKObject( pSlot, (int)(pKeySet - &pSlot->GpkObject[0]) );
   
   
   // TT: End
   
   // TT 12/10/99: Bug #1454 - Update the card
   pbBuff1 = (BYTE*)GMEM_Alloc( MAX_GPK_PUBLIC );
   if (IsNull(pbBuff1))
   {
      RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
   }
   
   dwBuff1Len = MAX_GPK_PUBLIC;
   if (!prepare_write_gpk_objects (pContext->hProv, pbBuff1, &dwBuff1Len, FALSE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN( CRYPT_FAILED, lRet );
   }
   
   if (!write_gpk_objects(pContext->hProv, pbBuff1, dwBuff1Len, TRUE, FALSE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN( CRYPT_FAILED, lRet );
   }
   
   GMEM_Free( pbBuff1 );
   
   pbBuff1 = (BYTE*)GMEM_Alloc( MAX_GPK_PRIVATE );
   if (IsNull(pbBuff1))
   {
      RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
   }
   
   dwBuff1Len = MAX_GPK_PRIVATE;
   if (!prepare_write_gpk_objects (pContext->hProv, pbBuff1, &dwBuff1Len, TRUE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN( CRYPT_FAILED, lRet );
   }
   
   if (!write_gpk_objects(pContext->hProv, pbBuff1, dwBuff1Len, TRUE, TRUE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN( CRYPT_FAILED, lRet );
   }
   
   GMEM_Free( pbBuff1 );
   // TT: End
   
   
   // Byebye context
   pContext->hProv          = 0;
   pContext->Flags          = 0;
   pContext->szContainer[0] = 0;
   
   RETURN( CRYPT_SUCCEED, 0 );
}


/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
BOOL LegacyAcquireNewKeySet( IN  HCRYPTPROV*  phProv,
                             OUT char*        szContainer,
                             IN  const char*  szContainerAsked,
                             IN  DWORD        BuffFlags )
{
   BOOL       CryptResp, fLocked;
   DWORD      i, SlotNb;
   HCRYPTKEY  hPubKey;
   // +NK 06.02.2001
   // BYTE  bPinValue[PIN_MAX+2];
   DWORD dwPinLength; 
   DWORD dwStatus;
   // -
   
   ProvCont[*phProv].keysetID = 0;
   
   SlotNb = ProvCont[*phProv].Slot;
   
   // If another AcquireContext - without its related ReleaseContest -
   // has been done before, this new AcquireContext can not be done
   
   if (BuffFlags & CRYPT_VERIFYCONTEXT)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
   }
   
   
   
   /*    IN CASE THAT A DELETEKEY IS NOT DONE FOR A RE-ENROLLMENT    */
   
   // Reserve the Provider Context handle since the Acquire Context succeeded
   ProvCont[*phProv].hProv = *phProv;
   ProvCont[*phProv].Flags = BuffFlags;
   
   if (Slot[SlotNb].InitFlag)
   {
      CryptResp = MyCPGetUserKey(*phProv, AT_KEYEXCHANGE, &hPubKey);
      if (CryptResp)
      {
         RETURN (CRYPT_FAILED, NTE_TOKEN_KEYSET_STORAGE_FULL);
      }
      else
      {
         CryptResp = MyCPGetUserKey(*phProv, AT_SIGNATURE, &hPubKey);
         if (CryptResp)
         {
            RETURN (CRYPT_FAILED, NTE_TOKEN_KEYSET_STORAGE_FULL);
         }
      }
   }
   
   // If another AcquireContext - without its related ReleaseContest -
   // has been done before, this new AcquireContext can not be done
   // {DCB} -- It's possible that the application that marked this busy
   //          exited without calling CryptReleaseContext.  Hence, it's
   //          possible that this check will fail even if no one else
   //          is using the card.  By making this check last, we reduce
   //          the likelyhood that this bug is encountered.
   
   fLocked = FALSE;

   if (fLocked)
   {
      RETURN (CRYPT_FAILED, SCARD_E_SHARING_VIOLATION);
   }
   

   // +NK 06.02.2001
   // if ((BuffFlags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
   
   dwStatus = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                                NULL, 
                                &dwPinLength );
   if ( (dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_EMPTY) )
      RETURN (CRYPT_FAILED, dwStatus);
   
   if ((BuffFlags & CRYPT_SILENT) && (dwStatus == ERROR_EMPTY))
   // -
   {
      RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
   }
   
   if (!PIN_Validation(*phProv))
      return CRYPT_FAILED;
   
   /* If the PIN code can be or has been entered, read the description of the
   private key parameters*/
   
   CspFlags = BuffFlags;
   
   
   if (IsNullStr(szContainerAsked))
   {
       // no szContainerAsked is specified, create the keyset object with default name
       CryptResp = init_key_set(*phProv, CSP_DEFAULTKEYSETNAME);
   }
   else
   {
       CryptResp = init_key_set(*phProv, szContainerAsked);
   }

   
   
   if (!CryptResp)
      return CRYPT_FAILED;
   
   if (PublicEFExists(*phProv))
   {
      for (i = 1; i <= Slot[SlotNb].NbGpkObject; i++)
      {
         if ((Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PUBLIC)||
            (Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PRIVATE))
         {
            read_gpk_pub_key(*phProv, i, &(Slot[SlotNb].GpkObject[i].PubKey));
         }
      }
   }
   else
   {
      for (i = 1; i <= Slot[SlotNb].NbGpkObject; i++)
      {
         if ((Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PUBLIC)||
            (Slot[SlotNb].GpkObject[i].Tag == TAG_RSA_PRIVATE))
         {
            Slot[SlotNb].GpkObject[i].PubKey.KeySize = 0;
         }
      }
   }
   // Update the container name
   if (IsNullStr(szContainerAsked))
   {
       // no szContainerAsked is specified, use default name
        strcpy( szContainer, CSP_DEFAULTKEYSETNAME );
   }
   else
   {
        strcpy( szContainer, szContainerAsked );
   }
   
      
   Slot[SlotNb].ContextCount++;
   
   countCardContextRef++;
   
   ProvCont[*phProv].keysetID = 0xFF;
   
   RETURN (CRYPT_SUCCEED, 0);
}



BOOL CreateKeyset( HCRYPTPROV hProv, Slot_Description* pSlot, LPCSTR szName, BYTE* pKeySetID )
{
   GPK_OBJ* pObject;
   BYTE*    pbBuff1;
   DWORD    dwBuff1Len;
   int      lRet;
   BYTE     keysetID;
   int      i, len;
      
   *pKeySetID = 0;
   
   if (pSlot->NbGpkObject >= MAX_GPK_OBJ)
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }   
   
   pObject = &pSlot->GpkObject[ pSlot->NbGpkObject + 1 ];
   ZeroMemory( pObject, sizeof(*pObject) );
   
   // Find an unused keyset ID
   for (keysetID = 1; keysetID < 0xFF; ++keysetID)
   {
      if (FindKeySetByID( pSlot, keysetID ) == 0)
         break;   // Found one =)
   }
   
   if (keysetID == 0xFF)
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
      
   // Now initialize the fields
   for (i=0; i<MAX_FIELD; ++i)
      pObject->Field[i].bReal = TRUE;
   
   pObject->Tag         = TAG_KEYSET;      
   pObject->Flags       = FLAG_ID | FLAG_LABEL;
   pObject->ObjId       = pSlot->NbGpkObject + 1;
   pObject->IsPrivate   = FALSE;
   
   // Keyset ID
   pObject->Field[POS_ID].Len       = 1;
   pObject->Field[POS_ID].pValue    = (BYTE*)GMEM_Alloc( 1 );
   if(IsNull(pObject->Field[POS_ID].pValue))
   {
       RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   pObject->Field[POS_ID].pValue[0] = keysetID;
   
   // Keyset name
   len = strlen( szName );
   pObject->Field[POS_LABEL].Len    = (WORD)len;
   pObject->Field[POS_LABEL].pValue = (BYTE*)GMEM_Alloc( len );
   if(IsNull(pObject->Field[POS_LABEL].pValue))
   {
       RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   memcpy( pObject->Field[POS_LABEL].pValue, szName, len );
   
   // One more object!
   ++(pSlot->NbGpkObject);
   
   *pKeySetID = keysetID;
   
   // TT 29/09/99: Save the keyset object =)
   pbBuff1 = (BYTE*)GMEM_Alloc(MAX_GPK_PUBLIC);
   if (IsNull(pbBuff1))
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   
   dwBuff1Len = MAX_GPK_PUBLIC;
   if (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, FALSE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN (CRYPT_FAILED, lRet);
   }
   
   if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, FALSE))
   {
      lRet = GetLastError();
      GMEM_Free (pbBuff1);
      RETURN (CRYPT_FAILED, lRet);
   }
   
   GMEM_Free (pbBuff1);
   // TT - END - 
   
   
   RETURN( CRYPT_SUCCEED, 0 );
}



BOOL AcquireNewKeySet( IN  HCRYPTPROV* phProv,
                       OUT char*       szContainer,
                       IN  const char* szContainerAsked,
                       DWORD           BuffFlags )
{
   Slot_Description* pSlot;
   int               SlotNb;
      
   SlotNb = ProvCont[*phProv].Slot;
   pSlot  = &Slot[SlotNb];
   
   ProvCont[*phProv].keysetID = 0;
   
   // If another AcquireContext - without its related ReleaseContest -
   // has been done before, this new AcquireContext can not be done   
   if (BuffFlags & CRYPT_VERIFYCONTEXT)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   }
   
   // Check if keyset already exist on the card
   if (FindKeySet( pSlot, szContainerAsked ))
   {
      RETURN( CRYPT_FAILED, NTE_EXISTS );
   }
   

   // Reserve the Provider Context handle since the Acquire Context succeeded
   ProvCont[*phProv].hProv = *phProv;
   ProvCont[*phProv].Flags = BuffFlags;
   
   CspFlags = BuffFlags;
   
   
   if (IsNullStr(szContainerAsked))
   {
       // no szContainerAsked is specified, create the keyset object with default name
       if (!CreateKeyset( *phProv, pSlot, CSP_DEFAULTKEYSETNAME, &ProvCont[*phProv].keysetID ))
       {
          return FALSE;
       }
       // Update the container name  
       strcpy( szContainer, CSP_DEFAULTKEYSETNAME );
   }
   else
   {
       // Create the keyset object
       if (!CreateKeyset( *phProv, pSlot, szContainerAsked, &ProvCont[*phProv].keysetID ))
       {
          return FALSE;
       }
       // Update the container name  
       strcpy( szContainer, szContainerAsked );
   }
      
   ++(pSlot->ContextCount);
   
   ++countCardContextRef;
   
   RETURN( CRYPT_SUCCEED, 0 );
}



/* -----------------------------------------------------------------------------
--------------------------------------------------------------------------------*/
BOOL LegacyAcquireUseKeySet( HCRYPTPROV* phProv,
                             const char* szContainer,
                             const char* szContainerAsked,
                             DWORD       BuffFlags )
{
   BOOL      CryptResp;
   HCRYPTKEY hPubKey;
   DWORD     SlotNb;
      
   SlotNb = ProvCont[*phProv].Slot;
   ProvCont[*phProv].keysetID = 0;
   
   if (IsNullStr(szContainer))
   {
      RETURN( CRYPT_FAILED, NTE_KEYSET_NOT_DEF );
   }
   
   // Accept only if the container asked is the same as the one on the card
   // OR if the container asked is NULL and a reader is specified (SECURE LOGON)
   if (IsNotNullStr(szContainerAsked) && strcmp(szContainer, szContainerAsked))
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEYSET );
   }
   
   // Reserve the Provider Context handle since the Acquire Context succeeded
   ProvCont[*phProv].hProv = *phProv;
   ProvCont[*phProv].Flags = BuffFlags;
   
   hPubKey = 0;
   CryptResp = MyCPGetUserKey(*phProv, AT_KEYEXCHANGE, &hPubKey);
   
   // Copy the key into the RSA Base, if the key exists AND it has not been imported
   // previously
   
   if ((CryptResp) && (hPubKey != 0) && (ProvCont[*phProv].hRSAKEK == 0))
   {
      if (!copy_gpk_key(*phProv, hPubKey, AT_KEYEXCHANGE))
         return CRYPT_FAILED;
   }
   
   hPubKey = 0;
   CryptResp = MyCPGetUserKey(*phProv, AT_SIGNATURE, &hPubKey);
   
   // Copy the key into the RSA Base, if the key exists AND it has not been imported
   // previously
   
   if (CryptResp && hPubKey!=0 && ProvCont[*phProv].hRSASign==0)
   {
      if (!copy_gpk_key(*phProv, hPubKey, AT_SIGNATURE))
         return CRYPT_FAILED;
   }
      
   Slot[SlotNb].ContextCount++;
   
   countCardContextRef++;
   
   ProvCont[*phProv].keysetID = 0xFF;
   
   RETURN( CRYPT_SUCCEED, 0 );
}



BOOL AcquireUseKeySet( HCRYPTPROV* phProv,
                       const char* szContainer,
                       const char* szContainerAsked,
                       DWORD       BuffFlags )
{
   BOOL        CryptResp;
   HCRYPTKEY   hPubKey;
   DWORD       SlotNb;
   GPK_OBJ*    pKeySet;
      
   SlotNb = ProvCont[*phProv].Slot;
   ProvCont[*phProv].keysetID = 0;
   
   // Secure logon doesn't specify a keyset name, let's use the first
   // one available =)
   if ( IsNullStr(szContainerAsked) )
   {
      pKeySet = FindFirstKeyset( &Slot[SlotNb] );
   }
   else
   {
      // Check if keyset is on the card
      pKeySet = FindKeySet( &Slot[SlotNb], szContainerAsked );
   }
   
   if (pKeySet==0)
   {      
      RETURN( CRYPT_FAILED, NTE_KEYSET_NOT_DEF );
   }
   
   // Found the container...
   memcpy( ProvCont[*phProv].szContainer, (char*)pKeySet->Field[POS_LABEL].pValue,
           pKeySet->Field[POS_LABEL].Len );
   
   // Reserve the Provider Context handle since the Acquire Context succeeded
   ProvCont[*phProv].hProv    = *phProv;
   ProvCont[*phProv].Flags    = BuffFlags;
   ProvCont[*phProv].keysetID = pKeySet->Field[POS_ID].pValue[0];
   
   hPubKey = 0;
   
   CryptResp = MyCPGetUserKey(*phProv, AT_KEYEXCHANGE, &hPubKey);
   
   // Copy the key into the RSA Base, if the key exists AND it has not been imported
   // previously
   
   if ((CryptResp) && (hPubKey != 0) && (ProvCont[*phProv].hRSAKEK == 0))
   {
      if (!copy_gpk_key(*phProv, hPubKey, AT_KEYEXCHANGE))
      {
         return CRYPT_FAILED;
      }
   }
   
   hPubKey = 0;
   CryptResp = MyCPGetUserKey(*phProv, AT_SIGNATURE, &hPubKey);
   
   // Copy the key into the RSA Base, if the key exists AND it has not been imported
   // previously
   
   if ((CryptResp) && (hPubKey != 0) && (ProvCont[*phProv].hRSASign == 0))
   {
      if (!copy_gpk_key(*phProv, hPubKey, AT_SIGNATURE))
      {
         return CRYPT_FAILED;
      }
   }
      
   Slot[SlotNb].ContextCount++;
   
   countCardContextRef++;
   
   RETURN( CRYPT_SUCCEED, 0 );
}




/*
-  MyCPAcquireContext
-
*  Purpose:
*               The CPAcquireContext function is used to acquire a context
*               handle to a cryptograghic service provider (CSP).
*
*
*  Parameters:
*               OUT phProv        -  Handle to a CSP
*               OUT pszIdentity   -  Pointer to a string which is the
*                                    identity of the logged on user
*               IN  dwFlags       -  Flags values
*               IN  pVTable       -  Pointer to table of function pointers
*
*  Returns:
*/
BOOL WINAPI MyCPAcquireContext(OUT HCRYPTPROV      *phProv,
                               IN  LPCSTR           pszContainer,
                               IN  DWORD            dwFlags,
                               IN  PVTableProvStruc pVTable
                               )
{
   SCARD_READERSTATE    ReaderState;
   DWORD                dwStatus;
   DWORD                dwProto, ind, ind2;
   DWORD                BuffFlags;
   DWORD                lRet;
   DWORD                SlotNb;
   BOOL                 CryptResp;
   char                 szContainerAsked[MAX_PATH];
   TCHAR                szReaderName[512],   
                        szReaderFriendlyName[512],
                        szModulePath[MAX_PATH],
                        szCspTitle[MAX_STRING],
                        szCspText[MAX_STRING];   
   
   *phProv = 0;
      
   if (IsNull(hFirstInstMod))
   {
      hFirstInstMod = g_hInstMod;
            
      dwStatus = GetModuleFileName( g_hInstMod, szModulePath, sizeof(szModulePath)/sizeof(TCHAR) );

      if (dwStatus)
         LoadLibrary(szModulePath);
   }
   
   if (bFirstGUILoad)
   {
      bFirstGUILoad = FALSE;
      
      dwStatus = GetModuleFileName( g_hInstMod, szModulePath, sizeof(szModulePath)/sizeof(TCHAR) );
      
      if (dwStatus)
      {
#ifdef MS_BUILD
         // Microsoft uses "gpkrsrc.dll"
         _tcscpy(&szModulePath[_tcslen(szModulePath) - 7], TEXT("rsrc.dll"));
#else
         // Gemplus uses "gpkgui.dll"
         _tcscpy(&szModulePath[_tcslen(szModulePath) - 7], TEXT("gui.dll"));
#endif
         DBG_PRINT(TEXT("Trying to load resource DLL: \"%s\""), szModulePath );
         g_hInstRes = LoadLibrary(szModulePath);
         DBG_PRINT(TEXT("Result is g_hInstRes = %08x, error is %08x"), g_hInstRes, (g_hInstRes) ? GetLastError(): 0 );
         
         if (IsNull(g_hInstRes))
         {
            if (!(dwFlags & CRYPT_SILENT))
            {
               LoadString(g_hInstMod, IDS_GPKCSP_TITLE, szCspTitle, sizeof(szCspTitle)/sizeof(TCHAR));
               LoadString(g_hInstMod, IDS_GPKCSP_NOGUI, szCspText, sizeof(szCspText)/sizeof(TCHAR));
               MessageBox(0, szCspText, szCspTitle, MB_OK | MB_ICONEXCLAMATION);
            }
            RETURN( CRYPT_FAILED, NTE_PROVIDER_DLL_FAIL );
         }
      }
      else
      {
         if (!(dwFlags & CRYPT_SILENT))
         {
            LoadString(g_hInstMod, IDS_GPKCSP_TITLE, szCspTitle, sizeof(szCspTitle)/sizeof(TCHAR));
            LoadString(g_hInstMod, IDS_GPKCSP_NOGUI, szCspText, sizeof(szCspText)/sizeof(TCHAR));
            MessageBox(0, szCspText, szCspTitle, MB_OK | MB_ICONEXCLAMATION);
         }
         RETURN( CRYPT_FAILED, NTE_PROVIDER_DLL_FAIL );
      }
   }
    
   g_hMainWnd = 0;
   if (pVTable)
   {
      if (pVTable->FuncReturnhWnd != 0)
      {
         // cspdk.h doesn't define the calling convention properly
         typedef void (__stdcall *STDCALL_CRYPT_RETURN_HWND)(HWND *phWnd);
         STDCALL_CRYPT_RETURN_HWND pfnFuncRreturnhWnd = (STDCALL_CRYPT_RETURN_HWND)pVTable->FuncReturnhWnd;
         pfnFuncRreturnhWnd( &g_hMainWnd );
      }
   }
   
   
   // If it is the first AcquireContext done by the application, then
   // prepare the RSA BASE and initialize some variables;
   if (hProvBase == 0)
   {
      CryptResp = InitAcquire();
      
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   
   BuffFlags = dwFlags;
   
   if (dwFlags & CRYPT_VERIFYCONTEXT)
      dwFlags = dwFlags^CRYPT_VERIFYCONTEXT;
   
   if (dwFlags & CRYPT_SILENT)
      dwFlags = dwFlags^CRYPT_SILENT;
   
   if (dwFlags & CRYPT_MACHINE_KEYSET)              // This flag is ignored by this CSP
      dwFlags = dwFlags^CRYPT_MACHINE_KEYSET;
   
   
   // Parse the container name
   
   ZeroMemory( szReaderFriendlyName, sizeof(szReaderFriendlyName) );
   ZeroMemory( szContainerAsked,     sizeof(szContainerAsked) );
   
   if (IsNotNull (pszContainer))
   {
      ind = 0;
      if (pszContainer[ind] == '\\')
      {
         ind = 4;
         while ((pszContainer[ind] != 0x00) && (pszContainer[ind] != '\\'))
         {
            szReaderFriendlyName[ind-4] = pszContainer[ind];
            ind++;
         }
         
         if (pszContainer[ind] == '\\')
         {
            ind++;
         }
      }
      
      ind2 = 0;
      while ((pszContainer[ind] != 0x00) && (ind2<sizeof(szContainerAsked)-1))
      {
         szContainerAsked[ind2] = pszContainer[ind];
         ind++;
         ind2++;
      }
   }
   
   // Find a free handle for this new AcquireContext
   
   *phProv = find_context_free();
   if (*phProv == 0)
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   
   ProvCont[*phProv].isContNameNullBlank = IsNullStr(pszContainer);        // [mv - 15/05/98]
   ProvCont[*phProv].bCardTransactionOpened = FALSE; // [FP]
   
   if ((BuffFlags & CRYPT_VERIFYCONTEXT) && (ProvCont[*phProv].isContNameNullBlank))        // [mv - 15/05/98]
   {
      // return a velid handle, but without any access to the card
      ProvCont[*phProv].hProv = *phProv;
      ProvCont[*phProv].Flags = BuffFlags;
      RETURN( CRYPT_SUCCEED, 0 );
   }
   else
   {
      /* Calais IRM Establish Context                              */
      if (hCardContext == 0)   // mv
      {
         lRet = SCardEstablishContext( SCARD_SCOPE_SYSTEM, 0, 0, &hCardContext );
         
         if (SCARDPROBLEM(lRet,0x0000,0xFF))
         {
            hCardContext = 0;
            countCardContextRef = 0;
            ReleaseProvider(*phProv);
            *phProv = 0;
            RETURN( CRYPT_FAILED, lRet );
         }
      }
      

#if (_WIN32_WINNT < 0x0500)

      // Read the reader list      
      char* pAllocatedBuff = 0;
      
      __try
      {
         static s_bInit = false;

         if (!s_bInit)
         {
            DWORD   i, BuffLength;
            char*   Buff;
            
            lRet = SCardListReaders(hCardContext, 0, 0, &BuffLength);
            if (SCARDPROBLEM(lRet,0x0000,0xFF))
            {
               ReleaseProvider(*phProv);
               *phProv = 0;
               RETURN( CRYPT_FAILED, lRet );
            }
            
            pAllocatedBuff = (char*)GMEM_Alloc(BuffLength);

            if (pAllocatedBuff == 0)
            {
               ReleaseProvider(*phProv);
               *phProv = 0;
               RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
            }
            
            Buff = pAllocatedBuff;
            
            lRet = SCardListReaders(hCardContext, 0, Buff, &BuffLength);
            if (SCARDPROBLEM(lRet,0x0000,0xFF))
            {
               ReleaseProvider(*phProv);
               *phProv = 0;
               RETURN( CRYPT_FAILED, lRet );
            }
            
            i = 0;
            while (strlen(Buff) != 0 && i < MAX_SLOT)
            {
               ZeroMemory( Slot[i].szReaderName, sizeof(Slot[i].szReaderName) );
               strncpy(Slot[i].szReaderName, Buff, (sizeof(Slot[i].szReaderName)/sizeof(TCHAR))-1);
               Slot[i].szReaderName[(sizeof(Slot[i].szReaderName)/sizeof(TCHAR))-1]=0;
               Buff = Buff + strlen(Buff) + 1;
               i++;
            }
            
            if (strlen(Buff) != 0)
            {
               ReleaseProvider(*phProv);
               *phProv = 0;
               RETURN( CRYPT_FAILED, NTE_FAIL );
            }
            
            for (; i < MAX_SLOT; i++)
            {
               ZeroMemory( Slot[i].szReaderName, sizeof(Slot[i].szReaderName) );
            }

            s_bInit = true;
         }
      }
      __finally
      {
         if (pAllocatedBuff)
         {
            GMEM_Free( pAllocatedBuff );
            pAllocatedBuff = 0;
         }
      }
      

      
      // If the ReaderFriendlyName is NULL, scan the list of readers to find the one
      // containing the container key set that is looked for.      
      
      // This fix is to work around the bug on the
      // OPEN_CARD - Ressource Manager v1.0 (NT4, Win 95) -

      if (!IsWin2000() && IsNullStr(szReaderFriendlyName))
      {
         SCARDHANDLE hCard;
         int NbMatch = 0;

           GpkLocalUnlock();
         __try
         {
            DWORD i;
            char szSlotReaderName[512];

            for (i = 0; i < MAX_SLOT; i++)
            {
               strncpy(szSlotReaderName, Slot[i].szReaderName, sizeof(szSlotReaderName)-1);
               szSlotReaderName[sizeof(szSlotReaderName)-1]=0;

               if (IsNotNullStr (szSlotReaderName))
               {
                  hCard = funcConnect (hCardContext, szSlotReaderName, mszCardList, 0);
                  if (hCard != 0)
                  {
                     //if (SCardBeginTransaction(hCard) == SCARD_S_SUCCESS)
                     //{
                        if (funcCheck (hCardContext, hCard, szContainerAsked))
                        {
                           strncpy (szReaderFriendlyName, szSlotReaderName, (sizeof(szReaderFriendlyName)/sizeof(TCHAR))-1);
                           szReaderFriendlyName[(sizeof(szReaderFriendlyName)/sizeof(TCHAR))-1]=0;
                           NbMatch++;
                        }
                     
                      //  SCardEndTransaction(hCard, SCARD_LEAVE_CARD);
                     //}
                     funcDisconnect (hCardContext, hCard, 0);
                  }
               }
            }
         }
         __finally
         {
            GpkLocalLock();
         }
         
         // If there are more than one match, the user has to chose
         
         if (NbMatch != 1)
         {
            ZeroMemory( szReaderFriendlyName, sizeof(szReaderFriendlyName) );
         }
      }

#endif   // (_WIN32_WINNT < 0x0500)


      if (IsNullStr(szReaderFriendlyName))
      {

         SCARDHANDLE hCard = 0;
           dwStatus = OpenCard(szContainerAsked, BuffFlags, &hCard, szReaderName, sizeof(szReaderName)/sizeof(TCHAR));

         if ((hCard == 0) || (dwStatus != SCARD_S_SUCCESS))
         {
            ReleaseProvider(*phProv);
            *phProv = 0;
            RETURN (CRYPT_FAILED, dwStatus);
         }
         
         ProvCont[*phProv].hCard = hCard;
         
         ReaderState.szReader       = szReaderName;
         ReaderState.dwCurrentState = SCARD_STATE_UNAWARE;
         SCardGetStatusChange(hCardContext, 1, &ReaderState, 1);
         
         _tcscpy(szReaderName, ReaderState.szReader);
         
         if (!find_reader (&(ProvCont[*phProv].Slot), szReaderName))
         {
            ReleaseProvider(*phProv);
            *phProv = 0;
            RETURN( CRYPT_FAILED, SCARD_E_READER_UNAVAILABLE );
         }
      }
      else
      {
         DWORD dwSts = ConnectToCard( szReaderFriendlyName,
                                      SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0,
                                      &ProvCont[*phProv].hCard, &dwProto );
         
         if (dwSts != SCARD_S_SUCCESS)
         {
            ReleaseProvider(*phProv);
            *phProv = 0;
            RETURN( CRYPT_FAILED, dwSts );
         }
         
         ReaderState.szReader       = szReaderFriendlyName;
         ReaderState.dwCurrentState = SCARD_STATE_UNAWARE;
         SCardGetStatusChange(hCardContext, 1, &ReaderState, 1);
         
         _tcscpy(szReaderName, ReaderState.szReader);
         
         if (!find_reader (&(ProvCont[*phProv].Slot), szReaderFriendlyName))
         {
            ReleaseProvider(*phProv);
            *phProv = 0;
            RETURN( CRYPT_FAILED, SCARD_E_READER_UNAVAILABLE );
         }
      }
      
      // Now we know which reader is used. start a thread to check that reader if necessary
      
      lRet = BeginTransaction(ProvCont[*phProv].hCard);
      if (lRet != SCARD_S_SUCCESS)
      {
         ReleaseProvider(*phProv);
         *phProv = 0;
         RETURN (CRYPT_FAILED, lRet);
      }
      
      SlotNb = ProvCont[*phProv].Slot;
      
      InitializeSlot( SlotNb );
      
      // TT 30/07/99
      lRet = DetectGPK8000( ProvCont[*phProv].hCard, &ProvCont[*phProv].bGPK8000 );
      if (lRet != SCARD_S_SUCCESS)
      {
         SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
         ReleaseProvider(*phProv);
         *phProv = 0;
         RETURN (CRYPT_FAILED, lRet );
      }
      
      ProvCont[*phProv].bLegacyKeyset = FALSE;
      // TT: END
      
      ProvCont[*phProv].hRSASign    = 0;
      ProvCont[*phProv].hRSAKEK     = 0;
      ProvCont[*phProv].keysetID    = 0xFF;     // TT: GPK8000 support
      ProvCont[*phProv].bGPK_ISO_DF    = FALSE;
      ProvCont[*phProv].dataUnitSize   = 0;
      ProvCont[*phProv].bDisconnected = FALSE;

      if (!Select_MF(*phProv))
      {
          // [FP] +
          DBG_PRINT(TEXT("Try to reconnect"));
          //DWORD dwProto;
          lRet = SCardReconnect(ProvCont[*phProv].hCard, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1, SCARD_RESET_CARD, &dwProto);
          if (lRet != SCARD_S_SUCCESS) RETURN (CRYPT_FAILED, lRet);

          DBG_PRINT(TEXT("Try Select_MF again"));
          if (!Select_MF(*phProv))
          {
              DBG_PRINT(TEXT("Second Select_MF fails"));
              // [FP] -
              lRet = GetLastError();
         
              SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
              ReleaseProvider(*phProv);
              *phProv = 0;
              RETURN( CRYPT_FAILED, lRet );
          }
      }

      // Read Serial number to store it
      bSendBuffer[0] = 0x80;   //CLA
      bSendBuffer[1] = 0xC0;   //INS
      bSendBuffer[2] = 0x02;   //P1
      bSendBuffer[3] = 0xA0;   //P2
      bSendBuffer[4] = 0x08;   //Lo
      cbSendLength = 5;

      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit(ProvCont[*phProv].hCard,
                           SCARD_PCI_T0,
                           bSendBuffer,
                           cbSendLength,
                           NULL,
                           bRecvBuffer,
                           &cbRecvLength);

      if (SCARDPROBLEM(lRet,0x9000, bSendBuffer[4]))
      {
          SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
          ReleaseProvider(*phProv);
          *phProv = 0;
          RETURN (CRYPT_FAILED, 
          (SCARD_S_SUCCESS == lRet) ? NTE_BAD_KEYSET : lRet);
      }

      memcpy(Slot[SlotNb].bGpkSerNb, bRecvBuffer, bSendBuffer[4]);

      if (!Select_Crypto_DF(*phProv))
      {
         lRet = GetLastError();
         
         SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
         ReleaseProvider(*phProv);
         *phProv = 0;
         RETURN( CRYPT_FAILED, lRet );
      }
      
      // Get the response from the Select DF to obtain the IADF
      bSendBuffer[0] = 0x00;           //CLA
      bSendBuffer[1] = 0xC0;           //INS
      bSendBuffer[2] = 0x00;           //P1
      bSendBuffer[3] = 0x00;           //P2
      bSendBuffer[4] = bRecvBuffer[1]; //Lo
      cbSendLength = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[*phProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );

      if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      {
         Select_MF(*phProv);
         SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
         ReleaseProvider(*phProv);
         *phProv = 0;
         
         RETURN( CRYPT_FAILED, (SCARD_S_SUCCESS == lRet) ? NTE_BAD_KEYSET : lRet );
      }
      
      ZeroMemory( ProvCont[*phProv].szContainer, sizeof(ProvCont[*phProv].szContainer));
      
      if (bRecvBuffer[4] == 0x30)
         Slot[SlotNb].InitFlag = FALSE;
      else
      {
         Slot[SlotNb].InitFlag = TRUE;
         
         if (ProvCont[*phProv].bGPK8000)
         {
            // Find the keyset's name
            // This is done in AcquireUseKeySet()
            ZeroMemory( ProvCont[*phProv].szContainer, sizeof(ProvCont[*phProv].szContainer) );
         }
         else
         {
            memcpy(ProvCont[*phProv].szContainer, &bRecvBuffer[5], cbRecvLength - 7);
         }
      }
      
            // inserted by sven: Force re-reading of all objects to detect modifications by other processes
            Slot[SlotNb].m_TSPublic=Slot[SlotNb].m_TSPrivate=0;

      // read the description of the public key parameters
      if (!Slot[SlotNb].ValidateTimestamps(*phProv))
         return CRYPT_FAILED;
      
      if (!Slot[SlotNb].Read_Public)
      {
         if (!read_gpk_objects(*phProv, FALSE))
         {
            lRet = GetLastError();
            Select_MF(*phProv);
            SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
            ReleaseProvider(*phProv);
            *phProv = 0;
            
            RETURN (CRYPT_FAILED, lRet);
         }
         
         Slot[SlotNb].Read_Public     = TRUE;
         Slot[SlotNb].Read_Priv       = FALSE;
      }
   }
    
   // TT 05/10/99
   if (!ProvCont[*phProv].bGPK8000)
   {
      ProvCont[*phProv].bLegacyKeyset = DetectLegacy( &Slot[SlotNb] );
      if (!ProvCont[*phProv].bLegacyKeyset)
      {
         ZeroMemory( ProvCont[*phProv].szContainer, sizeof(ProvCont[*phProv].szContainer) );
      }
   }
   // TT - END -
   
   if (dwFlags == CRYPT_DELETEKEYSET)
   {
      if (ProvCont[*phProv].bLegacyKeyset)
         CryptResp = LegacyAcquireDeleteKeySet(phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags);
      else
         CryptResp = AcquireDeleteKeySet(phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags);
      
      lRet      = GetLastError();
      
      Select_MF (*phProv);
      SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
  
     ReleaseProvider(*phProv);
     *phProv = 0;
      
     RETURN( CryptResp, lRet );
   }
   else if (dwFlags == CRYPT_NEWKEYSET)
   {
      if (ProvCont[*phProv].bLegacyKeyset)
         CryptResp = LegacyAcquireNewKeySet(phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags);
      else
         CryptResp = AcquireNewKeySet( phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags );
      
      lRet      = GetLastError();      
      Select_MF (*phProv);
      SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
      
      if (!CryptResp)
      {
         ReleaseProvider (*phProv);
         *phProv = 0;
      }

      RETURN( CryptResp, lRet );
   }
   else if (dwFlags == 0)
   {
      if (ProvCont[*phProv].bLegacyKeyset)
         CryptResp = LegacyAcquireUseKeySet(phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags);
      else
         CryptResp = AcquireUseKeySet(phProv, ProvCont[*phProv].szContainer, szContainerAsked, BuffFlags);
      
      lRet      = GetLastError();
      
      //Select_MF (*phProv); // [FP] PIN not presented
      SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
      
      if (!CryptResp)
      {
         ReleaseProvider (*phProv);
         *phProv = 0;
      }
      
      RETURN( CryptResp, lRet );
   }
   else
   {
      SCardEndTransaction(ProvCont[*phProv].hCard, SCARD_LEAVE_CARD);
      
      ReleaseProvider(*phProv);
      *phProv = 0;
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   }
}

/*
-  MyCPGetProvParam
-
*  Purpose:

  *                Allows applications to get various aspects of the
  *                operations of a provider
  *
  *  Parameters:
  *               IN      hProv      -  Handle to a CSP
  *               IN      dwParam    -  Parameter number
  *               OUT     pbData     -  Pointer to data
  *               IN      pdwDataLen -  Length of parameter data
  *               IN      dwFlags    -  Flags values
  *
  *  Returns:
  */
BOOL WINAPI MyCPGetProvParam( IN HCRYPTPROV hProv,
                              IN DWORD      dwParam,
                              IN BYTE*      pbData,
                              IN DWORD*     pdwDataLen,
                              IN DWORD      dwFlags )
{
   DWORD        lRet;
   BOOL         CryptResp;
   DWORD        SlotNb;
   ALG_ID       aiAlgid;
   BOOL         algNotSupported;
   TCHAR        szCspName[MAX_STRING];
   
   //BYTE*        ptr = 0;
   
   if (!Context_exist(hProv))
   {
      RETURN( CRYPT_FAILED, NTE_BAD_UID );
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (dwFlags & CRYPT_MACHINE_KEYSET)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   }
   
   if ((dwFlags == CRYPT_FIRST)
      &&(dwParam != PP_ENUMALGS)
      &&(dwParam != PP_ENUMALGS_EX)
      &&(dwParam != PP_ENUMCONTAINERS)
      )
   {
      RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
   }
   
   switch (dwParam)
   {
   case PP_UNIQUE_CONTAINER:
   case PP_CONTAINER:
      // [mv - 15/05/98]
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < strlen(ProvCont[hProv].szContainer)+1)
         {
            *pdwDataLen = strlen(ProvCont[hProv].szContainer)+1;
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         strcpy( (char*)pbData, ProvCont[hProv].szContainer);
      }
      
      *pdwDataLen = strlen(ProvCont[hProv].szContainer)+1;
      break;
      
   case PP_ENUMALGS:
   case PP_ENUMALGS_EX:
      CryptResp = CryptGetProvParam(hProvBase,
         dwParam,
         pbData,
         pdwDataLen,
         dwFlags
         );
      if (!CryptResp)
      {
         lRet = GetLastError();
         RETURN (CRYPT_FAILED, lRet);
      }
      
      if (NULL != pbData)
      {
         // Extract algorithm information from 'pbData' buffer.
         BYTE *ptr = pbData;
         aiAlgid = *(ALG_ID UNALIGNED *)ptr;
         
         BOOL b512exist = FALSE,
              b1024exist = FALSE;
         
         for ( unsigned i = 0 ; i < Slot[SlotNb].NbKeyFile; ++i )
         {
            if (Slot[SlotNb].GpkPubKeys[i].KeySize == 512/8) b512exist = TRUE;
            else if (Slot[SlotNb].GpkPubKeys[i].KeySize == 1024/8) b1024exist = TRUE;
         }

         // Can happen if card is removed
         if (!b512exist && !b1024exist)
            Slot[SlotNb].NbKeyFile = 0;

         if (aiAlgid == CALG_RSA_KEYX)
         {
            if (PP_ENUMALGS_EX == dwParam)
            {
               PROV_ENUMALGS_EX *penAlg = (PROV_ENUMALGS_EX *)pbData;
                    if (Slot[SlotNb].NbKeyFile==0)
                    {
                        penAlg->dwDefaultLen = RSA_KEK_Size * 8;
                        penAlg->dwMinLen     = 512;
                        penAlg->dwMaxLen     = RSA_KEK_Size * 8;
               }
                    else
                    {
                        penAlg->dwDefaultLen = RSA_KEK_Size * 8;
                        penAlg->dwMinLen     = (b512exist) ? 512 : 1024;
                        penAlg->dwMaxLen     = (b1024exist) ? 1024 : 512;
                        
                        if (penAlg->dwMaxLen > (DWORD)RSA_KEK_Size * 8)
                            penAlg->dwMaxLen = (DWORD)RSA_KEK_Size * 8;
                    }
            }
            else
            {
               PROV_ENUMALGS *penAlg = (PROV_ENUMALGS *)pbData;
                    if (Slot[SlotNb].NbKeyFile==0)
                        penAlg->dwBitLen     = RSA_KEK_Size * 8;
                    else
                    {
                        penAlg->dwBitLen     = (b1024exist) ? 1024 : 512;
                        if (penAlg->dwBitLen > (DWORD)RSA_KEK_Size * 8)
                            penAlg->dwBitLen = (DWORD)RSA_KEK_Size * 8;
                    }
            }
         }
         else if (aiAlgid == CALG_RSA_SIGN)
         {
            if (PP_ENUMALGS_EX == dwParam)
            {
               PROV_ENUMALGS_EX *penAlg = (PROV_ENUMALGS_EX *)pbData;
                    if (Slot[SlotNb].NbKeyFile==0)
                    {
                        penAlg->dwDefaultLen = 1024;
                        penAlg->dwMinLen     = 512;
                        penAlg->dwMaxLen     = 1024;
                    }
               else
               {
                  penAlg->dwDefaultLen = (b1024exist) ? 1024 : 512;
                  penAlg->dwMinLen     = (b512exist) ? 512 : 1024;
                  penAlg->dwMaxLen     = (b1024exist) ? 1024 : 512;
               }
            }
            else
            {
               PROV_ENUMALGS *penAlg = (PROV_ENUMALGS *)pbData;
                    if (Slot[SlotNb].NbKeyFile==0)
                        penAlg->dwBitLen     = 1024;
               else
                  penAlg->dwBitLen     = (b1024exist) ? 1024 : 512;
            }
         }
         else if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
                   ProvCont[hProv].isContNameNullBlank )
         {
            // No access to the card has been done in this case
         }
         else if ((dwFlags != CRYPT_FIRST ) && (Slot[SlotNb].GpkMaxSessionKey == 0))
         {
            // card was removed, nothing to do
         }
         else if  (GET_ALG_CLASS(aiAlgid) == ALG_CLASS_DATA_ENCRYPT)
         {
            // The max session key in the card is only for encryption
            // There is a card in the Reader,
            // read the max session key, if not already done
            
            if (Slot[SlotNb].GpkMaxSessionKey == 0)
            {
               CryptResp = Read_MaxSessionKey_EF(hProv,
                  &(Slot[SlotNb].GpkMaxSessionKey));
               // if the DF of EF is not here, maxSessionKey==0
            }
            
            // skip the algo if not supported by the card 
            do
            {
               algNotSupported = FALSE;
               
               if (dwParam == PP_ENUMALGS)
               {
                  PROV_ENUMALGS *penAlg = (PROV_ENUMALGS *)pbData;

                  // TT Hack: "Unknown cryptographic algorithm" at winlogon problem.
                  if (penAlg->aiAlgid == CALG_RC2 && Slot[SlotNb].GpkMaxSessionKey < 128)
                  {
                     penAlg->dwBitLen = 40;
                  }
                        
                  // DES needs 64 bits of unwrap capability
                  if (penAlg->aiAlgid == CALG_DES && Slot[SlotNb].GpkMaxSessionKey < 64)
                     algNotSupported = TRUE;
                  else
                  // Limit encryption algorithms to unwrap capabilities
                  if (GET_ALG_CLASS(penAlg->aiAlgid)==ALG_CLASS_DATA_ENCRYPT)
                  {
                     if (penAlg->dwBitLen > Slot[SlotNb].GpkMaxSessionKey)
                        algNotSupported = TRUE;
                  }
               }
               else
               {
                  PROV_ENUMALGS_EX *penAlg = (PROV_ENUMALGS_EX *)pbData;

                  // TT Hack: "Unknown cryptographic algorithm" at winlogon problem.
                  if (penAlg->aiAlgid == CALG_RC2 && Slot[SlotNb].GpkMaxSessionKey < 128)
                  {
                     penAlg->dwDefaultLen = 40;
                     penAlg->dwMinLen     = 40;
                     penAlg->dwMaxLen     = 40;
                  }

                  // DES needs 64 bits of unwrap capability
                  if (penAlg->aiAlgid == CALG_DES && Slot[SlotNb].GpkMaxSessionKey < 64)
                     algNotSupported = TRUE;
                  else
                  // Limit encryption algorithms to unwrap capabilities
                  if (GET_ALG_CLASS(penAlg->aiAlgid)==ALG_CLASS_DATA_ENCRYPT)
                  {
                     if (penAlg->dwMinLen > Slot[SlotNb].GpkMaxSessionKey)
                        algNotSupported = TRUE;
                     else
                     {
                        if (penAlg->dwMaxLen > Slot[SlotNb].GpkMaxSessionKey)
                           penAlg->dwMaxLen = Slot[SlotNb].GpkMaxSessionKey;

                        if (penAlg->dwDefaultLen > penAlg->dwMaxLen)
                           penAlg->dwDefaultLen = penAlg->dwMaxLen;
                     }
                  }
               }

               if (algNotSupported)
               {
                  // Algo not supported, read the next one
                  dwFlags = 0;
                  CryptResp = CryptGetProvParam( hProvBase, dwParam, pbData, pdwDataLen, dwFlags );
                  if (!CryptResp)  
                     return CRYPT_FAILED;
               }

            } while (algNotSupported);
         }
         }
         break;
         
   case PP_ENUMCONTAINERS:
      {  
         if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
             (ProvCont[hProv].isContNameNullBlank))
         {
            static CHAR* lpszCurrentContainerInList = 0;        //  multi sz strings of containters
            static CHAR mszContainerList[(MAX_SLOT * 128) + 1];
            DWORD dwContainerListLen = 0;
            static DWORD dwContainerMaxLen = 0;

            if (dwFlags == CRYPT_FIRST)
            {
                // List readers
                SCARDCONTEXT hCardEnumContext;
                lRet = SCardEstablishContext(SCARD_SCOPE_SYSTEM, 0, 0, &hCardEnumContext);
                if (lRet != SCARD_S_SUCCESS)
                {
                    if (lRet == SCARD_E_NO_SERVICE)
                        lRet = ERROR_NO_MORE_ITEMS;
                    RETURN (CRYPT_FAILED, lRet);
                }

                PTCHAR mszReaderList = 0;
                DWORD dwReaderListLen = 0;
                lRet = SCardListReaders(hCardEnumContext, 0, mszReaderList, &dwReaderListLen);
                if (lRet != SCARD_S_SUCCESS)
                {
                    if (lRet == SCARD_E_NO_READERS_AVAILABLE)
                        lRet = ERROR_NO_MORE_ITEMS;
                    SCardReleaseContext(hCardEnumContext);
                    RETURN (CRYPT_FAILED, lRet);
                }

                mszReaderList = (PTCHAR)GMEM_Alloc(dwReaderListLen * sizeof(TCHAR));
                if (IsNull(mszReaderList))
                {
                    SCardReleaseContext(hCardEnumContext);
                    RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
                }

                lRet = SCardListReaders(hCardEnumContext, 0, mszReaderList, &dwReaderListLen);
                if (lRet != SCARD_S_SUCCESS)
                {
                    GMEM_Free(mszReaderList);
                    SCardReleaseContext(hCardEnumContext);
                    RETURN (CRYPT_FAILED, lRet);
                }

                SCardReleaseContext(hCardEnumContext);

                // For each reader, find the container if any
                PTCHAR szReader = 0;
                PTCHAR szReader2 = 0;
                CHAR   szContainer[128];
                DWORD  dwContainerLen = 128;
                HCRYPTPROV hReaderProv;

                for (szReader = mszReaderList; *szReader != 0; szReader += (_tcsclen(szReader) + 1))
                {
                    szReader2 = (PTCHAR)GMEM_Alloc((_tcslen(szReader) + 5)*sizeof(TCHAR));
                    if (IsNull(szReader2))
                    {
                        GMEM_Free(mszReaderList);
                        RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
                    }

                    _tcscpy(szReader2, TEXT("\\\\.\\"));
                    _tcscat(szReader2, szReader);

                    CHAR szReaderChar[128];

#ifndef UNICODE
                    strncpy(szReaderChar, szReader2, sizeof(szReaderChar)-1);
                    szReaderChar[sizeof(szReaderChar)-1]=0;
#else
                    WideCharToMultiByte(CP_ACP, 0, szReader2, -1, szReaderChar, 128, 0, 0);                              
#endif

                    GMEM_Free(szReader2);

                    if (!MyCPAcquireContext(&hReaderProv, szReaderChar, CRYPT_VERIFYCONTEXT | CRYPT_SILENT, 0))
                    {
                        DWORD dwGLE = GetLastError();

                        if (dwGLE == NTE_KEYSET_NOT_DEF ||
                            dwGLE == SCARD_W_REMOVED_CARD ||
                            dwGLE == SCARD_E_DIR_NOT_FOUND ||   // likely to happen with a non Gemplus card
                            dwGLE == SCARD_E_PROTO_MISMATCH)    // likely to happen with T=1 card
                        {
                            continue;
                        }
                        else
                        {
                            GMEM_Free(mszReaderList);
                            RETURN (CRYPT_FAILED, NTE_FAIL);
                        }
                    }

                    dwContainerLen = 128;
                    if (!MyCPGetProvParam(hReaderProv, PP_CONTAINER, (BYTE*)szContainer, &dwContainerLen, 0))
                    {
                        GMEM_Free(mszReaderList);
                        RETURN (CRYPT_FAILED, NTE_FAIL);
                    }

                    MyCPReleaseContext(hReaderProv, 0);
                    
                    strcpy(&mszContainerList[dwContainerListLen], szContainer);
                    dwContainerListLen += dwContainerLen;
                    dwContainerMaxLen = max(dwContainerMaxLen, dwContainerLen);
                }

                GMEM_Free(mszReaderList);
                
                lpszCurrentContainerInList = mszContainerList;
            }

            // Return containers one by one
            if (lpszCurrentContainerInList == 0 || *lpszCurrentContainerInList == 0)
                RETURN (CRYPT_FAILED, ERROR_NO_MORE_ITEMS);

            if (IsNotNull(pbData))
            {
                if (*pdwDataLen < dwContainerMaxLen)
                {
                    *pdwDataLen = dwContainerMaxLen;
                    RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
                }

                strcpy((CHAR*)pbData, lpszCurrentContainerInList);
                *pdwDataLen = strlen(lpszCurrentContainerInList) + 1;
                lpszCurrentContainerInList += strlen(lpszCurrentContainerInList) + 1;
            }
            else
            {
                *pdwDataLen = dwContainerMaxLen;
            }
         }
         else
         {
             if (dwFlags == CRYPT_FIRST)
             { 
                 if (!MyCPGetProvParam(hProv, PP_CONTAINER, pbData, pdwDataLen, 0))
                 {
                     RETURN (CRYPT_FAILED, GetLastError());
                 }
             }
             else
             {
                 RETURN (CRYPT_FAILED, ERROR_NO_MORE_ITEMS);
             }
         }
      }
      break;
      
   case PP_IMPTYPE:
      if (IsNotNull(pbData))
      {
         DWORD dwType = CRYPT_IMPL_MIXED | CRYPT_IMPL_REMOVABLE;
         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         memcpy(pbData, &dwType, sizeof(dwType));
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;

   case PP_KEYX_KEYSIZE_INC:
   case PP_SIG_KEYSIZE_INC:

      if (IsNotNull(pbData))
      {
         BOOL b512exist = FALSE,
              b1024exist = FALSE;
         
         for ( unsigned i = 0 ; i < Slot[SlotNb].NbKeyFile; ++i )
         {
            if (Slot[SlotNb].GpkPubKeys[i].KeySize == 512) b512exist = TRUE;
            else if (Slot[SlotNb].GpkPubKeys[i].KeySize == 1024) b1024exist = TRUE;
         }

         // Can happen if card is removed
         if (!b512exist && !b1024exist)
            Slot[SlotNb].NbKeyFile = 0;

         if (dwParam == PP_KEYX_KEYSIZE_INC && b1024exist && RSA_KEK_Size * 8 < 1024)
            b1024exist = FALSE;

         DWORD dwSize = 0;

         if (b512exist && b1024exist)
            dwSize = 512;

         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         memcpy(pbData, &dwSize, sizeof(dwSize));
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;

   case PP_NAME:
      LoadString(g_hInstMod, IDS_GPKCSP_NAME, szCspName, sizeof(szCspName)/sizeof(TCHAR));

      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < (_tcslen(szCspName)+1))
         {
            *pdwDataLen = (_tcslen(szCspName)+1);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }         

#ifndef UNICODE
        strcpy((CHAR*)pbData, szCspName);
#else
        char szCspName1[MAX_STRING];
        WideCharToMultiByte(CP_ACP, 0, szCspName, MAX_STRING, szCspName1, MAX_STRING, 0, 0);               
        strcpy((CHAR*)pbData, szCspName1);
#endif
      }

      *pdwDataLen = (_tcslen(szCspName)+1);
      break;
      
   case PP_VERSION:
      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         pbData[0] = 20;
         pbData[1] = 2;
         pbData[2] = 0;
         pbData[3] = 0;
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;
      
   case PP_PROVTYPE:
      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         *(LPDWORD)pbData = PROV_RSA_FULL;
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;
      
      case PP_KEYSPEC:
      if (IsNotNull(pbData))
      {
         DWORD dwSpec = AT_KEYEXCHANGE | AT_SIGNATURE;
         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         memcpy(pbData, &dwSpec, sizeof(dwSpec));
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;

      // + [FP] Proprietary functions used to load a RSA private key into the GPK card
   case GPP_SERIAL_NUMBER:
      if (dwFlags != 0)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < 8)
         {
            *pdwDataLen = 8;
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         CryptResp = Select_MF(hProv);
         if (!CryptResp)
            return CRYPT_FAILED;
         
         bSendBuffer[0] = 0x80;   //CLA
         bSendBuffer[1] = 0xC0;   //INS
         bSendBuffer[2] = 0x02;   //P1
         bSendBuffer[3] = 0xA0;   //P2
         bSendBuffer[4] = 0x08;   //Lo
         cbSendLength = 5;
         
         cbRecvLength = sizeof(bRecvBuffer);
         lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
         
         if (SCARDPROBLEM(lRet, 0x9000, bSendBuffer[4]))
         {
            RETURN (CRYPT_FAILED, SCARD_E_UNEXPECTED);
         }
         
         memcpy(pbData, bRecvBuffer, bSendBuffer[4]);
      }
      
      *pdwDataLen = 8;
      break;
      
   case GPP_SESSION_RANDOM:
      if (dwFlags != 0)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if (IsNotNull(pbData))
      {
         if (*pdwDataLen < 8)
         {
            *pdwDataLen = 8;
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         if (Slot[SlotNb].NbKeyFile == 0)                   // [FP] here instead of MyCPImportKey because
         {                                                  // it does a Select_Crypto_DF and we have to do
            Slot[SlotNb].NbKeyFile = Read_NbKeyFile(hProv); // it before the select file key
         }                                                  
         
         /* Select File Key                                                         */
         bSendBuffer[0] = 0x80;                    //CLA
         bSendBuffer[1] = 0x28;                    //INS
         bSendBuffer[2] = 0x00;                    //P1
         bSendBuffer[3] = (BYTE)(0x3F01 /*& 0x1F*/);   //P2
         bSendBuffer[4] = 0x08;                    //Lc
         memcpy(&bSendBuffer[5], pbData, 0x08);
         cbSendLength = 13;
         
         cbRecvLength = sizeof(bRecvBuffer);
         lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
         
         if(SCARDPROBLEM(lRet, 0x61FF, 0x00))
         {
            RETURN(CRYPT_FAILED, lRet);
         }
         
         /* Get Response                                                            */
         bSendBuffer[0] = 0x00;           //CLA
         bSendBuffer[1] = 0xC0;           //INS
         bSendBuffer[2] = 0x00;           //P1
         bSendBuffer[3] = 0x00;           //P2
         bSendBuffer[4] = bRecvBuffer[1]; //Lo
         cbSendLength = 5;
         
         cbRecvLength = sizeof(bRecvBuffer);
         lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
         
         if(SCARDPROBLEM(lRet, 0x9000, bSendBuffer[4]))
         {
            RETURN(CRYPT_FAILED, lRet);
         }
         
         memcpy(pbData, &bRecvBuffer[4], 8);
         ProvCont[hProv].bCardTransactionOpened = TRUE;
      }
      
      *pdwDataLen = 8;
      break;
      
   case GPP_IMPORT_MECHANISM:
      if (IsNotNull(pbData))
      {
         DWORD dwMechanism = GCRYPT_IMPORT_SECURE;
         
         if (*pdwDataLen < sizeof(DWORD))
         {
            *pdwDataLen = sizeof(DWORD);
            RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
         }
         
         memcpy(pbData, &dwMechanism, sizeof(dwMechanism));
      }
      
      *pdwDataLen = sizeof(DWORD);
      break;
      // - [FP]
      
   default:
      RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
    }
    
    RETURN (CRYPT_SUCCEED, 0);
}


/*
-      MyCPReleaseContext
-
*      Purpose:
*               The CPReleaseContext function is used to release a
*               context created by CryptAcquireContext.
*
*     Parameters:
*               IN  phProv        -  Handle to a CSP
*               IN  dwFlags       -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPReleaseContext( HCRYPTPROV hProv, DWORD dwFlags )
{
   DWORD       SlotNb;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   
   if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
        ProvCont[hProv].isContNameNullBlank)
   {
      
   }
   else
   {
      SlotNb = ProvCont[hProv].Slot;
            
      if (Slot[SlotNb].ContextCount > 0)
         Slot[SlotNb].ContextCount--;
      
      if (countCardContextRef > 0)
         countCardContextRef--;
   }
   
            
   if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
       ProvCont[hProv].isContNameNullBlank)
   {
       // No access to the card has been done in this case
   }
   else
   {
       // Select_MF(hProv);  [FP] PIN not presented
       // SCardEndTransaction(ProvCont[hProv].hCard, SCARD_LEAVE_CARD); [FP] coherence not checked
   }

   ReleaseProvider(hProv);
   
/* PYR 11/08/00: Do not unload
   if (IsNotNull(g_hInstRes) && Slot[SlotNb].ContextCount == 0)
   {
      bFirstGUILoad = TRUE;
      FreeLibrary(g_hInstRes);
      g_hInstRes = 0;
   }
*/   
   //If dwFlags is not set to zero, this function returns FALSE but the CSP is released
   //PYR  08/08/00. Note that CryptoAPI will not call again CPReleaseContext with the same handle.
   if (dwFlags != 0)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
   }
   else
   {
      RETURN( CRYPT_SUCCEED, 0 );
   }
}


/*
-  MyCPSetProvParam
-
*  Purpose:
*                Allows applications to customize various aspects of the
*                operations of a provider
*
*  Parameters:
*               IN      hProv   -  Handle to a CSP
*               IN      dwParam -  Parameter number
*               IN      pbData  -  Pointer to data
*               IN      dwFlags -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPSetProvParam(IN HCRYPTPROV hProv,
                             IN DWORD      dwParam,
                             IN CONST BYTE      *pbData,
                             IN DWORD      dwFlags
                             )
{
   DWORD       SlotNb;
   // + [FP] for GPP_CHANGE_PIN
   const char* Buff;
   char        szOldPin[PIN_LEN + 1];
   char        szNewPin[PIN_LEN + 1];
   // - [FP]
   // + NK 06.02.2001
   PINCACHE_PINS Pins;  
   CallbackData sCallbackData;
   DWORD dwStatus;
   // -

   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   switch (dwParam)
   {
   case PP_KEYEXCHANGE_PIN:
   case PP_SIGNATURE_PIN:
    {
      // Slot[SlotNb].ClearPin();
      // Slot[SlotNb].SetPin( (char*)pbData );
      PopulatePins( &Pins, (BYTE *)pbData, strlen( (char*)pbData ), NULL, 0 );

      sCallbackData.hProv = hProv;
      sCallbackData.IsCoherent = FALSE;

      // SlotNb may not be the same before and after Add_MSPinCache because of the call
      // to Coherent in the callback of the pin cache function. To be sure that we save
      // the handle to the good slot, we store it after the call 
      PINCACHE_HANDLE hPinCacheHandle = Slot[SlotNb].hPinCacheHandle;
      if ( (dwStatus = Add_MSPinCache( &hPinCacheHandle,
                                       &Pins, 
                                       Callback_VerifyChangePin, 
                                       (void*)&sCallbackData )) != ERROR_SUCCESS )
      {
         RETURN (CRYPT_FAILED, dwStatus);
      }
      Slot[ProvCont[hProv].Slot].hPinCacheHandle = hPinCacheHandle;
      break;
    }
   case PP_KEYSET_SEC_DESCR:
      break;   // Assume success.
      
   case GPP_CHANGE_PIN:
      if (dwFlags != 0)
      {
         RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
      }
      
      if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
           ProvCont[hProv].isContNameNullBlank )
      {
         RETURN( CRYPT_FAILED, NTE_PERM );
      }
      
      // parse input buffer
      Buff = (char*)pbData;
      memset(szOldPin, 0x00, PIN_LEN + 1);
      strncpy(szOldPin, Buff, PIN_LEN);
      
      Buff = Buff + strlen(Buff) + 1;
      memset(szNewPin, 0x00, PIN_LEN + 1);
      strncpy(szNewPin, Buff, PIN_LEN);

      PopulatePins( &Pins, (BYTE *)szOldPin, strlen(szOldPin), (BYTE *)szNewPin, strlen(szNewPin) );

      sCallbackData.hProv = hProv;
      sCallbackData.IsCoherent = TRUE;

      dwStatus = Add_MSPinCache( &(Slot[SlotNb].hPinCacheHandle),
                                       &Pins,
                                       Callback_VerifyChangePin,
                                       (void*)&sCallbackData );
      memset(szOldPin, 0x00, PIN_LEN + 1);
            memset(szNewPin, 0x00, PIN_LEN + 1);
            if(szOldPin[0] || szNewPin[0]) { MessageBeep(0); } // to prevent compiler from optimization
            if(dwStatus!=ERROR_SUCCESS)
            {
         RETURN (CRYPT_FAILED, dwStatus);
      }
      break;
      
   default:
      RETURN( CRYPT_FAILED, E_NOTIMPL );
   }
   
   RETURN( CRYPT_SUCCEED, 0 );
}


/*******************************************************************************
Key Generation and Exchange Functions
*******************************************************************************/

/*
-  MyCPDeriveKey
-
*  Purpose:
*                Derive cryptographic keys from base data
*
*
*  Parameters:
*               IN      hProv      -  Handle to a CSP
*               IN      Algid      -  Algorithm identifier
*               IN      hHash      -  Handle to hash
*               IN      dwFlags    -  Flags values
*               OUT     phKey      -  Handle to a generated key
*
*  Returns:
*/
BOOL WINAPI MyCPDeriveKey(IN  HCRYPTPROV hProv,
                          IN  ALG_ID     Algid,
                          IN  HCRYPTHASH hHash,
                          IN  DWORD      dwFlags,
                          OUT HCRYPTKEY *phKey
                          )
{
   BOOL        CryptResp;
   HCRYPTKEY   hKey;
   
   *phKey = 0;
   
   if (!Context_exist(hProv))
      RETURN( CRYPT_FAILED, NTE_BAD_UID );
   
   if (!hash_exist(hHash, hProv))
      RETURN( CRYPT_FAILED, NTE_BAD_HASH );
   
   hKey = find_tmp_free();
   if (hKey == 0)
      RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
   
   // In fact, the flags are processed implicitly in the RSA Base
   CryptResp = CryptDeriveKey( hProvBase, Algid, hHashGpk[hHash].hHashBase,
                               dwFlags, &TmpObject[hKey].hKeyBase );
   
   if (!CryptResp)
      return CRYPT_FAILED;
   
   TmpObject[hKey].hProv = hProv;
   *phKey = hKey + MAX_GPK_OBJ;
   
   RETURN( CRYPT_SUCCEED, 0 );
}


/*
-  MyCPDestroyKey
-
*  Purpose:
*                Destroys the cryptographic key that is being referenced
*                with the hKey parameter
*
*
*  Parameters:
*               IN      hProv  -  Handle to a CSP
*               IN      hKey   -  Handle to a key
*
*  Returns:
*/
BOOL WINAPI MyCPDestroyKey(IN HCRYPTPROV hProv,
                           IN HCRYPTKEY  hKey
                           )
{
   BOOL        CryptResp;
   
   if (!Context_exist(hProv))
      RETURN( CRYPT_FAILED, NTE_BAD_UID );
   
   if (hKey == 0)
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   
   if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
      RETURN( CRYPT_FAILED, NTE_PERM );
   
   if (hKey <= MAX_GPK_OBJ)
      RETURN( CRYPT_SUCCEED, 0 );
   
   if (!key_exist(hKey-MAX_GPK_OBJ, hProv))
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   
   if (TmpObject[hKey-MAX_GPK_OBJ].hKeyBase != 0)
   {
      CryptResp = CryptDestroyKey(TmpObject[hKey-MAX_GPK_OBJ].hKeyBase);
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   
   TmpObject[hKey-MAX_GPK_OBJ].hKeyBase = 0;
   TmpObject[hKey-MAX_GPK_OBJ].hProv    = 0;
   
   RETURN( CRYPT_SUCCEED, 0 );
}


/*
-  MyCPExportKey
-
*  Purpose:
*                Export cryptographic keys out of a CSP in a secure manner
*
*
*  Parameters:
*               IN  hProv      - Handle to the CSP user
*               IN  hKey       - Handle to the key to export
*               IN  hPubKey    - Handle to the exchange public key value of
*                                the destination user
*               IN  dwBlobType - Type of key blob to be exported
*               IN  dwFlags -    Flags values
*               OUT pbData -     Key blob data
*               OUT pdwDataLen - Length of key blob in bytes
*
*  Returns:
*/
BOOL WINAPI MyCPExportKey(IN  HCRYPTPROV hProv,
                          IN  HCRYPTKEY  hKey,
                          IN  HCRYPTKEY  hPubKey,
                          IN  DWORD      dwBlobType,
                          IN  DWORD      dwFlags,
                          OUT BYTE      *pbData,
                          OUT DWORD     *pdwDataLen
                          )
{
   BOOL        CryptResp;
   DWORD       dwBlobLen;
   HCRYPTKEY   hTmpKey,hKeyExp;
   BLOBHEADER  BlobHeader;
   RSAPUBKEY   RsaPubKey;
   GPK_EXP_KEY PubKey;
   DWORD       SlotNb;
   
   if (!Context_exist(hProv))
   {
      *pdwDataLen = 0;
      RETURN( CRYPT_FAILED, NTE_BAD_UID );
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (hKey == 0)
   {
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   }
   else if (hKey <= MAX_GPK_OBJ)
   {
      if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT &&
           ProvCont[hProv].isContNameNullBlank )
      {
         RETURN( CRYPT_FAILED, NTE_PERM );
      }
      
      if (dwBlobType == PUBLICKEYBLOB)
      {
         if (dwFlags != 0)
            RETURN( CRYPT_FAILED, NTE_BAD_FLAGS );
         
         if (hPubKey != 0)
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         
         if (Slot[SlotNb].GpkObject[hKey].FileId == 0x00)
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         
         if ( Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len == 0 ||
              ( Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0] != AT_KEYEXCHANGE &&
                Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0] != AT_SIGNATURE ) )
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         
         PubKey = Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY];
         
         if (PubKey.KeySize == 0)
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         
         if (PubKey.ExpSize > sizeof(DWORD))
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         
         dwBlobLen = sizeof(BLOBHEADER) +
                     sizeof(RSAPUBKEY) +
                     PubKey.KeySize;
         
         if (IsNull(pbData))
         {
            *pdwDataLen = dwBlobLen;
            RETURN( CRYPT_SUCCEED, 0 );
         }
         else if (*pdwDataLen < dwBlobLen)
         {
            *pdwDataLen = dwBlobLen;
            RETURN( CRYPT_FAILED, ERROR_MORE_DATA );
         }
         BlobHeader.bType    = PUBLICKEYBLOB;
         BlobHeader.bVersion = CUR_BLOB_VERSION;
         BlobHeader.reserved = 0x0000;
         if (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0] == AT_KEYEXCHANGE)
         {
            BlobHeader.aiKeyAlg = CALG_RSA_KEYX;
         }
         else
         {
            BlobHeader.aiKeyAlg = CALG_RSA_SIGN;
         }
         RsaPubKey.magic     = 0x31415352;
         RsaPubKey.bitlen    = PubKey.KeySize * 8;
         RsaPubKey.pubexp    = 0;
         memcpy( &RsaPubKey.pubexp, PubKey.Exposant, sizeof(DWORD) );
         memcpy( pbData, &BlobHeader, sizeof(BlobHeader) );
         memcpy( &pbData[sizeof(BlobHeader)], &RsaPubKey, sizeof(RsaPubKey) );
         r_memcpy( &pbData[sizeof(BlobHeader)+ sizeof(RsaPubKey) ], PubKey.Modulus, PubKey.KeySize );
         *pdwDataLen = dwBlobLen;
      }
      else
      {
         *pdwDataLen = 0;
         RETURN( CRYPT_FAILED, NTE_BAD_TYPE );
      }
   }
    
   /* Temporary key                                                           */
   else if (key_exist( hKey - MAX_GPK_OBJ, hProv ))
   {
      hTmpKey = hKey - MAX_GPK_OBJ;
      
      if (hPubKey == 0)
      {
         *pdwDataLen = 0;
         RETURN( CRYPT_FAILED, NTE_BAD_KEY );
      }
      
      if (hPubKey <= MAX_GPK_OBJ)
      {
         //hKeyExp = Slot[SlotNb].GpkObject[hPubKey].hKeyBase;
         if ((Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].Len == 0)  ||
             ((Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] != AT_KEYEXCHANGE) &&
              (Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] != AT_SIGNATURE)))
         {
            *pdwDataLen = 0;
            RETURN(CRYPT_FAILED, NTE_BAD_KEY);
         }

         if (Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] == AT_KEYEXCHANGE)
         {
            hKeyExp = ProvCont[hProv].hRSAKEK;
         }
         else
         {
            hKeyExp = ProvCont[hProv].hRSASign;
         }
      }
      else
      {
         if (!key_exist(hPubKey-MAX_GPK_OBJ, hProv))
         {
            *pdwDataLen = 0;
            RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         }
         else
         {
            hKeyExp = TmpObject[hPubKey-MAX_GPK_OBJ].hKeyBase;
         }
      }
      
      CryptResp = CryptExportKey( TmpObject[hTmpKey].hKeyBase, hKeyExp, dwBlobType,
                                  dwFlags, pbData, pdwDataLen );
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   
   /* Unknown key handle                                                      */
   else
   {
      *pdwDataLen = 0;
      RETURN( CRYPT_FAILED, NTE_BAD_KEY );
   }
   
   RETURN( CRYPT_SUCCEED, 0 );
}



/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL gen_key_on_board8000( HCRYPTPROV hProv, BYTE fileId )
{
   BOOL        Is1024 = FALSE;
   ULONG       ulStart, ulEnd;
   BYTE        KeyType, Sfi;
   //char        szTmp[100];
   WORD        wKeySize = 0;
   SCARDHANDLE hCard;
   DWORD       lRet;
   
   hCard = ProvCont[hProv].hCard;
   
   BeginWait();
   
   /*-------------------------------------------------------------------------*/
   /* Call on board generation for specified key file                         */
   /*-------------------------------------------------------------------------*/
   Sfi = 0x04 | (fileId<<3);
   
   /* Read Record (TAG_INFO) to get key size                                  */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xB2;   //INS
   bSendBuffer[2] = 0x01;   //P1
   bSendBuffer[3] = Sfi;    //P2
   bSendBuffer[4] = 0x07;   //Lo
   cbSendLength   = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength
      );
   if(SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      EndWait();
      return CRYPT_FAILED;
   }
   
   KeyType = bRecvBuffer[1];
   
   if (KeyType == 0x11)
   {
      Is1024 = TRUE;
      wKeySize = 1024;
   }
   else if (KeyType == 0x00)
   {
      Is1024 = FALSE;
      wKeySize = 512;
   }
   else
   {
      EndWait();
      return CRYPT_FAILED;
   }
   
   Sfi = 0x80 | (fileId);

   // + [FP]
   //sprintf(szTmp, 
   //   "RSA %d bit key pair on-board generation", 
   //   wKeySize
   //   );

   //ShowProgress(GetActiveWindow(), szTmp, "Operation in progress...", 0);
   ShowProgressWrapper(wKeySize);
   // - [FP]

   ulStart = GetTickCount();
   if (Is1024)
   {
      ulEnd = ulStart + (TIME_GEN_1024 * 1000);
   }
   else
   {
      ulEnd = ulStart + (TIME_GEN_512 * 1000);
   }
   
GEN_KEY:
   /* Call on-board generation                                                */
   bSendBuffer[0] = 0x80;     //CLA
   bSendBuffer[1] = 0xD2;     //INS
   bSendBuffer[2] = Sfi;      //P1
   bSendBuffer[3] = KeyType;  //P2
   cbSendLength = 4;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if(SCARDPROBLEM(lRet,0x9000,0x00))
   {
      DestroyProgress();
      EndWait();
      return CRYPT_FAILED;
   }
   
   /* Wait for generation is successfull                                      */
   if (Is1024 && g_GPK8000KeyGenTime1024 > 0)
   {
      Wait( 1, 1, g_GPK8000KeyGenTime1024 );
   }
   else
      if (!Is1024 && g_GPK8000KeyGenTime512 > 0)
      {
         Wait( 1, 1, g_GPK8000KeyGenTime512 );
      }
      
      do
      {  
         /* Get response to know if generation successfull                       */
         bSendBuffer[0] = 0x00;  //CLA
         bSendBuffer[1] = 0xC0;  //INS
         bSendBuffer[2] = 0x00;  //P1
         bSendBuffer[3] = 0x00;  //P2
         bSendBuffer[4] = 0x42;  //Le
         if (Is1024)
         {
            bSendBuffer[4] = 0x82;  //Le
         }
         cbSendLength = 5;
         
         cbRecvLength = sizeof(bRecvBuffer);
         lRet = SCardTransmit( hCard, SCARD_PCI_T0, bSendBuffer,
                               cbSendLength, 0, bRecvBuffer, &cbRecvLength );
         if(SCARDPROBLEM(lRet,0x9000,0x00))
         {
            
            if ((dwSW1SW2 == 0x6a88) || (dwSW1SW2 == 0x9220))
            {
               goto GEN_KEY;
            }
         }
         
         // + [FP]
         //sprintf(szTmp, 
         //   "Operation started since %d seconds",
         //   (GetTickCount() - ulStart) / 1000 
         //   );
         //ChangeProgressText(szTmp);
         ChangeProgressWrapper((GetTickCount() - ulStart) / 1000);
         // - [FP]

         if (GetTickCount() > ulEnd)
         {
            break;
         }
      }
      while ((lRet != SCARD_S_SUCCESS) || (dwSW1SW2 != 0x9000));
      DestroyProgress();
      
      if ((lRet != SCARD_S_SUCCESS) || (dwSW1SW2 != 0x9000))
      {
         EndWait();
         return CRYPT_FAILED;
      }
      
      EndWait();
      
      return CRYPT_SUCCEED;
}

/*------------------------------------------------------------------------------
------------------------------------------------------------------------------*/

static BOOL gen_key_on_board (HCRYPTPROV hProv)
{
   BOOL     IsLast   = FALSE,
            IsExport = TRUE,
            Is1024   = FALSE;
   BYTE     Sfi, TmpKeyLength;
   WORD     wPubSize;
   DWORD    i, lRet ,dwLen,
            dwNumberofCommands,
            dwLastCommandLen,
            dwCommandLen;
   DWORD    SlotNb;
   WORD     offset;
   
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (Slot[SlotNb].NbKeyFile == 0)
      Slot[SlotNb].NbKeyFile = Read_NbKeyFile(hProv);
   
   if (Slot[SlotNb].NbKeyFile == 0 || Slot[SlotNb].NbKeyFile > MAX_REAL_KEY)
   {
      RETURN( CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND );
   }
   
   if (!Select_MF(hProv))
      return CRYPT_FAILED;
   
   if (!VerifyDivPIN(hProv, FALSE))
      return CRYPT_FAILED;
   
   if (!Select_Crypto_DF(hProv))
      return CRYPT_FAILED;
   
   if (!PIN_Validation(hProv))
      return CRYPT_FAILED;
   
   if (!VerifyDivPIN(hProv, TRUE))
      return CRYPT_FAILED;
   
   /*-------------------------------------------------------------------------*/
   /* Call on board generation for each key file                              */
   /*-------------------------------------------------------------------------*/
   
   i = 0;
   do
   {
      Sfi = 0x04 | ((GPK_FIRST_KEY+(BYTE)i)<<3);
      
      /* Read Record (TAG_INFO) to get key size                      */
      bSendBuffer[0] = 0x00;   //CLA
      bSendBuffer[1] = 0xB2;   //INS
      bSendBuffer[2] = 0x01;   //P1
      bSendBuffer[3] = Sfi;    //P2
      bSendBuffer[4] = 0x07;   //Lo
      cbSendLength   = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      {
         EndWait();
         RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
      }
      
      if (bRecvBuffer[1] == 0x11)
      {
         IsExport = FALSE;
         Is1024 = TRUE;
      }
      else
      {
         Is1024 = FALSE;
      }
      
      TmpKeyLength = bRecvBuffer[1];
      
      Sfi = 0x80 | (GPK_FIRST_KEY+(BYTE)i);
      
GEN_KEY:
      /* Call on-board generation                                     */
      bSendBuffer[0] = 0x80;           //CLA
      bSendBuffer[1] = 0xD2;           //INS
      bSendBuffer[2] = Sfi;            //P1
      bSendBuffer[3] = TmpKeyLength;  //P2
      cbSendLength = 4;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      
      if (SCARDPROBLEM(lRet,0x9000,0x00))
      {
         // if the first key has been generate successfully -- meaning??         
         if (dwSW1SW2 == 0x6982) // 0x6982: access condition not fulfilled
         {
            i++;          // skip and generate another key
            continue;
         }
         
         EndWait();
         RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
      }
      
      /* Wait for generation is successfull                                   */
      if (Is1024)
      {
         Wait( i+1, Slot[SlotNb].NbKeyFile, TIME_GEN_1024 );
      }
      else
      {
         Wait( i+1, Slot[SlotNb].NbKeyFile, TIME_GEN_512 );
      }
      
      /* Get response to know if generation successfull                       */
      bSendBuffer[0] = 0x00;  //CLA
      bSendBuffer[1] = 0xC0;  //INS
      bSendBuffer[2] = 0x00;  //P1
      bSendBuffer[3] = 0x00;  //P2
      bSendBuffer[4] = 0x42;  //Le
      if (Is1024)
      {
         bSendBuffer[4] = 0x82;  //Le
      }
      cbSendLength = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000,0x00))
      {
         if (dwSW1SW2 == 0x6a88) // 0x6a88: key selection error
         {
            goto GEN_KEY;
         }
         
         EndWait();
         RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
      }
      
      /* Freeze key file                                                      */
      bSendBuffer[0] = 0x80;   //CLA
      bSendBuffer[1] = 0x16;   //INS
      bSendBuffer[2] = 0x02;   //P1
      bSendBuffer[3] = 0x00;   //P2
      bSendBuffer[4] = 0x05;   //Li
      bSendBuffer[5] = 0x00;
      bSendBuffer[6] = 0x07+(BYTE)i;
      bSendBuffer[7] = 0x40;
      bSendBuffer[8] = 0x40;
      bSendBuffer[9] = 0x00;
      
      cbSendLength = 10;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000,0x00))
      {
         EndWait();
         RETURN( CRYPT_FAILED, SCARD_E_UNEXPECTED );
      }
      
      i++;
   }
   while (i < Slot[SlotNb].NbKeyFile); // version 2.00.002, it was "(i<MAX_REAL_KEY)"
   
   /*-------------------------------------------------------------------------*/
   /* Erase on board generation filter                                        */
   /*-------------------------------------------------------------------------*/
   
   /* Call erase command                                                      */
   bSendBuffer[0] = 0x80;  //CLA
   bSendBuffer[1] = 0xD4;  //INS
   bSendBuffer[2] = 0x00;  //P1
   bSendBuffer[3] = 0x00;  //P2
   cbSendLength = 4;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      EndWait();
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   /*-------------------------------------------------------------------------*/
   /* Public Part                                                             */
   /*-------------------------------------------------------------------------*/
   
   wPubSize = EF_PUBLIC_SIZE;
   if (IsExport)
   {
      wPubSize = wPubSize + DIFF_US_EXPORT;
   }
   
   /* Create EF for Public Object storage                                     */
   bSendBuffer[0]  = 0x80;   //CLA
   bSendBuffer[1]  = 0xE0;   //INS
   bSendBuffer[2]  = 0x02;   //P1
   bSendBuffer[3]  = 0x00;   //P2
   bSendBuffer[4]  = 0x0C;   //Li
   bSendBuffer[5]  = HIBYTE(GPK_OBJ_PUB_EF);    //File Id
   bSendBuffer[6]  = LOBYTE(GPK_OBJ_PUB_EF);
   bSendBuffer[7]  = 0x01;                      //FDB
   bSendBuffer[8]  = 0x00;                      //Rec Len
   bSendBuffer[9]  = HIBYTE(wPubSize);          //Body Length
   bSendBuffer[10] = LOBYTE(wPubSize);
   bSendBuffer[11] = 0x00;                      //AC1
   bSendBuffer[12] = 0x00;
   bSendBuffer[13] = 0xC0;                      //AC2
   bSendBuffer[14] = 0x00;
   bSendBuffer[15] = 0x00;                      //AC3
   bSendBuffer[16] = 0x00;
   
   cbSendLength = 17;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      EndWait();
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   /* Select Public Object storage EF                                         */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_OBJ_PUB_EF);
   bSendBuffer[6] = LOBYTE(GPK_OBJ_PUB_EF);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
   {
      EndWait();
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   dwLen = sizeof(InitValue[Slot[SlotNb].NbKeyFile-1]);//wPubSize;
   
   /* Write the Objects EF                                                    */
   dwNumberofCommands = (dwLen-1)/FILE_CHUNK_SIZE + 1;
   dwLastCommandLen   = dwLen%FILE_CHUNK_SIZE;
   
   if (dwLastCommandLen == 0)
   {
      dwLastCommandLen = FILE_CHUNK_SIZE;
   }
   
   dwCommandLen = FILE_CHUNK_SIZE;
   
   for (i=0; i < dwNumberofCommands ; i++)
   {
      if (i == dwNumberofCommands - 1)
      {
         dwCommandLen = dwLastCommandLen;
      }
      
      /* Write FILE_CHUCK_SIZE bytes or last bytes                            */
      bSendBuffer[0] = 0x00;                          //CLA
      bSendBuffer[1] = 0xD6;                          //INS
      // TT 03/11/99
      //bSendBuffer[2] = HIBYTE(i*FILE_CHUNK_SIZE/4);   //P1
      //bSendBuffer[3] = LOBYTE(i*FILE_CHUNK_SIZE/4);   //P2
      offset = (WORD)(i * FILE_CHUNK_SIZE) / ProvCont[hProv].dataUnitSize;
      bSendBuffer[2] = HIBYTE( offset );
      bSendBuffer[3] = LOBYTE( offset );              
      bSendBuffer[4] = (BYTE)dwCommandLen;            //Li
      memcpy(&bSendBuffer[5],
         &InitValue[Slot[SlotNb].NbKeyFile-1][i*FILE_CHUNK_SIZE],
         dwCommandLen
         );
      cbSendLength = 5 + dwCommandLen;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000, 0x00))
      {
         EndWait();
         RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
      }
   }
   
   /*-------------------------------------------------------------------------*/
   /* Private Part                                                            */
   /*-------------------------------------------------------------------------*/
   
   /* Create EF for Private Object storage                                     */
   bSendBuffer[0]  = 0x80;   //CLA
   bSendBuffer[1]  = 0xE0;   //INS
   bSendBuffer[2]  = 0x02;   //P1
   bSendBuffer[3]  = 0x00;   //P2
   bSendBuffer[4]  = 0x0C;   //Li
   bSendBuffer[5]  = HIBYTE(GPK_OBJ_PRIV_EF);   //File Id
   bSendBuffer[6]  = LOBYTE(GPK_OBJ_PRIV_EF);
   bSendBuffer[7]  = 0x01;                      //FDB
   bSendBuffer[8]  = 0x00;                      //Rec Len
   bSendBuffer[9]  = HIBYTE(EF_PRIVATE_SIZE);   //Body Length
   bSendBuffer[10] = LOBYTE(EF_PRIVATE_SIZE);
   bSendBuffer[11] = 0x40;                      //AC1
   bSendBuffer[12] = 0x80;
   bSendBuffer[13] = 0xC0;                      //AC2
   bSendBuffer[14] = 0x80;
   bSendBuffer[15] = 0x40;                      //AC3
   bSendBuffer[16] = 0x80;
   
   cbSendLength = 17;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      EndWait();
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   /* Select Private Object storage EF                                        */
   bSendBuffer[0] = 0x00;   //CLA
   bSendBuffer[1] = 0xA4;   //INS
   bSendBuffer[2] = 0x02;   //P1
   bSendBuffer[3] = 0x00;   //P2
   bSendBuffer[4] = 0x02;   //Li
   bSendBuffer[5] = HIBYTE(GPK_OBJ_PRIV_EF);
   bSendBuffer[6] = LOBYTE(GPK_OBJ_PRIV_EF);
   cbSendLength = 7;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x61FF,0x00))
   {
      EndWait();
      RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
   }
   
   dwLen = sizeof(InitValue[Slot[SlotNb].NbKeyFile-1]);//EF_PRIVATE_SIZE;
   
   /* Write the Objects EF                                                    */
   dwNumberofCommands = (dwLen-1)/FILE_CHUNK_SIZE + 1;
   dwLastCommandLen   = dwLen%FILE_CHUNK_SIZE;
   
   if (dwLastCommandLen == 0)
   {
      dwLastCommandLen = FILE_CHUNK_SIZE;
   }
   
   dwCommandLen = FILE_CHUNK_SIZE;
   
   for (i=0; i < dwNumberofCommands ; i++)
   {
      if (i == dwNumberofCommands - 1)
      {
         dwCommandLen = dwLastCommandLen;
      }
      
      // Write FILE_CHUCK_SIZE bytes or last bytes
      bSendBuffer[0] = 0x00;                          //CLA
      bSendBuffer[1] = 0xD6;                          //INS
      offset = (WORD)(i * FILE_CHUNK_SIZE) / ProvCont[hProv].dataUnitSize;
      bSendBuffer[2] = HIBYTE( offset );
      bSendBuffer[3] = LOBYTE( offset );              
      bSendBuffer[4] = (BYTE)dwCommandLen;            //Li
      memcpy(&bSendBuffer[5],
         &InitValue[Slot[SlotNb].NbKeyFile-1][i*FILE_CHUNK_SIZE],
         dwCommandLen
         );
      cbSendLength = 5 + dwCommandLen;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000, 0x00))
      {
         EndWait();
         RETURN(CRYPT_FAILED, SCARD_E_UNEXPECTED);
      }
   }
   EndWait();
   
   RETURN (CRYPT_SUCCEED, 0);
}



/*
-  MyCPGenKey
-
*  Purpose:
*                Generate cryptographic keys
*
*
*  Parameters:
*               IN      hProv   -  Handle to a CSP
*               IN      Algid   -  Algorithm identifier
*               IN      dwFlags -  Flags values
*               OUT     phKey   -  Handle to a generated key
*
*  Returns:
*/

BOOL WINAPI MyCPGenKey(IN  HCRYPTPROV hProv,
                       IN  ALG_ID     Algid,
                       IN  DWORD      dwFlags,
                       OUT HCRYPTKEY *phKey
                       )
{
   HCRYPTKEY   hKey, hKeyPriv;
   BOOL        bSessKey;
   BYTE        *pbBuff1 = 0, i;
   BYTE        KeyBuff[50], SaltBuff[50];
   BYTE        SaltLen, KeyLen;
   DWORD       lRet,
               dwBuff1Len,
               SlotNb;
   int         nbKey;
   BOOL        bAllSameSize;
   BOOL        b512avail;
   BOOL        b1024avail;
   // +NK 06.02.2001
   DWORD dwPinLength;
   // -

   *phKey = 0;
   bSessKey = FALSE;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;

   if (Algid == AT_KEYEXCHANGE || Algid == AT_SIGNATURE)
   {
      if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
      {
         RETURN( CRYPT_FAILED, NTE_PERM );
      }

      if (Slot[SlotNb].NbKeyFile == 0)
         Slot[SlotNb].NbKeyFile = Read_NbKeyFile(hProv);
   
      if (Slot[SlotNb].NbKeyFile == 0 || Slot[SlotNb].NbKeyFile > MAX_REAL_KEY)
      {
         RETURN (CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND);   // should not bigger than MAX_REAL_KEY
      }
   }
   
   switch (Algid)
   {
   case AT_SIGNATURE:
      //
      //    Verisign Enrollment process does not respect this fact
      //
      //       if (dwFlags & CRYPT_EXPORTABLE)
      //       {
      //           RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      //       }
      
      if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
      {
         RETURN( CRYPT_FAILED, NTE_PERM );
      }

      // + NK 06.02.2001 
     // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
     lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                              NULL, 
                                     &dwPinLength );

      if ((lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY))
          RETURN (CRYPT_FAILED, lRet);

       if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
       // - NK
      {
         RETURN( CRYPT_FAILED, NTE_SILENT_CONTEXT );
      }
      
      if (!PublicEFExists(hProv))
      {
         if (!gen_key_on_board(hProv))
         {
            return CRYPT_FAILED;
         }
         else
         {
            if (!read_gpk_objects(hProv, FALSE))
               return CRYPT_FAILED;

            Slot[SlotNb].Read_Public = TRUE;
            Slot[SlotNb].Read_Priv   = FALSE;
         }
      }
      
      if (!Read_Priv_Obj(hProv))
         return CRYPT_FAILED;
      
      if (HIWORD(dwFlags) != 0x0000)
      {      
         KeyLen = HIWORD(dwFlags) / 8;
         //check for the keylen, only 512 or 1024 key are supported for now
         if (( KeyLen != 64 && KeyLen != 128 ) || (HIWORD(dwFlags) & 7))
         {
             RETURN (CRYPT_FAILED, NTE_BAD_LEN);
         }       

         // [FP] +
         switch(Slot[SlotNb].NbKeyFile)
         {
            case 2:
                if ((Slot[SlotNb].GpkPubKeys[0].KeySize == 64) &&
                    (Slot[SlotNb].GpkPubKeys[1].KeySize == 64) && // GPK4K Intl
                    (KeyLen == 128))
                    RETURN (CRYPT_FAILED, NTE_BAD_LEN);
                break;

            case 4:
                break;

            default:
                RETURN (CRYPT_FAILED, NTE_FAIL);
         }
         // [FP] +
      }
      else
      {
         KeyLen = 0;
         
         // Read key file lengths
         nbKey = Slot[SlotNb].NbKeyFile;
         
         for (i = 0; i<nbKey; ++i)
            KeyLenFile[i] = Slot[SlotNb].GpkPubKeys[i].KeySize;
         
         // If all keys have the same size, use that size
         bAllSameSize = TRUE;
         for (i = 1; i<nbKey; ++i)
         {
            if (KeyLenFile[i] != KeyLenFile[0])
            {
               bAllSameSize = FALSE;
               break;
            }
         }
         
         if (bAllSameSize)
            KeyLen = KeyLenFile[0];
         else
         {          
            // TT - BUG #1504: If only one key size is available, try to use it
            b512avail = find_gpk_obj_tag_type( hProv, TAG_RSA_PUBLIC, 0, 512/8, FALSE, FALSE ) != 0;
            b1024avail = find_gpk_obj_tag_type( hProv, TAG_RSA_PUBLIC, 0, 1024/8, FALSE, FALSE ) != 0;
            
            if (!b512avail && !b1024avail)
            {
               RETURN (CRYPT_FAILED, NTE_FAIL );
            }
            
            if (b512avail && !b1024avail) KeyLen = 512/8;
            else if (!b512avail && b1024avail) KeyLen = 1024/8;
            else
            {
               // TT - END
               if (ProvCont[hProv].Flags & CRYPT_SILENT)
               {
                  // Check if default key length (1024) is available
                  for (i = 0; i<nbKey; ++i)
                  {
                     if (KeyLenFile[i] == 0x80)
                     {
                        KeyLen = 0x80;
                        break;
                     }
                  }
                  
                  if (KeyLen==0)
                  {
                     // Take smallest key size available
                     KeyLen = KeyLenFile[0];
                     for (i = 1; i<nbKey; ++i)
                     {
                        if (KeyLenFile[i] < KeyLen)
                           KeyLen = KeyLenFile[i];
                     }
                  }
               }
               else
               {
                  DialogBox(g_hInstRes, TEXT("KEYDIALOG"), GetAppWindow(), KeyDlgProc);
                  if (KeyLenChoice == 0)
                  {
                     RETURN (CRYPT_FAILED, NTE_BAD_LEN);
                  }
                  else
                  {
                     KeyLen = KeyLenChoice;
                  }
               }
            }
         }
      }
      
      // AT_SIGNATURE      
      hKey = find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC,  0x00, KeyLen, FALSE, FALSE);
      if ((hKey != 0)
         &&(find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC,  AT_SIGNATURE, 0x00, FALSE, FALSE) == 0)
         &&(find_gpk_obj_tag_type(hProv, TAG_CERTIFICATE, AT_SIGNATURE, 0x00, FALSE, FALSE) == 0)
         )
      {
         *phKey = hKey;
      }
      else
      {
         RETURN (CRYPT_FAILED, NTE_FAIL );
      }
      
      // TT 24/09/99: On board key generation for GPK8000
      if (ProvCont[hProv].bGPK8000)
      {
         if (!gen_key_on_board8000( hProv, Slot[SlotNb].GpkObject[hKey].FileId ))
         {
            RETURN( CRYPT_FAILED, NTE_FAIL );
         }
      }
      // TT - END -
      
      
      
      hKeyPriv = find_gpk_obj_tag_file(hProv,
         TAG_RSA_PRIVATE,
         Slot[SlotNb].GpkObject[hKey].FileId,
         FALSE
         );
      
      if ( hKeyPriv == 0 )
      {
         RETURN (CRYPT_FAILED, NTE_SIGNATURE_FILE_BAD);
      }
      
      if ((HIWORD(dwFlags) != 0)  &&
         (Slot[SlotNb].GpkObject[hKeyPriv].PubKey.KeySize != (HIWORD(dwFlags) / 8))
         )
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
      if (IsNull (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue))
      {
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
      if (IsNull (Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue))
      {
         GMEM_Free (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue);
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      Slot[SlotNb].GpkObject[hKey].IsCreated                     = TRUE;
      Slot[SlotNb].GpkObject[hKey].Flags = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_KEY_TYPE;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len       = 1;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0] = AT_SIGNATURE;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].bReal     = TRUE;
      
      /* Set Flags of automatic fields for PKCS#11 compatibility           */
      Slot[SlotNb].GpkObject[hKey].Flags = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_ID;
      Slot[SlotNb].GpkObject[hKey].Field[POS_ID].Len   = 0;
      Slot[SlotNb].GpkObject[hKey].Field[POS_ID].bReal = FALSE;
      
      Slot[SlotNb].GpkObject[hKeyPriv].IsCreated                     = TRUE;
      Slot[SlotNb].GpkObject[hKeyPriv].Flags = Slot[SlotNb].GpkObject[hKeyPriv].Flags | FLAG_KEY_TYPE;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].Len       = 1;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue[0] = AT_SIGNATURE;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].bReal     = TRUE;
      
      /* Set Flags of automatic fields for PKCS#11 compatibility           */
      Slot[SlotNb].GpkObject[hKeyPriv].Flags = Slot[SlotNb].GpkObject[hKeyPriv].Flags | FLAG_ID;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_ID].Len   = 0;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_ID].bReal = FALSE;
      
      if (!ProvCont[hProv].bLegacyKeyset)
      {
         Slot[SlotNb].GpkObject[hKey].Flags |= FLAG_KEYSET;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].Len       = 1;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
         if(IsNull(Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue))
         {
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].bReal     = TRUE;
         Slot[SlotNb].GpkObject[hKeyPriv].Flags |= FLAG_KEYSET;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].Len       = 1;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
         if(IsNull(Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue))
         {
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].bReal     = TRUE;
      }
      
      // Set the file containing the key to USE, add "- GPK_FIRST_KEY" here. version 2.00.002
      Slot[SlotNb].UseFile [Slot[SlotNb].GpkObject[hKey].FileId- GPK_FIRST_KEY] = TRUE;
      
      break;
      
   case AT_KEYEXCHANGE:
      //
      //    Verisign Enrollment process does not respect this fact
      //
      //       if (dwFlags & CRYPT_EXPORTABLE)
      //       {
      //           RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      //       }
      
      if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
       // + NK 06.02.2001 
      // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
      lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                               NULL, 
                                &dwPinLength );

      if ( (lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY) )
         RETURN (CRYPT_FAILED, lRet);

       if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
       // - NK
      {
         RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
      }
      
      if (!PublicEFExists(hProv))
      {
         if (!gen_key_on_board(hProv))
         {
            return CRYPT_FAILED;
         }
         else
         {
            if (!read_gpk_objects(hProv, FALSE))
               return CRYPT_FAILED;
                        
            Slot[SlotNb].Read_Public = TRUE;
            Slot[SlotNb].Read_Priv   = FALSE;
         }
      }
      
      if (!Read_Priv_Obj(hProv))
         return CRYPT_FAILED;
      
      if (HIWORD(dwFlags) != 0x0000)
      {
         KeyLen = HIWORD(dwFlags) / 8;

         //check for the keylen, only 512 or 1024 key are supported for now
         if (( KeyLen != 64 && KeyLen != 128 ) || (HIWORD(dwFlags) & 7))
         {
             RETURN (CRYPT_FAILED, NTE_BAD_LEN);
         }

         // [FP] +
         switch(Slot[SlotNb].NbKeyFile)
         {
            case 2:
                if ((Slot[SlotNb].GpkPubKeys[0].KeySize == 64) &&
                    (Slot[SlotNb].GpkPubKeys[1].KeySize == 64) && // GPK4K Intl
                    (KeyLen == 128))
                    RETURN (CRYPT_FAILED, NTE_BAD_LEN);
                break;

            case 4:
                if ((Slot[SlotNb].GpkPubKeys[0].KeySize == 64) &&
                    (Slot[SlotNb].GpkPubKeys[1].KeySize == 64) &&
                    (Slot[SlotNb].GpkPubKeys[2].KeySize == 64) &&
                    (Slot[SlotNb].GpkPubKeys[3].KeySize == 128) && // GPK8K Intl
                    (KeyLen == 128))
                    RETURN (CRYPT_FAILED, NTE_BAD_LEN);
                break;

            default:
                RETURN (CRYPT_FAILED, NTE_FAIL);
         }
         // [FP] +
      }
      else
      {
         KeyLen = 0;
         
         // Read key file lengths
         nbKey = Slot[SlotNb].NbKeyFile;
         
         for (i = 0; i<nbKey; ++i)
            KeyLenFile[i] = Slot[SlotNb].GpkPubKeys[i].KeySize;
         
         // If all keys have the same size, use that size
         bAllSameSize = TRUE;
         for (i = 1; i<nbKey; ++i)
         {
            if (KeyLenFile[i] != KeyLenFile[0])
            {
               bAllSameSize = FALSE;
               break;
            }
         }
         
         if (bAllSameSize)
            KeyLen = KeyLenFile[0];
         else
         {
            // TT - BUG #1504: If only one key size is available, try to use it
            b512avail = find_gpk_obj_tag_type( hProv, TAG_RSA_PUBLIC, 0, 512/8, TRUE, FALSE ) != 0;
            b1024avail = find_gpk_obj_tag_type( hProv, TAG_RSA_PUBLIC, 0, 1024/8, TRUE, FALSE ) != 0;
            
            if (!b512avail && !b1024avail)
            {
               RETURN (CRYPT_FAILED, NTE_FAIL );
            }
            
            if (b512avail && !b1024avail) KeyLen = 512/8;
            else if (!b512avail && b1024avail) KeyLen = 1024/8;
            else
            {
               // TT - END
               // Check if default key length is available
               for (i = 0; i<nbKey; ++i)
               {
                  if (KeyLenFile[i] == RSA_KEK_Size)
                  {
                     KeyLen = RSA_KEK_Size;
                     break;
                  }
               }
               
               if (KeyLen==0)
               {
                  // Take smallest key size available
                  KeyLen = KeyLenFile[0];
                  for (i = 1; i<nbKey; ++i)
                  {
                     if (KeyLenFile[i] < KeyLen)
                        KeyLen = KeyLenFile[i];
                  }
               }
            }
         }
      }     

      if (KeyLen > RSA_KEK_Size)      
      {
         RETURN (CRYPT_FAILED, NTE_BAD_LEN);
      }
      
      // AT_EXCHANGE
      hKey = find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC, 0x00, KeyLen, TRUE, FALSE);
      if ((hKey != 0)
         &&(find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC,  AT_KEYEXCHANGE, 0x00, TRUE,  FALSE) == 0)
         &&(find_gpk_obj_tag_type(hProv, TAG_CERTIFICATE, AT_KEYEXCHANGE, 0x00, FALSE, FALSE) == 0)
         )
      {
         *phKey = hKey;
      }
      else
      {
         RETURN (CRYPT_FAILED, NTE_FAIL );
      }

      // TT 24/09/99: On board key generation for GPK8000
      if (ProvCont[hProv].bGPK8000)
      {
         if (!gen_key_on_board8000( hProv, Slot[SlotNb].GpkObject[hKey].FileId ))
         {
            RETURN( CRYPT_FAILED, NTE_FAIL );
         }
      }
      // TT - END -
      
      hKeyPriv = find_gpk_obj_tag_file(hProv,
         TAG_RSA_PRIVATE,
         Slot[SlotNb].GpkObject[hKey].FileId,
         TRUE
         );
      
      if ( hKeyPriv == 0 )
      {
         RETURN (CRYPT_FAILED, NTE_SIGNATURE_FILE_BAD);
      }
      
      if ((HIWORD(dwFlags) != 0) &&
         (Slot[SlotNb].GpkObject[hKeyPriv].PubKey.KeySize  != (HIWORD(dwFlags) / 8))
         )
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
      if (IsNull (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue))
      {
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
      if (IsNull (Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue))
      {
         GMEM_Free (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue);
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
     
      Slot[SlotNb].GpkObject[hKey].IsCreated                     = TRUE;
      Slot[SlotNb].GpkObject[hKey].Flags = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_KEY_TYPE;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len       = 1;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0] = AT_KEYEXCHANGE;
      Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].bReal     = TRUE;
      
      /* Set Flags of automatic fields for PKCS#11 compatibility           */
      Slot[SlotNb].GpkObject[hKey].Flags = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_ID;
      Slot[SlotNb].GpkObject[hKey].Field[POS_ID].Len   = 0;
      Slot[SlotNb].GpkObject[hKey].Field[POS_ID].bReal = FALSE;
      
      Slot[SlotNb].GpkObject[hKeyPriv].IsCreated = TRUE;
      Slot[SlotNb].GpkObject[hKeyPriv].Flags     = Slot[SlotNb].GpkObject[hKeyPriv].Flags | FLAG_KEY_TYPE;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].Len       = 1;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].pValue[0] = AT_KEYEXCHANGE;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEY_TYPE].bReal     = TRUE;
      
      /* Set Flags of automatic fields for PKCS#11 compatibility           */
      Slot[SlotNb].GpkObject[hKeyPriv].Flags = Slot[SlotNb].GpkObject[hKeyPriv].Flags | FLAG_ID;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_ID].Len   = 0;
      Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_ID].bReal = FALSE;
      
      if (!ProvCont[hProv].bLegacyKeyset)
      {
         Slot[SlotNb].GpkObject[hKey].Flags |= FLAG_KEYSET;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].Len       = 1;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
         if(IsNull(Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue))
         {
             RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
         Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].bReal     = TRUE;
         Slot[SlotNb].GpkObject[hKeyPriv].Flags |= FLAG_KEYSET;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].Len       = 1;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
         if(IsNull(Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue))
         {
             RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
         Slot[SlotNb].GpkObject[hKeyPriv].Field[POS_KEYSET].bReal     = TRUE;
      }
      
      
      // Set the file containing the key to USE, add "- GPK_FIRST_KEY" here, version 2.00.002
      Slot[SlotNb].UseFile [Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY] = TRUE;
      break;
      
   case CALG_RC2:
      KeyLen  = RC2_Key_Size;
      SaltLen = 0;
      if (dwFlags & CRYPT_CREATE_SALT)
      {
         SaltLen = RC2_128_SIZE - RC2_Key_Size;
      }
      bSessKey = TRUE;
      break;
      
   case CALG_RC4:
      KeyLen  = RC2_Key_Size;
      SaltLen = 0;
      if (dwFlags & CRYPT_CREATE_SALT)
      {
         SaltLen = RC2_128_SIZE - RC2_Key_Size;
      }
      bSessKey = TRUE;
      break;
      
   case CALG_DES:
      KeyLen   = DES_SIZE;
      SaltLen  = 0;
      if (dwFlags & CRYPT_CREATE_SALT)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      bSessKey = TRUE;
      break;
      
   case CALG_3DES_112:
      KeyLen  = DES3_112_SIZE;
      SaltLen = 0;
      if (dwFlags & CRYPT_CREATE_SALT)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      bSessKey = TRUE;
      break;
      
   case CALG_3DES:
      KeyLen  = DES3_SIZE;
      SaltLen = 0;
      if (dwFlags & CRYPT_CREATE_SALT)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      bSessKey = TRUE;
      break;
      
   default:
      RETURN (CRYPT_FAILED, NTE_BAD_ALGID);
   }
   
   if (!bSessKey)
   {
      CspFlags = ProvCont[hProv].Flags;
      
      
      pbBuff1 = (BYTE*)GMEM_Alloc (MAX_GPK_PUBLIC);
      if (IsNull(pbBuff1))
      {
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      dwBuff1Len = MAX_GPK_PUBLIC;
      if (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, FALSE))
      {
         lRet = GetLastError();
         GMEM_Free (pbBuff1);
         RETURN (CRYPT_FAILED, lRet);
      }
     
      if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, FALSE))
      {
         lRet = GetLastError();
         GMEM_Free (pbBuff1);
         RETURN (CRYPT_FAILED, lRet);
      }
      
      GMEM_Free (pbBuff1);
      
      pbBuff1 = (BYTE*)GMEM_Alloc (MAX_GPK_PRIVATE);
      if (IsNull(pbBuff1))
      {
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      dwBuff1Len = MAX_GPK_PRIVATE;
      if (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, TRUE))
      {
         lRet = GetLastError();
         GMEM_Free (pbBuff1);
         RETURN (CRYPT_FAILED, lRet);
      }
      
      if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, TRUE))
      {
         lRet = GetLastError();
         GMEM_Free (pbBuff1);
         RETURN (CRYPT_FAILED, lRet);
      }
      
      GMEM_Free (pbBuff1);
      
      /* Copy Gpk Key in Microsoft RSA base Module                            */

      Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[*phKey].FileId - GPK_FIRST_KEY].KeySize = 0;
      
      if (!read_gpk_pub_key( hProv, *phKey, &Slot[SlotNb].GpkObject[*phKey].PubKey ))
         return CRYPT_FAILED;

      if (!copy_gpk_key(hProv, *phKey, Algid))
         return CRYPT_FAILED;      
   }
   else
   {
      hKey = find_tmp_free();
      if (hKey == 0)
      {
         RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
      }
      
      if (KeyLen > AuxMaxSessionKeyLength)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_LEN);
      }
      
      // Notice: Implicitly we also need in this case to establish a transaction
      //         with the card. OK done by the wrapper
      
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         if (!CryptGenKey (hProvBase, Algid, dwFlags, &(TmpObject[hKey].hKeyBase)))
            return CRYPT_FAILED;      
         
         TmpObject[hKey].hProv = hProv;
         *phKey = hKey + MAX_GPK_OBJ;
         
         RETURN (CRYPT_SUCCEED, 0);
      }
      
      if (!MyCPGenRandom(hProv, KeyLen, KeyBuff))
         return CRYPT_FAILED;      
      
      if (SaltLen != 0)
      {
         if (!MyCPGenRandom(hProv, SaltLen, SaltBuff))
            return CRYPT_FAILED;      
      }
      
      /* Copy Session Key in Microsoft RSA base Module*/
      if (dwFlags & CRYPT_CREATE_SALT)     // CryptImport does not deal with that flag
         dwFlags ^= CRYPT_CREATE_SALT;    // however, it is consider anyhow with the
      // SaltLen parameter.
      
      if (!copy_tmp_key(hProv, hKey, dwFlags, Algid, KeyBuff, KeyLen, SaltBuff, SaltLen))
         return CRYPT_FAILED;      
      
      *phKey = hKey + MAX_GPK_OBJ;
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}



/*
-  MyCPGenRandom
-
*  Purpose:
*                Used to fill a buffer with random bytes
*
*
*  Parameters:
*               IN  hProv      -  Handle to the user identifcation
*               OUT pbBuffer   -  Pointer to the buffer where the random
*                                 bytes are to be placed
*               IN  dwLen      -  Number of bytes of random data requested
*
*  Returns:
*/
BOOL WINAPI MyCPGenRandom(IN HCRYPTPROV hProv,
                          IN DWORD      dwLen,
                          IN OUT BYTE  *pbBuffer
                          )
                          
{
   DWORD i, dwMod, dwLastCommandLen, lRet;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
      (ProvCont[hProv].isContNameNullBlank))
   {
      RETURN (CRYPT_FAILED, NTE_PERM);
   }
   
   if (dwLen==0)
   {
      RETURN (CRYPT_SUCCEED, 0);
   }
   
   /* Generate random by blocks of 32 bytes */
   dwMod             = (dwLen-1)/32 + 1;
   dwLastCommandLen  = dwLen%32;
   
   if (dwLastCommandLen == 0)
   {
      dwLastCommandLen = 32;
   }
   
   for (i=0 ; i < dwMod ; i++)
   {
      /* Ask card for a 32 bytes random number                                   */
      bSendBuffer[0] = 0x80;   //CLA
      bSendBuffer[1] = 0x84;   //INS
      bSendBuffer[2] = 0x00;   //P1
      bSendBuffer[3] = 0x00;   //P2
      bSendBuffer[4] = 0x20;   //Lo
      cbSendLength = 5;
      
      cbRecvLength = sizeof(bRecvBuffer);
      lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                            cbSendLength, 0, bRecvBuffer, &cbRecvLength );
      if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
      {
         RETURN (CRYPT_FAILED, SCARD_E_UNSUPPORTED_FEATURE);
      }
      
      memcpy(&pbBuffer[i*32],
         bRecvBuffer,
         ((i == dwMod - 1) ? dwLastCommandLen : 32)
         );
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPGetKeyParam
-
*  Purpose:
*                Allows applications to get various aspects of the
*                operations of a key
*
*  Parameters:
*               IN      hProv      -  Handle to a CSP
*               IN      hKey       -  Handle to a key
*               IN      dwParam    -  Parameter number
*               IN      pbData     -  Pointer to data
*               IN      pdwDataLen -  Length of parameter data
*               IN      dwFlags    -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPGetKeyParam(IN HCRYPTPROV hProv,
                            IN HCRYPTKEY  hKey,
                            IN DWORD      dwParam,
                            IN BYTE      *pbData,
                            IN DWORD     *pdwDataLen,
                            IN DWORD      dwFlags
                            )
{
   BOOL        CryptResp;
   BYTE        hCert;
   BYTE        KeyType;
   BYTE        KeyId;
   BYTE        GpkKeySize;
   DWORD       SlotNb;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   /* Resident Key                                                            */
   if (hKey == 0)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   else if (hKey <= MAX_GPK_OBJ)
   {
      if (dwFlags != 0)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
      }
      
      // [mv - 15/05/98]
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if (Slot[SlotNb].GpkObject[hKey].FileId == 0)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }
      
      if (Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len == 0)
      {
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }
      
      KeyId = Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0];
      
      switch (dwParam)
      {
      case KP_ALGID:
         if (IsNotNull(pbData))
         {
            DWORD dwAlgid;
            
            if (*pdwDataLen < sizeof(DWORD))
            {
               *pdwDataLen = sizeof(DWORD);
               RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
            }
            
            switch (KeyId)
            {
            case AT_KEYEXCHANGE:
               dwAlgid = CALG_RSA_KEYX;
               break;
               
            case AT_SIGNATURE:
               dwAlgid = CALG_RSA_SIGN;
               break;
               
            default:
               RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
            }
            memcpy(pbData, &dwAlgid, sizeof(DWORD));
         }
         
         *pdwDataLen = sizeof(DWORD);
         break;
         
      case KP_BLOCKLEN:
      case KP_KEYLEN:
         if (IsNotNull(pbData))
         {
            DWORD dwBlockLen;
            
            if (*pdwDataLen < sizeof(DWORD))
            {
               *pdwDataLen = sizeof(DWORD);
               RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
            }
            
            GpkKeySize = Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY].KeySize;
            if (GpkKeySize == 0)
            {
               RETURN (CRYPT_FAILED, NTE_BAD_KEY);
            }
            
            dwBlockLen = GpkKeySize*8;
            memcpy(pbData, &dwBlockLen, sizeof(DWORD));
         }
         
         *pdwDataLen = sizeof(DWORD);
         break;
         
      case KP_PERMISSIONS:
         if (IsNotNull(pbData))
         {
            DWORD dwPerm;
            
            if (*pdwDataLen < sizeof(DWORD))
            {
               *pdwDataLen = sizeof(DWORD);
               RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
            }
                        
            switch (KeyId)
            {
            case AT_KEYEXCHANGE:
               dwPerm = 0
                  |   CRYPT_ENCRYPT   // Allow encryption
                  |   CRYPT_DECRYPT   // Allow decryption
                  //  CRYPT_EXPORT    // Allow key to be exported
                  |   CRYPT_READ      // Allow parameters to be read
                  |   CRYPT_WRITE     // Allow parameters to be set
                  |   CRYPT_MAC       // Allow MACs to be used with key
                  |   CRYPT_EXPORT_KEY// Allow key to be used for exporting keys
                  |   CRYPT_IMPORT_KEY// Allow key to be used for importing keys
                  ;
               break;
               
            case AT_SIGNATURE:
               dwPerm = 0
                  //  CRYPT_ENCRYPT   // Allow encryption
                  //  CRYPT_DECRYPT   // Allow decryption
                  //  CRYPT_EXPORT    // Allow key to be exported
                  |   CRYPT_READ      // Allow parameters to be read
                  |   CRYPT_WRITE     // Allow parameters to be set
                  |   CRYPT_MAC       // Allow MACs to be used with key
                  //  CRYPT_EXPORT_KEY// Allow key to be used for exporting keys
                  //  CRYPT_IMPORT_KEY// Allow key to be used for importing keys
                  ;
               break;
               
            default:
               RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
            }
            memcpy(pbData, &dwPerm, sizeof(DWORD));
         }
         
         *pdwDataLen = sizeof(DWORD);
         break;
         
      case KP_CERTIFICATE:
         KeyType = Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0];
         hCert = find_gpk_obj_tag_type( hProv, TAG_CERTIFICATE, KeyType,
                                        0x00, FALSE, FALSE );
         if (hCert == 0)
         {
            RETURN( CRYPT_FAILED, SCARD_E_NO_SUCH_CERTIFICATE );
         }
         
         /* Retrieve Certificate Value                                     */
         if (IsNotNull(pbData))
         {
            if (*pdwDataLen < Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len)
            {
               *pdwDataLen = Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len;
               RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
            }
            memcpy(pbData,
               Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue,
               Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len
               );
         }
         
         *pdwDataLen = Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len;
         break;
         
         
      default:
         RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
        }
    }
    /* Session Key                                                             */
    else if (key_exist (hKey-MAX_GPK_OBJ, hProv))
    {
       CryptResp = CryptGetKeyParam (TmpObject[hKey-MAX_GPK_OBJ].hKeyBase,
          dwParam,
          pbData,
          pdwDataLen,
          dwFlags);
       if (!CryptResp)
         return CRYPT_FAILED;      
    }
    /* Bad Key                                                                 */
    else
    {
       RETURN (CRYPT_FAILED, NTE_BAD_KEY);
    }
    
    RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPGetUserKey
-
*  Purpose:
*                Gets a handle to a permanent user key
*
*
*  Parameters:
*               IN  hProv      -  Handle to the user identifcation
*               IN  dwKeySpec  -  Specification of the key to retrieve
*               OUT phUserKey  -  Pointer to key handle of retrieved key
*
*  Returns:
*/
BOOL WINAPI MyCPGetUserKey(IN  HCRYPTPROV hProv,
                           IN  DWORD      dwKeySpec,
                           OUT HCRYPTKEY *phUserKey
                           )
{
   HCRYPTKEY   hKey;
   GPK_EXP_KEY aPubKey;
   DWORD       dwLen;
   
   *phUserKey = 0;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   /* Bug # 1103
   if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
   (ProvCont[hProv].isContNameNullBlank))
   */
   if ( ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT )
   {
      RETURN (CRYPT_FAILED, NTE_PERM);
   }
   
   if (!PublicEFExists(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_NO_KEY);
   }
   
   if (dwKeySpec != AT_KEYEXCHANGE && dwKeySpec != AT_SIGNATURE)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }

   if (dwKeySpec == AT_KEYEXCHANGE)
   {
      hKey = find_gpk_obj_tag_type(hProv,
         TAG_RSA_PUBLIC,
         (BYTE)dwKeySpec,
         0x00,
         TRUE,
         FALSE
         );
      
      // get the key length
      if (hKey != 0)
      {
         if (!read_gpk_pub_key(hProv, hKey, &aPubKey))
         {
            hKey = 0;
         }
         else
         {
            dwLen = aPubKey.KeySize;
            if (dwLen > RSA_KEK_Size)
            {
               hKey = 0;
            }
         }
      }
   }
   else
   {
      hKey = find_gpk_obj_tag_type(hProv,
         TAG_RSA_PUBLIC,
         (BYTE)dwKeySpec,
         0x00,
         FALSE,
         FALSE
         );
   }
   
   if (hKey == 0)
   {
      RETURN (CRYPT_FAILED, NTE_NO_KEY);
   }
   
   *phUserKey = hKey;
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*
-  MyCPImportKey
-
*  Purpose:
*                Import cryptographic keys
*
*
*  Parameters:
*               IN  hProv     -  Handle to the CSP user
*               IN  pbData    -  Key blob data
*               IN  dwDataLen -  Length of the key blob data
*               IN  hPubKey   -  Handle to the exchange public key value of
*                                the destination user
*               IN  dwFlags   -  Flags values
*               OUT phKey     -  Pointer to the handle to the key which was
*                                Imported
*
*  Returns:
*/
BOOL WINAPI MyCPImportKey(IN  HCRYPTPROV  hProv,
                          IN  CONST BYTE *pbData,
                          IN  DWORD       dwDataLen,
                          IN  HCRYPTKEY   hPubKey,
                          IN  DWORD       dwFlags,
                          OUT HCRYPTKEY  *phKey
                          )
{
   DWORD       lRet;
   BOOL        CryptResp;
   HCRYPTKEY   hTmpKey, hPrivKey;
   BLOBHEADER  BlobHeader;
   DWORD       dwAlgid, dwBlobLen;
   BYTE*       pBlob;
   BYTE*       pBlobOut;
   DWORD       SlotNb;
   // + [FP] for PRIVATEKEYBLOB
   BOOL        GpkObj;
   GPK_EXP_KEY aPubKey;
   DWORD       dwKeyLen;
   BYTE        bKeyType;
   BOOL        IsExchange;
   HCRYPTKEY   hKey;
   BYTE        bSfi;
   BYTE        *pbBuff1 = 0;
   DWORD        dwBuff1Len;
   // - [FP]
   // + NK 07.02.2001
   DWORD dwPinLength;
   // -NK
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   if ((IsNull(pbData)) || (dwDataLen < sizeof(BLOBHEADER)+sizeof(RSAPUBKEY)))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_DATA);
   }
   
   memcpy(&BlobHeader, pbData, sizeof(BLOBHEADER));
   
   if (BlobHeader.bVersion != CUR_BLOB_VERSION)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_VER);
   }
   
   switch (BlobHeader.bType)
   {
   case PUBLICKEYBLOB:
      {
         hTmpKey = find_tmp_free();
         if (hTmpKey == 0)
         {
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         /* Copy Session Key in Microsoft RSA base Module                           */
         CryptResp = CryptImportKey(hProvBase,
            pbData,
            dwDataLen,
            0,
            dwFlags,
            &(TmpObject[hTmpKey].hKeyBase));
         
         if (!CryptResp)
            return CRYPT_FAILED;      
         
         TmpObject[hTmpKey].hProv = hProv;
         
         *phKey = hTmpKey+MAX_GPK_OBJ;
      }
      break;
      
   case SIMPLEBLOB:
      {
         if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
         {
            RETURN (CRYPT_FAILED, NTE_PERM);
         }
         
          // + NK 06.02.2001 
         // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
         lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                                  NULL, 
                                   &dwPinLength );

         if ( (lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY) )
            RETURN (CRYPT_FAILED, lRet);
         
           if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
       // - NK
         {
            RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
         }
         
         // Verify the PINs
         
         if (!PIN_Validation(hProv))
            return CRYPT_FAILED;      
         
         if (!VerifyDivPIN(hProv, TRUE))
            return CRYPT_FAILED;      
         
         switch (BlobHeader.aiKeyAlg)
         {
         case CALG_RC2:
         case CALG_RC4:
         case CALG_DES:
         case CALG_3DES_112:
         case CALG_3DES:    break;
            
         default:
            RETURN (CRYPT_FAILED, NTE_BAD_ALGID);
         }
         
         memcpy( &dwAlgid, &pbData[sizeof(BlobHeader)], sizeof(DWORD) );
         
         switch (dwAlgid)
         {
         case CALG_RSA_KEYX:
            CryptResp = MyCPGetUserKey(hProv, AT_KEYEXCHANGE, &hPrivKey);
            if ((!CryptResp) || (hPrivKey == 0))
            {
               RETURN (CRYPT_FAILED, NTE_BAD_DATA);
            }
            break;
            
         case CALG_RSA_SIGN:
            RETURN (CRYPT_FAILED, NTE_BAD_DATA);
            break;
            
         default:
            RETURN (CRYPT_FAILED, NTE_BAD_DATA);
         }
         
         dwBlobLen = dwDataLen-sizeof(BLOBHEADER)-sizeof(DWORD);
         
         pBlob = (BYTE*)GMEM_Alloc(dwBlobLen);
         if (IsNull(pBlob))
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         
         pBlobOut  = (BYTE*)GMEM_Alloc(dwBlobLen);
         if (IsNull(pBlobOut))
         {
            GMEM_Free (pBlob);
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         bool   bErrorInTryOccured=false;
         DWORD  dwErrorCode=ERROR_SUCCESS;
         __try
         {
            memcpy( pBlob, &pbData[sizeof(BLOBHEADER)+sizeof(DWORD)], dwBlobLen );
         
            hTmpKey = find_tmp_free();
            if (hTmpKey == 0)
            {
                bErrorInTryOccured=true;
                dwErrorCode=NTE_NO_MEMORY;
                __leave;
            }
            //   RETURN( CRYPT_FAILED, NTE_NO_MEMORY );
         
            CryptResp = key_unwrap( hProv, hPrivKey, pBlob, dwBlobLen, pBlobOut, &dwBlobLen );
            if (!CryptResp)
            {
                bErrorInTryOccured=true;
                __leave;
            }
               //return CRYPT_FAILED;
         
            if (dwBlobLen > AuxMaxSessionKeyLength)
            {
                bErrorInTryOccured=true;
                dwErrorCode=NTE_BAD_KEY;
                __leave;
            }
             //  RETURN( CRYPT_FAILED, NTE_BAD_KEY );
         
            /* Copy Session Key in Microsoft RSA base Module                           */
            if (!copy_tmp_key(hProv, hTmpKey, dwFlags, BlobHeader.aiKeyAlg, pBlobOut, dwBlobLen, 0, 0))
            {
                bErrorInTryOccured=true;
                __leave;
            }
               //return CRYPT_FAILED;
         
            *phKey = hTmpKey+MAX_GPK_OBJ;
         }
         __finally
         {         
            GMEM_Free(pBlob);
            GMEM_Free(pBlobOut);
         }
         if(bErrorInTryOccured)
         {
            if(dwErrorCode==ERROR_SUCCESS)
                return CRYPT_FAILED;
            else
                RETURN(CRYPT_FAILED, dwErrorCode);
         }
      }
      break;
        
        // + [FP]
   case PRIVATEKEYBLOB:
      {
         if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
         {
            RETURN (CRYPT_FAILED, NTE_PERM);
         }
         
         // + NK 06.02.2001 
         // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
         
         lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                                  NULL, 
                                  &dwPinLength );
         if ( (lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY) )
            RETURN (CRYPT_FAILED, lRet);
         
         if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
         // - NK
         {
            RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
         }
         
         if (Slot[SlotNb].NbKeyFile == 0 || Slot[SlotNb].NbKeyFile > MAX_REAL_KEY)
         {
            RETURN (CRYPT_FAILED, SCARD_E_FILE_NOT_FOUND);   // should not bigger than MAX_REAL_KEY
         }
         
         // get the key type
         bKeyType = (BlobHeader.aiKeyAlg == CALG_RSA_KEYX) ? AT_KEYEXCHANGE : AT_SIGNATURE;
         IsExchange = (BlobHeader.aiKeyAlg == CALG_RSA_KEYX) ? TRUE : FALSE;
         
         // get the key size (in bits)
         memcpy(&dwKeyLen,
            &pbData[sizeof(BlobHeader)+ sizeof(DWORD)],
            sizeof(DWORD)
            );
         
         if (bKeyType == AT_KEYEXCHANGE)
         {
            if ((dwKeyLen / 8) > RSA_KEK_Size)
            {
               RETURN (CRYPT_FAILED, NTE_BAD_LEN);
            }
         }
         
         GpkObj = TRUE;
         
         hKey = find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC, bKeyType, 0x00, IsExchange, FALSE);
         
         if (hKey != 0)
         {
            if (!read_gpk_pub_key(hProv, hKey, &aPubKey))
            {
               RETURN (CRYPT_FAILED, NTE_FAIL);
            }
            
            if ((dwKeyLen / 8) != aPubKey.KeySize)
            {
               RETURN (CRYPT_FAILED, NTE_BAD_LEN);
            }
         }
         else
         {
            GpkObj = FALSE;
            
            // find a file on the card
            hKey = find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC, 0x00, (BYTE)(dwKeyLen / 8), IsExchange, FALSE);
            
            if ((hKey != 0)
               &&(find_gpk_obj_tag_type(hProv, TAG_RSA_PUBLIC,  bKeyType, 0x00, IsExchange, FALSE) == 0)
               &&(find_gpk_obj_tag_type(hProv, TAG_CERTIFICATE, bKeyType, 0x00, FALSE, FALSE) == 0)
               )
            {
               *phKey = hKey;
            }
            else
            {
               RETURN (CRYPT_FAILED, NTE_FAIL);
            }
         }
         
         bSfi = Slot[SlotNb].GpkObject[hKey].FileId;
         
         if (!Read_Priv_Obj(hProv))
            return CRYPT_FAILED;      
         
         if (!VerifyDivPIN(hProv, TRUE))
            return CRYPT_FAILED;      
      
         // load the public key in the card
            // Update record 2 (modulus)
            bSendBuffer[0] = 0x00;                                  //CLA
           bSendBuffer[1] = 0xDC;                                  //INS
           bSendBuffer[2] = 0x02;                                  //P1
           bSendBuffer[3] = (BYTE)(bSfi << 3) + 0x04;              //P2
           bSendBuffer[4] = (BYTE)(TAG_LEN + (dwKeyLen / 8));      //Li
           bSendBuffer[5] = TAG_MODULUS;
           memcpy(&bSendBuffer[6], &pbData[sizeof(BlobHeader) + sizeof(RSAPUBKEY)], dwKeyLen / 8);
           cbSendLength = 5 + bSendBuffer[4];
           
           cbRecvLength = sizeof(bRecvBuffer);
           lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                                 cbSendLength, 0, bRecvBuffer, &cbRecvLength );
           
           if(SCARDPROBLEM(lRet, 0x9000, 0x00))
           {
              RETURN (CRYPT_FAILED, NTE_FAIL);
           }
           
           // Update record 3 (public exponent)
           bSendBuffer[0] = 0x00;                                  //CLA
           bSendBuffer[1] = 0xDC;                                  //INS
           bSendBuffer[2] = 0x03;                                  //P1
           bSendBuffer[3] = (BYTE)(bSfi << 3) + 0x04;              //P2
           bSendBuffer[4] = (BYTE)(TAG_LEN + PUB_EXP_LEN);         //Li
           bSendBuffer[5] = TAG_PUB_EXP;
           memcpy(&bSendBuffer[6], &pbData[sizeof(BlobHeader) + (2 * sizeof(DWORD))], PUB_EXP_LEN);
           cbSendLength = 5 + bSendBuffer[4];
           
           cbRecvLength = sizeof(bRecvBuffer);
           lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                                 cbSendLength, 0, bRecvBuffer, &cbRecvLength );
           
           if(SCARDPROBLEM(lRet, 0x9000, 0x00))
           {
              RETURN (CRYPT_FAILED, NTE_FAIL);
           }
           
           // load the private key in the card
           if (dwKeyLen == 512)
           {
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16 * 5),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8)],
                 168
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
           }
           else if (dwKeyLen == 1024)
           {
              // PRIME 1 CRT part
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8)],
                 72
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
              
              // PRIME 2 CRT part
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8) + 72],
                 72
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
              
              // COEFFICIENT CRT part
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8) + 144],
                 72
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
              
              // EXPONENT 1 CRT part
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8) + 216],
                 72
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
              
              // EXPONENT 2 CRT part
              if (!LoadPrivateKey(ProvCont[hProv].hCard,
                 bSfi,
                 (WORD)(dwKeyLen / 16),
                 &pbData[sizeof(BlobHeader)+ sizeof(RSAPUBKEY) + (dwKeyLen/8) + 288],
                 72
                 )
                 )
              {
                 RETURN (CRYPT_FAILED, NTE_FAIL);
              }
           }
           else
           {
              RETURN (CRYPT_FAILED, NTE_BAD_LEN);
           }
           
           if (!GpkObj)
           {
              hPrivKey = find_gpk_obj_tag_file(hProv,   TAG_RSA_PRIVATE, Slot[SlotNb].GpkObject[hKey].FileId, TRUE);
              
              if ( hPrivKey == 0 )
              {
                 RETURN (CRYPT_FAILED, NTE_SIGNATURE_FILE_BAD);
              }
              
              Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
              if (IsNull(Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue))
              {
                 RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
              }
              
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEY_TYPE].pValue = (BYTE*)GMEM_Alloc(1);
              if (IsNull(Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEY_TYPE].pValue))
              {
                 GMEM_Free(Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue);
                 RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
              }
              
              Slot[SlotNb].GpkObject[hKey].IsCreated                          = TRUE;
              Slot[SlotNb].GpkObject[hKey].Flags                              = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_KEY_TYPE;
              Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len            = 1;
              Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0]      = bKeyType;
              Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].bReal          = TRUE;
              
              /* Set Flags of automatic fields for PKCS#11 compatibility           */
              Slot[SlotNb].GpkObject[hKey].Flags                              = Slot[SlotNb].GpkObject[hKey].Flags | FLAG_ID;
              Slot[SlotNb].GpkObject[hKey].Field[POS_ID].Len                  = 0;
              Slot[SlotNb].GpkObject[hKey].Field[POS_ID].bReal                = FALSE;
              
              Slot[SlotNb].GpkObject[hPrivKey].IsCreated                      = TRUE;
              Slot[SlotNb].GpkObject[hPrivKey].Flags                          = Slot[SlotNb].GpkObject[hPrivKey].Flags | FLAG_KEY_TYPE;
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEY_TYPE].Len        = 1;
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEY_TYPE].pValue[0]  = bKeyType;
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEY_TYPE].bReal      = TRUE;
              
              /* Set Flags of automatic fields for PKCS#11 compatibility           */
              Slot[SlotNb].GpkObject[hPrivKey].Flags                          = Slot[SlotNb].GpkObject[hPrivKey].Flags | FLAG_ID;
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_ID].Len              = 0;
              Slot[SlotNb].GpkObject[hPrivKey].Field[POS_ID].bReal            = FALSE;
              
              if (!ProvCont[hProv].bLegacyKeyset)
              {
                 Slot[SlotNb].GpkObject[hKey].Flags                          |= FLAG_KEYSET;
                 Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].Len           = 1;
                 Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue        = (BYTE*)GMEM_Alloc(1);
                 if(IsNull(Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue))
                 {
                     RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
                 }
                 Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].pValue[0]     = ProvCont[hProv].keysetID;
                 Slot[SlotNb].GpkObject[hKey].Field[POS_KEYSET].bReal         = TRUE;
                 
                 Slot[SlotNb].GpkObject[hPrivKey].Flags                      |= FLAG_KEYSET;
                 Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEYSET].Len       = 1;
                 Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
                 if(IsNull(Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEYSET].pValue))
                 {
                     RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
                 }
                 Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
                 Slot[SlotNb].GpkObject[hPrivKey].Field[POS_KEYSET].bReal     = TRUE;
              }
              
              // set the file containing the key to USE, add "- GPK_FIRST_KEY" here, version 2.00.002
              Slot[SlotNb].UseFile[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY] = TRUE;
              
              pbBuff1 = (BYTE*)GMEM_Alloc (MAX_GPK_PUBLIC);
              if (IsNull(pbBuff1))
              {
                 RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
              }
              
              dwBuff1Len = MAX_GPK_PUBLIC;
              if (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, FALSE))
              {
                 lRet = GetLastError();
                 GMEM_Free (pbBuff1);
                 RETURN (CRYPT_FAILED, lRet);
              }
              
              if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, FALSE))
              {
                 lRet = GetLastError();
                 GMEM_Free (pbBuff1);
                 RETURN (CRYPT_FAILED, lRet);
              }
              
              GMEM_Free (pbBuff1);
              
              pbBuff1 = (BYTE*)GMEM_Alloc (MAX_GPK_PRIVATE);
              if (IsNull(pbBuff1))
              {
                 RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
              }
              
              dwBuff1Len = MAX_GPK_PRIVATE;
              if (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, TRUE))
              {
                 lRet = GetLastError();
                 GMEM_Free (pbBuff1);
                 RETURN (CRYPT_FAILED, lRet);
              }
              
              if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, TRUE))
              {
                 lRet = GetLastError();
                 GMEM_Free (pbBuff1);
                 RETURN (CRYPT_FAILED, lRet);
              }
              
              GMEM_Free (pbBuff1);
              
              // copy Gpk Key in Microsoft RSA base Module
              if (!copy_gpk_key(hProv, *phKey, bKeyType))
                  return CRYPT_FAILED;
         }
         break;
      }
      // - [FP]
      
   case SYMMETRICWRAPKEYBLOB:
      {
         hTmpKey = find_tmp_free();
         if (hTmpKey == 0)
         {
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         // find the handle of imported key 
         HCRYPTKEY   hEncKey;
   
         if ((hPubKey <= MAX_GPK_OBJ) || (!key_exist(hPubKey-MAX_GPK_OBJ, hProv)))
         {
              RETURN (CRYPT_FAILED, NTE_BAD_KEY);
         }
         else
         {
              hEncKey = TmpObject[hPubKey-MAX_GPK_OBJ].hKeyBase;
         }
   
         /* import Session Key in Microsoft Base Module                           */
         CryptResp = CryptImportKey(hProvBase,
            pbData,
            dwDataLen,
            hEncKey,
            dwFlags,
            &(TmpObject[hTmpKey].hKeyBase));
         
         if (!CryptResp)
            return CRYPT_FAILED;      
         
         TmpObject[hTmpKey].hProv = hProv;
         
         *phKey = hTmpKey+MAX_GPK_OBJ;
      }
      break;
      
    default:
       {
          RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
       }
    }
    
    RETURN (CRYPT_SUCCEED, 0);
}

/*
-  CPSetKeyParam
-
*  Purpose:
*                Allows applications to customize various aspects of the
*                operations of a key
*
*  Parameters:
*               IN      hProv   -  Handle to a CSP
*               IN      hKey    -  Handle to a key
*               IN      dwParam -  Parameter number
*               IN      pbData  -  Pointer to data
*               IN      dwFlags -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPSetKeyParam(IN HCRYPTPROV hProv,
                            IN HCRYPTKEY  hKey,
                            IN DWORD      dwParam,
                            IN CONST BYTE      *pbData,
                            IN DWORD      dwFlags
                            )
{
   BOOL    bNew;
   BOOL    WriteCert;
   BOOL    CryptResp;
   BYTE    hCert;
   BYTE    KeyType;
   BYTE    hPrivKey;
   BYTE    *pbLabel;
   BYTE    *pbBuff1 = 0, *pbBuff2 = 0;
   WORD    wLabelLen, i;
   DWORD   lRet,
      dwBuff1Len,
      dwBuff2Len,
      SlotNb;
   GPK_OBJ TmpCert, TmpPrivKey;
   // + NK 07.02.2001
   PINCACHE_PINS Pins;
   DWORD dwPinLength;
   // -NK
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   /* Resident Key                                                            */
   if (hKey == 0)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   else if (hKey <= MAX_GPK_OBJ)
   {
      if (ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT)
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if ((!Slot[SlotNb].GpkObject[hKey].IsCreated)  ||
         ( Slot[SlotNb].GpkObject[hKey].FileId == 0))
      {
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }

      switch (dwParam)
      {
      case KP_ADMIN_PIN:
         RETURN(CRYPT_FAILED, E_NOTIMPL);
         break;
         
      case KP_KEYEXCHANGE_PIN:
      case KP_SIGNATURE_PIN:
         // Slot[SlotNb].ClearPin();
         // Slot[SlotNb].SetPin( (char*)pbData );
         PopulatePins( &Pins, (BYTE *)pbData, strlen( (char*)pbData ), NULL, 0 );

         CallbackData sCallbackData;
         sCallbackData.hProv = hProv;
         sCallbackData.IsCoherent = TRUE;

         if ( (lRet = Add_MSPinCache( &(Slot[SlotNb].hPinCacheHandle),
                                      &Pins, 
                                      Callback_VerifyChangePin, 
                                      (void*)&sCallbackData )) != ERROR_SUCCESS )
         {
            RETURN (CRYPT_FAILED, lRet);
         }
         break;
         
      case KP_CERTIFICATE:
         if (!Read_Priv_Obj(hProv))
            return CRYPT_FAILED;

         // + NK 06.02.2001 
         // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))

         lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                                  NULL, 
                                  &dwPinLength );

         if ( (lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY) )
            RETURN (CRYPT_FAILED, lRet);
         
         if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
         // - NK
         {
            RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
         }
         
         // Supports only X509 certificats
         
         if ((IsNull(pbData)) || (pbData[0] != 0x30) ||(pbData[1] != 0x82))
         {
            RETURN (CRYPT_FAILED, NTE_BAD_DATA);
         }
         
         /* Store Certificate value                                        */
         /* Try to found existing certificate                              */
         KeyType = Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue[0];
         hCert = find_gpk_obj_tag_type(hProv,
            TAG_CERTIFICATE,
            KeyType,
            0x00,
            FALSE,
            FALSE);
         
         /* If not found create new object                                 */
         bNew = FALSE;
         if (hCert == 0)
         {
            if (Slot[SlotNb].NbGpkObject >= MAX_GPK_OBJ)
            {
               RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
            }
            Slot[SlotNb].NbGpkObject++;
            
            hCert = Slot[SlotNb].NbGpkObject;
            bNew = TRUE;
         }
         else
         {
            DialogBox(g_hInstRes, TEXT("CONTDIALOG"), GetAppWindow(), ContDlgProc);
            if (ContainerStatus == ABORT_OPERATION)
            {
               RETURN (CRYPT_FAILED, SCARD_W_CANCELLED_BY_USER);
            }
         }
         
         /* Search associated private RSA key part                         */
         if (KeyType == AT_KEYEXCHANGE)
         {
            hPrivKey = find_gpk_obj_tag_type(hProv,
               TAG_RSA_PRIVATE,
               KeyType,
               0x00,
               TRUE,  // Exchange key
               TRUE
               );
         }
         else
         {
            hPrivKey = find_gpk_obj_tag_type(hProv,
               TAG_RSA_PRIVATE,
               KeyType,
               0x00,
               FALSE, // Signature key
               TRUE
               );
         }
         
         TmpCert = Slot[SlotNb].GpkObject[hCert];
         
         for (i = 0; i < MAX_FIELD; i++)
         {
            Slot[SlotNb].GpkObject[hCert].Field[i].bReal = TRUE;
         }
         
         Slot[SlotNb].GpkObject[hCert].Tag       = TAG_CERTIFICATE;
         Slot[SlotNb].GpkObject[hCert].Flags     = FLAG_VALUE | FLAG_KEY_TYPE | FLAG_LABEL |
            FLAG_SUBJECT | FLAG_SERIAL_NUMBER |
            FLAG_ISSUER | FLAG_ID | FLAG_MODIFIABLE;
         if (bNew)
         {
            Slot[SlotNb].GpkObject[hCert].ObjId = Slot[SlotNb].NbGpkObject-1;
         }
         Slot[SlotNb].GpkObject[hCert].FileId               = Slot[SlotNb].GpkObject[hKey].FileId;
         Slot[SlotNb].GpkObject[hCert].PubKey               = Slot[SlotNb].GpkObject[hKey].PubKey;
         Slot[SlotNb].GpkObject[hCert].IsCreated            = TRUE;
         Slot[SlotNb].GpkObject[hCert].IsPrivate            = FALSE;
         Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len = (pbData[2] * 256) + pbData[3] + 4;
         
         // TT 12/08/99: Keyset ID
         if (!ProvCont[hProv].bLegacyKeyset)
         {
            Slot[SlotNb].GpkObject[hCert].Flags |= FLAG_KEYSET;
            Slot[SlotNb].GpkObject[hCert].Field[POS_KEYSET].Len       = 1;
            Slot[SlotNb].GpkObject[hCert].Field[POS_KEYSET].pValue    = (BYTE*)GMEM_Alloc(1);
            if(IsNull(Slot[SlotNb].GpkObject[hCert].Field[POS_KEYSET].pValue))
            {
                RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
            }
            Slot[SlotNb].GpkObject[hCert].Field[POS_KEYSET].pValue[0] = ProvCont[hProv].keysetID;
            Slot[SlotNb].GpkObject[hCert].Field[POS_KEYSET].bReal     = TRUE;
         }
         
         // TT: END
         
         //            if (IsNotNull(GpkObject[hCert].Field[POS_VALUE].pValue))
         //            {
         //               This will be free later with TmpCert
         //            }
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue =
            (BYTE*)GMEM_Alloc(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len);
         
         if (IsNull(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue))
         {
            Slot[SlotNb].GpkObject[hCert] = TmpCert;
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         memcpy(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue,
            pbData,
            Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len
            );
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].bReal = TRUE;
         
         /* Type = Type of associated key                                  */
         Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].Len =
            Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len;
         
         //            if (IsNotNull(GpkObject[hCert].Field[POS_KEY_TYPE].pValue))
         //            {
         //               This will be free later with TmpCert
         //            }
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue =
            (BYTE*)GMEM_Alloc(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].Len);
         
         if (IsNull(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue))
         {
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
            Slot[SlotNb].GpkObject[hCert] = TmpCert;
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         memcpy(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue,
            Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].pValue,
            Slot[SlotNb].GpkObject[hKey].Field[POS_KEY_TYPE].Len
            );
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].bReal = TRUE;
         
         /* Derive Label from certificate value for PKCS#11 compatibility  */
         
         if (MakeLabel( Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue,
                        Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len,
                        0, &wLabelLen )  == RV_SUCCESS)
         {
            pbLabel = (BYTE*)GMEM_Alloc(wLabelLen);
            
            if (IsNull(pbLabel))
            {
               GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue);
               GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
               Slot[SlotNb].GpkObject[hCert] = TmpCert;
               --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
               RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
            }
            
            MakeLabel(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue,
               Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].Len,
               pbLabel,
               &wLabelLen
               );
         }
         else
         {
            wLabelLen = 17;
            pbLabel = (BYTE*)GMEM_Alloc(wLabelLen);
            
            if (IsNull(pbLabel))
            {
               GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue);
               GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
               Slot[SlotNb].GpkObject[hCert] = TmpCert;
               --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
               RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
            }
            
            memcpy(pbLabel, "User's Digital ID", 17);
         }
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].Len = wLabelLen;
         
         //          if (IsNotNull(GpkObject[hCert].Field[POS_LABEL].pValue))
         //           {
         //              This will be free later with TmpCert
         //           }
         
         Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].pValue = (BYTE*)GMEM_Alloc(wLabelLen);
         
         if (IsNull(Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].pValue))
         {
            GMEM_Free(pbLabel);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
            Slot[SlotNb].GpkObject[hCert] = TmpCert;
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         memcpy(Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].pValue,
            pbLabel,
            wLabelLen
            );
         Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].bReal = TRUE;
         
         TmpPrivKey = Slot[SlotNb].GpkObject[hPrivKey];
         
         Slot[SlotNb].GpkObject[hPrivKey].Flags = Slot[SlotNb].GpkObject[hPrivKey].Flags | FLAG_LABEL;
         Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].Len = wLabelLen;
         
         //          if (IsNotNull(GpkObject[hPrivKey].Field[POS_LABEL].pValue))
         //          {
         //             This will be free later with TmpPrivKey
         //          }
         
         Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].pValue = (BYTE*)GMEM_Alloc(wLabelLen);
         
         if (IsNull(Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].pValue))
         {
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].pValue);
            GMEM_Free(pbLabel);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
            
            Slot[SlotNb].GpkObject[hPrivKey] = TmpPrivKey;
            Slot[SlotNb].GpkObject[hCert] = TmpCert;
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
         }
         
         memcpy(Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].pValue,
            pbLabel,
            wLabelLen
            );
         Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].bReal = TRUE;
         GMEM_Free(pbLabel);
         
         /* Set automatic fields for PKCS#11 compatibility                 */
         Slot[SlotNb].GpkObject[hCert].Field[POS_ID].Len              = 0;
         Slot[SlotNb].GpkObject[hCert].Field[POS_ID].bReal            = FALSE;
         Slot[SlotNb].GpkObject[hCert].Field[POS_SUBJECT].Len         = 0;
         Slot[SlotNb].GpkObject[hCert].Field[POS_SUBJECT].bReal       = FALSE;
         Slot[SlotNb].GpkObject[hCert].Field[POS_ISSUER].Len          = 0;
         Slot[SlotNb].GpkObject[hCert].Field[POS_ISSUER].bReal        = FALSE;
         Slot[SlotNb].GpkObject[hCert].Field[POS_SERIAL_NUMBER].Len   = 0;
         Slot[SlotNb].GpkObject[hCert].Field[POS_SERIAL_NUMBER].bReal = FALSE;
         
         /* Set automatic fields of assocoiated key for PKCS#11            */
         Slot[SlotNb].GpkObject[hPrivKey].Flags = Slot[SlotNb].GpkObject[hPrivKey].Flags | FLAG_SUBJECT;
         Slot[SlotNb].GpkObject[hPrivKey].Field[POS_SUBJECT].Len   = 0;
         Slot[SlotNb].GpkObject[hPrivKey].Field[POS_SUBJECT].bReal = FALSE;
         
         CspFlags = ProvCont[hProv].Flags;
         
         
         WriteCert = TRUE;
         pbBuff1 = (BYTE*)GMEM_Alloc (MAX_GPK_PUBLIC);
         
         if (IsNull(pbBuff1))
         {
            WriteCert = FALSE;
         }
         
         dwBuff1Len = MAX_GPK_PUBLIC;
         if (WriteCert && (!prepare_write_gpk_objects (hProv, pbBuff1, &dwBuff1Len, FALSE)))
         {
            WriteCert = FALSE;
            GMEM_Free (pbBuff1);
         }
         
         if (WriteCert)
         {
            pbBuff2 = (BYTE*)GMEM_Alloc (MAX_GPK_PRIVATE);
            if (IsNull(pbBuff2))
            {
               WriteCert = FALSE;
               GMEM_Free (pbBuff1);
            }
         }
         
         dwBuff2Len = MAX_GPK_PRIVATE;
         if (WriteCert && (!prepare_write_gpk_objects (hProv, pbBuff2, &dwBuff2Len, TRUE)))
         {
            WriteCert = FALSE;
            GMEM_Free (pbBuff1);
            GMEM_Free (pbBuff2);
         }
         
         if (!WriteCert)
         {
            // restore the info. the new certificate is too large
            
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_VALUE].pValue);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_KEY_TYPE].pValue);
            GMEM_Free(Slot[SlotNb].GpkObject[hCert].Field[POS_LABEL].pValue);
            GMEM_Free(Slot[SlotNb].GpkObject[hPrivKey].Field[POS_LABEL].pValue);
            
            Slot[SlotNb].GpkObject[hCert]    = TmpCert;
            Slot[SlotNb].GpkObject[hPrivKey] = TmpPrivKey;
            
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, SCARD_E_WRITE_TOO_MANY);
         }
         
         if (IsNotNull(TmpCert.Field[POS_VALUE].pValue))
         {
            GMEM_Free(TmpCert.Field[POS_VALUE].pValue);
         }
         
         if (IsNotNull(TmpCert.Field[POS_KEY_TYPE].pValue))
         {
            GMEM_Free(TmpCert.Field[POS_KEY_TYPE].pValue);
         }
         
         if (IsNotNull(TmpCert.Field[POS_LABEL].pValue))
         {
            GMEM_Free(TmpCert.Field[POS_LABEL].pValue);
         }
         
         if (IsNotNull(TmpPrivKey.Field[POS_LABEL].pValue))
         {
            GMEM_Free(TmpPrivKey.Field[POS_LABEL].pValue);
         }
         
         if (!write_gpk_objects(hProv, pbBuff1, dwBuff1Len, FALSE, FALSE))
         {
            lRet = GetLastError();
            GMEM_Free (pbBuff1);
            GMEM_Free (pbBuff2);
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, lRet);
         }
         
         if (!write_gpk_objects(hProv, pbBuff2, dwBuff2Len, FALSE, TRUE))
         {
            lRet = GetLastError();
            Select_MF(hProv);
            GMEM_Free (pbBuff1);
            GMEM_Free (pbBuff2);
            --Slot[SlotNb].NbGpkObject;  // Bug #1675/1676
            RETURN (CRYPT_FAILED, lRet);
         }
         
         GMEM_Free (pbBuff1);
         GMEM_Free (pbBuff2);
         
         break;
         
        default:
           RETURN (CRYPT_FAILED, NTE_BAD_TYPE);
        }
        
    }
    
    /* Session Key                                                             */
    else if (key_exist(hKey-MAX_GPK_OBJ, hProv))
    {
       /* Set Key Parameter in Microsoft RSA Base Module                    */
       CryptResp = CryptSetKeyParam(TmpObject[hKey-MAX_GPK_OBJ].hKeyBase,
          dwParam,
          pbData,
          dwFlags
          );
       if (!CryptResp)
         return CRYPT_FAILED;      
    }
    /* Bad Key                                                                 */
    else
    {
       RETURN (CRYPT_FAILED, NTE_BAD_KEY);
    }
    
    RETURN (CRYPT_SUCCEED, 0);
}

/*******************************************************************************
Data Encryption Functions
*******************************************************************************/

/*
-  CPDecrypt
-
*  Purpose:
*                Decrypt data
*
*
*  Parameters:
*               IN  hProv         -  Handle to the CSP user
*               IN  hKey          -  Handle to the key
*               IN  hHash         -  Optional handle to a hash
*               IN  Final         -  Boolean indicating if this is the final
*                                    block of ciphertext
*               IN  dwFlags       -  Flags values
*               IN OUT pbData     -  Data to be decrypted
*               IN OUT pdwDataLen -  Pointer to the length of the data to be
*                                    decrypted
*
*  Returns:
*/
BOOL WINAPI MyCPDecrypt(IN HCRYPTPROV hProv,
                        IN HCRYPTKEY  hKey,
                        IN HCRYPTHASH hHash,
                        IN BOOL       Final,
                        IN DWORD      dwFlags,
                        IN OUT BYTE  *pbData,
                        IN OUT DWORD *pdwDataLen
                        )
                        
{
   BOOL        CryptResp;
   HCRYPTKEY   hDecKey;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if ((hKey <= MAX_GPK_OBJ) || (!key_exist(hKey-MAX_GPK_OBJ, hProv)))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   else
   {
      hDecKey = TmpObject[hKey-MAX_GPK_OBJ].hKeyBase;
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   CryptResp = CryptDecrypt(hDecKey,
      hHashGpk[hHash].hHashBase,
      Final,
      dwFlags,
      pbData,
      pdwDataLen
      );
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*
-  CPEncrypt
-
*  Purpose:
*                Encrypt data
*
*
*  Parameters:
*               IN  hProv         -  Handle to the CSP user
*               IN  hKey          -  Handle to the key
*               IN  hHash         -  Optional handle to a hash
*               IN  Final         -  Boolean indicating if this is the final
*                                    block of plaintext
*               IN  dwFlags       -  Flags values
*               IN OUT pbData     -  Data to be encrypted
*               IN OUT pdwDataLen -  Pointer to the length of the data to be
*                                    encrypted
*               IN dwBufLen       -  Size of Data buffer
*
*  Returns:
*/
BOOL WINAPI MyCPEncrypt(IN HCRYPTPROV hProv,
                        IN HCRYPTKEY  hKey,
                        IN HCRYPTHASH hHash,
                        IN BOOL       Final,
                        IN DWORD      dwFlags,
                        IN OUT BYTE  *pbData,
                        IN OUT DWORD *pdwDataLen,
                        IN DWORD      dwBufLen
                        )
{
   BOOL        CryptResp;
   HCRYPTKEY   hEncKey;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if ((hKey <= MAX_GPK_OBJ) || (!key_exist(hKey-MAX_GPK_OBJ, hProv)))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   else
   {
      hEncKey = TmpObject[hKey-MAX_GPK_OBJ].hKeyBase;
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   CryptResp = CryptEncrypt(hEncKey,
      hHashGpk[hHash].hHashBase,
      Final,
      dwFlags,
      pbData,
      pdwDataLen,
      dwBufLen
      );
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*******************************************************************************
Hashing and Digital Signature Functions
*******************************************************************************/

/*
-  MyCPCreateHash
-
*  Purpose:
*                initate the hashing of a stream of data
*
*
*  Parameters:
*               IN  hUID    -  Handle to the user identifcation
*               IN  Algid   -  Algorithm identifier of the hash algorithm
*                              to be used
*               IN  hKey    -  Optional key for MAC algorithms
*               IN  dwFlags -  Flags values
*               OUT pHash   -  Handle to hash object
*
*  Returns:
*/
BOOL WINAPI MyCPCreateHash(IN  HCRYPTPROV  hProv,
                           IN  ALG_ID      Algid,
                           IN  HCRYPTKEY   hKey,
                           IN  DWORD       dwFlags,
                           OUT HCRYPTHASH *phHash
                           )
{
   BOOL        CryptResp;
   HCRYPTKEY   hKeyMac;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   *phHash = find_hash_free();
   if ((*phHash) == 0)
   {
      RETURN (CRYPT_FAILED, NTE_NO_MEMORY);
   }
   
   hKeyMac = 0;
   if ((Algid == CALG_MAC) || (Algid == CALG_HMAC) )
   {
      if ((hKey <= MAX_GPK_OBJ) || (!key_exist(hKey - MAX_GPK_OBJ, hProv)))
      {
         *phHash = 0;
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }
      else
      {
         hKeyMac = TmpObject[hKey-MAX_GPK_OBJ].hKeyBase;
      }
   }
   
   CryptResp = CryptCreateHash(hProvBase,
      Algid,
      hKeyMac,
      dwFlags,
      &(hHashGpk[*phHash].hHashBase)
      );
   if (!CryptResp)
   {
      *phHash = 0;
      return CRYPT_FAILED;      
   }
   
   hHashGpk[*phHash].hProv = hProv;
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPDestroyHash
-
*  Purpose:
*                Destroy the hash object
*
*
*  Parameters:
*               IN  hProv     -  Handle to the user identifcation
*               IN  hHash     -  Handle to hash object
*
*  Returns:
*/
BOOL WINAPI MyCPDestroyHash(IN HCRYPTPROV hProv,
                            IN HCRYPTHASH hHash
                            )
{
  BOOL        CryptResp;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   /* Destroy Microsoft RSA Base Hash                                         */
   CryptResp = CryptDestroyHash(hHashGpk[hHash].hHashBase);
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   hHashGpk[hHash].hHashBase  = 0;
   hHashGpk[hHash].hProv      = 0;
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPGetHashParam
-
*  Purpose:
*                Allows applications to get various aspects of the
*                operations of a hash
*
*  Parameters:
*               IN      hProv      -  Handle to a CSP
*               IN      hHash      -  Handle to a hash
*               IN      dwParam    -  Parameter number
*               IN      pbData     -  Pointer to data
*               IN      pdwDataLen -  Length of parameter data
*               IN      dwFlags    -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPGetHashParam(IN HCRYPTPROV hProv,
                             IN HCRYPTHASH hHash,
                             IN DWORD      dwParam,
                             IN BYTE      *pbData,
                             IN DWORD     *pdwDataLen,
                             IN DWORD      dwFlags
                             )
{
   BOOL        CryptResp;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   CryptResp = CryptGetHashParam(hHashGpk[hHash].hHashBase,
      dwParam,
      pbData,
      pdwDataLen,
      dwFlags
      );
   if (!CryptResp)
      return CRYPT_FAILED;      

   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPHashData
-
*  Purpose:
*                Compute the cryptograghic hash on a stream of data
*
*
*  Parameters:
*               IN  hProv     -  Handle to the user identifcation
*               IN  hHash     -  Handle to hash object
*               IN  pbData    -  Pointer to data to be hashed
*               IN  dwDataLen -  Length of the data to be hashed
*               IN  dwFlags   -  Flags values
*               IN  pdwMaxLen -  Maximum length of the data stream the CSP
*                                module may handle
*
*  Returns:
*/
BOOL WINAPI MyCPHashData(IN HCRYPTPROV  hProv,
                         IN HCRYPTHASH  hHash,
                         IN CONST BYTE *pbData,
                         IN DWORD       dwDataLen,
                         IN DWORD       dwFlags
                         )
{
   BOOL        CryptResp;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   /* Hash Data with Microsoft RSA Base                                       */
   CryptResp = CryptHashData(hHashGpk[hHash].hHashBase,
      pbData,
      dwDataLen,
      dwFlags);
   
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  CPHashSessionKey
-
*  Purpose:
*                Compute the cryptograghic hash on a key object.
*
*
*  Parameters:
*               IN  hProv     -  Handle to the user identifcation
*               IN  hHash     -  Handle to hash object
*               IN  hKey      -  Handle to a key object
*               IN  dwFlags   -  Flags values
*
*  Returns:
*               CRYPT_FAILED
*               CRYPT_SUCCEED
*/
BOOL WINAPI MyCPHashSessionKey(IN HCRYPTPROV hProv,
                               IN HCRYPTHASH hHash,
                               IN HCRYPTKEY  hKey,
                               IN DWORD      dwFlags
                               )
{
   BOOL        CryptResp;
   HCRYPTKEY   hTmpKey;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   if (hKey <= MAX_GPK_OBJ)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   
   hTmpKey = hKey - MAX_GPK_OBJ;
   
   if (!key_exist(hTmpKey, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   
   /* Hash Data with Microsoft RSA Base                                       */
   CryptResp = CryptHashSessionKey(hHashGpk[hHash].hHashBase,
      TmpObject[hTmpKey].hKeyBase,
      dwFlags
      );
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPSetHashParam
-
*  Purpose:
*                Allows applications to customize various aspects of the
*                operations of a hash
*
*  Parameters:
*               IN      hProv   -  Handle to a CSP
*               IN      hHash   -  Handle to a hash
*               IN      dwParam -  Parameter number
*               IN      pbData  -  Pointer to data
*               IN      dwFlags -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPSetHashParam(IN HCRYPTPROV hProv,
                             IN HCRYPTHASH hHash,
                             IN DWORD      dwParam,
                             IN CONST BYTE      *pbData,
                             IN DWORD      dwFlags
                             )
{
   BOOL        CryptResp;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   /* Set Hash parameter with Microsoft RSA Base                              */
   CryptResp = CryptSetHashParam(hHashGpk[hHash].hHashBase,
      dwParam,
      pbData,
      dwFlags
      );
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   RETURN (CRYPT_SUCCEED, 0);
}


/*
-  MyCPSignHash
-
*  Purpose:
*                Create a digital signature from a hash
*
*
*  Parameters:
*               IN  hProv        -  Handle to the user identifcation
*               IN  hHash        -  Handle to hash object
*               IN  Algid        -  Algorithm identifier of the signature
*                                   algorithm to be used
*               IN  sDescription -  Description of data to be signed
*               IN  dwFlags      -  Flags values
*               OUT pbSignture   -  Pointer to signature data
*               OUT dwHashLen    -  Pointer to the len of the signature data
*
*  Returns:
*/
BOOL WINAPI MyCPSignHash(IN  HCRYPTPROV hProv,
                         IN  HCRYPTHASH hHash,
                         IN  DWORD      dwKeySpec,
                         IN  LPCWSTR    sDescription,
                         IN  DWORD      dwFlags,
                         OUT BYTE      *pbSignature,
                         OUT DWORD     *pdwSigLen
                         )
{
   DWORD       lRet;
   DWORD       SlotNb;
   BOOL        CryptResp;
   DWORD       dwLen;
   BYTE        GpkKeySize;
   BYTE        HashMode;
   HCRYPTKEY   hKey;
   BYTE        TmpHashValue[64];
   // + NK 07.02.2001
   DWORD dwPinLength;
   // -NK
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }

   SlotNb = ProvCont[hProv].Slot;
   
   if (dwFlags != 0)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_FLAGS);
   }
   
   // returns same value as aux csp
   if (dwKeySpec != AT_KEYEXCHANGE && dwKeySpec != AT_SIGNATURE)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_ALGID);
   }


   /* sDescription is not supported */
   if (IsNotNullStr(sDescription))
   {
      RETURN(CRYPT_FAILED, ERROR_INVALID_PARAMETER);
   }
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   HashMode = GPKHashMode (hHash);
   if (HashMode == 0x00)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   /* Select Key                                                              */
   CryptResp = MyCPGetUserKey(hProv, dwKeySpec, &hKey);
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   if (!(Slot[SlotNb].GpkObject[hKey].Flags & FLAG_SIGN))
   {
      *pdwSigLen = 0;
      RETURN(CRYPT_FAILED, NTE_BAD_KEY);
   }
   
   GpkKeySize = Slot[SlotNb].GpkPubKeys[Slot[SlotNb].GpkObject[hKey].FileId - GPK_FIRST_KEY].KeySize;
   if (GpkKeySize == 0)
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY);
   }
   
   if (IsNull(pbSignature) || (0 == *pdwSigLen))
   {
      *pdwSigLen = GpkKeySize;
      RETURN (CRYPT_SUCCEED, 0 );
   }
   
   if (GpkKeySize > *pdwSigLen)
   {
      *pdwSigLen = GpkKeySize;
      RETURN (CRYPT_FAILED, ERROR_MORE_DATA);
   }
   
   // + NK 06.02.2001 
   // if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (IsNullStr(Slot[SlotNb].GetPin())))
   lRet = Query_MSPinCache( Slot[SlotNb].hPinCacheHandle,
                            NULL, 
                            &dwPinLength );

   if ( (lRet != ERROR_SUCCESS) && (lRet != ERROR_EMPTY) )
      RETURN (CRYPT_FAILED, lRet);
   
   if ((ProvCont[hProv].Flags & CRYPT_SILENT) && (lRet == ERROR_EMPTY))
   // - NK
   {
      RETURN (CRYPT_FAILED, NTE_SILENT_CONTEXT);
   }

   // Verify the PINs
   if (!PIN_Validation(hProv)) {
     return CRYPT_FAILED;      
   }
   
   if (!VerifyDivPIN(hProv, TRUE))
      return CRYPT_FAILED;      
   
   /* Card Select Context for RSA with specified Hash type */
   bSendBuffer[0] = 0x80;                    //CLA
   bSendBuffer[1] = 0xA6;                    //INS
   bSendBuffer[2] = Slot[SlotNb].GpkObject[hKey].FileId;  //P1
   bSendBuffer[3] = HashMode;                //P2
   cbSendLength   = 4;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_KEY_STATE);
   }
   
   /* Force Calculation of Hash Value                                      */
   dwLen     = sizeof(TmpHashValue);
   CryptResp = CryptGetHashParam(hHashGpk[hHash].hHashBase,
      HP_HASHVAL,
      TmpHashValue,
      &dwLen,
      0);
   
   if (!CryptResp)
      return CRYPT_FAILED;      
   
   r_memcpy(&bSendBuffer[5], TmpHashValue, dwLen);
   /* Send hash Data with only one command                                 */
   bSendBuffer[0] = 0x80;        //CLA
   bSendBuffer[1] = 0xEA;        //INS
   bSendBuffer[2] = 0x00;        //P1
   bSendBuffer[3] = 0x00;        //P2
   bSendBuffer[4] = (BYTE)dwLen; //Li
   cbSendLength = dwLen + 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   
   if (SCARDPROBLEM(lRet,0x9000,0x00))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_SIGNATURE);
   }
   
   /* Get signature                                                           */
   bSendBuffer[0] = 0x80;        //CLA
   bSendBuffer[1] = 0x86;        //INS
   bSendBuffer[2] = 0x00;        //P1
   bSendBuffer[3] = 0x00;        //P2
   bSendBuffer[4] = GpkKeySize;  //Lo
   cbSendLength   = 5;
   
   cbRecvLength = sizeof(bRecvBuffer);
   lRet = SCardTransmit( ProvCont[hProv].hCard, SCARD_PCI_T0, bSendBuffer,
                         cbSendLength, 0, bRecvBuffer, &cbRecvLength );
   if (SCARDPROBLEM(lRet,0x9000,bSendBuffer[4]))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_SIGNATURE);
   }
   
   cbRecvLength = cbRecvLength - 2;
   
   *pdwSigLen = cbRecvLength;
   
   memcpy(pbSignature, bRecvBuffer, cbRecvLength);
   
   RETURN (CRYPT_SUCCEED, 0);
}

/*
-  MyCPVerifySignature
-
*  Purpose:
*                Used to verify a signature against a hash object
*
*
*  Parameters:
*               IN  hProv        -  Handle to the user identifcation
*               IN  hHash        -  Handle to hash object
*               IN  pbSignture   -  Pointer to signature data
*               IN  dwSigLen     -  Length of the signature data
*               IN  hPubKey      -  Handle to the public key for verifying
*                                   the signature
*               IN  Algid        -  Algorithm identifier of the signature
*                                   algorithm to be used
*               IN  sDescription -  Description of data to be signed
*               IN  dwFlags      -  Flags values
*
*  Returns:
*/
BOOL WINAPI MyCPVerifySignature(IN HCRYPTPROV  hProv,
                                IN HCRYPTHASH  hHash,
                                IN CONST BYTE *pbSignature,
                                IN DWORD       dwSigLen,
                                IN HCRYPTKEY   hPubKey,
                                IN LPCWSTR     sDescription,
                                IN DWORD       dwFlags
                                )
{
   DWORD     SlotNb;
   BOOL      CryptResp;
   HCRYPTKEY hTmpKey;
   
   if (!Context_exist(hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_UID);
   }
   
   SlotNb = ProvCont[hProv].Slot;
   
   if (!hash_exist(hHash, hProv))
   {
      RETURN (CRYPT_FAILED, NTE_BAD_HASH);
   }
   
   if (hPubKey <= MAX_GPK_OBJ)
   {
      if ((ProvCont[hProv].Flags & CRYPT_VERIFYCONTEXT) &&
         (ProvCont[hProv].isContNameNullBlank))
      {
         RETURN (CRYPT_FAILED, NTE_PERM);
      }
      
      if (( !Slot[SlotNb].GpkObject[hPubKey].IsCreated) ||
         ( (Slot[SlotNb].GpkObject[hPubKey].Tag != TAG_RSA_PUBLIC ) &&
         (Slot[SlotNb].GpkObject[hPubKey].Tag != TAG_RSA_PRIVATE)    )
         
         )
      {
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }

      HCRYPTKEY hVerKey;
      if ((Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].Len == 0)  ||
          ((Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] != AT_KEYEXCHANGE) &&
           (Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] != AT_SIGNATURE)))
      {
         RETURN(CRYPT_FAILED, NTE_BAD_KEY);
      }

      if (Slot[SlotNb].GpkObject[hPubKey].Field[POS_KEY_TYPE].pValue[0] == AT_KEYEXCHANGE)
      {
         hVerKey = ProvCont[hProv].hRSAKEK;
      }
      else
      {
         hVerKey = ProvCont[hProv].hRSASign;
      }

      CryptResp = CryptVerifySignature(hHashGpk[hHash].hHashBase,
         pbSignature,
         dwSigLen,
         hVerKey, //Slot[SlotNb].GpkObject[hPubKey].hKeyBase,
         (LPCTSTR)sDescription,
         dwFlags);
      if (!CryptResp)
         return CRYPT_FAILED;
   }
   else
   {
      hTmpKey = hPubKey - MAX_GPK_OBJ;
      
      if (!key_exist(hTmpKey, hProv))
      {
         RETURN (CRYPT_FAILED, NTE_BAD_KEY);
      }
      
      /* Verify Signature with Microsoft RSA Base Module */
      CryptResp = CryptVerifySignature(hHashGpk[hHash].hHashBase,
         pbSignature,
         dwSigLen,
         TmpObject[hTmpKey].hKeyBase,
         (LPCTSTR)sDescription,
         dwFlags);
      if (!CryptResp)
         return CRYPT_FAILED;      
   }
   
   RETURN (CRYPT_SUCCEED, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkcsp\gpkgui.h ===
/*******************************************************************************
*           Copyright (C) 1997 Gemplus International   All Rights Reserved      
*
* Name        : GPKGUI.H
*
* Description : GUI used by Cryptographic Service Provider for GPK Card.
*
  Author      : Laurent CASSIER (1.0), Francois Jacques (2.0)

  Compiler    : Microsoft Visual C 6.0

  Host        : IBM PC and compatible machines under Windows 32 bit

* Release     : 2.00.000
*
* Last Modif. : 15/04/99: V2.00.000 - International support, merged PKCS11/CSP UI
*               02/11/97: V1.00.002 - Separate code from GpkCsp Code.
*               27/08/97: V1.00.001 - Begin implementation based on CSP kit.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/

/*------------------------------------------------------------------------------
Name definition:
   _GPKGUI_H is used to avoid multiple inclusion.
------------------------------------------------------------------------------*/
#ifndef _GPKGUI_H
#define _GPKGUI_H

#ifdef __cplusplus
extern "C" {
#endif

/*-----------------------------------------------------------------------------
  Global Variable and Declaration for PIN an Progress DialogBox management
------------------------------------------------------------------------------*/
#define PIN_MAX            (8)
#define PIN_MIN            (4)         // [JMR 02-04]
#define MAX_STRING         MAX_PATH
#define MAX_REAL_KEY       (16)

#define ACCEPT_CONTAINER   (1)
#define ABORT_OPERATION    (2)

extern HINSTANCE g_hInstMod;
extern HINSTANCE g_hInstRes;
extern HWND      g_hMainWnd;

/* PIN DialogBox                                                              */
extern char    szGpkPin[PIN_MAX+2];	   // [JMR 02-04]
extern DWORD   dwGpkPinLen;
extern char    szGpkNewPin[PIN_MAX+2]; // [JMR 02-04]	
extern WORD    wGpkNewPinLen;

extern BOOL    bChangePin;
//extern BOOL    bAdmPin;
extern BOOL    NoDisplay;
extern BOOL    bNewPin;
extern BOOL    bHideChange;
extern BOOL    bUnblockPin;
extern BOOL    bUser;


/* ProgressText DialogBox                                                     */

/* FJ: changed char to TCHAR
extern char    szProgTitle[256];
extern char    szProgText[256];
*/

extern TCHAR   szProgTitle[MAX_STRING];
extern TCHAR   szProgText[MAX_STRING];


extern BOOL    IsProgButtonClick;
extern HWND    hProgressDlg;
extern FARPROC lpProgressDlg;
extern HCURSOR hCursor, hCursor2;

void DisplayMessage( LPTSTR szMsg, LPTSTR szCaption, void* pValue);

/*------------------------------------------------------------------------------
               Functions for PIN (User and SO) Dialog Box Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK PinDlgProc(HWND   hDlg, 
                            UINT   message, 
                            WPARAM wParam, 
                            LPARAM lParam);

//#ifdef _GPKCSP 
/*------------------------------------------------------------------------------
               Functions for Container Dialogue Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK ContDlgProc(HWND   hDlg, 
                             UINT   message, 
                             WPARAM wParam, 
                             LPARAM lParam);
//#endif /* _GPKCSP */

/*------------------------------------------------------------------------------
               Functions for Key Dialog Box Management
------------------------------------------------------------------------------*/
INT_PTR CALLBACK KeyDlgProc (HWND   hDlg,
                             UINT   message,
                             WPARAM wParam,
                             LPARAM lParam);


/*------------------------------------------------------------------------------
               Functions for Progress Dialog Box Management
------------------------------------------------------------------------------*/

/*******************************************************************************
* void Wait (DWORD ulStep,
*            DWORD ulMaxStep,
*            DWORD ulSecond)
*
* Description    : Change Progress Box Text.
*
* Remarks        : Nothing.
*
* In             : ulStep    = Current step number.
*                  ulMaxStep = Maximum step number.
*                  ulSecond  = 
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void Wait(DWORD ulStep,
		  DWORD ulMaxStep,
		  DWORD ulSecond
		  );

/*******************************************************************************/

void ShowProgressWrapper(WORD wKeySize);

/*******************************************************************************/

void ChangeProgressWrapper(DWORD dwTime);

/*******************************************************************************
* void ShowProgress (HWND  hWnd, 
*                    LPTSTR lpstrTitle, 
*                    LPTSTR lpstrText,
*                    LPTSTR lpstrButton
*                   )
*
* Description    : Initialize Progress dialog box CALLBACK.
*
* Remarks        : If lpstrButton is null, then don't display cancel button
*
* In             : hWnd        = Handle of parent window.
*                  lpstrTitle  = Pointer to Title of dialog box.
*                  lpstrText   = Pointer to Text of dialog box.
*                  lpstrButton = Pointer to Text of button.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void ShowProgress (HWND  hWnd, 
                   LPTSTR lpstrTitle, 
                   LPTSTR lpstrText,
                   LPTSTR lpstrButton
                  );


/*******************************************************************************
* void ChangeProgressText (LPTSTR lpstrText)
*
* Description    : Change Progress Box Text.
*
* Remarks        : Nothing.
*
* In             : lpstrText  = Pointer to Text of dialog box.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void ChangeProgressText (LPTSTR lpstrText);

/*******************************************************************************
* void DestroyProgress (void)
*
* Description    : Destroy Progress dialog box CALLBACK.
*
* Remarks        : Nothing.
*
* In             : Nothing.
*
* Out            : Nothing.
*
* Response       : Nothing.
*
*******************************************************************************/
void DestroyProgress (void);

/*******************************************************************************
* INT_PTR     CALLBACK ProgressDlgProc(HWND   hDlg,
*                                      UINT   message,
*                                      WPARAM wParam, 
*                                      LPARAM lParam
*                                     )
* 
* Description : CALLBACK for management of Progess Dialog Box.
*
* Remarks     : Nothing.
*
* In          : hDlg    = Window handle.
*               message = Type of message.
*               wParam  = Word message-specific information.
*               lParam  = Long message-specific information.
*
* Out         : Nothing.
*
* Responses   : If everything is OK :
*                    G_OK
*               If an condition error is raised:
*
*******************************************************************************/
INT_PTR CALLBACK ProgressDlgProc(HWND   hDlg, 
                         UINT   message, 
                         WPARAM wParam,  
                         LPARAM lParam
                        );

/*******************************************************************************
					Functions for setting cursor in wait mode
*******************************************************************************/
void BeginWait(void);
void EndWait(void);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\inc\ac.h ===
/*------------------------------------------------------------------------------
Name definition:
   _AC_H is used to avoid multiple inclusion.
------------------------------------------------------------------------------*/
#ifndef _AC_H
#define _AC_H

#include "compcert.h"

/*------------------------------------------------------------------------------
                        Functions Prototypes definitions
------------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" 
{
#endif


int AcAd8_Encode(BLOC *pInBloc, BLOC *pOutBloc);

int AcAd8_Decode(BLOC *pInBloc, BLOC *pOutBloc);


int AcFx8_Encode(BLOC *pInBloc, BLOC *pOutBloc);

int AcFx8_Decode(BLOC *pInBloc, BLOC *pOutBloc);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\inc\gmem.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright 2000 Gemplus Canada Inc.
//
// Project:
//          Kenny (GPK CSP)
//
// Authors:
//          Thierry Tremblay
//          Francois Paradis
//
// Compiler:
//          Microsoft Visual C++ 6.0 - SP3
//          Platform SDK - January 2000
//
///////////////////////////////////////////////////////////////////////////////////////////

#ifndef KENNY_GMEM_H
#define KENNY_GMEM_H

#include <stdlib.h>



#ifdef __cplusplus
extern "C" 
{
#endif



///////////////////////////////////////////////////////////////////////////////////////////
//
// Heap memory management
//
///////////////////////////////////////////////////////////////////////////////////////////

void* GMEM_Alloc( size_t size );
void* GMEM_ReAlloc( void* pMemory, size_t newSize );
void  GMEM_Free( void* pMemory );



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\gpkrsrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gpkrsrc.rc
//
#define IDS_GPKUI_USERPIN               1000
#define IDS_GPKUI_SOPIN                 1001
#define IDS_GPKUI_NEWUSERPIN            1002
#define IDS_GPKUI_NEWSOPIN              1003
#define IDS_GPKUI_PINLOCKED             1004
#define IDS_GPKUI_UNBLOCKCODE           1005
#define IDS_GPKUI_CONFIRMNEWUSERPIN     1006
#define IDS_GPKUI_CONFIRMNEWSOPIN       1007
#define IDS_GPKUI_WRONGCONFIRM          1008
#define IDS_GPKUI_CHANGEPIN             1009
#define IDS_GPKUI_PINWRONGLENGTH        1010
#define IDS_GPKUI_CHOOSEKEYLENGTH       1011
#define IDS_GPKUI_CARDLOCKED            1013
#define IDS_GPKUI_BADPINCODE            1014
#define IDS_GPKUI_NBRTRYLEFT            1015
#define IDS_GPKUI_CONTINUE              1016
#define IDS_GPKUI_OPENDLGTITLE          1017
#define IDS_CAPTION_CHANGEPIN           1018
#define IDS_CAPTION_YES                 1019
#define IDS_CAPTION_NO                  1020
#define IDS_CAPTION_OK                  1021
#define IDS_CAPTION_CANCEL              1022
#define IDS_CAPTION_ABORT               1023
#define IDS_GPKUI_TITLE                 1030
#define IDC_CONTDLGTXT                  1049
#define IDC_PINDLGTXT                   1050
#define IDC_PINDLGTXT1                  1051
#define IDS_GPK4K_PROGRESSTITLE         1100
#define IDS_GPK4K_PROGRESSPERCENT       1101
#define IDS_GPK4K_DAMAGEDCARD           1102
#define IDS_GPK4K_EXTDSKNOTFOUND        1103
#define IDS_GPK4K_KEYGEN                1104
#define IDS_GPK4K_UNKNOWNTOKEN          1105
#define IDS_GPK4K_EXTDSKUNABLE          1106
#define IDS_GPK4K_PROGRESSTEXT          1107
#define IDS_GPK4K_PROGRESSTIME          1108
#define IDC_PIN                         10001
#define IDC_PIN1                        10003
#define IDC_PROGDLGTXT                  10004
#define IDC_KEYDLGTXT                   10008
#define IDC_KEYLENGTH1                  10009
#define IDC_KEYLENGTH                   10010
#define IDB_CHANGE                      10012
#define IDB_KEYLENGTH1                  10015
#define IDB_KEYLENGTH                   10016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\pincache\pincache.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    pincache.h
                                                
Abstract:

    Pin Caching Library for Smart Card CSP's

Author:

    Dan Griffin

--*/
 
#ifndef __PINCACHE__H__
#define __PINCACHE__H__

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


/*+-----------------------------------------------------------------------*\
PINCACHE_HANDLE
Handle to pin cache data.  Should be initialized to NULL.

CSP should keep one PINCACHE_HANDLE per available card.  For instance, two
HCRYPTPROV handles open for the same card should reference the same pin
cache handle.  If multiple cards are simultaneously available on the system,
the CSP should have a separate cache handle for each.

No thread synchronization is provided by functions in this module when accessing
pin cache data.
\*------------------------------------------------------------------------*/  
typedef LPVOID PINCACHE_HANDLE;

/*+-----------------------------------------------------------------------*\
PINCACHE_PINS
Pin struct to be populated by the CSP and passed to PinCacheAdd.  

This struct is used in two different ways:

1) When simply caching a pin, such as in response to a CryptSetProvParam
PP_KEYEXCHANGE_PIN call, the pin and its length should be set in the 
pbCurrentPin and cbCurrentPin parameters, respectively.  In this case,
cbNewPin must be zero and pbNewPin must be NULL.

2) When updating the cache in response to a user pin-change event,
the new pin and its length should be set in the pbNewPin and cbNewPin
parameters.  The current pin and its length should be set in the 
pbCurrentPin and cbCurrentPin parameters.

In cases when the PFN_VERIFYPIN_CALLBACK is called (see below), this struct 
will be passed to that function without modification (its members will not
be changed by PinCacheAdd).
\*------------------------------------------------------------------------*/  
typedef struct _PINCACHE_PINS
{
    DWORD cbCurrentPin; 
    PBYTE pbCurrentPin;
    DWORD cbNewPin;
    PBYTE pbNewPin;
} PINCACHE_PINS, *PPINCACHE_PINS;

/*+-----------------------------------------------------------------------*\
PFN_VERIFYPIN_CALLBACK
Signature for function used by PinCacheAdd in certain cases to verify that
the supplied pin is correct.

The callback is used any time the cached pin is to be updated.  

If pbNewPin is not NULL, this is a change-pin scenario.  Otherwise, this
is a verify-pin scenario.

The pvCallbackCtx is always passed to the callback without modification.  
It is assumed to be context information required by the CSP.
\*------------------------------------------------------------------------*/  
typedef DWORD (WINAPI *PFN_VERIFYPIN_CALLBACK)(
    IN PPINCACHE_PINS pPins, 
    IN PVOID pvCallbackCtx);

/*+-----------------------------------------------------------------------*\
PinCacheFlush
Cleanup and delete the cache.

CSP should call this function in the following situations:

1) The card for which this PINCACHE_HANDLE applies has been removed.

2) The CSP detects that card data has been modified by another process.  For
example, the pin has been changed.
\*------------------------------------------------------------------------*/
void WINAPI PinCacheFlush(
    IN PINCACHE_HANDLE *phCache);

/*+-----------------------------------------------------------------------*\
PinCacheAdd
Cache a pin.

CSP should call PinCacheAdd in response to CryptSetProvParam
PP_KEYEXCHANGE_PIN and within all pin-related UI from the CSP (including 
pin-change and verification).

This function exhibits the following behavior in these scenarios.  The flow
of this description continues through each case until you encounter a 
"return" value.

If a pin is currently cached (the cache has been initialized) and the 
currently cached pin does not match pPins->pbCurrentPin, 
SCARD_W_WRONG_CHV is returned.  Otherwise, continue.

"Pin Decision"                   
If the pPins->pbNewPin parameter is non-NULL, that pin will be added to the cache
in cases where the cache is modified, below.  This case indicates 
a pin-change.  Otherwise, the pPins->pbCurrentPin will be cached.  

If pPins->pbNewPin is non-NULL, or the cache has not been initialized,
pfnVerifyPinCallback is called.  If the callback fails, PinCacheAdd
immediately returns with the value returned by the callback.

"Uninitialized Cache"
For uninitialized cache, the appropriate pin (per "Pin Decision," above)
is cached with the current Logon ID.  Return ERROR_SUCCESS.

"Initialized Cache"
If the current Logon ID is different from the cached Logon ID, then the new 
Logon ID is cached in place of the currently cached Logon ID.  If the currently
cached pin is different from the pin to be cached (per "Pin Decision," above),
then the cached pin is replaced.  Return ERROR_SUCCESS.
\*------------------------------------------------------------------------*/
DWORD WINAPI PinCacheAdd(
    IN PINCACHE_HANDLE *phCache,
    IN PPINCACHE_PINS pPins,
    IN PFN_VERIFYPIN_CALLBACK pfnVerifyPinCallback,
    IN PVOID pvCallbackCtx);

/*+-----------------------------------------------------------------------*\
PinCacheQuery
Retrieve a cached pin.

If the cache is not initialized, *pcbPin is set to zero and ERROR_EMPTY
is returned.

If the cache is initialized, PinCacheQuery implements the following behaviors:

1) If the current Logon ID is different from the cached Logon ID, *pcbPin is 
set to zero and ERROR_SUCCESS is returned.

2) If the current Logon ID is the same as the cached Logon ID, the following
tests are made:  
If pbPin is NULL, *pcbPin is set to the size of the currently cached pin and
ERROR_SUCCESS is returned.
If pbPin is non-NULL and *pcbPin is smaller than the size of the currently 
cached pin, *pcbPin is set to the size of the currently cached pin and
ERROR_MORE_DATA is returned.
If pbPin is non-NULL and *pcbPin is at least the size of the currently cached
pin, then *pcbPin is set to the size of the currently cached pin, the cached
pin is copied into pbPin, and ERROR_SUCCESS is returned.
\*------------------------------------------------------------------------*/

DWORD WINAPI PinCacheQuery(
    IN PINCACHE_HANDLE hCache,
    IN OUT PBYTE pbPin,
    IN OUT PDWORD pcbPin);

/*+-----------------------------------------------------------------------*\
PinCachePresentPin
Request a cached pin via a callback.

If the cache is not initialized, ERROR_EMPTY is returned.

If the cache is initialized, PinCachePresentPin implements the following 
behavior:

1) If the current Logon ID is different from the cached Logon ID, 
SCARD_W_CARD_NOT_AUTHENTICATED is returned and the callback is not invoked.

2) If the current Logon ID is the same as the cached Logon ID, then a PINCACHE_PINS
structure is initialized as follows.  The cbCurrentPin and pbCurrentPin members
are set to the values of the currently cached pin.  The pbNewPin and cbNewPin
members are zero'd.  The pfnVerifyPinCallback is then invoked with the PINCACHE_PINS
structure and the pvCallbackCtx parameter as arguments.

PinCachePresentPin returns the value returned by pfnVerifyPinCallback.
\*------------------------------------------------------------------------*/

DWORD WINAPI PinCachePresentPin(
    IN PINCACHE_HANDLE hCache,
    IN PFN_VERIFYPIN_CALLBACK pfnVerifyPinCallback,
    IN PVOID pvCallbackCtx);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\pincache\pincache.c ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    pincache.c
                                                
Abstract:

    Pin Caching Library for Smart Card CSP's

Author:

    Dan Griffin

--*/

#include <windows.h>
#include "pincache.h"

#if defined(DBG) || defined(DEBUG)
#define DebugPrint(a)   (OutputDebugString(a))

#if TEST_DEBUG
#include <stdio.h>

#define CROW 8
void PCPrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    sprintf(rgsz, "\n  %s, %d bytes ::\n", pszHdr, cbSize);
    DebugPrint(rgsz);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        DebugPrint(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            sprintf(rgsz + (3*i), " %02x", pb[i]);
        DebugPrint(rgsz);
        for (i = cb; i < CROW; i++)
            DebugPrint("   ");
        DebugPrint("    '");        
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                sprintf(rgsz+i, "%c", pb[i]);
            else
                sprintf(rgsz+i, ".");
        }
        sprintf(rgsz+i, "\n");
        DebugPrint(rgsz);
        pb += cb;
    }
}

BOOL MyGetTokenInformation(
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength);

#define GetTokenInformation(A, B, C, D, E) MyGetTokenInformation(A, B, C, D, E)
#define TestDebugPrint(a) (OutputDebugString(a))
#else
#define TestDebugPrint(a)
#endif // TEST_DEBUG

#else
#define DebugPrint(a)
#define TestDebugPrint(a)
#endif // DBG || DEBUG

typedef struct _PINCACHEITEM
{
    LUID luid;
    PBYTE pbPin;
    DWORD cbPin;
    DWORD dwBadTries;
} PINCACHEITEM, *PPINCACHEITEM;

#define CacheAlloc(X)   (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, X))
#define CacheFree(X)    (HeapFree(GetProcessHeap(), 0, X))

#define INIT_PIN_ATTACK_SLEEP        6000     // milliseconds
#define MAX_PIN_ATTACK_SLEEP        24000     // milliseconds
#define MAX_FREE_BAD_TRIES              3

/**
 * Function: PinCacheFlush
 */
void WINAPI PinCacheFlush(
    IN OUT PINCACHE_HANDLE *phCache)
{
    PPINCACHEITEM pCache = (PPINCACHEITEM) *phCache;

    if (NULL == pCache)
        return;

    TestDebugPrint(("PinCacheFlush: deleting cache\n"));

    ZeroMemory(pCache->pbPin, pCache->cbPin);
    ZeroMemory(pCache, sizeof(PINCACHEITEM));

    CacheFree(pCache->pbPin);
    CacheFree(pCache);

    *phCache = NULL;
}

/**
 * Function: PinCacheAdd
 */
DWORD WINAPI PinCacheAdd(
    IN PINCACHE_HANDLE *phCache,
    IN PPINCACHE_PINS pPins,
    IN PFN_VERIFYPIN_CALLBACK pfnVerifyPinCallback,
    IN PVOID pvCallbackCtx)
{
    HANDLE hThreadToken         = 0;
    TOKEN_STATISTICS stats;
    DWORD dwError               = ERROR_SUCCESS;
    DWORD cb                    = 0;
    PPINCACHEITEM pCache        = (PPINCACHEITEM) *phCache;
    DWORD cbPinToCache          = 0;
    PBYTE pbPinToCache          = NULL;
    BOOL fRefreshPin            = FALSE;
    DWORD dwSleep               = 0;
    
    if (NULL != pCache &&
        (pPins->cbCurrentPin != pCache->cbPin ||
         0 != memcmp(pCache->pbPin, pPins->pbCurrentPin, pCache->cbPin)))
    {

        // The caller hasn't supplied the correct Pin, according to the current
        // cache state.  Perhaps the user accidently typed the wrong pin, in which
        // case the caller's logon LUID should be the same as the cached LUID.
        // If the LUID's don't match, this could still be an attack or a legitimate
        // attempt from a different logon with a mis-typed pin.

        if (! OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
        {
            if (! OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
            {
                dwError = GetLastError();
                goto Ret;         
            }                  
        }

        if (! GetTokenInformation(
                hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
        {
            dwError = GetLastError();
            goto Ret;
        }

        
        if (0 != memcmp(&stats.AuthenticationId, &pCache->luid, sizeof(LUID)) &&
            ++pCache->dwBadTries > MAX_FREE_BAD_TRIES)
        {
            // Current caller is a different luid from the cached one,
            // and it's happened a few times already, so this call is suspicious.  
            // Start delaying.

            DebugPrint(("PinCacheAdd: error - calling SleepEx().  Currently cached pin doesn't match\n"));
            
            dwSleep = pCache->dwBadTries * INIT_PIN_ATTACK_SLEEP;

            if (MAX_PIN_ATTACK_SLEEP < dwSleep)
                dwSleep = MAX_PIN_ATTACK_SLEEP;

            SleepEx(dwSleep, FALSE);
        }

        dwError = SCARD_W_WRONG_CHV;
        goto Ret;
    }
    else if (NULL != pCache && 0 != pCache->dwBadTries)
    {
        pCache->dwBadTries = 0;
    }

    if (pPins->pbNewPin)
    {
        fRefreshPin = TRUE;
        cbPinToCache = pPins->cbNewPin;
        pbPinToCache = pPins->pbNewPin;
    }
    else
    {
        cbPinToCache = pPins->cbCurrentPin;
        pbPinToCache = pPins->pbCurrentPin;
    }

    if (fRefreshPin || NULL == pCache)
    {
        // Check the pin
        if (ERROR_SUCCESS != (dwError = 
                pfnVerifyPinCallback(pPins, pvCallbackCtx)))
        {
            TestDebugPrint(("PinCacheAdd: pfnVerifyPinCallback failed\n"));
            return dwError;
        }
    }

    if (! OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
    {
        if (! OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
        {
            TestDebugPrint(("PinCacheAdd: failed to open thread or process token\n"));
            dwError = GetLastError();
            goto Ret;         
        }                  
    }

    if (! GetTokenInformation(
            hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
    {
        TestDebugPrint(("PinCacheAdd: GetTokenInformation failed\n"));
        dwError = GetLastError();
        goto Ret;
    }

#if TEST_DEBUG
    PCPrintBytes("PinCache LUID", (PBYTE) &stats.AuthenticationId, sizeof(LUID));
#endif

    // Now the current ID is in stats.AuthenticationId
                       
    if (NULL == pCache)
    {
        TestDebugPrint(("PinCacheAdd: initializing new cache\n"));

        // Initialize new cache
        if (NULL == (pCache = (PPINCACHEITEM) CacheAlloc(sizeof(PINCACHEITEM))))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }

        CopyMemory(&pCache->luid, &stats.AuthenticationId, sizeof(LUID));
        *phCache = (PINCACHE_HANDLE) pCache;
        fRefreshPin = TRUE;
    }
    else
    {
        // Compare ID's
        if (0 != memcmp(&stats.AuthenticationId, &pCache->luid, sizeof(LUID)))
        {
            // PIN's are the same, so cache the new ID
            TestDebugPrint(("PinCacheAdd: same Pin, different Logon as cached values\n"));
            CopyMemory(&pCache->luid, &stats.AuthenticationId, sizeof(LUID));
        }
    }

    if (fRefreshPin)
    {
        if (pCache->pbPin)
            CacheFree(pCache->pbPin);

        pCache->cbPin = cbPinToCache;
        if (NULL == (pCache->pbPin = (PBYTE) CacheAlloc(cbPinToCache)))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        CopyMemory(pCache->pbPin, pbPinToCache, cbPinToCache);
    }

Ret:
    if (hThreadToken)
        CloseHandle(hThreadToken);

    return dwError;   
}

/**
 * Function: PinCacheQuery
 */
DWORD WINAPI PinCacheQuery(
    IN PINCACHE_HANDLE hCache,
    IN OUT PBYTE pbPin,
    IN OUT PDWORD pcbPin)
{
    HANDLE hThreadToken     = 0;
    TOKEN_STATISTICS stats;
    DWORD dwError           = ERROR_SUCCESS;
    DWORD cb                = 0;
    PPINCACHEITEM pCache    = (PPINCACHEITEM) hCache;

    if (NULL == pCache)
    {
        *pcbPin = 0;
        return ERROR_EMPTY;
    }

    if (! OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
    {
        if (! OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
        {
            TestDebugPrint(("PinCacheQuery: failed to open thread or process token\n"));
            dwError = GetLastError();
            goto Ret;         
        }                  
    }

    if (! GetTokenInformation(
            hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
    {
        TestDebugPrint(("PinCacheQuery: GetTokenInformation failed\n"));
        dwError = GetLastError();
        goto Ret;
    }   

    // Now the current ID is in stats.AuthenticationId
                                    
    if (0 != memcmp(&stats.AuthenticationId, &pCache->luid, sizeof(LUID)))
    {
        // ID's are different, so ignore cache
        TestDebugPrint(("PinCacheQuery: different Logon from cached value\n"));
        *pcbPin = 0;
        goto Ret;
    }

    // ID's are the same, so return cached PIN
    TestDebugPrint(("PinCacheQuery: same Logon as cached value\n"));
        
    if (NULL != pbPin)
    {
        if (*pcbPin >= pCache->cbPin)
            CopyMemory(pbPin, pCache->pbPin, pCache->cbPin);
        else
            dwError = ERROR_MORE_DATA;
    }

    *pcbPin = pCache->cbPin;      
    
Ret:
    if (hThreadToken)
        CloseHandle(hThreadToken);

    return dwError;   
}

/**
 * Function: PinCachePresentPin
 */
DWORD WINAPI PinCachePresentPin(
    IN PINCACHE_HANDLE hCache,
    IN PFN_VERIFYPIN_CALLBACK pfnVerifyPinCallback,
    IN PVOID pvCallbackCtx)
{
    HANDLE hThreadToken     = 0;
    TOKEN_STATISTICS stats;
    DWORD cb                = 0;
    DWORD dwError           = ERROR_SUCCESS;
    PPINCACHEITEM pCache    = (PPINCACHEITEM) hCache;
    PINCACHE_PINS Pins;

    if (NULL == pCache)
        return ERROR_EMPTY;

    if (! OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
    {
        if (! OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
        {
            TestDebugPrint(("PinCachePresentPin: failed to open thread or process token\n"));
            dwError = GetLastError();
            goto Ret;         
        }                  
    }

    if (! GetTokenInformation(
            hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
    {
        TestDebugPrint(("PinCachePresentPin: GetTokenInformation failed\n"));
        dwError = GetLastError();
        goto Ret;
    }   

    // Now the current ID is in stats.AuthenticationId
                                    
    if (0 != memcmp(&stats.AuthenticationId, &pCache->luid, sizeof(LUID)))
    {
        // ID's are different, so ignore cache
        TestDebugPrint(("PinCachePresentPin: different Logon from cached value\n"));
        dwError = SCARD_W_CARD_NOT_AUTHENTICATED;
        goto Ret;
    }

    // ID's are the same, so return cached PIN
    TestDebugPrint(("PinCachePresentPin: same Logon as cached value\n"));

    Pins.cbCurrentPin = pCache->cbPin;
    Pins.pbCurrentPin = pCache->pbPin;
    Pins.cbNewPin = 0;
    Pins.pbNewPin = NULL;

    dwError = (*pfnVerifyPinCallback)(&Pins, pvCallbackCtx);

Ret:
    if (hThreadToken)
        CloseHandle(hThreadToken);

    return dwError;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\gemsafe\inc\compcert.h ===
/*******************************************************************************
*                       Copyright (c) 1998 Gemplus Development
*
* Name        : COMPCERT.H
*
* Description : 
*
  Author      : Christophe Clavier

  Compiler    : Microsoft Visual C 1.5x/2.0
                ANSI C UNIX.

  Host        : IBM PC and compatible machines under Windows 3.x.
                UNIX machine.

* Release     : 1.10.001
*
* Last Modif. : 04/03/98: V1.10.001 - New dictionary management.
*               27/08/97: V1.00.001 - First implementation.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/

/*------------------------------------------------------------------------------
Name definition:
   _COMPCERT_H is used to avoid multiple inclusion.
------------------------------------------------------------------------------*/
#ifndef _COMPCERT_H
#define _COMPCERT_H


/* Errors code                                                                */
#define RV_SUCCESS					0	/* Info		*/
#define RV_COMPRESSION_FAILED		1	/* Warning	*/
#define RV_MALLOC_FAILED			2	/* Error		*/
#define RV_BAD_DICTIONARY			3	/* Error		*/
#define RV_INVALID_DATA				4	/* Error		*/
#define RV_BLOC_TOO_LONG			5	/* Warning  */
#define RV_FILE_OPEN_FAILED		6	/* Error    */
#define RV_BUFFER_TOO_SMALL		7	/* Error	   */

/* Dictionary mode                                                             */
#define DICT_STANDARD   (0)      // DLL mode only
#define DICT_REGISTRY   (1)
#define DICT_FILE       (2)


/*------------------------------------------------------------------------------
                          Types definitions
------------------------------------------------------------------------------*/
typedef unsigned char   TAG;
typedef TAG*            TAG_PTR;
typedef BYTE*           BYTE_PTR;

#pragma pack(push, 8)

typedef struct 
{
   USHORT   usLen;
   BYTE_PTR pData;
} BLOC, * BLOC_PTR;

typedef struct 
{
   BLOC Asn1;
   BLOC Content;
   TAG  Tag;
} ASN1, * ASN1_PTR;

#pragma pack(pop)

/*------------------------------------------------------------------------------
                        Functions Prototypes definitions
------------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" 
{
#endif

int CC_Init      (BYTE  bDictMode,
                  BYTE *pszDictName
                 );

int CC_Exit      (void);

int CC_Compress  (BLOC *pCert,
                  BLOC *pCompCert
                 );

int CC_Uncompress(BLOC *pCompCert,
                  BLOC *pUncompCert
                 );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\basecsp\debug.c ===
#include <windows.h>
#include <dsysdbg.h>
#include "debug.h"

DEFINE_DEBUG2(Basecsp)

static DEBUG_KEY  MyDebugKeys[] = 
{   
    { DEB_TRACE_CSP,            "TraceCsp" },
    { DEB_TRACE_FINDCARD,       "TraceFindcard" },
    { DEB_TRACE_CACHE,          "TraceCache" },
    { DEB_TRACE_MEM,            "TraceMem" },
    { DEB_TRACE_CRYPTOAPI,      "TraceCryptoAPI" },
    { 0,                        NULL}
};

void CspInitializeDebug(void)
{
#if DBG
    BasecspInitDebug(MyDebugKeys);
#endif
}

void CspUnloadDebug(void)
{
#if DBG
    BasecspUnloadDebug();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\basecsp\findcard.c ===
#include <windows.h>
#include <wincrypt.h>

#pragma warning(push)
#pragma warning(disable:4201) 
// Disable error C4201 in public header 
//  nonstandard extension used : nameless struct/union
#include <winscard.h>
#pragma warning(pop)

#include "basecsp.h"
#include "datacach.h"
#include "cardmod.h"
#include "debug.h"

//
// Debugging Macros
//
#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_FINDCARD, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_FINDCARD, "%s: Leaving, status: 0x%x\n", #x, y)); }

//
// Function: FindCardMakeCardHandles
//
// Purpose: Based on reader name information in the CARD_MATCH_DATA
//  structure, build and return an SCARD_CONTEXT and SCARD_HANDLE
//  for the target card.
//
// Note, the wszMatchedReader, dwShareMode, and dwPreferredProtocols fields
// of the CARD_MATCH_DATA structure must be initialized by the caller.
//
DWORD FindCardMakeCardHandles(
    IN  PCARD_MATCH_DATA    pCardMatchData,
    OUT SCARDCONTEXT        *pSCardContext,
    OUT SCARDHANDLE         *pSCardHandle)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD dwActiveProtocol = 0;

    *pSCardContext = 0;
    *pSCardHandle = 0;

    dwSts = SCardEstablishContext(
        SCARD_SCOPE_USER, 
        NULL,
        NULL,
        pSCardContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = SCardConnectW(
        *pSCardContext,
        pCardMatchData->wszMatchedReader,
        pCardMatchData->dwShareMode,
        pCardMatchData->dwPreferredProtocols,
        pSCardHandle,
        &dwActiveProtocol);

Ret:

    if (ERROR_SUCCESS != dwSts)
    {
        if (*pSCardHandle)
        {
            SCardDisconnect(*pSCardHandle, SCARD_LEAVE_CARD);
            *pSCardHandle = 0;
        }

        if (*pSCardContext)
        {
            SCardReleaseContext(*pSCardContext);
            *pSCardContext = 0;
        }
    }

    return dwSts;
}

//
// Function: CardStateCacheFindAddItem
//
// Purpose: Lookup the card specified in the CARD_MATCH_DATA structure
//          in the CSP's cache of CARD_STATE items.  If the card is found
//          in the cache, set the CARD_MATCH_DATA to point to the cached
//          item.  
//
//          If the matching card is not found cached, add it to the cache.
//
//          If this function Succeeds, the returned CARD_STATE structure
//          has its own valid card context and card handle.
//
DWORD CardStateCacheFindAddItem(
    IN PCARD_MATCH_DATA pCardMatchData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fInCspCS = FALSE;
    DATA_BLOB dbKeys;
    DATA_BLOB dbCardState;
    PCARD_STATE pCardState = pCardMatchData->pCardState;
    BOOL fMakeNewCardHandle = FALSE;
    BOOL fInCardStateCS = FALSE;

    memset(&dbKeys, 0, sizeof(dbKeys));
    memset(&dbCardState, 0, sizeof(dbCardState));

    DsysAssert(0 != pCardState->pCardData->hScard);
    DsysAssert(0 != pCardState->pCardData->hSCardCtx);
    DsysAssert(0 != pCardMatchData->hSCard);
    DsysAssert(0 != pCardMatchData->hSCardCtx);

    // Now going to search the CSP_STATE for a cached entry for the current
    // card.  Grab the critical section protecting the cache.
    dwSts = CspEnterCriticalSection(
        &pCardMatchData->pCspState->cs);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    fInCspCS = TRUE;

    // Lookup a cache entry via card serial number
    dbKeys.pbData = (PBYTE) pCardMatchData->pCardState->wszSerialNumber;
    dbKeys.cbData = 
        wcslen(pCardMatchData->pCardState->wszSerialNumber) * sizeof(
            pCardMatchData->pCardState->wszSerialNumber[0]);

    dwSts = CacheGetItem(
        pCardMatchData->pCspState->hCache,
        &dbKeys,
        1, &dbCardState);

    if (ERROR_NOT_FOUND != dwSts &&
        ERROR_SUCCESS != dwSts)
        // some unexpected error has occurred
        goto Ret;

    if (ERROR_NOT_FOUND == dwSts)
    {
        // This is a new card that has not been cached yet.  Add it
        // to the cache.
        //
        // Since we're not using an already-cached card, and we expect
        // that this card object was just passed to us new, we know
        // that we need to create a new card handle for it.
        //

        dbCardState.cbData = sizeof(CARD_STATE);
        dbCardState.pbData = (PBYTE) pCardState;
        
        dwSts = CacheAddItem(
            pCardMatchData->pCspState->hCache,
            &dbKeys,
            1, &dbCardState);

        dbCardState.pbData = NULL;

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        DsysAssert(TRUE == fInCspCS);

        // We're done mucking with the cache list, so let it go.
        CspLeaveCriticalSection(&pCardMatchData->pCspState->cs);

        fInCspCS = FALSE;
    }
    else
    {
        DsysAssert(TRUE == fInCspCS);

        // We're now done with the cache list in this case.
        CspLeaveCriticalSection(&pCardMatchData->pCspState->cs);

        fInCspCS = FALSE;

        //
        // The current card has already been cached.  Free the local copy of
        // the CSP_STATE struct and use the cached one instead.
        //
        // We can't hold the critsec on the current CardState, and keep its
        // associated card's transaction, while waiting for the critsec of 
        // another CardState.  That could deadlock.
        //
        if (pCardMatchData->fTransacted)
        {
            dwSts = CspEndTransaction(pCardState);
            
            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            pCardMatchData->fTransacted = FALSE;
        }

        // Can't let the SCARDCONTEXT be released, because the scarddlg 
        // routines will still be expecting to use it.
        pCardState->pCardData->hSCardCtx = 0;

        DeleteCardState(pCardState);
        CspFreeH(pCardState);
        pCardMatchData->pCardState = (PCARD_STATE) dbCardState.pbData;

        // Update the local pointer for convenience.
        pCardState = (PCARD_STATE) dbCardState.pbData;

        // Don't want this pointer freed out from under us since we're going 
        // to use this struct.
        dbCardState.pbData = NULL;

        //
        // Now we need to verify that the handles cached with this card 
        // structure are still valid.  Check now.  If the handles
        // aren't valid anymore, we'll reconnect to this card below.
        // 
        // We want to ensure that each card object has it's own handles.
        //
        // Since the card state objects are shared, we need to take the
        // critical section of the target object before we can examine its 
        // handles.
        //
        dwSts = CspEnterCriticalSection(&pCardState->cs);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
        else 
            fInCardStateCS = TRUE;

        if (pCardMatchData->hSCardCtx == pCardState->pCardData->hSCardCtx)
            dwSts = ValidateCardHandle(pCardState, FALSE, NULL);
        else
            dwSts = ValidateCardHandle(pCardState, TRUE, NULL);

        if (ERROR_SUCCESS != dwSts)
            fMakeNewCardHandle = TRUE;
    }

    if (fMakeNewCardHandle)
    {
        if (FALSE == fInCardStateCS)
        {
            dwSts = CspEnterCriticalSection(&pCardState->cs);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
            else
                fInCardStateCS = TRUE;
        }

        dwSts = FindCardMakeCardHandles(
            pCardMatchData,
            &pCardState->pCardData->hSCardCtx,
            &pCardState->pCardData->hScard);
    }

Ret:
    if (fInCardStateCS)
        CspLeaveCriticalSection(&pCardState->cs);
    if (fInCspCS)
        CspLeaveCriticalSection(
            &pCardMatchData->pCspState->cs);
    if (dbCardState.pbData)
        CspFreeH(dbCardState.pbData);

    return dwSts;
}

//
// Function: GetCardSerialNumber
//
// Purpose: Attempt to read the serial number of the card
//          specified in pCardMatchData.
//
//          Assumes that a transaction is not currently held on the target 
//          card by the caller.
//
DWORD GetCardSerialNumber(
    IN OUT  PCARD_MATCH_DATA pCardMatchData)
{
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext = NULL;
    DWORD cch = 0;
    WCHAR rgwsz[MAX_PATH];
    DWORD dwSts = ERROR_SUCCESS;
    PCARD_STATE pCardState = NULL;
    PCARD_DATA pCardData = NULL;
    DATA_BLOB DataBlob;
    DWORD dwState = 0;
    DWORD dwProtocol = 0;
    LPWSTR mszReaders = NULL;

    LOG_BEGIN_FUNCTION(GetCardSerialNumber);

    memset(&DataBlob, 0, sizeof(DataBlob));

    //
    // Determine how to talk to the card by looking
    // for the appropriate Card Specific Module in the Calais
    // database.
    //
    cch = sizeof(rgwsz) / sizeof(rgwsz[0]);
    dwSts = SCardGetCardTypeProviderNameW(
        pCardMatchData->hSCardCtx,
        pCardMatchData->wszMatchedCard,
        SCARD_PROVIDER_CARD_MODULE,
        rgwsz,
        &cch);

    if (ERROR_SUCCESS != dwSts)
        goto Ret; 

    pCardState = (PCARD_STATE) CspAllocH(sizeof(CARD_STATE));

    LOG_CHECK_ALLOC(pCardState);

    pCardState->dwVersion = CARD_STATE_CURRENT_VERSION;

    dwSts = InitializeCardState(pCardState);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pCardState->hCardModule = LoadLibraryW(rgwsz);

    if (0 == pCardState->hCardModule)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pfnCardAcquireContext = 
        (PFN_CARD_ACQUIRE_CONTEXT) GetProcAddress(
        pCardState->hCardModule,
        "CardAcquireContext");

    if (NULL == pfnCardAcquireContext)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pCardData = (PCARD_DATA) CspAllocH(sizeof(CARD_DATA));

    LOG_CHECK_ALLOC(pCardData);

    dwSts = InitializeCardData(pCardData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // We need to temporarily copy the current card handle into the
    // CARD_DATA structure, so we can make some calls into the card
    // module.  We may keep these handles in some cases.
    // 
    pCardData->hScard = pCardMatchData->hSCard;
    pCardData->hSCardCtx = pCardMatchData->hSCardCtx;
    
    pCardData->pwszCardName = (LPWSTR) CspAllocH(
        (1 + wcslen(pCardMatchData->wszMatchedCard)) * sizeof(WCHAR));

    LOG_CHECK_ALLOC(pCardData->pwszCardName);

    wcscpy(
        pCardData->pwszCardName,
        pCardMatchData->wszMatchedCard);

    pCardData->cbAtr = cbATR_BUFFER;
    pCardData->pbAtr = (PBYTE) CspAllocH(cbATR_BUFFER);

    LOG_CHECK_ALLOC(pCardData->pbAtr);

    //
    // Use SCardStatus to get the ATR of the card we're trying
    // to talk to.
    //
    cch = SCARD_AUTOALLOCATE;
    dwSts = SCardStatusW(
        pCardData->hScard,
        (LPWSTR) &mszReaders,
        &cch,
        &dwState,
        &dwProtocol,
        pCardData->pbAtr,
        &pCardData->cbAtr);

    switch (dwSts)
    {
    case SCARD_W_RESET_CARD:
        // The card managed to get reset already.  Try to reconnect.

        dwSts = SCardReconnect(
            pCardData->hScard,
            pCardMatchData->dwShareMode,
            pCardMatchData->dwPreferredProtocols,
            SCARD_LEAVE_CARD,
            &dwProtocol);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        break;

    case ERROR_SUCCESS:
        break;

    default:
        goto Ret;
    }

    //
    // Now acquire a card module context for this card.
    //
    dwSts = pfnCardAcquireContext(pCardData, 0);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pCardState->pCardData = pCardData;
    pCardData = NULL;

    //
    // Now that we have both the CARD_STATE and CARD_DATA structures,
    // we can setup the caching contexts to be used by the CSP and to
    // be exposed to the card module.
    //
    dwSts = InitializeCspCaching(pCardState);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = CspBeginTransaction(pCardState);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pCardMatchData->fTransacted = TRUE;

    //
    // Get the serial number for this card
    //
    dwSts = CspReadFile(
        pCardState,
        wszCARD_IDENTIFIER_FILE_FULL_PATH,
        0, 
        &DataBlob.pbData,
        &DataBlob.cbData);

    if (ERROR_SUCCESS != dwSts)
    {
        CspEndTransaction(pCardState);
        pCardMatchData->fTransacted = FALSE;
        goto Ret;
    }

    memcpy(
        pCardState->wszSerialNumber,
        DataBlob.pbData,
        DataBlob.cbData);


    pCardState->pfnCardAcquireContext = pfnCardAcquireContext;
    pCardMatchData->pCardState = pCardState;
    pCardState = NULL;

Ret:

    // If we're not in a transaction, assume the current handles will be
    // cleaned up by the caller
    /*
    if (NULL != pCardMatchData->pCardState &&
        NULL != pCardMatchData->pCardState->pCardData &&
        FALSE == pCardMatchData->fTransacted)
    {
        pCardMatchData->pCardState->pCardData->hScard = 0;
        pCardMatchData->pCardState->pCardData->hSCardCtx = 0;
    }
    */

    if (DataBlob.pbData)
        CspFreeH(DataBlob.pbData);
    if (pCardState)
    {
        DeleteCardState(pCardState);
        CspFreeH(pCardState);
    }
    if (pCardData)
    {
        CleanupCardData(pCardData);
        CspFreeH(pCardData);
    }
    if (mszReaders)
        SCardFreeMemory(pCardMatchData->hSCardCtx, mszReaders);

    LOG_END_FUNCTION(GetCardSerialNumber, dwSts);

    return dwSts;
}

//
// Function: FindCardConnectProc
//
// Purpose: This function is called by SCardUIDlgSelectCard to 
//          connect to candidate cards.  This is a wrapper for 
//          SCardConnectW, useful because the reader name and card
//          name are copied  into the PCARD_MATCH_DATA structure for
//          reference by FindCardCheckProc, below.
//
SCARDHANDLE WINAPI FindCardConnectProc(
    IN      SCARDCONTEXT hSCardCtx,
    IN      LPWSTR wszReader,
    IN      LPWSTR wszCard,
    IN OUT  PVOID pvCardMatchData)
{
    SCARDHANDLE hSCard = 0;
    DWORD dwSts = ERROR_SUCCESS;
    PCARD_MATCH_DATA pCardMatchData = (PCARD_MATCH_DATA) pvCardMatchData;

    DsysAssert(FALSE == pCardMatchData->fTransacted);

    dwSts = SCardConnectW(
        hSCardCtx, 
        wszReader, 
        pCardMatchData->dwShareMode,
        pCardMatchData->dwPreferredProtocols,
        &hSCard,
        &pCardMatchData->dwActiveProtocol);

    if (ERROR_SUCCESS != dwSts)
    {
        SetLastError(dwSts);
        return 0;
    }

    wcsncpy(
        pCardMatchData->wszMatchedCard, 
        wszCard,
        pCardMatchData->cchMatchedCard);

    wcsncpy(
        pCardMatchData->wszMatchedReader,
        wszReader,
        pCardMatchData->cchMatchedReader);

    return hSCard;
}

//
// Function: FindCardDisconnectProc
//
// Purpose: Called by SCardUIDlgSelectCard, this is a wrapper
//          for SCardDisconnect.  Some cleanup is also done in the 
//          provided CARD_MATCH_DATA structure to indicate that no
//          card handle is currently active.
//
void WINAPI FindCardDisconnectProc(
    IN      SCARDCONTEXT hSCardCtx,
    IN      SCARDHANDLE hSCard,
    IN      PVOID pvCardMatchData)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCARD_MATCH_DATA pCardMatchData = (PCARD_MATCH_DATA) pvCardMatchData;

    UNREFERENCED_PARAMETER(hSCardCtx);

    DsysAssert(FALSE == pCardMatchData->fTransacted);

    //
    // Get rid of the matching card and reader information.
    //

    memset(
        pCardMatchData->wszMatchedCard,
        0,
        pCardMatchData->cchMatchedCard * sizeof(pCardMatchData->wszMatchedCard[0]));

    memset(
        pCardMatchData->wszMatchedReader,
        0,
        pCardMatchData->cchMatchedReader * sizeof(pCardMatchData->wszMatchedReader[0]));

    pCardMatchData->hSCard = 0;

    // If there is a matched card currently, we may be about to disconnect its
    // card handle.  If so, set that handle value to zero.
    if (NULL != pCardMatchData->pCardState)
    {
        dwSts = CspEnterCriticalSection(
            &pCardMatchData->pCardState->cs);

        if (ERROR_SUCCESS != dwSts)
        {
            SetLastError(dwSts);
            return;
        }

        if (hSCard == pCardMatchData->pCardState->pCardData->hScard)
            pCardMatchData->pCardState->pCardData->hScard = 0;

        CspLeaveCriticalSection(
            &pCardMatchData->pCardState->cs);
    }

    dwSts = SCardDisconnect(hSCard, SCARD_LEAVE_CARD);

    if (ERROR_SUCCESS != dwSts)
    {
        SetLastError(dwSts);
        return;
    }
}

//
// Function: FindCardMatchUserParamaters
//
// Purpose: Check the card specified in the CARD_MATCH_DATA structure against
//          the user parameters specified in CryptAcquireContext.
//
//          Assumes that the caller does not hold a transaction on the 
//          target card.
//
//          If the card match is successful, the transaction will still be held
//          when the function returns.  The caller must release it.
//
DWORD WINAPI FindCardMatchUserParameters(
    IN PCARD_MATCH_DATA pCardMatchData)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_FREE_SPACE_INFO CardFreeSpaceInfo;
    DATA_BLOB DataBlob;
    PCARD_STATE pCardState = pCardMatchData->pCardState;
    CONTAINER_MAP_RECORD ContainerRecord;
    BYTE cContainers = 0;

    LOG_BEGIN_FUNCTION(FindCardMatchUserParameters);

    memset(&CardFreeSpaceInfo, 0, sizeof(CardFreeSpaceInfo));
    memset(&DataBlob, 0, sizeof(DataBlob));
    memset(&ContainerRecord, 0, sizeof(ContainerRecord));

    //
    // Now start checking this card for matching
    // information.
    //
    if (CRYPT_NEWKEYSET & pCardMatchData->dwCtxFlags)
    {
        if (FALSE == pCardMatchData->fTransacted)
        {
            dwSts = CspBeginTransaction(pCardState);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            pCardMatchData->fTransacted = TRUE;
        }

        //
        // The user wants to create a new keyset.  Will that
        // be possible on this card?
        // 
        dwSts = CspQueryFreeSpace(
            pCardState,
            0, 
            &CardFreeSpaceInfo);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Determine how many valid containers are already present on this card
        dwSts = ContainerMapEnumContainers(
            pCardState, &cContainers, NULL);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (cContainers >= CardFreeSpaceInfo.dwMaxKeyContainers)
        {
            // No space for an additional container exists on 
            // this card.
            dwSts = (DWORD) NTE_TOKEN_KEYSET_STORAGE_FULL;
            goto Ret;
        }
                                     
        // If a container name was specified, make sure that container name
        // doesn't already exist on this card.
        if (NULL != pCardMatchData->pwszContainerName)
        {
            wcscpy(ContainerRecord.wszGuid, pCardMatchData->pwszContainerName);

            dwSts = ContainerMapFindContainer(
                pCardState, &ContainerRecord, NULL);

            switch (dwSts)
            {
            case ERROR_SUCCESS:
                // If that call succeeded, then the specified container
                // already exists, so this card can't be used.
                dwSts = (DWORD) NTE_EXISTS;
                break;
            case NTE_BAD_KEYSET:
                // In this case, we're successful because the keyset
                // wasn't found.
                dwSts = ERROR_SUCCESS;
                break;
            default:
                goto Ret;
            }
        }
        else
        {
            // Otherwise, the caller is attempting to create a new default
            // container, using a random Guid.  Nothing else to do at this time.
        }
    }
    else if (CRYPT_VERIFYCONTEXT & pCardMatchData->dwCtxFlags)
    {
        //
        // Caller is requesting VERIFYCONTEXT only.  We don't need to check
        // for a specific container, we we're done.
        //
    }
    else
    {
        if (FALSE == pCardMatchData->fTransacted)
        {
            dwSts = CspBeginTransaction(pCardState);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            pCardMatchData->fTransacted = TRUE;
        }

        //
        // The user wants to open an existing keyset.
        //
        if (pCardMatchData->pwszContainerName)
        {
            wcscpy(ContainerRecord.wszGuid, pCardMatchData->pwszContainerName);

            dwSts = ContainerMapFindContainer(
                pCardState, 
                &ContainerRecord, 
                &pCardMatchData->bContainerIndex);

            if (ERROR_SUCCESS != dwSts)
            {                  
                dwSts = (DWORD) SCARD_E_NO_KEY_CONTAINER;
                goto Ret;
            }
        }
        else
        {
            // User wants to open an existing default container.
            
            dwSts = ContainerMapGetDefaultContainer(
                pCardState, 
                &ContainerRecord, 
                &pCardMatchData->bContainerIndex);

            if (ERROR_SUCCESS != dwSts)
            {
                dwSts = (DWORD) SCARD_E_NO_KEY_CONTAINER;
                goto Ret;
            }

            // Hang onto the default container name - it will be needed in 
            // the User Context.

            pCardMatchData->pwszContainerName = (LPWSTR) CspAllocH(
                (wcslen(ContainerRecord.wszGuid) + 1) * sizeof(WCHAR));

            LOG_CHECK_ALLOC(pCardMatchData->pwszContainerName);

            wcscpy(
                pCardMatchData->pwszContainerName,
                ContainerRecord.wszGuid);

            pCardMatchData->fFreeContainerName = TRUE;
        }
    }

Ret:

    if (ERROR_SUCCESS != dwSts && TRUE == pCardMatchData->fTransacted)
    {
        CspEndTransaction(pCardMatchData->pCardState);
        pCardMatchData->fTransacted = FALSE;
    }

    if (DataBlob.pbData)
        CspFreeH(DataBlob.pbData);

    LOG_END_FUNCTION(FindCardMatchUserParameters, dwSts);

    return dwSts;
}

// 
// Function: FindCardCheckProc
//
// Purpose: Called by SCardUIDlgSelectCard to check candidate cards.
//
BOOL WINAPI FindCardCheckProc(
    IN SCARDCONTEXT hSCardCtx, 
    IN SCARDHANDLE hSCard, 
    IN PVOID pvCardMatchData)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCARD_MATCH_DATA pCardMatchData = (PCARD_MATCH_DATA) pvCardMatchData;
    BOOL fCardMatches = FALSE;

    UNREFERENCED_PARAMETER(hSCardCtx);

    LOG_BEGIN_FUNCTION(FindCardCheckProc);
    
    pCardMatchData->hSCard = hSCard;
    pCardMatchData->dwError = ERROR_SUCCESS;

    //
    // Read the serial number from the card
    //
    dwSts = GetCardSerialNumber(
        pCardMatchData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Lookup the serial number in our cached list
    // of cards
    //
    dwSts = CardStateCacheFindAddItem(
        pCardMatchData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (CARD_MATCH_TYPE_SERIAL_NUMBER == 
        pCardMatchData->dwMatchType)
    {
        // We're working on a "by Serial Number" match, so compare
        // the requested serial number to that of the card being
        // examined.  If they match, the search ends successfully.
        // If they don't, we know this is the wrong card.

        if (0 == wcscmp(
            pCardMatchData->pwszSerialNumber,
            pCardMatchData->pCardState->wszSerialNumber))
        {
            fCardMatches = TRUE;
        }
    }
    else
    {
        // We're not searching by serial number, so we'll make some sort
        // of container-based decision for matching a card.

        dwSts = FindCardMatchUserParameters(
            pCardMatchData);

        if (ERROR_SUCCESS == dwSts ||
            (NTE_TOKEN_KEYSET_STORAGE_FULL == dwSts &&
             SC_DLG_NO_UI != pCardMatchData->dwUIFlags))
        {
            //
            // If the user picked this card explicitly from the UI, but
            // the card is full, report a successful match to scarddlg.
            // This allows the CSP to return an appropriate error code
            // to allow enrollment to restart by re-using an existing key,
            // rather than trying to create a new one.
            //
            fCardMatches = TRUE;
        }
    }
    
Ret:

    pCardMatchData->hSCard = 0;

    if (pCardMatchData->fTransacted)
    {
        CspEndTransaction(pCardMatchData->pCardState);
        pCardMatchData->fTransacted = FALSE;
    }

    if (TRUE == fCardMatches)
    {
        pCardMatchData->pUIMatchedCardState = pCardMatchData->pCardState;
    }
    else
    {
        pCardMatchData->pCardState = NULL;
        pCardMatchData->dwError = dwSts;
    }

    LOG_END_FUNCTION(FindCardCheckProc, dwSts);

    return fCardMatches;
}

//
// Function: FindCardCached
//
// Purpose: Attempt to find a matching card using only cached
//          data.
//
DWORD FindCardCached(
    IN OUT  PCARD_MATCH_DATA pCardMatchData)
{
    PCARD_STATE pCardState = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    PDATA_BLOB pdb = NULL;
    DWORD cItems = 0;
    BOOL fCardStatusChanged = FALSE;

    LOG_BEGIN_FUNCTION(FindCardCached);

    dwSts = CspEnterCriticalSection(
        &pCardMatchData->pCspState->cs);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = CacheEnumItems(
        pCardMatchData->pCspState->hCache,
        &pdb,
        &cItems);

    CspLeaveCriticalSection(
        &pCardMatchData->pCspState->cs);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    while (cItems--)
    {
        pCardState = (PCARD_STATE) pdb[cItems].pbData;
        pCardMatchData->pCardState = pCardState;

        // Make sure the handle for this cached card is still valid.  If
        // the handle isn't valid, skip this card for the cached search.
        dwSts = CspEnterCriticalSection(&pCardState->cs);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = ValidateCardHandle(pCardState, TRUE, &fCardStatusChanged);

        if ((ERROR_SUCCESS != dwSts || 
             TRUE == fCardStatusChanged) && 
            NULL != pCardState->hPinCache)
        {
            // Flush the pin cache for this card.  Not checking error code
            // since we'll keep processing, anyway.
            CspRemoveCachedPin(pCardState, wszCARD_USER_USER);
        }

        CspLeaveCriticalSection(&pCardState->cs);

        if (ERROR_SUCCESS == dwSts)
        {
            dwSts = FindCardMatchUserParameters(
                pCardMatchData);
    
            if (ERROR_SUCCESS == dwSts)
                break;
            else
                pCardMatchData->pCardState = NULL;
        }
    }

    CacheFreeEnumItems(pdb);

Ret:

    if (TRUE == pCardMatchData->fTransacted)
    {
        CspEndTransaction(pCardMatchData->pCardState);
        pCardMatchData->fTransacted = FALSE;
    }

    LOG_END_FUNCTION(FindCardCached, dwSts);

    return dwSts;
}

//
// Function: FindCard
//
// Purpose: Primary internal routine for matching a suitable card
//          based on these factors:
//
//          a) Cards that are supportable by this CSP.
//          b) Cards that meet the user supplied criteria from 
//             CryptAcquireContext.
//
DWORD FindCard(
    IN OUT  PCARD_MATCH_DATA pCardMatchData)
{
    DWORD dwSts = ERROR_SUCCESS;
    OPENCARDNAME_EXW ocnx;
    OPENCARD_SEARCH_CRITERIAW ocsc;

    LOG_BEGIN_FUNCTION(FindCard);

    if (CARD_MATCH_TYPE_READER_AND_CONTAINER ==
        pCardMatchData->dwMatchType)
    {
        //
        // Only look for a cached card if the search type is
        // by Reader and Container.  
        //
        // The reason for this is:  if we already know the serial number
        // of the card we're looking for, then we must have already had a 
        // valid card previously.  Assume that we'll have to go through
        // the Resource Manager to locate such a card, because the card 
        // handle became invalid and reconnect failed (the card was withdrawn
        // and possibly inserted in a different reader).
        //

        dwSts = FindCardCached(pCardMatchData);
    
        if (ERROR_SUCCESS == dwSts && 
            NULL != pCardMatchData->pCardState)
        {
            //
            // Found a cached card, so we're done.
            //
            goto Ret;
        }
    }

    //
    // No cached card was found, or this is a "by Serial Number" search,
    // so continue the search via
    // the smart card subsystem.
    //

    dwSts = SCardEstablishContext(
        SCARD_SCOPE_USER, NULL, NULL, &pCardMatchData->hSCardCtx);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    memset(&ocnx, 0, sizeof(ocnx));
    memset(&ocsc, 0, sizeof(ocsc));

    ocsc.dwStructSize = sizeof(ocsc);
    ocsc.lpfnCheck = FindCardCheckProc;
    ocsc.lpfnConnect = FindCardConnectProc;
    ocsc.lpfnDisconnect = FindCardDisconnectProc;
    ocsc.dwShareMode = pCardMatchData->dwShareMode;
    ocsc.dwPreferredProtocols = pCardMatchData->dwPreferredProtocols;
    ocsc.pvUserData = (PVOID) pCardMatchData;

    ocnx.dwStructSize = sizeof(ocnx);
    ocnx.pvUserData = (PVOID) pCardMatchData;
    ocnx.hSCardContext = pCardMatchData->hSCardCtx;
    ocnx.pOpenCardSearchCriteria = &ocsc;
    ocnx.lpstrCard = pCardMatchData->wszMatchedCard;
    ocnx.nMaxCard = pCardMatchData->cchMatchedCard;
    ocnx.lpstrRdr = pCardMatchData->wszMatchedReader;
    ocnx.nMaxRdr = pCardMatchData->cchMatchedReader;
    ocnx.lpfnConnect = FindCardConnectProc;
    ocnx.dwShareMode = pCardMatchData->dwShareMode;
    ocnx.dwPreferredProtocols = pCardMatchData->dwPreferredProtocols;
    
    //
    // The first attempt at finding a matching card should be done 
    // "silently."  We want to control whether card selection UI is
    // displayed, depending on whether a card is currently in the
    // reader, and depending on the context flags.
    // 
    ocnx.dwFlags = SC_DLG_NO_UI;
    pCardMatchData->dwUIFlags = ocnx.dwFlags;

    dwSts = SCardUIDlgSelectCardW(&ocnx);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        break; // Success, we're done.

    case SCARD_E_CANCELLED:

        if (NTE_TOKEN_KEYSET_STORAGE_FULL == pCardMatchData->dwError)
        {
            dwSts = (DWORD) NTE_TOKEN_KEYSET_STORAGE_FULL;
            break;
        }

        if (    (CRYPT_SILENT & pCardMatchData->dwCtxFlags) ||
                (CRYPT_VERIFYCONTEXT & pCardMatchData->dwCtxFlags))
        {
            //
            // We couldn't show UI, and the caller specified a key container
            // (or simply asked for the default) that we couldn't find.  Apps
            // such as enrollment station expect that we return NTE_BAD_KEYSET
            // in this scenario.
            //

            if (SCARD_E_NO_KEY_CONTAINER == pCardMatchData->dwError)
            {
                dwSts = (DWORD) NTE_BAD_KEYSET;
                break;
            }

            dwSts = (DWORD) SCARD_E_NO_SMARTCARD;
            break;
        }

        // Allow UI and try again.
        ocnx.dwFlags = 0;
        pCardMatchData->dwUIFlags = ocnx.dwFlags;

        dwSts = SCardUIDlgSelectCardW(&ocnx);

        //
        // If scarddlg thinks the match was successful, but the matched card
        // is actually full, then report that error.  This is done so that the
        // user can manually select a "full" card in the UI, and 
        // certificate enrollment can proceed by re-using the existing key.
        //
        if (ERROR_SUCCESS == dwSts &&
            NTE_TOKEN_KEYSET_STORAGE_FULL == pCardMatchData->dwError)
        {
            dwSts = (DWORD) NTE_TOKEN_KEYSET_STORAGE_FULL;
            break;
        }

        break;

    default:
        break; // Return error to caller.
    }

    if (ERROR_SUCCESS == dwSts)
    {
        // Make sure scarddlg didn't fail unexpectedly
        if (0 == ocnx.hCardHandle)
        {
            dwSts = SCARD_E_NO_SMARTCARD;
            goto Ret;
        }

        DsysAssert(NULL != pCardMatchData->pUIMatchedCardState);

        pCardMatchData->pCardState = pCardMatchData->pUIMatchedCardState;

        dwSts = CspEnterCriticalSection(
            &pCardMatchData->pCardState->cs);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (0 == pCardMatchData->pCardState->pCardData->hScard)
        {
            pCardMatchData->pCardState->pCardData->hScard = ocnx.hCardHandle;
            ocnx.hCardHandle = 0;
            pCardMatchData->pCardState->pCardData->hSCardCtx = 
                pCardMatchData->hSCardCtx;
            pCardMatchData->hSCardCtx = 0;
        }

        CspLeaveCriticalSection(
            &pCardMatchData->pCardState->cs);

        ocnx.hCardHandle = 0;
    }

Ret:

    DsysAssert(FALSE == pCardMatchData->fTransacted);
    DsysAssert(0 == pCardMatchData->hSCard);

    if (0 != ocnx.hCardHandle)
        SCardDisconnect(ocnx.hCardHandle, SCARD_LEAVE_CARD);

    if (0 != pCardMatchData->hSCardCtx && ERROR_SUCCESS != dwSts)
        SCardReleaseContext(pCardMatchData->hSCardCtx);

    LOG_END_FUNCTION(FindCard, dwSts);

    return dwSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\basecsp\capi.c ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    Windows for Smart Cards Base CSP

Abstract:


Author:

    Dan Griffin

Notes:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>

#pragma warning(push)
#pragma warning(disable:4201) 
// Disable error C4201 in public header 
//  nonstandard extension used : nameless struct/union
#include <winscard.h>
#pragma warning(pop)

#include <cspdk.h>
#include <md5.h>
#include <stdlib.h>
#include "basecsp.h"
#include "cardmod.h"
#include "datacach.h"
#include "pincache.h"
#include "pinlib.h"
#include "resource.h"
#include "debug.h"
#include "compress.h"

extern DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );

//
// Debugging Macros
//
#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_CSP, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_CSP, "%s: Leaving, status: 0x%x\n", #x, y)); }

#define LOG_BEGIN_CRYPTOAPI(x)                                          \
    { DebugLog((DEB_TRACE_CRYPTOAPI, "%s: Entering\n", #x)); }
    
#define LOG_END_CRYPTOAPI(x, y)                                         \
    { DebugLog((DEB_TRACE_CRYPTOAPI, "%s: Leaving, status: 0x%x\n", #x, y)); }
//
// When receiving an encoded certificate from the calling application,
// the current interface doesn't include a length, so we have to try
// to determine the length of the encoded blob ourselves.  If there's an
// encoding error, we'll just walk off the end of the buffer, so set this
// maximum. 
//                                                         
#define cbENCODED_CERT_OVERFLOW                     5000 // Bytes

#define PROVPATH            "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"
#define PROVPATH_LEN        sizeof(PROVPATH)

//
// Local structure definitions
//

//
// This is a node for the list of algorithms supported by this CSP and a given
// card.
//
typedef struct _SUPPORTED_ALGORITHM
{
    struct _SUPPORTED_ALGORITHM *pNext;
    PROV_ENUMALGS_EX EnumalgsEx;
} SUPPORTED_ALGORITHM, *PSUPPORTED_ALGORITHM;

//
// Type: LOCAL_USER_CONTEXT
//
// This is the HCRYPTPROV type for the base CSP.
//
#define LOCAL_USER_CONTEXT_CURRENT_VERSION 1

typedef struct _LOCAL_USER_CONTEXT
{
    DWORD dwVersion;
    PCARD_STATE pCardState;
    CSP_REG_SETTINGS RegSettings;
    BOOL fHoldingTransaction;
    BYTE bContainerIndex;

    // This is a multi-string of all of the container names present on 
    // the card associated with this context.  This member is only used
    // by CryptGetProvParam PP_ENUMCONTAINERS.  Access is not synchronized.
    LPSTR mszEnumContainers;
    LPSTR mszCurrentEnumContainer;

    // This is a list of algorithms supported by this CSP and card.  This is
    // only accessed via CryptGetProvParam PP_ENUMALGS and PP_ENUMALGS_EX.
    // Access is not synchronized.
    PSUPPORTED_ALGORITHM pSupportedAlgs;
    PSUPPORTED_ALGORITHM pCurrentAlg;

} LOCAL_USER_CONTEXT, *PLOCAL_USER_CONTEXT;

//
// Type: LOCAL_KEY_CONTEXT
//
// This is the HCRYPTKEY type for the base CSP.
//
typedef struct _LOCAL_KEY_CONTEXT
{
    PBYTE pbArchivablePrivateKey;
    DWORD cbArchivablePrivateKey;

} LOCAL_KEY_CONTEXT, *PLOCAL_KEY_CONTEXT;

//
// Type: LOCAL_HASH_CONTEXT
//
// This is the HCRYPTHASH type for the base CSP.
//
/*
typedef struct _LOCAL_HASH_CONTEXT
{
    //
    // Don't need anything here yet.
    //

} LOCAL_HASH_CONTEXT, *PLOCAL_HASH_CONTEXT;
*/

//
// Global variables
//

CSP_STRING      g_Strings [] =
{
    { NULL, IDS_PINDIALOG_NEWPIN_MISMATCH }, 
    { NULL, IDS_PINDIALOG_MSGBOX_TITLE }, 
    { NULL, IDS_PINDIALOG_WRONG_PIN }, 
    { NULL, IDS_PINDIALOG_PIN_RETRIES } 
};

CSP_STATE       g_CspState;             

CARD_KEY_SIZES DefaultCardKeySizes = 
{ 
    CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 
};

// 
// Registry Initialization 
//

//
// Function: RegConfigAddEntries
//
DWORD WINAPI RegConfigAddEntries(
    IN HKEY hKey)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD iEntry = 0;

    for (   iEntry = 0; 
            iEntry < sizeof(RegConfigValues) / sizeof(RegConfigValues[0]); 
            iEntry++)
    {
        dwSts = RegSetValueExW(
            hKey, 
            RegConfigValues[iEntry].wszValueName,
            0L, 
            REG_DWORD, 
            (LPBYTE) &RegConfigValues[iEntry].dwDefValue,
            sizeof(DWORD));

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }

Ret:
    
    return dwSts;
}

//
// Function: RegConfigGetSettings
//
DWORD WINAPI RegConfigGetSettings(
    IN OUT PCSP_REG_SETTINGS pRegSettings)
{
    DWORD dwSts = ERROR_SUCCESS;
    HKEY hKey = 0;
    DWORD dwVal = 0;
    DWORD cbVal = sizeof(DWORD);

    dwSts = RegOpenProviderKey(&hKey, KEY_READ);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = RegQueryValueExW(
        hKey,
        wszREG_DEFAULT_KEY_LEN,
        NULL,
        NULL,
        (LPBYTE) &dwVal,
        &cbVal);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pRegSettings->cDefaultPrivateKeyLenBits = dwVal;
    dwVal = 0;
    cbVal = sizeof(DWORD);

    dwSts = RegQueryValueExW(
        hKey,
        wszREG_REQUIRE_CARD_KEY_GEN,
        NULL,
        NULL,
        (LPBYTE) &dwVal,
        &cbVal);
                 
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pRegSettings->fRequireOnCardPrivateKeyGen = (BOOL) dwVal;
    dwVal = 0;
    cbVal = sizeof(DWORD);
    
Ret:    
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}
    
// 
// CSP State Management Routines
//

//
// Function: DeleteCspState
//
// Purpose: Delete the global state data structure for this CSP.
//          Should be called during DLL_PROCESS_DETACH.
//
DWORD DeleteCspState(void)
{
    CspDeleteCriticalSection(&g_CspState.cs);

    if (0 != g_CspState.hCache)
        CacheDeleteCache(g_CspState.hCache);

    memset(&g_CspState, 0, sizeof(g_CspState));

    return ERROR_SUCCESS;
}

//
// Function: InitializeCspState
//
// Purpose: Setup the global state data structure for this CSP.
//          Should be called during DLL_PROCESS_ATTACH.
//
DWORD InitializeCspState(
    IN HMODULE hCspModule)
{
    DWORD dwSts = ERROR_SUCCESS;
    CACHE_INITIALIZE_INFO CacheInitInfo;
    BOOL fSuccess = FALSE;

    memset(&g_CspState, 0, sizeof(g_CspState));
    memset(&CacheInitInfo, 0, sizeof(CacheInitInfo));

    g_CspState.hCspModule = hCspModule;

    dwSts = CspInitializeCriticalSection(
        &g_CspState.cs);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    CacheInitInfo.dwType = CACHE_TYPE_IN_PROC;

    dwSts = CacheInitializeCache(
        &g_CspState.hCache,
        &CacheInitInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    fSuccess = TRUE;
Ret:
    if (FALSE == fSuccess)
        DeleteCspState();

    return dwSts;
}

//
// Function: GetCspState
//
// Purpose: Acquire a pointer to the global state data structure
//          for this CSP.  This function should always be used,
//          rather than referring to the global object directly.
//
DWORD GetCspState(
    IN OUT PCSP_STATE *ppCspState)
{
    DWORD dwSts;

    dwSts = CspEnterCriticalSection(
        &g_CspState.cs);
    
    if (ERROR_SUCCESS != dwSts)
        return dwSts;

    g_CspState.dwRefCount++;

    CspLeaveCriticalSection(
        &g_CspState.cs);

    *ppCspState = &g_CspState;

    return ERROR_SUCCESS;
}

//
// Function: ReleaseCspState
//
// Purpose: Signal that the caller's pointer to the global
//          state data structure is no longer being used.
//
DWORD ReleaseCspState(
    IN OUT PCSP_STATE *ppCspState)
{
    DWORD dwSts;

    dwSts = CspEnterCriticalSection(
        &g_CspState.cs);

    if (ERROR_SUCCESS != dwSts)
        return dwSts;

    g_CspState.dwRefCount--;

    CspLeaveCriticalSection(
        &g_CspState.cs);

    *ppCspState = NULL;

    return ERROR_SUCCESS;
}

//
// Pin Management Routines
//

//
// Struct: VERIFY_PIN_CALLBACK_DATA
//
typedef struct _VERIFY_PIN_CALLBACK_DATA
{
    PUSER_CONTEXT pUserCtx;
    LPWSTR wszUserId;
} VERIFY_PIN_CALLBACK_DATA, *PVERIFY_PIN_CALLBACK_DATA;

//
// Callback for verifying a submitted pin, or requested pin change, from the 
// user via the pin prompt UI.  
//
DWORD WINAPI VerifyPinFromUICallback(
    IN PPINCACHE_PINS pPins, 
    IN PVOID pvCallbackCtx)
{
    PPIN_SHOW_GET_PIN_UI_INFO pInfo =     
        (PPIN_SHOW_GET_PIN_UI_INFO) pvCallbackCtx;
    PVERIFY_PIN_CALLBACK_DATA pData = 
        (PVERIFY_PIN_CALLBACK_DATA) pInfo->pvCallbackContext;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pData->pUserCtx->pvLocalUserContext;

    // Determine if a Change Pin operation has been requested
    if (NULL != pPins->pbNewPin)
    {
        // A pin change needs to go through the caching layer to ensure that
        // the cache and associated counters get updated.
        return CspChangeAuthenticator(
            pLocal->pCardState,
            pData->wszUserId,
            pPins->pbCurrentPin,
            pPins->cbCurrentPin,
            pPins->pbNewPin,
            pPins->cbNewPin,
            0,
            &pInfo->cAttemptsRemaining);
    }

    // For the simple submit pin, this pin is directly from the user, so we 
    // pass it directly to the card rather than going through the caching 
    // layer.
    return pLocal->pCardState->pCardData->pfnCardSubmitPin(
        pLocal->pCardState->pCardData,
        pData->wszUserId,
        pPins->pbCurrentPin,
        pPins->cbCurrentPin,
        &pInfo->cAttemptsRemaining);
}

//
// Function: VerifyPinCallback
//
DWORD WINAPI VerifyPinCallback(
    IN PPINCACHE_PINS pPins, 
    IN PVOID pvCallbackCtx)
{
    PVERIFY_PIN_CALLBACK_DATA pData = 
        (PVERIFY_PIN_CALLBACK_DATA) pvCallbackCtx;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pData->pUserCtx->pvLocalUserContext;

    // This pin is from the pin cache, so filter it through the caching layer.
    return CspSubmitPin(
        pLocal->pCardState,
        pData->wszUserId,
        pPins->pbCurrentPin,
        pPins->cbCurrentPin,
        NULL);
}

//
// Function: CspAuthenticateUser
//
DWORD WINAPI CspAuthenticateUser(
    IN PUSER_CONTEXT pUserCtx)
{
    VERIFY_PIN_CALLBACK_DATA CallbackCtx;
    DWORD dwError = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserContext = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    PIN_SHOW_GET_PIN_UI_INFO PinUIInfo;
    PINCACHE_PINS Pins;
    
    LOG_BEGIN_FUNCTION(CspAuthenticateUser);

    memset(&Pins, 0, sizeof(Pins));
    memset(&PinUIInfo, 0, sizeof(PinUIInfo));
    memset(&CallbackCtx, 0, sizeof(CallbackCtx));

    CallbackCtx.pUserCtx = pUserCtx;
    CallbackCtx.wszUserId = wszCARD_USER_USER;

    dwError = PinCachePresentPin(
        pLocalUserContext->pCardState->hPinCache,
        VerifyPinCallback,
        (PVOID) &CallbackCtx);

    if (SCARD_W_CARD_NOT_AUTHENTICATED == dwError ||
        ERROR_EMPTY == dwError ||
        SCARD_W_WRONG_CHV == dwError)
    {
        PinCacheFlush(&pLocalUserContext->pCardState->hPinCache);

        // No pin is cached.  Is the context "silent"?

        if (CRYPT_VERIFYCONTEXT & pUserCtx->dwFlags ||
            CRYPT_SILENT & pUserCtx->dwFlags)
        {
            dwError = (DWORD) NTE_SILENT_CONTEXT;
            goto Ret;
        }

        // Context is not silent.  Show UI to let the user enter a pin.

        pUserCtx->pVTableW->FuncReturnhWnd(&PinUIInfo.hClientWindow);

        PinUIInfo.pStrings = g_Strings;
        PinUIInfo.hDlgResourceModule = GetModuleHandle(L"basecsp.dll");
        PinUIInfo.wszPrincipal = wszCARD_USER_USER;
        PinUIInfo.pfnVerify = VerifyPinFromUICallback;
        PinUIInfo.pvCallbackContext = (PVOID) &CallbackCtx;
        PinUIInfo.wszCardName = 
            pLocalUserContext->pCardState->wszSerialNumber;

        dwError = PinShowGetPinUI(&PinUIInfo);

        if (ERROR_SUCCESS != dwError || NULL == PinUIInfo.pbPin)
            goto Ret;

        Pins.cbCurrentPin = PinUIInfo.cbPin;
        Pins.pbCurrentPin = PinUIInfo.pbPin;

        //
        // The user entered a pin that has been successfully verified by the 
        // card.  The Pin UI should have already converted the pin from
        // string form into bytes that we can send to the card.
        // Cache the pin.
        //
        dwError = PinCacheAdd(
            &pLocalUserContext->pCardState->hPinCache,
            &Pins,
            VerifyPinCallback,
            (PVOID) &CallbackCtx);

        if (ERROR_SUCCESS != dwError)
            goto Ret;
    }

    pLocalUserContext->pCardState->fAuthenticated = TRUE;

Ret:

    if (PinUIInfo.pbPin)
    {
        RtlSecureZeroMemory(PinUIInfo.pbPin, PinUIInfo.cbPin);
        CspFreeH(PinUIInfo.pbPin);
    }

    LOG_END_FUNCTION(CspAuthenticateUser, dwError);

    return dwError;
}

//
// Frees the memory consumed by the supported algorithms list.
//
DWORD FreeSupportedAlgorithmsList(PLOCAL_USER_CONTEXT pLocal)
{
    DWORD dwError = ERROR_SUCCESS;
    PSUPPORTED_ALGORITHM pCurrent = NULL;

    DsysAssert(NULL != pLocal->pSupportedAlgs);

    while (NULL != pLocal->pSupportedAlgs)
    {
        pCurrent = pLocal->pSupportedAlgs;
        pLocal->pSupportedAlgs = pCurrent->pNext;

        CspFreeH(pCurrent);
    }

    return ERROR_SUCCESS;
}

// 
// Builds a list of algorithms supported by this CSP and smartcard.
//
DWORD BuildSupportedAlgorithmsList(PUSER_CONTEXT pUserCtx)
{
    PLOCAL_USER_CONTEXT pLocal = (PLOCAL_USER_CONTEXT) 
        pUserCtx->pvLocalUserContext;
    DWORD dwSts = ERROR_SUCCESS;
    CARD_KEY_SIZES CardKeySizes;
    PROV_ENUMALGS_EX EnumalgsEx;
    DWORD cbData = sizeof(EnumalgsEx);
    PSUPPORTED_ALGORITHM pCurrent = NULL;
    DWORD dwFlag = CRYPT_FIRST;

    DsysAssert(NULL != pLocal);
    DsysAssert(NULL == pLocal->pSupportedAlgs);

    memset(&CardKeySizes, 0, sizeof(CardKeySizes));
    memset(&EnumalgsEx, 0, sizeof(EnumalgsEx));

    while (TRUE == CryptGetProvParam(
        pUserCtx->hSupportProv,
        PP_ENUMALGS_EX,
        (PBYTE) &EnumalgsEx,
        &cbData,
        dwFlag))
    {
        dwFlag = CRYPT_NEXT;

        if (NULL == pCurrent)
        {
            // First item
            pLocal->pSupportedAlgs = (PSUPPORTED_ALGORITHM) CspAllocH(
                sizeof(SUPPORTED_ALGORITHM));

            LOG_CHECK_ALLOC(pLocal->pSupportedAlgs);

            pCurrent = pLocal->pSupportedAlgs;
        }
        else
        {
            // Adding an item
            pCurrent->pNext = (PSUPPORTED_ALGORITHM) CspAllocH(
                sizeof(SUPPORTED_ALGORITHM));

            LOG_CHECK_ALLOC(pCurrent->pNext);

            pCurrent = pCurrent->pNext;
        }

        memcpy(
            &pCurrent->EnumalgsEx,
            &EnumalgsEx,
            sizeof(EnumalgsEx));

        memset(&EnumalgsEx, 0, sizeof(EnumalgsEx));

        // Special handling for public key algs since they depend on what the 
        // target card actually supports
        switch (pCurrent->EnumalgsEx.aiAlgid)
        {
        case CALG_RSA_KEYX:

            // If there's no CARD_STATE in this context, that should mean this
            // is a VerifyContext with no card inserted.  MMC expects that 
            // algorithm enumeration is successful without a card, so provide
            // some default public key values in that case.

            if (NULL == pLocal->pCardState)
            {
                DsysAssert(CRYPT_VERIFYCONTEXT & pUserCtx->dwFlags);

                memcpy(
                    &CardKeySizes, 
                    &DefaultCardKeySizes, 
                    sizeof(CARD_KEY_SIZES));

                break;
            }

            dwSts = CspQueryKeySizes(
                pLocal->pCardState,
                AT_KEYEXCHANGE,
                0,
                &CardKeySizes);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            break;

        case CALG_RSA_SIGN:

            if (NULL == pLocal->pCardState)
            {
                DsysAssert(CRYPT_VERIFYCONTEXT & pUserCtx->dwFlags);

                memcpy(
                    &CardKeySizes, 
                    &DefaultCardKeySizes, 
                    sizeof(CARD_KEY_SIZES));

                break;
            }

            dwSts = CspQueryKeySizes(
                pLocal->pCardState,
                AT_SIGNATURE,
                0,
                &CardKeySizes);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            break;

        default:
            // Go to the next alg
            continue;
        }

        pCurrent->EnumalgsEx.dwDefaultLen = CardKeySizes.dwDefaultBitlen;
        pCurrent->EnumalgsEx.dwMaxLen = CardKeySizes.dwMaximumBitlen;
        pCurrent->EnumalgsEx.dwMinLen = CardKeySizes.dwMinimumBitlen;

        memset(&CardKeySizes, 0, sizeof(CardKeySizes));
    }

    if (ERROR_NO_MORE_ITEMS == (dwSts = GetLastError()))
        dwSts = ERROR_SUCCESS;

Ret:

    if (ERROR_SUCCESS != dwSts && NULL != pLocal->pSupportedAlgs)
        FreeSupportedAlgorithmsList(pLocal);

    return dwSts;
}

//
// Function: DeleteLocalUserContext
//
void DeleteLocalUserContext(PLOCAL_USER_CONTEXT pLocalUserCtx)
{
    if (NULL != pLocalUserCtx->mszEnumContainers)
    {
        CspFreeH(pLocalUserCtx->mszEnumContainers);
        pLocalUserCtx->mszEnumContainers = NULL;
    }

    if (NULL != pLocalUserCtx->pSupportedAlgs)
        FreeSupportedAlgorithmsList(pLocalUserCtx);

    // Don't free the card state here, since those structures are shared.
    pLocalUserCtx->pCardState = NULL;
}

//
// Function: CleanupContainerInfo
//
void CleanupContainerInfo(
    IN OUT PCONTAINER_INFO pContainerInfo)
{
    if (pContainerInfo->pbKeyExPublicKey)
    {
        CspFreeH(pContainerInfo->pbKeyExPublicKey);
        pContainerInfo->pbKeyExPublicKey = NULL;
    }

    if (pContainerInfo->pbSigPublicKey)
    {
        CspFreeH(pContainerInfo->pbSigPublicKey);
        pContainerInfo->pbSigPublicKey = NULL;
    }
}

//
// Function: GetKeyModulusLength
//
DWORD GetKeyModulusLength(
    IN PUSER_CONTEXT pUserCtx,
    IN DWORD dwKeySpec,
    OUT PDWORD pcbModulus)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocal =
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    CONTAINER_MAP_RECORD ContainerRecord;

    *pcbModulus = 0;

    memset(&ContainerRecord, 0, sizeof(ContainerRecord));

    wcscpy(ContainerRecord.wszGuid, pUserCtx->wszBaseContainerName);

    dwSts = ContainerMapFindContainer(
        pLocal->pCardState,
        &ContainerRecord,
        NULL);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    switch (dwKeySpec)
    {
    case AT_SIGNATURE:

        if (0 == ContainerRecord.wSigKeySizeBits)
        {
            dwSts = (DWORD) NTE_NO_KEY;
            goto Ret;
        }

        *pcbModulus = ContainerRecord.wSigKeySizeBits / 8;
        break;

    case AT_KEYEXCHANGE:

        if (0 == ContainerRecord.wKeyExchangeKeySizeBits)
        {
            dwSts = (DWORD) NTE_NO_KEY;
            goto Ret;
        }

        *pcbModulus = ContainerRecord.wKeyExchangeKeySizeBits / 8;
        break;

    default:

        dwSts = (DWORD) NTE_BAD_ALGID;
        goto Ret;
    }
    
Ret:

    return dwSts;
}   

//
// Finds the index corresponding to a specified container in the card 
// container map file.  Returns the contents the container map file.
//
// The container name can optionally be omitted, in which case the map file
// is simply read and returned.
//
DWORD I_ContainerMapFind(
    IN              PCARD_STATE pCardState,
    IN OPTIONAL     LPWSTR wszContainerGuid,
    OUT OPTIONAL    PBYTE pbIndex,
    OUT             PCONTAINER_MAP_RECORD *ppContainerMapFile,
    OUT             PBYTE pcContainerMapFile)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbContainerMap;
    BYTE iContainer = 0;

    memset(&dbContainerMap, 0, sizeof(dbContainerMap));

    *ppContainerMapFile = NULL;
    *pcContainerMapFile = 0;

    // Read the container map file from the card
    dwSts = CspReadFile(
        pCardState,
        wszCONTAINER_MAP_FILE_FULL_PATH,
        0,
        &dbContainerMap.pbData,
        &dbContainerMap.cbData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (0 != dbContainerMap.cbData)
    {
        // Expect that the file contains an exact multiple of the record size
        DsysAssert(0 == (dbContainerMap.cbData % sizeof(CONTAINER_MAP_RECORD)));

        *ppContainerMapFile = (PCONTAINER_MAP_RECORD) dbContainerMap.pbData;
        *pcContainerMapFile = (BYTE)
            (dbContainerMap.cbData / sizeof(CONTAINER_MAP_RECORD));
        dbContainerMap.pbData = NULL;
    }

    // See if caller just wanted us to return the map file contents
    if (NULL == wszContainerGuid)
        goto Ret;

    for (   iContainer = 0; 
            iContainer < *pcContainerMapFile;
            iContainer++)
    {
        if (0 == wcscmp(
            wszContainerGuid,
            (*ppContainerMapFile)[iContainer].wszGuid) &&
            (CONTAINER_MAP_VALID_CONTAINER & 
                (*ppContainerMapFile)[iContainer].bFlags))
        {
            *pbIndex = iContainer;
            goto Ret;
        }
    }

    dwSts = NTE_BAD_KEYSET;

Ret:

    if (dbContainerMap.pbData)
        CspFreeH(dbContainerMap.pbData);

    return dwSts;
}

//
// Returns the number of valid containers present on the card.  Optionally,
// returns a list of the container names in a multi-string.
//
// The returned *mwszContainers pointer must be freed by the caller.
//
DWORD ContainerMapEnumContainers(
    IN              PCARD_STATE pCardState,
    OUT             PBYTE pcContainers,
    OUT OPTIONAL    LPWSTR *mwszContainers)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE cContainerMap = 0;
    BYTE iContainer = 0;
    DWORD cchCurrent = 0;
    DWORD cchCumulative = 0;

    *pcContainers = 0;

    if (NULL != mwszContainers)
        *mwszContainers = NULL;

    dwSts = I_ContainerMapFind(
        pCardState,
        NULL,
        NULL,
        &pContainerMap,
        &cContainerMap);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // We'll make two passes through the container map file.  The first pass 
    // counts the number of valid containers present.  This allows us to make
    // a single allocation large enough for a multi-string consisting of all
    // of the valid container names.  We'll pick up the names in the second
    // pass through the file.
    //

    // Pass 1
    for (iContainer = 0; iContainer < cContainerMap; iContainer++)
    {
        if (CONTAINER_MAP_VALID_CONTAINER & pContainerMap[iContainer].bFlags)
            *pcContainers += 1;
    }

    if (0 == *pcContainers || NULL == mwszContainers)
        goto Ret;

    // Build a big enough buffer
    *mwszContainers = (LPWSTR) CspAllocH(
        ((*pcContainers * (1 + MAX_CONTAINER_NAME_LEN)) + 1) * sizeof(WCHAR));

    // Pass 2
    for (iContainer = 0; iContainer < cContainerMap; iContainer++)
    {
        if (CONTAINER_MAP_VALID_CONTAINER & pContainerMap[iContainer].bFlags)
        {
            cchCurrent = wcslen(pContainerMap[iContainer].wszGuid);

            memcpy(
                *mwszContainers + cchCumulative,
                pContainerMap[iContainer].wszGuid,
                cchCurrent * sizeof(WCHAR));

            cchCumulative += cchCurrent + 1;
        }
    }

Ret:

    if (pContainerMap)
        CspFreeH(pContainerMap);

    return dwSts;
}

//
// Searches for the named container on the card.  The container to look for
// must be in pContainer->wszGuid.  If the container is not found, 
// NTE_BAD_KEYSET is returned.
//
DWORD ContainerMapFindContainer(
    IN              PCARD_STATE pCardState,
    IN OUT          PCONTAINER_MAP_RECORD pContainer,
    OUT OPTIONAL    PBYTE pbContainerIndex)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE bIndex = 0;
    BYTE cContainerMap = 0;

    dwSts = I_ContainerMapFind(
        pCardState,
        pContainer->wszGuid,
        &bIndex,
        &pContainerMap,
        &cContainerMap);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    memcpy(
        (PBYTE) pContainer,
        (PBYTE) (pContainerMap + bIndex),
        sizeof(CONTAINER_MAP_RECORD));

    if (NULL != pbContainerIndex)
        *pbContainerIndex = bIndex;

Ret:

    if (pContainerMap)
        CspFreeH(pContainerMap);

    return dwSts;
}

//
// Searches for the default container on the card.  If no default container is
// found, NTE_BAD_KEYSET is returned.
//
DWORD ContainerMapGetDefaultContainer(
    IN              PCARD_STATE pCardState,
    OUT             PCONTAINER_MAP_RECORD pContainer,
    OUT OPTIONAL    PBYTE pbContainerIndex)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE cContainerMap = 0;
    BYTE iContainer = 0;

    dwSts = I_ContainerMapFind(
        pCardState,
        NULL,
        NULL,
        &pContainerMap,
        &cContainerMap);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    for (iContainer = 0; iContainer < cContainerMap; iContainer++)
    {
        if ((pContainerMap[iContainer].bFlags & 
                CONTAINER_MAP_VALID_CONTAINER) &&
            (pContainerMap[iContainer].bFlags & 
                CONTAINER_MAP_DEFAULT_CONTAINER))
        {
            memcpy(
                (PBYTE) pContainer,
                (PBYTE) (pContainerMap + iContainer),
                sizeof(CONTAINER_MAP_RECORD));

            if (NULL != pbContainerIndex)
                *pbContainerIndex = iContainer;

            goto Ret;
        }
    }

    dwSts = NTE_BAD_KEYSET;

Ret:
    
    if (pContainerMap)
        CspFreeH(pContainerMap);

    return dwSts;
}

//
// Sets the default container on the card.
//
DWORD ContainerMapSetDefaultContainer(
    IN  PCARD_STATE pCardState,
    IN  LPWSTR wszContainerGuid)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE bIndex = 0;
    BYTE cContainerMap = 0;
    BYTE iContainer = 0;
    DATA_BLOB dbContainerMap;

    memset(&dbContainerMap, 0, sizeof(dbContainerMap));

    dwSts = I_ContainerMapFind(
        pCardState,
        wszContainerGuid,
        &bIndex,
        &pContainerMap,
        &cContainerMap);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // If some other container is currently marked as the default, unmark it.
    //

    for (iContainer = 0; iContainer < cContainerMap; iContainer++)
    {
        if (pContainerMap[iContainer].bFlags & CONTAINER_MAP_DEFAULT_CONTAINER)
            pContainerMap[iContainer].bFlags &= ~CONTAINER_MAP_DEFAULT_CONTAINER;
    }

    pContainerMap[bIndex].bFlags |= CONTAINER_MAP_DEFAULT_CONTAINER;

    dbContainerMap.pbData = (PBYTE) pContainerMap;
    dbContainerMap.cbData = cContainerMap * sizeof(CONTAINER_MAP_RECORD);

    // Write the updated map file to the card
    dwSts = CspWriteFile(
        pCardState,
        wszCONTAINER_MAP_FILE_FULL_PATH,
        0,
        dbContainerMap.pbData,
        dbContainerMap.cbData);

Ret:
    
    if (pContainerMap)
        CspFreeH(pContainerMap);

    return dwSts;
}

//
// Adds a new container record to the container map.  If the specified 
// container already exists, replaces the existing keyset (if any) with
// the one provided.
//
// If cKeySizeBits is zero, assumes that a container with no keys is being
// added.
//
DWORD ContainerMapAddContainer(
    IN              PCARD_STATE pCardState,
    IN              LPWSTR pwszContainerGuid,
    IN              DWORD cKeySizeBits,
    IN              DWORD dwKeySpec,
    IN              BOOL fGetNameOnly,
    OUT             PBYTE pbContainerIndex)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE cContainerMap = 0;
    BYTE iContainer = 0;
    DATA_BLOB dbContainerMap;
    PCONTAINER_MAP_RECORD pNewMap = NULL;
    BOOL fExistingContainer = FALSE;

    memset(&dbContainerMap, 0, sizeof(dbContainerMap));

    // See if this container already exists
    dwSts = I_ContainerMapFind(
        pCardState,
        pwszContainerGuid,
        &iContainer,
        &pContainerMap,
        &cContainerMap);

    switch (dwSts)
    {
    case NTE_BAD_KEYSET:

        //
        // This is a new container that does not already exist.
        // Look for an existing "empty" slot in the container map file
        //

        for (iContainer = 0; iContainer < cContainerMap; iContainer++)
        {
            if (0 == (pContainerMap[iContainer].bFlags & 
                      CONTAINER_MAP_VALID_CONTAINER))
                break;
        }

        break;

    case ERROR_SUCCESS:

        //
        // This container already exists.  The new keyset will be added to it,
        // possibly replacing an existing keyset of the same type.
        //

        fExistingContainer = TRUE;
        break;

    default:

        goto Ret;
    }

    //
    // Pass the container index that we're using back to the caller; that may 
    // be all that was requested.
    //

    *pbContainerIndex = iContainer;

    if (fGetNameOnly)
        goto Ret;

    if (iContainer == cContainerMap)
    {
        //
        // No empty slot was found in the container map.  We'll have to grow
        // the map and add the new container to the end.
        //

        pNewMap = (PCONTAINER_MAP_RECORD) CspAllocH(
            (cContainerMap + 1) * sizeof(CONTAINER_MAP_RECORD));

        LOG_CHECK_ALLOC(pNewMap);

        memcpy(
            (PBYTE) pNewMap,
            (PBYTE) pContainerMap,
            cContainerMap * sizeof(CONTAINER_MAP_RECORD));

        CspFreeH(pContainerMap);
        pContainerMap = pNewMap;
        pNewMap = NULL;
        cContainerMap++;
    }

    //
    // Update the container map file and write it to the card
    //

    pContainerMap[iContainer].bFlags |= CONTAINER_MAP_VALID_CONTAINER;

    if (0 != cKeySizeBits)
    {
        switch (dwKeySpec)
        {
        case AT_KEYEXCHANGE:
            pContainerMap[iContainer].wKeyExchangeKeySizeBits = (WORD) cKeySizeBits;
            break;
        case AT_SIGNATURE:
            pContainerMap[iContainer].wSigKeySizeBits = (WORD) cKeySizeBits;
            break;
        default:
            dwSts = NTE_BAD_ALGID;
            goto Ret;
        }
    }

    if (FALSE == fExistingContainer)
    {
        wcscpy(
            pContainerMap[iContainer].wszGuid,
            pwszContainerGuid);
    }

    dbContainerMap.pbData = (PBYTE) pContainerMap;
    dbContainerMap.cbData = cContainerMap * sizeof(CONTAINER_MAP_RECORD);

    dwSts = CspWriteFile(
        pCardState,
        wszCONTAINER_MAP_FILE_FULL_PATH,
        0,
        dbContainerMap.pbData,
        dbContainerMap.cbData);

Ret:

    if (pContainerMap)
        CspFreeH(pContainerMap);
    if (pNewMap)
        CspFreeH(pNewMap);

    return dwSts;
}

// 
// Deletes a container record from the container map.  Returns NTE_BAD_KEYSET
// if the specified container does not exist.
//
// If the deleted container was the default, finds the first valid container
// remaining on the card and marks it as the new default.
//
DWORD ContainerMapDeleteContainer(
    IN              PCARD_STATE pCardState,
    IN              LPWSTR pwszContainerGuid,
    OUT             PBYTE pbContainerIndex)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCONTAINER_MAP_RECORD pContainerMap = NULL;
    BYTE dwIndex = 0;
    BYTE cContainerMap = 0;
    DATA_BLOB dbContainerMap;
    BYTE iContainer = 0;

    memset(&dbContainerMap, 0, sizeof(dbContainerMap));

    //
    // See if this container already exists.  If it does, invalidate its entry
    // in the map file and write the file back to the card.
    //

    dwSts = I_ContainerMapFind(
        pCardState,
        pwszContainerGuid,
        &dwIndex,
        &pContainerMap,
        &cContainerMap);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (CONTAINER_MAP_DEFAULT_CONTAINER & pContainerMap[dwIndex].bFlags)
    {
        // Find a valid container to mark as the new default

        for (iContainer = 0; iContainer < cContainerMap; iContainer++)
        {
            if (CONTAINER_MAP_VALID_CONTAINER & 
                pContainerMap[iContainer].bFlags)
            {
                pContainerMap[iContainer].bFlags |= 
                    CONTAINER_MAP_DEFAULT_CONTAINER;
                break;
            }
        }
    }

    memset(
        (PBYTE) (pContainerMap + dwIndex),
        0,
        sizeof(CONTAINER_MAP_RECORD));

    *pbContainerIndex = dwIndex;

    //
    // Update the container map file and write it to the card
    //

    dbContainerMap.pbData = (PBYTE) pContainerMap;
    dbContainerMap.cbData = cContainerMap * sizeof(CONTAINER_MAP_RECORD);

    dwSts = CspWriteFile(
        pCardState,
        wszCONTAINER_MAP_FILE_FULL_PATH,
        0,
        dbContainerMap.pbData,
        dbContainerMap.cbData);

Ret:
    
    if (pContainerMap)
        CspFreeH(pContainerMap);

    return dwSts;
}

//
// Function: ValidateCardHandle
//
// Purpose: Verify that the provided SCARDHANDLE is valid.  If the handle
//          is not valid, disconnect and flush the pin cache.
//
// Assume: pCardState critical section should currently be held by caller.
//
DWORD ValidateCardHandle(
    IN PCARD_STATE pCardState,
    IN BOOL fMayReleaseContextHandle,
    OUT OPTIONAL BOOL *pfFlushPinCache)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD dwState = 0;
    DWORD dwProtocol = 0;
    DWORD cch = 0;
    LPWSTR mszReaders = NULL;
    BYTE rgbAtr [cbATR_BUFFER];
    DWORD cbAtr = sizeof(rgbAtr);
    PCARD_DATA pCardData = pCardState->pCardData;

    LOG_BEGIN_FUNCTION(ValidateCardHandle);

    cch = SCARD_AUTOALLOCATE;
    dwSts = SCardStatusW(
        pCardData->hScard,
        (LPWSTR) &mszReaders,
        &cch,
        &dwState,
        &dwProtocol,
        rgbAtr,
        &cbAtr);
    
    if (mszReaders)
        SCardFreeMemory(pCardData->hScard, mszReaders);

    switch (dwSts)
    {
    case SCARD_W_RESET_CARD:

        dwSts = SCardReconnect(
            pCardData->hScard,
            SCARD_SHARE_SHARED,
            SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
            SCARD_LEAVE_CARD,
            &dwProtocol);
    
        if (ERROR_SUCCESS == dwSts)
            // We're done if reconnect succeeded
            goto Ret;

        break;

    case ERROR_SUCCESS:
        if (SCARD_SPECIFIC == dwState)
            // The card handle is still valid and ready to use.  We're done.
            goto Ret;

        break;
        
    default:
        // This includes the case where the card status SCARD_W_REMOVED was 
        // returned.  Nothing to do but disconnect, below.
        break;
    }

    //
    // The card appears to have been withdrawan at some point, or some
    // other problem occurred.
    //
    // We should not attempt to reconnect the card in any case other than
    // RESET, since we wouldn't be sure that it's the same card without
    // further checks.  Instead just close the card handle and let the caller
    // find the correct card again.
    //

    SCardDisconnect(
        pCardData->hScard,
        SCARD_LEAVE_CARD);

    pCardData->hScard = 0;
    dwSts = (DWORD) SCARD_E_INVALID_HANDLE;

    if (fMayReleaseContextHandle)
    {
        SCardReleaseContext(
            pCardData->hSCardCtx);

        pCardData->hSCardCtx = 0;
    }

    if (NULL != pfFlushPinCache)
        *pfFlushPinCache = TRUE;

Ret:

    LOG_END_FUNCTION(ValidateCardHandle, dwSts);

    return dwSts;
}

//
// Function: FindCardBySerialNumber
//
// Purpose: Search for an existing card whose serial number is already
//          known.  This is necessary for a User Context associated with
//          a card whose handle failed to reconnect.
//
DWORD FindCardBySerialNumber(
    IN PUSER_CONTEXT pUserCtx)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_MATCH_DATA CardMatchData;
    PCSP_STATE pCspState = NULL;
    PLOCAL_USER_CONTEXT pLocalUserCtx =
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;

    memset(&CardMatchData, 0, sizeof(CardMatchData));

    dwSts = GetCspState(&pCspState);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    
    CardMatchData.pwszSerialNumber = 
        pLocalUserCtx->pCardState->wszSerialNumber;
    CardMatchData.dwCtxFlags = pUserCtx->dwFlags;
    CardMatchData.dwMatchType = CARD_MATCH_TYPE_SERIAL_NUMBER;
    CardMatchData.cchMatchedCard = MAX_PATH;
    CardMatchData.cchMatchedReader = MAX_PATH;
    CardMatchData.cchMatchedSerialNumber = MAX_PATH;
    CardMatchData.pCspState = pCspState;
    CardMatchData.dwShareMode = SCARD_SHARE_SHARED;
    CardMatchData.dwPreferredProtocols = 
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    // As a sanity check, disassociate this user context with its current 
    // Card State structure.  If we find a match, it will be the same one,
    // because we already know the serial number, but the user context
    // shouldn't maintain this state until then.
    pLocalUserCtx->pCardState = NULL;

    // Try to find a matching card.
    dwSts = FindCard(&CardMatchData);
    
    if (ERROR_SUCCESS == dwSts)
        pLocalUserCtx->pCardState = CardMatchData.pCardState;

Ret:
    if (pCspState)
        ReleaseCspState(&pCspState);
    
    return dwSts;
}

//
// Function: BuildCertificateFilename
//
DWORD WINAPI
BuildCertificateFilename(
    IN  PUSER_CONTEXT pUserCtx, 
    IN  DWORD dwKeySpec,
    OUT LPWSTR *ppszFilename)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE bContainerIndex = 0;
    DWORD cchFilename = 0;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext; 
    CONTAINER_MAP_RECORD ContainerRecord;
    LPWSTR wszPrefix = NULL;

    switch(dwKeySpec)
    {
    case AT_SIGNATURE:
        wszPrefix = wszUSER_SIGNATURE_CERT_PREFIX;
        break;
    case AT_KEYEXCHANGE:
        wszPrefix = wszUSER_KEYEXCHANGE_CERT_PREFIX;
        break;
    default:
        dwSts = (DWORD) NTE_BAD_ALGID;
        goto Ret;
    }

    memset(&ContainerRecord, 0, sizeof(ContainerRecord));

    wcscpy(ContainerRecord.wszGuid, pUserCtx->wszBaseContainerName);

    dwSts = ContainerMapFindContainer(
        pLocal->pCardState,
        &ContainerRecord,
        &bContainerIndex);

    cchFilename = wcslen(wszPrefix) + 2 + 1;

    *ppszFilename = (LPWSTR) CspAllocH(sizeof(WCHAR) * cchFilename);

    LOG_CHECK_ALLOC(*ppszFilename);

    wsprintf(
        *ppszFilename,
        L"%s%02X",
        wszPrefix,
        bContainerIndex);

Ret:
    if (ERROR_SUCCESS != dwSts && *ppszFilename)
    {
        CspFreeH(*ppszFilename);
        *ppszFilename = NULL;
    }

    return dwSts;
}

//
// Function: CspBeginTransaction
//
DWORD CspBeginTransaction(
    IN PCARD_STATE pCardState)
{
    DWORD dwSts = ERROR_SUCCESS;

    dwSts = CspEnterCriticalSection(&pCardState->cs);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = SCardBeginTransaction(pCardState->pCardData->hScard);

Ret:
    if (ERROR_SUCCESS != dwSts)
        CspLeaveCriticalSection(&pCardState->cs);

    return dwSts;
}

//
// Function: CspEndTransaction
//
DWORD CspEndTransaction(
    IN PCARD_STATE pCardState)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD dwAction = 
        pCardState->fAuthenticated ?
        SCARD_RESET_CARD :
        SCARD_LEAVE_CARD;

    if (pCardState->fAuthenticated && 
        pCardState->pCardData->pfnCardDeauthenticate)
    {
        // The card is currently in an authenticated state, and the card 
        // module has its own Deauthenticate function.  Try to use the
        // cardmod function instead using RESET_CARD in the 
        // SCardEndTransaction call.  This can be a big perf improvement.

        dwSts = pCardState->pCardData->pfnCardDeauthenticate(
            pCardState->pCardData, wszCARD_USER_USER, 0);

        // If the Deauthenticate succeeded, all that's left to do is release
        // the transaction.  If the Deauthenticate failed, we'll try one
        // more time to RESET the card.

        if (ERROR_SUCCESS == dwSts)
            dwAction = SCARD_LEAVE_CARD;
    }

    dwSts = SCardEndTransaction(
        pCardState->pCardData->hScard, 
        dwAction);

    if (ERROR_SUCCESS != dwSts)
    {
        // Bad news if we got here.  Better try to close the card handle
        // to cleanup.
        SCardDisconnect(pCardState->pCardData->hScard, SCARD_RESET_CARD);
        pCardState->pCardData->hScard = 0;

        SCardReleaseContext(pCardState->pCardData->hSCardCtx);
        pCardState->pCardData->hSCardCtx = 0;
    }
    else
        pCardState->fAuthenticated = FALSE;

    // We've left the transaction, so the "cached" cache file info is no 
    // longer reliable.
    pCardState->fCacheFileValid = FALSE;

    CspLeaveCriticalSection(&pCardState->cs);

    return dwSts;
}

// 
// Function: BeginCardCapiCall
//
// Purpose: Setup the user context and associated card context for a new 
//          Crypto API call.  This includes:
//              1) Reconnecting to the card, if necessary.  
//              2) Begin transaction.
//
DWORD BeginCardCapiCall(
    IN PUSER_CONTEXT pUserCtx)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    BOOL fFlushPinCache = FALSE;

    LOG_BEGIN_FUNCTION(BeginCardCapiCall);

    DsysAssert(FALSE == pLocalUserCtx->fHoldingTransaction);

    dwSts = CspEnterCriticalSection(
        &pLocalUserCtx->pCardState->cs);

    if (ERROR_SUCCESS != dwSts)
        return dwSts;

    dwSts = ValidateCardHandle(
        pLocalUserCtx->pCardState, TRUE, &fFlushPinCache);

    if (ERROR_SUCCESS != dwSts || TRUE == fFlushPinCache)
        // Flush the pin cache for this card.  Not checking error code
        // since we'll keep processing, anyway.
        CspRemoveCachedPin(pLocalUserCtx->pCardState, wszCARD_USER_USER);

    if (ERROR_SUCCESS != dwSts)
    {
        //
        // Could not connect to the card.  
        //

        CspLeaveCriticalSection(
            &pLocalUserCtx->pCardState->cs);

        // Attempt to find the card again,
        // possibly in a different reader.
        dwSts = FindCardBySerialNumber(pUserCtx);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }
    else
        CspLeaveCriticalSection(
            &pLocalUserCtx->pCardState->cs);

    // If the reconnect failed, bail now.
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Now Begin Transaction on the card.
    dwSts = CspBeginTransaction(pLocalUserCtx->pCardState);

    if (ERROR_SUCCESS == dwSts)
        pLocalUserCtx->fHoldingTransaction = TRUE;

Ret:

    LOG_END_FUNCTION(BeginCardCapiCall, dwSts);

    return dwSts;
}

//
// Function: EndCardCapiCall
//
// Purpose: Cleanup the user context and associated card context following
//          the completion of a Crypto API call.  This includes ending
//          the transaction on the card.
//
DWORD EndCardCapiCall(
    IN PUSER_CONTEXT pUserCtx)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;

    LOG_BEGIN_FUNCTION(EndCardCapiCall);

    if (TRUE == pLocal->fHoldingTransaction)
    {
        dwSts = CspEndTransaction(pLocal->pCardState);

        if (ERROR_SUCCESS != dwSts)
        {
            // Something got screwed up and we weren't able to EndTransaction
            // correctly.  Expect that the SCard handles got released as a 
            // result.

            DsysAssert(0 == pLocal->pCardState->pCardData->hScard);
            DsysAssert(0 == pLocal->pCardState->pCardData->hSCardCtx);
        }

        // Even if the EndTransaction failed, we expect that the card handles 
        // got closed, and we expect that the Card State critsec is no 
        // longer held.
        pLocal->fHoldingTransaction = FALSE;
    }

    LOG_END_FUNCTION(EndCardCapiCall, dwSts);

    return dwSts;
}

//
// Function: DeleteContainer
//
DWORD DeleteContainer(PUSER_CONTEXT pUserCtx)
{
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    DWORD dwSts = ERROR_SUCCESS;
    LPWSTR wszFilename = NULL;
    BYTE bContainerIndex = 0;

    //
    // Delete the certificate (if any) associated with the signature key
    // (if any).
    //

    dwSts = BuildCertificateFilename(
        pUserCtx, AT_SIGNATURE, &wszFilename);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Ignore error on this call - there may not be a cert associated
    // with this container and we're just trying to cleanup as much as 
    // we can.
    CspDeleteFile(
        pLocal->pCardState,
        0,
        wszFilename);

    CspFreeH(wszFilename);
    wszFilename = NULL;

    //
    // Delete the key exchange cert (if any)
    //

    dwSts = BuildCertificateFilename(
        pUserCtx, AT_KEYEXCHANGE, &wszFilename);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    CspDeleteFile(
        pLocal->pCardState,
        0,
        wszFilename);

    //
    // Perform the delete operation on the card
    //

    dwSts = CspDeleteContainer(
        pLocal->pCardState,
        pLocal->bContainerIndex,
        0);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Remove this container from the container map
    //

    dwSts = ContainerMapDeleteContainer(
        pLocal->pCardState,
        pUserCtx->wszBaseContainerName,
        &bContainerIndex);

    DsysAssert(bContainerIndex == pLocal->bContainerIndex);

Ret:
    if (wszFilename)
        CspFreeH(wszFilename);

    return dwSts;
}

// 
// Determines if the current context was acquired using CRYPT_VERIFYCONTEXT
// semantics.
//
// A VerifyContext is allowed for some calls if and only if the
// context has been associated with a specific card.  The fAllowWithCardAccess
// param should be set to TRUE in those cases.
//
DWORD CheckForVerifyContext(
    IN PUSER_CONTEXT pUserContext,
    IN BOOL fAllowOnlyWithCardAccess)
{
    PLOCAL_USER_CONTEXT pLocal = (PLOCAL_USER_CONTEXT)
        pUserContext->pvLocalUserContext;

    if (CRYPT_VERIFYCONTEXT & pUserContext->dwFlags)
    {
        if (fAllowOnlyWithCardAccess)
        {
            if (NULL != pLocal && NULL != pLocal->pCardState)
                return ERROR_SUCCESS;
        }

        return NTE_BAD_FLAGS;
    }

    return ERROR_SUCCESS;
}

//
// Function: LocalAcquireContext
//
DWORD LocalAcquireContext(
    PUSER_CONTEXT pUserContext,
    PLOCAL_CALL_INFO pLocalCallInfo)
{
    PLOCAL_USER_CONTEXT pLocalUserContext = NULL;
    DWORD dwSts;
    CARD_MATCH_DATA CardMatchData;
    LPWSTR pwsz = NULL;
    PCSP_STATE pCspState = NULL;
    DWORD cch = 0;
    CONTAINER_MAP_RECORD ContainerRecord;

    LOG_BEGIN_CRYPTOAPI(LocalAcquireContext);

    memset(&CardMatchData, 0, sizeof(CardMatchData));
    memset(&ContainerRecord, 0, sizeof(ContainerRecord));

    SetLocalCallInfo(pLocalCallInfo, FALSE);

    // Determine if any container/reader information
    // has been specified.
    if (pUserContext->wszContainerNameFromCaller)
    {
        pwsz = (LPWSTR) pUserContext->wszContainerNameFromCaller;

        if (0 == wcsncmp(L"\\\\.\\", pwsz, 4))
        {
            // A reader has been specified
            pwsz += wcslen(L"\\\\.\\");

            // pwsz now points to the reader name

            CardMatchData.pwszContainerName = 
                wcschr(pwsz, L'\\') + 1;

            cch = (DWORD) (CardMatchData.pwszContainerName - pwsz - 1);

            CardMatchData.pwszReaderName = (LPWSTR) CspAllocH(
                sizeof(WCHAR) * (1 + cch));

            LOG_CHECK_ALLOC(CardMatchData.pwszReaderName);

            memcpy(
                CardMatchData.pwszReaderName,
                pwsz,
                sizeof(WCHAR) * cch);
        }
        else
        {
            CardMatchData.pwszContainerName = pwsz;
        }
        
        // Check and cleanup the specified container name
        if (CardMatchData.pwszContainerName)
        {
            // Additional backslashes are not allowed.
            if (wcschr(
                CardMatchData.pwszContainerName,
                L'\\'))
            {
                dwSts = (DWORD) NTE_BAD_KEYSET;
                goto Ret;
            }

            // There may have just been a trailing '\' 
            // with no following container name, or the
            // specified name may have just been the NULL string.
            if (L'\0' == CardMatchData.pwszContainerName[0])
            {
                CardMatchData.pwszContainerName = NULL;
            }
        }

        // Verify that the final container name isn't too long
        if (NULL != CardMatchData.pwszContainerName &&
            MAX_CONTAINER_NAME_LEN < wcslen(CardMatchData.pwszContainerName))
        {
            dwSts = (DWORD) NTE_BAD_KEYSET;
            goto Ret;
        }
    }

    // Get pointer to global CSP data; includes
    // list of cached card information.
    dwSts = GetCspState(&pCspState);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
 
    // Setup the caller's cryptographic context.
    pLocalUserContext = (PLOCAL_USER_CONTEXT) CspAllocH(sizeof(LOCAL_USER_CONTEXT));

    LOG_CHECK_ALLOC(pLocalUserContext);
   
    pLocalUserContext->dwVersion = LOCAL_USER_CONTEXT_CURRENT_VERSION;

    // Prepare info for matching an available 
    // smart card to the caller's request.
    CardMatchData.dwCtxFlags = pUserContext->dwFlags;
    CardMatchData.dwMatchType = CARD_MATCH_TYPE_READER_AND_CONTAINER;
    CardMatchData.cchMatchedCard = MAX_PATH;
    CardMatchData.cchMatchedReader = MAX_PATH;
    CardMatchData.cchMatchedSerialNumber = MAX_PATH;
    CardMatchData.pCspState = pCspState;
    CardMatchData.dwShareMode = SCARD_SHARE_SHARED;
    CardMatchData.dwPreferredProtocols = 
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    // Try to find a matching card.
    dwSts = FindCard(&CardMatchData);

    //
    // Check for a VERIFYCONTEXT request in which no container specification
    // has been made.  A failed card match is fine in that case since
    // this context will only be used to query generic CSP information.
    //

    if (ERROR_SUCCESS != dwSts &&
        (CRYPT_VERIFYCONTEXT & pUserContext->dwFlags) &&
        NULL == pUserContext->wszContainerNameFromCaller)
    {
        pUserContext->pvLocalUserContext = (PVOID) pLocalUserContext;
        pLocalUserContext = NULL;

        dwSts = ERROR_SUCCESS;
        goto Ret;
    }

    // Any other non-success case is fatal
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pLocalUserContext->pCardState = CardMatchData.pCardState;
    pLocalUserContext->bContainerIndex = CardMatchData.bContainerIndex;

    // Read configuration information out of the registry.
    dwSts = RegConfigGetSettings(
        &pLocalUserContext->RegSettings);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // If the caller requested a new container but didn't give a container
    // name, create a Guid name now.
    //
    if (NULL == CardMatchData.pwszContainerName &&
        (CRYPT_NEWKEYSET & pUserContext->dwFlags))
    {
        dwSts = CreateUuidContainerName(pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }
    else if (NULL != CardMatchData.pwszContainerName)
    {
        // Caller did give a container name, or the default container is
        // being used and we queried the name from the card during
        // our search.  Copy it into the user context.

        pUserContext->wszBaseContainerName = (LPWSTR) CspAllocH(
            sizeof(WCHAR) * (1 + wcslen(CardMatchData.pwszContainerName)));

        LOG_CHECK_ALLOC(pUserContext->wszBaseContainerName);

        wcscpy(
            pUserContext->wszBaseContainerName,
            CardMatchData.pwszContainerName);
    }

    //
    // Associate context information for this CSP
    //
    pUserContext->pvLocalUserContext = (PVOID) pLocalUserContext;

    if (NULL != pUserContext->wszBaseContainerName)
    {
        //
        // Make a copy of the base container name to use as the "unique" container
        // name, since for this CSP they're the same.  
        //
        // The only reason we should skip this step is for VERIFY_CONTEXT.
        //

        pUserContext->wszUniqueContainerName = (LPWSTR) CspAllocH(
            sizeof(WCHAR) * (1 + wcslen(pUserContext->wszBaseContainerName)));
    
        LOG_CHECK_ALLOC(pUserContext->wszUniqueContainerName);
    
        wcscpy(
            pUserContext->wszUniqueContainerName,
            pUserContext->wszBaseContainerName);

        if (CRYPT_NEWKEYSET & pUserContext->dwFlags)
        {
            //
            // Add-container requires us to 
            // authenticate to the card, since we'll need to write the updated
            // container map.
            //

            dwSts = BeginCardCapiCall(pUserContext);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            dwSts = CspAuthenticateUser(pUserContext);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            dwSts = ContainerMapAddContainer(
                pLocalUserContext->pCardState,
                pUserContext->wszBaseContainerName,
                0,
                0,
                FALSE,
                &pLocalUserContext->bContainerIndex);

            //
            // Determine if there is already a "default" container on this
            // card.  If not, mark the new one as default.
            //
            dwSts = ContainerMapGetDefaultContainer(
                pLocalUserContext->pCardState,
                &ContainerRecord,
                NULL);

            if (NTE_BAD_KEYSET == dwSts)
            {
                dwSts = ContainerMapSetDefaultContainer(
                    pLocalUserContext->pCardState,
                    pUserContext->wszBaseContainerName);
            }

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
        }
    }
    else
    {
        DsysAssert(CRYPT_VERIFYCONTEXT & pUserContext->dwFlags);
    }

    //
    // If caller has requested a Delete Keyset, then do that work now
    // and cleanup the local user context at the end.
    //
    if (CRYPT_DELETEKEYSET & pUserContext->dwFlags)
    {
        dwSts = BeginCardCapiCall(pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = CspAuthenticateUser(pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = DeleteContainer(pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }
    else
    {
        pLocalUserContext = NULL;
    }

Ret:

    if (pUserContext->pvLocalUserContext)
        EndCardCapiCall(pUserContext);

    if (pCspState)
        ReleaseCspState(&pCspState);
    
    if (pLocalUserContext)
    {
        pUserContext->pvLocalUserContext = NULL;
        DeleteLocalUserContext(pLocalUserContext);
        CspFreeH(pLocalUserContext);
    }

    if (CardMatchData.pwszReaderName)
        CspFreeH(CardMatchData.pwszReaderName);
    if (CardMatchData.fFreeContainerName &&
        CardMatchData.pwszContainerName)
        CspFreeH(CardMatchData.pwszContainerName);

    LOG_END_CRYPTOAPI(LocalAcquireContext, dwSts);

    return dwSts;
}

//
// Function: LocalReleaseContext
//
DWORD WINAPI
LocalReleaseContext(
    IN  PUSER_CONTEXT       pUserCtx,
    IN  DWORD               dwFlags,
    OUT PLOCAL_CALL_INFO    pLocalCallInfo)
{
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    DWORD dwSts = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_CRYPTOAPI(LocalReleaseContext);

    if (pLocal)
    {
        DeleteLocalUserContext(pLocal);
        CspFreeH(pLocal);
        pUserCtx->pvLocalUserContext = NULL;
    }

    LOG_END_CRYPTOAPI(LocalReleaseContext, dwSts);

    return dwSts;
}

//
// Function: LocalGenKey
//
DWORD WINAPI
LocalGenKey(
    IN  PKEY_CONTEXT        pKeyCtx,
    OUT PLOCAL_CALL_INFO    pLocalCallInfo)
{
    PUSER_CONTEXT pUserCtx = pKeyCtx->pUserContext;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    DWORD dwSts = ERROR_SUCCESS;
    CARD_CAPABILITIES CardCapabilities;
    HCRYPTKEY hKey = 0;
    PBYTE pbKey = NULL;
    DWORD cbKey = 0;
    PLOCAL_KEY_CONTEXT pLocalKeyCtx = NULL;
    BYTE bContainerIndex = 0;

    LOG_BEGIN_CRYPTOAPI(LocalGenKey);

    memset(&CardCapabilities, 0, sizeof(CardCapabilities));

    if (CALG_RSA_KEYX == pKeyCtx->Algid)
        pKeyCtx->Algid = AT_KEYEXCHANGE;
    else if (CALG_RSA_SIGN == pKeyCtx->Algid)
        pKeyCtx->Algid = AT_SIGNATURE;

    if (AT_SIGNATURE == pKeyCtx->Algid ||
        AT_KEYEXCHANGE == pKeyCtx->Algid)
    {
        // Public key call.  Handle this here since we have to talk to the
        // card.  All other key algs will be handled in the support CSP.

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = CheckForVerifyContext(pKeyCtx->pUserContext, FALSE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (CRYPT_EXPORTABLE & pKeyCtx->dwFlags)
        {
            dwSts = NTE_BAD_FLAGS;
            goto Ret;
        }

        dwSts = BeginCardCapiCall(pUserCtx);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = CspQueryCapabilities(
            pLocalUserCtx->pCardState,
            &CardCapabilities);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (0 == pKeyCtx->cKeyBits)
            pKeyCtx->cKeyBits = pLocalUserCtx->RegSettings.cDefaultPrivateKeyLenBits;

        //
        // If ARCHIVABLE is set, we don't gen the key on the card, since we 
        // don't want to force cards to support exportable private keys.
        //
        if (    CardCapabilities.fKeyGen &&
                0 == (CRYPT_ARCHIVABLE & pKeyCtx->dwFlags))
        {
            dwSts = CspAuthenticateUser(pUserCtx);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
            
            dwSts = CspCreateContainer(
                pLocalUserCtx->pCardState,
                pLocalUserCtx->bContainerIndex,
                CARD_CREATE_CONTAINER_KEY_GEN,
                pKeyCtx->Algid,
                pKeyCtx->cKeyBits,
                NULL);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
        }
        else
        {
            // This card does not support on-card key generation.  See
            // if we're allowed to create our own key blob and import
            // it.

            if (pLocalUserCtx->RegSettings.fRequireOnCardPrivateKeyGen)
            {
                dwSts = (DWORD) SCARD_E_UNSUPPORTED_FEATURE;
                goto Ret;
            }

            //
            // Create a new, exportable private key in the software CSP.  Then
            // export it and import it onto the card.
            //

            if (! CryptGenKey(
                pUserCtx->hSupportProv,
                pKeyCtx->Algid,
                CRYPT_EXPORTABLE | (pKeyCtx->cKeyBits << 16),
                &hKey))
            {
                dwSts = GetLastError();
                goto Ret;
            }

            if (! CryptExportKey(
                hKey,
                0,
                PRIVATEKEYBLOB,
                0,
                NULL,
                &cbKey))
            {
                dwSts = GetLastError();
                goto Ret;
            }

            pbKey = (PBYTE) CspAllocH(cbKey);

            LOG_CHECK_ALLOC(pbKey);

            if (! CryptExportKey(
                hKey,
                0,
                PRIVATEKEYBLOB,
                0,
                pbKey,
                &cbKey))
            {
                dwSts = GetLastError();
                goto Ret;
            }

            dwSts = CspAuthenticateUser(pUserCtx);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            dwSts = CspCreateContainer(
                pLocalUserCtx->pCardState,
                pLocalUserCtx->bContainerIndex,
                CARD_CREATE_CONTAINER_KEY_IMPORT,
                pKeyCtx->Algid,
                cbKey,
                pbKey);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            //
            // Check for CRYPT_ARCHIVABLE.  If it's set, we'll keep a copy of 
            // the private key for the lifetime of this key context for the
            // caller to export it.
            //

            if (CRYPT_ARCHIVABLE & pKeyCtx->dwFlags)
            {
                pLocalKeyCtx = (PLOCAL_KEY_CONTEXT) CspAllocH(
                    sizeof(LOCAL_KEY_CONTEXT));

                LOG_CHECK_ALLOC(pLocalKeyCtx);

                pLocalKeyCtx->pbArchivablePrivateKey = pbKey;
                pLocalKeyCtx->cbArchivablePrivateKey = cbKey;
                pbKey = NULL;
                pKeyCtx->pvLocalKeyContext = (PVOID) pLocalKeyCtx;
            }
        }

        //
        // Add the new key information for this container to the map file
        //

        dwSts = ContainerMapAddContainer(
            pLocalUserCtx->pCardState,
            pUserCtx->wszBaseContainerName,
            pKeyCtx->cKeyBits,
            pKeyCtx->Algid,
            FALSE,
            &bContainerIndex);

        DsysAssert(bContainerIndex == pLocalUserCtx->bContainerIndex);
    }
    else
    {
        // Not a public key call, so handle in the support CSP.

        SetLocalCallInfo(pLocalCallInfo, TRUE);
    }

Ret:

    EndCardCapiCall(pUserCtx);

    if (pbKey)
    {
        RtlSecureZeroMemory(pbKey, cbKey);
        CspFreeH(pbKey);
    }

    if (hKey)
        CryptDestroyKey(hKey);

    LOG_END_CRYPTOAPI(LocalGenKey, dwSts);

    return dwSts;
}

//
// Function: LocalDestroyKey
//
DWORD WINAPI 
LocalDestroyKey(
    IN OUT  PKEY_CONTEXT        pKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo)
{
    PLOCAL_KEY_CONTEXT pLocalKeyCtx =
        (PLOCAL_KEY_CONTEXT) pKeyContext->pvLocalKeyContext;

    LOG_BEGIN_CRYPTOAPI(LocalDestroyKey);

    if (NULL != pLocalKeyCtx)
    {
        if (NULL != pLocalKeyCtx->pbArchivablePrivateKey)
        {
            RtlSecureZeroMemory(
                pLocalKeyCtx->pbArchivablePrivateKey, 
                pLocalKeyCtx->cbArchivablePrivateKey);
            CspFreeH(pLocalKeyCtx->pbArchivablePrivateKey);
            pLocalKeyCtx->pbArchivablePrivateKey = NULL;
        }

        CspFreeH(pLocalKeyCtx);
        pKeyContext->pvLocalKeyContext = NULL;
    }

    LOG_END_CRYPTOAPI(LocalDestroyKey, ERROR_SUCCESS);

    return ERROR_SUCCESS;
}

//
// Determines if an encoded certificate blob contains certain Enhanced Key
// Usage OIDs.  The target OIDs are SmartCard Logon and Enrollment Agent.
// If either OID is present, the key container associated with this 
// certificate should be considered the new default container on the target
// card.
//
DWORD CheckCertUsageForDefaultContainer(
    PBYTE pbEncodedCert,
    DWORD cbEncodedCert,
    BOOL *pfMakeDefault)
{
    DWORD dwSts = 0;
    PCCERT_CONTEXT pCertCtx = NULL;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage = 0;

    *pfMakeDefault = FALSE;

    //
    // Build a cert context from the encoded blob
    //

    pCertCtx = CertCreateCertificateContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncodedCert,
        cbEncodedCert);

    if (NULL == pCertCtx)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // Get an array of the EKU OIDs present in this cert
    //

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        NULL,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pUsage = (PCERT_ENHKEY_USAGE) CspAllocH(cbUsage);

    if (NULL == pUsage)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        pUsage,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // Look for the two specific OIDs that would make this the new default
    // cert/container
    //

    while (pUsage->cUsageIdentifier)
    {
        pUsage->cUsageIdentifier -= 1;

        if (0 == strcmp(
                szOID_KP_SMARTCARD_LOGON,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]) ||
            0 == strcmp(
                szOID_ENROLLMENT_AGENT,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]))
        {
            *pfMakeDefault = TRUE;
        }
    }

Ret:

    if (pUsage)
        CspFreeH(pUsage);
    if (pCertCtx)
        CertFreeCertificateContext(pCertCtx);

    return dwSts;
}

//
// Function: LocalSetKeyParam
//
DWORD WINAPI
LocalSetKeyParam(
    IN  PKEY_CONTEXT pKeyCtx,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pKeyCtx->pUserContext->pvLocalUserContext;
    DWORD cbCert = 0;
    DWORD cbCompressed = 0;
    PBYTE pbCompressed = NULL;
    LPWSTR wszCertFilename = NULL;
    CARD_FILE_ACCESS_CONDITION Acl = EveryoneReadUserWriteAc;
    DATA_BLOB CertData;
    CARD_CAPABILITIES CardCapabilities;
    BOOL fMakeDefault = FALSE;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_CRYPTOAPI(LocalSetKeyParam);

    memset(&CertData, 0, sizeof(CertData));
    memset(&CardCapabilities, 0, sizeof(CardCapabilities));

    switch (dwParam)
    {
    case KP_CERTIFICATE:
        
        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = CheckForVerifyContext(pKeyCtx->pUserContext, FALSE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Determine how long the encoded cert blob is.
        //
        __try
        {
            cbCert = Asn1UtilAdjustEncodedLength(
                pbData, (DWORD) cbENCODED_CERT_OVERFLOW);

            if (0 == cbCert || cbENCODED_CERT_OVERFLOW == cbCert)
            {
                dwSts = (DWORD) NTE_BAD_DATA;
                goto Ret;
            }
        }
        __except(EXCEPTION_ACCESS_VIOLATION == GetExceptionCode() ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
        {
            dwSts = (DWORD) NTE_BAD_DATA;
            goto Ret;
        }

        // Begin a transaction and reconnect the card if necessary
        dwSts = BeginCardCapiCall(pKeyCtx->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Build the filename we'll use for this cert
        //
        dwSts = BuildCertificateFilename(
            pKeyCtx->pUserContext, pKeyCtx->Algid, &wszCertFilename);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Determine if this certificate contains OIDs that should make the 
        // associated key container the new default.
        //
        dwSts = CheckCertUsageForDefaultContainer(
            (PBYTE) pbData,
            cbCert,
            &fMakeDefault);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
        
        //
        // Determine the capabilities of the target card - we want to know 
        // whether it (or its card module) implements its own data
        // compression.
        //

        dwSts = CspQueryCapabilities(
            pLocalUserCtx->pCardState,
            &CardCapabilities);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (FALSE == CardCapabilities.fCertificateCompression)
        {
            // 
            // If this card doesn't implement its own certificate compression
            // then we will compress the cert.
            //
            // Find out how big the compressed cert will be
            //
            dwSts = CompressData(cbCert, NULL, &cbCompressed, NULL);
    
            if (ERROR_SUCCESS != dwSts)
                goto Ret;
    
            pbCompressed = CspAllocH(cbCompressed);
    
            LOG_CHECK_ALLOC(pbCompressed);
    
            // Compress the cert
            dwSts = CompressData(
                cbCert, 
                (PBYTE) pbData, 
                &cbCompressed, 
                pbCompressed);
    
            if (ERROR_SUCCESS != dwSts)
                goto Ret;
    
            CertData.cbData = cbCompressed;
            CertData.pbData = pbCompressed;
        }
        else
        {
            CertData.cbData = cbCert;
            CertData.pbData = (PBYTE) pbData;
        }

        //
        // Authenticate to the card as User
        //
        dwSts = CspAuthenticateUser(pKeyCtx->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Write the cert to the card.
        //
        dwSts = CspCreateFile(
            pLocalUserCtx->pCardState,
            wszCertFilename,
            Acl);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = CspWriteFile(
            pLocalUserCtx->pCardState,
            wszCertFilename,
            0,
            CertData.pbData,
            CertData.cbData);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (fMakeDefault)
        {
            dwSts = ContainerMapSetDefaultContainer(
                pLocalUserCtx->pCardState,
                pKeyCtx->pUserContext->wszBaseContainerName);
        }

        break;

    default:
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        break;
    }

Ret:

    EndCardCapiCall(pKeyCtx->pUserContext);

    if (pbCompressed)
        CspFreeH(pbCompressed);
    if (wszCertFilename)
        CspFreeH(wszCertFilename);

    LOG_END_CRYPTOAPI(LocalSetKeyParam, dwSts);

    return dwSts;
}

//
// Function: LocalGetKeyParam
//
DWORD WINAPI
LocalGetKeyParam(
    IN  PKEY_CONTEXT pKeyCtx,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pKeyCtx->pUserContext->pvLocalUserContext;
    LPWSTR wszCertFilename = NULL;
    DATA_BLOB CertData;
    DWORD cbUncompressed = 0;
    CARD_CAPABILITIES CardCapabilities;

    LOG_BEGIN_CRYPTOAPI(LocalGetKeyParam);

    memset(&CertData, 0, sizeof(CertData));
    memset(&CardCapabilities, 0, sizeof(CardCapabilities));

    switch (dwParam)
    {
    case KP_CERTIFICATE:

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = CheckForVerifyContext(pKeyCtx->pUserContext, TRUE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Note, reading the certificate files should not require 
        // authentication to the card, but we will Enter Transaction
        // to be safe.

        dwSts = BeginCardCapiCall(pKeyCtx->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Get the name of the certificate file to read from the card.
        //
        dwSts = BuildCertificateFilename(
            pKeyCtx->pUserContext, pKeyCtx->Algid, &wszCertFilename);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Read the file from the card.
        //
        dwSts = CspReadFile(
            pLocalUserCtx->pCardState,
            wszCertFilename,
            0,
            &CertData.pbData,
            &CertData.cbData);

        if (ERROR_SUCCESS != dwSts)
        {
            if (SCARD_E_FILE_NOT_FOUND == dwSts)
                dwSts = SCARD_E_NO_SUCH_CERTIFICATE;

            goto Ret;
        }

        dwSts = CspQueryCapabilities(
            pLocalUserCtx->pCardState,
            &CardCapabilities);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (FALSE == CardCapabilities.fCertificateCompression)
        {
            //
            // If this card doesn't implement its own certificate compression,
            // then we expect the cert was compressed by the CSP.
            //
            // Find out how big the uncompressed cert will be
            //

            dwSts = UncompressData(
                CertData.cbData, 
                CertData.pbData, 
                &cbUncompressed, 
                NULL);
    
            if (ERROR_SUCCESS != dwSts)
                goto Ret;
    
            //
            // Check the length of the caller's buffer, or if the caller is just
            // querying for size.
            //
            if (*pcbDataLen < cbUncompressed || NULL == pbData)
            {
                *pcbDataLen = cbUncompressed;
    
                if (NULL != pbData)
                    dwSts = ERROR_MORE_DATA;
    
                goto Ret;
            }

            *pcbDataLen = cbUncompressed;
    
            // Uncompress the cert into the caller's buffer
            dwSts = UncompressData(
                CertData.cbData,
                CertData.pbData,
                &cbUncompressed,
                pbData);
    
            if (ERROR_SUCCESS != dwSts)
            {
                if (ERROR_INTERNAL_ERROR == dwSts)
                    dwSts = NTE_BAD_DATA;
    
                goto Ret;
            }
        }
        else
        {
            // 
            // This card does implement its own compression, so assume that 
            // we have received the cert uncompressed.
            //
            if (*pcbDataLen < CertData.cbData || NULL == pbData)
            {
                *pcbDataLen = CertData.cbData;
    
                if (NULL != pbData)
                    dwSts = ERROR_MORE_DATA;
    
                goto Ret;
            }

            *pcbDataLen = CertData.cbData;

            memcpy(pbData, CertData.pbData, CertData.cbData);
        }

        break;

    default:
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        break;
    }

Ret:

    EndCardCapiCall(pKeyCtx->pUserContext);

    if (CertData.pbData)
        CspFreeH(CertData.pbData);
    if (wszCertFilename)
        CspFreeH(wszCertFilename);

    LOG_END_CRYPTOAPI(LocalGetKeyParam, dwSts);

    return dwSts;
}

//
// Function: LocalSetProvParam
//
DWORD WINAPI
LocalSetProvParam(
    IN  PUSER_CONTEXT pUserCtx,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pUserCtx->pvLocalUserContext;
    PINCACHE_PINS Pins;
    PFN_VERIFYPIN_CALLBACK pfnVerify = VerifyPinCallback;
    VERIFY_PIN_CALLBACK_DATA CallbackCtx;
    DWORD iChar = 0;
    LPSTR szPin = NULL;

    LOG_BEGIN_CRYPTOAPI(LocalSetProvParam);

    memset(&Pins, 0, sizeof(Pins));
    memset(&CallbackCtx, 0, sizeof(CallbackCtx));

    switch (dwParam)
    {
    case PP_KEYEXCHANGE_PIN:
    case PP_SIGNATURE_PIN:

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = CheckForVerifyContext(pUserCtx, FALSE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = PinStringToBytesA(
            (LPSTR) pbData,
            &Pins.cbCurrentPin,
            &Pins.pbCurrentPin);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = BeginCardCapiCall(pUserCtx);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Remove any existing cached pin, just in case
        CspRemoveCachedPin(
            pLocalUserCtx->pCardState, wszCARD_USER_USER);

        CallbackCtx.pUserCtx = pUserCtx;
        CallbackCtx.wszUserId = wszCARD_USER_USER;

        dwSts = PinCacheAdd(
            &pLocalUserCtx->pCardState->hPinCache,
            &Pins,
            pfnVerify,
            (PVOID) &CallbackCtx);

        // We're now authenticated to the card if the pin was correct.  Make
        // sure we deauthenticate below.
        if (ERROR_SUCCESS == dwSts)
            pLocalUserCtx->pCardState->fAuthenticated = TRUE;

        break;

    default:
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        break;
    }

Ret:
    EndCardCapiCall(pUserCtx);

    if (Pins.pbCurrentPin)
        CspFreeH(Pins.pbCurrentPin);

    LOG_END_CRYPTOAPI(LocalSetProvParam, dwSts);

    return dwSts;
}

//
// Function: LocalGetProvParam
//
DWORD WINAPI
LocalGetProvParam(
    IN      PUSER_CONTEXT       pUserContext,
    IN      DWORD               dwParam,
    OUT     PBYTE               pbData,
    IN OUT  PDWORD              pcbDataLen,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pUserContext->pvLocalUserContext;
    BYTE cContainers = 0;
    LPWSTR mwszContainers = NULL;
    DWORD cbContainers = 0;
    DWORD cchContainers = 0;
    DWORD cbCurrent = 0;
    BOOL fTransacted = FALSE;
    PROV_ENUMALGS *pEnumAlgs = NULL;

    LOG_BEGIN_CRYPTOAPI(LocalGetProvParam);

    switch (dwParam)
    {
    case PP_ENUMALGS_EX:
    case PP_ENUMALGS:

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        // Build the list of supported algorithms if we haven't done so already
        // for this context.
        if (NULL == pLocalUserCtx->pSupportedAlgs)
        {
            dwSts = BuildSupportedAlgorithmsList(pUserContext);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
        }

        // Reset the enumeration if requested.
        if (CRYPT_FIRST == dwFlags)
            pLocalUserCtx->pCurrentAlg = pLocalUserCtx->pSupportedAlgs;

        // Is the enumeration already done?
        if (NULL == pLocalUserCtx->pCurrentAlg)
        {
            dwSts = ERROR_NO_MORE_ITEMS;
            goto Ret;
        }

        cbCurrent = (PP_ENUMALGS_EX == dwParam) ?
            sizeof(PROV_ENUMALGS_EX) :
            sizeof(PROV_ENUMALGS);

        // Check the size of the caller's buffer or if caller is merely 
        // requesting size info.
        if (NULL == pbData || *pcbDataLen < cbCurrent)
        {
            *pcbDataLen = cbCurrent;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;

            goto Ret;
        }

        *pcbDataLen = cbCurrent;

        if (PP_ENUMALGS_EX == dwParam)
        {
            memcpy(pbData, &pLocalUserCtx->pCurrentAlg->EnumalgsEx, cbCurrent);
        }
        else
        {
            // Have to do a member-wise copy of the PROV_ENUMALGS struct since
            // the list we maintain is PROV_ENUMALGS_EX.

            pEnumAlgs = (PROV_ENUMALGS *) pbData;

            pEnumAlgs->aiAlgid = 
                pLocalUserCtx->pCurrentAlg->EnumalgsEx.aiAlgid;
            pEnumAlgs->dwBitLen = 
                pLocalUserCtx->pCurrentAlg->EnumalgsEx.dwDefaultLen;
            pEnumAlgs->dwNameLen = 
                pLocalUserCtx->pCurrentAlg->EnumalgsEx.dwNameLen;

            memcpy(
                pEnumAlgs->szName, 
                pLocalUserCtx->pCurrentAlg->EnumalgsEx.szName, 
                pEnumAlgs->dwNameLen);
        }

        pLocalUserCtx->pCurrentAlg = pLocalUserCtx->pCurrentAlg->pNext;

        break;

    case PP_ENUMCONTAINERS:

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = CheckForVerifyContext(pUserContext, TRUE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        if (NULL == pLocalUserCtx->mszEnumContainers ||
            CRYPT_FIRST == dwFlags)
        {
            // 
            // We need to build a new list of containers on this card if we 
            // haven't already done so, or if the caller is starting a new
            // container enumeration.
            //

            if (NULL != pLocalUserCtx->mszEnumContainers)
            {
                CspFreeH(pLocalUserCtx->mszEnumContainers);
                pLocalUserCtx->mszEnumContainers = NULL;
                pLocalUserCtx->mszCurrentEnumContainer = NULL;
            }

            dwSts = BeginCardCapiCall(pUserContext);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            fTransacted = TRUE;

            dwSts = ContainerMapEnumContainers(
                pLocalUserCtx->pCardState,
                &cContainers,
                &mwszContainers);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;

            cchContainers = CountCharsInMultiSz(mwszContainers);

            cbContainers = WideCharToMultiByte(
                CP_ACP,
                0,
                mwszContainers,
                cchContainers,
                NULL,
                0,
                NULL,
                NULL);

            if (0 == cbContainers)
            {
                dwSts = GetLastError();
                goto Ret;
            }

            pLocalUserCtx->mszEnumContainers = (LPSTR) CspAllocH(cbContainers);

            LOG_CHECK_ALLOC(pLocalUserCtx->mszEnumContainers);

            cbContainers = WideCharToMultiByte(
                CP_ACP,
                0,
                mwszContainers,
                cchContainers,
                pLocalUserCtx->mszEnumContainers,
                cbContainers,
                NULL,
                NULL);

            if (0 == cbContainers)
            {
                dwSts = GetLastError();
                goto Ret;
            }

            pLocalUserCtx->mszCurrentEnumContainer = 
                pLocalUserCtx->mszEnumContainers;
        }

        if (NULL == pLocalUserCtx->mszCurrentEnumContainer ||
            '\0' == pLocalUserCtx->mszCurrentEnumContainer[0])
        {
            dwSts = ERROR_NO_MORE_ITEMS;
            goto Ret;
        }

        cbCurrent = (strlen(
            pLocalUserCtx->mszCurrentEnumContainer) + 1) * sizeof(CHAR);

        if (NULL == pbData || *pcbDataLen < cbCurrent)
        {
            *pcbDataLen = cbCurrent;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;

            goto Ret;
        }

        *pcbDataLen = cbCurrent;

        memcpy(
            pbData, 
            (PBYTE) pLocalUserCtx->mszCurrentEnumContainer,
            cbCurrent);

        ((PBYTE) pLocalUserCtx->mszCurrentEnumContainer) += cbCurrent;

        break;

    default:
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        break;
    }

Ret:

    if (fTransacted)
        EndCardCapiCall(pUserContext);

    LOG_END_CRYPTOAPI(LocalGetProvParam, dwSts);

    return dwSts;
}


//
// Function: LocalExportKey
//
DWORD WINAPI
LocalExportKey(
    IN  PKEY_CONTEXT pKeyCtx,
    IN  PKEY_CONTEXT pPubKeyCtx,
    IN  DWORD dwBlobType,
    IN  DWORD dwFlags,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocalUserCtx = 
        (PLOCAL_USER_CONTEXT) pKeyCtx->pUserContext->pvLocalUserContext;
    CONTAINER_INFO ContainerInfo;
    DWORD cbKey = 0;
    PBYTE pbKey = 0;
    PLOCAL_KEY_CONTEXT pLocalKeyCtx = NULL;

    LOG_BEGIN_CRYPTOAPI(LocalExportKey);

    memset(&ContainerInfo, 0, sizeof(ContainerInfo));

    SetLocalCallInfo(pLocalCallInfo, TRUE);

    switch (dwBlobType)
    {
    case PRIVATEKEYBLOB:
        SetLocalCallInfo(pLocalCallInfo, FALSE);

        if (NULL != pKeyCtx->pvLocalKeyContext)
        {
            pLocalKeyCtx = (PLOCAL_KEY_CONTEXT) pKeyCtx->pvLocalKeyContext;

            if (NULL != pLocalKeyCtx->pbArchivablePrivateKey)
            {
                if (    *pcbDataLen < pLocalKeyCtx->cbArchivablePrivateKey || 
                        NULL == pbData)
                {
                    *pcbDataLen = pLocalKeyCtx->cbArchivablePrivateKey;

                    if (NULL != pbData)
                        dwSts = ERROR_MORE_DATA;

                    goto Ret;
                }

                *pcbDataLen = pLocalKeyCtx->cbArchivablePrivateKey;

                memcpy(
                    pbData, 
                    pLocalKeyCtx->pbArchivablePrivateKey,
                    pLocalKeyCtx->cbArchivablePrivateKey);

                break;
            }
        }

        dwSts = (DWORD) NTE_BAD_TYPE;
        break;

    case PUBLICKEYBLOB:
        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = BeginCardCapiCall(pKeyCtx->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = CspGetContainerInfo(
            pLocalUserCtx->pCardState,
            pLocalUserCtx->bContainerIndex,
            0,
            &ContainerInfo);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        switch (pKeyCtx->Algid)
        {
        case AT_SIGNATURE:
            cbKey = ContainerInfo.cbSigPublicKey;
            pbKey = ContainerInfo.pbSigPublicKey;
            break;

        case AT_KEYEXCHANGE:
            cbKey = ContainerInfo.cbKeyExPublicKey;
            pbKey = ContainerInfo.pbKeyExPublicKey;
            break;

        default:
            dwSts = (DWORD) NTE_BAD_KEY;
            goto Ret;
        }

        if (*pcbDataLen < cbKey || NULL == pbData)
        {
            *pcbDataLen = cbKey;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;

            goto Ret;
        }

        *pcbDataLen = cbKey;

        memcpy(pbData, pbKey, cbKey);
        break;
    }

Ret:
    EndCardCapiCall(pKeyCtx->pUserContext);

    CleanupContainerInfo(&ContainerInfo);

    LOG_END_CRYPTOAPI(LocalExportKey, dwSts);

    return dwSts;
}

//
// Function: LocalImportKey
//
DWORD WINAPI
LocalImportKey(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      PBYTE               pbData,
    IN      DWORD               cbDataLen,
    IN      PKEY_CONTEXT        pPubKey,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    BLOBHEADER *pBlobHeader = (BLOBHEADER *) pbData;
    PBYTE pbDecrypted = NULL;
    DWORD cbDecrypted = 0;
    CARD_PRIVATE_KEY_DECRYPT_INFO DecryptInfo;
    PLOCAL_USER_CONTEXT pLocal =
        (PLOCAL_USER_CONTEXT) pKeyContext->pUserContext->pvLocalUserContext;
    PBYTE pbPlaintextBlob = NULL;
    DWORD cbPlaintextBlob = 0;

    memset(&DecryptInfo, 0, sizeof(DecryptInfo));

    LOG_BEGIN_CRYPTOAPI(LocalImportKey);

    switch (pBlobHeader->bType)
    {
    case SIMPLEBLOB:

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        // Only allow Key Exchange type keys to decrypt other keys
        if (AT_SIGNATURE == pPubKey->Algid)
        {
            dwSts = (DWORD) NTE_BAD_TYPE;
            goto Ret;
        }

        if (CALG_RSA_KEYX != *(ALG_ID *) (pbData + sizeof(BLOBHEADER)))
        {
            dwSts = (DWORD) NTE_BAD_ALGID;
            goto Ret;
        }

        if (pPubKey->pUserContext != pKeyContext->pUserContext)
        {
            dwSts = (DWORD) NTE_BAD_UID;
            goto Ret;
        }

        dwSts = CheckForVerifyContext(pKeyContext->pUserContext, FALSE);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Decrypt a session key blob using the private key.
        //

        dwSts = BeginCardCapiCall(pKeyContext->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        dwSts = CspAuthenticateUser(pKeyContext->pUserContext);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        DecryptInfo.cbData = cbDataLen - sizeof(BLOBHEADER) - sizeof(ALG_ID);
        DecryptInfo.dwKeySpec = AT_KEYEXCHANGE;
        DecryptInfo.dwVersion = CARD_PRIVATE_KEY_DECRYPT_INFO_CURRENT_VERSION;
        DecryptInfo.pbData = pbData + sizeof(BLOBHEADER) + sizeof(ALG_ID);
        DecryptInfo.bContainerIndex = pLocal->bContainerIndex;
    
        dwSts = CspPrivateKeyDecrypt(
            pLocal->pCardState,
            &DecryptInfo);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    
        dwSts = VerifyPKCS2Padding(
            DecryptInfo.pbData,
            DecryptInfo.cbData,
            &pbDecrypted,
            &cbDecrypted);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Now we can build a PLAINTEXTKEYBLOB with the decrypted session key 
        // and import it into the helper CSP.
        //
        
        cbPlaintextBlob = sizeof(BLOBHEADER) + sizeof(DWORD) + cbDecrypted;

        pbPlaintextBlob = CspAllocH(cbPlaintextBlob);

        LOG_CHECK_ALLOC(pbPlaintextBlob);

        ((BLOBHEADER *) pbPlaintextBlob)->aiKeyAlg = pBlobHeader->aiKeyAlg;
        ((BLOBHEADER *) pbPlaintextBlob)->bType = PLAINTEXTKEYBLOB;
        ((BLOBHEADER *) pbPlaintextBlob)->bVersion = CUR_BLOB_VERSION;

        *(DWORD *) (pbPlaintextBlob + sizeof(BLOBHEADER)) = cbDecrypted;

        memcpy(
            pbPlaintextBlob + sizeof(BLOBHEADER) + sizeof(DWORD),
            pbDecrypted,
            cbDecrypted);

        if (! CryptImportKey(
            pKeyContext->pUserContext->hSupportProv,
            pbPlaintextBlob,
            cbPlaintextBlob,
            0,
            pKeyContext->dwFlags,
            &pKeyContext->hSupportKey))
        {
            dwSts = GetLastError();
            goto Ret;
        }

        pKeyContext->Algid = pBlobHeader->aiKeyAlg;
        pKeyContext->cKeyBits = cbDecrypted * 8;

        break;

    case PRIVATEKEYBLOB:

        // We don't allow importing privatekey blobs into the smartcard 
        // CSP, and it doesn't make sense to use the helper CSP for this,
        // so fail.

        SetLocalCallInfo(pLocalCallInfo, FALSE);

        dwSts = (DWORD) NTE_BAD_TYPE;

        break;

    default:

        // For all other blob types, let the helper CSP take a shot.

        SetLocalCallInfo(pLocalCallInfo, TRUE);
    }


Ret:

    EndCardCapiCall(pKeyContext->pUserContext);

    if (pbDecrypted)
        CspFreeH(pbDecrypted);
    if (pbPlaintextBlob)
        CspFreeH(pbPlaintextBlob);

    LOG_END_CRYPTOAPI(LocalImportKey, dwSts);

    return dwSts;
}

//
// Function: LocalEncrypt
//
DWORD WINAPI
LocalEncrypt(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTHASH hHash,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD cbBufLen)
{
    *pcbDataLen = 0;

    //
    // TODO
    //

    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Function: LocalDecrypt
//
DWORD WINAPI
LocalDecrypt(
    IN  PKEY_CONTEXT pKeyCtx,
    IN  PHASH_CONTEXT pHashCtx,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PBYTE pbDecrypted = NULL;
    DWORD cbDecrypted = 0;
    CARD_PRIVATE_KEY_DECRYPT_INFO DecryptInfo;
    PLOCAL_USER_CONTEXT pLocal =
        (PLOCAL_USER_CONTEXT) pKeyCtx->pUserContext->pvLocalUserContext;

    LOG_BEGIN_CRYPTOAPI(LocalDecrypt);

    memset(&DecryptInfo, 0, sizeof(DecryptInfo));

    dwSts = CheckForVerifyContext(pKeyCtx->pUserContext, FALSE);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (AT_KEYEXCHANGE == pKeyCtx->Algid)
    {
        SetLocalCallInfo(pLocalCallInfo, FALSE);
    }
    else
    {
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        goto Ret;
    }

    dwSts = BeginCardCapiCall(pKeyCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = CspAuthenticateUser(pKeyCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    DecryptInfo.cbData = *pcbDataLen;
    DecryptInfo.dwKeySpec = AT_KEYEXCHANGE;
    DecryptInfo.dwVersion = CARD_PRIVATE_KEY_DECRYPT_INFO_CURRENT_VERSION;
    DecryptInfo.pbData = pbData;
    DecryptInfo.bContainerIndex = pLocal->bContainerIndex;

    dwSts = CspPrivateKeyDecrypt(
        pLocal->pCardState,
        &DecryptInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = VerifyPKCS2Padding(
        DecryptInfo.pbData,
        DecryptInfo.cbData,
        &pbDecrypted,
        &cbDecrypted);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    memcpy(
        pbData,
        pbDecrypted,
        cbDecrypted);

    *pcbDataLen = cbDecrypted;
    
Ret:
    EndCardCapiCall(pKeyCtx->pUserContext);
    
    if (pbDecrypted)
        CspFreeH(pbDecrypted);

    LOG_END_CRYPTOAPI(LocalDecrypt, dwSts);

    return dwSts;
}

//
// Function: LocalSignHash
//
DWORD WINAPI
LocalSignHash(
    IN  PHASH_CONTEXT pHashCtx,
    IN  DWORD dwKeySpec,
    IN  DWORD dwFlags,
    OUT LPBYTE pbSignature,
    IN OUT LPDWORD pcbSigLen,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pHashCtx->pUserContext->pvLocalUserContext;
    PBYTE pbHash = NULL;
    PBYTE pbSig = NULL;
    DWORD cbHash = 0;
    DWORD cbPrivateKey = 0;
    ALG_ID aiHash = 0;
    DWORD cbData = 0;
    CARD_PRIVATE_KEY_DECRYPT_INFO DecryptInfo;
    RSAPUBKEY *pPubKey = NULL; 

    LOG_BEGIN_CRYPTOAPI(LocalSignHash);

    SetLocalCallInfo(pLocalCallInfo, FALSE);

    dwSts = CheckForVerifyContext(pHashCtx->pUserContext, FALSE);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    
    memset(&DecryptInfo, 0, sizeof(DecryptInfo));

    dwSts = BeginCardCapiCall(pHashCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Get the size of the private key that will be used for signing
    //
    dwSts = GetKeyModulusLength(
        pHashCtx->pUserContext, dwKeySpec, &cbPrivateKey);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (*pcbSigLen < cbPrivateKey || NULL == pbSignature)
    {
        *pcbSigLen = cbPrivateKey;

        if (NULL != pbSignature)
            dwSts = ERROR_MORE_DATA;

        goto Ret;
    }

    //
    // Get the hash value we're going to sign
    //
    if (! CryptGetHashParam(
        pHashCtx->hSupportHash,
        HP_HASHVAL,
        NULL,
        &cbHash,
        0))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pbHash = (PBYTE) CspAllocH(cbHash);

    LOG_CHECK_ALLOC(pbHash);

    if (! CryptGetHashParam(
        pHashCtx->hSupportHash,
        HP_HASHVAL,
        pbHash,
        &cbHash,
        0))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // Get the algid of this hash so the correct encoding can be applied
    //
    cbData = sizeof(aiHash);

    if (! CryptGetHashParam(
        pHashCtx->hSupportHash,
        HP_ALGID,
        (PBYTE) &aiHash,
        &cbData,
        0))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // Apply PKCS1 encoding to this hash data.  It gets padded out to the 
    // length of the key modulus.  The padded buffer is allocated for us.
    //
    dwSts = ApplyPKCS1SigningFormat(
        aiHash,
        pbHash,
        cbHash,
        0,
        cbPrivateKey,
        &pbSig);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Private key decrypt the formatted data
    //
    dwSts = CspAuthenticateUser(pHashCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    DecryptInfo.cbData = cbPrivateKey;
    DecryptInfo.pbData = pbSig;
    DecryptInfo.dwKeySpec = dwKeySpec;
    DecryptInfo.dwVersion = CARD_PRIVATE_KEY_DECRYPT_INFO_CURRENT_VERSION;
    DecryptInfo.bContainerIndex = pLocal->bContainerIndex;

    dwSts = CspPrivateKeyDecrypt(
        pLocal->pCardState,
        &DecryptInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Copy the completed signature into the caller's buffer
    //
    memcpy(
        pbSignature,
        pbSig,
        cbPrivateKey);

    *pcbSigLen = cbPrivateKey;

Ret:
    EndCardCapiCall(pHashCtx->pUserContext);

    if (pbSig)
        CspFreeH(pbSig);
    if (pbHash)
        CspFreeH(pbHash);

    LOG_END_CRYPTOAPI(LocalSignHash, dwSts);

    return dwSts;
}

//
// Function: LocalVerifySignature
//
DWORD WINAPI
LocalVerifySignature(
    IN  PHASH_CONTEXT pHashCtx,
    IN  CONST BYTE *pbSignature,
    IN  DWORD cbSigLen,
    IN  PKEY_CONTEXT pKeyCtx,
    IN  DWORD dwFlags,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PLOCAL_USER_CONTEXT pLocal = 
        (PLOCAL_USER_CONTEXT) pHashCtx->pUserContext->pvLocalUserContext;
    CONTAINER_INFO ContainerInfo;
    HCRYPTKEY hKey = 0;
    BOOL fSignature = (AT_SIGNATURE == pKeyCtx->Algid);

    LOG_BEGIN_CRYPTOAPI(LocalVerifySignature);

    memset(&ContainerInfo, 0, sizeof(ContainerInfo));

    SetLocalCallInfo(pLocalCallInfo, FALSE);

    dwSts = CheckForVerifyContext(pHashCtx->pUserContext, FALSE);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = BeginCardCapiCall(pHashCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Get the public key
    //
    dwSts = CspGetContainerInfo(
        pLocal->pCardState,
        pLocal->bContainerIndex,
        0,
        &ContainerInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Import the public key into the helper CSP
    //
    if (! CryptImportKey(
        pHashCtx->pUserContext->hSupportProv,
        fSignature ? 
            ContainerInfo.pbSigPublicKey :
            ContainerInfo.pbKeyExPublicKey,
        fSignature ?
            ContainerInfo.cbSigPublicKey :
            ContainerInfo.cbKeyExPublicKey,
        0,
        0,
        &hKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    // 
    // Use the helper CSP to verify the signature
    //
    if (! CryptVerifySignature(
        pHashCtx->hSupportHash,
        pbSignature,
        cbSigLen,
        hKey,
        NULL,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

Ret:
    EndCardCapiCall(pHashCtx->pUserContext);

    CleanupContainerInfo(&ContainerInfo);
    
    if (hKey)
        CryptDestroyKey(hKey);

    LOG_END_CRYPTOAPI(LocalVerifySignature, dwSts);

    return dwSts;
}

//
// Function: LocalGetUserKey
//
DWORD WINAPI
LocalGetUserKey(
    IN  PKEY_CONTEXT pKeyCtx,
    OUT PLOCAL_CALL_INFO pLocalCallInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbKey = 0;

    LOG_BEGIN_CRYPTOAPI(LocalGetUserKey);

    if (AT_SIGNATURE == pKeyCtx->Algid || AT_KEYEXCHANGE == pKeyCtx->Algid)
    {
        SetLocalCallInfo(pLocalCallInfo, FALSE);
    }
    else
    {
        SetLocalCallInfo(pLocalCallInfo, TRUE);
        goto Ret;
    }

    dwSts = CheckForVerifyContext(pKeyCtx->pUserContext, TRUE);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = BeginCardCapiCall(pKeyCtx->pUserContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = GetKeyModulusLength(
        pKeyCtx->pUserContext,
        pKeyCtx->Algid,
        &cbKey);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (cbKey)
    {
        pKeyCtx->cKeyBits = cbKey * 8;
    }
    else
    {
        dwSts = (DWORD) NTE_NO_KEY;
        goto Ret;
    }

Ret:
    EndCardCapiCall(pKeyCtx->pUserContext);

    LOG_END_CRYPTOAPI(LocalGetUserKey, dwSts);

    return dwSts;
}

//
// Function: LocalDuplicateKey
//
DWORD WINAPI
LocalDuplicateKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  LPDWORD pdwReserved,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//
// Function: UnloadStrings
//
void
UnloadStrings(
    IN PCSP_STRING  pStrings,
    IN DWORD        cStrings)
{
    DWORD   iString = 0;

    for (   iString = 0; 
            iString < cStrings;
            iString++)
    {
        if (NULL != pStrings[iString].wszString)
        {
            CspFreeH(pStrings[iString].wszString);
            pStrings[iString].wszString = NULL;
        }
    }
}

//
// Function: LoadStrings
//
DWORD
LoadStrings(
    IN HMODULE      hMod,
    IN PCSP_STRING  pStrings,
    IN DWORD        cStrings)
{
    DWORD   dwSts = ERROR_INTERNAL_ERROR;
    DWORD   cch;
    WCHAR   wsz[MAX_PATH];
    DWORD   iString = 0;

    for (   iString = 0; 
            iString < cStrings;
            iString++)
    {
        cch = LoadStringW(
            hMod, 
            pStrings[iString].dwResource,
            wsz, 
            sizeof(wsz) / sizeof(wsz[0]));

        if (0 == cch)
        {
            dwSts = GetLastError();
            goto ErrorExit;
        }

        pStrings[iString].wszString = (LPWSTR) CspAllocH(sizeof(WCHAR) * (cch + 1));

        if (NULL == pStrings[iString].wszString)
        {
            dwSts = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(
            pStrings[iString].wszString,
            wsz);
    }

    return ERROR_SUCCESS;

ErrorExit:

    UnloadStrings(pStrings, cStrings);

    return dwSts;
}

//
// Function: LocalDllInitialize
//
BOOL WINAPI LocalDllInitialize(
    IN      PVOID               hmod,
    IN      ULONG               Reason,
    IN      PCONTEXT            Context)
{
    DWORD dwLen = 0;
    static BOOL fLoadedStrings = FALSE;
    static BOOL fInitializedCspState = FALSE;
    BOOL fSuccess = FALSE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        // load strings
        if (ERROR_SUCCESS != LoadStrings(
                hmod, 
                g_Strings, 
                sizeof(g_Strings) / sizeof(g_Strings[0])))
            goto Cleanup;
        
        fLoadedStrings = TRUE;

        // Initialize global CSP data for this process
        if (ERROR_SUCCESS != InitializeCspState(hmod))
            goto Cleanup;

        fInitializedCspState = TRUE;

        CspInitializeDebug();

        fSuccess = TRUE;
        break;

    case DLL_PROCESS_DETACH:

        CspUnloadDebug();

        fSuccess = TRUE;

        goto Cleanup;
    }
    
    return fSuccess;

Cleanup:

    if (fLoadedStrings)
    {
        UnloadStrings(
            g_Strings, 
            sizeof(g_Strings) / sizeof(g_Strings[0]));

        fLoadedStrings = FALSE;
    }

    if (fInitializedCspState)
    {
        DeleteCspState();
        fInitializedCspState = FALSE;
    }

    return fSuccess;
}

//
// Function: LocalDllRegisterServer
//
DWORD WINAPI LocalDllRegisterServer(void)
{
    HKEY hKey = 0;
    DWORD dwSts = ERROR_SUCCESS;

    dwSts = RegOpenProviderKey(&hKey, KEY_ALL_ACCESS);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    
    //
    // Add CSP default configuration
    //
    dwSts = RegConfigAddEntries(hKey);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}

//
// Declaration of the LOCAL_CSP_INFO structure required by the 
// CSP lib.  
//
LOCAL_CSP_INFO LocalCspInfo =
{

    LocalAcquireContext,    //pfnLocalAcquireContext;
    LocalReleaseContext,    //pfnLocalReleaseContext;
    LocalGenKey,            //pfnLocalGenKey;
    NULL,                   //pfnLocalDeriveKey;
    LocalDestroyKey,        //pfnLocalDestroyKey;
    LocalSetKeyParam,       //pfnLocalSetKeyParam;
    LocalGetKeyParam,       //pfnLocalGetKeyParam;
    LocalSetProvParam,      //pfnLocalSetProvParam;
    LocalGetProvParam,      //pfnLocalGetProvParam;
    NULL,                   //pfnLocalSetHashParam;
    NULL,                   //pfnLocalGetHashParam;
    LocalExportKey,         //pfnLocalExportKey;
    LocalImportKey,         //pfnLocalImportKey;
    NULL,                   //pfnLocalEncrypt;
    LocalDecrypt,           //pfnLocalDecrypt;
    NULL,                   //pfnLocalCreateHash;
    NULL,                   //pfnLocalHashData;
    NULL,                   //pfnLocalHashSessionKey;
    LocalSignHash,          //pfnLocalSignHash;
    NULL,                   //pfnLocalDestroyHash;
    LocalVerifySignature,   //pfnLocalVerifySignature;
    NULL,                   //pfnLocalGenRandom;
    LocalGetUserKey,        //pfnLocalGetUserKey;
    NULL,                   //pfnLocalDuplicateHash;
    NULL,                   //pfnLocalDuplicateKey;
    
    LocalDllInitialize,     //pfnLocalDllInitialize;
    LocalDllRegisterServer, //pfnLocalDllRegisterServer;
    NULL,                   //pfnLocalDllUnregisterServer;
    
    MS_SCARD_PROV_W,        //wszProviderName;
    PROV_RSA_FULL,          //dwProviderType;
    CRYPT_IMPL_REMOVABLE,
    
    MS_STRONG_PROV,         //wszSupportProviderName;
    PROV_RSA_FULL           //dwSupportProviderType;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\cardintf\cardintf.c ===
#include <windows.h>
#include "basecsp.h"
#include "cardmod.h"
#include "debug.h"

//
// Debugging Macros
//
#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_CACHE, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_CACHE, "%s: Leaving, status: 0x%x\n", #x, y)); }

//
// Type: CARD_CACHED_DATA_TYPE
//
// These values are used as keys for the card data cache,
// to distinguish the various types of cached data.
//
typedef enum
{
    Cached_CardCapabilities = 1,
    Cached_ContainerInfo,
    Cached_GeneralFile,
    Cached_FileEnumeration,
    Cached_ContainerEnumeration,
    Cached_KeySizes,
    Cached_FreeSpace,
    Cached_CardmodFile,
    Cached_Pin

} CARD_CACHED_DATA_TYPE;

//
// Type: CARD_CACHE_FRESHNESS_LOCATION
//
// These values distinguish the broad classes of card data.
// 
typedef DWORD CARD_CACHE_FRESHNESS_LOCATION;

#define CacheLocation_Pins              1
#define CacheLocation_Containers        2
#define CacheLocation_Files             4

//
// Type: CARD_CACHE_ITEM_INFO
//
// This struct is used as the actual item to be added to the 
// cache for each data item cached.  The data itself is expected to follow
// this header in memory, so that the blob can be managed by a single pointer.
//
typedef struct _CARD_CACHE_ITEM_INFO
{
    CARD_CACHE_FILE_FORMAT CacheFreshness;
    DWORD cbCachedItem;

} CARD_CACHE_ITEM_INFO, *PCARD_CACHE_ITEM_INFO;

//
// Used for the CARD_CACHE_QUERY_INFO dwQuerySource member
//
#define CARD_CACHE_QUERY_SOURCE_CSP         0
#define CARD_CACHE_QUERY_SOURCE_CARDMOD     1

// 
// Type: CARD_CACHE_QUERY_INFO
//
// This is the parameter list for the
// I_CspQueryCardCacheForItem function, below.
//
typedef struct _CARD_CACHE_QUERY_INFO
{
    // Input parameters
    PCARD_STATE pCardState;
    CARD_CACHE_FRESHNESS_LOCATION CacheLocation;
    BOOL fIsPerishable;
    DWORD cCacheKeys;
    DATA_BLOB *mpdbCacheKeys;
    DWORD dwQuerySource;

    // Output parameters
    CARD_CACHE_FILE_FORMAT CacheFreshness;
    BOOL fCheckedFreshness;
    PCARD_CACHE_ITEM_INFO pItem;
    BOOL fFoundStaleItem;

} CARD_CACHE_QUERY_INFO, *PCARD_CACHE_QUERY_INFO;

// 
// Function: CountCharsInMultiSz
//
DWORD CountCharsInMultiSz(
    IN LPWSTR mwszStrings)
{
    DWORD cch = 0;

    while (L'\0' != mwszStrings[cch])
        cch += wcslen(mwszStrings + cch) + 1;

    return cch + 1;
}

//
// Function: MyCacheAddItem
//
// Purpose: Provide the caching functionality of SCardCacheAddItem, until that 
//  function is available via winscard.dll
//
DWORD WINAPI MyCacheAddItem(
    IN PCARD_CACHE_QUERY_INFO pInfo,
    IN DATA_BLOB *pdbItem)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbLocalItem;
    CACHEHANDLE hCache = 0;

    memset(&dbLocalItem, 0, sizeof(dbLocalItem));

    if (CARD_CACHE_QUERY_SOURCE_CSP == pInfo->dwQuerySource &&
        NULL != pInfo->pCardState->pfnCacheAdd)
    {
        dwSts = pInfo->pCardState->pfnCacheAdd(
            pInfo->mpdbCacheKeys,
            pInfo->cCacheKeys,
            pdbItem);
    }
    else
    {
        switch (pInfo->dwQuerySource)
        {
        case CARD_CACHE_QUERY_SOURCE_CSP:
            hCache = pInfo->pCardState->hCache;
            break;
        case CARD_CACHE_QUERY_SOURCE_CARDMOD:
            hCache = pInfo->pCardState->hCacheCardModuleData;
            break;
        default:
            dwSts = ERROR_INTERNAL_ERROR;
            goto Ret;
        }

        //
        // Since we expect that the winscard cache will make a copy of our
        // data buffer, we need to do that here to expose the same 
        // behavior.
        //
        dbLocalItem.cbData = pdbItem->cbData;

        dbLocalItem.pbData = CspAllocH(pdbItem->cbData);

        LOG_CHECK_ALLOC(dbLocalItem.pbData);

        memcpy(
            dbLocalItem.pbData,
            pdbItem->pbData,
            dbLocalItem.cbData);

        dwSts = CacheAddItem(
            hCache,
            pInfo->mpdbCacheKeys,
            pInfo->cCacheKeys,
            &dbLocalItem);
    }

Ret:

    return dwSts;
}

//
// Function: MyCacheLookupItem
//
// Provide: Provide the caching functionality of SCardCacheLookupItem, until 
//  that function is available via winscard.dll.
//
//  Assumes that the caller will free the buffer pInfo->dbItem.pbData
//
DWORD WINAPI MyCacheLookupItem(
    IN      PCARD_CACHE_QUERY_INFO pInfo,
    IN OUT  PDATA_BLOB pdbItem)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbLocalItem;
    CACHEHANDLE hCache = 0;
    SCARD_CACHE_LOOKUP_ITEM_INFO ScardCacheLookup;

    memset(&dbLocalItem, 0, sizeof(dbLocalItem));
    memset(&ScardCacheLookup, 0, sizeof(ScardCacheLookup));

    if (pInfo->pCardState->pfnCacheLookup)
    {
        ScardCacheLookup.cCacheKey = pInfo->cCacheKeys;
        ScardCacheLookup.dwVersion = 
            SCARD_CACHE_LOOKUP_ITEM_INFO_CURRENT_VERSION;
        ScardCacheLookup.pfnAlloc = CspAllocH;
        ScardCacheLookup.mpdbCacheKey = pInfo->mpdbCacheKeys;

        dwSts = pInfo->pCardState->pfnCacheLookup(&ScardCacheLookup);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        pdbItem->cbData = ScardCacheLookup.dbItem.cbData;
        pdbItem->pbData = ScardCacheLookup.dbItem.pbData;
    }
    else
    {
        switch (pInfo->dwQuerySource)
        {
        case CARD_CACHE_QUERY_SOURCE_CSP:
            hCache = pInfo->pCardState->hCache;
            break;
        case CARD_CACHE_QUERY_SOURCE_CARDMOD:
            hCache = pInfo->pCardState->hCacheCardModuleData;
            break;
        default:
            dwSts = ERROR_INTERNAL_ERROR;
            goto Ret;
        }

        dwSts = CacheGetItem(
            hCache,
            pInfo->mpdbCacheKeys,
            pInfo->cCacheKeys,
            &dbLocalItem);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Expect that the winscard cache will make a copy of the cached data
        // buffer before returning it to us.  So, we need to make our own copy
        // of the buffer in this code path.
        //
        pdbItem->cbData = dbLocalItem.cbData;
        
        pdbItem->pbData = CspAllocH(dbLocalItem.cbData);
    
        LOG_CHECK_ALLOC(pdbItem->pbData);

        memcpy(
            pdbItem->pbData,
            dbLocalItem.pbData,
            pdbItem->cbData);
    }

Ret:

    return dwSts;
}

//
// Function: MyCacheDeleteItem
//
DWORD WINAPI MyCacheDeleteItem(
    IN PCARD_CACHE_QUERY_INFO pInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    CACHEHANDLE hCache = 0;

    //
    // We're only concerned about deleting cached items if we're doing local
    // caching.  Otherwise, we assume that the global cache is doing its own
    // management of stale items.
    //
    
    if (NULL == pInfo->pCardState->pfnCacheAdd ||
        CARD_CACHE_QUERY_SOURCE_CARDMOD == pInfo->dwQuerySource)
    {
        switch (pInfo->dwQuerySource)
        {
        case CARD_CACHE_QUERY_SOURCE_CSP:
            hCache = pInfo->pCardState->hCache;
            break;
        case CARD_CACHE_QUERY_SOURCE_CARDMOD:
            hCache = pInfo->pCardState->hCacheCardModuleData;
            break;
        default:
            dwSts = ERROR_INTERNAL_ERROR;
            goto Ret;
        }

        dwSts = CacheDeleteItem(
            hCache,
            pInfo->mpdbCacheKeys,
            pInfo->cCacheKeys);
    }

Ret:
    return dwSts;
}

//
// Function: I_CspReadCardCacheFile
//
DWORD I_CspReadCardCacheFile(
    IN PCARD_STATE pCardState,
    OUT PCARD_CACHE_FILE_FORMAT pCacheFile)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbCacheFile;

    if (FALSE == pCardState->fCacheFileValid)
    {
        memset(&dbCacheFile, 0, sizeof(dbCacheFile));
    
        dwSts = pCardState->pCardData->pfnCardReadFile(
            pCardState->pCardData,
            wszCACHE_FILE_FULL_PATH,
            0, 
            &dbCacheFile.pbData,
            &dbCacheFile.cbData);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    
        if (sizeof(CARD_CACHE_FILE_FORMAT) != dbCacheFile.cbData)
        {
            dwSts = ERROR_BAD_LENGTH;
            goto Ret;
        }
    
        memcpy(
            &pCardState->CacheFile,
            dbCacheFile.pbData,
            sizeof(CARD_CACHE_FILE_FORMAT));

        pCardState->fCacheFileValid = TRUE;

        CspFreeH(dbCacheFile.pbData);
    }

    memcpy(
        pCacheFile,
        &pCardState->CacheFile,
        sizeof(CARD_CACHE_FILE_FORMAT));

Ret:
    return dwSts;
}

// 
// Function: I_CspWriteCardCacheFile
//
DWORD I_CspWriteCardCacheFile(
    IN PCARD_STATE pCardState,
    IN PCARD_CACHE_FILE_FORMAT pCacheFile)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbCacheFile;

    memset(&dbCacheFile, 0, sizeof(dbCacheFile));

    dbCacheFile.pbData = (PBYTE) pCacheFile;
    dbCacheFile.cbData = sizeof(CARD_CACHE_FILE_FORMAT);

    dwSts = pCardState->pCardData->pfnCardWriteFile(
        pCardState->pCardData,
        wszCACHE_FILE_FULL_PATH,
        0, 
        dbCacheFile.pbData,
        dbCacheFile.cbData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Also update the cached copy of the cache file in the CARD_STATE.
    memcpy(
        &pCardState->CacheFile,
        pCacheFile,
        sizeof(CARD_CACHE_FILE_FORMAT));

    pCardState->fCacheFileValid = TRUE;

Ret:
    return dwSts;
}

//
// Function: I_CspIncrementCacheFreshness
//
// Purpose: Indicates that an item in the specified cache location is 
//          being updated.  As a result, the corresponding counter in 
//          the cache file will be incremented.
//
DWORD I_CspIncrementCacheFreshness(
    IN PCARD_STATE pCardState,
    IN CARD_CACHE_FRESHNESS_LOCATION CacheLocation,
    OUT PCARD_CACHE_FILE_FORMAT pNewFreshness)
{
    DWORD dwSts = ERROR_SUCCESS;

    memset(pNewFreshness, 0, sizeof(CARD_CACHE_FILE_FORMAT));

    dwSts = I_CspReadCardCacheFile(
        pCardState, pNewFreshness);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (CacheLocation_Pins & CacheLocation)
        ++pNewFreshness->bPinsFreshness;

    if (CacheLocation_Containers & CacheLocation)
        ++pNewFreshness->wContainersFreshness;

    if (CacheLocation_Files & CacheLocation)
        ++pNewFreshness->wFilesFreshness;

    dwSts = I_CspWriteCardCacheFile(
        pCardState, pNewFreshness);

Ret:
    return dwSts;
}

//
// Function: I_CspAddCardCacheItem
//
// Purpose: Abstract the process of caching some card data that has been
//          confirmed to not exist cached (or was removed for being
//          stale.
//          Copy the provided card data, wrap it in a CARD_CACHE_ITEM_INFO 
//          structure and then cache it.
//
// Assume: The card state critical section must be held by caller.  
//         I_CspQueryCardCacheForItem should be called before this function,
//         without releasing the crit sec between the two calls.
//
DWORD I_CspAddCardCacheItem(
    IN PCARD_CACHE_QUERY_INFO pInfo,
    IN PCARD_CACHE_ITEM_INFO pItem)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbItem;

    DsysAssert(NULL == pInfo->pItem);

    memset(&dbItem, 0, sizeof(dbItem));

    if (pInfo->fIsPerishable)
    {
        if (pInfo->fCheckedFreshness)
        {
            memcpy(
                &pItem->CacheFreshness,
                &pInfo->CacheFreshness,
                sizeof(pInfo->CacheFreshness));
        }
        else
        {
            // This item can stale, and we haven't already queried for the
            // current cache counter for this location, so do it now.

            dwSts = I_CspReadCardCacheFile(
                pInfo->pCardState,
                &pItem->CacheFreshness);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
        }
    }

    dbItem.pbData = (PBYTE) pItem;
    dbItem.cbData = sizeof(CARD_CACHE_ITEM_INFO) + pItem->cbCachedItem;

    dwSts = MyCacheAddItem(pInfo, &dbItem);

Ret:

    return dwSts;
}

//
// Function: I_CspQueryCardCacheForItem
// 
// Purpose: Abstract some of the processing that needs to be done for cache
//          lookups of card data.  If the item is found 
//          cached, check if it's perishable, and if so, if it's still valid.
//          If it's valid, done.
//          If the data is not valid, free it's resources and delete its
//          entry from the cache.
//
// Assume: The CARD_STATE critical section is assumed to be held by the caller.
//         Also, that the item returned by cache lookups is of type
//         CARD_CACHE_ITEM_INFO.
//
DWORD I_CspQueryCardCacheForItem(
    PCARD_CACHE_QUERY_INFO pInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCARD_CACHE_ITEM_INFO pCacheItem = NULL;
    BOOL fItemIsFresh = TRUE;
    DATA_BLOB dbLocalItem;

    LOG_BEGIN_FUNCTION(I_CspQueryCardCacheForItem);

    memset(&dbLocalItem, 0, sizeof(dbLocalItem));

    pInfo->pItem = NULL;

    dwSts = MyCacheLookupItem(pInfo, &dbLocalItem);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // Item was found cached

        pCacheItem = (PCARD_CACHE_ITEM_INFO) dbLocalItem.pbData;

        if (TRUE == pInfo->fIsPerishable)
        {
            // Is the cached data stale?

            if (FALSE == pInfo->fCheckedFreshness)
            {
                // We haven't already read the card cache file for this
                // query, so do it now.
                dwSts = I_CspReadCardCacheFile(
                    pInfo->pCardState,
                    &pInfo->CacheFreshness);
    
                if (ERROR_SUCCESS != dwSts)
                    goto Ret;
    
                pInfo->fCheckedFreshness = TRUE;
            }
    
            //
            // Mask out and check each cache counter location, since some
            // cached data types may be dependent on multiple cache 
            // locations to stay fresh.
            //

            if (CacheLocation_Pins & pInfo->CacheLocation)
            {
                if (    pCacheItem->CacheFreshness.bPinsFreshness < 
                        pInfo->CacheFreshness.bPinsFreshness)
                    fItemIsFresh = FALSE;
            }

            if (CacheLocation_Containers & pInfo->CacheLocation)
            {
                if (    pCacheItem->CacheFreshness.wContainersFreshness <
                        pInfo->CacheFreshness.wContainersFreshness)
                    fItemIsFresh = FALSE;
            }

            if (CacheLocation_Files & pInfo->CacheLocation)
            {
                if (    pCacheItem->CacheFreshness.wFilesFreshness <
                        pInfo->CacheFreshness.wFilesFreshness)
                    fItemIsFresh = FALSE;
            }

            if (FALSE == fItemIsFresh)
            {
                // Cached data is not fresh.  Delete it from the cache.

                pInfo->fFoundStaleItem = TRUE;
    
                dwSts = MyCacheDeleteItem(pInfo);
    
                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                // Set error to indicate no cached item is being
                // returned.
                dwSts = ERROR_NOT_FOUND;
                goto Ret;
            }
        }

        // Item is either not perishable, or still fresh.  

        pInfo->pItem = pCacheItem;
        pCacheItem = NULL;
    
        break;

    case ERROR_NOT_FOUND:
        // No cached data was found

        // Don't do anything else at this point, just report the
        // status to the caller.
        break;

    default:
        // some sort of unexpected error occurred
        goto Ret;
    }

Ret:

    if (pCacheItem)
        CspFreeH(pCacheItem);

    LOG_END_FUNCTION(I_CspQueryCardCacheForItem, dwSts);

    return dwSts;
}

//
// Initializes the CARD_CACHE_QUERY_INFO structure for a cache lookup
// being performed on behalf of the card module.
//
void I_CspCacheInitializeQueryForCardmod(
    IN      PVOID pvCacheContext,
    IN      LPWSTR wszFileName,
    IN OUT  PCARD_CACHE_QUERY_INFO pInfo,
    IN OUT  PDATA_BLOB mpdbCacheKeys,
    IN      DWORD cCacheKeys)
{
    CARD_CACHED_DATA_TYPE cachedType = Cached_CardmodFile;

    DsysAssert(3 == cCacheKeys);

    // Setup the cache keys for this item
    mpdbCacheKeys[0].cbData = sizeof(cachedType);
    mpdbCacheKeys[0].pbData = (PBYTE) &cachedType;

    mpdbCacheKeys[1].cbData = 
        wcslen(
            ((PCARD_STATE) pvCacheContext)->wszSerialNumber) * sizeof(WCHAR);
    mpdbCacheKeys[1].pbData = 
        (PBYTE) ((PCARD_STATE) pvCacheContext)->wszSerialNumber;

    mpdbCacheKeys[2].cbData = wcslen(wszFileName) * sizeof(wszFileName[0]); 
    mpdbCacheKeys[2].pbData = (PBYTE) wszFileName;

    //
    // Since the card module will use this function to cache files that
    // aren't "owned" by the Base CSP, and since cardmod files probably 
    // don't map to our CacheLocation's very well, assume that any change 
    // to any part of the card should cause this cached data to be staled.
    //
    pInfo->CacheLocation = 
        CacheLocation_Pins | CacheLocation_Files | CacheLocation_Containers;

    pInfo->cCacheKeys = cCacheKeys;
    pInfo->dwQuerySource = CARD_CACHE_QUERY_SOURCE_CARDMOD;
    pInfo->fIsPerishable = TRUE;
    pInfo->mpdbCacheKeys = mpdbCacheKeys;
    pInfo->pCardState = (PCARD_STATE) pvCacheContext;
}

//
// Cache "Add item" function exposed to the card module.
//
DWORD WINAPI CspCacheAddFileProc(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    PCARD_CACHE_ITEM_INFO pItem = NULL;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;

    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    if (0 == cbData || NULL == pbData)
        goto Ret;

    // Copy the data to be cached into a buffer w/ space for a cache
    // header.
    pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
        sizeof(CARD_CACHE_ITEM_INFO) + cbData);

    LOG_CHECK_ALLOC(pItem);

    memcpy(
        ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
        pbData,
        cbData);

    pItem->cbCachedItem = cbData;

    I_CspCacheInitializeQueryForCardmod(
        pvCacheContext, 
        wszTag, 
        &CacheQueryInfo, 
        rgdbKeys, 
        sizeof(rgdbKeys) / sizeof(rgdbKeys[0]));

    dwSts = I_CspAddCardCacheItem(&CacheQueryInfo, pItem);

Ret:

    if (pItem)
        CspFreeH(pItem);

    return dwSts;
}

//
// Cache "Lookup item" function exposed to the card module.
//
DWORD WINAPI CspCacheLookupFileProc(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHE_QUERY_INFO CacheQueryInfo;

    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    *ppbData = NULL;
    *pcbData = 0;

    I_CspCacheInitializeQueryForCardmod(
        pvCacheContext, 
        wszTag, 
        &CacheQueryInfo,
        rgdbKeys,
        sizeof(rgdbKeys) / sizeof(rgdbKeys[0]));

    dwSts = I_CspQueryCardCacheForItem(&CacheQueryInfo);

    // Will return ERROR_NOT_FOUND if no matching cached item was found.
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    *pcbData = CacheQueryInfo.pItem->cbCachedItem;

    *ppbData = (PBYTE) CspAllocH(*pcbData);

    LOG_CHECK_ALLOC(*ppbData);

    memcpy(
        *ppbData,
        ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
        *pcbData);

Ret:

    return dwSts;
}

//
// Cache "Delete item" function exposed to the card module.
//
DWORD WINAPI CspCacheDeleteFileProc(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHE_QUERY_INFO CacheQueryInfo;

    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    I_CspCacheInitializeQueryForCardmod(
        pvCacheContext, 
        wszTag, 
        &CacheQueryInfo,
        rgdbKeys,
        sizeof(rgdbKeys) / sizeof(rgdbKeys[0]));

    dwSts = MyCacheDeleteItem(&CacheQueryInfo);

    return dwSts;
}

//
// Initializes caching for the CSP and for the caching helper routines
// provided to the card module.
//
DWORD InitializeCspCaching(
    IN OUT PCARD_STATE pCardState)
{
    DWORD dwSts = ERROR_SUCCESS;
    CACHE_INITIALIZE_INFO CacheInitializeInfo;

    memset(&CacheInitializeInfo, 0, sizeof(CacheInitializeInfo));
 
    //
    // Initialize caching for the CSP
    //

    // Data cached by the CSP should be cached system-wide if possible.
    CacheInitializeInfo.dwType = CACHE_TYPE_SERVICE;

    //
    // Initialize our data caching routines.  First, see if winscard.dll 
    // provides caching routines.  If it does, use them.  Otherwise,
    // use our own local cache.
    //

    pCardState->hWinscard = LoadLibrary(L"winscard.dll");

    if (NULL == pCardState->hWinscard)
    {
        dwSts = GetLastError();
        goto Ret;
    }
    
    pCardState->pfnCacheLookup = (PFN_SCARD_CACHE_LOOKUP_ITEM) GetProcAddress(
        pCardState->hWinscard,
        "SCardCacheLookupItem");

    if (NULL == pCardState->pfnCacheLookup)
    {
        // Since this export is missing from winscard, use local caching.

        dwSts = CacheInitializeCache(
            &pCardState->hCache,
            &CacheInitializeInfo);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }
    else
    {
        pCardState->pfnCacheAdd = (PFN_SCARD_CACHE_ADD_ITEM) GetProcAddress(
            pCardState->hWinscard,
            "SCardCacheAddItem");

        if (NULL == pCardState->pfnCacheAdd)
        {
            dwSts = GetLastError();
            goto Ret;
        }
    }

    //
    // Initialize caching for the card module
    //

    // Assume that file data cached by the card module should only be 
    // maintained per-process, not system-wide.
    CacheInitializeInfo.dwType = CACHE_TYPE_IN_PROC;

    dwSts = CacheInitializeCache(
        &pCardState->hCacheCardModuleData,
        &CacheInitializeInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // When the card module calls back to use our caching routines,
    // we need a pointer to the CARD_STATE.
    pCardState->pCardData->pvCacheContext = pCardState;

    pCardState->pCardData->pfnCspCacheAddFile = CspCacheAddFileProc;
    pCardState->pCardData->pfnCspCacheDeleteFile = CspCacheDeleteFileProc;
    pCardState->pCardData->pfnCspCacheLookupFile = CspCacheLookupFileProc;

Ret:

    return dwSts;
}


//
// Function: InitializeCardState
//
DWORD InitializeCardState(
    IN OUT PCARD_STATE pCardState)
{
    DWORD dwSts = ERROR_SUCCESS;

    dwSts = CspInitializeCriticalSection(
        &pCardState->cs);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    else
        pCardState->fInitializedCS = TRUE;

Ret:
    if (ERROR_SUCCESS != dwSts)
        DeleteCardState(pCardState);

    return dwSts;
}

//
// Takes an array of DATA_BLOB structures, enumerated from a cache.
// Frees all "pbData" pointers in the array.
//
void FreeCacheItems(
    PDATA_BLOB pdbItems,
    DWORD cItems)
{
    PCARD_CACHE_ITEM_INFO pItemInfo = NULL;
    PCONTAINER_INFO pContainerInfo = NULL;

    while (0 != cItems--)
        CspFreeH(pdbItems[cItems].pbData);
}


// 
// Function: InitializeCardData
//
DWORD InitializeCardData(PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    CACHE_INITIALIZE_INFO CacheInitializeInfo;

    memset(&CacheInitializeInfo, 0, sizeof(CacheInitializeInfo));

    pCardData->dwVersion = CARD_DATA_CURRENT_VERSION;
    pCardData->pfnCspAlloc = CspAllocH;
    pCardData->pfnCspReAlloc = CspReAllocH;
    pCardData->pfnCspFree = CspFreeH;

    return dwSts;
}

//
// Function: CleanupCardData
//
void CleanupCardData(PCARD_DATA pCardData)
{
    if (pCardData->pfnCardDeleteContext)
        pCardData->pfnCardDeleteContext(pCardData);

    if (pCardData->pbAtr)
    {
        CspFreeH(pCardData->pbAtr);
        pCardData->pbAtr = NULL;
    }

    if (pCardData->pwszCardName)
    {
        CspFreeH(pCardData->pwszCardName);
        pCardData->pwszCardName = NULL;
    }

    if (pCardData->hScard)
    {
        SCardDisconnect(pCardData->hScard, SCARD_LEAVE_CARD);
        pCardData->hScard = 0;
    }

    if (pCardData->hSCardCtx)
    {
        SCardReleaseContext(pCardData->hSCardCtx);
        pCardData->hSCardCtx = 0;
    }
}

//
// Enumerates and frees all items in the cache, then deletes the cache.
//
void DeleteCacheAndAllItems(CACHEHANDLE hCache)
{
    PDATA_BLOB pdbCacheItems = NULL;
    DWORD cCacheItems = 0;

    if (ERROR_SUCCESS == CacheEnumItems(
        hCache, &pdbCacheItems, &cCacheItems))
    {
        FreeCacheItems(pdbCacheItems, cCacheItems);
        CacheFreeEnumItems(pdbCacheItems);
    }

    CacheDeleteCache(hCache);
}

// 
// Function: DeleteCardState
//
void DeleteCardState(PCARD_STATE pCardState)
{
    DWORD dwSts = ERROR_SUCCESS;

    if (pCardState->fInitializedCS)
        CspDeleteCriticalSection(
            &pCardState->cs);

    if (pCardState->hCache)
    {
        // Need to free all of our cached data before
        // deleting the cache handle.

        DeleteCacheAndAllItems(pCardState->hCache);
        pCardState->hCache = 0;
    }
  
    if (pCardState->hCacheCardModuleData)
    {
        // Need to free the card module cached data.

        DeleteCacheAndAllItems(pCardState->hCacheCardModuleData);
        pCardState->hCacheCardModuleData = 0;
    }

    if (pCardState->hWinscard)
    {
        FreeLibrary(pCardState->hWinscard);
        pCardState->hWinscard = NULL;
        pCardState->pfnCacheAdd = NULL;
        pCardState->pfnCacheLookup = NULL;
    }

    if (pCardState->pCardData)            
    {
        CleanupCardData(pCardState->pCardData);
        CspFreeH(pCardState->pCardData);
    }

    if (pCardState->hCardModule)
        FreeLibrary(pCardState->hCardModule);
}

//
// Function: CspQueryCapabilities
//
DWORD
WINAPI
CspQueryCapabilities(
    IN      PCARD_STATE         pCardState,
    IN OUT  PCARD_CAPABILITIES  pCardCapabilities)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    DATA_BLOB rgdbKeys[2];
    PCARD_CACHE_ITEM_INFO pItem = NULL;
    CARD_CACHED_DATA_TYPE cachedType = Cached_CardCapabilities;

    memset(rgdbKeys, 0, sizeof(rgdbKeys));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    rgdbKeys[0].pbData = (PBYTE) &cachedType;
    rgdbKeys[0].cbData = sizeof(cachedType);

    rgdbKeys[1].pbData = (PBYTE) pCardState->wszSerialNumber;
    rgdbKeys[1].cbData = 
        sizeof(WCHAR) * wcslen(pCardState->wszSerialNumber);

    // Card Capabilities data item is Non-Perishable
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKeys) / sizeof(rgdbKeys[0]);
    CacheQueryInfo.mpdbCacheKeys = rgdbKeys;
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_NOT_FOUND:

        // This data has not yet been cached.  We'll have to 
        // query the data from the card module.

        dwSts = pCardState->pCardData->pfnCardQueryCapabilities(
            pCardState->pCardData,
            pCardCapabilities);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Now add this data to the cache before returning.

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) + sizeof(CARD_CAPABILITIES));

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = sizeof(CARD_CAPABILITIES);

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            pCardCapabilities,
            sizeof(CARD_CAPABILITIES));

        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    case ERROR_SUCCESS:

        //
        // The data was found in the cache.  
        //

        DsysAssert(
            sizeof(CARD_CAPABILITIES) == CacheQueryInfo.pItem->cbCachedItem);

        memcpy(
            pCardCapabilities,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            sizeof(CARD_CAPABILITIES));

        break;

    default:

        // Unexpected error
        break;
    }

Ret:

    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);
    if (pItem)
        CspFreeH(pItem);

    return dwSts;
}

//
// Function: CspDeleteContainer
//
DWORD
WINAPI
CspDeleteContainer(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwReserved)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_ContainerInfo;
    CARD_CACHE_FILE_FORMAT CacheFile;
    CARD_CACHE_QUERY_INFO QueryInfo;

    memset(&QueryInfo, 0, sizeof(QueryInfo));
    memset(rgdbKeys, 0, sizeof(rgdbKeys));

    //
    // First, update the cache file.
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Containers, 
        &CacheFile);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Do the container deletion in the card module
    //

    dwSts = pCardState->pCardData->pfnCardDeleteContainer(
        pCardState->pCardData,
        bContainerIndex,
        dwReserved);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Finally, delete any cached Container Information for the
    // specified container.
    //

    // First part of key is data type
    rgdbKeys[0].cbData = sizeof(cachedType);
    rgdbKeys[0].pbData = (PBYTE) &cachedType;
    
    // Second part of key is container name
    rgdbKeys[1].cbData = sizeof(bContainerIndex);
    rgdbKeys[1].pbData = &bContainerIndex;

    rgdbKeys[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKeys[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    QueryInfo.cCacheKeys = sizeof(rgdbKeys) / sizeof(rgdbKeys[0]);
    QueryInfo.mpdbCacheKeys = rgdbKeys;
    QueryInfo.pCardState = pCardState;

    MyCacheDeleteItem(&QueryInfo);

Ret:

    return dwSts;
}

//
// Function: CspCreateContainer
//
DWORD
WINAPI
CspCreateContainer(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwKeySize,
    IN      PBYTE       pbKeyData)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_CACHE_FILE_FORMAT CacheFreshness;

    memset(&CacheFreshness, 0, sizeof(CacheFreshness));

    //
    // Update the cache file
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Containers, 
        &CacheFreshness);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Create the container on (and/or add the keyset to) the card
    //

    dwSts = pCardState->pCardData->pfnCardCreateContainer(
        pCardState->pCardData,
        bContainerIndex,
        dwFlags,
        dwKeySpec,
        dwKeySize,
        pbKeyData);

Ret:

    return dwSts;
}

//
// Function: CspGetContainerInfo
//
// Purpose: Query for key information for the specified container.
//
//          Note, the public key buffers returned in the PCONTAINER_INFO
//          struct must be freed by the caller.
//
DWORD
WINAPI
CspGetContainerInfo(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN OUT  PCONTAINER_INFO pContainerInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_ContainerInfo;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    // first part of cache key is item type
    rgdbKey[0].cbData = sizeof(cachedType);
    rgdbKey[0].pbData = (PBYTE) &cachedType;

    // second part of cache key is container name
    rgdbKey[1].cbData = sizeof(bContainerIndex);
    rgdbKey[1].pbData = &bContainerIndex;

    rgdbKey[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKey[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    CacheQueryInfo.CacheLocation = CacheLocation_Containers;
    CacheQueryInfo.fIsPerishable = TRUE;
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKey) / sizeof(rgdbKey[0]);
    CacheQueryInfo.mpdbCacheKeys = rgdbKey;
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // Item was successfully found cached.  

        //
        // This data length includes the size of the public keys, so we can 
        // only check a minimum size for the cached data.
        //
        DsysAssert(sizeof(CONTAINER_INFO) <= CacheQueryInfo.pItem->cbCachedItem);

        memcpy(
            pContainerInfo,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            sizeof(CONTAINER_INFO));

        //
        // Now we can check the exact length of the cached blob for sanity.
        //
        DsysAssert(
            sizeof(CONTAINER_INFO) + 
            pContainerInfo->cbKeyExPublicKey + 
            pContainerInfo->cbSigPublicKey == 
            CacheQueryInfo.pItem->cbCachedItem);

        //
        // If the Signature and Key Exchange public keys exist, copy them out
        // of the "flat" cache structure.
        //
        
        if (pContainerInfo->cbKeyExPublicKey)
        {
            pContainerInfo->pbKeyExPublicKey = CspAllocH(
                pContainerInfo->cbKeyExPublicKey);

            LOG_CHECK_ALLOC(pContainerInfo->pbKeyExPublicKey);

            memcpy(
                pContainerInfo->pbKeyExPublicKey,
                ((PBYTE) CacheQueryInfo.pItem) +
                    sizeof(CARD_CACHE_ITEM_INFO) +
                    sizeof(CONTAINER_INFO),
                pContainerInfo->cbKeyExPublicKey);
        }

        if (pContainerInfo->cbSigPublicKey)
        {
            pContainerInfo->pbSigPublicKey = CspAllocH(
                pContainerInfo->cbSigPublicKey);

            LOG_CHECK_ALLOC(pContainerInfo->pbSigPublicKey);

            memcpy(
                pContainerInfo->pbSigPublicKey,
                ((PBYTE) CacheQueryInfo.pItem) +
                    sizeof(CARD_CACHE_ITEM_INFO) +
                    sizeof(CONTAINER_INFO),
                pContainerInfo->cbSigPublicKey);
        }

        break;

    case ERROR_NOT_FOUND:
        // No matching item was found cached, or the found item
        // was stale.  Have to read it from the card.

        //
        // Send the request to the card module
        //

        dwSts = pCardState->pCardData->pfnCardGetContainerInfo(
            pCardState->pCardData,
            bContainerIndex,
            dwFlags,
            pContainerInfo);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        //
        // Cache the returned container information
        //

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) +
            sizeof(CONTAINER_INFO) +
            pContainerInfo->cbKeyExPublicKey +
            pContainerInfo->cbSigPublicKey);

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = 
            sizeof(CONTAINER_INFO) +
            pContainerInfo->cbKeyExPublicKey +
            pContainerInfo->cbSigPublicKey;

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            pContainerInfo,
            sizeof(CONTAINER_INFO));

        if (pContainerInfo->pbKeyExPublicKey)
        {
            memcpy(
                ((PBYTE) pItem) + 
                    sizeof(CARD_CACHE_ITEM_INFO) + 
                    sizeof(CONTAINER_INFO),
                pContainerInfo->pbKeyExPublicKey,
                pContainerInfo->cbKeyExPublicKey);
        }

        if (pContainerInfo->pbSigPublicKey)
        {
            memcpy(
                ((PBYTE) pItem) + 
                    sizeof(CARD_CACHE_ITEM_INFO) + 
                    sizeof(CONTAINER_INFO) +
                    pContainerInfo->cbKeyExPublicKey,
                pContainerInfo->pbSigPublicKey,
                pContainerInfo->cbSigPublicKey);
        }

        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    default:
        // An unexpected error occurred.
        goto Ret;
    }

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    if (ERROR_SUCCESS != dwSts)
    {
        if (pContainerInfo->pbKeyExPublicKey)
        {
            CspFreeH(pContainerInfo->pbKeyExPublicKey);
            pContainerInfo->pbKeyExPublicKey = NULL;
        }

        if (pContainerInfo->pbSigPublicKey)
        {
            CspFreeH(pContainerInfo->pbSigPublicKey);
            pContainerInfo->pbSigPublicKey = NULL;
        }
    }
    
    return dwSts;
}

//
// Initializes the cache lookup keys and CARD_CACHE_QUERY_INFO structure
// pin-related cache operations.
//
void I_BuildPinCacheQueryInfo(
    IN      PCARD_STATE             pCardState,
    IN      LPWSTR                  pwszUserId,
    IN      PDATA_BLOB              pdbKey,
    IN      CARD_CACHED_DATA_TYPE   *pType,
    IN OUT  PCARD_CACHE_QUERY_INFO  pInfo)
{
    // first part of cache key is item type
    pdbKey[0].cbData = sizeof(CARD_CACHED_DATA_TYPE);
    pdbKey[0].pbData = (PBYTE) pType;

    // second part of cache key is user name
    pdbKey[1].cbData = 
        wcslen(pwszUserId) * sizeof(WCHAR);
    pdbKey[1].pbData = (PBYTE) pwszUserId;

    pdbKey[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    pdbKey[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    pInfo->CacheLocation = CacheLocation_Pins;
    pInfo->fIsPerishable = TRUE;
    pInfo->mpdbCacheKeys = pdbKey;
    pInfo->cCacheKeys = 3;
    pInfo->pCardState = pCardState;
}

//
// Removes cached pin information for the specified user from the general data
// cache and the PinCache.
//
void
WINAPI
CspRemoveCachedPin(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId)
{
    DATA_BLOB rgdbKey[3];
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;
    CARD_CACHED_DATA_TYPE cachedType = Cached_Pin;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    I_BuildPinCacheQueryInfo(
        pCardState, pwszUserId, rgdbKey, &cachedType, &CacheQueryInfo);

    MyCacheDeleteItem(&CacheQueryInfo);

    PinCacheFlush(&pCardState->hPinCache);
}

// 
// Record the change of the pin (or challenge) for the specified user in 
// the data cache, and increment the pin cache counter on the card.
//
DWORD
WINAPI
CspChangeAuthenticator(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbCurrentAuthenticator,
    IN      DWORD       cbCurrentAuthenticator,
    IN      PBYTE       pbNewAuthenticator,
    IN      DWORD       cbNewAuthenticator,
    IN      DWORD       cRetryCount,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[3];
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;
    CARD_CACHED_DATA_TYPE cachedType = Cached_Pin;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    //
    // Do the requestion operation
    //

    dwSts = pCardState->pCardData->pfnCardChangeAuthenticator(
        pCardState->pCardData,
        pwszUserId,
        pbCurrentAuthenticator,
        cbCurrentAuthenticator,
        pbNewAuthenticator,
        cbNewAuthenticator,
        cRetryCount,
        pcAttemptsRemaining);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Update the Pins freshness counter of the card cache file.  We do
    // this after the pin change because we need to wait for the card to be
    // authenticated.
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Pins, 
        &CacheQueryInfo.CacheFreshness);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // 
    // Delete any existing entry for this user-pin in the cache
    //

    I_BuildPinCacheQueryInfo(
        pCardState, pwszUserId, rgdbKey, &cachedType, &CacheQueryInfo);

    MyCacheDeleteItem(&CacheQueryInfo);

    //
    // Cache the updated pin info
    //

    pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
        sizeof(CARD_CACHE_ITEM_INFO));

    LOG_CHECK_ALLOC(pItem);

    dwSts = I_CspAddCardCacheItem(
        &CacheQueryInfo,
        pItem);

Ret:

    if (pItem)
        CspFreeH(pItem);

    return dwSts;
}

// 
// -- Expect that CspSubmitPin is only called from within a PinCache verify-pin
// callback.  This is because the pbPin is expected to have come directly
// from the pin cache, and therefore may be stale.  
//
// -- Expect that the user pin in the pin cache is tightly coupled to the 
// cache stamp information cached in the general data cache for the user.
// That is, the cached pin must have been the correct pin when the pin-location
// cache stamp on the card had the stamp value that is stored in the general 
// cache.
//
// This allows us to avoid presenting a pin to the card that we already know is
// wrong.  This could happen, for example, if the pin has been changed via a 
// separate process.
//
DWORD
WINAPI
CspSubmitPin(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId,
    IN      PBYTE       pbPin,
    IN      DWORD       cbPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[3];
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;
    CARD_CACHED_DATA_TYPE cachedType = Cached_Pin;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    I_BuildPinCacheQueryInfo(
        pCardState, pwszUserId, rgdbKey, &cachedType, &CacheQueryInfo);

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // The user's cached pin appears to be synchronized with the pin 
        // cache counter on the card.  Do the submit.

        break;

    case ERROR_NOT_FOUND:

        if (TRUE == CacheQueryInfo.fFoundStaleItem)
        {
            //
            // The user's cached pin is out of synch with the pin cache counter.
            // Don't do the submit, but return a sensible error code.
            //

            dwSts = SCARD_W_WRONG_CHV;
            goto Ret;
        }

        // There is no cached pin information for this user yet.  Add it now.

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO));

        LOG_CHECK_ALLOC(pItem);

        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Now continue and submit the pin

        break;

    default:
        // Unexpected error occurred

        goto Ret;
    }

    dwSts = pCardState->pCardData->pfnCardSubmitPin(
        pCardState->pCardData,
        pwszUserId,
        pbPin,
        cbPin,
        pcAttemptsRemaining);

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    return dwSts;
}

//
// Function: CspCreateFile
//
DWORD
WINAPI
CspCreateFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_CACHE_FILE_FORMAT CacheFreshness;

    memset(&CacheFreshness, 0, sizeof(CacheFreshness));

    //
    // Update the Files freshness counter of the card cache file
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Files, 
        &CacheFreshness);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = pCardState->pCardData->pfnCardCreateFile(
        pCardState->pCardData,
        pwszFileName,
        AccessCondition);

Ret:

    return dwSts;
}

//
// Function: CspReadFile
//
DWORD 
WINAPI
CspReadFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    OUT     PBYTE       *ppbData,
    OUT     PDWORD      pcbData)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_GeneralFile;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    // first part of cache key is item type
    rgdbKey[0].cbData = sizeof(cachedType);
    rgdbKey[0].pbData = (PBYTE) &cachedType;

    // second part of cache key is file name
    rgdbKey[1].cbData = 
        wcslen(pwszFileName) * sizeof(WCHAR);
    rgdbKey[1].pbData = (PBYTE) pwszFileName;

    rgdbKey[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKey[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    CacheQueryInfo.CacheLocation = CacheLocation_Files;
    CacheQueryInfo.fIsPerishable = TRUE;
    CacheQueryInfo.mpdbCacheKeys = rgdbKey;
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKey) / sizeof(rgdbKey[0]);
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // This file was found cached and up to date.

        *pcbData = CacheQueryInfo.pItem->cbCachedItem;

        *ppbData = CspAllocH(*pcbData);

        LOG_CHECK_ALLOC(*ppbData);

        memcpy(
            *ppbData,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            *pcbData);

        break;

    case ERROR_NOT_FOUND:
        // An up-to-date cached version of the file was not found

        dwSts = pCardState->pCardData->pfnCardReadFile(
            pCardState->pCardData,
            pwszFileName,
            dwFlags,
            ppbData,
            pcbData);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) + *pcbData);

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = *pcbData;

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            *ppbData,
            *pcbData);

        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    default:
        // Unexpected error occurred

        break;
    }

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    if (ERROR_SUCCESS != dwSts)
    {
        if (*ppbData)
        {
            CspFreeH(*ppbData);
            *ppbData = NULL;
        }
    }

    return dwSts;
}

//
// Function: CspWriteFile
//
DWORD
WINAPI
CspWriteFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_GeneralFile;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKeys, 0, sizeof(rgdbKeys));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    //
    // Update the Files freshness counter of the card cache file
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Files, 
        &CacheQueryInfo.CacheFreshness);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // 
    // Delete any existing entry for this file in the cache
    //

    // First cache lookup key is data type
    rgdbKeys[0].cbData = sizeof(cachedType);
    rgdbKeys[0].pbData = (PBYTE) &cachedType;

    // Second cache lookup key is filename
    rgdbKeys[1].cbData = wcslen(pwszFileName) * sizeof(WCHAR);
    rgdbKeys[1].pbData = (PBYTE) pwszFileName;

    rgdbKeys[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKeys[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    CacheQueryInfo.fCheckedFreshness = TRUE;
    CacheQueryInfo.fIsPerishable = TRUE;
    CacheQueryInfo.mpdbCacheKeys = rgdbKeys;
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKeys) / sizeof(rgdbKeys[0]);
    CacheQueryInfo.CacheLocation = CacheLocation_Files;
    CacheQueryInfo.pCardState = pCardState;

    //
    // Since we know that any currently cached data for this file is  
    // obsolete, make an attempt to delete it from the cache.
    //

    MyCacheDeleteItem(&CacheQueryInfo);

    //
    // Perform the Write File operation
    //

    dwSts = pCardState->pCardData->pfnCardWriteFile(
        pCardState->pCardData,
        pwszFileName,
        dwFlags,
        pbData,
        cbData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Cache the updated file contents
    //

    pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
        sizeof(CARD_CACHE_ITEM_INFO) + cbData);

    LOG_CHECK_ALLOC(pItem);

    pItem->cbCachedItem = cbData;

    memcpy(
        ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
        pbData,
        cbData);

    dwSts = I_CspAddCardCacheItem(
        &CacheQueryInfo,
        pItem);

Ret:

    if (pItem)
        CspFreeH(pItem);

    return dwSts;
}

//
// Function: CspDeleteFile
//
DWORD
WINAPI
CspDeleteFile(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwReserved,
    IN      LPWSTR      pwszFileName)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_GeneralFile;
    CARD_CACHE_FILE_FORMAT CacheFile;
    CARD_CACHE_QUERY_INFO QueryInfo;

    memset(rgdbKeys, 0, sizeof(rgdbKeys));
    memset(&QueryInfo, 0, sizeof(QueryInfo));

    //
    // Update the Files freshness counter of the card cache file
    //

    dwSts = I_CspIncrementCacheFreshness(
        pCardState, 
        CacheLocation_Files, 
        &CacheFile);
    
    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // 
    // Delete any existing entry for this file in the cache
    //

    // First cache lookup key is data type
    rgdbKeys[0].cbData = sizeof(cachedType);
    rgdbKeys[0].pbData = (PBYTE) &cachedType;

    // Second cache lookup key is filename
    rgdbKeys[1].cbData = wcslen(pwszFileName) * sizeof(WCHAR);
    rgdbKeys[1].pbData = (PBYTE) pwszFileName;

    rgdbKeys[2].cbData =
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKeys[2].pbData = (PBYTE) pCardState->wszSerialNumber;

    QueryInfo.cCacheKeys = sizeof(rgdbKeys) / sizeof(rgdbKeys[0]);
    QueryInfo.mpdbCacheKeys = rgdbKeys;
    QueryInfo.pCardState = pCardState;

    MyCacheDeleteItem(&QueryInfo);

    //
    // Do the CardDeleteFile operation
    //

    dwSts = pCardState->pCardData->pfnCardDeleteFile(
        pCardState->pCardData,
        dwReserved,
        pwszFileName);

Ret:

    return dwSts;
}

//
// Function: CspEnumFiles
//
DWORD
WINAPI
CspEnumFiles(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwFlags,
    IN OUT  LPWSTR      *pmwszFileNames)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[2];
    CARD_CACHED_DATA_TYPE cachedType = Cached_FileEnumeration;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    DWORD cbFileNames = 0;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    // cache key is item type
    rgdbKey[0].cbData = sizeof(cachedType);
    rgdbKey[0].pbData = (PBYTE) &cachedType;

    rgdbKey[1].cbData =
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKey[1].pbData = (PBYTE) pCardState->wszSerialNumber;

    CacheQueryInfo.CacheLocation = CacheLocation_Files;
    CacheQueryInfo.fIsPerishable = TRUE;
    CacheQueryInfo.mpdbCacheKeys = rgdbKey;
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKey) / sizeof(rgdbKey[0]);
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // The list of files was found cached and up to date.

        *pmwszFileNames = (LPWSTR) CspAllocH(
            CacheQueryInfo.pItem->cbCachedItem);

        memcpy(
            (PBYTE) *pmwszFileNames,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            CacheQueryInfo.pItem->cbCachedItem);

        break;

    case ERROR_NOT_FOUND:
        // An up-to-date cached version of the file was not found
        
        dwSts = pCardState->pCardData->pfnCardEnumFiles(
            pCardState->pCardData,
            dwFlags,
            pmwszFileNames);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        cbFileNames = 
            sizeof(WCHAR) * CountCharsInMultiSz(*pmwszFileNames);

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) + cbFileNames);

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = cbFileNames;

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            (PBYTE) *pmwszFileNames,
            cbFileNames);

        // Cache the new data
        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    default:
        // Unexpected error occurred

        break;
    }

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    if (ERROR_SUCCESS != dwSts)
    {
        if (*pmwszFileNames)
        {
            CspFreeH(*pmwszFileNames);
            *pmwszFileNames = NULL;
        }
    }

    return dwSts;
}

//
// Function: CspQueryFreeSpace
//                                         
DWORD
WINAPI
CspQueryFreeSpace(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwFlags,
    OUT     PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB rgdbKey[2];
    CARD_CACHED_DATA_TYPE cachedType = Cached_FreeSpace;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKey, 0, sizeof(rgdbKey));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    // cache key is item type
    rgdbKey[0].cbData = sizeof(cachedType);
    rgdbKey[0].pbData = (PBYTE) &cachedType;

    rgdbKey[1].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);
    rgdbKey[1].pbData = (PBYTE) pCardState->wszSerialNumber;

    // Card Free Space information is dependent on both the Files
    // and the Containers cache counters.
    CacheQueryInfo.CacheLocation = 
        CacheLocation_Files | CacheLocation_Containers;
    CacheQueryInfo.fIsPerishable = TRUE;
    CacheQueryInfo.mpdbCacheKeys = rgdbKey;
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKey) / sizeof(rgdbKey[0]);
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_SUCCESS:

        // Free Space info was found cached and up to date

        DsysAssert(
            sizeof(CARD_FREE_SPACE_INFO) == 
            CacheQueryInfo.pItem->cbCachedItem);

        memcpy(
            pCardFreeSpaceInfo,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            sizeof(CARD_FREE_SPACE_INFO));

        break;

    case ERROR_NOT_FOUND:
        
        // Up to date Free Space info was not found
        
        dwSts = pCardState->pCardData->pfnCardQueryFreeSpace(
            pCardState->pCardData,
            dwFlags,
            pCardFreeSpaceInfo);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) + sizeof(CARD_FREE_SPACE_INFO));

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = sizeof(CARD_FREE_SPACE_INFO);

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            (PBYTE) pCardFreeSpaceInfo,
            sizeof(CARD_FREE_SPACE_INFO));

        // Cache the new data
        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    default:
        // Unexpected error occurred

        goto Ret;
    }

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    return dwSts;
}

//
// Function: CspPrivateKeyDecrypt
//
DWORD
WINAPI
CspPrivateKeyDecrypt(
    IN      PCARD_STATE                     pCardState,
    IN      PCARD_PRIVATE_KEY_DECRYPT_INFO  pInfo)
{
    return pCardState->pCardData->pfnCardPrivateKeyDecrypt(
        pCardState->pCardData,
        pInfo);
}

//
// Function: CspQueryKeySizes
//
DWORD
WINAPI
CspQueryKeySizes(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwReserved,
    OUT     PCARD_KEY_SIZES pKeySizes)
{
    DWORD dwSts = ERROR_SUCCESS;
    CARD_CACHE_QUERY_INFO CacheQueryInfo;
    DATA_BLOB rgdbKeys[3];
    CARD_CACHED_DATA_TYPE cachedType = Cached_KeySizes;
    PCARD_CACHE_ITEM_INFO pItem = NULL;

    memset(rgdbKeys, 0, sizeof(rgdbKeys));
    memset(&CacheQueryInfo, 0, sizeof(CacheQueryInfo));

    // First part of cache key is item type
    rgdbKeys[0].pbData = (PBYTE) &cachedType;
    rgdbKeys[0].cbData = sizeof(cachedType);

    // Second part of cache key is public-key type
    rgdbKeys[1].pbData = (PBYTE) &dwKeySpec;
    rgdbKeys[1].cbData = sizeof(dwKeySpec);

    rgdbKeys[2].pbData = (PBYTE) pCardState->wszSerialNumber;
    rgdbKeys[2].cbData = 
        wcslen(pCardState->wszSerialNumber) * sizeof(WCHAR);

    // Key Sizes data item is Non-Perishable
    CacheQueryInfo.cCacheKeys = sizeof(rgdbKeys) / sizeof(rgdbKeys[0]);
    CacheQueryInfo.mpdbCacheKeys = rgdbKeys;
    CacheQueryInfo.pCardState = pCardState;

    dwSts = I_CspQueryCardCacheForItem(
        &CacheQueryInfo);

    switch (dwSts)
    {
    case ERROR_NOT_FOUND:

        // This data has not yet been cached.  We'll have to 
        // query the data from the card module.

        dwSts = pCardState->pCardData->pfnCardQueryKeySizes(
            pCardState->pCardData,
            dwKeySpec,
            dwReserved,
            pKeySizes);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        // Now add this data to the cache 

        pItem = (PCARD_CACHE_ITEM_INFO) CspAllocH(
            sizeof(CARD_CACHE_ITEM_INFO) + sizeof(CARD_KEY_SIZES));

        LOG_CHECK_ALLOC(pItem);

        pItem->cbCachedItem = sizeof(CARD_KEY_SIZES);

        memcpy(
            ((PBYTE) pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            (PBYTE) pKeySizes,
            sizeof(CARD_KEY_SIZES));

        dwSts = I_CspAddCardCacheItem(
            &CacheQueryInfo,
            pItem);

        break;

    case ERROR_SUCCESS:

        //
        // The data was found in the cache.  
        //

        DsysAssert(
            sizeof(CARD_KEY_SIZES) == CacheQueryInfo.pItem->cbCachedItem);

        memcpy(
            pKeySizes,
            ((PBYTE) CacheQueryInfo.pItem) + sizeof(CARD_CACHE_ITEM_INFO),
            sizeof(CARD_KEY_SIZES));

        break;

    default:

        // Unexpected error
        break;
    }

Ret:

    if (pItem)
        CspFreeH(pItem);
    if (CacheQueryInfo.pItem)
        CspFreeH(CacheQueryInfo.pItem);

    return dwSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\cardmod\cardmod.c ===
#include <windows.h>
#include <psapi.h>

#pragma warning(push)
#pragma warning(disable:4201) 
// Disable error C4201 in public header 
//  nonstandard extension used : nameless struct/union
#include <winscard.h>
#pragma warning(pop)

#include "basecsp.h"
#include "cardmod.h"
#include "wpscproxy.h"
#include "marshalpc.h"
#include <limits.h>
#include "pincache.h"
#include <rsa.h>
#include <carddbg.h>
#include <stdio.h>
#include "physfile.h"

DWORD I_CardMapErrorCode(IN SCODE status);

//
// Get the number of characters in a Unicode string,
// NOT including the terminating Null.
//                                                      
#define WSZ_CHAR_COUNT(x) ((sizeof(x) / sizeof(WCHAR)) - 1)

//
// Macro for testing DWORD return codes.  Any return not equal to 
// ERROR_SUCCESS is assumed to mean Failure.
//
#define CARDMOD_FAILED(x) (ERROR_SUCCESS != x)

//
// Debug Logging
//
// This uses the debug routines from dsysdbg.h
// Debug output will only be available in chk
// bits.
//
DEFINE_DEBUG2(Cardmod)

#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_FUNC, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_FUNC, "%s: Leaving, status: 0x%x\n", #x, y)); }
    
#define LOG_CHECK_ALLOC(x)                                              \
    { if (NULL == x) {                                                  \
        dwError = ERROR_NOT_ENOUGH_MEMORY;                              \
        DebugLog((DEB_TRACE_MEM, "%s: Allocation failed\n", #x));       \
        goto Ret;                                                       \
    } }
    
#define LOG_CHECK_SCW_CALL(x)                                           \
    { if (ERROR_SUCCESS != (dwError = I_CardMapErrorCode(x))) {         \
        DebugLog((DEB_TRACE_FUNC, "%s: failed, status: 0x%x\n",         \
            #x, dwError));                                              \
        goto Ret;                                                       \
    } }

//
// Defines for interoperating with Crypto API public keys
//
#define cbCAPI_PUBLIC_EXPONENT                          3
#define CAPI_PUBLIC_EXPONENT                            0x10001

//
// Define data size used for Admin principal challenge-response authentication
//
#define cbCHALLENGE_RESPONSE_DATA                       8

//
// Card module applet instruction codes
//
#define PIN_CHANGE_CLA                                  0x00
#define PIN_CHANGE_INS                                  0x52
#define PIN_CHANGE_P1                                   0x00
#define PIN_CHANGE_P2                                   0x00

#define PIN_UNBLOCK_CLA                                 0x00
#define PIN_UNBLOCK_INS                                 0x52
#define PIN_UNBLOCK_P1                                  0x01
// PIN_UNBLOCK_P2 is the new max retry count, which can be set by caller

#define PIN_RETRY_COUNTER_CLA                           0x00
#define PIN_RETRY_COUNTER_INS                           0x50
#define PIN_RETRY_COUNTER_P1                            0x00
#define PIN_RETRY_COUNTER_P2                            0x00

//
// Data Structures used by this module
//

//
// Type: SUPPORTED_CARD
//
#define MAX_SUPPORTED_FILE_LEN                          50 // WCHARS
#define MAX_SUPPORTED_CARD_ATR_LEN                      21

typedef struct _SUPPORTED_CARD_
{
    LPWSTR wszCardName;
    BYTE rgbAtr[MAX_SUPPORTED_CARD_ATR_LEN];
    DWORD cbAtr;
    BYTE rgbAtrMask[MAX_SUPPORTED_CARD_ATR_LEN];

    CARD_CAPABILITIES CardCapabilities;
    CARD_FREE_SPACE_INFO CardFreeSpaceInfo;
    CARD_KEY_SIZES CardKeySizes_KeyEx;
    CARD_KEY_SIZES CardKeySizes_Sig;

} SUPPORTED_CARD, *PSUPPORTED_CARD;

SUPPORTED_CARD SupportedCards [] =
{
    //
    // ITG's deployment cards
    //

    // T=1
    {   L"ITG_MSCSP_V1", 
        { 0x3b, 0x8c, 0x81, 0x31, 0x20, 0x55, 0x49, 0x54, 
          0x47, 0x5f, 0x4d, 0x53, 0x43, 0x53, 0x50, 0x5f,
          0x56, 0x31, 0x2a },
        19,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    },

    // T=0
    {   L"ITG_MSCSP_V2", 
        { 0x3b, 0xdc, 0x13, 0x00, 0x40, 0x3a, 0x49, 0x54,
          0x47, 0x5f, 0x4d, 0x53, 0x43, 0x53, 0x50, 0x5f,
          0x56, 0x32 },
        18,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    },

    // 
    // These are Windows for Smart Cards test cards.  They do not support
    // on-card key gen.
    //

    // T=0 Cards
    {   L"BaseCSP-T0-1", 
        { 0x3B, 0xDC, 0x13, 0x00, 0x40, 0x3A, 0x42, 0x61, 
          0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54, 0x30, 
          0x2D, 0x31 },
        18,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    },

    // T=1 Card, 9600 bps
    {   L"BaseCSP-T1-1", 
        { 0x3B, 0x8C, 0x81, 0x31, 0x20, 0x55, 0x42, 0x61, 
          0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54, 0x31, 
          0x2D, 0x31, 0x68 },
        19,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    },

    // T=1 Card, 19 kbps
    {   L"BaseCSP-T1-2", 
        { 0x3B, 0xDC, 0x13, 0x0A, 0x81, 0x31, 0x20, 0x55, 0x42, 0x61, 
          0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54, 0x31, 
          0x2D, 0x31, 0x21 },
        21,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    },

    // T=1 Card, 38 kbps
    {   L"BaseCSP-T1-3", 
        { 0x3B, 0x9C, 0x13, 0x81, 0x31, 0x20, 0x55, 0x42, 0x61, 
          0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54, 0x31, 
          0x2D, 0x31, 0x6B },
        20,
        { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
          0xFF, 0xFF, 0xFF },
        { CARD_CAPABILITIES_CURRENT_VERSION, FALSE, FALSE },
        { CARD_FREE_SPACE_INFO_CURRENT_VERSION, CARD_DATA_VALUE_UNKNOWN, (DWORD) -1, 2 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 },
        { CARD_KEY_SIZES_CURRENT_VERSION, 1024, 1024, 1024, 0 }
    }
};

static WCHAR l_wszImagePath[MAX_PATH];

//
// Type: CARDMOD_CONTEXT
//
typedef struct _CARDMOD_CONTEXT
{
    SCARDHANDLE hWfscCardHandle;
    PSUPPORTED_CARD pSupportedCard;

} CARDMOD_CONTEXT, *PCARDMOD_CONTEXT;

typedef struct _VERIFY_PIN_CALLBACK_DATA
{
    LPWSTR wszUserId;
    PCARD_DATA pCardData;
} VERIFY_PIN_CALLBACK_DATA, *PVERIFY_PIN_CALLBACK_DATA;

//
// Maps status codes returned from the Smart Card for Windows proxy to common
// Windows status codes.
//
DWORD I_CardMapErrorCode(
    IN  SCODE status)
{
    DWORD iMap = 0;
    struct {
        SCODE scode;
        DWORD dwError;
    } ErrorMap [] = {
        {   SCW_S_OK,               ERROR_SUCCESS },
        {   SCW_E_FILENOTFOUND,     (DWORD) SCARD_E_FILE_NOT_FOUND },
        {   SCW_E_DIRNOTFOUND,      (DWORD) SCARD_E_DIR_NOT_FOUND },
        {   SCW_E_PARTITIONFULL,    (DWORD) SCARD_E_WRITE_TOO_MANY },
        {   SCW_E_MEMORYFAILURE,    ERROR_NOT_ENOUGH_MEMORY },
        {   SCW_E_VMNOMEMORY,       ERROR_NOT_ENOUGH_MEMORY },
        {   SCW_E_NOTAUTHENTICATED, (DWORD) SCARD_E_INVALID_CHV },
        {   SCW_E_ALREADYEXISTS,    (DWORD) ERROR_FILE_EXISTS }
    };

    for (iMap = 0; iMap < (sizeof(ErrorMap) / sizeof(ErrorMap[0])); iMap++)
    {
        if (ErrorMap[iMap].scode == status)
            return ErrorMap[iMap].dwError;
    }

    // Otherwise, best we can do is pass a general error
    DebugLog((
        DEB_WARN, 
        "I_CardMapErrorCode could not map error 0x%X\n", 
        status));

    return (DWORD) SCARD_F_INTERNAL_ERROR;
}

//
// Maps the error code returned by a card applet to a common error code.  The
// status word returned by the applet is first converted into a Windows For 
// Smart Cards error code.
//
// Reminder: Status words returned by the RTE apps are in the form:
// 9000 -> Success
// 6Fyy -> An API failed with return code yy
// 6Ezz -> An exception was raised (zz is the err number)
//
DWORD I_CardMapExecuteErrorCode(
    IN  WORD wStatus)
{
    SCODE status = 0xC0000000 | (wStatus & 0xFF);

    if (0x90 == (wStatus >> 8))
        return ERROR_SUCCESS;
    else
        return I_CardMapErrorCode(status);
}

//
// Creates and writes a new file to the card with the supplied Access Condition
// and file contents.  If fCache is true, the file is cached using the caller's
// CacheAddFile function.
//
DWORD I_CardWriteFile(
    IN      PCARD_DATA pCardData,
    IN      LPWSTR wszPhysicalFile,
    IN      LPWSTR wszAcl,
    IN      PBYTE pbData,
    IN      DWORD cbData,
    IN      BOOL fCache)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    HFILE hFile = 0;
    DWORD cbActual = 0;

    UNREFERENCED_PARAMETER(fCache);

    LOG_CHECK_SCW_CALL(hScwCreateFile(
        pCardmodContext->hWfscCardHandle,
        wszPhysicalFile,
        wszAcl,
        &hFile));

    LOG_CHECK_SCW_CALL(hScwWriteFile32(
        pCardmodContext->hWfscCardHandle,
        hFile,
        pbData,
        cbData,
        &cbActual));

    if (cbActual != cbData)
    {
        dwError = (DWORD) SCARD_W_EOF;
        goto Ret;
    }

    DebugLog((
        DEB_TRACE, 
        "I_CardWriteFile: wrote %S, %d bytes\n", 
        wszPhysicalFile,
        cbData));

    if (fCache)
    {
        dwError = pCardData->pfnCspCacheAddFile(
            pCardData->pvCacheContext,
            wszPhysicalFile, 
            0, 
            pbData,
            cbData);
    }

Ret:
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle, hFile);

    return dwError;
}

//
// If fUseCached is true, first attempts to satisfy the read request 
// via the caller's CacheLookupFile function.  Otherwise,
// reads a file directly from the smart card by first opening the file and 
// determining its size.  The file is cached using the caller's CacheAddFile
// pointer if fCache is true.
//
DWORD I_CardReadFile(
    IN      PCARD_DATA pCardData,
    IN      LPWSTR wszPhysicalFile,
    OUT     PBYTE *ppbData,
    OUT     DWORD *pcbData,
    IN      BOOL fUseCached)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    HFILE hFile = 0;
    DWORD cbActual = 0;

    if (fUseCached)
    {
        dwError = pCardData->pfnCspCacheLookupFile(
            pCardData->pvCacheContext,
            wszPhysicalFile, 
            0, 
            ppbData,
            pcbData);

        switch (dwError)
        {
        case ERROR_NOT_FOUND:
            // A cached copy of the requested file is not available; 
            // read it from the card.
            break;

        case ERROR_SUCCESS:
            // Fall through
        default:

            // Either we found cached data or an unexpected error occurred.
            // We're done.

            goto Ret;
        }
    }

    LOG_CHECK_SCW_CALL(hScwCreateFile(
        pCardmodContext->hWfscCardHandle, 
        wszPhysicalFile,
        NULL,
        &hFile));

    LOG_CHECK_SCW_CALL(hScwGetFileLength(
        pCardmodContext->hWfscCardHandle,
        hFile,
        (TOFFSET *) pcbData));

    *ppbData = (PBYTE) pCardData->pfnCspAlloc(*pcbData);

    LOG_CHECK_ALLOC(*ppbData);

    LOG_CHECK_SCW_CALL(hScwReadFile32(
        pCardmodContext->hWfscCardHandle,
        hFile,
        *ppbData,
        *pcbData,
        &cbActual));

    if (cbActual != *pcbData)
        dwError = (DWORD) SCARD_W_EOF;

    DebugLog((
        DEB_TRACE, 
        "I_CardReadFile: read %S, %d bytes\n", 
        wszPhysicalFile,
        *pcbData));

    if (fUseCached)
    {
        // Cache this file.
        dwError = pCardData->pfnCspCacheAddFile(
            pCardData->pvCacheContext,
            wszPhysicalFile, 
            0, 
            *ppbData,
            *pcbData);
    }

Ret:
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle, hFile);

    if (ERROR_SUCCESS != dwError && *ppbData)
    {
        pCardData->pfnCspFree(*ppbData);
        *ppbData = NULL;
    }

    return dwError;
}

//
// Maps a logical user name to a physical user, or principal, recognized by
// the card.
//
DWORD GetWellKnownUserMapping(
    IN      PCARD_DATA pCardData,
    IN      LPWSTR wszLogicalUser,
    OUT     LPWSTR *ppwszPhysicalUser)
{
    DWORD dwError = ERROR_NO_SUCH_USER;
    int iUser = 0;

    static const WCHAR wszAdmin [] = L"admin";
    static const WCHAR wszAnonymous [] = L"anonymous";
    static const WCHAR wszUser [] = L"user";

    struct {
        LPWSTR wszLogicalUser;
        const WCHAR (*wszPhysicalUser);
        DWORD cchPhysicalUser;
    } UserMap [] = {
        {   wszCARD_USER_ADMIN,
            wszAdmin,
            WSZ_CHAR_COUNT(wszAdmin) },
        {   wszCARD_USER_EVERYONE,
            wszAnonymous,
            WSZ_CHAR_COUNT(wszAnonymous) },
        {   wszCARD_USER_USER,
            wszUser,
            WSZ_CHAR_COUNT(wszUser) }
    };

    for (iUser = 0; iUser < sizeof(UserMap) / sizeof(UserMap[0]); iUser++)
    {
        if (0 == wcscmp(wszLogicalUser, UserMap[iUser].wszLogicalUser))
        {
            *ppwszPhysicalUser = (LPWSTR) pCardData->pfnCspAlloc(
                sizeof(WCHAR) * (1 + UserMap[iUser].cchPhysicalUser));

            LOG_CHECK_ALLOC(*ppwszPhysicalUser);

            wcscpy(
                *ppwszPhysicalUser,
                UserMap[iUser].wszPhysicalUser);

            dwError = ERROR_SUCCESS;
            break;
        }
    }

Ret:
    return dwError;
}

//
// Maps a logical Access Condition to a physical ACL file recognized by the 
// card.
//
DWORD GetWellKnownAcMapping(
    IN      PCARD_DATA pCardData,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition,
    OUT     LPWSTR *ppwszPhysicalAclFile)
{
    DWORD dwError = ERROR_NOT_FOUND;
    int iAcl = 0;

    struct {
        CARD_FILE_ACCESS_CONDITION LogicalAc;
        const WCHAR (*wszPhysicalAcl);
        DWORD cchPhysicalAcl;
    } AclMap [] = {
        {   EveryoneReadUserWriteAc,
            wszUserWritePhysicalAcl,
            WSZ_CHAR_COUNT(wszUserWritePhysicalAcl) },
        {   UserWriteExecuteAc,
            wszUserExecutePhysicalAcl,
            WSZ_CHAR_COUNT(wszUserExecutePhysicalAcl) },
        {   EveryoneReadAdminWriteAc,
            wszAdminWritePhysicalAcl,
            WSZ_CHAR_COUNT(wszAdminWritePhysicalAcl) }
    };

    for (iAcl = 0; iAcl< sizeof(AclMap) / sizeof(AclMap[0]); iAcl++)
    {
        if (AccessCondition == AclMap[iAcl].LogicalAc)
        {
            *ppwszPhysicalAclFile = (LPWSTR) pCardData->pfnCspAlloc(
                (1 + AclMap[iAcl].cchPhysicalAcl) * sizeof(WCHAR));

            LOG_CHECK_ALLOC(*ppwszPhysicalAclFile);

            memcpy(
                *ppwszPhysicalAclFile,
                AclMap[iAcl].wszPhysicalAcl,
                (1 + AclMap[iAcl].cchPhysicalAcl) * sizeof(WCHAR));

            dwError = ERROR_SUCCESS;

            break;
        }
    }

Ret:
    return dwError;
}

//
// Maps a well known logical file or directory name to a physical file
// or directory.
//
DWORD GetWellKnownFileMapping(
    IN  PCARD_DATA pCardData,
    IN  LPWSTR wszLogicalFileName,
    OUT LPSTR *ppszPhysicalFileName)
{
    DWORD cbPhysicalFileName = 0;
    int i = 0;        
    BOOL fMatched = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cchLogicalName = 0;
    LPSTR szAnsiExtra = NULL;

    enum NameType { File, Directory };
    struct {
        LPWSTR wszLogicalName;
        LPSTR szPhysicalName;
        enum NameType type;
        DWORD cbPhysicalName;
    } FileMap [] = {
        //
        // When composing the lookup table, the deepest directory paths
        // must be listed first, so that partial matching will find the 
        // longest partial match first.
        //
        {   wszUSER_SIGNATURE_CERT_PREFIX,  szPHYSICAL_USER_SIGNATURE_CERT_PREFIX,
            File,                           cbPHYSICAL_USER_SIGNATURE_CERT_PREFIX },
        {   wszUSER_KEYEXCHANGE_CERT_PREFIX,szPHYSICAL_USER_KEYEXCHANGE_CERT_PREFIX,
            File,                           cbPHYSICAL_USER_KEYEXCHANGE_CERT_PREFIX },
        {   wszCSP_DATA_DIR_FULL_PATH,      szPHYSICAL_CSP_DIR, 
            Directory,                      cbPHYSICAL_CSP_DIR },
        {   wszCACHE_FILE_FULL_PATH,        szPHYSICAL_CACHE_FILE,     
            File,                           cbPHYSICAL_CACHE_FILE },
        {   wszCARD_IDENTIFIER_FILE_FULL_PATH,
                                            szPHYSICAL_CARD_IDENTIFIER,
            File,                           cbPHYSICAL_CARD_IDENTIFIER },
        {   wszCONTAINER_MAP_FILE_FULL_PATH,
                                            szPHYSICAL_CONTAINER_MAP_FILE,
            File,                           cbPHYSICAL_CONTAINER_MAP_FILE },
        {   wszPERSONAL_DATA_FILE_FULL_PATH,          
                                            szPHYSICAL_PERSONAL_DATA_FILE,
            File,                           cbPHYSICAL_PERSONAL_DATA_FILE }
    };

    *ppszPhysicalFileName = NULL;

    // First, look for an exact match.
    for (i = 0; i < sizeof(FileMap) / sizeof(FileMap[0]); i++)
    {
        if (0 == wcscmp(wszLogicalFileName, FileMap[i].wszLogicalName))
        {
            fMatched = TRUE;
            break;
        }
    }

    if (fMatched)
    {
        if (NULL == FileMap[i].szPhysicalName)
        {
            dwError = ERROR_NOT_FOUND;
            goto Ret;
        }

        cbPhysicalFileName = FileMap[i].cbPhysicalName + sizeof(WCHAR);

        *ppszPhysicalFileName = (LPSTR) pCardData->pfnCspAlloc(cbPhysicalFileName);

        LOG_CHECK_ALLOC(*ppszPhysicalFileName);

        memcpy(
            *ppszPhysicalFileName, 
            FileMap[i].szPhysicalName,
            FileMap[i].cbPhysicalName);
    }
    else
    {
        // Have to try for a partial match.  Check if the beginning
        // of the logical name matches a known name.

        for (   i = 0; 
                FALSE == fMatched && (i < sizeof(FileMap) / sizeof(FileMap[0])); 
                i++)
        {
            if (wszLogicalFileName != 
                    wcsstr(wszLogicalFileName, FileMap[i].wszLogicalName))
                continue;

            //
            // We found a match and it's at the beginning of the string
            //

            cchLogicalName = (DWORD) wcslen(FileMap[i].wszLogicalName);

            //
            // Convert the trailing portion of the matched Unicode string
            // to Ansi.
            //

            dwError = I_CardConvertFileNameToAnsi(
                pCardData,
                wszLogicalFileName + cchLogicalName,
                &szAnsiExtra);

            if (ERROR_SUCCESS != dwError)
                goto Ret;

            // 
            // Build the fully matched/converted physical file string.  The
            // resultant string will have three single-byte NULL chars 
            // appended to ensure that the resultant string is a valid,
            // terminated Unicode string.
            //

            *ppszPhysicalFileName = (LPSTR) pCardData->pfnCspAlloc(
                3 + 
                FileMap[i].cbPhysicalName + 
                strlen(szAnsiExtra));

            LOG_CHECK_ALLOC(*ppszPhysicalFileName);

            memcpy(
                *ppszPhysicalFileName,
                FileMap[i].szPhysicalName,
                FileMap[i].cbPhysicalName);

            memcpy(
                *ppszPhysicalFileName + FileMap[i].cbPhysicalName,
                szAnsiExtra,
                strlen(szAnsiExtra));

            fMatched = TRUE;
        }
    }

    if (FALSE == fMatched)
        dwError = ERROR_NOT_FOUND;

Ret:

    if (NULL != szAnsiExtra)
        pCardData->pfnCspFree(szAnsiExtra);

    return dwError;
}

// 
// Converts a Crypto API private key blob to the separate public and private
// key files that will be written to the card.
//
DWORD ConvertPrivateKeyBlobToCardFormat(
    IN      PCARD_DATA pCardData,
    IN      DWORD dwKeySpec,
    IN      PBYTE pbKeyBlob,
    IN      DWORD cbKeyBlob,
    OUT     PBYTE *ppbCardPrivateKey,
    OUT     DWORD *pcbCardPrivateKey,
    OUT     PBYTE *ppbCardPublicKey,
    OUT     DWORD *pcbCardPublicKey)
{
    DWORD dwError = ERROR_SUCCESS;
    RSAPUBKEY *pPub = NULL;
    DWORD cBitlenBytes = 0;
    DWORD cbKey = 0;
    PBYTE pbKey = NULL;

    UNREFERENCED_PARAMETER(pCardData);
    UNREFERENCED_PARAMETER(dwKeySpec);
    UNREFERENCED_PARAMETER(cbKeyBlob);

    *ppbCardPrivateKey = NULL;
    *pcbCardPrivateKey = 0;
    *ppbCardPublicKey = NULL;
    *pcbCardPublicKey = 0;

    //
    // Setup the public key file
    //
    pPub = (RSAPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));

    *pcbCardPublicKey = (pPub->bitlen / 8) + sizeof(RSAPUBKEY);

    *ppbCardPublicKey = (PBYTE) pCardData->pfnCspAlloc(*pcbCardPublicKey);

    LOG_CHECK_ALLOC(*ppbCardPublicKey);

    memcpy(
        *ppbCardPublicKey,
        pPub,
        *pcbCardPublicKey);

    //
    // Need to change the RSA "magic" field in the Public key blob from
    // "RSA2" to "RSA1" to make this a correct PUBLICKEYBLOB (although we
    // won't add the BLOBHEADER to the front until someone tries to export
    // it from the card).
    //
    memcpy(
        *ppbCardPublicKey,
        (PBYTE) "RSA1",
        4);

    //
    // Setup the private key file
    //

    cBitlenBytes = pPub->bitlen / 8;

    *pcbCardPrivateKey = 1 + 1 + 3 + 1 + 9 * cBitlenBytes / 2;

    *ppbCardPrivateKey = (PBYTE) pCardData->pfnCspAlloc(*pcbCardPrivateKey);

    LOG_CHECK_ALLOC(*ppbCardPrivateKey);

    pbKey = *ppbCardPrivateKey;

    // Key mode
    pbKey[cbKey] = MODE_RSA_SIGN;
    cbKey++;

    // size of public exponent
    pbKey[cbKey] = cbCAPI_PUBLIC_EXPONENT;
    cbKey++;

    DsysAssert(CAPI_PUBLIC_EXPONENT == pPub->pubexp);

    // public exponent
    memcpy(
        pbKey + cbKey, 
        (PBYTE) &pPub->pubexp, 
        cbCAPI_PUBLIC_EXPONENT);
    cbKey += cbCAPI_PUBLIC_EXPONENT;

    // RSA key length
    pbKey[cbKey] = (BYTE) cBitlenBytes; 
    cbKey++;

    // public key
    memcpy(
        pbKey + cbKey, 
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
        cBitlenBytes);
    cbKey += cBitlenBytes; 

    // prime 1
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // prime 2
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            (3 * cBitlenBytes / 2),
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Exp1 (D mod (P-1)) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            2 * cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Exp2 (D mod (Q-1)) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            (5 * cBitlenBytes / 2),
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Coef ((Q^(-1)) mod p) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            3 * cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // private exponent
    memcpy(
        pbKey + cbKey,
        pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + 
            (7 * cBitlenBytes / 2),
        cBitlenBytes);        
    cbKey += cBitlenBytes;

    DsysAssert(cbKey == *pcbCardPrivateKey);

Ret:
    if (ERROR_SUCCESS != dwError)
    {
        if (*ppbCardPublicKey)
        {
            pCardData->pfnCspFree(*ppbCardPublicKey);
            *ppbCardPublicKey = NULL;
        }
    }

    return dwError;
}

//
// Card Module Exported Functions
//

//
// Initializes a CARD_DATA context structure for the card identified by Name,
// ATR, and SCARDHANDLE supplied by the caller.
//
DWORD 
WINAPI
CardAcquireContext(
    IN OUT  PCARD_DATA  pCardData,
    IN      DWORD       dwFlags)
{
    int iSupportedCard = 0;
    BOOL fSupportedCard = FALSE;
    PCARDMOD_CONTEXT pCardmodContext = NULL;
    DWORD dwError = ERROR_SUCCESS;

    LOG_BEGIN_FUNCTION(CardAcquireContext);

    if (0 != dwFlags)
    {
        dwError = (DWORD) NTE_BAD_FLAGS;
        goto Ret;
    }

    for (
            iSupportedCard = 0; 
            iSupportedCard < sizeof(SupportedCards) / 
                sizeof(SupportedCards[0]); 
            iSupportedCard++)
    {
        if (0 == wcscmp(
                SupportedCards[iSupportedCard].wszCardName, 
                pCardData->pwszCardName) 
                    &&
            SupportedCards[iSupportedCard].cbAtr == pCardData->cbAtr 
                    &&
            0 == memcmp(
                SupportedCards[iSupportedCard].rgbAtr, 
                pCardData->pbAtr, 
                SupportedCards[iSupportedCard].cbAtr))
        {
            fSupportedCard = TRUE;
            break;
        }
    }

    if (FALSE == fSupportedCard)
    {
        dwError = (DWORD) SCARD_E_UNKNOWN_CARD;
        goto Ret;
    }

    pCardData->pfnCardDeleteContext         = CardDeleteContext;
    pCardData->pfnCardQueryCapabilities     = CardQueryCapabilities;
    pCardData->pfnCardDeleteContainer       = CardDeleteContainer;
    pCardData->pfnCardCreateContainer       = CardCreateContainer;
    pCardData->pfnCardGetContainerInfo      = CardGetContainerInfo;
    pCardData->pfnCardSubmitPin             = CardSubmitPin;
    pCardData->pfnCardChangeAuthenticator   = CardChangeAuthenticator;
    pCardData->pfnCardGetChallenge          = CardGetChallenge;
    pCardData->pfnCardAuthenticateChallenge = CardAuthenticateChallenge;
    pCardData->pfnCardUnblockPin            = CardUnblockPin;
    pCardData->pfnCardDeauthenticate        = CardDeauthenticate;
    pCardData->pfnCardCreateFile            = CardCreateFile;
    pCardData->pfnCardReadFile              = CardReadFile;
    pCardData->pfnCardWriteFile             = CardWriteFile;
    pCardData->pfnCardDeleteFile            = CardDeleteFile;
    pCardData->pfnCardEnumFiles             = CardEnumFiles;
    pCardData->pfnCardGetFileInfo           = CardGetFileInfo;
    pCardData->pfnCardQueryFreeSpace        = CardQueryFreeSpace;
    pCardData->pfnCardPrivateKeyDecrypt     = CardPrivateKeyDecrypt;
    pCardData->pfnCardQueryKeySizes         = CardQueryKeySizes;

    pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pfnCspAlloc(sizeof(CARDMOD_CONTEXT));

    LOG_CHECK_ALLOC(pCardmodContext);

    LOG_CHECK_SCW_CALL(hScwAttachToCard(
        pCardData->hScard, 
        NULL, 
        &pCardmodContext->hWfscCardHandle));

    pCardmodContext->pSupportedCard = SupportedCards + iSupportedCard;

    pCardData->pvVendorSpecific = (PVOID) pCardmodContext;
    pCardmodContext = NULL;

Ret:
    if (    ERROR_SUCCESS != dwError &&
            NULL != pCardmodContext &&
            pCardmodContext->hWfscCardHandle)
        hScwDetachFromCard(pCardmodContext->hWfscCardHandle);
    if (pCardmodContext)
        pCardData->pfnCspFree(pCardmodContext);

    LOG_END_FUNCTION(CardAcquireContext, dwError);

    return dwError;
}

//
// Frees the resources consumed by a CARD_DATA structure.
//
DWORD
WINAPI
CardDeleteContext(
    OUT     PCARD_DATA  pCardData)
{                        
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    LOG_BEGIN_FUNCTION(CardDeleteContext);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    if (pCardmodContext->hWfscCardHandle)
    {
        hScwDetachFromCard(pCardmodContext->hWfscCardHandle);
        pCardmodContext->hWfscCardHandle = 0;
    }
    
    if (pCardData->pvVendorSpecific)
    {
        pCardData->pfnCspFree(pCardData->pvVendorSpecific);
        pCardData->pvVendorSpecific = NULL;
    }

    LOG_END_FUNCTION(CardDeleteContext, dwError);

    return dwError;
}

//
// Returns the static capabilities of the target card.
//
DWORD
WINAPI
CardQueryCapabilities(
    IN      PCARD_DATA          pCardData,
    IN OUT  PCARD_CAPABILITIES  pCardCapabilities)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    LOG_BEGIN_FUNCTION(CardQueryCapabilities);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    memcpy(
        pCardCapabilities,
        &pCardmodContext->pSupportedCard->CardCapabilities,
        sizeof(CARD_CAPABILITIES));

    LOG_END_FUNCTION(CardQueryCapabilities, dwError);

    return dwError;                
}

//
// The encoded key filename is one hex byte, such as "FF", which requires
// two characters.
//
#define cchENCODED_KEY_FILENAME     2

//
// Creates the physical filenames used for the key files associated with the
// specified container.
//
DWORD BuildCardKeyFilenames(
    IN              PCARD_DATA pCardData,
    IN              DWORD dwKeySpec,
    IN              BYTE bContainerIndex,
    OUT OPTIONAL    LPSTR *pszPrivateFilename,
    OUT OPTIONAL    LPSTR *pszPublicFilename)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cchFileName = 0;
    DWORD dwIndex = (DWORD) bContainerIndex;
    LPSTR szPrivatePrefix = NULL;
    DWORD cbPrivatePrefix = 0;
    LPSTR szPublicPrefix = NULL;
    DWORD cbPublicPrefix = 0;

    if (pszPrivateFilename)
        *pszPrivateFilename = NULL;
    if (pszPublicFilename)
        *pszPublicFilename = NULL;

    switch (dwKeySpec)
    {
    case AT_SIGNATURE:
        szPrivatePrefix = szPHYSICAL_SIGNATURE_PRIVATE_KEY_PREFIX;
        cbPrivatePrefix = cbPHYSICAL_SIGNATURE_PRIVATE_KEY_PREFIX;
        szPublicPrefix = szPHYSICAL_SIGNATURE_PUBLIC_KEY_PREFIX;
        cbPublicPrefix = cbPHYSICAL_SIGNATURE_PUBLIC_KEY_PREFIX;
        break;

    case AT_KEYEXCHANGE:
        szPrivatePrefix = szPHYSICAL_KEYEXCHANGE_PRIVATE_KEY_PREFIX;
        cbPrivatePrefix = cbPHYSICAL_KEYEXCHANGE_PRIVATE_KEY_PREFIX;
        szPublicPrefix = szPHYSICAL_KEYEXCHANGE_PUBLIC_KEY_PREFIX;
        cbPublicPrefix = cbPHYSICAL_KEYEXCHANGE_PUBLIC_KEY_PREFIX;
        break;

    default:
        dwError = (DWORD) NTE_BAD_ALGID;
        goto Ret;
    }

    //
    // Build the public key filename
    //

    if (pszPublicFilename)
    {
        cchFileName = cchENCODED_KEY_FILENAME;
        cchFileName += (cbPublicPrefix / sizeof(CHAR)) + 3; 
    
        *pszPublicFilename = (LPSTR) pCardData->pfnCspAlloc(
            cchFileName * sizeof(CHAR));
    
        LOG_CHECK_ALLOC(*pszPublicFilename);
    
        memcpy(*pszPublicFilename, szPublicPrefix, cbPublicPrefix);

        sprintf(
            *pszPublicFilename + cbPublicPrefix,
            "%d\0\0",
            dwIndex);
    }
    
    //
    // Build the private key filename
    //

    if (pszPrivateFilename)
    {
        cchFileName = cchENCODED_KEY_FILENAME;
        cchFileName += (cbPrivatePrefix / sizeof(CHAR)) + 3;
    
        *pszPrivateFilename = (LPSTR) pCardData->pfnCspAlloc(
            cchFileName * sizeof(CHAR));
    
        LOG_CHECK_ALLOC(*pszPrivateFilename);

        memcpy(*pszPrivateFilename, szPrivatePrefix, cbPrivatePrefix);

        sprintf(
            *pszPrivateFilename + cbPrivatePrefix,
            "%d\0\0",
            dwIndex);
    }
    
Ret:
    if (ERROR_SUCCESS != dwError)
    {
        if (*pszPublicFilename)
        {
            pCardData->pfnCspFree(*pszPublicFilename);
            *pszPublicFilename = NULL;
        }

        if (*pszPrivateFilename)
        {
            pCardData->pfnCspFree(*pszPrivateFilename);
            *pszPrivateFilename = NULL;
        }
    }

    return dwError;
}

//
// Deletes the Signature and Key Exchange public and private key files, 
// if present, associated with the specified container.
//
DWORD
WINAPI
CardDeleteContainer(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwReserved)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    LPSTR szPrivateKeyFile = NULL;
    LPSTR szPublicKeyFile = NULL;
    SCODE scode = 0;

    UNREFERENCED_PARAMETER(dwReserved);

    LOG_BEGIN_FUNCTION(CardDeleteContainer);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    //
    // Attempt to delete the Signature key files associated with this
    // container, if any.
    //
    dwError = BuildCardKeyFilenames(
        pCardData,
        AT_SIGNATURE,
        bContainerIndex,
        &szPrivateKeyFile,
        &szPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPrivateKeyFile);

    if (SCW_E_FILENOTFOUND != scode && SCW_S_OK != scode)
        goto Ret;

    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPublicKeyFile);

    if (SCW_E_FILENOTFOUND != scode && SCW_S_OK != scode)
        goto Ret;

    pCardData->pfnCspFree(szPrivateKeyFile);
    szPrivateKeyFile = NULL;
    pCardData->pfnCspFree(szPublicKeyFile);
    szPublicKeyFile = NULL;

    //
    // Attempt to delete the Key Exchange key files associated with this 
    // container, if any.
    //
    dwError = BuildCardKeyFilenames(
        pCardData,
        AT_KEYEXCHANGE,
        bContainerIndex,
        &szPrivateKeyFile,
        &szPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPrivateKeyFile);

    if (SCW_E_FILENOTFOUND != scode && SCW_S_OK != scode)
        goto Ret;

    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPublicKeyFile);

Ret:

    if (SCW_E_FILENOTFOUND != scode && SCW_S_OK != scode)
        dwError = I_CardMapErrorCode(scode);

    if (szPrivateKeyFile)
        pCardData->pfnCspFree(szPrivateKeyFile);
    if (szPublicKeyFile)
        pCardData->pfnCspFree(szPublicKeyFile);

    LOG_END_FUNCTION(CardDeleteContainer, dwError);

    return dwError;
}

//
// Writes the private and public key files to the card, supplying the 
// appropriate access conditions.
//
DWORD WriteCardKeyFiles(
    IN      PCARD_DATA pCardData,
    IN      LPWSTR wszPrivateKeyFile,
    IN      LPWSTR wszPublicKeyFile,
    IN      PBYTE pbPrivateKey,
    IN      DWORD cbPrivateKey,
    IN      PBYTE pbPublicKey,
    IN      DWORD cbPublicKey)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    CARD_FILE_ACCESS_CONDITION Ac;
    LPWSTR wszPrivateAcl = NULL;
    LPWSTR wszPublicAcl = NULL;
    HFILE hFile = 0;
    SCODE scode = 0;

    memset(&Ac, 0, sizeof(Ac));

    Ac = UserWriteExecuteAc;

    dwError = GetWellKnownAcMapping(
        pCardData, Ac, &wszPrivateAcl);

    if (CARDMOD_FAILED(dwError))
        goto Ret;        

    Ac = EveryoneReadUserWriteAc;

    dwError = GetWellKnownAcMapping(
        pCardData, Ac, &wszPublicAcl);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    // 
    // See if the private key file already exists
    //
    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle, 
        wszPrivateKeyFile);

    if (SCW_S_OK != scode && SCW_E_FILENOTFOUND != scode)
    {
        dwError = I_CardMapErrorCode(scode);
        goto Ret;
    }

    dwError = I_CardWriteFile(
        pCardData, 
        wszPrivateKeyFile,
        wszPrivateAcl,
        pbPrivateKey,
        cbPrivateKey,
        FALSE);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    // Done with private key file

    // 
    // See if the public key file already exists
    //
    scode = hScwDeleteFile(
        pCardmodContext->hWfscCardHandle, 
        wszPublicKeyFile);

    if (SCW_S_OK != scode && SCW_E_FILENOTFOUND != scode)
    {
        dwError = I_CardMapErrorCode(scode);
        goto Ret;
    }

    dwError = I_CardWriteFile(
        pCardData, 
        wszPublicKeyFile,
        wszPublicAcl,
        pbPublicKey,
        cbPublicKey,
        TRUE);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    // Done with public key file

Ret:
    if (wszPrivateAcl)
        pCardData->pfnCspFree(wszPrivateAcl);
    if (wszPublicAcl)
        pCardData->pfnCspFree(wszPublicAcl);
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle, hFile);

    return dwError;
}

//
// Writes new keys to the card in a location logically defined by the 
// bContainerIndex container name.  If keys are already defined for the
// specified container, the existing keys are over-written.
//
// If dwFlags contains CARD_CREATE_CONTAINER_KEY_GEN, then dwKeySize is the
// number of bits of the key to be created.
//
// If dwFlags contains CARD_CREATE_CONTAINER_KEY_IMPORT, then dwKeySize is
// the byte length of pbKeyData.
//
DWORD
WINAPI
CardCreateContainer(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwKeySize,
    IN      PBYTE       pbKeyData)
{
    DWORD dwError = ERROR_SUCCESS;
    PBYTE pbPrivateKeyFile = NULL;
    DWORD cbPrivateKeyFile = 0;
    PBYTE pbPublicKeyFile = NULL;
    DWORD cbPublicKeyFile = 0;
    LPSTR szPrivateKeyFile = NULL;
    LPSTR szPublicKeyFile = NULL;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    LOG_BEGIN_FUNCTION(CardCreateContainer);

    if (CARD_CREATE_CONTAINER_KEY_GEN & dwFlags)
    {
        dwError = (DWORD) SCARD_E_UNSUPPORTED_FEATURE;
        goto Ret;
    }

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    //
    // Setup the key files
    //
    dwError = ConvertPrivateKeyBlobToCardFormat(
        pCardData,
        dwKeySpec,
        pbKeyData,
        dwKeySize,
        &pbPrivateKeyFile,
        &cbPrivateKeyFile,
        &pbPublicKeyFile,
        &cbPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    dwError = BuildCardKeyFilenames(
        pCardData,
        dwKeySpec,
        bContainerIndex,
        &szPrivateKeyFile,
        &szPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    //
    // Write the actual keys to the card
    //
    dwError = WriteCardKeyFiles(
        pCardData,
        (LPWSTR) szPrivateKeyFile,
        (LPWSTR) szPublicKeyFile,
        pbPrivateKeyFile,
        cbPrivateKeyFile,
        pbPublicKeyFile,
        cbPublicKeyFile);

Ret:

    if (pbPrivateKeyFile)
    {
        RtlSecureZeroMemory(pbPrivateKeyFile, cbPrivateKeyFile);
        pCardData->pfnCspFree(pbPrivateKeyFile);
    }
    if (pbPublicKeyFile)
        pCardData->pfnCspFree(pbPublicKeyFile);
    if (szPrivateKeyFile)
        pCardData->pfnCspFree(szPrivateKeyFile);
    if (szPublicKeyFile)
        pCardData->pfnCspFree(szPublicKeyFile);
    
    LOG_END_FUNCTION(CardCreateContainer, dwError);

    return dwError;
}

//
// Initializes a CONTAINER_INFO structure for the indicated container, 
// including Signature and Key Exchange Crypto API public key blobs if
// those keys exist.
//
DWORD
WINAPI
CardGetContainerInfo(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN OUT  PCONTAINER_INFO pContainerInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR szPublicKeyFile = NULL;
    PBYTE pbPublicKey = NULL;
    DWORD cbPublicKey = 0;
    BLOBHEADER *pBlobHeader = NULL;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_FUNCTION(CardGetContainerInfo);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    //
    // Does this container have a Signature key?
    //

    dwError = BuildCardKeyFilenames(
        pCardData,
        AT_SIGNATURE,
        bContainerIndex,
        NULL,
        &szPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    dwError = I_CardReadFile(
        pCardData,
        (LPWSTR) szPublicKeyFile,
        &pbPublicKey,
        &cbPublicKey,
        TRUE);

    switch (dwError)
    {
    case SCARD_E_FILE_NOT_FOUND:
         
        // There appears to be no Signature key in this container.  Continue.

        break;

    case ERROR_SUCCESS:
    
        pContainerInfo->pbSigPublicKey = 
            (PBYTE) pCardData->pfnCspAlloc(sizeof(BLOBHEADER) + cbPublicKey);
    
        LOG_CHECK_ALLOC(pContainerInfo->pbSigPublicKey);
    
        pBlobHeader = (BLOBHEADER *) pContainerInfo->pbSigPublicKey;
        pBlobHeader->bType = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0x0000;
        pBlobHeader->aiKeyAlg = CALG_RSA_SIGN;
    
        memcpy(
            pContainerInfo->pbSigPublicKey + sizeof(BLOBHEADER),
            pbPublicKey,
            cbPublicKey);
    
        pContainerInfo->cbSigPublicKey = sizeof(BLOBHEADER) + cbPublicKey;
    
        pCardData->pfnCspFree(szPublicKeyFile);
        szPublicKeyFile = NULL;
        pCardData->pfnCspFree(pbPublicKey);
        pbPublicKey = NULL;

        break;

    default:

        // Unexpected error
        goto Ret;
    }

    // 
    // Does this container have a Key Exchange key?
    //

    dwError = BuildCardKeyFilenames(
        pCardData,
        AT_KEYEXCHANGE,
        bContainerIndex,
        NULL,
        &szPublicKeyFile);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    dwError = I_CardReadFile(
        pCardData,
        (LPWSTR) szPublicKeyFile,
        &pbPublicKey,
        &cbPublicKey,
        TRUE);

    switch (dwError)
    {
    case SCARD_E_FILE_NOT_FOUND:
         
        // There appears to be no Key Exchange key in this container.  

        break;

    case ERROR_SUCCESS:

        pContainerInfo->pbKeyExPublicKey =
            (PBYTE) pCardData->pfnCspAlloc(sizeof(BLOBHEADER) + cbPublicKey);

        LOG_CHECK_ALLOC(pContainerInfo->pbKeyExPublicKey);

        pBlobHeader = (BLOBHEADER *) pContainerInfo->pbKeyExPublicKey;
        pBlobHeader->bType = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0x0000;
        pBlobHeader->aiKeyAlg = CALG_RSA_KEYX;

        memcpy(
            pContainerInfo->pbKeyExPublicKey + sizeof(BLOBHEADER),
            pbPublicKey,
            cbPublicKey);

        pContainerInfo->cbKeyExPublicKey = sizeof(BLOBHEADER) + cbPublicKey;

        break;

    default:

        // Unexpected error
        goto Ret;
    }

    // If we got here, then the API has succeeded
    dwError = ERROR_SUCCESS;

Ret:
    if (pbPublicKey)
        pCardData->pfnCspFree(pbPublicKey);
    if (szPublicKeyFile)
        pCardData->pfnCspFree(szPublicKeyFile);

    if (ERROR_SUCCESS != dwError)
    {
        if (NULL != pContainerInfo->pbKeyExPublicKey)
        {
            pCardData->pfnCspFree(pContainerInfo->pbKeyExPublicKey);
            pContainerInfo->pbKeyExPublicKey = NULL;
        }

        if (NULL != pContainerInfo->pbSigPublicKey)
        {
            pCardData->pfnCspFree(pContainerInfo->pbSigPublicKey);
            pContainerInfo->pbSigPublicKey = NULL;
        }
    }

    LOG_END_FUNCTION(CardGetContainerInfo, dwError);

    return dwError;
}

//
// Queries the number of pin retries available for the specified user, using
// the pin counter applet.
//
DWORD I_CardQueryPinRetries(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      wszPrincipal,
    OUT     PDWORD      pcAttemptsRemaining)
{
    DWORD dwError = ERROR_SUCCESS;
    ISO_HEADER IsoHeader;
    UINT16 wStatusWord = 0;
    SCODE status = 0;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    // Build the command
    IsoHeader.INS = PIN_RETRY_COUNTER_INS;
    IsoHeader.CLA = PIN_RETRY_COUNTER_CLA;
    IsoHeader.P1 = PIN_RETRY_COUNTER_P1;
    IsoHeader.P2 = PIN_RETRY_COUNTER_P2;

    status = hScwExecute(
        pCardmodContext->hWfscCardHandle,
        &IsoHeader,
        (PBYTE) wszPrincipal,
        (TCOUNT) (wcslen(wszPrincipal) + 1) * sizeof(WCHAR),
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
        dwError = I_CardMapExecuteErrorCode(wStatusWord);
    else
        dwError = I_CardMapErrorCode(status);

    if (ERROR_SUCCESS == dwError)
        *pcAttemptsRemaining = (DWORD) (wStatusWord & 0xFF);

    return dwError;
}

//
// Authenticates the specified logical user name via the specified pin.
//
// If pcAttemptsRemaining is non-NULL, and if the authentication fails,
// that parameter will container the number of authentication attempts 
// remaining before the card is locked.
//
DWORD
WINAPI
CardSubmitPin(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      PBYTE       pbPin,
    IN      DWORD       cbPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    LPWSTR wszPrincipal = NULL;
    SCODE scode = SCW_S_OK;
    DWORD dwAttempts = 0;

    LOG_BEGIN_FUNCTION(CardSubmitPin);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    if (NULL != pcAttemptsRemaining)
        *pcAttemptsRemaining = CARD_DATA_VALUE_UNKNOWN;

    dwError = GetWellKnownUserMapping(
        pCardData, pwszUserId, &wszPrincipal);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    scode = hScwAuthenticateName(
        pCardmodContext->hWfscCardHandle,
        wszPrincipal,
        pbPin,
        (TCOUNT) cbPin);

    dwError = I_CardMapErrorCode(scode);

    if (SCARD_E_INVALID_CHV == dwError && NULL != pcAttemptsRemaining)
    {
        // Determine how many more invalid pin presentation attempts can be 
        // made before the card is locked.

        dwError = I_CardQueryPinRetries(
            pCardData,
            wszPrincipal,
            &dwAttempts);

        if (ERROR_SUCCESS != dwError)
            goto Ret;

        *pcAttemptsRemaining = dwAttempts;
        dwError = (DWORD) SCARD_E_INVALID_CHV;
    }

Ret:

    if (wszPrincipal)
        pCardData->pfnCspFree(wszPrincipal);

    LOG_END_FUNCTION(CardSubmitPin, dwError);

    return dwError;
}

//
// Changes the pin for the specified logical user.
//
// If the authentication using the current pin fails, and if 
// pcAttemptsRemaining is non-NULL, that parameter will be set to the number
// of authentication attempts remaining before the card is locked.
//
DWORD I_CardChangePin(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      wszPhysicalUser,
    IN      PBYTE       pbCurrentPin,
    IN      DWORD       cbCurrentPin,
    IN      PBYTE       pbNewPin,
    IN      DWORD       cbNewPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{
    ISO_HEADER IsoHeader;
    UINT16 wStatusWord = 0;
    PBYTE pbDataIn = NULL;
    DWORD cbDataIn = 0;
    DWORD cbUser = 0;
    SCODE status = 0;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    DWORD cAttempts = 0;

    memset(&IsoHeader, 0, sizeof(IsoHeader));

    if (NULL != pcAttemptsRemaining)
        *pcAttemptsRemaining = CARD_DATA_VALUE_UNKNOWN;

    //
    // Allocate a command buffer to be transmitted to the card
    //

    cbUser = (DWORD) (wcslen(wszPhysicalUser) + 1) * sizeof(WCHAR); 

    cbDataIn = 2 + cbUser + 2 + cbCurrentPin + 2 + cbNewPin;

    pbDataIn = (PBYTE) pCardData->pfnCspAlloc(cbDataIn);

    LOG_CHECK_ALLOC(pbDataIn);

    cbDataIn = 0;

    // Setup User Name TLV
    pbDataIn[cbDataIn] = 0;
    cbDataIn++;

    pbDataIn[cbDataIn] = (BYTE) cbUser;
    cbDataIn++;

    memcpy(pbDataIn + cbDataIn, (PBYTE) wszPhysicalUser, cbUser);
    cbDataIn += cbUser;

    // Setup Current Pin TLV
    pbDataIn[cbDataIn] = 1;
    cbDataIn++;

    pbDataIn[cbDataIn] = (BYTE) cbCurrentPin;
    cbDataIn++;

    memcpy(pbDataIn + cbDataIn, pbCurrentPin, cbCurrentPin);
    cbDataIn += cbCurrentPin;

    // Setup New Pin TLV
    pbDataIn[cbDataIn] = 2;
    cbDataIn++;

    pbDataIn[cbDataIn] = (BYTE) cbNewPin;
    cbDataIn++;

    memcpy(pbDataIn + cbDataIn, pbNewPin, cbNewPin);
    cbDataIn += cbNewPin;

    // Build the command
    IsoHeader.INS = PIN_CHANGE_INS;
    IsoHeader.CLA = PIN_CHANGE_CLA;
    IsoHeader.P1 = PIN_CHANGE_P1;
    IsoHeader.P2 = PIN_CHANGE_P2;

    //
    // Send the pin change command to the card
    //

    status = hScwExecute(
        pCardmodContext->hWfscCardHandle,
        &IsoHeader,
        pbDataIn,
        (TCOUNT) cbDataIn,
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
        dwError = I_CardMapExecuteErrorCode(wStatusWord);
    else
        dwError = I_CardMapErrorCode(status);

    if (SCARD_E_INVALID_CHV == dwError && NULL != pcAttemptsRemaining)
    {
        dwError = I_CardQueryPinRetries(
            pCardData,
            wszPhysicalUser,
            &cAttempts);

        if (ERROR_SUCCESS != dwError)
            goto Ret;

        *pcAttemptsRemaining = cAttempts;
        dwError = (DWORD) SCARD_E_INVALID_CHV;
    }

Ret:

    if (pbDataIn)
        pCardData->pfnCspFree(pbDataIn);

    return dwError;
}

//
// Performs the challenge-response using the provided callback
//
/*
DWORD I_CardChallengeResponse(
    IN PCARD_DATA pCardData,
    IN PFN_PIN_CHALLENGE_CALLBACK pfnCallback,
    IN PVOID pvCallbackContext,
    OUT PBYTE *ppbResponse,
    OUT DWORD *pcbResponse)
{
    PBYTE pbChallenge = NULL;
    DWORD cbChallenge = 0;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    cbChallenge = cbCHALLENGE_RESPONSE_DATA;
    *pcbResponse = cbCHALLENGE_RESPONSE_DATA;
    
    pbChallenge = pCardData->pfnCspAlloc(cbChallenge);

    LOG_CHECK_ALLOC(pbChallenge);

    *ppbResponse = pCardData->pfnCspAlloc(*pcbResponse);

    LOG_CHECK_ALLOC(*ppbResponse);

    LOG_CHECK_SCW_CALL(hScwGenerateRandom(
        pCardmodContext->hWfscCardHandle,
        pbChallenge,
        (TCOUNT) cbChallenge));

    dwError = pfnCallback(
        pbChallenge,
        cbChallenge,
        *ppbResponse,
        *pcbResponse,
        pvCallbackContext);

Ret:

    if (NULL != pbChallenge)
        pCardData->pfnCspFree(pbChallenge);

    if (NULL != *ppbResponse && ERROR_SUCCESS != dwError)
    {
        pCardData->pfnCspFree(*ppbResponse);
        *ppbResponse = NULL;
    }

    return dwError;
}
*/

// 
// Calls the pin unblock applet on the card
//
DWORD I_CardUnblock(
    IN PCARD_DATA pCardData,
    IN LPWSTR wszPhysicalUser,
    IN PBYTE pbNewPin,
    IN DWORD cbNewPin,
    IN DWORD cNewMaxRetries)
{
    ISO_HEADER IsoHeader;
    UINT16 wStatusWord = 0;
    PBYTE pbDataIn = NULL;
    DWORD cbDataIn = 0;
    DWORD cbUser = 0;
    SCODE status = 0;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    memset(&IsoHeader, 0, sizeof(IsoHeader));

    //
    // Allocate a command buffer to be transmitted to the card
    //

    cbUser = (DWORD) (wcslen(wszPhysicalUser) + 1) * sizeof(WCHAR); 

    cbDataIn = 2 + cbUser + 2 + cbNewPin;

    pbDataIn = (PBYTE) pCardData->pfnCspAlloc(cbDataIn);

    LOG_CHECK_ALLOC(pbDataIn);

    cbDataIn = 0;

    // Setup User Name TLV
    pbDataIn[cbDataIn] = 0;
    cbDataIn++;

    pbDataIn[cbDataIn] = (BYTE) cbUser;
    cbDataIn++;

    memcpy(pbDataIn + cbDataIn, (PBYTE) wszPhysicalUser, cbUser);
    cbDataIn += cbUser;

    // Setup New Pin TLV
    pbDataIn[cbDataIn] = 2;
    cbDataIn++;

    pbDataIn[cbDataIn] = (BYTE) cbNewPin;
    cbDataIn++;

    memcpy(pbDataIn + cbDataIn, pbNewPin, cbNewPin);
    cbDataIn += cbNewPin;

    // Build the command
    IsoHeader.INS = PIN_UNBLOCK_INS;
    IsoHeader.CLA = PIN_UNBLOCK_CLA;
    IsoHeader.P1 = PIN_UNBLOCK_P1;
    IsoHeader.P2 = (BYTE) cNewMaxRetries;

    //
    // Send the pin change command to the card
    //

    status = hScwExecute(
        pCardmodContext->hWfscCardHandle,
        &IsoHeader,
        pbDataIn,
        (TCOUNT) cbDataIn,
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
        dwError = I_CardMapExecuteErrorCode(wStatusWord);
    else
        dwError = I_CardMapErrorCode(status);

Ret:

    if (pbDataIn)
        pCardData->pfnCspFree(pbDataIn);

    return dwError;
}

//
// Retrieves cryptographic authentication challenge bytes from the card.
//
DWORD 
WINAPI 
CardGetChallenge(
    IN      PCARD_DATA  pCardData,
    OUT     PBYTE       *ppbChallengeData,
    OUT     PDWORD      pcbChallengeData)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    LOG_BEGIN_FUNCTION(CardGetChallenge);

    *pcbChallengeData = cbCHALLENGE_RESPONSE_DATA;
    
    *ppbChallengeData = pCardData->pfnCspAlloc(*pcbChallengeData);

    LOG_CHECK_ALLOC(*ppbChallengeData);

    LOG_CHECK_SCW_CALL(hScwGenerateRandom(
        pCardmodContext->hWfscCardHandle,
        *ppbChallengeData,
        (TCOUNT) (*pcbChallengeData)));

Ret:

    if (NULL != *ppbChallengeData && ERROR_SUCCESS != dwError)
    {
        pCardData->pfnCspFree(*ppbChallengeData);
        *ppbChallengeData = NULL;
    }

    LOG_END_FUNCTION(CardGetChallenge, dwError);

    return dwError;
}


//
// Submits the supplied response bytes to the card, to complete an Admin 
// challenge-response authentication.
//
DWORD 
WINAPI 
CardAuthenticateChallenge(
    IN      PCARD_DATA  pCardData,
    IN      PBYTE       pbResponseData,
    IN      DWORD       cbResponseData,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{   
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    LOG_BEGIN_FUNCTION(CardAuthenticateChallenge);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    //
    // Authenticate the admin
    //

    dwError = CardSubmitPin(
        pCardData,
        wszCARD_USER_ADMIN,
        pbResponseData,
        cbResponseData,
        pcAttemptsRemaining);

    LOG_END_FUNCTION(CardAuthenticateChallenge, dwError);

    return dwError;
}

//
// Authenticates as Admin using the provided auth material.  Then unblocks the
// specified account and sets the specified new pin and retry count.  The Admin
// is deauthenticated before returning.
//
DWORD 
WINAPI 
CardUnblockPin(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbAuthenticationData,
    IN      DWORD       cbAuthenticationData,
    IN      PBYTE       pbNewPinData,
    IN      DWORD       cbNewPinData,
    IN      DWORD       cRetryCount,
    IN      DWORD       dwFlags)
{    
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    LPWSTR wszPhysicalUser = NULL;

    LOG_BEGIN_FUNCTION(CardUnblockPin);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    // Verify that admin authentication method flags are valid, although this
    // module will use the auth data the same way in either case.
    if (CARD_UNBLOCK_PIN_PIN != dwFlags &&
        CARD_UNBLOCK_PIN_CHALLENGE_RESPONSE != dwFlags)
    {
        dwError = (DWORD) NTE_BAD_FLAGS;
        goto Ret;
    }

    // Map the provided logical user name to physical user
    dwError = GetWellKnownUserMapping(
         pCardData,
         pwszUserId,
         &wszPhysicalUser);

     if (ERROR_SUCCESS != dwError)
         goto Ret;

    // Authenticate as admin
    dwError = CardSubmitPin(
        pCardData,
        wszCARD_USER_ADMIN,
        pbAuthenticationData,
        cbAuthenticationData,
        NULL);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    // Perform the unblock
    dwError = I_CardUnblock(
        pCardData,
        wszPhysicalUser,
        pbNewPinData,
        cbNewPinData,
        cRetryCount);

Ret:

    if (NULL != wszPhysicalUser)
        pCardData->pfnCspFree(wszPhysicalUser);

    LOG_END_FUNCTION(CardUnblockPin, dwError);

    return dwError;
}

//
// Changes the pin or challenge-response key for the specified account.
// 
// Updating the retry count via this API is not supported in this 
// implementation.
//
DWORD 
WINAPI 
CardChangeAuthenticator(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbCurrentAuthenticator,
    IN      DWORD       cbCurrentAuthenticator,
    IN      PBYTE       pbNewAuthenticator,
    IN      DWORD       cbNewAuthenticator,
    IN      DWORD       cRetryCount,
    OUT OPTIONAL PDWORD pcAttemptsRemaining)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    LPWSTR wszPhysicalUser = NULL;

    LOG_BEGIN_FUNCTION(CardChangeAuthenticator);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    if (0 != cRetryCount)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // Map the provided logical user name to physical user
    dwError = GetWellKnownUserMapping(
         pCardData,
         pwszUserId,
         &wszPhysicalUser);

    if (ERROR_SUCCESS != dwError)
         goto Ret;

    // Change the authenticator (pin or challenge-response key) for the target
    // account.
    dwError = I_CardChangePin(
        pCardData,
        wszPhysicalUser,
        pbCurrentAuthenticator,
        cbCurrentAuthenticator,
        pbNewAuthenticator,
        cbNewAuthenticator,
        pcAttemptsRemaining);

Ret:

    if (NULL != wszPhysicalUser)
        pCardData->pfnCspFree(wszPhysicalUser);

    LOG_END_FUNCTION(CardChangeAuthenticator, dwError);

    return dwError;
}

//
// De-authenticates the specified logical user.
//
DWORD
WINAPI
CardDeauthenticate(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      DWORD       dwFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR wszPhysicalUser = NULL;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_FUNCTION(CardDeauthenticate);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownUserMapping(pCardData, pwszUserId, &wszPhysicalUser);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    LOG_CHECK_SCW_CALL(hScwDeauthenticateName(
        pCardmodContext->hWfscCardHandle,
        wszPhysicalUser));

Ret:

    if (wszPhysicalUser)
        pCardData->pfnCspFree(wszPhysicalUser);

    LOG_END_FUNCTION(CardDeauthenticate, dwError);

    return dwError;
}


//
// Creates a new file on the card using the specified logical name and Access
// Condition.  
//
// If the specified file already exists, ERROR_FILE_EXISTS is returned.
//
DWORD
WINAPI
CardCreateFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR szPhysicalFileName = NULL;
    LPWSTR wszPhysicalAcl = NULL;                      
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    HFILE hFile = 0;

    LOG_BEGIN_FUNCTION(CardCreateFile);

    if (wcslen(pwszFileName) >
        MAX_SUPPORTED_FILE_LEN)
    {
        dwError = ERROR_FILENAME_EXCED_RANGE;
        goto Ret;
    }

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownFileMapping(
        pCardData, pwszFileName, &szPhysicalFileName);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    dwError = GetWellKnownAcMapping(
        pCardData, AccessCondition, &wszPhysicalAcl);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    LOG_CHECK_SCW_CALL(hScwCreateFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPhysicalFileName,
        wszPhysicalAcl,
        &hFile));

Ret:
    if (szPhysicalFileName)
        pCardData->pfnCspFree(szPhysicalFileName);
    if (wszPhysicalAcl)
        pCardData->pfnCspFree(wszPhysicalAcl);
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle,
            hFile);

    LOG_END_FUNCTION(CardCreateFile, dwError);

    return dwError;
}


//
// Reads the specified logical file directly from the card (without any
// caching).
//
// If the specified file is not found, returns SCARD_E_FILE_NOT_FOUND.
//
DWORD 
WINAPI
CardReadFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    OUT     PBYTE       *ppbData,
    OUT     PDWORD      pcbData)
{
    LPSTR szPhysical = NULL;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_FUNCTION(CardReadFile);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownFileMapping(
        pCardData,
        pwszFileName,
        &szPhysical);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    // 
    // For any file requested directly by the CSP (or other caller), assume 
    // that no cache lookup should be done.  That is, assume that the caller
    // is doing its own caching for files that it "owns".
    //
    dwError = I_CardReadFile(
        pCardData,
        (LPWSTR) szPhysical,
        ppbData,
        pcbData,
        FALSE);
    
Ret:
    if (szPhysical)
        pCardData->pfnCspFree(szPhysical);

    if (CARDMOD_FAILED(dwError) && *ppbData)
    {
        pCardData->pfnCspFree(*ppbData);
        *ppbData = NULL;
    }
    
    LOG_END_FUNCTION(CardReadFile, dwError);

    return dwError;
}

//
// Writes the specified logical file to the card.
//
// If the specified file does not already exist, SCARD_E_FILE_NOT_FOUND
// is returned.
//
DWORD
WINAPI
CardWriteFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    LPSTR szPhysical = NULL;
    DWORD dwError = ERROR_SUCCESS;
    HFILE hFile = 0;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    DWORD cbActual = 0;

    UNREFERENCED_PARAMETER(dwFlags);
    
    LOG_BEGIN_FUNCTION(CardWriteFile);
    
    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownFileMapping(
        pCardData, pwszFileName, &szPhysical);
    
    if (ERROR_SUCCESS != dwError)
        goto Ret;

    LOG_CHECK_SCW_CALL(hScwCreateFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPhysical,
        NULL,
        &hFile));
    
    LOG_CHECK_SCW_CALL(hScwWriteFile32(
        pCardmodContext->hWfscCardHandle,
        hFile,
        pbData,
        cbData,
        &cbActual));

    if (cbActual != cbData)
    {
        dwError = (DWORD) SCARD_W_EOF;
        goto Ret;
    }

Ret:
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle, hFile);
    if (szPhysical)
        pCardData->pfnCspFree(szPhysical);

    LOG_END_FUNCTION(CardWriteFile, dwError);

    return dwError;
}

//
// Deletes the specified logical file from the card.
//
// If the specified files is not found, SCARD_E_FILE_NOT_FOUND is returned.
//
DWORD
WINAPI
CardDeleteFile(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwReserved,
    IN      LPWSTR      pwszFileName)
{
    LPSTR szPhysical = NULL;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwReserved);

    LOG_BEGIN_FUNCTION(CardDeleteFile);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownFileMapping(
        pCardData, pwszFileName, &szPhysical);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    LOG_CHECK_SCW_CALL(hScwDeleteFile(
        pCardmodContext->hWfscCardHandle, (LPWSTR) szPhysical));

Ret:

    if (szPhysical)
        pCardData->pfnCspFree(szPhysical);

    LOG_END_FUNCTION(CardDeleteFile, dwError);

    return dwError;
}

//
// Enumerates the files present on the card in the logical directory name
// specified by the caller in the pmwszFileName parameter.
//
DWORD
WINAPI
CardEnumFiles(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    IN OUT  LPWSTR      *pmwszFileName)
{
    /*
    LPWSTR wszPhysicalDirectory = NULL;
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    LPWSTR wszFiles = NULL;
    LPWSTR wsz = NULL;
    DWORD cchFiles = MAX_SUPPORTED_FILE_LEN;
    DWORD cchCurrent = 0;
    UINT16 nEnumCookie = 0;
    SCODE result = 0;
    BOOL fRetrying = FALSE;
    */

    UNREFERENCED_PARAMETER(dwFlags);

    //
    // TODO - need to implement reverse file mapping for this function to work
    // correctly.
    //

    UNREFERENCED_PARAMETER(pCardData);
    UNREFERENCED_PARAMETER(pmwszFileName);
    return ERROR_CALL_NOT_IMPLEMENTED;

    /*
    LOG_BEGIN_FUNCTION(CardEnumFiles);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    // Find the physical directory name in which we'll
    // be enumerating.
    
    dwError = GetWellKnownFileMapping(
        pCardData, *pmwszFileName, &wszPhysicalDirectory);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    // Now set the CSP's pointer to the logical directory
    // name to NULL to avoid ambiguity, since we'll be re-using the same 
    // pointer to return the list of files.
    
    *pmwszFileName = NULL;

    // Allocate space for a multi-string that may or may not be
    // large enough to hold all of the enumerated file names.

    wszFiles = (LPWSTR) pCardData->pfnCspAlloc(cchFiles * sizeof(WCHAR));

    LOG_CHECK_ALLOC(wszFiles);

#pragma warning(push)
// Disable warning/error for conditional expression is constant
#pragma warning(disable:4127) 

    while (TRUE)
    {                                                       
#pragma warning(pop)

        //
        // The WFSC marshalling code seems to puke if a buffer length of
        // greater than SCHAR_MAX (127) is passed.
        //
        result = hScwEnumFile(
            pCardmodContext->hWfscCardHandle,
            wszPhysicalDirectory,
            &nEnumCookie,
            wszFiles + cchCurrent,
            (TCOUNT) min(cchFiles - cchCurrent, MAX_SUPPORTED_FILE_LEN));

        if (SCW_S_OK == result)
        {
            // Add on the length of the new file plus its terminator
            cchCurrent += (DWORD) wcslen(wszFiles + cchCurrent) + 1;

            fRetrying = FALSE;

            // Continue looping
        }
        else if (SCW_E_BUFFERTOOSMALL == result)
        {
            if (fRetrying)
            {
                // We already retried this call once.  Give up.
                break;
            }

            wsz = (LPWSTR) pCardData->pfnCspAlloc((cchCurrent * 2) * sizeof(WCHAR));

            LOG_CHECK_ALLOC(wsz);

            memcpy(
                wsz,
                wszFiles,
                cchCurrent);

            pCardData->pfnCspFree(wszFiles);
            wszFiles = wsz;
            wsz = NULL;
            cchFiles = cchCurrent * 2;

            fRetrying = TRUE;

            // Retry the last enum call
        }
        else if (SCW_E_NOMOREFILES == result)
        {
            *pmwszFileName = (LPWSTR) pCardData->pfnCspAlloc(
                (1 + cchCurrent) * sizeof(WCHAR));

            LOG_CHECK_ALLOC(*pmwszFileName);

            memcpy(
                *pmwszFileName,
                wszFiles,
                cchCurrent * sizeof(WCHAR));

            // Make sure the multi-string is terminated by an extra NULL
            (*pmwszFileName)[cchCurrent] = L'\0';

            // We're done
            break;
        }
        else
        {
            // Unexpected error.  Bail.
            dwError = (DWORD) result;
            goto Ret;
        }
    }

Ret:

    if (wszPhysicalDirectory)
        pCardData->pfnCspFree(wszPhysicalDirectory);
    if (wszFiles)
        pCardData->pfnCspFree(wszFiles);
    if (wsz)
        pCardData->pfnCspFree(wsz);

    if (ERROR_SUCCESS != dwError && *pmwszFileName)
    {
        pCardData->pfnCspFree(*pmwszFileName);
        *pmwszFileName = NULL;
    }

    LOG_END_FUNCTION(CardEnumFiles, dwError);

    return dwError;
    */
}

//
// Initializes a CARD_FILE_INFO structure for the specified logical file.
//
DWORD
WINAPI
CardGetFileInfo(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    OUT     PCARD_FILE_INFO pCardFileInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR szPhysical = NULL;
    HFILE hFile = 0;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    TOFFSET nFileLength = 0;

    LOG_BEGIN_FUNCTION(CardGetFileInfo);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = GetWellKnownFileMapping(
        pCardData,
        pwszFileName,
        &szPhysical);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    //
    // First, get the length of the file.
    //
    LOG_CHECK_SCW_CALL(hScwCreateFile(
        pCardmodContext->hWfscCardHandle,
        (LPWSTR) szPhysical,
        NULL,
        &hFile));

    LOG_CHECK_SCW_CALL(hScwGetFileLength(
        pCardmodContext->hWfscCardHandle,
        hFile,
        &nFileLength));

    pCardFileInfo->cbFileSize = (DWORD) nFileLength;

    //
    // Next, get ACL info.
    //

    // TODO
    pCardFileInfo->AccessCondition = InvalidAc;
    
Ret:

    if (szPhysical)
        pCardData->pfnCspFree(szPhysical);    
    if (hFile)
        hScwCloseFile(
            pCardmodContext->hWfscCardHandle, hFile);

    LOG_END_FUNCTION(CardGetFileInfo, dwError);

    return dwError;
}


//
// Initializes a CARD_FREE_SPACE_INFO structure using static information about
// the available space on the target card.
//
DWORD
WINAPI
CardQueryFreeSpace(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    OUT     PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo)
{
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwFlags);

    LOG_BEGIN_FUNCTION(CardQueryFreeSpace);
    
    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    //
    // Get the base free space information for this card.
    //
    memcpy(
        pCardFreeSpaceInfo,
        &pCardmodContext->pSupportedCard->CardFreeSpaceInfo,
        sizeof(CARD_FREE_SPACE_INFO));

    LOG_END_FUNCTION(CardQueryFreeSpace, 0);

    return ERROR_SUCCESS;
}

// 
// Performs an RSA decryption using the specified Signature or Key Exchange
// key on the specified data.  The length of the target data must be equal
// to the length of the public modulus, and pInfo->cbData must be set to 
// that length.
//
DWORD
WINAPI
CardPrivateKeyDecrypt(
    IN      PCARD_DATA                      pCardData,
    IN OUT  PCARD_PRIVATE_KEY_DECRYPT_INFO  pInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR szPrivateKeyFile = NULL;
    PBYTE pbInit = NULL;
    DWORD cbInit = 0;
    DWORD cbPrivateKeyFile = 0;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;
    PBYTE pbCiphertext = NULL;
    TCOUNT cbCiphertext = 0;

    LOG_BEGIN_FUNCTION(CardPrivateKeyDecrypt);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    dwError = BuildCardKeyFilenames(
        pCardData,
        pInfo->dwKeySpec,
        pInfo->bContainerIndex,
        &szPrivateKeyFile,
        NULL);

    if (CARDMOD_FAILED(dwError))
        goto Ret;

    //
    // Setup the command to initialize the RSA operation on the card
    //

    cbPrivateKeyFile = ((DWORD) wcslen(
        (LPWSTR) szPrivateKeyFile) + 1) * sizeof(WCHAR);

    cbInit = 1 + 1 + 1 + cbPrivateKeyFile + 2;

    pbInit = (PBYTE) pCardData->pfnCspAlloc(cbInit);

    LOG_CHECK_ALLOC(pbInit);

    cbInit = 0;

    // Tag
    pbInit[cbInit] = 0x00;
    cbInit++;

    // Length
    //  Number of following bytes:
    //  filename len, filename + NULL, key data offset
    pbInit[cbInit] = (BYTE) (1 + cbPrivateKeyFile + 2);
    cbInit++;

    // Value
    pbInit[cbInit] = (BYTE) cbPrivateKeyFile / sizeof(WCHAR);
    cbInit++;

    memcpy(pbInit + cbInit, (PBYTE) szPrivateKeyFile, cbPrivateKeyFile);
    cbInit += cbPrivateKeyFile;

    *(UNALIGNED WORD *) (pbInit + cbInit) = 0x0000;

    LOG_CHECK_SCW_CALL(hScwCryptoInitialize(
        pCardmodContext->hWfscCardHandle,
        CM_RSA_CRT | CM_KEY_INFILE,
        pbInit));

    //
    // Do the private key decrypt
    //

    pbCiphertext = (PBYTE) pCardData->pfnCspAlloc(pInfo->cbData);

    LOG_CHECK_ALLOC(pbCiphertext);

    cbCiphertext = (TCOUNT) pInfo->cbData;

    LOG_CHECK_SCW_CALL(hScwCryptoAction(
        pCardmodContext->hWfscCardHandle,
        pInfo->pbData,
        (TCOUNT) pInfo->cbData,
        pbCiphertext,
        &cbCiphertext));

    if (cbCiphertext != pInfo->cbData)
    {
        dwError = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    memcpy(pInfo->pbData, pbCiphertext, cbCiphertext);

Ret:

    if (pbCiphertext)
        pCardData->pfnCspFree(pbCiphertext);
    if (pbInit)
        pCardData->pfnCspFree(pbInit);
    if (szPrivateKeyFile)
        pCardData->pfnCspFree(szPrivateKeyFile);

    LOG_END_FUNCTION(CardPrivateKeyDecrypt, dwError);

    return dwError;
}

//
// Initializes a CARD_KEY_SIZES structure for the specified key type, indicated
// the key sizes supported by the target card.
//
DWORD
WINAPI
CardQueryKeySizes(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwReserved,
    OUT     PCARD_KEY_SIZES pKeySizes)
{
    DWORD dwError = ERROR_SUCCESS;
    PCARDMOD_CONTEXT pCardmodContext = 
        (PCARDMOD_CONTEXT) pCardData->pvVendorSpecific;

    UNREFERENCED_PARAMETER(dwReserved);

    LOG_BEGIN_FUNCTION(CardQueryKeySizes);

    ProxyUpdateScardHandle(pCardmodContext->hWfscCardHandle, pCardData->hScard);

    switch (dwKeySpec)
    {
    case AT_SIGNATURE:
        memcpy(
            pKeySizes,
            &pCardmodContext->pSupportedCard->CardKeySizes_Sig,
            sizeof(CARD_KEY_SIZES));

        break;

    case AT_KEYEXCHANGE:
        memcpy(
            pKeySizes,
            &pCardmodContext->pSupportedCard->CardKeySizes_KeyEx,
            sizeof(CARD_KEY_SIZES));

        break;

    default:
        dwError = (DWORD) NTE_BAD_ALGID;
        break;
    }

    LOG_END_FUNCTION(CardQueryKeySizes, dwError);

    return dwError;
}

// 
// Loader callback.
//
BOOL WINAPI
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context)    // Unused parameter
{
    DWORD dwLen = 0;

    UNREFERENCED_PARAMETER(Context);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        // Get our image name.
        dwLen = GetModuleBaseName(
            GetCurrentProcess(),
            hmod,
            l_wszImagePath, 
            sizeof(l_wszImagePath) / sizeof(l_wszImagePath[0]));

        if (0 == dwLen)
             return FALSE;

        DisableThreadLibraryCalls(hmod);

#if DBG
        CardmodInitDebug(MyDebugKeys);
#endif
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
        // Cleanup
#if DBG 
        CardmodUnloadDebug();
#endif
    }

    return TRUE;
}

//
// Registers the cards supported by this card module.
//
STDAPI
DllRegisterServer(
    void)
{         
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwSts;
    int iSupportedCard = 0;

    for (
            iSupportedCard = 0; 
            iSupportedCard < sizeof(SupportedCards) / 
                sizeof(SupportedCards[0]); 
            iSupportedCard++)
    {
        SCardForgetCardType(
            0,
            SupportedCards[iSupportedCard].wszCardName);

        dwSts = SCardIntroduceCardType(
            0,
            SupportedCards[iSupportedCard].wszCardName,
            NULL,
            NULL,
            0,
            SupportedCards[iSupportedCard].rgbAtr,
            SupportedCards[iSupportedCard].rgbAtrMask,
            SupportedCards[iSupportedCard].cbAtr);
    
        if (SCARD_S_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorRet;
        }
    
        dwSts = SCardSetCardTypeProviderName(
            0,
            SupportedCards[iSupportedCard].wszCardName,
            SCARD_PROVIDER_CSP,
            MS_SCARD_PROV);
        
        if (SCARD_S_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorRet;
        }
    
        dwSts = SCardSetCardTypeProviderName(
            0,
            SupportedCards[iSupportedCard].wszCardName,
            SCARD_PROVIDER_CARD_MODULE,
            l_wszImagePath);
    
        if (SCARD_S_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorRet;
        }
    }
    
ErrorRet:
    return dwReturn;
}

//
// Deletes the registration of cards supported by this card module.
//
STDAPI
DllUnregisterServer(
    void)
{
    DWORD dwSts = ERROR_SUCCESS;
    int iSupportedCard = 0;

    for (
            iSupportedCard = 0; 
            iSupportedCard < sizeof(SupportedCards) / 
                sizeof(SupportedCards[0]); 
            iSupportedCard++)
    {
        dwSts = SCardForgetCardType(
            0,
            SupportedCards[iSupportedCard].wszCardName);
    }

    return dwSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\cardmod\debug.c ===
#include <windows.h>
#include "carddbg.h"

DEBUG_KEY  MyDebugKeys[] = 
{   
    {DEB_ERROR,                 "Error"},
    {DEB_WARN,                  "Warning"},
    {DEB_TRACE,                 "Trace"},
    {DEB_TRACE_FUNC,            "TraceFuncs"},
    {DEB_TRACE_MEM,             "TraceMem"},
    {DEB_TRACE_TRANSMIT,        "TraceTransmit"},
    {DEB_TRACE_PROXY,           "TraceProxy"},
    {0, NULL}
};

#if DBG
#include <stdio.h>
#define CROW 16
void I_DebugPrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];
    ULONG cbOffset = 0;
    BOOL fTruncated = FALSE;

    if (NULL == pb || 0 == cbSize)
        return;

    memset(rgsz, 0, sizeof(rgsz));

    DebugLog((
        DEB_TRACE_TRANSMIT, 
        "%S, %d bytes ::\n", 
        pwszHdr, 
        cbSize));

    // Don't overflow the debug library output buffer.
    if (cbSize > 50)
    {
        cbSize = 50;
        fTruncated = TRUE;
    }

    while (cbSize > 0)
    {
        // Start every row with extra space
        strcat(rgsz, "   ");
        cbOffset = (ULONG) strlen(rgsz);

        cb = min(CROW, cbSize);
        cbSize -= cb;

        for (i = 0; i < cb; i++)
        {
            sprintf(
                rgsz + cbOffset,
                " %02x",
                pb[i]);
            cbOffset += 3;
        } 
        for (i = cb; i < CROW; i++)
        {
            strcat(rgsz, "   "); 
        }

        strcat(rgsz, "    '");
        cbOffset = (ULONG) strlen(rgsz);

        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                sprintf(
                    rgsz + cbOffset,
                    "%c",
                    pb[i]);
            else
                sprintf(
                    rgsz + cbOffset,
                    ".",
                    pb[i]);

            cbOffset++;
        }

        strcat(rgsz, "\n");
        pb += cb;
    }

    if (fTruncated)
        DebugLog((
            DEB_TRACE_TRANSMIT, 
            "(truncated)\n%s",
            rgsz));
    else
        DebugLog((
            DEB_TRACE_TRANSMIT, 
            "\n%s",
            rgsz));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\compress\compress.c ===
#include <windows.h>
#include "compress.h"
#include <zlib.h>
#include <limits.h>

#define CURRENT_COMPRESSED_DATA_VERSION 1

typedef struct _COMPRESSED_DATA_HEADER
{
    BYTE bVersion;
    UNALIGNED WORD wLength;
} COMPRESSED_DATA_HEADER, *PCOMPRESSED_DATA_HEADER;

//
// Return value is the maximum length in bytes of the compressed data.  The
// input is the length in bytes of the uncompressed data.
//
DWORD GetCompressedDataLength(
    IN  DWORD cbUncompressed)
{
    //
    // Length computation:
    //  zlib requires input length plus .01%, plus 12 bytes
    //  Add one additional byte for loss of precision in above computation
    //  Add length of data header
    //
    return (13 + sizeof(COMPRESSED_DATA_HEADER) + 
        (DWORD) ((float) cbUncompressed * (float) 1.001));
}

//
// Compresses the input data using zlib, optimizing for compression ratio at 
// the expense of speed.  If pbOut is NULL, pcbOut will be set to the maximum
// length required to store the compressed data.
//
DWORD
WINAPI
CompressData(
    IN  DWORD   cbIn,
    IN  PBYTE   pbIn,
    OUT PDWORD  pcbOut,
    OUT PBYTE   pbOut)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbOut = GetCompressedDataLength(cbIn);
    PCOMPRESSED_DATA_HEADER pHeader = NULL;

    if (NULL == pbOut)
    {
        *pcbOut = cbOut;
        goto Ret;
    }

    if (*pcbOut < cbOut)
    {
        *pcbOut = cbOut;
        dwSts = ERROR_MORE_DATA;
        goto Ret;
    }

    if (USHRT_MAX < cbIn)
    {
        dwSts = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    if (Z_OK != compress2(
        pbOut + sizeof(COMPRESSED_DATA_HEADER),
        &cbOut,
        pbIn,
        cbIn,
        Z_BEST_COMPRESSION))
    {
        dwSts = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    pHeader = (PCOMPRESSED_DATA_HEADER) pbOut;
    pHeader->bVersion = CURRENT_COMPRESSED_DATA_VERSION;
    pHeader->wLength = (WORD) cbIn;

    *pcbOut = cbOut + sizeof(COMPRESSED_DATA_HEADER);

Ret:

    return dwSts;
}

//
// Uncompresses the data using zlib.  If pbOut is NULL, pcbOut is set to the
// exact length of the uncompressed data - this will equal the cbIn value
// originally passed to CompressData, above.
//
DWORD
WINAPI
UncompressData(
    IN  DWORD   cbIn,
    IN  PBYTE   pbIn,
    OUT PDWORD  pcbOut,
    OUT PBYTE   pbOut)
{
    DWORD dwSts = ERROR_SUCCESS;
    PCOMPRESSED_DATA_HEADER pHeader = NULL;

    pHeader = (PCOMPRESSED_DATA_HEADER) pbIn;

    if (NULL == pbOut)
    {
        *pcbOut = pHeader->wLength;
        goto Ret;
    }

    if (*pcbOut < pHeader->wLength)
    {
        *pcbOut = pHeader->wLength;
        dwSts = ERROR_MORE_DATA;
        goto Ret;
    }

    *pcbOut = pHeader->wLength;

    if (Z_OK != uncompress(
        pbOut,
        pcbOut,
        pbIn + sizeof(COMPRESSED_DATA_HEADER),
        cbIn - sizeof(COMPRESSED_DATA_HEADER)))
    {
        dwSts = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    if (pHeader->wLength != *pcbOut)
        dwSts = ERROR_INTERNAL_ERROR;

Ret:

    return dwSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\carddbg.h ===
#ifndef __CARDMOD__DEBUG__H
#define __CARDMOD__DEBUG__H

#include <windows.h>
#include <dsysdbg.h>

// 
// Debug Support
//
// This uses the debug routines from dsysdbg.h
// Debug output will only be available in chk
// bits.
//

DECLARE_DEBUG2(Cardmod)

#define DEB_ERROR                       0x00000001
#define DEB_WARN                        0x00000002
#define DEB_TRACE                       0x00000004
#define DEB_TRACE_FUNC                  0x00000008
#define DEB_TRACE_MEM                   0x00000010
#define DEB_TRACE_TRANSMIT              0x00000020
#define DEB_TRACE_PROXY                 0x00000040

extern DEBUG_KEY  MyDebugKeys[];

extern void I_DebugPrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize);

#if DBG
#define DebugLog(x)                     CardmodDebugPrint x
#define DebugPrintBytes(x, y, z)        (I_DebugPrintBytes(x, y, z))
#else
#define DebugLog(x)
#define DebugPrintBytes(x, y, z)
#endif

#define LOG_BEGIN_PROXY(x)                                           \
    { DebugLog((DEB_TRACE_PROXY, "%s\n", #x)); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\datacach\datacach.c ===
#include <windows.h>
#include <md5.h>
#include "datacach.h"

#define CACHE_TABLE_SIZE            MD5DIGESTLEN
#define CACHE_KEY_HASH_SIZE         MD5DIGESTLEN
#define CACHE_TABLE_LOOKUP_MASK     0x0F

typedef struct _CACHE_TABLE_ENTRY
{
    DATA_BLOB dbData;
    struct _CACHE_TABLE_ENTRY *pNext;
    BYTE rgbKeyHash[CACHE_KEY_HASH_SIZE];
} CACHE_TABLE_ENTRY, *PCACHE_TABLE_ENTRY;

typedef struct _CACHE_TABLE_HEAD
{
    PCACHE_TABLE_ENTRY Table[CACHE_TABLE_SIZE];
    DWORD cItems;
    CACHE_INITIALIZE_INFO InitInfo;
} CACHE_TABLE_HEAD, *PCACHE_TABLE_HEAD;

typedef CACHE_TABLE_HEAD CACHE_TABLE, *PCACHE_TABLE;

void I_CacheHashKeys(
    IN PDATA_BLOB mpdbKeys,
    IN DWORD cKeys,
    OUT BYTE rgHash[])
{
    MD5_CTX md5Ctx;

    MD5Init(&md5Ctx);

    while (cKeys--)
    {
        MD5Update(
            &md5Ctx,
            mpdbKeys[cKeys].pbData,
            mpdbKeys[cKeys].cbData);
    }

    MD5Final(&md5Ctx);
    
    memcpy(rgHash, md5Ctx.digest, MD5DIGESTLEN);
}

PVOID I_CacheAlloc(SIZE_T size)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

void I_CacheFreeMemory(
    PVOID pvMem)
{
    HeapFree(GetProcessHeap(), 0, pvMem);
}

DWORD CacheGetItem(
    IN CACHEHANDLE hCache,
    IN PDATA_BLOB mpdbKeys,
    IN DWORD cKeys,
    OUT PDATA_BLOB pdbItem)
{
    PCACHE_TABLE pCacheTable = (PCACHE_TABLE) hCache;
    BYTE rgbKeyHash[CACHE_KEY_HASH_SIZE];
    int index = 0;
    PCACHE_TABLE_ENTRY pEntry = NULL;

    I_CacheHashKeys(mpdbKeys, cKeys, rgbKeyHash);

    index = rgbKeyHash[0] & CACHE_TABLE_LOOKUP_MASK;

    if (NULL != pCacheTable->Table[index])
    {
        for (
            pEntry = pCacheTable->Table[index];
            NULL != pEntry && 0 != memcmp(pEntry->rgbKeyHash, 
                                          rgbKeyHash, sizeof(rgbKeyHash));
            pEntry = pEntry->pNext) { ; }

        if (NULL != pEntry)
        {
            // Found the item.  Return it.
            pdbItem->cbData = pEntry->dbData.cbData;
            pdbItem->pbData = pEntry->dbData.pbData;

            return ERROR_SUCCESS;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD CacheAddItem(
    IN CACHEHANDLE hCache,
    IN PDATA_BLOB mpdbKeys,
    IN DWORD cKeys,
    IN PDATA_BLOB pdbItem)
{
    PCACHE_TABLE pCacheTable = (PCACHE_TABLE) hCache;
    BYTE rgbKeyHash[CACHE_KEY_HASH_SIZE];
    int index = 0;
    PCACHE_TABLE_ENTRY pEntry = NULL;

    pEntry = (PCACHE_TABLE_ENTRY) I_CacheAlloc(sizeof(CACHE_TABLE_ENTRY));

    if (NULL == pEntry)
        return ERROR_NOT_ENOUGH_MEMORY;

    pEntry->dbData.cbData = pdbItem->cbData;
    pEntry->dbData.pbData = pdbItem->pbData;
        
    I_CacheHashKeys(mpdbKeys, cKeys, rgbKeyHash);

    memcpy(
        pEntry->rgbKeyHash,
        rgbKeyHash,
        sizeof(rgbKeyHash));

    index = rgbKeyHash[0] & CACHE_TABLE_LOOKUP_MASK;

    if (NULL != pCacheTable->Table[index])
        pEntry->pNext = pCacheTable->Table[index];

    pCacheTable->Table[index] = pEntry;
    ++pCacheTable->cItems;

    return ERROR_SUCCESS;
}

DWORD CacheDeleteItem(
    IN CACHEHANDLE hCache,
    IN PDATA_BLOB mpdbKeys,
    IN DWORD cKeys)
{
    PCACHE_TABLE pCacheTable = (PCACHE_TABLE) hCache;
    BYTE rgbKeyHash[CACHE_KEY_HASH_SIZE];
    int index = 0;
    PCACHE_TABLE_ENTRY pEntry1 = NULL, pEntry2 = NULL;

    I_CacheHashKeys(mpdbKeys, cKeys, rgbKeyHash);

    index = rgbKeyHash[0] & CACHE_TABLE_LOOKUP_MASK;

    if (NULL != pCacheTable->Table[index])
    {
        pEntry1 = pCacheTable->Table[index];

        while ( NULL != pEntry1 &&
                0 != memcmp(pEntry1->rgbKeyHash, 
                            rgbKeyHash, sizeof(rgbKeyHash)))
        {
            pEntry2 = pEntry1;
            pEntry1 = pEntry2->pNext;
        }

        if (NULL != pEntry1)
        {
            // Found the item.  Delete it.

            // Was this the first/only item in the list?
            if (NULL == pEntry2)
                pCacheTable->Table[index] = pEntry1->pNext;
            else
                // Not first or only item.
                pEntry2->pNext = pEntry1->pNext;

            I_CacheFreeMemory(pEntry1);
            --pCacheTable->cItems;

            return ERROR_SUCCESS;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD CacheInitializeCache(
    IN CACHEHANDLE *phCache,
    IN PCACHE_INITIALIZE_INFO pCacheInitializeInfo)
{
    PCACHE_TABLE pCacheTable = NULL;

    pCacheTable = (PCACHE_TABLE) I_CacheAlloc(sizeof(CACHE_TABLE));

    if (NULL == pCacheTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(
        &pCacheTable->InitInfo,
        pCacheInitializeInfo,
        sizeof(CACHE_INITIALIZE_INFO));

    *phCache = (CACHEHANDLE) pCacheTable;

    return ERROR_SUCCESS;
}

DWORD CacheDeleteCache(
    IN CACHEHANDLE hCache)
{
    PCACHE_TABLE pCacheTable = (PCACHE_TABLE) hCache;
    PCACHE_TABLE_ENTRY pEntry1 = NULL, pEntry2 = NULL;
    int iTable;

    for (iTable = 0; iTable < CACHE_TABLE_SIZE; iTable++)
    {                          
        if (NULL != pCacheTable->Table[iTable])
        {
            pEntry1 = pCacheTable->Table[iTable];

            while (pEntry1)
            {
                pEntry2 = pEntry1->pNext;
                I_CacheFreeMemory(pEntry1);
                pEntry1 = pEntry2;
            }
        }
    }

    return ERROR_SUCCESS;
}


DWORD CacheFreeEnumItems(
    IN PDATA_BLOB pdbItems)
{
    I_CacheFreeMemory(pdbItems);
    
    return ERROR_SUCCESS;
}

DWORD CacheEnumItems(
    IN CACHEHANDLE hCache,
    OUT PDATA_BLOB *ppdbItems,
    OUT PDWORD pcItems)
{
    PCACHE_TABLE pCacheTable = (PCACHE_TABLE) hCache;
    PCACHE_TABLE_ENTRY pEntry = NULL;
    DWORD cItems = 0;
    PDATA_BLOB pdb = NULL;
    int iTable = 0;

    *ppdbItems = NULL;
    *pcItems = 0;

    cItems = pCacheTable->cItems;

    if (0 == cItems)
        return ERROR_SUCCESS;

    pdb = (PDATA_BLOB) I_CacheAlloc(cItems * sizeof(DATA_BLOB));

    if (NULL == pdb)
        return ERROR_NOT_ENOUGH_MEMORY;

    for (iTable = 0; iTable < CACHE_TABLE_SIZE; iTable++)
    {
        pEntry = pCacheTable->Table[iTable];

        while (NULL != pEntry)
        {
            memcpy(
                &(pdb[cItems - 1]),
                &pEntry->dbData,
                sizeof(DATA_BLOB));
            
            cItems--;
            pEntry = pEntry->pNext;
        }
    }

    *pcItems = pCacheTable->cItems;
    *ppdbItems = pdb;

    return ERROR_SUCCESS;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\cardmod\filename.c ===
#pragma warning(push)
#pragma warning(disable:4201) 
// Disable error C4201 in public header 
//  nonstandard extension used : nameless struct/union
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "cardmod.h"
#pragma warning(pop)


DWORD WINAPI I_CardConvertFileNameToAnsi(
    IN PCARD_DATA pCardData,
    IN LPWSTR wszUnicodeName,
    OUT LPSTR *ppszAnsiName)
{
    DWORD dwError = 0;
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;

    memset(&Unicode, 0, sizeof(Unicode));
    memset(&Ansi, 0, sizeof(Ansi));

    RtlInitUnicodeString(
        &Unicode, 
        wszUnicodeName);

    dwError = RtlUnicodeStringToAnsiString(
        &Ansi,
        &Unicode,
        TRUE);

    if (STATUS_SUCCESS != dwError)
    {
        dwError = RtlNtStatusToDosError(dwError);
        goto Ret;
    }

    *ppszAnsiName = (LPSTR) pCardData->pfnCspAlloc(
        (strlen(Ansi.Buffer) + 1) * sizeof(CHAR));

    if (NULL == *ppszAnsiName)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    strcpy(*ppszAnsiName, Ansi.Buffer);

Ret:

    if (Ansi.Buffer)
        RtlFreeAnsiString(&Ansi);

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\compress.h ===
#ifndef _BASECSP_COMPRESS_H_
#define _BASECSP_COMPRESS_H_ 

#include <windows.h>

DWORD
WINAPI
CompressData(
    IN  DWORD   cbIn,
    IN  PBYTE   pbIn,
    OUT PDWORD  pcbOut,
    OUT PBYTE   pbOut);

DWORD
WINAPI
UncompressData(
    IN  DWORD   cbIn,
    IN  PBYTE   pbIn,
    OUT PDWORD  pcbOut,
    OUT PBYTE   pbOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\basecsp.h ===
#ifndef __BASECSP_CAPI__H__
#define __BASECSP_CAPI__H__

#include <windows.h>
#include "cardmod.h"
#include "datacach.h"
#include "csplib.h"
#include "sccache.h"
#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Maximum length card ATR that we'll handle in the Base CSP
//
#define cbATR_BUFFER                            32

//
// Maximum length pin that we'll handle
//
#define cchMAX_PIN_LENGTH                       8

//
// Registry Information
//

#define wszREG_DEFAULT_KEY_LEN                  L"DefaultPrivateKeyLenBits"
#define wszREG_REQUIRE_CARD_KEY_GEN             L"RequireOnCardPrivateKeyGen"

typedef struct _REG_CONFIG_VALUES
{
    LPWSTR wszValueName;
    DWORD dwDefValue;
} REG_CONFIG_VALUES, *PREG_CONFIG_VALUES;

static REG_CONFIG_VALUES RegConfigValues [] = 
{
    { wszREG_DEFAULT_KEY_LEN,           1024 },
    { wszREG_REQUIRE_CARD_KEY_GEN,      0 }
};

typedef struct _CSP_REG_SETTINGS
{
    DWORD cDefaultPrivateKeyLenBits;
    BOOL fRequireOnCardPrivateKeyGen;
} CSP_REG_SETTINGS, *PCSP_REG_SETTINGS;

DWORD WINAPI RegConfigAddEntries(
    IN HKEY hKey);

DWORD WINAPI RegConfigGetSettings(
    IN OUT PCSP_REG_SETTINGS pRegSettings);

//
// General Wrappers
//

DWORD CountCharsInMultiSz(
    IN LPWSTR mwszStrings);

// Display Strings
typedef struct _CSP_STRING
{
    LPWSTR wszString;
    DWORD dwResource;
} CSP_STRING, *PCSP_STRING;

enum CSP_STRINGS_INDEX
{
    StringNewPinMismatch,
    StringPinMessageBoxTitle,
    StringWrongPin,
    StringPinRetries
};

typedef struct _CSP_STATE
{
    CRITICAL_SECTION cs;
    DWORD dwRefCount;
    CACHEHANDLE hCache;
    HMODULE hCspModule;
} CSP_STATE, *PCSP_STATE;

//
// Type: CONTAINER_MAP_RECORD
//
// This structure describes the format of the Base CSP's container map file,
// stored on the card.  This is well-known logical file wszCONTAINER_MAP_FILE.
// The file consists of zero or more of these records.
//
#define MAX_CONTAINER_NAME_LEN                  40

// This flag is set in the CONTAINER_MAP_RECORD bFlags member if the 
// corresponding container is valid and currently exists on the card.
// If the container is deleted, its bFlags field must be cleared.
#define CONTAINER_MAP_VALID_CONTAINER           1

// This flag is set in the CONTAINER_MAP_RECORD bFlags
// member if the corresponding container is the default container on the card.
#define CONTAINER_MAP_DEFAULT_CONTAINER         2

typedef struct _CONTAINER_MAP_RECORD
{
    WCHAR wszGuid [MAX_CONTAINER_NAME_LEN];
    BYTE bFlags;        
    WORD wSigKeySizeBits;
    WORD wKeyExchangeKeySizeBits;
} CONTAINER_MAP_RECORD, *PCONTAINER_MAP_RECORD;

// 
// Type: CARD_CACHE_FILE_FORMAT
//
// This struct is used as the file format of the cache file,
// as stored on the card.
//

#define CARD_CACHE_FILE_CURRENT_VERSION         1

typedef struct _CARD_CACHE_FILE_FORMAT
{
    BYTE bVersion;
    BYTE bPinsFreshness;

    WORD wContainersFreshness;
    WORD wFilesFreshness;
} CARD_CACHE_FILE_FORMAT, *PCARD_CACHE_FILE_FORMAT;

//
// Type: CARD_STATE
//
#define CARD_STATE_CURRENT_VERSION 1

typedef struct _CARD_STATE
{
    DWORD dwVersion;
    PCARD_DATA pCardData;
    HMODULE hCardModule;
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext;
    WCHAR wszSerialNumber[MAX_PATH];
    
    PINCACHE_HANDLE hPinCache;

    // This flag is set every time the pin is successfully presented
    // to the card.  If the flag is set when EndTransaction is called on the
    // card, the card will be deauthenticated (or Reset) and the flag cleared.
    // Otherwise, EndTransaction will simply leave the card.
    BOOL fAuthenticated;

    // A copy of the card cache file is kept in the CARD_STATE.  The cache 
    // file need only be read from the card once per transaction, although
    // it must also be updated on card writes.
    CARD_CACHE_FILE_FORMAT CacheFile;
    BOOL fCacheFileValid;

    CRITICAL_SECTION cs;
    BOOL fInitializedCS;
    
    CACHEHANDLE hCache;
    CACHEHANDLE hCacheCardModuleData;
    PFN_SCARD_CACHE_LOOKUP_ITEM pfnCacheLookup;
    PFN_SCARD_CACHE_ADD_ITEM pfnCacheAdd;
    HMODULE hWinscard;

} CARD_STATE, *PCARD_STATE;

//
// Type: CARD_MATCH_DATA
// 

#define CARD_MATCH_TYPE_READER_AND_CONTAINER            1
#define CARD_MATCH_TYPE_SERIAL_NUMBER                   2

typedef struct _CARD_MATCH_DATA
{
    //
    // Input parameters.
    //
    PCSP_STATE pCspState;
    DWORD dwCtxFlags;
    DWORD dwMatchType;
    DWORD dwUIFlags;
    
    DWORD cchMatchedReader;
    DWORD cchMatchedCard;
    DWORD cchMatchedSerialNumber;
    DWORD dwShareMode;
    DWORD dwPreferredProtocols;

    // Used in Reader and Container match requests
    LPWSTR pwszReaderName;
    LPWSTR pwszContainerName;
    BOOL fFreeContainerName;

    // Used in Serial Number match requests
    LPWSTR pwszSerialNumber;

    //
    // Internal parameters
    //
    PCARD_STATE pCardState;

    // Will be set when the current thread holds the transaction on the matched
    // card.  This allows us to reduce the number of transactions required to 
    // find a matching card (and complete the CryptAcquireContext call), 
    // which reduces the number of times we have to read the cache file.
    //
    // The transaction will always be released before the select card check
    // callback returns.
    BOOL fTransacted;
    
    // 
    // Output parameters
    //

    // Result of successful Card Search is
    // a valid, matching CARD_STATE structure.
    SCARDCONTEXT hSCardCtx;
    SCARDHANDLE hSCard;
    BYTE bContainerIndex;
    PCARD_STATE pUIMatchedCardState;

    WCHAR wszMatchedReader[MAX_PATH];
    WCHAR wszMatchedCard[MAX_PATH];
    DWORD dwActiveProtocol;

    // Result of an unsuccessful Card Search is that this
    // should be set to an appropriate error code.
    DWORD dwError;

} CARD_MATCH_DATA, *PCARD_MATCH_DATA;

DWORD FindCard(
    IN OUT  PCARD_MATCH_DATA pCardMatchData);

// 
// Defines for Card Specific Modules
//

// This value should be passed to 
//
//  SCardSetCardTypeProviderName
//  SCardGetCardTypeProviderName
//
// in order to query and set the Card Specific Module to be used
// for a given card.
#define SCARD_PROVIDER_CARD_MODULE 0x80000001

//
// Defines for Card Interface Layer operations
//


// 
// Function: InitializeCardState
//
DWORD InitializeCardState(PCARD_STATE pCardState);

// 
// Function: DeleteCardState
//
void DeleteCardState(PCARD_STATE pCardState);

// 
// Function: InitializeCardData
//
DWORD InitializeCardData(PCARD_DATA pCardData);

//
// Function: IntializeCspCaching
//
DWORD InitializeCspCaching(IN OUT PCARD_STATE pCardState);

//
// Function: CleanupCardData
//
void CleanupCardData(PCARD_DATA pCardData);

//
// Function: ValidateReconnectCardHandle
//
DWORD ValidateCardHandle(
    IN PCARD_STATE pCardState,
    IN BOOL fMayReleaseContextHandle,
    OUT OPTIONAL BOOL *pfFlushPinCache);

//
// Function: CspBeginTransaction
//
DWORD CspBeginTransaction(
    IN PCARD_STATE pCardState);

//
// Function: CspEndTransaction
//
DWORD CspEndTransaction(
    IN PCARD_STATE pCardState);

// 
// Function: CspQueryCapabilities
//
DWORD
WINAPI
CspQueryCapabilities(
    IN      PCARD_STATE         pCardState,
    IN OUT  PCARD_CAPABILITIES  pCardCapabilities);

//
// Function: CspDeleteContainer
//
DWORD
WINAPI
CspDeleteContainer(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwReserved);

//
// Function: CspCreateContainer
//
DWORD
WINAPI
CspCreateContainer(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwKeySize,
    IN      PBYTE       pbKeyData);

//
// Function: CspGetContainerInfo
//
DWORD
WINAPI
CspGetContainerInfo(
    IN      PCARD_STATE pCardState,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN OUT  PCONTAINER_INFO pContainerInfo);

//
// Function: CspRemoveCachedPin
//
void
WINAPI
CspRemoveCachedPin(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId);

//
// Function: CspChangeAuthenticator
//
DWORD
WINAPI
CspChangeAuthenticator(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbCurrentAuthenticator,
    IN      DWORD       cbCurrentAuthenticator,
    IN      PBYTE       pbNewAuthenticator,
    IN      DWORD       cbNewAuthenticator,
    IN      DWORD       cRetryCount,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

// 
// Function: CspSubmitPin
//
DWORD
WINAPI
CspSubmitPin(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszUserId,
    IN      PBYTE       pbPin,
    IN      DWORD       cbPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

//
// Function: CspCreateFile
//
DWORD
WINAPI
CspCreateFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition);

//
// Function: CspReadFile
//
DWORD 
WINAPI
CspReadFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    OUT     PBYTE       *ppbData,
    OUT     PDWORD      pcbData);

//
// Function: CspWriteFile
//
DWORD
WINAPI
CspWriteFile(
    IN      PCARD_STATE pCardState,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData);

//
// Function: CspDeleteFile
//
DWORD
WINAPI
CspDeleteFile(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwReserved,
    IN      LPWSTR      pwszFileName);

//
// Function: CspEnumFiles
//
DWORD
WINAPI
CspEnumFiles(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwFlags,
    IN OUT  LPWSTR      *pmwszFileName);

//
// Function: CspQueryFreeSpace
//                                         
DWORD
WINAPI
CspQueryFreeSpace(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwFlags,
    OUT     PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo);

//
// Function: CspPrivateKeyDecrypt
//
DWORD
WINAPI
CspPrivateKeyDecrypt(
    IN      PCARD_STATE                     pCardState,
    IN      PCARD_PRIVATE_KEY_DECRYPT_INFO  pInfo);

//
// Function: CspQueryKeySizes
//
DWORD
WINAPI
CspQueryKeySizes(
    IN      PCARD_STATE pCardState,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwReserved,
    OUT     PCARD_KEY_SIZES pKeySizes);

//
// Container Map Functions
//

DWORD ContainerMapEnumContainers(
    IN              PCARD_STATE pCardState,
    OUT             PBYTE pcContainers,
    OUT OPTIONAL    LPWSTR *mwszContainers);

DWORD ContainerMapFindContainer(
    IN              PCARD_STATE pCardState,
    IN OUT          PCONTAINER_MAP_RECORD pContainer,
    OUT OPTIONAL    PBYTE pbContainerIndex);

DWORD ContainerMapGetDefaultContainer(
    IN              PCARD_STATE pCardState,
    OUT             PCONTAINER_MAP_RECORD pContainer,
    OUT OPTIONAL    PBYTE pbContainerIndex);

DWORD ContainerMapSetDefaultContainer(
    IN              PCARD_STATE pCardState,
    IN              LPWSTR pwszContainerGuid);

DWORD ContainerMapAddContainer(
    IN              PCARD_STATE pCardState,
    IN              LPWSTR pwszContainerGuid,
    IN              DWORD cKeySizeBits,
    IN              DWORD dwKeySpec,
    IN              BOOL fGetNameOnly,
    OUT             PBYTE pbContainerIndex);

DWORD ContainerMapDeleteContainer(
    IN              PCARD_STATE pCardState,
    IN              LPWSTR pwszContainerGuid,
    OUT             PBYTE pbContainerIndex);

//
// UI Functions
//

typedef struct _CSP_PROMPT_FOR_PIN_INFO
{
    IN LPWSTR wszUser;
    OUT LPWSTR wszPin;
} CSP_PROMPT_FOR_PIN_INFO, *PCSP_PROMPT_FOR_PIN_INFO;

DWORD
WINAPI
CspPromptForPin(
    IN OUT  PCSP_PROMPT_FOR_PIN_INFO pInfo);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\csplib\csplib.c ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    csplib.c

    General Cryptographic Service Provider Library

Abstract:


Author:

    Dan Griffin

Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <psapi.h>
#include <rpc.h>
#include <wincrypt.h>
#include <dsysdbg.h>
#include <stdio.h>
#include "csplib.h"

//
// This global must be provided by the "Local" CSP using this library.
//
extern  LOCAL_CSP_INFO      LocalCspInfo; 

#define PROVPATH            L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"

//
// DllInitialize stores the image path in here during process attach.
//
CHAR                        l_szImagePath[MAX_PATH];

// 
// Debug Support
//
// This uses the debug routines from dsysdbg.h
// Debug output will only be available in chk
// bits.
//
DEFINE_DEBUG2(Csplib)

#if DBG
#define DebugLog(x) CsplibDebugPrint x
#else
#define DebugLog(x)
#endif

#define DEB_ERROR      0x00000001
#define DEB_WARN       0x00000002
#define DEB_TRACE      0x00000004
#define DEB_TRACE_FUNC 0x00000080
#define DEB_TRACE_MEM  0x00000100
#define TRACE_STUFF    0x00000200

static DEBUG_KEY  MyDebugKeys[] = 
{   
    {DEB_ERROR, "Error"},
    {DEB_WARN, "Warning"},
    {DEB_TRACE, "Trace"},
    {DEB_TRACE_FUNC, "TraceFuncs"},
    {DEB_TRACE_MEM, "TraceMem"},
    {0, NULL}
};

#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_FUNC, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_FUNC, "%s: Leaving, status: 0x%x\n", #x, y)); }
    
#define LOG_CHECK_ALLOC(x)                                              \
    { if (NULL == x) {                                                  \
        dwSts = ERROR_NOT_ENOUGH_MEMORY;                                \
        DebugLog((DEB_TRACE_MEM, "%s: Allocation failed\n", #x));       \
        goto Ret;                                                       \
    } }

//
// Function: ApplyPKCS1SigningFormat
//
// Purpose: Format a buffer with PKCS 1 for signing
//
// Notes:
//  If the padding and formatting is successful, the *ppbPKCS1Format parameter
//  will be allocated by this routine and must be freed by the caller.
//
DWORD WINAPI ApplyPKCS1SigningFormat(
    IN  ALG_ID HashAlgid,
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  DWORD dwFlags,
    IN  DWORD cbModulus,
    OUT PBYTE *ppbPKCS1Format)
{
    DWORD   dwSts = ERROR_SUCCESS;
    BYTE    *pbStart = NULL;
    BYTE    *pbEnd = NULL;
    BYTE    bTmp = 0;
    DWORD   i = 0;
    DWORD   cbAvailableData = cbModulus; // pPubKey->datalen;

    *ppbPKCS1Format = NULL;

    //
    // We know we need at least 3 bytes of padding space.
    //
    // Note, the final (third) byte of padding is the zeroed-byte at
    // location pbPKCS1Format[cbModulus - 1].
    //
    cbAvailableData -= 3;

    // In a few scenarios (involving small RSA keys), the new large SHA 
    // hashes are too big to be signed by the specified key.
    if (cbHash > cbAvailableData)
    {
        dwSts = (DWORD) NTE_BAD_LEN;
        goto Ret;
    }

    *ppbPKCS1Format = (PBYTE) CspAllocH(cbModulus);

    LOG_CHECK_ALLOC(*ppbPKCS1Format);
    
    // insert the block type
    (*ppbPKCS1Format)[cbModulus - 2] = 0x01; // Padding byte #1

    // insert the type I padding
    memset(*ppbPKCS1Format, 0xff, cbModulus - 2);

    // Reverse it
    for (i = 0; i < cbHash; i++)
        (*ppbPKCS1Format)[i] = pbHash[cbHash - (i + 1)];

    cbAvailableData -= cbHash;

    if ( 0 == (CRYPT_NOHASHOID & dwFlags))
    {
        switch (HashAlgid)
        {
        case CALG_MD2:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md2Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; 
            break;

        case CALG_MD4:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md4Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0;
            break;

        case CALG_MD5:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md5Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; 
            break;

        case CALG_SHA:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)shaEncodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; 
            break;

        case CALG_SSL3_SHAMD5:
            // No PKCS padding
            pbStart = *ppbPKCS1Format + cbHash;
            *pbStart++ = 0;
            break;

        case CALG_SHA_256:
            pbEnd = (LPBYTE) sha256Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;

            if (bTmp > cbAvailableData)
            {
                dwSts = (DWORD) NTE_BAD_LEN;
                goto Ret;
            }

            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; // Padding byte #2
            break;

        case CALG_SHA_384:
            pbEnd = (LPBYTE) sha384Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;

            if (bTmp > cbAvailableData)
            {
                dwSts = (DWORD) NTE_BAD_LEN;
                goto Ret;
            }

            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; // Padding byte #2
            break;

        case CALG_SHA_512:
            pbEnd = (LPBYTE) sha512Encodings[0];
            pbStart = *ppbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            
            if (bTmp > cbAvailableData)
            {
                dwSts = (DWORD) NTE_BAD_LEN;
                goto Ret;
            }

            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0; // Padding byte #2
            break;

        default:
            dwSts = (DWORD)NTE_BAD_ALGID;
            goto Ret;
        }
    }
    else
    {
        (*ppbPKCS1Format)[cbHash] = 0x00; 
    }

Ret:
    if (ERROR_SUCCESS != dwSts &&
        NULL != *ppbPKCS1Format)
    {
        CspFreeH(*ppbPKCS1Format);
        *ppbPKCS1Format = NULL;
    }

    return dwSts;
}

//
// Function: VerifyPKCS2Padding
//
DWORD WINAPI VerifyPKCS2Padding(
    IN  PBYTE pbPaddedData,
    IN  DWORD cbModulus,
    OUT PBYTE *ppbData,
    OUT PDWORD pcbData)
{
    DWORD dwSts = ERROR_SUCCESS;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    DWORD z = 0;
    
    *ppbData = NULL;
    *pcbData = 0;

    if ((pbPaddedData[cbModulus - 2] != PKCS_BLOCKTYPE_2) ||
        (pbPaddedData[cbModulus - 1] != 0))
    {
        dwSts = NTE_BAD_DATA;
        goto Ret;
    }

    cbData = cbModulus - 3;

    while ((cbData > 0) && (pbPaddedData[cbData]))
        cbData--;

    pbData = (PBYTE) CspAllocH(cbData);

    LOG_CHECK_ALLOC(pbData);

    // Reverse the session key bytes
    for (z = 0; z < cbData; ++z)
        pbData[z] = pbPaddedData[cbData - z - 1];

    *ppbData = pbData;
    pbData = NULL;
    *pcbData = cbData;

Ret:
    if (pbData)
        CspFreeH(pbData);

    return dwSts;
}

//
// Function: GetLocalCspInfo
//
PLOCAL_CSP_INFO GetLocalCspInfo(void)
{
    return &LocalCspInfo;
}

//
// Function: InitializeLocalCallInfo
//
DWORD InitializeLocalCallInfo(
    IN PLOCAL_CALL_INFO pLocalCallInfo)
{
    *pLocalCallInfo = FALSE;

    return ERROR_SUCCESS;
}

//
// Function: SetLocalCallInfo
//
// Purpose: The local CSP uses this function to indicate to functions in
//          this library whether execution of a given API should continue
//          after the local CSP has returned.
//
void SetLocalCallInfo(
    IN OUT  PLOCAL_CALL_INFO    pLocalCallInfo,
    IN      BOOL                fContinue)
{
    *pLocalCallInfo = fContinue;
}

//
// Function: CheckLocalCallInfo
//
BOOL CheckLocalCallInfo(
    IN      PLOCAL_CALL_INFO pLocalCallInfo,
    IN      DWORD dwSts,
    OUT     BOOL *pfSuccess)
{
    if (FALSE == *pLocalCallInfo)
        *pfSuccess = (ERROR_SUCCESS == dwSts);

    return *pLocalCallInfo;
}

//
// Memory Management
//

//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes)
{
    return HeapReAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, cBytes);
}

//
// Critical Section Management
//

//
// Function: CspInitializeCriticalSection
//
DWORD CspInitializeCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    __try {
        InitializeCriticalSection(pcs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}

//
// Function: CspEnterCriticalSection
//
DWORD CspEnterCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    __try {
        EnterCriticalSection(pcs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}   

//
// Function: CspLeaveCriticalSection
//
void CspLeaveCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    LeaveCriticalSection(pcs);
}

//
// Function: CspDeleteCriticalSection
//
void CspDeleteCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    DeleteCriticalSection(pcs);
}

//
// Registration Helpers
//

//
// Function: RegOpenProviderKey
//
DWORD WINAPI RegOpenProviderKey(
    IN OUT  HKEY *phProviderKey,
    IN      REGSAM samDesired)
{
    DWORD cbProv = 0;
    LPWSTR wszProv = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD dwIgn = 0;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *phProviderKey = 0;

    cbProv = (wcslen(PROVPATH) + 
              wcslen(pLocalCspInfo->wszProviderName) + 1) * sizeof(WCHAR);
    
    wszProv = (LPWSTR) CspAllocH(cbProv);
    
    if (NULL == wszProv)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    swprintf(
        wszProv,
        L"%s%s",
        PROVPATH,
        pLocalCspInfo->wszProviderName);
    
    //
    // Create or open in local machine for provider
    //
    dwSts = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                           wszProv,
                           0L, L"", REG_OPTION_NON_VOLATILE,
                           samDesired, NULL, phProviderKey,
                           &dwIgn);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

Ret:
    if (wszProv)
        CspFreeH(wszProv);
    if (ERROR_SUCCESS != dwSts && 0 != *phProviderKey)
        RegCloseKey(*phProviderKey);

    return dwSts;
}

//
// Function: CreateUuidContainerName
//
DWORD WINAPI CreateUuidContainerName(
    IN PUSER_CONTEXT pUserCtx)
{
    UUID Uuid;
    LPWSTR wszUuid = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    
    dwSts = (DWORD) UuidCreate(&Uuid);

    if (RPC_S_OK != dwSts)
        goto Ret;

    dwSts = (DWORD) UuidToStringW(&Uuid, &wszUuid);

    if (RPC_S_OK != dwSts)
        goto Ret;

    pUserCtx->wszBaseContainerName = wszUuid;
    pUserCtx->fBaseContainerNameIsRpcUuid = TRUE;
    wszUuid = NULL;

Ret:
    if (wszUuid)
        RpcStringFreeW(&wszUuid);

    return dwSts;
}        
    
//
// Function: DeleteUserContext
//
DWORD DeleteUserContext(
    IN PUSER_CONTEXT pUserContext)
{
    DWORD dwSts = ERROR_SUCCESS;

    if (pUserContext->pVTableW)
    {
        if (pUserContext->pVTableW->pbContextInfo)
        {
            CspFreeH(pUserContext->pVTableW->pbContextInfo);
            pUserContext->pVTableW = NULL;
        }

        if (pUserContext->pVTableW->pszProvName)
        {
            CspFreeH(pUserContext->pVTableW->pszProvName);
            pUserContext->pVTableW->pszProvName = NULL;
        }

        CspFreeH(pUserContext->pVTableW);
        pUserContext->pVTableW = NULL;
    }

    if (pUserContext->wszBaseContainerName)
    {
        if (pUserContext->fBaseContainerNameIsRpcUuid)
            RpcStringFreeW(&pUserContext->wszBaseContainerName);
        else
            CspFreeH(pUserContext->wszBaseContainerName);

        pUserContext->wszBaseContainerName = NULL;
    }

    if (pUserContext->wszContainerNameFromCaller)
    {
        CspFreeH(pUserContext->wszContainerNameFromCaller);
        pUserContext->wszContainerNameFromCaller = NULL;
    }

    if (pUserContext->wszUniqueContainerName)
    {
        CspFreeH(pUserContext->wszUniqueContainerName);
        pUserContext->wszUniqueContainerName = NULL;
    }

    if (pUserContext->hSupportProv)
    {
        if (! CryptReleaseContext(pUserContext->hSupportProv, 0))
            dwSts = GetLastError();

        pUserContext->hSupportProv = 0;
    }

    return dwSts;
}

//
// Function: DeleteKeyContext
//
DWORD DeleteKeyContext(
    IN PKEY_CONTEXT pKeyContext)
{
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    LOCAL_CALL_INFO LocalCallInfo;
    DWORD dwSts = ERROR_SUCCESS;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pKeyContext->hSupportKey)      
    {
        if (! CryptDestroyKey(pKeyContext->hSupportKey))
            dwSts = GetLastError();

        pKeyContext->hSupportKey = 0;
    }

    if (pKeyContext->pvLocalKeyContext)
    {
        if (pLocalCspInfo->pfnLocalDestroyKey)
        {
            pLocalCspInfo->pfnLocalDestroyKey(
                pKeyContext,
                &LocalCallInfo);

            pKeyContext->pvLocalKeyContext = NULL;
        }
    }

    return dwSts;
}

//
// Function: DeleteHashContext
//
DWORD DeleteHashContext(
    IN PHASH_CONTEXT pHashContext)
{
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    LOCAL_CALL_INFO LocalCallInfo;
    DWORD dwSts = ERROR_SUCCESS;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pHashContext->hSupportHash)
    {
        if (! CryptDestroyHash(pHashContext->hSupportHash))
            dwSts = GetLastError();

        pHashContext->hSupportHash = 0;
    }

    if (pHashContext->pvLocalHashContext)
    {
        if (pLocalCspInfo->pfnLocalDestroyHash)
        {
            pLocalCspInfo->pfnLocalDestroyHash(
                pHashContext,
                &LocalCallInfo);

            pHashContext->pvLocalHashContext = NULL;
        }
    }

    return dwSts;
}

/*
 -  CPAcquireContext
 -
 *  Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptographic service provider (CSP).
 *
 *
 *  Parameters:
 *               OUT phProv         -  Handle to a CSP
 *               IN  szContainer    -  Pointer to a string which is the
 *                                     identity of the logged on user
 *               IN  dwFlags        -  Flags values
 *               IN  pVTable        -  Pointer to table of function pointers
 *
 *  Returns:
 */

BOOL WINAPI
CPAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN  LPCSTR szContainer,
    IN  DWORD dwFlags,
    IN  PVTableProvStruc pVTable)
{
    ANSI_STRING AnsiContainer;
    UNICODE_STRING UnicodeContainer;
    ANSI_STRING AnsiProvName;
    UNICODE_STRING UnicodeProvName;
    BOOL fSuccess = FALSE;
    DWORD dwSts;
    DWORD dwError = NTE_FAIL;
    VTableProvStrucW VTableW;

    memset(&AnsiContainer, 0, sizeof(AnsiContainer));
    memset(&AnsiProvName, 0, sizeof(AnsiProvName));
    memset(&UnicodeContainer, 0, sizeof(UnicodeContainer));
    memset(&UnicodeProvName, 0, sizeof(UnicodeProvName));
    memset(&VTableW, 0, sizeof(VTableW));

    if (szContainer)
    {
        RtlInitAnsiString(&AnsiContainer, szContainer);
    
        dwSts = RtlAnsiStringToUnicodeString(
            &UnicodeContainer,
            &AnsiContainer,
            TRUE);
    
        if (STATUS_SUCCESS != dwSts)
        {
            dwError = RtlNtStatusToDosError(dwSts);
            goto Ret;
        }
    }

    VTableW.cbContextInfo = pVTable->cbContextInfo;
    VTableW.dwProvType = pVTable->dwProvType;
    VTableW.FuncReturnhWnd = pVTable->FuncReturnhWnd;
    VTableW.pbContextInfo = pVTable->pbContextInfo;
    VTableW.Version = pVTable->Version;

    RtlInitAnsiString(&AnsiProvName, pVTable->pszProvName);

    dwSts = RtlAnsiStringToUnicodeString(
        &UnicodeProvName,
        &AnsiProvName,
        TRUE);

    if (STATUS_SUCCESS != dwSts)
    {
        dwError = RtlNtStatusToDosError(dwSts);
        goto Ret;
    }

    VTableW.pszProvName = UnicodeProvName.Buffer;

    if (! CPAcquireContextW(
        phProv,
        szContainer ? UnicodeContainer.Buffer : NULL,
        dwFlags,
        &VTableW))
    {
        dwError = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (szContainer)
        RtlFreeUnicodeString(&UnicodeContainer);

    RtlFreeUnicodeString(&UnicodeProvName);

    if (! fSuccess)
        SetLastError(dwError);

    return fSuccess;
}


/*
 -  CPAcquireContextW
 -
 *  Purpose:
 *               The CPAcquireContextW function is used to acquire a context
 *               handle to a cryptographic service provider (CSP). using
 *               UNICODE strings.  This is an optional entry point for a CSP.
 *               It is not used prior to Whistler.  There it is used if
 *               exported by the CSP image, otherwise any string conversions
 *               are done, and CPAcquireContext is called.
 *
 *
 *  Parameters:
 *               OUT phProv         -  Handle to a CSP
 *               IN  szContainer    -  Pointer to a string which is the
 *                                     identity of the logged on user
 *               IN  dwFlags        -  Flags values
 *               IN  pVTable        -  Pointer to table of function pointers
 *
 *  Returns:
 */

BOOL WINAPI
CPAcquireContextW(
    OUT HCRYPTPROV *phProv,
    IN  LPCWSTR szContainer,
    IN  DWORD dwFlags,
    IN  PVTableProvStrucW pVTable)
{
    PUSER_CONTEXT pUserContext = NULL;
    LOCAL_CALL_INFO LocalCallInfo;
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    //
    // Invalid to specify a container name with 
    // VERIFYCONTEXT.
    //
    if (    (CRYPT_VERIFYCONTEXT & dwFlags) &&
            NULL != szContainer)
    {
        dwSts = NTE_BAD_FLAGS;
        goto Ret;
    }

    pUserContext = (PUSER_CONTEXT) CspAllocH(sizeof(USER_CONTEXT));

    LOG_CHECK_ALLOC(pUserContext);

    if (szContainer)
    {
        pUserContext->wszContainerNameFromCaller = 
            (LPWSTR) CspAllocH((1 + wcslen(szContainer)) * sizeof(WCHAR));

        LOG_CHECK_ALLOC(pUserContext->wszContainerNameFromCaller);

        wcscpy(
            pUserContext->wszContainerNameFromCaller,
            szContainer);
    }

    pUserContext->dwFlags = dwFlags;

    //
    // Copy the VTableProvStruc that we received from advapi, since
    // the info in the struct may be useful later.
    //
    pUserContext->pVTableW = 
        (PVTableProvStrucW) CspAllocH(sizeof(VTableProvStrucW));

    LOG_CHECK_ALLOC(pUserContext->pVTableW);

    // Copy the provider name
    pUserContext->pVTableW->pszProvName = 
        (LPWSTR) CspAllocH((1 + wcslen(pVTable->pszProvName)) * sizeof(WCHAR));

    LOG_CHECK_ALLOC(pUserContext->pVTableW->pszProvName);

    wcscpy(
        pUserContext->pVTableW->pszProvName,
        pVTable->pszProvName);

    // Copy the context information, if any
    if (pVTable->pbContextInfo)
    {
        pUserContext->pVTableW->pbContextInfo = 
            (PBYTE) CspAllocH(pVTable->cbContextInfo);

        LOG_CHECK_ALLOC(pUserContext->pVTableW->pbContextInfo);

        memcpy(
            pUserContext->pVTableW->pbContextInfo,
            pVTable->pbContextInfo,
            pVTable->cbContextInfo);

        pUserContext->pVTableW->cbContextInfo = pVTable->cbContextInfo;
    }

    // Copy the rest of the ProvStruc
    pUserContext->pVTableW->dwProvType = pVTable->dwProvType;
    pUserContext->pVTableW->FuncReturnhWnd = pVTable->FuncReturnhWnd;
    pUserContext->pVTableW->FuncVerifyImage = pVTable->FuncVerifyImage;
    pUserContext->pVTableW->Version = pVTable->Version;

    if (! CryptAcquireContextW(
        &pUserContext->hSupportProv,
        NULL,
        pLocalCspInfo->wszSupportProviderName,
        pLocalCspInfo->dwSupportProviderType,
        CRYPT_VERIFYCONTEXT))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    dwSts = pLocalCspInfo->pfnLocalAcquireContext(
        pUserContext,
        &LocalCallInfo);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (CRYPT_DELETEKEYSET & dwFlags)
    {
        DeleteUserContext(pUserContext);
        CspFreeH(pUserContext);
        pUserContext = NULL;
    }
    else
        *phProv = (HCRYPTPROV) pUserContext;

Ret:
    if (ERROR_SUCCESS != dwSts)
    {
        DeleteUserContext(pUserContext);
        CspFreeH(pUserContext);
        SetLastError(dwSts);

        fSuccess = FALSE;
    }
    else
        fSuccess = TRUE;

    return fSuccess;
}

/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  phProv        -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPReleaseContext(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwFlags)
{
    PUSER_CONTEXT pUserContext = (PUSER_CONTEXT) hProv;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    BOOL fSuccess = TRUE;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;

    InitializeLocalCallInfo(&LocalCallInfo);

    dwSts = pLocalCspInfo->pfnLocalReleaseContext(
        pUserContext, dwFlags, &LocalCallInfo);

    if (ERROR_SUCCESS != dwSts)
        fSuccess = FALSE;

    //
    // Try to free the user context structure, regardless of what the
    // local CSP replied in the above call.
    //
    DeleteUserContext(pUserContext);
    
    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPGenKey
 -
 *  Purpose:
 *                Generate cryptographic keys
 *
 *
 *  Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */

BOOL WINAPI
CPGenKey(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    DWORD dwSts = ERROR_SUCCESS;
    PKEY_CONTEXT pKeyCtx = NULL;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    LOCAL_CALL_INFO LocalCallInfo;

    InitializeLocalCallInfo(&LocalCallInfo);

    *phKey = 0;

    pKeyCtx = (PKEY_CONTEXT) CspAllocH(sizeof(KEY_CONTEXT));

    LOG_CHECK_ALLOC(pKeyCtx);

    pKeyCtx->Algid = Algid;
    pKeyCtx->dwFlags = 0x0000ffff & dwFlags;
    pKeyCtx->cKeyBits = dwFlags >> 16;
    pKeyCtx->pUserContext = pUserCtx;

    if (pLocalCspInfo->pfnLocalGenKey)
    {
        dwSts = pLocalCspInfo->pfnLocalGenKey(
            pKeyCtx, &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptGenKey(
        pUserCtx->hSupportProv,
        Algid,
        dwFlags,
        &pKeyCtx->hSupportKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:
    if (TRUE == fSuccess)
    {
        *phKey = (HCRYPTKEY) pKeyCtx;
        pKeyCtx = NULL;
    }

    if (pKeyCtx)
    {
        DeleteKeyContext(pKeyCtx);
        CspFreeH(pKeyCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPDeriveKey
 -
 *  Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *  Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hBaseData -   Handle to base data
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *  Returns:
 */

BOOL WINAPI
CPDeriveKey(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *ph