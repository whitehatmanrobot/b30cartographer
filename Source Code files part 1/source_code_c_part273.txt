                   }
                    else {
                        noneEffectsCheck.Checked = false;

                        if (value.IndexOf(EFFECTS_UNDERLINE_VALUE) >= 0)
                            underlineEffectsCheck.Checked = true;
                        if (value.IndexOf(EFFECTS_OVERLINE_VALUE) >= 0)
                            overlineEffectsCheck.Checked = true;
                        if (value.IndexOf(EFFECTS_STRIKE_VALUE) >= 0)
                            strikeEffectsCheck.Checked = true;
                        if (value.IndexOf(EFFECTS_BLINK_VALUE) >= 0)
                            blinkEffectSet = true;
                    }
                }
            }
        }

        private void InitFontNameUI() {
            Debug.Assert(IsInitMode() == true,
                         "initFontNameUI called when page is not in init mode");

            familyOption.Checked = false;
            systemFontOption.Checked = false;
            familyEdit.Clear();
            systemFontCombo.SelectedIndex = -1;

            Debug.Assert(fontAttribute != null,
                         "Expected fontAttribute to be non-null");
            Debug.Assert(fontFamilyAttribute != null,
                         "Expected fontFamilyAttribute to be non-null");

            string value = fontAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < SYSFONT_VALUES.Length; i++) {
                    if (SYSFONT_VALUES[i].Equals(value)) {
                        systemFontCombo.SelectedIndex = i;
                        systemFontOption.Checked = true;
                        return;
                    }
                }
            }

            value = fontFamilyAttribute.Value;
            if (value != null) {
                familyOption.Checked = true;

                if (value.Length != 0)
                    familyEdit.Text = value;
            }
        }

        private void InitSizeUI() {
            Debug.Assert(IsInitMode() == true,
                         "initSizeUI called when page is not in init mode");

            specificSizeOption.Checked = false;
            specificSizeUnit.Value = null;
            relativeSizeOption.Checked = false;
            relativeSizeCombo.SelectedIndex = -1;
            absoluteSizeOption.Checked = false;
            absoluteSizeCombo.SelectedIndex = -1;

            Debug.Assert(sizeAttribute != null,
                         "Expected sizeAttribute to be non-null");

            string value = sizeAttribute.Value;
            bool relative = false;
            bool absolute = false;
            int i;

            if (value != null) {
                if (value.Length != 0) {
                    // check for absolute font size
                    for (i = 1; i < ABSSIZE_VALUES.Length; i++) {
                        if (ABSSIZE_VALUES[i].Equals(value)) {
                            absoluteSizeCombo.SelectedIndex = i;
                            absolute = true;
                            break;
                        }
                    }

                    if (absolute == false) {
                        // check for relative font size
                        for (i = 1; i < RELSIZE_VALUES.Length; i++) {
                            if (RELSIZE_VALUES[i].Equals(value)) {
                                relativeSizeCombo.SelectedIndex = i;
                                relative = true;
                                break;
                            }
                        }

                        if (relative == false) {
                            // default to specific font size
                            specificSizeUnit.Value = value;
                        }
                    }
                }
                if (absolute == true)
                    absoluteSizeOption.Checked = true;
                else if (relative == true)
                    relativeSizeOption.Checked = true;
                else
                    specificSizeOption.Checked = true;
            }
        }

        private void InitSmallCapsUI() {
            Debug.Assert(IsInitMode() == true,
                         "initSmallCapsUI called when page is not in init mode");

            smallCapsCombo.SelectedIndex = -1;

            Debug.Assert(smallCapsAttribute != null,
                         "Expected smallCapsAttribute to be non-null");

            string value = smallCapsAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < SMALLCAPS_VALUES.Length; i++) {
                    if (SMALLCAPS_VALUES[i].Equals(value)) {
                        smallCapsCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitStyleUI() {
            Debug.Assert(IsInitMode() == true,
                         "initStyleUI called when page is not in init mode");

            styleCombo.SelectedIndex = -1;

            Debug.Assert(styleAttribute != null,
                         "Expected styleAttribute to be non-null");

            string value = styleAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < STYLE_VALUES.Length; i++) {
                    if (STYLE_VALUES[i].Equals(value)) {
                        styleCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitWeightUI() {
            Debug.Assert(IsInitMode() == true,
                         "initWeightUI called when page is not in init mode");

            relativeWeightOption.Checked = false;
            relativeWeightCombo.SelectedIndex = -1;
            absoluteWeightOption.Checked = false;
            absoluteWeightCombo.SelectedIndex = -1;

            Debug.Assert(sizeAttribute != null,
                         "Expected sizeAttribute to be non-null");

            string value = weightAttribute.Value;
            bool relative = false;
            int i;

            if (value != null) {
                if (value.Length != 0) {
                    // check for relative font weight
                    for (i = 1; i < RELWEIGHT_VALUES.Length; i++) {
                        if (RELWEIGHT_VALUES[i].Equals(value)) {
                            relative = true;
                            relativeWeightCombo.SelectedIndex = i;
                            break;
                        }
                    }

                    if (relative == false) {
                        // default to absolute font weight
                        if (ABSWEIGHT_NORMAL_VALUE.Equals(value)) {
                            absoluteWeightCombo.SelectedIndex = IDX_ABSWEIGHT_400;
                        }
                        else if (ABSWEIGHT_BOLD_VALUE.Equals(value)) {
                            absoluteWeightCombo.SelectedIndex = IDX_ABSWEIGHT_700;
                        }
                        else {
                            for (i = 1; i < ABSWEIGHT_VALUES.Length; i++) {
                                if (ABSWEIGHT_VALUES[i].Equals(value)) {
                                    absoluteWeightCombo.SelectedIndex = i;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (relative == true)
                    relativeWeightOption.Checked = true;
                else
                    absoluteWeightOption.Checked = true;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveCapitalizationUI() {
            string strCapitalization;

            if (capitalizationCombo.IsSet()) {
                int nIndex = capitalizationCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < CAPITALIZATION_VALUES.Length),
                             "Invalid index for direction");
                strCapitalization = CAPITALIZATION_VALUES[nIndex];
            }
            else
                strCapitalization = "";

            return strCapitalization;
        }

        private string SaveColorUI() {
            return colorCombo.Color;
        }

        private string SaveEffectsUI() {
            string value = "";

            if (noneEffectsCheck.CheckState == CheckState.Checked)
                value = EFFECTS_NONE_VALUE;
            else if (noneEffectsCheck.CheckState == CheckState.Unchecked) {
                if (underlineEffectsCheck.Checked)
                    value = EFFECTS_UNDERLINE_VALUE;
                if (overlineEffectsCheck.Checked)
                    value += " " + EFFECTS_OVERLINE_VALUE;
                if (strikeEffectsCheck.Checked)
                    value += " " + EFFECTS_STRIKE_VALUE;

                if (blinkEffectSet)
                    value += " " + EFFECTS_BLINK_VALUE;
            }

            return value.Trim();
        }

        private string SaveFontNameUI() {
            string value = null;

            if (familyOption.Checked == true) {
                value = familyEdit.Text.Trim();
            }
            else if (systemFontOption.Checked) {
                if (systemFontCombo.IsSet()) {
                    int index = systemFontCombo.SelectedIndex;
                    Debug.Assert((index >= 1) && (index < SYSFONT_VALUES.Length),
                                 "invalid index for system font");

                    value = SYSFONT_VALUES[index];
                }
            }
            if (value == null)
                value = "";

            return value;
        }

        private string SaveSmallCapsUI() {
            string value;

            if (smallCapsCombo.IsSet() && (systemFontOption.Checked == false)) {
                int index = smallCapsCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < SMALLCAPS_VALUES.Length),
                             "Invalid index for small caps");

                value = SMALLCAPS_VALUES[index];
            }
            else
                value = "";

            return value;
        }

        private string SaveSizeUI() {
            string value = null;

            if (systemFontOption.Checked == false) {
                if (specificSizeOption.Checked) {
                    value = specificSizeUnit.Value;
                }
                else if (relativeSizeOption.Checked) {
                    if (relativeSizeCombo.IsSet()) {
                        int index = relativeSizeCombo.SelectedIndex;
                        Debug.Assert((index >= 1) && (index < RELSIZE_VALUES.Length),
                                     "Invalid index");

                        value = RELSIZE_VALUES[index];
                    }
                }
                else if (absoluteSizeCombo.IsSet()) {
                    int index = absoluteSizeCombo.SelectedIndex;
                    Debug.Assert((index >= 1) && (index < ABSSIZE_VALUES.Length),
                                 "Invalid index");

                    value = ABSSIZE_VALUES[index];
                }
            }
            if (value == null)
                value = "";

            return value;
        }

        private string SaveStyleUI() {
            string value;

            if (styleCombo.IsSet() && (systemFontOption.Checked == false)) {
                int index = styleCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < STYLE_VALUES.Length),
                             "Invalid index for style");

                value = STYLE_VALUES[index];
            }
            else
                value = "";

            return value;
        }

        private string SaveWeightUI() {
            string value = null;

            if (systemFontOption.Checked == false) {
                if (relativeWeightOption.Checked) {
                    if (relativeWeightCombo.IsSet()) {
                        int index = relativeWeightCombo.SelectedIndex;
                        Debug.Assert((index >= 1) && (index < RELWEIGHT_VALUES.Length),
                                     "Invalid index");

                        value = RELWEIGHT_VALUES[index];
                    }
                }
                else if (absoluteWeightCombo.IsSet()) {
                    int index = absoluteWeightCombo.SelectedIndex;
                    Debug.Assert((index >= 1) && (index < ABSWEIGHT_VALUES.Length),
                                 "Invalid index");

                    if (index == IDX_ABSWEIGHT_400)
                        value = ABSWEIGHT_NORMAL_VALUE;
                    else if (index == IDX_ABSWEIGHT_700)
                        value = ABSWEIGHT_BOLD_VALUE;
                    else
                        value = ABSWEIGHT_VALUES[index];
                }
            }
            if (value == null)
                value = "";

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to update the preview

        private void UpdateCapitalizationPreview() {
            if (previewStyle == null)
                return;

            string value = SaveCapitalizationUI();
            Debug.Assert(value != null,
                         "saveCapitalizationUI returned null!");

            try {
                previewStyle.SetTextTransform(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in FontStylePage::updateCapitalizationPreview\n\t" + e.ToString());
            }
        }

        private void UpdateColorPreview() {
            if (previewStyle == null)
                return;

            string value = SaveColorUI();
            Debug.Assert(value != null,
                         "saveColorUI returned null!");

            try {
                previewStyle.SetColor(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateColorPreview\n\t" + e.ToString());
            }

            previewPending = false;
        }

        private void UpdateEffectsPreview() {
            if (previewStyle == null)
                return;

            string value = SaveEffectsUI();
            Debug.Assert(value != null,
                         "SaveEffectsUI returned null!");

            try {
                previewStyle.SetTextDecoration(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::UpdateEffectsPreview\n\t" + e.ToString());
            }
        }

        private void UpdateFontNamePreview(bool fTypeChanged) {
            if (previewStyle == null)
                return;

            string value = SaveFontNameUI();
            Debug.Assert(value != null,
                         "saveFontNameUI returned null!");

            try {
                if (fTypeChanged) {
                    previewStyle.RemoveAttribute("fontFamily", 1);
                    previewStyle.RemoveAttribute("font", 1);

                    if (familyOption.Checked) {
                        UpdateStylePreview();
                        UpdateSmallCapsPreview();
                        UpdateSizePreview();
                        UpdateWeightPreview();
                    }
                }

                if (familyOption.Checked) {
                    if (value.Length == 0) {
                        if (!fTypeChanged)
                            previewStyle.RemoveAttribute("fontFamily", 1);
                    }
                    else
                        previewStyle.SetFontFamily(value);
                }
                else if (systemFontOption.Checked) {
                    if (value.Length == 0) {
                        if (!fTypeChanged)
                            previewStyle.RemoveAttribute("font", 1);
                    }
                    else
                        previewStyle.SetFont(value);
                }
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateFontNamePreview\n\t" + e.ToString());
            }

            previewPending = false;
        }

        private void UpdateSizePreview() {
            if (previewStyle == null)
                return;

            string value = SaveSizeUI();
            Debug.Assert(value != null,
                         "saveSmallCapsUI returned null!");

            try {
                previewStyle.SetFontSize(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateSizePreview\n\t" + e.ToString());
            }
        }

        private void UpdateSmallCapsPreview() {
            if (previewStyle == null)
                return;

            string value = SaveSmallCapsUI();
            Debug.Assert(value != null,
                         "saveSmallCapsUI returned null!");

            try {
                previewStyle.SetFontObject(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateSmallCapsPreview\n\t" + e.ToString());
            }
        }

        private void UpdateStylePreview() {
            if (previewStyle == null)
                return;

            string value = SaveStyleUI();
            Debug.Assert(value != null,
                         "saveStyleUI returned null!");

            try {
                previewStyle.SetFontStyle(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateStylePreview\n\t" + e.ToString());
            }
        }

        private void UpdateWeightPreview() {
            if (previewStyle == null)
                return;

            string value = SaveWeightUI();
            Debug.Assert(value != null,
                         "saveWeightUI returned null!");

            try {
                previewStyle.SetFontWeight(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleFontPage::updateWeightPreview\n\t" + e.ToString());
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedColor"]/*' />
        /// <devdoc>
        ///     Handles changes to the color, when a new color is typed in to set
        ///     the dirty state and mark the control updated. The preview is updated
        ///     when editing is complete, i.e., the user tabs away.
        /// </devdoc>
        private void OnChangedColor(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (previewPending == false) {
                previewPending = true;
                colorAttribute.Dirty = true;
                SetDirty();
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedFamily"]/*' />
        /// <devdoc>
        ///     Handles changes to the font family, when a new font is typed in to set
        ///     the dirty state and mark the control updated. The preview is updated
        ///     when editing is complete and the user tabs away.
        /// </devdoc>
        private void OnChangedFamily(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (previewPending == false) {
                previewPending = true;
                fontFamilyAttribute.Dirty = true;
                SetDirty();
            }
        }

        private void OnChangedFontNameType(object source, EventArgs e) {
            if (IsInitMode())
                return;

            Debug.Assert(source is RadioButton,
                         "onChangedWeightType can only sink events from RadioButtons");
            if (((RadioButton)source).Checked == false) {
                fontAttribute.Dirty = true;
                fontFamilyAttribute.Dirty = true;
                SetDirty();
                SetEnabledState(true, false, false, false);
                UpdateFontNamePreview(true);
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedSize"]/*' />
        /// <devdoc>
        ///     Handles changes made to the font size to set the dirty state and update
        ///     the preview.
        /// </devdoc>
        private void OnChangedSize(object source, EventArgs e) {
            if (IsInitMode())
                return;
            sizeAttribute.Dirty = true;
            SetDirty();
            if (!source.Equals(specificSizeUnit) || (e != null)) {
                UpdateSizePreview();
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedSizeType"]/*' />
        /// <devdoc>
        ///     Handles changes made in the selection of font size type, to set the
        ///     dirty state and update the preview.
        /// </devdoc>
        private void OnChangedSizeType(object source, EventArgs e) {
            if (IsInitMode())
                return;

            sizeAttribute.Dirty = true;
            SetDirty();
            UpdateSizePreview();
            SetEnabledState(false, true, false, false);
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedWeight"]/*' />
        /// <devdoc>
        ///     Handles changes made to the font weight to set the dirty state and update
        ///     the preview.
        /// </devdoc>
        private void OnChangedWeight(object source, EventArgs e) {
            if (IsInitMode())
                return;
            weightAttribute.Dirty = true;
            SetDirty();
            UpdateWeightPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnChangedWeightType"]/*' />
        /// <devdoc>
        ///     Handles changes made in the selection of font weight type, to set the
        ///     dirty state and update the preview.
        /// </devdoc>
        private void OnChangedWeightType(object source, EventArgs e) {
            if (IsInitMode())
                return;

            weightAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, false, true, false);
            UpdateWeightPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnCheckChangedEffects"]/*' />
        /// <devdoc>
        ///     Handles changes in the text effect attributes to set the dirty state
        ///     and update the preview.
        ///     It also updates the state of the effects ui, if None was changed.
        /// </devdoc>
        private void OnCheckChangedEffects(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (noneEffectsCheck.Equals(source)) {
                if (noneEffectsCheck.ThreeState == true)
                    noneEffectsCheck.ThreeState = false;
                SetEnabledState(false, false, false, true);
            }

            effectsAttribute.Dirty = true;
            SetDirty();
            UpdateEffectsPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnClickColorPicker"]/*' />
        /// <devdoc>
        ///     Brings up the color picker to select a color.
        /// </devdoc>
        private void OnClickColorPicker(object source, EventArgs e) {
            string color = InvokeColorPicker(colorCombo.Color);

            if (color != null) {
                colorCombo.Color = color;
                colorAttribute.Dirty = true;
                SetDirty();
                UpdateColorPreview();
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnClickFontPicker"]/*' />
        /// <devdoc>
        ///     Brings up the font picker dialog to build up a font family value.
        /// </devdoc>
        private void OnClickFontPicker(object source, EventArgs e) {
            ISite site = Site;
            StyleBuilderSite builderSite = (site != null) ? (StyleBuilderSite)site.GetService(typeof(StyleBuilderSite)) : null;
            FontPicker dlgFP = new FontPicker(builderSite);
            DialogParentWindow parent = new DialogParentWindow(Parent.Handle);

            dlgFP.FontFamily = familyEdit.Text.Trim();

            if (dlgFP.ShowDialog(parent) == DialogResult.OK) {
                familyEdit.Text = dlgFP.FontFamily;
                fontFamilyAttribute.Dirty = true;
                SetDirty();
                UpdateFontNamePreview(false);
            }
            dlgFP.Dispose();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnLostFocusColor"]/*' />
        /// <devdoc>
        ///     Updates the preview if the color was modified when it had focus.
        /// </devdoc>
        private void OnLostFocusColor(object source, EventArgs e) {
            if (previewPending) {
                UpdateColorPreview();
            }
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnLostFocusFamily"]/*' />
        /// <devdoc>
        ///     Updates the preview if the font family was modified when it had focus.
        /// </devdoc>
        private void OnLostFocusFamily(object source, EventArgs e) {
            if (previewPending) {
                UpdateFontNamePreview(false);
            }
        }

        private void OnSelChangedCapitalization(object source, EventArgs e) {
            if (IsInitMode())
                return;
            capitalizationAttribute.Dirty = true;
            SetDirty();
            UpdateCapitalizationPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnSelChangedColor"]/*' />
        /// <devdoc>
        ///     Handles changes in the color, when a new color is picked from the
        ///     dropdown to set the dirty state and update the preview.
        /// </devdoc>
        private void OnSelChangedColor(object source, EventArgs e) {
            if (IsInitMode())
                return;
            colorAttribute.Dirty = true;
            SetDirty();
            UpdateColorPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnSelChangedSmallCaps"]/*' />
        /// <devdoc>
        ///     Handles changes made to the small caps to set the dirty state and
        ///     update the preview.
        /// </devdoc>
        private void OnSelChangedSmallCaps(object source, EventArgs e) {
            if (IsInitMode())
                return;
            smallCapsAttribute.Dirty = true;
            SetDirty();
            UpdateSmallCapsPreview();
        }

        /// <include file='doc\FontStylePage.uex' path='docs/doc[@for="FontStylePage.OnSelChangedStyle"]/*' />
        /// <devdoc>
        ///     Handles changes made to the font style to set the dirty state and
        ///     update the preview.
        /// </devdoc>
        private void OnSelChangedStyle(object source, EventArgs e) {
            if (IsInitMode())
                return;
            styleAttribute.Dirty = true;
            SetDirty();
            UpdateStylePreview();
        }

        private void OnSelChangedSysFont(object source, EventArgs e) {
            if (IsInitMode())
                return;
            fontAttribute.Dirty = true;
            SetDirty();
            UpdateFontNamePreview(false);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to persist attributes

        private void SaveCapitalization() {
            string value = SaveCapitalizationUI();
            Debug.Assert(value != null,
                         "saveCapitalizationUI returned null!");

            capitalizationAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveColor() {
            string value = SaveColorUI();
            Debug.Assert(value != null,
                         "saveColorUI returned null!");

            colorAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveEffects() {
            string value = SaveEffectsUI();
            Debug.Assert(value != null,
                         "SaveEffectsUI returned null!");

            effectsAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveFontName() {
            string value = SaveFontNameUI();
            Debug.Assert(value != null,
                         "saveFontNameUI returned null!");

            styleAttribute.Dirty = true;
            smallCapsAttribute.Dirty = true;
            sizeAttribute.Dirty = true;
            weightAttribute.Dirty = true;

            IStyleBuilderStyle[] styles = GetSelectedStyles();

            if (systemFontOption.Checked == true) {
                fontAttribute.ResetAttribute(styles, false);
                fontFamilyAttribute.ResetAttribute(styles, false);
                if (value.Length != 0)
                    fontAttribute.SaveAttribute(styles, value);
            }
            else {
                fontAttribute.ResetAttribute(styles, false);
                fontFamilyAttribute.ResetAttribute(styles, false);

                if (value.Length > 0)
                    fontFamilyAttribute.SaveAttribute(styles, value);
            }
        }

        private void SaveSize() {
            string value = SaveSizeUI();
            Debug.Assert(value != null,
                         "saveSizeUI returned null!");

            sizeAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveSmallCaps() {
            string value = SaveSmallCapsUI();
            Debug.Assert(value != null,
                         "saveSmallCapsUI returned null!");

            smallCapsAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveStyle() {
            string value = SaveStyleUI();
            Debug.Assert(value != null,
                         "saveStyleUI returned null!");

            styleAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveWeight() {
            string value = SaveWeightUI();
            Debug.Assert(value != null,
                         "saveWeightUI returned null!");

            weightAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\backgroundstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="BackgroundStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// BackgroundStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Interop.Trident;
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;
    using System.Globalization;
    
    /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage"]/*' />
    /// <devdoc>
    ///     BackgroundStylePage
    ///     The standard background page used in the StyleBuilder to edit background
    ///     color and image attributes of a CSS style.
    /// </devdoc>
    internal sealed class BackgroundStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private readonly static string HELP_KEYWORD = "vs.StyleBuilder.Background";

        // Background color constants
        private readonly static string COLOR_TRANSPARENT = "transparent";

        // Image constants
        private readonly static string IMAGE_NONE = "none";

        // Tiling constants
        private const int IDX_TILING_HORZ = 1;
        private const int IDX_TILING_VERT = 2;
        private const int IDX_TILING_BOTH = 3;
        private const int IDX_TILING_NONE = 4;

        private readonly static string[] TILING_VALUES = new string[]
        {
            null, "repeat-x", "repeat-y", "repeat", "no-repeat"
        };

        // Scrolling constants
        private const int IDX_SCROLLING_SCROLL = 1;
        private const int IDX_SCROLLING_FIXED = 2;

        private readonly static string[] SCROLLING_VALUES = new string[]
        {
            null, "scroll", "fixed"
        };

        // Position constants
        private const int IDX_POS_LEFT_TOP = 1;
        private const int IDX_POS_CENTER_CENTER = 2;
        private const int IDX_POS_RIGHT_BOTTOM = 3;
        private const int IDX_POS_CUSTOM = 4;

        private readonly static string[] HPOS_VALUES = new string[]
        {
            null, "left", "center", "right"
        };

        private readonly static string[] VPOS_VALUES = new string[]
        {
            null, "top", "center", "bottom"
        };

        // Preview Constants
        private readonly static string PREVIEW_TEMPLATE =
            "<div id=\"divBackground\" style=\"height: 100%; width: 100%; " +
                                              "padding: 0px; margin: 0px\">" +
                "<br><div id=\"divSample\" style=\"text-align: center\"></div>" +
                "<br><br><br><br><br><br><br><br><br><br>" +
            "</div>";
        private readonly static string PREVIEW_ELEM_ID = "divBackground";
        private readonly static string PREVIEW_SAMPLE_ID = "divSample";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute backColorAttribute;
        private CSSAttribute imageAttribute;
        private CSSAttribute tilingAttribute;
        private CSSAttribute scrollingAttribute;
        private CSSAttribute hPosAttribute;
        private CSSAttribute vPosAttribute;

        private bool previewPending;
        private IHTMLStyle previewStyle;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private CheckBox transparentCheck;
        private ColorComboBox backColorCombo;
        private Button colorPickerButton;
        private CheckBox imageNoneCheck;
        private TextBox imageUrlEdit;
        private Button imageUrlPickerButton;
        private UnsettableComboBox tilingCombo;
        private UnsettableComboBox scrollingCombo;
        private UnsettableComboBox hPosCombo;
        private UnsettableComboBox vPosCombo;
        private UnitControl hPosUnit;
        private UnitControl vPosUnit;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.BackgroundStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new BackgroundStylePage.
        /// </devdoc>
        public BackgroundStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(BackgroundStylePage), "BackPage.ico"));
            SetHelpKeyword(BackgroundStylePage.HELP_KEYWORD);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.ActivatePage"]/*' />
        /// <devdoc>
        ///     The page is now the currently active page in the StyleBuilder.
        ///     Be sure to call super.activatePage, so that the page is made visible.
        /// </devdoc>
        protected override void ActivatePage() {
            base.ActivatePage();

            // initialize the preview
            IStyleBuilderPreview preview = null;

            if (Site != null)
                preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));

            if (preview != null) {
                try {
                    IHTMLElement backgroundPreviewElem = null;
                    IHTMLElement sampleElem = null;
                    IHTMLElement previewElem = preview.GetPreviewElement();

                    previewElem.SetInnerHTML(PREVIEW_TEMPLATE);
                    backgroundPreviewElem = preview.GetElement(PREVIEW_ELEM_ID);
                    if (backgroundPreviewElem != null) {
                        previewStyle = backgroundPreviewElem.GetStyle();
                    }

                    sampleElem = preview.GetElement(PREVIEW_SAMPLE_ID);
                    if (sampleElem != null) {
                        sampleElem.SetInnerHTML(SR.GetString(SR.BgSP_PreviewText));
                    }
                }
                catch (Exception) {
                    previewStyle = null;
                    return;
                }

                Debug.Assert(previewStyle != null,
                             "Expected to have a non-null cached preview style reference");

                // Setup the font from the shared element to reflect settings in the font page
                try {
                    IHTMLElement sharedElem = preview.GetSharedElement();
                    IHTMLStyle sharedStyle;
                    string fontValue;

                    if (sharedElem != null)
                    {
                        sharedStyle = sharedElem.GetStyle();

                        previewStyle.SetColor(sharedStyle.GetColor());
                        previewStyle.SetTextDecoration(sharedStyle.GetTextDecoration());
                        previewStyle.SetTextTransform(sharedStyle.GetTextTransform());

                        fontValue = sharedStyle.GetFont();
                        if ((fontValue != null) && (fontValue.Length != 0)) {
                            previewStyle.SetFont(fontValue);
                        }
                        else {
                            previewStyle.RemoveAttribute("font", 1);
                            previewStyle.SetFontFamily(sharedStyle.GetFontFamily());

                            object o = sharedStyle.GetFontSize();
                            if (o != null) {
                                previewStyle.SetFontSize(o);
                            }
                            previewStyle.SetFontObject(sharedStyle.GetFontObject());
                            previewStyle.SetFontStyle(sharedStyle.GetFontStyle());
                            previewStyle.SetFontWeight(sharedStyle.GetFontWeight());
                        }
                    }
                } catch (Exception) {
                }

                // update initial preview
                UpdateBackColorPreview();
                UpdateImagePreview();
                UpdateTilingPreview();
                UpdateScrollingPreview();
                UpdatePositionXPreview();
                UpdatePositionYPreview();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            GroupBox positionGroup = new GroupBox();
            Label backColorLabel = new GroupLabel();
            Label colorLabel = new Label();
            Label imageLabel = new GroupLabel();
            Label imageUrlLabel = new Label();
            Label tilingLabel = new Label();
            Label scrollingLabel = new Label();
            Label hPosLabel = new Label();
            Label vPosLabel = new Label();

            transparentCheck = new CheckBox();
            backColorCombo = new ColorComboBox();
            colorPickerButton = new Button();
            imageNoneCheck = new CheckBox();
            imageUrlEdit = new TextBox();
            imageUrlPickerButton = new Button();
            tilingCombo = new UnsettableComboBox();
            scrollingCombo = new UnsettableComboBox();
            hPosCombo = new UnsettableComboBox();
            vPosCombo = new UnsettableComboBox();
            hPosUnit = new UnitControl();
            vPosUnit = new UnitControl();

            backColorLabel.Location = new Point(4, 4);
            backColorLabel.Size = new Size(400, 16);
            backColorLabel.TabIndex = 0;
            backColorLabel.TabStop = false;
            backColorLabel.Text = SR.GetString(SR.BgSP_BackColorLabel);

            colorLabel.Location = new Point(8, 28);
            colorLabel.Size = new Size(60, 16);
            colorLabel.TabIndex = 1;
            colorLabel.TabStop = false;
            colorLabel.Text = SR.GetString(SR.BgSP_ColorLabel);

            backColorCombo.Location = new Point(68, 24);
            backColorCombo.Size = new Size(142, 21);
            backColorCombo.TabIndex = 2;
            backColorCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedBackColor);
            backColorCombo.TextChanged += new EventHandler(this.OnChangedBackColor);
            backColorCombo.LostFocus += new EventHandler(this.OnLostFocusBackColor);

            colorPickerButton.Location = new Point(214, 23);
            colorPickerButton.Size = new Size(24, 22);
            colorPickerButton.TabIndex = 3;
            colorPickerButton.Text = "...";
            colorPickerButton.FlatStyle = FlatStyle.System;
            colorPickerButton.Click += new EventHandler(this.OnClickColorPicker);

            transparentCheck.Location = new Point(8, 48);
            transparentCheck.Size = new Size(180, 18);
            transparentCheck.TabIndex = 4;
            transparentCheck.Text = SR.GetString(SR.BgSP_TransparentCheck);
            transparentCheck.FlatStyle = FlatStyle.System;
            transparentCheck.CheckedChanged += new EventHandler(this.OnChangedTransparent);

            imageLabel.Location = new Point(4, 76);
            imageLabel.Size = new Size(400, 16);
            imageLabel.TabIndex = 5;
            imageLabel.TabStop = false;
            imageLabel.Text = SR.GetString(SR.BgSP_BackImageLabel);

            imageUrlLabel.Location = new Point(8, 100);
            imageUrlLabel.Size = new Size(60, 16);
            imageUrlLabel.TabIndex = 6;
            imageUrlLabel.TabStop = false;
            imageUrlLabel.Text = SR.GetString(SR.BgSP_BackImageURLLabel);

            imageUrlEdit.Location = new Point(68, 96);
            imageUrlEdit.Size = new Size(282, 20);
            imageUrlEdit.TabIndex = 7;
            imageUrlEdit.Text = "";
            imageUrlEdit.TextChanged += new EventHandler(this.OnChangedUrl);
            imageUrlEdit.LostFocus += new EventHandler(this.OnLostFocusUrl);

            imageUrlPickerButton.Location = new Point(354, 95);
            imageUrlPickerButton.Size = new Size(24, 22);
            imageUrlPickerButton.TabIndex = 8;
            imageUrlPickerButton.Text = "...";
            imageUrlPickerButton.Click += new EventHandler(this.OnClickUrlPicker);

            tilingLabel.Location = new Point(66, 128);
            tilingLabel.Size = new Size(108, 16);
            tilingLabel.TabIndex = 9;
            tilingLabel.TabStop = false;
            tilingLabel.Text = SR.GetString(SR.BgSP_TilingLabel);

            tilingCombo.Location = new Point(178, 124);
            tilingCombo.Size = new Size(200, 21);
            tilingCombo.TabIndex = 10;
            tilingCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            tilingCombo.Items.AddRange(new object[]
                                    {
                                        SR.GetString(SR.BgSP_TilingCombo_1),
                                        SR.GetString(SR.BgSP_TilingCombo_2),
                                        SR.GetString(SR.BgSP_TilingCombo_3),
                                        SR.GetString(SR.BgSP_TilingCombo_4)
                                    });
            tilingCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedTiling);

            scrollingLabel.Location = new Point(66, 156);
            scrollingLabel.Size = new Size(108, 16);
            scrollingLabel.TabIndex = 11;
            scrollingLabel.TabStop = false;
            scrollingLabel.Text = SR.GetString(SR.BgSP_ScrollingLabel);

            scrollingCombo.Location = new Point(178, 152);
            scrollingCombo.Size = new Size(200, 21);
            scrollingCombo.TabIndex = 12;
            scrollingCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            scrollingCombo.Items.AddRange(new object[]
                                       {
                                           SR.GetString(SR.BgSP_ScrollingCombo_1),
                                           SR.GetString(SR.BgSP_ScrollingCombo_2)
                                       });
            scrollingCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedScrolling);

            positionGroup.Location = new Point(58, 184);
            positionGroup.Size = new Size(332, 80);
            positionGroup.TabIndex = 13;
            positionGroup.TabStop = false;
            positionGroup.FlatStyle = FlatStyle.System;
            positionGroup.Text = SR.GetString(SR.BgSP_PositionGroup);

            hPosLabel.Location = new Point(12, 24);
            hPosLabel.Size = new Size(106, 16);
            hPosLabel.TabIndex = 0;
            hPosLabel.TabStop = false;
            hPosLabel.Text = SR.GetString(SR.BgSP_HPosLabel);

            hPosCombo.Location = new Point(120, 20);
            hPosCombo.Size = new Size(108, 21);
            hPosCombo.TabIndex = 1;
            hPosCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            hPosCombo.Items.AddRange(new object[]
                                  {
                                      SR.GetString(SR.BgSP_HPosCombo_1),
                                      SR.GetString(SR.BgSP_HPosCombo_2),
                                      SR.GetString(SR.BgSP_HPosCombo_3),
                                      SR.GetString(SR.BgSP_HPosCombo_4)
                                  });
            hPosCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedHPos);

            hPosUnit.Location = new Point(232, 20);
            hPosUnit.Size = new Size(88, 21);
            hPosUnit.TabIndex = 2;
            hPosUnit.DefaultUnit = UnitControl.UNIT_PX;
            hPosUnit.MinValue = -32768;
            hPosUnit.MaxValue = 32767;
            hPosUnit.Changed += new EventHandler(this.OnChangedHPos);

            vPosLabel.Location = new Point(12, 52);
            vPosLabel.Size = new Size(106, 16);
            vPosLabel.TabIndex = 3;
            vPosLabel.TabStop = false;
            vPosLabel.Text = SR.GetString(SR.BgSP_VPosLabel);

            vPosCombo.Location = new Point(120, 48);
            vPosCombo.Size = new Size(108, 21);
            vPosCombo.TabIndex = 4;
            vPosCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            vPosCombo.Items.AddRange(new object[]
                                  {
                                      SR.GetString(SR.BgSP_VPosCombo_1),
                                      SR.GetString(SR.BgSP_VPosCombo_2),
                                      SR.GetString(SR.BgSP_VPosCombo_3),
                                      SR.GetString(SR.BgSP_VPosCombo_4)
                                  });
            vPosCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedVPos);

            vPosUnit.Location = new Point(232, 48);
            vPosUnit.Size = new Size(88, 21);
            vPosUnit.TabIndex = 5;
            vPosUnit.DefaultUnit = UnitControl.UNIT_PX;
            vPosUnit.MinValue = -32768;
            vPosUnit.MaxValue = 32767;
            vPosUnit.Changed += new EventHandler(this.OnChangedVPos);

            imageNoneCheck.Location = new Point(8, 270);
            imageNoneCheck.Size = new Size(300, 23);
            imageNoneCheck.TabIndex = 14;
            imageNoneCheck.Text = SR.GetString(SR.BgSP_BackImageNoneCheck);
            imageNoneCheck.FlatStyle = FlatStyle.System;
            imageNoneCheck.CheckedChanged += new EventHandler(this.OnChangedNone);

            this.Controls.Clear();                                  
            this.Controls.AddRange(new Control[] {
                                    imageNoneCheck,
                                    positionGroup,
                                    scrollingLabel,
                                    scrollingCombo,
                                    tilingLabel,
                                    tilingCombo,
                                    imageUrlLabel,
                                    imageUrlEdit,
                                    imageUrlPickerButton,
                                    imageLabel,
                                    transparentCheck,
                                    colorLabel,
                                    backColorLabel,
                                    backColorCombo,
                                    colorPickerButton });
                                    
            positionGroup.Controls.Clear();                                    
            positionGroup.Controls.AddRange(new Control[] {
                                             vPosLabel,
                                             vPosCombo,
                                             vPosUnit,
                                             hPosLabel,
                                             hPosCombo,
                                             hPosUnit });
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     The page is being deactivated, either because the dialog is closing, or
        ///     some other page is replacing it as the active page.
        /// </devdoc>
        protected override bool DeactivatePage(bool closing, bool validate) {
            if (closing == false) {
                // update the shared style, so other pages can use it
                try {
                    IStyleBuilderPreview preview = null;

                    if (Site != null)
                        preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));
                    if (preview != null) {
                        IHTMLElement sharedElem = preview.GetSharedElement();
                        IHTMLStyle sharedStyle = null;

                        if (sharedElem != null)
                            sharedStyle = sharedElem.GetStyle();

                        if (sharedStyle != null) {
                            string value;

                            value = SaveBackColorUI();
                            sharedStyle.SetBackgroundColor(value);

                            value = SaveImageUI();
                            sharedStyle.SetBackgroundImage(value);

                            value = SaveTilingUI();
                            sharedStyle.SetBackgroundRepeat(value);

                            value = SaveScrollingUI();
                            sharedStyle.SetBackgroundAttachment(value);

                            value = SavePositionXUI();
                            sharedStyle.SetBackgroundPositionX(value);

                            value = SavePositionYUI();
                            sharedStyle.SetBackgroundPositionY(value);

                            sharedStyle = null;
                        }
                    }
                } catch (Exception) {
                }
            }

            previewStyle = null;
            return base.DeactivatePage(closing, validate);
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the values from the styles passed in into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not already been created
            if (backColorAttribute == null) {
                backColorAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDCOLOR);
                imageAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDIMAGE, true);
                tilingAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDREPEAT);
                scrollingAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDATTACHMENT);
                hPosAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDPOSITIONX);
                vPosAttribute = new CSSAttribute(CSSAttribute.CSSATTR_BACKGROUNDPOSITIONY);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            backColorAttribute.LoadAttribute(styles);
            imageAttribute.LoadAttribute(styles);
            tilingAttribute.LoadAttribute(styles);
            scrollingAttribute.LoadAttribute(styles);
            hPosAttribute.LoadAttribute(styles);
            vPosAttribute.LoadAttribute(styles);

            // initialize the UI the the loaded attributes
            InitBackColorUI();
            InitImageUI();
            InitTilingUI();
            InitScrollingUI();
            InitPositionXUI();
            InitPositionYUI();

            SetEnabledState(true, true);

            SetInitMode(false);
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the values from the UI (that have been modified) to the styles
        ///     passed in.
        /// </devdoc>
        protected override void SaveStyles() {
            if (backColorAttribute.Dirty)
                SaveBackColor();
            if (imageAttribute.Dirty)
                SaveImage();
            if (tilingAttribute.Dirty)
                SaveTiling();
            if (scrollingAttribute.Dirty)
                SaveScrolling();
            if (hPosAttribute.Dirty)
                SavePositionX();
            if (vPosAttribute.Dirty)
                SavePositionY();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.BgSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState(bool backColor, bool image) {
            if (backColor) {
                bool transparent = transparentCheck.Checked;

                backColorCombo.Enabled = !transparent;
                colorPickerButton.Enabled = !transparent;
            }

            if (image) {
                bool noneImage = imageNoneCheck.Checked;
                bool urlImage = !noneImage && imageUrlEdit.Text.Trim().Length != 0;
                bool customPosition;

                imageUrlEdit.Enabled = !noneImage;
                imageUrlPickerButton.Enabled = !noneImage;

                tilingCombo.Enabled = urlImage;
                scrollingCombo.Enabled = urlImage;

                customPosition = urlImage && (hPosCombo.SelectedIndex == IDX_POS_CUSTOM);
                hPosCombo.Enabled = urlImage;
                hPosUnit.Enabled = customPosition;

                customPosition = urlImage && (vPosCombo.SelectedIndex == IDX_POS_CUSTOM);
                vPosCombo.Enabled = urlImage;
                vPosUnit.Enabled = customPosition;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.InitBackColorUI"]/*' />
        /// <devdoc>
        ///     Loads the background color value (css attribute: background-color).
        /// </devdoc>
        private void InitBackColorUI() {
            Debug.Assert(IsInitMode() == true,
                         "initBackColorUI called when page is not in init mode");

            transparentCheck.ThreeState = true;
            transparentCheck.CheckState = CheckState.Indeterminate;
            backColorCombo.Color = "";

            Debug.Assert(backColorAttribute != null,
                         "Expected backColorAttribute to be non-null");

            string value = backColorAttribute.Value;
            if (value != null) {
                transparentCheck.ThreeState = false;
                transparentCheck.Checked = false;

                if (value.Length != 0) {
                    if (String.Compare(value, COLOR_TRANSPARENT, true, CultureInfo.InvariantCulture) == 0) {
                        transparentCheck.Checked = true;
                    }
                    else {
                        transparentCheck.Checked = false;
                        backColorCombo.Color = value;
                    }
                }
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.InitImageUI"]/*' />
        /// <devdoc>
        ///     Loads the background image value (css attribute: background-image).
        /// </devdoc>
        private void InitImageUI() {
            Debug.Assert(IsInitMode() == true,
                         "initImageUI called when page is not in init mode");

            imageNoneCheck.ThreeState = true;
            imageNoneCheck.CheckState = CheckState.Indeterminate;
            imageUrlEdit.Clear();

            Debug.Assert(imageAttribute != null,
                         "Expected imageAttribute to be non-null");

            string value = imageAttribute.Value;
            if (value != null) {
                imageNoneCheck.ThreeState = false;
                imageNoneCheck.Checked = false;

                if (value.Length != 0) {
                    if (String.Compare(IMAGE_NONE, value, true, CultureInfo.InvariantCulture) == 0) {
                        imageNoneCheck.Checked = true;
                    }
                    else {
                        imageNoneCheck.Checked = false;

                        string url = StylePageUtil.ParseUrlProperty(value, false);
                        if (url != null)
                            imageUrlEdit.Text = url;
                    }
                }
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.InitTilingUI"]/*' />
        /// <devdoc>
        ///     Loads the image tiling value (css attribute: background-repeat).
        /// </devdoc>
        private void InitTilingUI() {
            Debug.Assert(IsInitMode() == true,
                         "initTilingUI called when page is not in init mode");

            tilingCombo.SelectedIndex = -1;

            Debug.Assert(tilingAttribute != null,
                         "Expected tilingAttribute to be non-null");

            string value = tilingAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < TILING_VALUES.Length; i++) {
                    if (TILING_VALUES[i].Equals(value)) {
                        tilingCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.InitScrollingUI"]/*' />
        /// <devdoc>
        ///     Loads the image scrolling value (css attribute: background-attachment).
        /// </devdoc>
        private void InitScrollingUI() {
            Debug.Assert(IsInitMode() == true,
                         "initScrollingUI called when page is not in init mode");

            scrollingCombo.SelectedIndex = -1;

            Debug.Assert(scrollingAttribute != null,
                         "Expected scrollingAttribute to be non-null");

            string value = scrollingAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < SCROLLING_VALUES.Length; i++) {
                    if (SCROLLING_VALUES[i].Equals(value)) {
                        scrollingCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitPositionXUI() {
            Debug.Assert(IsInitMode() == true,
                         "initPositionXUI called when page is not in init mode");

            hPosCombo.SelectedIndex = -1;
            hPosUnit.Value = null;

            Debug.Assert(hPosAttribute != null,
                         "Expected hPosAttribute to be non-null");

            string value = hPosAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < HPOS_VALUES.Length; i++) {
                    if (HPOS_VALUES[i].Equals(value)) {
                        hPosCombo.SelectedIndex = i;
                        return;
                    }
                }
                hPosUnit.Value = value;
                value = hPosUnit.Value;
                if ((value != null) && (value.Length != 0))
                    hPosCombo.SelectedIndex = IDX_POS_CUSTOM;
            }
        }

        private void InitPositionYUI() {
            Debug.Assert(IsInitMode() == true,
                         "initPositionYUI called when page is not in init mode");

            vPosCombo.SelectedIndex = -1;
            vPosUnit.Value = null;

            Debug.Assert(vPosAttribute != null,
                         "Expected vPosAttribute to be non-null");

            string value = vPosAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < VPOS_VALUES.Length; i++) {
                    if (VPOS_VALUES[i].Equals(value)) {
                        vPosCombo.SelectedIndex = i;
                        return;
                    }
                }
                vPosUnit.Value = value;
                value = vPosUnit.Value;
                if ((value != null) && (value.Length != 0))
                    vPosCombo.SelectedIndex = IDX_POS_CUSTOM;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveBackColorUI() {
            string value;

            if (transparentCheck.Checked)
                value = COLOR_TRANSPARENT;
            else
                value = backColorCombo.Color;

            return value;
        }

        private string SaveImageUI() {
            string value = null;

            if (imageNoneCheck.Checked) {
                value = IMAGE_NONE;
            }
            else {
                value = StylePageUtil.CreateUrlProperty(imageUrlEdit.Text.Trim());
            }

            return value;
        }

        private string SaveTilingUI() {
            string value = null;

            if (tilingCombo.IsSet()) {
                int index = tilingCombo.SelectedIndex;

                Debug.Assert((index >= 1) && (index < TILING_VALUES.Length),
                             "Invalid index for image tiling");
                value = TILING_VALUES[index];
            }
            else
                value = "";

            return value;
        }

        private string SaveScrollingUI() {
            string value;

            if (scrollingCombo.IsSet()) {
                int index = scrollingCombo.SelectedIndex;

                Debug.Assert((index >= 1) && (index < SCROLLING_VALUES.Length),
                             "Invalid index for image scrolling");
                value = SCROLLING_VALUES[index];
            }
            else
                value = "";

            return value;
        }

        private string SavePositionXUI() {
            string value = null;

            if (hPosCombo.IsSet()) {
                int index = hPosCombo.SelectedIndex;

                Debug.Assert(((index >= 1) && (index < HPOS_VALUES.Length)) ||
                             (index == IDX_POS_CUSTOM),
                             "Invalid index for image horizontal position");
                if (index != IDX_POS_CUSTOM)
                    value = HPOS_VALUES[index];
                else
                    value = hPosUnit.Value;
            }
            if (value == null)
                value = "";

            return value;
        }

        private string SavePositionYUI() {
            string value = null;

            if (vPosCombo.IsSet()) {
                int index = vPosCombo.SelectedIndex;

                Debug.Assert(((index >= 1) && (index < VPOS_VALUES.Length)) ||
                             (index == IDX_POS_CUSTOM),
                             "Invalid index for image vertical position");
                if (index != IDX_POS_CUSTOM)
                    value = VPOS_VALUES[index];
                else
                    value = vPosUnit.Value;
            }
            if (value == null)
                value = "";

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to update the preview

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.UpdateBackColorPreview"]/*' />
        /// <devdoc>
        ///     Updates the preview to reflect the selected background color.
        /// </devdoc>
        private void UpdateBackColorPreview() {
            if (previewStyle == null)
                return;

            string value = SaveBackColorUI();
            Debug.Assert(value != null,
                         "saveBackColorUI returned null!");

            try {
                previewStyle.SetBackgroundColor(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::UpdateBackColorPreview\n\t" + e.ToString());
            }
            previewPending = false;
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.UpdateImagePreview"]/*' />
        /// <devdoc>
        ///     Updates the preview to reflect the selected background image.
        /// </devdoc>
        private void UpdateImagePreview() {
            if (previewStyle == null)
                return;

            string value = SaveImageUI();
            Debug.Assert(value != null,
                         "saveImageUI returned null!");

            try {
                previewStyle.SetBackgroundImage(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::UpdateImagePreview\n\t" + e.ToString());
            }
            previewPending = false;
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.UpdateTilingPreview"]/*' />
        /// <devdoc>
        ///     Updates the preview to reflect the selected image tiling value.
        /// </devdoc>
        private void UpdateTilingPreview() {
            if (previewStyle == null)
                return;

            string value = SaveTilingUI();
            Debug.Assert(value != null,
                         "saveTilingUI returned null!");

            try {
                previewStyle.SetBackgroundRepeat(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::updateTilingPreview\n\t" + e.ToString());
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.UpdateScrollingPreview"]/*' />
        /// <devdoc>
        ///     Updates the preview to reflect the selected image scrolling value.
        /// </devdoc>
        private void UpdateScrollingPreview() {
            if (previewStyle == null)
                return;

            string value = SaveScrollingUI();
            Debug.Assert(value != null,
                         "saveScrollingUI returned null!");

            try {
                previewStyle.SetBackgroundAttachment(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::updateScrollingPreview\n\t" + e.ToString());
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.UpdatePositionXPreview"]/*' />
        /// <devdoc>
        ///     Updates the preview to reflect the selected background position.
        /// </devdoc>
        private void UpdatePositionXPreview() {
            if (previewStyle == null)
                return;

            string value = SavePositionXUI();
            Debug.Assert(value != null,
                         "savePositionXUI returned null!");

            try {
                previewStyle.SetBackgroundPositionX(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::updatePositionXPreview\n\t" + e.ToString());
            }
        }

        private void UpdatePositionYPreview() {
            if (previewStyle == null)
                return;

            string strValue = SavePositionYUI();
            Debug.Assert(strValue != null,
                         "savePositionYUI returned null!");

            try {
                previewStyle.SetBackgroundPositionY(strValue);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleBackPage::updatePositionYPreview\n\t" + e.ToString());
            }
        }



        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedTransparent"]/*' />
        /// <devdoc>
        ///     Handles changes to the transparent background selection to set the dirty
        ///     state and update the preview. Also updates the enabled state of the
        ///     background color dropdown.
        /// </devdoc>
        private void OnChangedTransparent(object source, EventArgs e) {
            if (IsInitMode())
                return;
            backColorAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(true, false);
            UpdateBackColorPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedBackColor"]/*' />
        /// <devdoc>
        ///     Handles changes to the background color when a new color is typed in.
        ///     Marks the dirty state, and marks control updated. Preview will be updated
        ///     when user tabs away to a different color.
        /// </devdoc>
        private void OnChangedBackColor(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (previewPending == false) {
                backColorAttribute.Dirty = true;
                previewPending = true;
                SetDirty();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnLostFocusBackColor"]/*' />
        /// <devdoc>
        ///     Updates the preview window if the background color was modified, before
        ///     it lost focus.
        /// </devdoc>
        private void OnLostFocusBackColor(object source, EventArgs e) {
            if (previewPending) {
                UpdateBackColorPreview();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnSelChangedBackColor"]/*' />
        /// <devdoc>
        ///     Handles the event when a new background color is selected from the
        ///     background color dropdown.
        /// </devdoc>
        private void OnSelChangedBackColor(object source, EventArgs e) {
            if (IsInitMode())
                return;
            backColorAttribute.Dirty = true;
            SetDirty();
            UpdateBackColorPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnClickColorPicker"]/*' />
        /// <devdoc>
        ///     Brings up the color picker to select a background color
        /// </devdoc>
        private void OnClickColorPicker(object source, EventArgs e) {
            string color = InvokeColorPicker(backColorCombo.Color);

            if (color != null) {
                backColorCombo.Color = color;
                backColorAttribute.Dirty = true;
                SetDirty();
                UpdateBackColorPreview();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedNone"]/*' />
        /// <devdoc>
        ///     Handles changes to the background image to update the preview and
        ///     set the dirty state. Also sets the enabled state of the Url editbox.
        /// </devdoc>
        private void OnChangedNone(object source, EventArgs e) {
            if (IsInitMode())
                return;
            imageAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, true);
            UpdateImagePreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedUrl"]/*' />
        /// <devdoc>
        ///     Handles changes to the background image as a new Url is typed in.
        ///     Marks the dirty state and the control as updated. The preview will be
        ///     updated when the user tabs away to another control.
        /// </devdoc>
        private void OnChangedUrl(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if (previewPending == false) {
                imageAttribute.Dirty = true;
                previewPending = true;
                SetDirty();
            }
            SetEnabledState(false, true);
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnLostFocusUrl"]/*' />
        /// <devdoc>
        ///     Updates the preview if a new Url was entered before the control lost
        ///     focus.
        /// </devdoc>
        private void OnLostFocusUrl(object source, EventArgs e) {
            if (previewPending) {
                UpdateImagePreview();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnClickUrlPicker"]/*' />
        /// <devdoc>
        ///     Brings up the Url picker to select a Url.
        /// </devdoc>
        private void OnClickUrlPicker(object source, EventArgs e) {
            string url = imageUrlEdit.Text.Trim();

            url = InvokeUrlPicker(url,
                                  URLPickerFlags.URLP_CUSTOMTITLE | URLPickerFlags.URLP_DISALLOWASPOBJMETHODTYPE,
                                  SR.GetString(SR.BgSP_BackImageURLSelect),
                                  SR.GetString(SR.BgSP_BackImageURLFilter));
            if (url != null) {
                imageUrlEdit.Text = url;
                imageAttribute.Dirty = true;
                SetDirty();
                UpdateImagePreview();
            }
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnSelChangedTiling"]/*' />
        /// <devdoc>
        ///     Handles changes to the image tiling selection to mark the dirty
        ///     state and update the preview.
        /// </devdoc>
        private void OnSelChangedTiling(object source, EventArgs e) {
            if (IsInitMode())
                return;
            tilingAttribute.Dirty = true;
            SetDirty();
            UpdateTilingPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnSelChangedScrolling"]/*' />
        /// <devdoc>
        ///     Handles changes to the image scrolling selection to mark the dirty
        ///     state and update the preview.
        /// </devdoc>
        private void OnSelChangedScrolling(object source, EventArgs e) {
            if (IsInitMode())
                return;
            scrollingAttribute.Dirty = true;
            SetDirty();
            UpdateScrollingPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnSelChangedHPos"]/*' />
        /// <devdoc>
        ///     Handles changes to the horizontal position selection to mark the dirty
        ///     state and update the preview. Also sets the enabled state of the custom
        ///     horizontal position control.
        /// </devdoc>
        private void OnSelChangedHPos(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if ((hPosCombo.SelectedIndex == IDX_POS_CUSTOM) &&
                (hPosUnit.Value == null))
                hPosUnit.Value = "50%";
            hPosAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, true);
            UpdatePositionXPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedHPos"]/*' />
        /// <devdoc>
        ///     Handles changes to the custom horizontal position to mark the dirty state
        ///     and update the preview.
        /// </devdoc>
        private void OnChangedHPos(object source, EventArgs e) {
            if (IsInitMode())
                return;
            hPosAttribute.Dirty = true;
            SetDirty();
            if (e != null)
                UpdatePositionXPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnSelChangedVPos"]/*' />
        /// <devdoc>
        ///     Handles changes to the vertical position selection to mark the dirty
        ///     state and update the preview. Also sets the enabled state of the custom
        ///     horizontal position control.
        /// </devdoc>
        private void OnSelChangedVPos(object source, EventArgs e) {
            if (IsInitMode())
                return;
            if ((vPosCombo.SelectedIndex == IDX_POS_CUSTOM) &&
                (vPosUnit.Value == null))
                vPosUnit.Value = "50%";
            vPosAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, true);
            UpdatePositionYPreview();
        }

        /// <include file='doc\BackgroundStylePage.uex' path='docs/doc[@for="BackgroundStylePage.OnChangedVPos"]/*' />
        /// <devdoc>
        ///     Handles changes to the custom vertical position to mark the dirty state
        ///     and update the preview.
        /// </devdoc>
        private void OnChangedVPos(object source, EventArgs e) {
            if (IsInitMode())
                return;
            vPosAttribute.Dirty = true;
            SetDirty();
            if (e != null)
                UpdatePositionYPreview();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to persist attributes

        private void SaveBackColor() {
            string value = SaveBackColorUI();
            Debug.Assert(value != null,
                         "saveBackColorUI returned null!");

            backColorAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveImage() {
            string value = SaveImageUI();
            Debug.Assert(value != null,
                         "saveImageUI returned null!");

            IStyleBuilderStyle[] styles = GetSelectedStyles();
            bool noImage = (value == IMAGE_NONE);
            imageAttribute.SaveAttribute(styles, value);
            if (noImage) {
                tilingAttribute.ResetAttribute(styles, false);
                tilingAttribute.Dirty = false;

                scrollingAttribute.ResetAttribute(styles, false);
                scrollingAttribute.Dirty = false;
                
                hPosAttribute.ResetAttribute(styles, false);
                hPosAttribute.Dirty = false;

                vPosAttribute.ResetAttribute(styles, false);
                vPosAttribute.Dirty = false;
            }
        }

        private void SaveTiling() {
            string value = SaveTilingUI();
            Debug.Assert(value != null,
                         "saveTilingUI returned null!");

            tilingAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveScrolling() {
            string value = SaveScrollingUI();
            Debug.Assert(value != null,
                         "saveScrollingUI returned null!");

            scrollingAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SavePositionX() {
            string value = SavePositionXUI();
            Debug.Assert(value != null,
                         "savePositionXUI returned null!");

            hPosAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SavePositionY() {
            string value = SavePositionYUI();
            Debug.Assert(value != null,
                         "savePositionYUI returned null!");

            vPosAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\positionstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="PositionStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// PositionStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;

    /// <include file='doc\PositionStylePage.uex' path='docs/doc[@for="PositionStylePage"]/*' />
    /// <devdoc>
    ///     PositionStylePage
    ///     The standard edges page used in the StyleBuilder to edit position attributes
    ///     of a CSS style and VSForms element.
    /// </devdoc>
    internal sealed class PositionStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Position";

        // Position Mode Constants
        private const int IDX_POS_STATIC = 1;
        private const int IDX_POS_RELATIVE = 2;
        private const int IDX_POS_ABSOLUTE = 3;

        private readonly static string[] POSITION_VALUES = new string[]
        {
            null, "static", "relative", "absolute"
        };

        // ZIndex Constants
        private readonly static string ZINDEX_AUTO_VALUE = "auto";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute positionAttribute;
        private CSSAttribute topAttribute;
        private CSSAttribute leftAttribute;
        private CSSAttribute widthAttribute;
        private CSSAttribute heightAttribute;
        private CSSAttribute zIndexAttribute;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private UnsettableComboBox positionCombo;
        private PictureBoxEx positionPicture;
        private UnitControl leftUnit;
        private UnitControl topUnit;
        private UnitControl widthUnit;
        private UnitControl heightUnit;
        private NumberEdit zIndexEdit;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\PositionStylePage.uex' path='docs/doc[@for="PositionStylePage.PositionStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new PositionStylePage
        /// </devdoc>
        public PositionStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(PositionStylePage), "PositionPage.ico"));
            SetHelpKeyword(PositionStylePage.HELP_KEYWORD);
            SetSupportsPreview(false);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\PositionStylePage.uex' path='docs/doc[@for="PositionStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Label positionLabel = new Label();
            Label leftLabel = new Label();
            Label topLabel = new Label();
            Label widthLabel = new Label();
            Label heightLabel = new Label();
            Label zIndexLabel = new Label();
            ImageList positionImages = new ImageList();
            positionImages.ImageSize = new Size(34, 34);

            positionCombo = new UnsettableComboBox();
            positionPicture = new PictureBoxEx();
            leftUnit = new UnitControl();
            topUnit = new UnitControl();
            widthUnit = new UnitControl();
            heightUnit = new UnitControl();
            zIndexEdit = new NumberEdit();

            positionImages.Images.AddStrip(new Bitmap(typeof(PositionStylePage), "PropPosition.bmp"));
            positionPicture.Location = new Point(4, 9);
            positionPicture.Size = new Size(36, 36);
            positionPicture.TabIndex = 0;
            positionPicture.TabStop = false;
            positionPicture.Images = positionImages;

            positionLabel.Location = new Point(44, 8);
            positionLabel.Size = new Size(240, 16);
            positionLabel.TabIndex = 1;
            positionLabel.TabStop = false;
            positionLabel.Text = SR.GetString(SR.PosSP_PosModeLabel);

            positionCombo.Location = new Point(44, 24);
            positionCombo.Size = new Size(200, 21);
            positionCombo.TabIndex = 2;
            positionCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            positionCombo.Items.AddRange(new object[]
                                      {
                                          SR.GetString(SR.PosSP_PosModeCombo_1),
                                          SR.GetString(SR.PosSP_PosModeCombo_2),
                                          SR.GetString(SR.PosSP_PosModeCombo_3)
                                      });
            positionCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangePosition);

            topLabel.Location = new Point(46, 61);
            topLabel.Size = new Size(60, 16);
            topLabel.TabIndex = 3;
            topLabel.TabStop = false;
            topLabel.Text = SR.GetString(SR.PosSP_TopLabel);

            topUnit.Location = new Point(108, 57);
            topUnit.Size = new Size(88, 21);
            topUnit.TabIndex = 4;
            topUnit.DefaultUnit = UnitControl.UNIT_PX;
            topUnit.MinValue = -32768;
            topUnit.MaxValue = 32767;
            topUnit.Changed += new EventHandler(this.OnChangedTop);

            heightLabel.Location = new Point(220, 61);
            heightLabel.Size = new Size(60, 16);
            heightLabel.TabIndex = 5;
            heightLabel.TabStop = false;
            heightLabel.Text = SR.GetString(SR.PosSP_HeightLabel);

            heightUnit.Location = new Point(282, 57);
            heightUnit.Size = new Size(88, 21);
            heightUnit.TabIndex = 6;
            heightUnit.DefaultUnit = UnitControl.UNIT_PX;
            heightUnit.AllowNegativeValues = false;
            heightUnit.MinValue = -32768;
            heightUnit.MaxValue = 32767;
            heightUnit.Changed += new EventHandler(this.OnChangedHeight);

            leftLabel.Location = new Point(46, 84);
            leftLabel.Size = new Size(60, 16);
            leftLabel.TabIndex = 7;
            leftLabel.TabStop = false;
            leftLabel.Text = SR.GetString(SR.PosSP_LeftLabel);

            leftUnit.Location = new Point(108, 80);
            leftUnit.Size = new Size(88, 21);
            leftUnit.TabIndex = 8;
            leftUnit.DefaultUnit = UnitControl.UNIT_PX;
            leftUnit.MinValue = -32768;
            leftUnit.MaxValue = 32767;
            leftUnit.Changed += new EventHandler(this.OnChangedLeft);

            widthLabel.Location = new Point(220, 84);
            widthLabel.Size = new Size(60, 16);
            widthLabel.TabIndex = 9;
            widthLabel.TabStop = false;
            widthLabel.Text = SR.GetString(SR.PosSP_WidthLabel);

            widthUnit.Location = new Point(282, 80);
            widthUnit.Size = new Size(88, 21);
            widthUnit.TabIndex = 10;
            widthUnit.DefaultUnit = UnitControl.UNIT_PX;
            widthUnit.AllowNegativeValues = false;
            widthUnit.MinValue = -32768;
            widthUnit.MaxValue = 32767;
            widthUnit.Changed += new EventHandler(this.OnChangedWidth);

            zIndexLabel.Location = new Point(46, 112);
            zIndexLabel.Size = new Size(100, 16);
            zIndexLabel.TabIndex = 11;
            zIndexLabel.TabStop = false;
            zIndexLabel.Text = SR.GetString(SR.PosSP_ZIndexLabel);

            zIndexEdit.Location = new Point(46, 130);
            zIndexEdit.Size = new Size(60, 20);
            zIndexEdit.TabIndex = 12;
            zIndexEdit.MaxLength = 6;
            zIndexEdit.AllowDecimal = false;
            zIndexEdit.TextChanged += new EventHandler(this.OnChangedZIndex);

            this.Controls.Clear();                                   
            this.Controls.AddRange(new Control[] {
                                    zIndexLabel,
                                    zIndexEdit,
                                    widthLabel,
                                    widthUnit,
                                    leftLabel,
                                    leftUnit,
                                    heightLabel,
                                    heightUnit,
                                    topLabel,
                                    topUnit,
                                    positionPicture,
                                    positionLabel,
                                    positionCombo
                                    });
        }

        /// <include file='doc\PositionStylePage.uex' path='docs/doc[@for="PositionStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not been created already
            if (positionAttribute == null) {
                positionAttribute = new CSSAttribute(CSSAttribute.CSSATTR_POSITION);
                leftAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LEFT);
                topAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TOP);
                widthAttribute = new CSSAttribute(CSSAttribute.CSSATTR_WIDTH);
                heightAttribute = new CSSAttribute(CSSAttribute.CSSATTR_HEIGHT);
                zIndexAttribute = new CSSAttribute(CSSAttribute.CSSATTR_ZINDEX);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            positionAttribute.LoadAttribute(styles);
            leftAttribute.LoadAttribute(styles);
            topAttribute.LoadAttribute(styles);
            widthAttribute.LoadAttribute(styles);
            heightAttribute.LoadAttribute(styles);
            zIndexAttribute.LoadAttribute(styles);

            // initialize the ui with the attributes loaded
            InitPositionModeUI();
            InitDimensionUI(leftAttribute, leftUnit);
            InitDimensionUI(topAttribute, topUnit);
            InitDimensionUI(widthAttribute, widthUnit);
            InitDimensionUI(heightAttribute, heightUnit);
            InitZIndexUI();

            SetEnabledState();

            SetInitMode(false);
        }

        /// <include file='doc\PositionStylePage.uex' path='docs/doc[@for="PositionStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            if (positionAttribute.Dirty)
                SavePositionMode();
            if (leftAttribute.Dirty)
                SaveDimension(leftAttribute, leftUnit);
            if (topAttribute.Dirty)
                SaveDimension(topAttribute, topUnit);
            if (widthAttribute.Dirty)
                SaveDimension(widthAttribute, widthUnit);
            if (heightAttribute.Dirty)
                SaveDimension(heightAttribute, heightUnit);
            if (zIndexAttribute.Dirty)
                SaveZIndex();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.PosSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState() {
            int nIndexPos = positionCombo.SelectedIndex;
            bool fEnabled = (positionCombo.IsSet() &&
                                nIndexPos != IDX_POS_STATIC);

            // enabled when position is relative or absolute
            leftUnit.Enabled = fEnabled;
            topUnit.Enabled = fEnabled;

            // enabled when position is absolute
            zIndexEdit.Enabled = nIndexPos == IDX_POS_ABSOLUTE;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitDimensionUI(CSSAttribute ai, UnitControl unitDim) {
            Debug.Assert(IsInitMode() == true,
                         "initDimensionUI called when page is not in init mode");

            unitDim.Value = null;

            Debug.Assert(ai != null,
                         "Expected ai to be non-null");

            string value = ai.Value;
            if ((value != null) && (value.Length != 0))
                unitDim.Value = value;
        }

        private void InitPositionModeUI() {
            Debug.Assert(IsInitMode() == true,
                         "initPositionModeUI called when page is not in init mode");

            positionCombo.SelectedIndex = -1;
            positionPicture.CurrentIndex = -1;

            Debug.Assert(positionAttribute != null,
                         "Expected positionAttribute to be non-null");

            string value = positionAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < POSITION_VALUES.Length; i++) {
                    if (POSITION_VALUES[i].Equals(value)) {
                        positionCombo.SelectedIndex = i;
                        positionPicture.CurrentIndex = i - 1;
                        break;
                    }
                }
            }
        }

        private void InitZIndexUI() {
            Debug.Assert(IsInitMode() == true,
                         "initZIndexUI called when page is not in init mode");

            zIndexEdit.Clear();

            Debug.Assert(zIndexAttribute != null,
                         "Expected zIndexAttribute to be non-null");

            string value = zIndexAttribute.Value;
            if ((value != null) && (value.Length != 0) &&
                (!value.Equals(ZINDEX_AUTO_VALUE)))
                zIndexEdit.Text = value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveDimensionUI(UnitControl unitDim) {
            string value = unitDim.Value;

            return(value != null) ? value : "";
        }

        private string SavePositionModeUI() {
            string value;

            if (positionCombo.IsSet()) {
                int index = positionCombo.SelectedIndex;
                Debug.Assert((index >= 1) && (index < POSITION_VALUES.Length),
                             "Invalid index for position mode");

                value = POSITION_VALUES[index];
            }
            else
                value = "";

            return value;
        }

        private string SaveZIndexUI() {
            string value = zIndexEdit.Text.Trim();

            return value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnChangedLeft(object source, EventArgs e) {
            if (IsInitMode())
                return;
            leftAttribute.Dirty = true;
            SetDirty();
        }

        private void OnChangedHeight(object source, EventArgs e) {
            if (IsInitMode())
                return;
            heightAttribute.Dirty = true;
            SetDirty();
        }

        private void OnChangedTop(object source, EventArgs e) {
            if (IsInitMode())
                return;
            topAttribute.Dirty = true;
            SetDirty();
        }

        private void OnChangedWidth(object source, EventArgs e) {
            if (IsInitMode())
                return;
            widthAttribute.Dirty = true;
            SetDirty();
        }

        private void OnChangedZIndex(object source, EventArgs e) {
            if (IsInitMode())
                return;
            zIndexAttribute.Dirty = true;
            SetDirty();
        }

        private void OnSelChangePosition(object source, EventArgs e) {
            if (IsInitMode())
                return;

            int selectedIndex = positionCombo.SelectedIndex - 1;
            if (selectedIndex < 0)
                selectedIndex = -1;
            positionPicture.CurrentIndex = selectedIndex;

            positionAttribute.Dirty = true;
            SetDirty();
            SetEnabledState();
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to persist attributes

        private void SaveDimension(CSSAttribute ai, UnitControl unitDim) {
            string value = SaveDimensionUI(unitDim);
            Debug.Assert(value != null,
                         "saveDimensionUI returned null!");

            ai.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SavePositionMode() {
            string value = SavePositionModeUI();
            Debug.Assert(value != null,
                         "savePositionUI returned null!");

            positionAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveZIndex() {
            string value = SaveZIndexUI();
            Debug.Assert(value != null,
                         "saveZIndexUI returned null!");

            zIndexAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designerui\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\edgesstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="EdgesStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// EdgesStylePage.cs
//
// 12/27/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Interop.Trident;

    /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage"]/*' />
    /// <devdoc>
    ///     The standard edges page used in the StyleBuilder to edit margins, padding
    ///     and border attributes of a CSS style.
    /// </devdoc>
    internal sealed class EdgesStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Edges";

        // Edges
        private const int EDGE_TOP = 0;
        private const int EDGE_BOTTOM = 1;
        private const int EDGE_LEFT = 2;
        private const int EDGE_RIGHT = 3;
        private const int EDGE_ALL = 4;

        private const int EDGE_FIRST = EDGE_TOP;
        private const int EDGE_LAST = EDGE_RIGHT;

        private readonly static string[] EDGE_NAMES = new string[] {
            "Top", "Bottom", "Left", "Right"
        };

        // Border Style constants
        private const int IDX_BSTYLE_NONE = 1;
        private const int IDX_BSTYLE_SOLID = 2;
        private const int IDX_BSTYLE_DOUBLE = 3;
        private const int IDX_BSTYLE_GROOVE = 4;
        private const int IDX_BSTYLE_RIDGE = 5;
        private const int IDX_BSTYLE_INSET = 6;
        private const int IDX_BSTYLE_OUTSET = 7;

        internal readonly static string[] BORDERSTYLE_VALUES = new string[] {
            null, "none", "solid", "double", "groove", "ridge", "inset", "outset"
        };

        // Border Width constants
        private const int IDX_BWIDTH_THIN = 1;
        private const int IDX_BWIDTH_MEDIUM = 2;
        private const int IDX_BWIDTH_THICK = 3;
        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.IDX_BWIDTH_CUSTOM"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int IDX_BWIDTH_CUSTOM = 4;

        internal readonly static string[] BORDERWIDTH_VALUES = new string[] {
            null, "thin", "medium", "thick"
        };

        // Preview Constants
        private readonly static string PREVIEW_TEMPLATE =
            "<table border=0 cellspacing=0 cellpadding=0 width=100% height=100% style=\"background-color: window\">" +
                "<tr><td align=center valign=middle>" +
                    "<table border=0 cellspacing=0 cellpadding=0 style=\"background-color: buttonface\">" +
                        "<tr id=\"trMargin1\">" +
                            "<td id=\"tdTopLeftMargin\" style=\"height: 0px\"></td>" +
                            "<td></td>" +
                            "<td id=\"tdRightMargin\"></td>" +
                        "</tr>" +
                        "<tr>" +
                            "<td id=\"tdMargin2\"></td>" +
                            "<td id=\"tdBorder\" style=\"background-color: scrollbar\">" +
                                "<div id=\"divPadding\">" +
                                    "<span style=\"background-color: navy; height: 16px; width: 64px\"></span>" +
                                "</div>" +
                            "</td>" +
                            "<td id=\"tdMargin3\"></td>" +
                        "</tr>" +
                        "<tr id=\"trMargin4\">" +
                            "<td id=\"tdBottomMargin\" style=\"height: 0px\"></td>" +
                            "<td></td>" +
                            "<td></td>" +
                        "</tr>" +
                    "</table>" +
                "</td></tr>" +
            "</table>";
        private readonly static string PREVIEW_TLMARGIN_ELEM_ID = "tdTopLeftMargin";
        private readonly static string PREVIEW_RMARGIN_ELEM_ID = "tdRightMargin";
        private readonly static string PREVIEW_BMARGIN_ELEM_ID = "tdBottomMargin";
        private readonly static string PREVIEW_PADDING_ELEM_ID = "divPadding";
        private readonly static string PREVIEW_BORDER_ELEM_ID = "tdBorder";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute[] paddingAttributes = new CSSAttribute[4];
        private CSSAttribute[] marginAttributes = new CSSAttribute[4];
        private CSSAttribute[] borderStyleAttributes = new CSSAttribute[4];
        private CSSAttribute[] borderWidthAttributes = new CSSAttribute[4];
        private CSSAttribute[] borderColorAttributes = new CSSAttribute[4];

        private bool previewPending;

        private BorderData[] borderData;

        private IHTMLStyle tlMarginPreviewStyle;
        private IHTMLStyle rMarginPreviewStyle;
        private IHTMLStyle bMarginPreviewStyle;
        private IHTMLStyle paddingPreviewStyle;
        private IHTMLStyle borderPreviewStyle;

        private bool borderUIInitMode;

        ///////////////////////////////////////////////////////////////////////////
        // UI Members

        private UnitControl marginTopUnit;
        private UnitControl marginBottomUnit;
        private UnitControl marginLeftUnit;
        private UnitControl marginRightUnit;
        private UnitControl paddingTopUnit;
        private UnitControl paddingBottomUnit;
        private UnitControl paddingLeftUnit;
        private UnitControl paddingRightUnit;
        private ComboBox borderSelectionCombo;
        private PictureBoxEx borderSelectionPicture;
        private UnsettableComboBox borderStyleCombo;
        private UnsettableComboBox cbxBWidth;
        private ColorComboBox borderColorCombo;
        private Button colorPickerButton;
        private UnitControl borderWidthUnit;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.EdgesStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new EdgesStylePage
        /// </devdoc>
        public EdgesStylePage()
            : base() {
            borderData = new BorderData[4];
            for (int i = EDGE_FIRST; i <= EDGE_LAST; i++)
                borderData[i] = new BorderData();

            InitForm();
            SetIcon(new Icon(typeof(EdgesStylePage), "EdgesPage.ico"));
            SetHelpKeyword(EdgesStylePage.HELP_KEYWORD);
            SetDefaultSize(Size);

            borderUIInitMode = false;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.ActivatePage"]/*' />
        /// <devdoc>
        ///     The page is now the currently active page in the StyleBuilder.
        ///     Be sure to call super.activatePage, so that the page is made visible.
        /// </devdoc>
        protected override void ActivatePage() {
            base.ActivatePage();

            // initialize the preview
            IStyleBuilderPreview preview = null;

            if (Site != null)
                preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));

            if (preview != null) {
                try {
                    Microsoft.VisualStudio.Interop.Trident.IHTMLElement previewElem = preview.GetPreviewElement();
                    Microsoft.VisualStudio.Interop.Trident.IHTMLElement elem;

                    previewElem.SetInnerHTML(PREVIEW_TEMPLATE);

                    elem = preview.GetElement(PREVIEW_TLMARGIN_ELEM_ID);
                    if (elem != null) {
                        tlMarginPreviewStyle = elem.GetStyle();
                    }

                    elem = preview.GetElement(PREVIEW_RMARGIN_ELEM_ID);
                    if (elem != null) {
                        rMarginPreviewStyle = elem.GetStyle();
                    }

                    elem = preview.GetElement(PREVIEW_BMARGIN_ELEM_ID);
                    if (elem != null) {
                        bMarginPreviewStyle = elem.GetStyle();
                    }

                    elem = preview.GetElement(PREVIEW_PADDING_ELEM_ID);
                    if (elem != null) {
                        paddingPreviewStyle = elem.GetStyle();
                    }

                    elem = preview.GetElement(PREVIEW_BORDER_ELEM_ID);
                    if (elem != null) {
                        borderPreviewStyle = elem.GetStyle();
                    }
                } catch (Exception) {
                    tlMarginPreviewStyle = null;
                    rMarginPreviewStyle = null;
                    bMarginPreviewStyle = null;
                    paddingPreviewStyle = null;
                    borderPreviewStyle = null;
                    return;
                }

                Debug.Assert((tlMarginPreviewStyle != null) &&
                             (rMarginPreviewStyle != null) &&
                             (bMarginPreviewStyle != null) &&
                             (paddingPreviewStyle != null) &&
                             (borderPreviewStyle != null),
                             "Expected cached style references to be non-null");

                // update initial preview
                UpdateMarginPreview(EDGE_TOP);
                UpdateMarginPreview(EDGE_BOTTOM);
                UpdateMarginPreview(EDGE_LEFT);
                UpdateMarginPreview(EDGE_RIGHT);

                UpdatePaddingPreview(EDGE_TOP);
                UpdatePaddingPreview(EDGE_BOTTOM);
                UpdatePaddingPreview(EDGE_LEFT);
                UpdatePaddingPreview(EDGE_RIGHT);

                UpdateBorderStylePreview(EDGE_ALL);
                UpdateBorderColorPreview(EDGE_ALL);
                UpdateBorderWidthPreview(EDGE_ALL);
            }
        }

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Label marginsLabel = new GroupLabel();
            Label marginTopLabel = new Label();
            Label marginBottomLabel = new Label();
            Label marginLeftLabel = new Label();
            Label marginRightLabel = new Label();
            Label paddingLabel = new GroupLabel();
            Label paddingTopLabel = new Label();
            Label paddingBottomLabel = new Label();
            Label paddingLeftLabel = new Label();
            Label paddingRightLabel = new Label();
            Label bordersLabel = new GroupLabel();
            Label borderSelectionLabel = new Label();
            Label borderStyleLabel = new Label();
            Label borderWidthLabel = new Label();
            Label borderColorLabel = new Label();
            ImageList borderSelectionImages = new ImageList();
            borderSelectionImages.ImageSize = new Size(34, 34);

            marginTopUnit = new UnitControl();
            marginBottomUnit = new UnitControl();
            marginLeftUnit = new UnitControl();
            marginRightUnit = new UnitControl();
            paddingTopUnit = new UnitControl();
            paddingBottomUnit = new UnitControl();
            paddingLeftUnit = new UnitControl();
            paddingRightUnit = new UnitControl();
            borderSelectionCombo = new ComboBox();
            borderSelectionPicture = new PictureBoxEx();
            borderStyleCombo = new UnsettableComboBox();
            cbxBWidth = new UnsettableComboBox();
            borderColorCombo = new ColorComboBox();
            colorPickerButton = new Button();
            borderWidthUnit = new UnitControl();

            marginsLabel.Location = new Point(4, 4);
            marginsLabel.Size = new Size(166, 16);
            marginsLabel.TabIndex = 0;
            marginsLabel.TabStop = false;
            marginsLabel.Text = SR.GetString(SR.EdgesSP_MarginsLabel);

            marginTopLabel.Location = new Point(8, 24);
            marginTopLabel.Size = new Size(62, 16);
            marginTopLabel.TabIndex = 1;
            marginTopLabel.TabStop = false;
            marginTopLabel.Text = SR.GetString(SR.EdgesSP_EdgeTopLabel);

            marginTopUnit.Location = new Point(74, 20);
            marginTopUnit.Size = new Size(88, 21);
            marginTopUnit.TabIndex = 2;
            marginTopUnit.DefaultUnit = UnitControl.UNIT_PX;
            marginTopUnit.MinValue = -1024;
            marginTopUnit.MaxValue = 1024;
            marginTopUnit.Changed += new EventHandler(this.OnChangedMargin);

            marginBottomLabel.Location = new Point(8, 48);
            marginBottomLabel.Size = new Size(62, 16);
            marginBottomLabel.TabIndex = 2;
            marginBottomLabel.TabStop = false;
            marginBottomLabel.Text = SR.GetString(SR.EdgesSP_EdgeBottomLabel);

            marginBottomUnit.Location = new Point(74, 44);
            marginBottomUnit.Size = new Size(88, 21);
            marginBottomUnit.TabIndex = 3;
            marginBottomUnit.DefaultUnit = UnitControl.UNIT_PX;
            marginBottomUnit.MinValue = -1024;
            marginBottomUnit.MaxValue = 1024;
            marginBottomUnit.Changed += new EventHandler(this.OnChangedMargin);

            marginLeftLabel.Location = new Point(8, 72);
            marginLeftLabel.Size = new Size(62, 16);
            marginLeftLabel.TabIndex = 4;
            marginLeftLabel.TabStop = false;
            marginLeftLabel.Text = SR.GetString(SR.EdgesSP_EdgeLeftLabel);

            marginLeftUnit.Location = new Point(74, 68);
            marginLeftUnit.Size = new Size(88, 21);
            marginLeftUnit.TabIndex = 5;
            marginLeftUnit.DefaultUnit = UnitControl.UNIT_PX;
            marginLeftUnit.MinValue = -1024;
            marginLeftUnit.MaxValue = 1024;
            marginLeftUnit.Changed += new EventHandler(this.OnChangedMargin);

            marginRightLabel.Location = new Point(8, 96);
            marginRightLabel.Size = new Size(62, 16);
            marginRightLabel.TabIndex = 6;
            marginRightLabel.TabStop = false;
            marginRightLabel.Text = SR.GetString(SR.EdgesSP_EdgeRightLabel);

            marginRightUnit.Location = new Point(74, 92);
            marginRightUnit.Size = new Size(88, 21);
            marginRightUnit.TabIndex = 7;
            marginRightUnit.DefaultUnit = UnitControl.UNIT_PX;
            marginRightUnit.MinValue = -1024;
            marginRightUnit.MaxValue = 1024;
            marginRightUnit.Changed += new EventHandler(this.OnChangedMargin);

            paddingLabel.Location = new Point(182, 4);
            paddingLabel.Size = new Size(166, 16);
            paddingLabel.TabIndex = 8;
            paddingLabel.TabStop = false;
            paddingLabel.Text = SR.GetString(SR.EdgesSP_PaddingLabel);

            paddingTopLabel.Location = new Point(186, 24);
            paddingTopLabel.Size = new Size(62, 16);
            paddingTopLabel.TabIndex = 9;
            paddingTopLabel.TabStop = false;
            paddingTopLabel.Text = SR.GetString(SR.EdgesSP_EdgeTopLabel);

            paddingTopUnit.Location = new Point(252, 20);
            paddingTopUnit.Size = new Size(88, 21);
            paddingTopUnit.TabIndex = 10;
            paddingTopUnit.DefaultUnit = UnitControl.UNIT_PX;
            paddingTopUnit.AllowNegativeValues = false;
            paddingTopUnit.MaxValue = 1024;
            paddingTopUnit.Changed += new EventHandler(this.OnChangedPadding);

            paddingBottomLabel.Location = new Point(186, 48);
            paddingBottomLabel.Size = new Size(62, 16);
            paddingBottomLabel.TabIndex = 11;
            paddingBottomLabel.TabStop = false;
            paddingBottomLabel.Text = SR.GetString(SR.EdgesSP_EdgeBottomLabel);

            paddingBottomUnit.Location = new Point(252, 44);
            paddingBottomUnit.Size = new Size(88, 21);
            paddingBottomUnit.TabIndex = 12;
            paddingBottomUnit.DefaultUnit = UnitControl.UNIT_PX;
            paddingBottomUnit.AllowNegativeValues = false;
            paddingBottomUnit.MaxValue = 1024;
            paddingBottomUnit.Changed += new EventHandler(this.OnChangedPadding);

            paddingLeftLabel.Location = new Point(186, 72);
            paddingLeftLabel.Size = new Size(62, 16);
            paddingLeftLabel.TabIndex = 13;
            paddingLeftLabel.TabStop = false;
            paddingLeftLabel.Text = SR.GetString(SR.EdgesSP_EdgeLeftLabel);

            paddingLeftUnit.Location = new Point(252, 68);
            paddingLeftUnit.Size = new Size(88, 21);
            paddingLeftUnit.TabIndex = 14;
            paddingLeftUnit.DefaultUnit = UnitControl.UNIT_PX;
            paddingLeftUnit.AllowNegativeValues = false;
            paddingLeftUnit.MaxValue = 1024;
            paddingLeftUnit.Changed += new EventHandler(this.OnChangedPadding);

            paddingRightLabel.Location = new Point(186, 96);
            paddingRightLabel.Size = new Size(62, 16);
            paddingRightLabel.TabIndex = 15;
            paddingRightLabel.TabStop = false;
            paddingRightLabel.Text = SR.GetString(SR.EdgesSP_EdgeRightLabel);

            paddingRightUnit.Location = new Point(252, 92);
            paddingRightUnit.Size = new Size(88, 21);
            paddingRightUnit.TabIndex = 16;
            paddingRightUnit.DefaultUnit = UnitControl.UNIT_PX;
            paddingRightUnit.AllowNegativeValues = false;
            paddingRightUnit.MaxValue = 1024;
            paddingRightUnit.Changed += new EventHandler(this.OnChangedPadding);

            bordersLabel.Location = new Point(4, 124);
            bordersLabel.Size = new Size(400, 16);
            bordersLabel.TabIndex = 17;
            bordersLabel.TabStop = false;
            bordersLabel.Text = SR.GetString(SR.EdgesSP_BordersLabel);

            borderSelectionImages.Images.AddStrip(new Bitmap(typeof(EdgesStylePage), "BorderSides.bmp"));
            borderSelectionPicture.Location = new Point(8, 145);
            borderSelectionPicture.Size = new Size(36, 36);
            borderSelectionPicture.TabIndex = 18;
            borderSelectionPicture.TabStop = false;
            borderSelectionPicture.Images = borderSelectionImages;

            borderSelectionLabel.Location = new Point(48, 144);
            borderSelectionLabel.Size = new Size(352, 16);
            borderSelectionLabel.TabIndex = 19;
            borderSelectionLabel.TabStop = false;
            borderSelectionLabel.Text = SR.GetString(SR.EdgesSP_SidesLabel);

            borderSelectionCombo.Location = new Point(48, 160);
            borderSelectionCombo.Size = new Size(121, 21);
            borderSelectionCombo.TabIndex = 20;
            borderSelectionCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            borderSelectionCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.EdgesSP_SidesCombo_1),
                SR.GetString(SR.EdgesSP_SidesCombo_2),
                SR.GetString(SR.EdgesSP_SidesCombo_3),
                SR.GetString(SR.EdgesSP_SidesCombo_4),
                SR.GetString(SR.EdgesSP_SidesCombo_5)
            });
            borderSelectionCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedBorderSelection);

            borderStyleLabel.Location = new Point(48, 192);
            borderStyleLabel.Size = new Size(80, 16);
            borderStyleLabel.TabIndex = 21;
            borderStyleLabel.TabStop = false;
            borderStyleLabel.Text = SR.GetString(SR.EdgesSP_StyleLabel);

            borderStyleCombo.Location = new Point(130, 188);
            borderStyleCombo.Size = new Size(121, 21);
            borderStyleCombo.TabIndex = 22;
            borderStyleCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            borderStyleCombo.Items.AddRange(new object[]
            {
                SR.GetString(SR.EdgesSP_StyleCombo_1),
                SR.GetString(SR.EdgesSP_StyleCombo_2),
                SR.GetString(SR.EdgesSP_StyleCombo_3),
                SR.GetString(SR.EdgesSP_StyleCombo_4),
                SR.GetString(SR.EdgesSP_StyleCombo_5),
                SR.GetString(SR.EdgesSP_StyleCombo_6),
                SR.GetString(SR.EdgesSP_StyleCombo_7)
            });
            borderStyleCombo.SelectedIndexChanged += new EventHandler(this.OnChangedBorderStyle);

            borderWidthLabel.Location = new Point(48, 220);
            borderWidthLabel.Size = new Size(80, 16);
            borderWidthLabel.TabIndex = 23;
            borderWidthLabel.TabStop = false;
            borderWidthLabel.Text = SR.GetString(SR.EdgesSP_WidthLabel);

            cbxBWidth.Location = new Point(130, 216);
            cbxBWidth.Size = new Size(121, 21);
            cbxBWidth.TabIndex = 24;
            cbxBWidth.DropDownStyle = ComboBoxStyle.DropDownList;
            cbxBWidth.Items.AddRange(new object[]
            {
                SR.GetString(SR.EdgesSP_WidthCombo_1),
                SR.GetString(SR.EdgesSP_WidthCombo_2),
                SR.GetString(SR.EdgesSP_WidthCombo_3),
                SR.GetString(SR.EdgesSP_WidthCombo_4)
            });
            cbxBWidth.SelectedIndexChanged += new EventHandler(this.OnChangedBorderWidthType);

            borderWidthUnit.Location = new Point(254, 216);
            borderWidthUnit.Size = new Size(88, 21);
            borderWidthUnit.TabIndex = 25;
            borderWidthUnit.DefaultUnit = UnitControl.UNIT_PX;
            borderWidthUnit.AllowNegativeValues = false;
            borderWidthUnit.AllowPercentValues = false;
            borderWidthUnit.MaxValue = 1024;
            borderWidthUnit.Changed += new EventHandler(this.OnChangedCustomBorderWidth);

            borderColorLabel.Location = new Point(48, 248);
            borderColorLabel.Size = new Size(80, 16);
            borderColorLabel.TabIndex = 26;
            borderColorLabel.TabStop = false;
            borderColorLabel.Text = SR.GetString(SR.EdgesSP_ColorLabel);

            borderColorCombo.Location = new Point(130, 244);
            borderColorCombo.Size = new Size(121, 21);
            borderColorCombo.TabIndex = 27;
            borderColorCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedBorderColor);
            borderColorCombo.TextChanged += new EventHandler(this.OnChangedBorderColor);
            borderColorCombo.LostFocus += new EventHandler(this.OnLostFocusBorderColor);

            colorPickerButton.Location = new Point(254, 243);
            colorPickerButton.Size = new Size(24, 22);
            colorPickerButton.TabIndex = 31;
            colorPickerButton.Text = "...";
            colorPickerButton.FlatStyle = FlatStyle.System;
            colorPickerButton.Click += new EventHandler(this.OnClickedColorPicker);

            this.Controls.Clear();                                  
            this.Controls.AddRange(new Control[] {
                                    borderColorLabel,
                                    borderColorCombo,
                                    colorPickerButton,
                                    bordersLabel,
                                    borderWidthLabel,
                                    borderWidthUnit,
                                    cbxBWidth,
                                    borderStyleLabel,
                                    borderStyleCombo,
                                    borderSelectionPicture,
                                    borderSelectionLabel,
                                    borderSelectionCombo,
                                    paddingLabel,
                                    paddingRightLabel,
                                    paddingRightUnit,
                                    paddingLeftLabel,
                                    paddingLeftUnit,
                                    paddingBottomLabel,
                                    paddingBottomUnit,
                                    paddingTopLabel,
                                    paddingTopUnit,
                                    marginsLabel,
                                    marginRightLabel,
                                    marginRightUnit,
                                    marginLeftLabel,
                                    marginLeftUnit,
                                    marginBottomLabel,
                                    marginBottomUnit,
                                    marginTopLabel,
                                    marginTopUnit });
        }

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     The page is being deactivated, either because the dialog is closing, or
        ///     some other page is replacing it as the active page.
        /// </devdoc>
        protected override bool DeactivatePage(bool closing, bool validate) {
            tlMarginPreviewStyle = null;
            rMarginPreviewStyle = null;
            bMarginPreviewStyle = null;
            paddingPreviewStyle = null;
            borderPreviewStyle = null;

            return base.DeactivatePage(closing, validate);
        }

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the style attributes into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            int i;

            SetInitMode(true);

            // create the attributes if they've not already been created
            if (paddingAttributes[0] == null) {
                paddingAttributes[EDGE_TOP] = new CSSAttribute(CSSAttribute.CSSATTR_PADDINGTOP);
                paddingAttributes[EDGE_BOTTOM] = new CSSAttribute(CSSAttribute.CSSATTR_PADDINGBOTTOM);
                paddingAttributes[EDGE_LEFT] = new CSSAttribute(CSSAttribute.CSSATTR_PADDINGLEFT);
                paddingAttributes[EDGE_RIGHT] = new CSSAttribute(CSSAttribute.CSSATTR_PADDINGRIGHT);

                marginAttributes[EDGE_TOP] = new CSSAttribute(CSSAttribute.CSSATTR_MARGINTOP);
                marginAttributes[EDGE_BOTTOM] = new CSSAttribute(CSSAttribute.CSSATTR_MARGINBOTTOM);
                marginAttributes[EDGE_LEFT] = new CSSAttribute(CSSAttribute.CSSATTR_MARGINLEFT);
                marginAttributes[EDGE_RIGHT] = new CSSAttribute(CSSAttribute.CSSATTR_MARGINRIGHT);

                borderStyleAttributes[EDGE_TOP] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERTOPSTYLE);
                borderColorAttributes[EDGE_TOP] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERTOPCOLOR);
                borderWidthAttributes[EDGE_TOP] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERTOPWIDTH);

                borderStyleAttributes[EDGE_BOTTOM] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERBOTTOMSTYLE);
                borderColorAttributes[EDGE_BOTTOM] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERBOTTOMCOLOR);
                borderWidthAttributes[EDGE_BOTTOM] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERBOTTOMWIDTH);

                borderStyleAttributes[EDGE_LEFT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERLEFTSTYLE);
                borderColorAttributes[EDGE_LEFT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERLEFTCOLOR);
                borderWidthAttributes[EDGE_LEFT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERLEFTWIDTH);

                borderStyleAttributes[EDGE_RIGHT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERRIGHTSTYLE);
                borderColorAttributes[EDGE_RIGHT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERRIGHTCOLOR);
                borderWidthAttributes[EDGE_RIGHT] = new CSSAttribute(CSSAttribute.CSSATTR_BORDERRIGHTWIDTH);
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            for (i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                paddingAttributes[i].LoadAttribute(styles);
                marginAttributes[i].LoadAttribute(styles);
                borderStyleAttributes[i].LoadAttribute(styles);
                borderColorAttributes[i].LoadAttribute(styles);
                borderWidthAttributes[i].LoadAttribute(styles);

                borderData[i].SetStyleValue(borderStyleAttributes[i].Value);
                borderData[i].SetColor(borderColorAttributes[i].Value);
                borderData[i].SetWidthValue(borderWidthAttributes[i].Value);
            }

            // initialize the ui with the attributes loaded
            for (i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                InitPaddingUI(i);
                InitMarginUI(i);
            }

            borderSelectionCombo.SelectedIndex = EDGE_ALL;
            borderSelectionPicture.CurrentIndex = EDGE_ALL;
            InitBorderStyleUI(EDGE_ALL);
            InitBorderColorUI(EDGE_ALL);
            InitBorderWidthUI(EDGE_ALL);

            SetEnabledState();

            SetInitMode(false);
        }

        /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="EdgesStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the attributes as set in the UI. Only saves the values
        ///     that have been modified.
        /// </devdoc>
        protected override void SaveStyles() {
            for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                if (paddingAttributes[i].Dirty)
                    SavePadding(i);
                if (marginAttributes[i].Dirty)
                    SaveMargin(i);
                if (borderStyleAttributes[i].Dirty ||
                    borderColorAttributes[i].Dirty ||
                    borderWidthAttributes[i].Dirty)
                    SaveBorder(i);
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.EdgeSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState() {
            bool fBorder = (borderStyleCombo.IsSet() &&
                            borderStyleCombo.SelectedIndex != IDX_BSTYLE_NONE);

            borderColorCombo.Enabled = fBorder;
            colorPickerButton.Enabled = fBorder;
            cbxBWidth.Enabled = fBorder;
            borderWidthUnit.Enabled = fBorder && (cbxBWidth.SelectedIndex == IDX_BWIDTH_CUSTOM);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with attributes

        private void InitBorderColorUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            string value = null;

            borderColorCombo.Color = "";
            if (selectedEdge == EDGE_ALL) {
                value = borderData[EDGE_TOP].GetColor();

                for (int i = EDGE_BOTTOM; i <= EDGE_RIGHT; i++) {
                    if (!value.Equals(borderData[i].GetColor())) {
                        value = null;
                        break;
                    }
                }
            } else {
                value = borderData[selectedEdge].GetColor();
            }

            if ((value != null) && (value.Length > 0))
                borderColorCombo.Color = value;
        }

        private void InitBorderStyleUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            int index;

            borderStyleCombo.SelectedIndex = -1;
            if (selectedEdge == EDGE_ALL) {
                index = borderData[EDGE_TOP].GetStyleIndex();

                for (int i = EDGE_BOTTOM; i <= EDGE_RIGHT; i++) {
                    if (index != borderData[i].GetStyleIndex()) {
                        index = -1;
                        break;
                    }
                }
            } else {
                index = borderData[selectedEdge].GetStyleIndex();
            }

            borderStyleCombo.SelectedIndex = index;
        }

        private void InitBorderWidthUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            int index;
            string width;

            cbxBWidth.SelectedIndex = -1;
            borderWidthUnit.Value = null;

            if (selectedEdge == EDGE_ALL) {
                index = borderData[EDGE_TOP].GetWidthIndex();
                width = borderData[EDGE_TOP].GetWidthValue();

                for (int i = EDGE_BOTTOM; i <= EDGE_RIGHT; i++) {
                    if (index != borderData[i].GetWidthIndex()) {
                        index = -1;
                        break;
                    }
                    if (!width.Equals(borderData[i].GetWidthValue())) {
                        width = null;
                        break;
                    }
                }
            } else {
                index = borderData[selectedEdge].GetWidthIndex();
                width = borderData[selectedEdge].GetWidthValue();
            }

            cbxBWidth.SelectedIndex = index;
            borderWidthUnit.Value = width;
        }

        private void InitMarginUI(int selectedEdge) {
            Debug.Assert(IsInitMode() == true,
                         "initPaddingUI called when page is not in init mode");
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_LAST),
                         "Invalid edge index");

            UnitControl u = null;
            switch (selectedEdge) {
            case EDGE_TOP: u = marginTopUnit; break;
            case EDGE_BOTTOM: u = marginBottomUnit; break;
            case EDGE_LEFT: u = marginLeftUnit; break;
            case EDGE_RIGHT: u = marginRightUnit; break;
            }

            u.Value = marginAttributes[selectedEdge].Value;
        }

        private void InitPaddingUI(int selectedEdge) {
            Debug.Assert(IsInitMode() == true,
                         "initPaddingUI called when page is not in init mode");
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_LAST),
                         "Invalid edge index");

            UnitControl u = null;
            switch (selectedEdge) {
            case EDGE_TOP: u = paddingTopUnit; break;
            case EDGE_BOTTOM: u = paddingBottomUnit; break;
            case EDGE_LEFT: u = paddingLeftUnit; break;
            case EDGE_RIGHT: u = paddingRightUnit; break;
            }

            u.Value = paddingAttributes[selectedEdge].Value;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private void SaveBorderColorUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            string value = borderColorCombo.Color;

            if (selectedEdge != EDGE_ALL) {
                borderData[selectedEdge].SetColor(value);
                borderColorAttributes[selectedEdge].Dirty = true;
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    borderData[i].SetColor(value);
                    borderColorAttributes[i].Dirty = true;
                }
            }
        }

        private void SaveBorderStyleUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            int index = -1;
            if (borderStyleCombo.IsSet())
                index = borderStyleCombo.SelectedIndex;

            if (selectedEdge != EDGE_ALL) {
                borderData[selectedEdge].SetStyleIndex(index);
                borderStyleAttributes[selectedEdge].Dirty = true;
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    borderData[i].SetStyleIndex(index);
                    borderStyleAttributes[i].Dirty = true;
                }
            }
        }

        private void SaveBorderWidthUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_ALL),
                         "Invalid edge index");

            int index = -1;
            string width = null;

            if (cbxBWidth.IsSet()) {
                index = cbxBWidth.SelectedIndex;
                if (index == IDX_BWIDTH_CUSTOM)
                    width = borderWidthUnit.Value;
            }
            if (selectedEdge != EDGE_ALL) {
                borderWidthAttributes[selectedEdge].Dirty = true;
                if (index == IDX_BWIDTH_CUSTOM)
                    borderData[selectedEdge].SetCustomWidth(width);
                else
                    borderData[selectedEdge].SetWidthIndex(index);
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    borderWidthAttributes[i].Dirty = true;
                    if (index == IDX_BWIDTH_CUSTOM)
                        borderData[i].SetCustomWidth(width);
                    else
                        borderData[i].SetWidthIndex(index);
                }
            }
        }

        private string SaveMarginUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_LAST),
                         "Invalid edge index");

            UnitControl u = null;
            switch (selectedEdge) {
            case EDGE_TOP: u = marginTopUnit; break;
            case EDGE_BOTTOM: u = marginBottomUnit; break;
            case EDGE_LEFT: u = marginLeftUnit; break;
            case EDGE_RIGHT: u = marginRightUnit; break;
            }

            string value = u.Value;

            return(value != null) ? value : "";
        }

        private string SavePaddingUI(int selectedEdge) {
            Debug.Assert((selectedEdge >= EDGE_FIRST) && (selectedEdge <= EDGE_LAST),
                         "Invalid edge index");

            UnitControl u = null;
            switch (selectedEdge) {
            case EDGE_TOP: u = paddingTopUnit; break;
            case EDGE_BOTTOM: u = paddingBottomUnit; break;
            case EDGE_LEFT: u = paddingLeftUnit; break;
            case EDGE_RIGHT: u = paddingRightUnit; break;
            }

            string value = u.Value;

            return(value != null) ? value : "";
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to update the preview

        private void UpdateBorderColorPreview(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_ALL),
                         "Invalid edge index");

            if (borderPreviewStyle == null)
                return;

            if (edge != EDGE_ALL) {
                string value = borderData[edge].GetColor();
                Debug.Assert(value != null,
                             "BorderData::getColor retured null!");

                try {
                    borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[edge] + "Color",
                                                    value, 1);
                } catch (Exception e) {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderColorPreview\n\t" + e.ToString());
                }
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    string value = borderData[i].GetColor();
                    Debug.Assert(value != null,
                                 "BorderData::getColor retured null!");

                    try {
                        borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[i] + "Color",
                                                        value, 1);
                    } catch (Exception e) {
                        Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderColorPreview\n\t" + e.ToString());
                    }
                }
            }

            previewPending = false;
        }

        private void UpdateBorderStylePreview(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_ALL),
                         "Invalid edge index");

            if (borderPreviewStyle == null)
                return;

            if (edge != EDGE_ALL) {
                string value = borderData[edge].GetStyleValue();
                Debug.Assert(value != null,
                             "BorderData::getStyleValue retured null!");

                try {
                    borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[edge] + "Style",
                                                    value, 1);
                } catch (Exception e) {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderStylePreview\n\t" + e.ToString());
                }
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    string value = borderData[i].GetStyleValue();
                    Debug.Assert(value != null,
                                 "BorderData::getStyleValue retured null!");

                    try {
                        borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[i] + "Style",
                                                        value, 1);
                    } catch (Exception e) {
                        Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderStylePreview\n\t" + e.ToString());
                    }
                }
            }
        }

        private void UpdateBorderWidthPreview(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_ALL),
                         "Invalid edge index");

            if (borderPreviewStyle == null)
                return;

            if (edge != EDGE_ALL) {
                string value = borderData[edge].GetWidthValue();
                Debug.Assert(value != null,
                             "BorderData::getWidthValue retured null!");

                try {
                    borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[edge] + "Width",
                                                    value, 1);
                } catch (Exception e) {
                    Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderWidthPreview\n\t" + e.ToString());
                }
            } else {
                for (int i = EDGE_FIRST; i <= EDGE_LAST; i++) {
                    string value = borderData[i].GetWidthValue();
                    Debug.Assert(value != null,
                                 "BorderData::getWidthValue retured null!");

                    try {
                        borderPreviewStyle.SetAttribute("border" + EDGE_NAMES[i] + "Width",
                                                        value, 1);
                    } catch (Exception e) {
                        Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateBorderWidthPreview\n\t" + e.ToString());
                    }
                }
            }
        }

        private void UpdateMarginPreview(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_LAST),
                         "Invalid edge index");

            if (tlMarginPreviewStyle == null)
                return;

            Debug.Assert((rMarginPreviewStyle != null) && (bMarginPreviewStyle != null),
                         "All margin style references should be non-null");

            string strAttribute = null;
            Microsoft.VisualStudio.Interop.Trident.IHTMLStyle style = null;
            string value = SaveMarginUI(edge);
            Debug.Assert(value != null,
                         "saveMarginUI returned null!");

            switch (edge) {
            case EDGE_TOP:
                strAttribute = "height";
                style = tlMarginPreviewStyle;
                break;
            case EDGE_BOTTOM:
                strAttribute = "height";
                style = bMarginPreviewStyle;
                break;
            case EDGE_LEFT:
                strAttribute = "width";
                style = tlMarginPreviewStyle;
                break;
            case EDGE_RIGHT:
                strAttribute = "width";
                style = rMarginPreviewStyle;
                break;
            }

            try {
                style.SetAttribute(strAttribute, value, 1);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updateMarginPreview\n\t" + e.ToString());
            }
        }

        private void UpdatePaddingPreview(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_LAST),
                         "Invalid edge index");

            if (paddingPreviewStyle == null)
                return;

            string value = SavePaddingUI(edge);
            Debug.Assert(value != null,
                         "savePaddingUI returned null!");

            try {
                paddingPreviewStyle.SetAttribute("padding" + EDGE_NAMES[edge],
                                                 value, 1);
            } catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in EdgesStylePage::updatePaddingPreview\n\t" + e.ToString());
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnChangedBorderColor(object source, EventArgs e) {
            if (IsInitMode() || borderUIInitMode)
                return;
            if (previewPending == false) {
                previewPending = true;
                SetDirty();
            }
        }

        private void OnChangedBorderStyle(object source, EventArgs e) {
            if (IsInitMode() || borderUIInitMode)
                return;
            int selectedEdge = borderSelectionCombo.SelectedIndex;
            SaveBorderStyleUI(selectedEdge);
            SetDirty();
            SetEnabledState();
            UpdateBorderStylePreview(selectedEdge);
        }

        private void OnChangedBorderWidthType(object source, EventArgs e) {
            if (IsInitMode() || borderUIInitMode)
                return;
            int selectedEdge = borderSelectionCombo.SelectedIndex;
            SaveBorderWidthUI(selectedEdge);
            SetDirty();
            SetEnabledState();
            UpdateBorderWidthPreview(selectedEdge);
        }

        private void OnChangedCustomBorderWidth(object source, EventArgs e) {
            if (IsInitMode() || borderUIInitMode)
                return;
            int selectedEdge = borderSelectionCombo.SelectedIndex;
            SaveBorderWidthUI(selectedEdge);
            SetDirty();
            if (e != null)
                UpdateBorderWidthPreview(selectedEdge);
        }

        private void OnChangedMargin(object source, EventArgs e) {
            if (IsInitMode())
                return;

            Debug.Assert(source is UnitControl,
                         "onChangedMargin can only be hooked to sink events from UnitControls");

            int selectedEdge;
            if (source.Equals(marginTopUnit))
                selectedEdge = EDGE_TOP;
            else if (source.Equals(marginBottomUnit))
                selectedEdge = EDGE_BOTTOM;
            else if (source.Equals(marginLeftUnit))
                selectedEdge = EDGE_LEFT;
            else {
                Debug.Assert(source.Equals(marginRightUnit),
                             "unknown UnitControl hooked to onChangedMargin");

                selectedEdge = EDGE_RIGHT;
            }

            marginAttributes[selectedEdge].Dirty = true;
            SetDirty();
            if (e != null)
                UpdateMarginPreview(selectedEdge);
        }

        private void OnChangedPadding(object source, EventArgs e) {
            if (IsInitMode())
                return;

            Debug.Assert(source is UnitControl,
                         "onChangedPadding can only be hooked to sink events from UnitControls");

            int selectedEdge;
            if (source.Equals(paddingTopUnit))
                selectedEdge = EDGE_TOP;
            else if (source.Equals(paddingBottomUnit))
                selectedEdge = EDGE_BOTTOM;
            else if (source.Equals(paddingLeftUnit))
                selectedEdge = EDGE_LEFT;
            else {
                Debug.Assert(source.Equals(paddingRightUnit),
                             "unknown UnitControl hooked to onChangedPadding");

                selectedEdge = EDGE_RIGHT;
            }

            paddingAttributes[selectedEdge].Dirty = true;
            SetDirty();
            if (e != null)
                UpdatePaddingPreview(selectedEdge);
        }

        private void OnSelChangedBorderSelection(object source, EventArgs e) {
            if (IsInitMode())
                return;
            SetInitMode(true);
            int selectedEdge = borderSelectionCombo.SelectedIndex;
            borderSelectionPicture.CurrentIndex = selectedEdge;

            borderUIInitMode = true;
            InitBorderStyleUI(selectedEdge);
            InitBorderColorUI(selectedEdge);
            InitBorderWidthUI(selectedEdge);
            borderUIInitMode = false;

            SetEnabledState();
            SetInitMode(false);
        }

        private void OnClickedColorPicker(object source, EventArgs e) {
            string color = InvokeColorPicker(borderColorCombo.Color);

            if (color != null) {
                borderColorCombo.Color = color;

                int selectedEdge = borderSelectionCombo.SelectedIndex;
                SaveBorderColorUI(selectedEdge);
                SetDirty();
                UpdateBorderColorPreview(selectedEdge);
            }
        }

        private void OnLostFocusBorderColor(object source, EventArgs e) {
            if (previewPending) {
                int selectedEdge = borderSelectionCombo.SelectedIndex;
                SaveBorderColorUI(selectedEdge);
                SetDirty();
                UpdateBorderColorPreview(selectedEdge);
            }
        }

        private void OnSelChangedBorderColor(object source, EventArgs e) {
            if (IsInitMode() || borderUIInitMode)
                return;
            int selectedEdge = borderSelectionCombo.SelectedIndex;
            SaveBorderColorUI(selectedEdge);
            SetDirty();
            UpdateBorderColorPreview(selectedEdge);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save attributes

        private void SavePadding(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_LAST),
                         "Invalid edge index");

            string value = SavePaddingUI(edge);

            paddingAttributes[edge].SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveMargin(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_LAST),
                         "Invalid edge index");

            string value = SaveMarginUI(edge);

            marginAttributes[edge].SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveBorder(int edge) {
            Debug.Assert((edge >= EDGE_FIRST) && (edge <= EDGE_LAST),
                         "Invalid edge index");

            string value;

            if (borderStyleAttributes[edge].Dirty) {
                value = borderData[edge].GetStyleValue();
                Debug.Assert(value != null,
                             "BorderData::getStyleValue returned null!");
                borderStyleAttributes[edge].SaveAttribute(GetSelectedStyles(), value);
            }

            if (borderColorAttributes[edge].Dirty) {
                value = borderData[edge].GetColor();
                Debug.Assert(value != null,
                             "BorderData::getColor returned null!");
                borderColorAttributes[edge].SaveAttribute(GetSelectedStyles(), value);
            }

            if (borderWidthAttributes[edge].Dirty) {
                value = borderData[edge].GetWidthValue();
                Debug.Assert(value != null,
                             "BorderData::getWidthValue returned null!");
                borderWidthAttributes[edge].SaveAttribute(GetSelectedStyles(), value);
            }
        }
    }


    /// <include file='doc\EdgesStylePage.uex' path='docs/doc[@for="BorderData"]/*' />
    /// <devdoc>
    ///     Stores information about a single border
    /// </devdoc>
    internal sealed class BorderData {
        private int styleIndex;
        private int widthIndex;
        private string widthValue;
        private string colorValue;

        public void SetStyleValue(string strStyle) {
            styleIndex = -1;
            if ((strStyle != null) && (strStyle.Length != 0)) {
                for (int i = 1; i < EdgesStylePage.BORDERSTYLE_VALUES.Length; i++) {
                    if (EdgesStylePage.BORDERSTYLE_VALUES[i].Equals(strStyle)) {
                        styleIndex = i;
                        return;
                    }
                }
            }
        }

        public string GetStyleValue() {
            return(styleIndex <= 0) ? "" : EdgesStylePage.BORDERSTYLE_VALUES[styleIndex];
        }

        public void SetStyleIndex(int index) {
            Debug.Assert((index >= -1) && (index < EdgesStylePage.BORDERSTYLE_VALUES.Length),
                         "invalid border style index");

            styleIndex = index;
        }

        public int GetStyleIndex() {
            return styleIndex;
        }

        public void SetColor(string color) {
            colorValue = color;
        }

        public string GetColor() {
            return(colorValue != null) ? colorValue : "";
        }

        public string GetWidthValue() {
            string width = null;

            if (widthIndex != -1) {
                if (widthIndex == EdgesStylePage.IDX_BWIDTH_CUSTOM)
                    width = widthValue;
                else {
                    width = EdgesStylePage.BORDERWIDTH_VALUES[widthIndex];
                }
            }
            return(width != null) ? width : "";
        }

        public void SetWidthValue(string width) {
            widthValue = width;
            widthIndex = -1;

            if ((width != null) && (width.Length != 0)) {
                widthIndex = EdgesStylePage.IDX_BWIDTH_CUSTOM;
                for (int i = 1; i < EdgesStylePage.BORDERWIDTH_VALUES.Length; i++) {
                    if (EdgesStylePage.BORDERWIDTH_VALUES[i].Equals(width)) {
                        widthIndex = i;
                        return;
                    }
                }
            }
        }

        public void SetCustomWidth(string width) {
            widthIndex = EdgesStylePage.IDX_BWIDTH_CUSTOM;
            widthValue = width;
        }

        public int GetWidthIndex() {
            return widthIndex;
        }

        public void SetWidthIndex(int index) {
            Debug.Assert((index >= -1) && (index <= EdgesStylePage.IDX_BWIDTH_CUSTOM),
                         "invalid border width index");

            widthIndex = index;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\winforms\menudesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace Microsoft.VisualStudio.Windows.Forms {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Drawing;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.Win32;
    using Marshal = System.Runtime.InteropServices.Marshal;

    /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner"]/*' />
    /// <devdoc>
    ///     Designer for menu.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class MenuDesigner : ComponentDesigner , IVsMenuItem {

        private IVsMenuEditor       editor;
        private bool                justCreated; //flag to prevent menuEditor from setting invalid name.
        private String              textCache; //used to cache the text of a menu item - for perf reasons
        private DesignerVerbCollection verbs;

        //the unknown item defines the menu editors - "type here" item
        private const int UNKNOWN_MENU_ITEM = unchecked((int)0xFFFFFFFF);

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.MenuDesigner"]/*' />
        /// <devdoc>
        ///     Constructor for MenuDesigner.  Note that when created we set "just created" flag.
        ///     This is toggled to false when the menu editor first calls IMISetProp.  The reason
        ///     for this is when dragging menu items from form to form - the menu editor attempts
        ///     to set an invalid menu name.
        /// </devdoc>
        public MenuDesigner() {
            justCreated = true;
            textCache = null;
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public override ICollection AssociatedComponents {
            get {
                return ((Menu)Component).MenuItems;
            }
        }


        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.Editor"]/*' />
        /// <devdoc>
        ///     Gets/Sets a reference to the shell's menu editor...
        /// </devdoc>
        internal IVsMenuEditor Editor {
            get {
                return editor;
            }

            set {
                editor = value;
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.Text"]/*' />
        /// <devdoc>
        ///     Shadow's the menu item's text property, so we can validate the name and deal 
        ///     appropriately with separators.
        /// </devdoc>
        private string Text {
            get {
                if (Component is MenuItem) {
                    return ((MenuItem)Component).Text;
                }
                return "";
            }
            set {
                if (Component is MenuItem) {
                    if (value.Equals("-") && (((MenuItem)Component).Parent is MainMenu)) {
                        throw new ArgumentException((SR.GetString(SR.MenuDesignerTopLevelSeparator)));
                    }
                    ((MenuItem)Component).Text = value;
                }
            }
        }


        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.Verbs"]/*' />
        /// <devdoc>
        ///     We add our "Edit Menu" verb to context & main menus here - this is done for
        ///     accessibility purposes.
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                if (verbs == null) {
                    verbs = new DesignerVerbCollection();
                    IComponent c = Component;
                    if (c is MainMenu || c is ContextMenu) {
                        verbs.Add(new DesignerVerb(SR.GetString(SR.MenuDesignerEditMenuVerb), new EventHandler(this.OnEditMenuVerb)));
                    }
                }
                return verbs;
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.OnEditMenuVerb"]/*' />
        /// <devdoc>
        ///     Fired when the user invokes the designer verb to edit the menu.
        /// </devdoc>
        private void OnEditMenuVerb(object sender, EventArgs e) {
            MenuEditorService menuEdSvc = GetService(typeof(IMenuEditorService)) as MenuEditorService;
            Menu m = (Menu)Component;
            if (menuEdSvc != null) {
                if (m.MenuItems.Count > 0) {
                    //with a valid count, set selection to 0th item
                    menuEdSvc.SetSelection(m.MenuItems[0]);
                }
                else {
                    //otherwise, set our selection to our "unknown" item
                    editor.SelectionChange((IntPtr)UNKNOWN_MENU_ITEM);
                }
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.CommitPropertyChange"]/*' />
        /// <devdoc>
        ///     This method sets the properites on menu's which are set by VS's Menu Designer.
        /// </devdoc>
        private void CommitPropertyChange(IComponent target, PropertyDescriptor prop, object value) {
            if (target == null || prop == null || value == null) {
                return;
            }
            if (justCreated && value.ToString().Length == 0) {
                justCreated = false;
                return;
            }

            MenuEditorService menuEdSvc = GetService(typeof(IMenuEditorService)) as MenuEditorService;
            if (menuEdSvc != null) 
               menuEdSvc.MenuChangedLocally = true;

            if (!(prop.GetValue(target)).Equals(value)) {
                prop.SetValue(target, value);
                if (menuEdSvc != null) {
                    menuEdSvc.CommitTransaction();
                }
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IComponentChangeService compSvc = (IComponentChangeService)GetService(typeof(IComponentChangeService));

                if (compSvc != null) {
                    compSvc.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                }
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.FillMenu"]/*' />
        /// <devdoc>
        ///     This method is called by the menuEditorService when it is first initialized.
        ///     Its purpose is to add all of the menu items to the shell's menuEditor.
        /// </devdoc>
        public void FillMenu(Menu menu) {
            if (menu == null)
                return;

            if (menu.IsParent) {                
                IDesignerHost theHost = (IDesignerHost)GetService(typeof(IDesignerHost));
                
                MenuItem[] items = new MenuItem[menu.MenuItems.Count];
                menu.MenuItems.CopyTo(items, 0);
                for (int i = 0; i < items.Length; i++) {
                    MenuDesigner menuDesigner = (MenuDesigner)theHost.GetDesigner(items[i]);
                    
                    // if we didn't get a menu designer wait, we may be pasting
                    if (menuDesigner == null) {
                        continue;
                    }

                    menuDesigner.Editor = Editor;
                    IVsMenuItem item = (IVsMenuItem)menuDesigner;

                    //the first sub-menu will have a valid parent
                    if (i == 0) {
                        IVsMenuItem itemParent = null;

                        if (menu is MenuItem) {
                            itemParent = (IVsMenuItem)theHost.GetDesigner(menu);
                        }
                        Editor.AddMenuItem( item, itemParent, null);
                    }

                    //if we're not the first sub-menu, add using our insertafter pointer
                    else {
                        IVsMenuItem itemPrevious = (IVsMenuItem)theHost.GetDesigner(items[i-1]);
                        Editor.AddMenuItem( item, null, itemPrevious);
                    }

                    //if the item we just added is a parent, call fillmenu on it
                    if (items[i].IsParent) {
                        menuDesigner.FillMenu(items[i]);
                    }
                }
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.IMIGetExtraProps"]/*' />
        /// <devdoc>
        ///     This will be called by the IVsMenuEditor to perform all clipboard operations including
        ///     unknown properties.
        /// </devdoc>
        public int IMIGetExtraProps( object pstm) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.IMIGetProp"]/*' />
        /// <devdoc>
        ///     This method is called by the IVsMenuEditor when properties of a particular menu
        ///     item need to be retrieved.
        /// </devdoc>
        public int IMIGetProp(int propId, out object pObj) {

            //make sure we can get a component that is a menuitem
            //so we can get its' properties...
            IComponent c = Component;

            if (!(c is MenuItem)) {
                pObj = null;
                return NativeMethods.S_OK;
            }

            MenuItem menuItem = (MenuItem)c;

            switch (propId) {
                case __VSMEPROPID.VSMEPROPID_NAME:       
                    String name = null;
                    PropertyDescriptor pd = TypeDescriptor.GetProperties(menuItem)["Name"];
                    if (pd != null) {
                        name = pd.GetValue(menuItem).ToString();
                    }
                    pObj = name;
                    break;

                case __VSMEPROPID.VSMEPROPID_CAPTION: 
                    pObj = TypeDescriptor.GetProperties(menuItem)["Text"].GetValue(menuItem).ToString();

                    //passing a 0 length string back into the menu editor if it's not
                    //active will not redraw... so here, we force a repaint, by setting the appropriate item.
                    //This case only surfaces if you "undo" a menu item's text and the menu editor is not active.
                    //
                    if (pObj != null && pObj.ToString().Length == 0) {
                        MenuEditorService menuEdSvc = GetService(typeof(IMenuEditorService)) as MenuEditorService;
                        if (menuEdSvc != null && !menuEdSvc.IsActive()) {
                            menuEdSvc.SetSelection(menuItem);
                        }
                    }
                    break;

                case __VSMEPROPID.VSMEPROPID_CHECKED:
                    pObj = TypeDescriptor.GetProperties(menuItem)["Checked"].GetValue(menuItem); 
                    break;

                case __VSMEPROPID.VSMEPROPID_ENABLED:
                    pObj = TypeDescriptor.GetProperties(menuItem)["Enabled"].GetValue(menuItem); 
                    break;

                case __VSMEPROPID.VSMEPROPID_VISIBLE:
                    pObj = TypeDescriptor.GetProperties(menuItem)["Visible"].GetValue(menuItem); 
                    break;

                case __VSMEPROPID.VSMEPROPID_RADIOCHECK:
                    pObj = TypeDescriptor.GetProperties(menuItem)["RadioCheck"].GetValue(menuItem); 
                    break;
                    
                default:
                    pObj = null;
                    break;

            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.IMISetExtraProps"]/*' />
        /// <devdoc>
        ///     This will be called by the IVsMenuEditor to perform all clipboard operations including
        ///     unknown properties.
        /// </devdoc>
        public int IMISetExtraProps( object pstm) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.IMISetProp"]/*' />
        /// <devdoc>
        ///     This method is called by the IVsMenuEditor when properties of a particular menu
        ///     item need to be set.
        /// </devdoc>
        public int IMISetProp(int propId, object obj) {
            //make sure we can get a component that is a menuitem
            //so we can adjust its' properties...
            IComponent c = Component;
            if (!(c is MenuItem))
                return NativeMethods.S_OK;

            PropertyDescriptor prop = null;
            object value = null;

            try {

                //if this is the first call to setProp since we've been created
                //then we need to be sure to ignore any name change from the
                //menu editor
                if (justCreated) {
                    if (propId == __VSMEPROPID.VSMEPROPID_NAME) {
                        return NativeMethods.S_OK;
                    }
                }

                switch (propId) {
                    case __VSMEPROPID.VSMEPROPID_NAME:       
                        prop = TypeDescriptor.GetProperties(c)["Name"];
                        value = Convert.ToString(obj);
                        break;

                    case __VSMEPROPID.VSMEPROPID_CAPTION:    
                        if (obj == null) {
                            textCache = "";
                        }
                        else {
                            textCache = obj.ToString();
                        }
                        break;

                    case __VSMEPROPID.VSMEPROPID_CHECKED:    
                        prop = TypeDescriptor.GetProperties(c)["Checked"];
                        value = (bool)obj;
                        break;

                    case __VSMEPROPID.VSMEPROPID_ENABLED:    
                        prop = TypeDescriptor.GetProperties(c)["Enabled"];
                        value = (bool)obj;
                        break;

                    case __VSMEPROPID.VSMEPROPID_VISIBLE:    
                        prop = TypeDescriptor.GetProperties(c)["Visible"];
                        value = (bool)obj;
                        break;

                    case __VSMEPROPID.VSMEPROPID_RADIOCHECK: 
                        prop = TypeDescriptor.GetProperties(c)["RadioCheck"];
                        value = (bool)obj;
                        break;
                }
            }
            catch (Exception e) {
                //try to get the iuiservice and show the error that we encountered
                IUIService uiService = (IUIService)GetService(typeof(IUIService));
                if (uiService != null) {
                    uiService.ShowError(e, SR.GetString(SR.MenuDesignerInvalidPropertyValue));
                }
                return NativeMethods.S_FALSE;
            }
            
            //This will call prop.SetValue and push the info onto the undo stack
            //
            if (propId != __VSMEPROPID.VSMEPROPID_CAPTION) {
                try {
                    CommitPropertyChange(c, prop, value);
                }
                catch (Exception e) {
                    //try to get the iuiservice and show the error that we encountered
                    IUIService uiService = (IUIService)GetService(typeof(IUIService));
                    if (uiService != null) {
                        uiService.ShowError(e.InnerException);
                    }
                    return NativeMethods.S_FALSE;
                }
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes the designer with the given component.  The designer can
        ///     get the component's site and request services from it in this call.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            IComponentChangeService compChange = (IComponentChangeService)GetService(typeof(IComponentChangeService));

            if (compChange != null) {
                compChange.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }
        }
        
        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.LosingSelection"]/*' />
        /// <devdoc>
        ///     This method is called by the menu editor service, it tells this menu designer
        ///     that it is about to lose selection.  Since we cache the value of the text, 
        ///     we need to make sure that we flush this value here.
        /// </devdoc>
        public void LosingSelection() {
            PropertyDescriptor prop = null;
            IComponent c = Component;

            if (!(c is MenuItem))
                return;

            if (textCache != null) {
                prop = TypeDescriptor.GetProperties(c)["Text"];
                CommitPropertyChange(c, prop, textCache);
                textCache = null;            
            }
        }        
        
        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     This is called after a property has been changed.  It allows the implementor
        ///     to do any post-processing that may be needed after a property change.
        ///     For example, a designer will typically update the source code that sets the
        ///     property with the new value.
        /// </devdoc>
        public void OnComponentChanged(object sender, ComponentChangedEventArgs ccevent) {

            IComponent comp = Component;

            if (comp != ccevent.Component) {
                return;
            }

            MemberDescriptor prop = ccevent.Member;

            if (Editor == null || prop == null) {
                return;
            }

            if (prop.Name.Equals("Text")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_CAPTION);
            }
            else if (prop.Name.Equals("Name")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_NAME);
            }
            else if (prop.Name.Equals("Checked")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_CHECKED);
            }
            else if (prop.Name.Equals("Enabled")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_ENABLED);
            }
            else if (prop.Name.Equals("RadioCheck")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_RADIOCHECK);
            }
            else if (prop.Name.Equals("Visible")) {
                Editor.OnChange((IVsMenuItem)this, __VSMEPROPID.VSMEPROPID_VISIBLE);
            }
        }

        /// <include file='doc\MenuDesigner.uex' path='docs/doc[@for="MenuDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///     We override this hear so we can shadow the Text property on the menu item.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            
            base.PreFilterProperties(properties);

            if (Component is MenuItem) {
                properties["Text"] = TypeDescriptor.CreateProperty(typeof(MenuDesigner),
                                                                  (PropertyDescriptor)properties["Text"],
                                                                  new Attribute[0]);            
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\axtowfc\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\winforms\menueditorservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuEditorService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Windows.Forms {
    
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Designer.Service;
    using System;
    using System.Collections;   
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    
    using Marshal = System.Runtime.InteropServices.Marshal;
    


    /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService"]/*' />
    /// <devdoc>
    ///     This class implements most of the funtionality of the
    ///     menu editor.  The actual menu editor code is located within the
    ///     Visual Studio environment.  This service merely surfaces the menu
    ///     editor for easy use.
    /// </devdoc>
    [
    CLSCompliant(false)
    ]
    internal class MenuEditorService : IMenuEditorService, IVsMenuEditorSite, IVsToolboxUser, NativeMethods.IOleCommandTarget {

        //
        // Menu editor details.
        //
        // There are three main objects associated with the menu editor:
        //
        // IVsMenuEditor     The shell owns this.  It is the main interface
        //                   into the menu editor.  We create it here through
        //                   a call to IVsMenuEditorFactory.
        //
        // IVsMenuEditorSite The MenuEditorService implements this site.  There
        //                   is a site for each IVsMenuEditor.  We only allow
        //                   a single active menu at a time, so there is only
        //                   a need for one site.  The site gets called
        //                   when the user manipulates the menu editor, so
        //                   the site must know how to take an IVsMenuItem and
        //                   convert it back into an IComponent that we can
        //                   manipulate.  We will do this through a QI on
        //                   the IVsMenuItem for IDesigner.
        //
        // IVsMenuItem       This represents a single menu item, and must
        //                   be implemented on the menu's designer object so
        //                   that we can go from IVsMenuItem back to IDesigner.
        //
        // To use the MenuEditorService you must extend it and override the
        // following methods:
        //
        //      int GetMenuBarOwner()   This returns the HWND of the window
        //                              that will host the menu bar.  The
        //                              HWND msut remain valid for the life
        //                              of the menu bar.  If this handle
        //                              needs to be recreated, you are
        //                              responsible for closing and re-opening
        //                              the menu editor.
        //
        //      int GetMenuOwner()      This returns the HWND of the window
        //                              that will host drop down menus.  This
        //                              HWND is typically the size of the document
        //                              window.
        //
        // To show a menu, get the menu editor and call SetActiveMenu(IComponent).
        // The component you pass should be a component that contains a designer
        // that also implements IVsMenuItem.  The menu structure will be obtained
        // from this interface.

        // IVsMenuEditor, which the shell owns and is the main interface to the
        // editor.  Also, there is IVsMenuEditorSite
        // Instance data we keep for the life of the service
        //
        private IDesignerHost       host;

        // Instance data we keep for the currently active menu
        //
        private IVsMenuEditor       menuEditor;
        private Menu                activeMenu;
        private int                 menuHeight;
        private int                 initialMenuHeight;
        private MenuDesigner        selectedMenuDesigner; //used to keep track of when to release caption and name cache (perf.)
        private bool                justSetNullSelection; //used to avoid setting the selection twice, when collapsing menus
        private EventHandler        idleHandler;          //used with undo/redo to refill the menu structure
        private MenuItem            lastSetItem;          //this tells us where focus should be after undo/redo
        private DocumentManager     docManager;           //when the docmngr gets disposed, we null our reference to hostcommandtarget
        private bool                refreshOnLoadComplete;//signifies that we need to reload the menus when designer loading is done.
        private ScrollableControl   designerFrame;        //represents the window around the form - used for scrolling the window 
                                                          //when we have many, many menu items
        private bool                menuJustAddedOrRemoved;//used to keep track if the menu editor created/destroyed
                                                           //a menuitem or if the undo/redo service did
        private bool                menuChangedLocally;    //used to monitor who made changes to the menu components
        private bool                isMenuInherited;       //indicates if the 'active menu' is inherited
        private InheritanceAttribute inheritanceAttribute;
        private DesignerTransaction designerTransaction;   //we'll use this for wrapping undo/redo events together
        private IComponentChangeService           compChange;
        private NativeMethods.IOleCommandTarget   hostCommandTarget;
        private NativeMethods.IOleCommandTarget   menuCommandTarget;
        

        


        // constants used when callins editor.selectionchnage
        //
        private const int UNKNOWN_MENU_ITEM = unchecked((int)0xFFFFFFFF);

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.MenuEditorService"]/*' />
        /// <devdoc>
        ///     Creates a new menu editor service and adds the service
        ///     to the service list.
        /// </devdoc>
        public MenuEditorService(IDesignerHost host) {
            this.host = host;
            menuHeight = 0;
            selectedMenuDesigner = null;
            designerFrame = null;
            idleHandler = null;
            lastSetItem = null;
            menuJustAddedOrRemoved = false;
            menuChangedLocally = false;
            docManager = null;
            designerTransaction = null;
            inheritanceAttribute = null;
            refreshOnLoadComplete = false;
            // Monitor menuitem add/remove events for undo/redo actions
            //
            compChange = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            if (compChange != null) {
                compChange.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                compChange.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                compChange.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }

            docManager = (DocumentManager)host.GetService(typeof(DocumentManager));
            if (docManager != null) {
                docManager.DesignerDisposed += new DesignerEventHandler(this.DesignerDisposed);
            }

            host.LoadComplete += new EventHandler(OnLoadComplete);
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.MenuChangedLocally"]/*' />
        /// <devdoc>
        ///      Set to true if we've made changes to our menu components.  By knowing this, we can predict if we
        ///      we will need to refresh our menu structure or now.  Ex: Undo/Redo
        /// </devdoc>
        internal bool MenuChangedLocally {
            get {
                return menuChangedLocally;
            }
            set{
                menuChangedLocally = value;
            }                        
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.MenuHeight"]/*' />
        public int MenuHeight {
            get {
                return menuHeight;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IsMenuInherited"]/*' />
        /// <devdoc>
        ///      Returns true if the active menu is an inherited component.  We use this to determine if we 
        ///      we need to resize the base control or not.
        /// </devdoc>
        private bool IsMenuInherited {
            get {
                if (inheritanceAttribute == null && activeMenu != null) {
                    inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(activeMenu)[typeof(InheritanceAttribute)];
                    if (inheritanceAttribute.Equals(InheritanceAttribute.NotInherited)) {
                        isMenuInherited = false;
                    }
                    else {
                        isMenuInherited = true;
                    }
                }
                return isMenuInherited;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.OnComponentAdded"]/*' />
        /// <devdoc>
        ///      Called when a component is added to the design container.
        ///      We need to watch this for special casing the undo/redo of menuitems.
        /// </devdoc>
        private void OnComponentAdded(object source, ComponentEventArgs ce) {
            if (!menuJustAddedOrRemoved && ce.Component is MenuItem && idleHandler == null) {
                if (!host.Loading) {
                    idleHandler = new EventHandler(this.OnIdle);
                    Application.Idle += idleHandler;
                }
                else {
                    //delay menu refresh until load complete
                    refreshOnLoadComplete = true;
                }
            }
            menuJustAddedOrRemoved = false;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.OnComponentChanged"]/*' />
        /// <devdoc>
        ///      Called when a component is changed to the design container.
        ///      We need to watch this for special casing the undo/redo of menuitems.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs ccevent) {
            if (idleHandler == null) {
                if (ccevent.Component is MenuItem) {
                    MemberDescriptor prop = ccevent.Member;
                    if (prop == null)
                        return;
                    if (prop.Name.Equals("Index")) {
                        idleHandler = new EventHandler(this.OnIdle);
                        Application.Idle += idleHandler;
                    }
                }
                else if (ccevent.Component is Menu.MenuItemCollection) {
                    idleHandler = new EventHandler(this.OnIdle);
                    Application.Idle += idleHandler;
                }
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///      Called when a component is removed from the design container.
        ///      We need to watch this for special casing the undo/redo of menuitems.
        /// </devdoc>
        private void OnComponentRemoved(object source, ComponentEventArgs ce) {
            if (!menuJustAddedOrRemoved && ce.Component is MenuItem && idleHandler == null) {
                Menu m = activeMenu;
                this.SetMenu(null);
                this.SetMenu(m);
            }
            menuJustAddedOrRemoved = false;
        }

        /// <devdoc>
        ///     This is called when the designer frame is destroyed.  We pass the HWND of this
        ///     frame to the menu editor, and it always needs a valid window.  So destroy the
        ///     menu editor before the HWND goes away.
        /// </devdoc>
        private void OnFrameHandleDestroyed(object sender, EventArgs e) {
            Debug.Assert(!((Control)sender).RecreatingHandle, "Menu editor service does not expect the designer frame to create its handle.");
            ((Control)sender).HandleDestroyed -= new EventHandler(OnFrameHandleDestroyed);
            designerFrame = null;
            
            if (menuEditor != null) {
                DisposeMenuEditor();
            }
        }
        
        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.OnIdle"]/*' />
        /// <devdoc>
        ///      This event is added everytime we detect an undo/redo action.  By doing this, we wait for
        ///      all components to be un-done/redone then refill our menu - this helps us avoid flicker.
        /// </devdoc>
        private void OnIdle(object sender, EventArgs e) {
            Application.Idle -= idleHandler;
            idleHandler = null;

            Menu m = activeMenu;
            MenuChangedLocally = true;
            if (menuEditor != null) {
                menuEditor.SelectionChange(IntPtr.Zero);
            }
            this.SetMenu(null);
            this.SetMenu(m);
            if (lastSetItem != null) {
                
                this.SetSelection(lastSetItem);
                lastSetItem = null;
            }

        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.OnLoadComplete"]/*' />
        /// <devdoc>
        ///      When the designer is done loading, we may need to refresh the menu structure depending on the
        ///      'refreshOnLoadComplete' flag.
        /// </devdoc>
        private void OnLoadComplete(object sender, EventArgs e) {
            if (refreshOnLoadComplete) {
                refreshOnLoadComplete = false;
                idleHandler = new EventHandler(this.OnIdle);
                Application.Idle += idleHandler;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.CreateMenuEditor"]/*' />
        /// <devdoc>
        ///     Creates the menu editor based on the contents of
        ///     activeMenu, and stores the new menu editor
        ///     in menuEditor.  This may also modify the
        ///     current NativeMethods.IOleCommandTarget service to point to our command
        ///     target, should the menu editor implement this interface.
        /// </devdoc>
        private void CreateMenuEditor() {
            
            ISite site = activeMenu.Site;
            if (site==null) {
                return;
            }

            //retrieve services necessary for creating a menueditor
            IVsMenuEditorSite    menuEditorSite    = (IVsMenuEditorSite)this;
            IVsMenuEditorFactory menuEditorFactory = (IVsMenuEditorFactory)site.GetService(typeof(IVsMenuEditorFactory));
            IOleUndoManager      oleUndoManager    = (IOleUndoManager)site.GetService(typeof(IOleUndoManager));
            NativeMethods.IOleServiceProvider  serviceProvider   = (NativeMethods.IOleServiceProvider)site.GetService(typeof(NativeMethods.IOleServiceProvider));


            //if any sites == null, silently fail & return from method
            if (menuEditorSite == null  || menuEditorFactory == null || serviceProvider == null) {
                return;
            }

            //if we're working with a contextmenu, be sure to set that flag as well
            int contextMenuFlag = 0;
            if (activeMenu is ContextMenu) {
                contextMenuFlag = (int)__VSMEINIT.MD_CONTEXTMENU;
            }

            //create & fill our MenuEditorInit stuct used to create a new menueditor
            tagMenuEditorInit menuEditorInit = new tagMenuEditorInit();

            Control rootControl = (Control)host.RootComponent;

            if (rootControl == null) {
                return;
            }

            IntPtr hwndParent = ((Microsoft.VisualStudio.Designer.IDesignerDocument)host).View.Handle;
            if (rootControl.Parent is ScrollableControl) {
                designerFrame = (ScrollableControl)rootControl.Parent;
                designerFrame.HandleDestroyed += new EventHandler(OnFrameHandleDestroyed);
                hwndParent = designerFrame.Handle;
            }

            menuEditorInit.pMenuEditorSite = menuEditorSite;
            menuEditorInit.pSP             = serviceProvider;
            menuEditorInit.pUndoMgr        = oleUndoManager;
            menuEditorInit.hwnd            = rootControl.Handle;
            menuEditorInit.hwndParent      = hwndParent;
            menuEditorInit.dwFlags         = (((int)__VSMEINIT.MD_VISIBLESUPPORT)| 
                                              ((int)__VSMEINIT.MD_RADIOCHECKSUPPORT)| 
                                              ((int)__VSMEINIT.MD_VIEWCODESUPPORT)|
                                              ((int)__VSMEINIT.MD_NOUNDOSUPPORT)|
                                              contextMenuFlag);
                                             
            menuEditorInit.pszAccelList    = null;

            //because the tagMenuEditorInit struct has an inlineSystem.Runtime.InteropServices.Guid, we need to do the custom marshalling
            Guid guid = new Guid("CA761232-ED42-11CE-BACD-00AA0057B223");
            menuEditorInit.SiteID = guid;

            //here's where we actually make the factory create the menu editor...
            IVsMenuEditor editor;
            menuEditorFactory.CreateMenuEditor(menuEditorInit, out editor);

            //bail out if we didn't get anything back
            if (editor == null) {
                return;
            }
            
            //store the editor into our member variable
            menuEditor = editor;

            //setup the command targets
            if (menuEditor is NativeMethods.IOleCommandTarget) {
                menuCommandTarget = (NativeMethods.IOleCommandTarget)menuEditor;
                hostCommandTarget = (NativeMethods.IOleCommandTarget)site.GetService(typeof(NativeMethods.IOleCommandTarget));

                if (hostCommandTarget != null) {
                    host.RemoveService(typeof(NativeMethods.IOleCommandTarget));
                }
                host.AddService(typeof(NativeMethods.IOleCommandTarget), this);
            }

            if (menuEditor is IVsToolboxUser) {
                host.AddService(typeof(IVsToolboxUser), this);
            }

            //setup the height
            menuEditor.GetHeight(out menuHeight);
            initialMenuHeight = menuHeight;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.CommitTransaction"]/*' />
        /// <devdoc>
        ///     Invoked internally by the menuDesigner, this is used to commit the transaction we opened in CreateItem.
        /// </devdoc>
        internal void CommitTransaction() {
            if(designerTransaction != null) {
                designerTransaction.Commit();
                designerTransaction = null;
            }
        }
        
        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IVsMenuEditorSite.CreateItem"]/*' />
        /// <devdoc>
        ///     Creates a menu item.  This method is called by the IVsMenuEditor.
        /// </devdoc>
        void IVsMenuEditorSite.CreateItem(IVsMenuItem pIMIParent, IVsMenuItem pIMIInsertAfter, out IVsMenuItem ppIMINew) {
            menuJustAddedOrRemoved = true;
            ppIMINew = null;

            // What menu are we going to add this new item to, and where
            // are we going to add it?
            //
            Menu parentMenu = null;
            int addIndex;

            //very first menu item
            if(pIMIParent == null && pIMIInsertAfter == null) {
                parentMenu = activeMenu;
                addIndex = 0;
            }
            //valid parent means that you just started a new menu and are the first item
            else if(pIMIParent != null) {
                parentMenu = (Menu)(((MenuDesigner)pIMIParent).Component);
                addIndex = 0;
            }
            //otherwise, it's another menu item in a list (not a top item)
            else {
                MenuItem previousMenu = (MenuItem)(((MenuDesigner)pIMIInsertAfter).Component);
                if(previousMenu.Index < (previousMenu.Parent).MenuItems.Count - 1) {
                    parentMenu = previousMenu.Parent;
                    addIndex = previousMenu.Index + 1;
                }
                else {
                    parentMenu = previousMenu.Parent;
                    addIndex = -1; // just call add, no index.
                }
            }

            Debug.Assert(parentMenu != null, "We should have been able to locate a parent menu");

            // Now that we have a menu we are going to add our new item to, make sure that
            // it's not privately inherited.  If it is, we can't very well add any items
            // to it.
            //
            InheritanceAttribute inheritanceAttr = (InheritanceAttribute)TypeDescriptor.GetAttributes(parentMenu)[typeof(InheritanceAttribute)];
            if (inheritanceAttr.InheritanceLevel == InheritanceLevel.InheritedReadOnly) {
                Exception ex = new InvalidOperationException(SR.GetString(SR.MenuDesignerInheritedParent));
                ex.HelpLink = SR.MenuDesignerInheritedParent;

                IUIService uis = (IUIService)host.GetService(typeof(IUIService));
                if (uis != null) {
                    uis.ShowError(ex);
                }

                throw ex;
            }

            try {
                // We passed the test.  Now create and add the item.
                //
                if (designerTransaction == null) {
                    designerTransaction = host.CreateTransaction(SR.GetString(SR.DesignerBatchCreateMenu));
                }
                //start to create the menu item
                MenuItem menuItem = (MenuItem)host.CreateComponent(typeof(MenuItem));
                if (selectedMenuDesigner != null) {
                    //tell the currently selected menu, that its losing selection
                    selectedMenuDesigner.LosingSelection();
                }

                if (compChange != null) {
                    compChange.OnComponentChanging(parentMenu, null);
                }

                if (addIndex == -1) {
                    parentMenu.MenuItems.Add(menuItem);
                }
                else {
                    parentMenu.MenuItems.Add(addIndex, menuItem);
                }
                
                if (compChange != null) {
                    MenuChangedLocally = true;
                    compChange.OnComponentChanged(parentMenu, null, null, null);
                }

                //get the designer for this new menu item (which implements ivsmenuitem) and return that....
                MenuDesigner menuDesigner = (MenuDesigner)host.GetDesigner(menuItem);
                menuDesigner.Editor = menuEditor;
                ppIMINew = (IVsMenuItem)menuDesigner;
                selectedMenuDesigner = menuDesigner;
            }
            catch {
                if (designerTransaction != null) {
                    designerTransaction.Cancel();
                    designerTransaction = null;
                }
                selectedMenuDesigner = null;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IVsMenuEditorSite.DeleteItem"]/*' />
        /// <devdoc>
        ///     Deletes a menu item.  This method is called by the IVsMenuEditor.
        /// </devdoc>
        void IVsMenuEditorSite.DeleteItem(IVsMenuItem pIMI) {
            DesignerTransaction trans = null;
            menuJustAddedOrRemoved = true;
            
            try {
                trans = host.CreateTransaction(SR.GetString(SR.DesignerBatchDeleteMenu));
                
                //start to create the menu item

                MenuDesigner menuDesigner = null;
                if (pIMI == null) {
                    menuDesigner = (MenuDesigner)host.GetDesigner(activeMenu);
                }
                else {
                    menuDesigner = (MenuDesigner)pIMI;
                }
                IComponent comp = menuDesigner.Component;
                if (comp is MenuItem) {
                    MenuItem menu = (MenuItem)comp;
                    if (menu.MenuItems.Count > 0 ) {
                        //because we're a parent item, we'll want to refresh
                        //for our children. This can be done by clearing this
                        //flag, so when we see the comp change message, we 
                        //know to completely refresh
                        menuJustAddedOrRemoved = false;
                    }

                    int index = ((MenuItem)menu).Index;
                    Menu theParent = ((MenuItem)menu).Parent;
                    if (theParent != null) {

                        if (compChange != null) {
                            compChange.OnComponentChanging(theParent, null);
                        }

                        theParent.MenuItems.Remove((MenuItem)menu);

                        if (compChange != null) {
                            MenuChangedLocally = true;
                            compChange.OnComponentChanged(theParent, null, null, null);
                        }
                    }
                    //We now need to destroy the component
                    //
                    //first, supress the selection change, so that when we remove the component,
                    //it will not modify our selection (important for the shell's menu editor)
                    ISelectionService svc = (ISelectionService)host.GetService(typeof(ISelectionService));
                    if (svc != null && svc is SelectionService) {
                        ((SelectionService)svc).AllowNoSelection = true;
                        try {
                            host.DestroyComponent(menu);
                        }
                        finally {
                            ((SelectionService)svc).AllowNoSelection = false;

                        }
                    }
                }
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.DesignerDisposed"]/*' />
        /// <devdoc>
        ///      We watch this event so we know when to dispose our reference to hostCommandTarget.
        /// </devdoc>
        private void DesignerDisposed(object source, DesignerEventArgs e) {
            if (e.Designer == host && docManager != null) {
                docManager.DesignerDisposed -= new DesignerEventHandler(this.DesignerDisposed);
                docManager = null;
                hostCommandTarget = null;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this service.
        /// </devdoc>
        public virtual void Dispose() {
            if (compChange != null) {
                compChange.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                compChange.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                compChange.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                compChange = null;
            }

            if (docManager != null) {
                docManager.DesignerDisposed -= new DesignerEventHandler(this.DesignerDisposed);
                docManager = null;
            }

            if (menuEditor != null) {
                DisposeMenuEditor();
            }

            if (host != null) {
                host.LoadComplete -= new EventHandler(OnLoadComplete);
                host = null;
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.DisposeMenuEditor"]/*' />
        /// <devdoc>
        ///     Disposes of the menu editor.
        /// </devdoc>
        private void DisposeMenuEditor() {
            if (menuEditor == null || host == null) {
                return;
            }

            //The menu editor needs this call to be made
            //before we release it
            //
            menuEditor.DeleteMenuItem(null);

            // Restore the host's command target if
            // we replaced it.

            if (menuCommandTarget != null) {
                host.RemoveService(typeof(NativeMethods.IOleCommandTarget));
                menuCommandTarget = null;
            }

            if (hostCommandTarget != null) {
                host.AddService(typeof(NativeMethods.IOleCommandTarget), hostCommandTarget);
                hostCommandTarget = null;
            }

            host.RemoveService(typeof(IVsToolboxUser));

            menuEditor = null;
            activeMenu = null;

            //repaint the frame, so that the new menu is visible
            Control baseControl = (Control)host.RootComponent;
            if (baseControl != null) {
                IntPtr handle  = baseControl.Handle;
                NativeMethods.RECT rect = new NativeMethods.RECT();
                NativeMethods.GetWindowRect(handle, ref rect);

                NativeMethods.SetWindowPos(handle, IntPtr.Zero, 0, 0,
                                     rect.right - rect.left,
                                     (rect.bottom - rect.top) - initialMenuHeight,
                                     NativeMethods.SWP_NOACTIVATE | NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOZORDER);
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.NativeMethods.IOleCommandTarget.Exec'"]/*' />
        /// <devdoc>
        ///     Executes the given command.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.Exec(ref Guid pguidCmdGroup, int nCmdID, int nCmdexecopt, Object[] pvaIn, int pvaOut) {
            
            // Since the menu can be in different states when QueryStatus is called, 
            // this is the order in which we pass the cmd around:
            // 1) if the in-situ edit box is in place on the menu item, always return 
            //    not supported.  Otherwise, the windows control won't get the undo/redo msg.
            // 2) if the menu editor is valid (has items and is currently displaying them),
            //    then we'll first ask it if it wants this message, if so, we just return s_ok.
            // 3) finally, we pass the message to the command target, and return that result.
            bool activeAndValid = IsActive()
                               && activeMenu != null
                               && (activeMenu.MenuItems.Count > 0);

            int hr = NativeMethods.OLECMDERR_E_UNKNOWNGROUP;


            if (GetUIState()) {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
            if (activeAndValid && menuCommandTarget != null) {
                hr =  menuCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            }
            else if (hostCommandTarget != null) {
                hr = hostCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            }

            return hr;
        }
        
        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.Finalize"]/*' />
        /// <devdoc>
        ///     Disposes of this service at garbage collection time.
        /// </devdoc>
        ~MenuEditorService() {
            Dispose();
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.GetMenu"]/*' />
        /// <devdoc>
        ///     Returns the current menu.
        /// </devdoc>
        public Menu GetMenu() {
            return activeMenu;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.MessageFilter"]/*' />
        /// <devdoc>
        ///     This method should be called for each message that the hosting form
        ///     receives.  The menu editor may consume the message, in which case
        ///     this method will reuturn true.
        /// </devdoc>
        public virtual bool MessageFilter(ref Message m) {
            if (menuEditor != null) {
                try {
                    int retVal;
                    int hr = menuEditor.Filter((int)m.HWnd, m.Msg, (int)m.WParam, (int)m.LParam, out retVal);

                    if (hr == NativeMethods.S_OK) {
                        if(m.Msg == NativeMethods.WM_NCCALCSIZE) {
                            if(menuEditor != null) 
                                menuEditor.GetHeight(out menuHeight);
    
                            NativeMethods.InvalidateRect(m.HWnd, null, true);
                            return true;
                        }
                        if(m.Msg == NativeMethods.WM_CONTEXTMENU) {
                            //This means that we passed a context menu message along to the 
                            //menu editor and it was shown (hence the hr s_ok).  We should
                            //return true (i.e. handled) so our designer doesn't pop up it's 
                            //own menu
                            //
                            return true;
                        }
                    }

                    //Do the hittest logic to see if the menu area is being tested.
                    //If so, return HTMENU
                    if (m.Msg ==  NativeMethods.WM_NCHITTEST) {
                        NativeMethods.POINT point = new NativeMethods.POINT((int)(short)m.LParam, (int)m.LParam >> 16);
                        NativeMethods.MapWindowPoints(IntPtr.Zero,((Control)(host.RootComponent)).Handle, point, 1);
                        if(point.y < 0 && point.y > (-1*menuHeight)) {
                            m.Result = (IntPtr)NativeMethods.HTMENU;
                            return true;
                        }
                    }


                    //If there's been a mouse button down in our non-client (a.k.a HTMENU) area 
                    //we should be activating the menu editor...
                    //
                    if((m.Msg == NativeMethods.WM_NCLBUTTONDOWN || m.Msg == NativeMethods.WM_NCRBUTTONDOWN)
                        && (int)m.WParam == NativeMethods.HTMENU) {
                            menuEditor.SelectionChange((IntPtr)UNKNOWN_MENU_ITEM);
                            return true;
                    }


                }
                catch (Exception) {
                }
            }
            return false;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.GetUIState"]/*' />
        /// <devdoc>
        ///     Determines if the user is actually editing a menu item - in other words, the in-situ edit box
        ///     is active on the menu editor.
        /// </devdoc>
        private bool GetUIState() {
            if(menuEditor == null)
                return false;

            int uiState;
            menuEditor.GetUIState(out uiState);

            if (uiState == 1)
                return true;

            return false;
        }


        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IsActive"]/*' />
        /// <devdoc>
        ///     Returns a bool representing the active state of the current menu
        /// </devdoc>
        public bool IsActive() {
            if(menuEditor == null)
                return false;

            bool b;
            menuEditor.IsActive(out b);
            return b;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IsSupported"]/*' />
        /// <devdoc>
        ///     We simply pass this message along to the vs menu editor.  This allows for dragging/dropping 
        ///     menu items to and from the toolbox.
        /// </devdoc>
        int IVsToolboxUser.IsSupported(NativeMethods.IOleDataObject pDO) {
            if (menuEditor != null)
                return ((IVsToolboxUser)menuEditor).IsSupported(pDO);
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IsItemPicked"]/*' />
        /// <devdoc>
        ///     We simply pass this message along to the vs menu editor.  This allows for dragging/dropping 
        ///     menu items to and from the toolbox.
        /// </devdoc>
        void IVsToolboxUser.ItemPicked(NativeMethods.IOleDataObject pDO){
            if (menuEditor != null)
                ((IVsToolboxUser)menuEditor).ItemPicked(pDO);
        }



        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IVsMenuEditorSite.MoveItems"]/*' />
        /// <devdoc>
        ///     Moves 1 or more menu items.  This method is called by the IVsMenuEditor.
        /// </devdoc>
        void IVsMenuEditorSite.MoveItems(IVsMenuItem pIMIFirst, IVsMenuItem pIMILast, IVsMenuItem pIMIParent, IVsMenuItem pIMIInsertAfter) {

            DesignerTransaction trans = host.CreateTransaction(SR.GetString(SR.DesignerBatchMoveMenu));

            //create an array (possibly 1-length) of items that we need to move
            MenuItem[] menusToMove = null;

            try {
    
                if( pIMIFirst.Equals(pIMILast)) {
                    menusToMove = new MenuItem[1];
                    menusToMove[0] = (MenuItem)((MenuDesigner)pIMIFirst).Component;
                }
                else {
                    MenuItem first = (MenuItem)((MenuDesigner)pIMIFirst).Component;
                    MenuItem last  = (MenuItem)((MenuDesigner)pIMILast).Component;
                    Menu menuParent= first.Parent;
    
                    int firstIndex = -1;
                    int lastIndex  = -1;
                    int arraySize  = 0;
    
                    //get the index of the first & last so we know the # of items being moved
                    for(int i = 0; i < menuParent.MenuItems.Count; i++) {
                        if(menuParent.MenuItems[i].Equals(first)) {
                            firstIndex = i;
                            break;
                        }
                    }
                    if(firstIndex == -1 ) {
                        return;
                    }
                    for(int i = firstIndex + 1; i < menuParent.MenuItems.Count; i++) {
                        if(menuParent.MenuItems[i].Equals(last)) {
                            lastIndex = i;
                            break;
                        }
                    }
                    if(lastIndex == -1 ) {
                        return;
                    }
                    //create the array of appropreate size and add items to it
                    arraySize = lastIndex - firstIndex + 1;
                    menusToMove = new MenuItem[arraySize];
    
                    for(int i = firstIndex; i <= lastIndex; i++) {
                        menusToMove[ i - firstIndex] = menuParent.MenuItems[i];
                    }
                }
    
                Menu menuOldParent = ((MenuItem)((MenuDesigner)pIMIFirst).Component).Parent;
                Menu menuNewParent = null;
    
                if (menuOldParent != null) {
    
                    if (compChange != null) {
                        compChange.OnComponentChanging(menuOldParent, null);
                    }
    
                    //remove the item(s) from the old parent's collection
                    for(int i = 0; i < menusToMove.Length; i++) {
                        menuOldParent.MenuItems.Remove(menusToMove[i]);
                    }
                    
                    if (compChange != null) {
                        MenuChangedLocally = true;
                        compChange.OnComponentChanged(menuOldParent, null, null, null);
                    }
                }
    
                if(pIMIInsertAfter == null) {
                    //We are adding these items @ the beginning of the collection...
    
                    if(pIMIParent == null)
                        menuNewParent = (Menu)activeMenu;
                    else
                        menuNewParent = (Menu)((MenuDesigner)pIMIParent).Component;
    
                    if (compChange != null) {
                        compChange.OnComponentChanging(menuNewParent, null);
                    }
    
                    for(int i = 0; i < menusToMove.Length; i++ ) {
                        menuNewParent.MenuItems.Add(i, menusToMove[i]);
                    }

                    if (compChange != null) {
                        MenuChangedLocally = true;
                        compChange.OnComponentChanged(menuNewParent, null, null, null);
                    }
                }
                else {
                    //we are adding these items somewhere in the middle of the array
                    MenuItem menuInsertAfter = (MenuItem)((MenuDesigner)pIMIInsertAfter).Component;
                    menuNewParent = menuInsertAfter.Parent;
    
                    if (compChange != null) {
                        compChange.OnComponentChanging(menuNewParent, null);
                    }
    
                    int insertIndex = -1;
                    for(int i = 0; i < menuNewParent.MenuItems.Count; i++) {
                        if(menuNewParent.MenuItems[i].Equals(menuInsertAfter)) {
                            insertIndex = i + 1;
                            break;
                        }
                    }
                    if( insertIndex == -1)
                        return;
    
                    for(int i = 0; i < menusToMove.Length; i++)
                        menuNewParent.MenuItems.Add( i + insertIndex, menusToMove[i]);

    
                    if (compChange != null) {
                        MenuChangedLocally = true;
                        compChange.OnComponentChanged(menuNewParent, null, null, null);
                    }
                }

                //if we just moved menu items to the top level, undo their check state (if checked)
                if (menuNewParent != null && menuNewParent == activeMenu) {
                    for (int i = 0; i < menusToMove.Length; i++) {
                        if (menusToMove[i].Checked) {
                            MenuDesigner des = (MenuDesigner)host.GetDesigner(menusToMove[i]);
                            if (des != null) {
                                //have the menu designer set this property, this way, it'll take care of
                                //adding this to the undo stack
                                des.IMISetProp(__VSMEPROPID.VSMEPROPID_CHECKED, false);
                            }
                        }
                    }
                }
            }
            finally {
                trans.Commit();
            }
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.NativeMethods.IOleCommandTarget.QueryStatus"]/*' />
        /// <devdoc>
        ///     Inquires about the status of a command.  A command's status indicates
        ///     it's availability on the menu, it's visibility, and it's checked state.
        ///
        ///     The exception thrown by this method indicates the current command status.
        /// </devdoc>
        int NativeMethods.IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, int cCmds, NativeMethods._tagOLECMD prgCmds, IntPtr pCmdText) {

            // Since the menu can be in different states when QueryStatus is called, 
            // this is the order in which we pass the cmd around:
            // 1) if the in-situ edit box is in place on the menu item, always return 
            //    not supported.  Otherwise, the windows control won't get the undo/redo msg.
            // 2) if the menu editor is valid (has items and is currently displaying them),
            //    then we'll first ask it if it wants this message, if so, we just return s_ok.
            // 3) finally, we pass the message to the command target, and return that result.
            bool activeAndValid = IsActive()
                               && activeMenu != null
                               && (activeMenu.MenuItems.Count > 0);

            int hr = NativeMethods.OLECMDERR_E_UNKNOWNGROUP;

            if (GetUIState()) {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
            if (activeAndValid && menuCommandTarget != null) {
                hr =  menuCommandTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            }
            else if (hostCommandTarget != null) {
                hr = hostCommandTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            }

            return hr;
        }

        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.IVsMenuEditorSite.SelectionChange"]/*' />
        /// <devdoc>
        ///     Called by the shell's menu editor when a selection change has been made.
        /// </devdoc>
        void IVsMenuEditorSite.SelectionChange(IntPtr ppIMI, int SelCmd) {
            if (menuEditor == null) {
                return;
            }

            //If we have an open designer transaction, commit.
            //This could happen if we're expecting the native menueditor
            //to set the text of an item - and the selection suddenly 
            //changes.
            CommitTransaction();

            //get the maximum dimensions of all our menus, then determine
            //if we need to scroll the designerframe's Window...
            //
            if (designerFrame != null) {
                tagRECT menuRECT = new tagRECT();
                int result = menuEditor.GetItemRect(null, menuRECT, 0);
                if (result == 0 && ppIMI != IntPtr.Zero) {
                    Size designerSize = designerFrame.AutoScrollMinSize;
                    Point scrollPosition = designerFrame.AutoScrollPosition;

                    if (designerSize.Width < menuRECT.right - scrollPosition.X) {
                        designerSize.Width = menuRECT.right - scrollPosition.X;
                    }
                    if (designerSize.Height < menuRECT.bottom - scrollPosition.Y) {
                        designerSize.Height = menuRECT.bottom - scrollPosition.Y;
                    }
                    
                    designerFrame.AutoScrollMinSize = designerSize;
                }
            }

            if (selectedMenuDesigner != null) {
                //tell the currently selected menu, that its losing selection
                selectedMenuDesigner.LosingSelection();
            }

            if (ppIMI == IntPtr.Zero) {
                selectedMenuDesigner = null;
                //If we just set a null selection, don't set the selection again!
                if (!justSetNullSelection) {
                    ISelectionService svc = (ISelectionService)host.GetService(typeof(ISelectionService));
                    if (svc != null) {
                        if (!IsActive()) {
                            object baseControl = host.RootComponent;
                            if (baseControl != null) {
                                svc.SetSelectedComponents( new object[]{baseControl}, SelectionTypes.Replace);
                            }
                        }
                        else {
                            svc.SetSelectedComponents( null, SelectionTypes.Replace);
                        }
                    }
                }
                return;
            }
            // Here, we're going to marshal this pointer into an array of menu items.
            // We'll walk the array using ReadInt32 and store them into an ArrayList.
            // Then... to an array of IVsMenuItems
            int         iteration   = 0;
            IntPtr      retVal      = IntPtr.Zero;
            ArrayList   items       = new ArrayList();
            
            while( (retVal = Marshal.ReadIntPtr((IntPtr)((long)ppIMI + (iteration*4)), 0)) != IntPtr.Zero) {
                Object item = Marshal.GetObjectForIUnknown(retVal);
                if (item != null && item is IVsMenuItem) {
                    items.Add(item);
                }     
                iteration++;
            }
                
            if(items.Count == 0) return;

            IVsMenuItem[] menuItems = new IVsMenuItem[items.Count];
            items.CopyTo(menuItems,0);

            //here, we will save the newly selected menu, so that we can 
            //tell it to flush its cache, when we change selection
            if (menuItems[0] is MenuDesigner) {
                selectedMenuDesigner = (MenuDesigner)menuItems[0];
            }
            
            //Selection change is begin called
            if(SelCmd == __VSMESELCMD.SELCMD_SELCHANGE) {

                Object[] selectedMenuItems = new Object[menuItems.Length];
                       
                //build an array of all the selected object
                for(int i = 0; i < menuItems.Length; i++) {
                    selectedMenuItems[i] = ((MenuDesigner)menuItems[i]).Component;
                }
                ISelectionService svc = (ISelectionService)host.GetService(typeof(ISelectionService));
                if (svc != null) {
                    svc.SetSelectedComponents( selectedMenuItems, SelectionTypes.Replace);
                }
                //if we've just create a menu item & the "in-place" edit is not active
                //i.e. we didn't just start typing in a "type here" box, then we've 
                //done something like copy/pasted/undo/redo/etc... so lets make sure
                //that any text we have in our text cache is flushed
                //
                if (!GetUIState() && selectedMenuDesigner != null) {
                    selectedMenuDesigner.LosingSelection();
                }
                
            }
            //View code is being requested
            else if(SelCmd == __VSMESELCMD.SELCMD_VIEWCODE) {
                IEventBindingService ebs = (IEventBindingService)host.GetService(typeof(IEventBindingService));
                if (ebs != null) {
                    ebs.ShowCode();
                }
            }
            //Create the default event
            else if(SelCmd == __VSMESELCMD.SELCMD_VIEWCODEDOUBLECLICK) {
                ((MenuDesigner)menuItems[0]).DoDefaultAction();
            }
            //Need to show the properties window here
            else if(SelCmd == __VSMESELCMD.SELCMD_PROPERTIES) {
                IMenuCommandService menuSvc = (IMenuCommandService)host.GetService(typeof(IMenuCommandService));
                if (menuSvc != null){
                    menuSvc.GlobalInvoke(MenuCommands.PropertiesWindow);
                }
            }
            //if we're leaving a edit, we ALWAYS want to make sure
            //we've commited our transaction
            else if (SelCmd == __VSMESELCMD.SELCMD_LEAVEEDIT) {
                CommitTransaction();
            }
        }
        
        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.SetMenu"]/*' />
        /// <devdoc>
        ///     Sets the current menu visible on the form.  The menu will be painted
        ///     at the top of a form's window frame and can be directly edited
        ///     by the user.
        /// </devdoc>
        public void SetMenu(Menu menu) {
            if (menuEditor != null) {
                try {
                    justSetNullSelection = true;
                    menuEditor.SelectionChange(IntPtr.Zero);
                    if (designerFrame != null) {
                        designerFrame.AutoScrollMinSize = Size.Empty;
                    }
                }
                finally {
                    justSetNullSelection = false;
                }
            }

            if (menu == activeMenu)
                return;

            DisposeMenuEditor();

            if (menu == null)
                return;
            
            activeMenu = menu;

            CreateMenuEditor();

            if (menuEditor != null) {

                IDesigner designer = host.GetDesigner(menu);

                Debug.Assert(designer is MenuDesigner, "Host returned a designer that is not a MenuDesigner");

                MenuDesigner menuDesigner = (MenuDesigner)designer;

                menuDesigner.Editor = menuEditor;
                menuDesigner.FillMenu(menu);

                // Resize the window to accomodate the height of the menu, only if the menu 
                // is not inherited.
                //
                Control baseControl = (Control)host.RootComponent;
                if (baseControl != null) {
                
                    NativeMethods.RECT rc = new NativeMethods.RECT();
                    NativeMethods.GetWindowRect(baseControl.Handle, ref rc);

                    //The only time we want to change the height is if we're not an 
                    //inherited menu currently loading
                    //
                    if (!(IsMenuInherited && host.Loading)) {
                        rc.bottom += menuHeight;
                    }

                    NativeMethods.SetWindowPos(baseControl.Handle, IntPtr.Zero, 
                        0, 0, rc.right - rc.left, rc.bottom - rc.top,
                        NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOZORDER);
                }
                if (activeMenu.MenuItems.Count > 0) {
                    menuEditor.AddMenuItem(null,null,null);
                }

            }
        }


        /// <include file='doc\MenuEditorService.uex' path='docs/doc[@for="MenuEditorService.SetSelection"]/*' />
        /// <devdoc>
        ///     Sets the selected menu item of the current menu
        /// </devdoc>
        public void SetSelection(MenuItem item) {
        
            // make sure we have a menuEditor service.  if someone deleted
            // the main menu and manages  to select a menuitem, we bail.
            // this can happen when you drag a MainMenu from one form to another.
            if (menuEditor == null || item == null) {
                return;
            }
            
            IVsMenuItem itemToSelect = (IVsMenuItem)((MenuDesigner)host.GetDesigner(item));
            menuEditor.SelectionChangeFocus(itemToSelect);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static BooleanSwitch commonDesignerServices;
        
        public static BooleanSwitch CommonDesignerServices {
            get {
                if (commonDesignerServices == null) {
                    commonDesignerServices = new BooleanSwitch("CommonDesignerServices", "Assert if any common designer service is not found.");
                }
                return commonDesignerServices;
            }
        }                        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\changeiid\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\axtowfc\axtowfc.cs ===
//------------------------------------------------------------------'------------
// <copyright file="AxToWFC.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Tools {
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Diagnostics;
    using System;
    using System.Text;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Collections.Specialized;

    /// <include file='doc\AxToWFC.uex' path='docs/doc[@for="AxImp"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AxImp {
        private const int ErrorReturnCode = 100;
        private const int SuccessReturnCode = 0;
        private const int errorCode = unchecked((int)0xbaadbaad);
        
        private const int MAX_PATH = 260;

        private static AxImporter.Options options;
        private static NameValueCollection rcwReferences = new NameValueCollection();
        private static StringCollection    rcwOptions = new StringCollection();

        private static string typeLibName;
        
        internal static BooleanSwitch AxImpSwitch = new BooleanSwitch("AxImp", "ActiveX wrapper generation application.");

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int SearchPath(string lpPath, string lpFileName, string lpExtension, int nBufferLength, StringBuilder lpBuffer, int[] lpFilePart);

        private static bool ArgumentMatch(string arg, string formal) {
            if (arg[0] != '/' && arg[0] != '-') {
                return false;
            }
            arg = arg.Substring(1);
            return(arg == formal);
        }


        /// <include file='doc\AxToWFC.uex' path='docs/doc[@for="AxImp.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        unsafe public static void Main(string[] args) {
            Environment.ExitCode = errorCode;

            int err = SuccessReturnCode;              
            
            if (!ParseArguments(args, ref options, ref err))
                return;

            if (!FillRcwReferences(ref err)) {
                return;
            }

            if (rcwReferences.Count >= 1) {
                options.references = (AxImporter.IReferenceResolver)
                    new AxImporterResolver(rcwReferences);
            }
            
            try {
                Run(options);
            }
            catch (Exception e) {
                Console.WriteLine(AxImpSR.GetString(AxImpSR.AxImpError, e.Message));
                return;
            }

            Environment.ExitCode = 0;
        }

        private static bool ParseArguments(String []aArgs, ref AxImporter.Options Options, ref int ReturnCode) {
            CommandLine cmdLine;
            Option opt;
            
            // Create the options object that will be returned.
            options = new AxImporter.Options();

            options.outputDirectory = Environment.CurrentDirectory;
            options.overwriteRCW = true;

            // Parse the command line arguments using the command line argument parser.
            try {
                cmdLine = new CommandLine(aArgs, new String[] {"*out", "*publickey", "*keyfile", "*keycontainer", 
                    "source", "delaysign", "nologo", "silent", "verbose", "?", "help", "*rcw"});
            }
            catch (ApplicationException e) {
                PrintLogo();
                WriteErrorMsg(null, e);
                ReturnCode = ErrorReturnCode;
                return false;           
            }

            // Make sure there is at least one argument.
            if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1) {
                PrintUsage();
                ReturnCode = SuccessReturnCode;
                return false;
            }

            // Get the name of the COM typelib.
            typeLibName = cmdLine.GetNextArg();
            
            // Go through the list of options.
            while ((opt = cmdLine.GetNextOption()) != null) {
                // Determine which option was specified.
                if (opt.Name.Equals("out")) {
                    FileInfo fi = new FileInfo(opt.Value);
                    string dir = fi.Directory.FullName;
                    if (dir != null && dir.Length > 0) {
                        options.outputDirectory = dir;
                    }

                    options.outputName = fi.Name;
                }
                else if (opt.Name.Equals("publickey")) {
                    if (options.keyPair != null || options.publicKey != null) {
                        PrintLogo();
                        WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_TooManyKeys));
                        ReturnCode = ErrorReturnCode;
                        return false;
                    }
                    // Read data from binary file into byte array.
                    byte[] aData;
                    try {
                        FileStream fs = new FileStream(opt.Value, FileMode.Open, FileAccess.Read, FileShare.Read);
                        int iLength = (int)fs.Length;
                        aData = new byte[iLength];
                        fs.Read(aData, 0, iLength);
                        fs.Close();
                    }
                    catch (Exception e) {
                        PrintLogo();
                        WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_ErrorWhileOpeningFile, opt.Value), e);
                        ReturnCode = ErrorReturnCode;
                        return false;
                    }
                    options.publicKey = aData;
                }
                else if (opt.Name.Equals("keyfile")) {
                    if (options.keyPair != null || options.publicKey != null) {
                        PrintLogo();
                        WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_TooManyKeys));
                        ReturnCode = ErrorReturnCode;
                        return false;
                    }
                    // Read data from binary file into byte array.
                    byte[] aData;
                    try {
                        FileStream fs = new FileStream(opt.Value, FileMode.Open, FileAccess.Read);
                        int iLength = (int)fs.Length;
                        aData = new byte[iLength];
                        fs.Read(aData, 0, iLength);
                        fs.Close();
                    }
                    catch (Exception e) {
                        PrintLogo();
                        WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_ErrorWhileOpeningFile, opt.Value), e);
                        ReturnCode = ErrorReturnCode;
                        return false;
                    }
                    options.keyFile = opt.Value;
                    options.keyPair = new StrongNameKeyPair(aData);
                }
                else if (opt.Name.Equals("keycontainer")) {
                    if (options.keyPair != null) {
                        PrintLogo();
                        WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_TooManyKeys));
                        ReturnCode = ErrorReturnCode;
                        return false;
                    }
                    options.keyContainer = opt.Value;
                    options.keyPair = new StrongNameKeyPair(opt.Value);
                }
                else if (opt.Name.Equals("source")) {
                    options.genSources = true;
                }
                else if (opt.Name.Equals("delaysign"))
                    options.delaySign = true;
                else if (opt.Name.Equals("nologo"))
                    options.noLogo = true;
                else if (opt.Name.Equals("silent"))
                    options.silentMode = true;
                else if (opt.Name.Equals("rcw")) {
                    // Store away for later processing
                    rcwOptions.Add(opt.Value);
                }
                else if (opt.Name.Equals("verbose"))
                    options.verboseMode = true;
                else if (opt.Name.Equals("?") || opt.Name.Equals("help")) {
                    PrintUsage();
                    ReturnCode = SuccessReturnCode;
                    return false;
                }
                else {
                    PrintLogo();
                    WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_InvalidOption));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
            }

            // Validate that the typelib name has been specified.
            if (typeLibName == null) {
                PrintLogo();
                WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_NoInputFile));
                ReturnCode = ErrorReturnCode;
                return false;
            }

            // Gather information needed for strong naming the assembly (if
            // the user desires this).
            if ((options.keyPair != null) && (options.publicKey == null)) {
                try {
                    options.publicKey = options.keyPair.PublicKey;
                }
                catch (Exception) {
                    PrintLogo();
                    WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_InvalidStrongName));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
            }

            if (options.delaySign && options.keyPair == null && options.keyContainer == null) {
                PrintLogo();
                WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_DelaySignError));
                ReturnCode = ErrorReturnCode;
                return false;
            }

            if (!File.Exists(typeLibName)) {
                FileInfo file = new FileInfo(typeLibName);
                PrintLogo();
                WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_FileNotExists, file.FullName));
                ReturnCode = ErrorReturnCode;
                return false;
            }

            return true;
        }

        private static bool FillRcwReferences(ref int returnCode)
        {
            // Stash correspondence between typelib name and RCW dll.  Typelib
            // name found through assembly level attribute on the RCW dll.
            
            foreach (string rcwPartialPath in rcwOptions) {
            
                string rcwPath = Path.Combine(Environment.CurrentDirectory, rcwPartialPath);

                if (!File.Exists(rcwPath)) {
                    WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_RefAssemblyNotFound, rcwPath));
                    returnCode = ErrorReturnCode;
                    return false;
                }
            
                Assembly asm;   
                try
                {
                    asm = Assembly.LoadFrom(rcwPath);
                }
                catch (Exception e)
                {
                    WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_AssemblyLoadFailed, rcwPath, e.Message));
                    returnCode = ErrorReturnCode;
                    return false;
                }
                
                object [] attrs = asm.GetCustomAttributes(typeof(ImportedFromTypeLibAttribute), true);
                if (attrs.Length != 1) {
                    WriteErrorMsg(AxImpSR.GetString(AxImpSR.Err_NotRcw, rcwPath));
                    returnCode = ErrorReturnCode;
                    return false;
                }
                
                ImportedFromTypeLibAttribute attr = (ImportedFromTypeLibAttribute)(attrs[0]);
                rcwReferences[attr.Value] = rcwPath;

            }
            
            return true;
        
        }

        private static void PrintLogo() {
            if (!options.noLogo) {
                Console.WriteLine(AxImpSR.GetString(AxImpSR.Logo, Environment.Version, ThisAssembly.Copyright));
            }
        }

        private static void PrintUsage() {
            PrintLogo();

            Console.WriteLine(AxImpSR.GetString(AxImpSR.Usage, Environment.Version));
        }

        /// <include file='doc\AxToWFC.uex' path='docs/doc[@for="AxImp.Run"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private static void Run(AxImporter.Options options) {
            string[] assemsGenerated;

            AxImporter importer = new AxImporter(options);

            FileInfo file = new FileInfo(typeLibName);
            string axctlType = importer.GenerateFromFile(file);

            if (!options.silentMode && options.genSources && importer.GeneratedSources.Length > 0) {
                string[] srcGen = importer.GeneratedSources;
                foreach( string s in srcGen ) {
                    Console.WriteLine(AxImpSR.GetString(AxImpSR.GeneratedSource, s));
                }
            }

            if (!options.silentMode) {
                assemsGenerated = importer.GeneratedAssemblies;
                foreach(string a in assemsGenerated) {
                    Console.WriteLine(AxImpSR.GetString(AxImpSR.GeneratedAssembly, a));
                }
            }
        }

        internal static void WriteErrorMsg(String strPrefix, Exception e) {
            String strErrorMsg = "";
            if (strPrefix != null)
                strErrorMsg = strPrefix;

            if (e.Message != null) {
                strErrorMsg += e.Message;
            }
            else {
                strErrorMsg += e.GetType().ToString();
            }

            Console.Error.WriteLine(AxImpSR.GetString(AxImpSR.AxImpError, strErrorMsg));
        }

        internal static void WriteErrorMsg(String strErrorMsg) {
            Console.Error.WriteLine(AxImpSR.GetString(AxImpSR.AxImpError, strErrorMsg));
        }
    
        private class AxImporterResolver : AxImporter.IReferenceResolver
        {
            public AxImporterResolver(NameValueCollection rcwRefs)
            {
                this.rcwReferences = rcwRefs;
            }
            
            string AxImporter.IReferenceResolver.ResolveManagedReference(string assemName)
            {
                // Match AxImporter behavior when there is no resolver.
                return assemName + ".dll";
            }
            
            string AxImporter.IReferenceResolver.ResolveComReference(UCOMITypeLib typeLib)
            {
                string rcwName = Marshal.GetTypeLibName(typeLib);
                
                // It's OK if this returns null, meaning no match.
                return rcwReferences[rcwName];
            }
            
            string AxImporter.IReferenceResolver.ResolveComReference(AssemblyName name)
            {
                string resolvedReference = rcwReferences[name.Name];
                if (resolvedReference == null)
                {
                    // Match AxImporter behavior when there is no resolver.
                    resolvedReference = name.EscapedCodeBase;
                }

                return resolvedReference;
            }
            
            string AxImporter.IReferenceResolver.ResolveActiveXReference(UCOMITypeLib typeLib)
            {
                // Match AxImporter behavior when there is no resolver.
                return null;
            }
            
            private NameValueCollection rcwReferences;

        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\styledesigner\pages\textstylepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextStylePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// TextStylePage.cs
//
// 12/22/98: Created: NikhilKo
//

namespace Microsoft.VisualStudio.StyleDesigner.Pages {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.VisualStudio.StyleDesigner;
    using Microsoft.VisualStudio.StyleDesigner.Controls;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Interop.Trident;

    /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage"]/*' />
    /// <devdoc>
    ///     TextStylePage
    ///     The standard edges page used in the StyleBuilder to text formatting
    ///     attributes of a CSS style and a VSForms element.
    ///
    ///     Wordspacing support is currently ifdef'd out within #if SUPPORT_WORDSPACING
    ///     code. If this is enabled, some UI layout changes in other parts of code will
    ///     also be required.
    ///
    ///     Whitespace support is currently ifdef'd out within #if SUPPORT_WHITESPACE
    ///     code. Enabling this should require minimal UI changes if any, since its the
    ///     last thing on the page.
    /// </devdoc>
    internal sealed class TextStylePage : StyleBuilderPage {
        ///////////////////////////////////////////////////////////////////////////
        // Constants
        private static readonly string HELP_KEYWORD = "vs.StyleBuilder.Text";

        // Horizontal Alignment constants
        private const int IDX_HALIGN_LEFT = 1;
        private const int IDX_HALIGN_CENTERED = 2;
        private const int IDX_HALIGN_RIGHT = 3;
        private const int IDX_HALIGN_JUSTIFIED = 4;

        private readonly static string[] HALIGN_VALUES = new string[]
        {
            null, "left", "center", "right", "justify"
        };

        // Vertical Alignment constants
        private const int IDX_VALIGN_SUB = 1;
        private const int IDX_VALIGN_SUP = 2;
        private const int IDX_VALIGN_BASELINE = 3;

        private readonly static string[] VALIGN_VALUES = new string[]
        {
            null, "sub", "super", "baseline"
        };

        // Justification constants
        private const int IDX_JUSTIFY_AUTO = 1;
        private const int IDX_JUSTIFY_WORD = 2;
        private const int IDX_JUSTIFY_LETTERWORD = 3;
        private const int IDX_JUSTIFY_DISTRIBUTE = 4;
        private const int IDX_JUSTIFY_DISTRIBUTELINES = 5;

        private readonly static string[] JUSTIFY_VALUES = new string[]
        {
            null, "auto", "inter-word", "newspaper", "distribute", "distribute-all-lines"
        };

        // Spacing constants
        private const int IDX_SPC_NORMAL = 1;
        private const int IDX_SPC_CUSTOM = 2;

        private readonly static string SPACE_NORMAL_VALUE = "normal";

        // Direction constants
        private const int IDX_DIRECTION_LTR = 1;
        private const int IDX_DIRECTION_RTL = 2;

        private readonly static string[] DIRECTION_VALUES = new string[]
        {
            null, "ltr", "rtl"
        };

    #if SUPPORRT_WHITESPACE
        // Whitespace constants
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.IDX_WHITESPC_NORMAL"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int IDX_WHITESPC_NORMAL = 1;
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.IDX_WHITESPC_PRE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int IDX_WHITESPC_PRE = 2;
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.IDX_WHITESPC_NOWRAP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected const int IDX_WHITESPC_NOWRAP = 3;

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.WHITESPACE_VALUES"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected readonly static string[] WHITESPACE_VALUES = new string[]
        {
            null, "normal", "pre", "nowrap"
        };
    #endif // SUPPORT_WHITESPACE

        // Preview Constants
        private readonly static string PREVIEW_TEMPLATE =
            "<div style=\"height: 100%; width: 100%; padding: 0px; margin: 0px\">" +
                "<div id=\"divText\">" +
                    "<span id=\"spanNormal\"></span>&nbsp;" +
                    "<span id=\"spanTextPreview\">" +
                        "<span id=\"spanInflow\"></span>" +
                        "<div id=\"divTextPreview\"></div>" +
                    "</span>" +
                "</div>" +
            "</div>";
        private readonly static string PREVIEW_ELEM1_ID = "spanTextPreview";
        private readonly static string PREVIEW_ELEM2_ID = "divTextPreview";
        private readonly static string PREVIEW_FONTELEM_ID = "divText";
        private readonly static string PREVIEW_NORMALELEM_ID = "spanNormal";
        private readonly static string PREVIEW_INFLOWELEM_ID = "spanInflow";


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private CSSAttribute horzAlignAttribute;
        private CSSAttribute justificationAttribute;
        private CSSAttribute verticalAlignAttribute;
        private CSSAttribute letterSpacingAttribute;
    #if SUPPORT_WORDSPACING
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.wordSpacingAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected CSSAttribute wordSpacingAttribute;
    #endif // SUPPORT_WORDSPACING
        private CSSAttribute lineSpacingAttribute;
        private CSSAttribute indentationAttribute;
        private CSSAttribute directionAttribute;
    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.whitespaceAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected CSSAttribute whitespaceAttribute;
    #endif // SUPPORT_WHITESPACE

        private IHTMLStyle previewFlowStyle;
        private IHTMLStyle previewBlockStyle1;
        private IHTMLStyle2 previewBlockStyle2;

        private UnsettableComboBox horzAlignCombo;
        private UnsettableComboBox justificationCombo;
        private UnsettableComboBox vertAlignCombo;
        private UnsettableComboBox letterSpacingCombo;
        private UnitControl letterSpacingUnit;
    #if SUPPORT_WORDSPACING
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.wordSpacingCombo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected UnsettableComboBox wordSpacingCombo;
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.wordSpacingUnit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected UnitControl wordSpacingUnit;
    #endif // SUPPORT_WORDSPACING
        private UnsettableComboBox lineSpacingCombo;
        private UnitControl lineSpacingUnit;
        private UnitControl indentationUnit;
        private UnsettableComboBox directionCombo;
    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.whitespaceCombo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected UnsettableComboBox whitespaceCombo;
    #endif // SUPPORT_WHITESPACE


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.TextStylePage"]/*' />
        /// <devdoc>
        ///     Creates a new StyleTextPage
        /// </devdoc>
        public TextStylePage()
            : base() {
            InitForm();
            SetIcon(new Icon(typeof(TextStylePage), "TextPage.ico"));
            SetHelpKeyword(TextStylePage.HELP_KEYWORD);
            SetDefaultSize(Size);
        }


        ///////////////////////////////////////////////////////////////////////////
        // IStyleBuilderPage Implementation and StyleBuilderPage Overrides

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.ActivatePage"]/*' />
        /// <devdoc>
        ///     The page is now the currently active page in the StyleBuilder.
        ///     Be sure to call super.activatePage, so that the page is made visible.
        /// </devdoc>
        protected override void ActivatePage() {
            base.ActivatePage();

            // initialize the preview
            IStyleBuilderPreview preview = null;

            if (Site != null)
                preview = (IStyleBuilderPreview)Site.GetService(typeof(IStyleBuilderPreview));

            if (preview != null) {
                try
                {
                    IHTMLElement tempElem = null;
                    IHTMLElement previewElem = preview.GetPreviewElement();

                    previewElem.SetInnerHTML(PREVIEW_TEMPLATE);

                    tempElem = preview.GetElement(PREVIEW_NORMALELEM_ID);
                    if (tempElem != null)
                    {
                        tempElem.SetInnerHTML(SR.GetString(SR.TxtSP_PreviewTextNormal));
                        tempElem = null;
                    }

                    tempElem = preview.GetElement(PREVIEW_INFLOWELEM_ID);
                    if (tempElem != null)
                    {
                        tempElem.SetInnerHTML(SR.GetString(SR.TxtSP_PreviewTextInflow));
                        tempElem = null;
                    }

                    tempElem = preview.GetElement(PREVIEW_ELEM1_ID);
                    if (tempElem != null)
                    {
                        previewFlowStyle = tempElem.GetStyle();
                    }

                    tempElem = preview.GetElement(PREVIEW_ELEM2_ID);
                    if (tempElem != null)
                    {
                        tempElem.SetInnerHTML(SR.GetString(SR.TxtSP_PreviewTextPara));
                        previewBlockStyle1 = tempElem.GetStyle();

                        if (previewBlockStyle1 is IHTMLStyle2)
                            previewBlockStyle2 = (IHTMLStyle2)previewBlockStyle1;

                        tempElem = null;
                    }
                }
                catch (Exception) {
                    previewBlockStyle1 = null;
                    previewBlockStyle2 = null;
                    previewFlowStyle = null;
                    return;
                }

                Debug.Assert((previewFlowStyle != null) &&
                             (previewBlockStyle1 != null) &&
                             (previewBlockStyle2 != null),
                             "Expected to have a non-null cached preview style references");

                // Setup the font from the shared element to reflect settings in the font page
                try {
                    IHTMLElement sharedElem = preview.GetSharedElement();

                    if (sharedElem != null) {
                        IHTMLStyle tempStyle = null;
                        IHTMLElement tempElem = preview.GetElement(PREVIEW_FONTELEM_ID);
                        IHTMLStyle sharedStyle = sharedElem.GetStyle();

                        if (tempElem != null)
                            tempStyle = tempElem.GetStyle();

                        if ((tempStyle != null) && (sharedStyle != null)) {
                            tempStyle.SetTextDecoration(sharedStyle.GetTextDecoration());
                            tempStyle.SetTextTransform(sharedStyle.GetTextTransform());

                            string fontValue = sharedStyle.GetFont();
                            if ((fontValue != null) && (fontValue.Length != 0)) {
                                tempStyle.SetFont(fontValue);
                            }
                            else {
                                tempStyle.RemoveAttribute("font", 1);
                                tempStyle.SetFontFamily(sharedStyle.GetFontFamily());

                                object o = sharedStyle.GetFontSize();
                                if (o != null) {
                                    tempStyle.SetFontSize(o);
                                }
                                tempStyle.SetFontObject(sharedStyle.GetFontObject());
                                tempStyle.SetFontStyle(sharedStyle.GetFontStyle());
                                tempStyle.SetFontWeight(sharedStyle.GetFontWeight());
                            }
                        }
                    }
                } catch (Exception) {
                }

                // update initial preview
                UpdateHAlignPreview();
                UpdateJustificationPreview();
                UpdateVAlignPreview();
                UpdateSpcLettersPreview();
    #if SUPPORT_WORDSPACING
                UpdateSpcWordsPreview();
    #endif // SUPPORT_WORDSPACING
                UpdateSpcLinesPreview();
                UpdateIndentationPreview();
                UpdateDirectionPreview();
    #if SUPPORT_WHITESPACE
                UpdateWhitespacePreview();
    #endif // SUPPORT_WHITESPACE
            }
        }

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.CreateUI"]/*' />
        /// <devdoc>
        ///     Creates the UI elements within the page.
        /// </devdoc>
        protected override void CreateUI() {
            Label alignmentLabel = new GroupLabel();
            Label spacingLabel = new GroupLabel();
            Label flowLabel = new GroupLabel();
            Label horzAlignLabel = new Label();
            Label justificationLabel = new Label();
            Label vertAlignLabel = new Label();
            Label letterSpacingLabel = new Label();
    #if SUPPORT_WORDSPACING
            Label wordSpacingLabel = new Label();
    #endif // SUPPORT_WORDSPACING
            Label lineSpacingLabel = new Label();
            Label indentationLabel = new Label();
            Label directionLabel = new Label();
    #if SUPPORT_WHITESPACE
            Label whitespaceLabel = new Label();
    #endif // SUPPORT_WHITESPACE

            horzAlignCombo = new UnsettableComboBox();
            justificationCombo = new UnsettableComboBox();
            vertAlignCombo = new UnsettableComboBox();
            letterSpacingCombo = new UnsettableComboBox();
            letterSpacingUnit = new UnitControl();
    #if SUPPORT_WORDSPACING
            wordSpacingCombo = new UnsettableComboBox();
            wordSpacingUnit = new UnitControl();
    #endif // SUPPORT_WORDSPACING
            lineSpacingCombo = new UnsettableComboBox();
            lineSpacingUnit = new UnitControl();
            indentationUnit = new UnitControl();
            directionCombo = new UnsettableComboBox();
    #if SUPPORT_WHITESPACE
            whitespaceCombo = new UnsettableComboBox();
    #endif // SUPPORT_WHITESPACE

            alignmentLabel.Location = new Point(4, 4);
            alignmentLabel.Size = new Size(400, 16);
            alignmentLabel.TabIndex = 0;
            alignmentLabel.TabStop = false;
            alignmentLabel.Text = SR.GetString(SR.TxtSP_AlignmentLabel);

            horzAlignLabel.Location = new Point(8, 24);
            horzAlignLabel.Size = new Size(84, 16);
            horzAlignLabel.TabIndex = 1;
            horzAlignLabel.TabStop = false;
            horzAlignLabel.Text = SR.GetString(SR.TxtSP_HorzAlignLabel);

            horzAlignCombo.Location = new Point(92, 20);
            horzAlignCombo.Size = new Size(174, 21);
            horzAlignCombo.TabIndex = 2;
            horzAlignCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            horzAlignCombo.Items.AddRange(new object[]
                                       {
                                           SR.GetString(SR.TxtSP_HorzAlignCombo_1),
                                           SR.GetString(SR.TxtSP_HorzAlignCombo_2),
                                           SR.GetString(SR.TxtSP_HorzAlignCombo_3),
                                           SR.GetString(SR.TxtSP_HorzAlignCombo_4)
                                       });
            horzAlignCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedHAlign);

            justificationLabel.Location = new Point(8, 78);
            justificationLabel.Size = new Size(84, 16);
            justificationLabel.TabIndex = 5;
            justificationLabel.TabStop = false;
            justificationLabel.Text = SR.GetString(SR.TxtSP_JustificationLabel);

            justificationCombo.Location = new Point(92, 76);
            justificationCombo.Size = new Size(220, 21);
            justificationCombo.TabIndex = 6;
            justificationCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            justificationCombo.Items.AddRange(new object[]
                                           {
                                               SR.GetString(SR.TxtSP_JustificationCombo_1),
                                               SR.GetString(SR.TxtSP_JustificationCombo_2),
                                               SR.GetString(SR.TxtSP_JustificationCombo_3),
                                               SR.GetString(SR.TxtSP_JustificationCombo_4),
                                               SR.GetString(SR.TxtSP_JustificationCombo_5)
                                           });
            justificationCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedJustification);

            vertAlignLabel.Location = new Point(8, 52);
            vertAlignLabel.Size = new Size(84, 16);
            vertAlignLabel.TabIndex = 3;
            vertAlignLabel.TabStop = false;
            vertAlignLabel.Text = SR.GetString(SR.TxtSP_VertAlignLabel);

            vertAlignCombo.Location = new Point(92, 48);
            vertAlignCombo.Size = new Size(174, 21);
            vertAlignCombo.TabIndex = 4;
            vertAlignCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            vertAlignCombo.Items.AddRange(new object[]
                                       {
                                           SR.GetString(SR.TxtSP_VertAlignCombo_1),
                                           SR.GetString(SR.TxtSP_VertAlignCombo_2),
                                           SR.GetString(SR.TxtSP_VertAlignCombo_3)
                                       });
            vertAlignCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedVAlign);

            spacingLabel.Location = new Point(4, 98);
            spacingLabel.Size = new Size(400, 16);
            spacingLabel.TabIndex = 7;
            spacingLabel.TabStop = false;
            spacingLabel.Text = SR.GetString(SR.TxtSP_SpacingLabel);

            letterSpacingLabel.Location = new Point(8, 120);
            letterSpacingLabel.Size = new Size(84, 16);
            letterSpacingLabel.TabIndex = 8;
            letterSpacingLabel.TabStop = false;
            letterSpacingLabel.Text = SR.GetString(SR.TxtSP_SpcLettersLabel);

            letterSpacingCombo.Location = new Point(92, 116);
            letterSpacingCombo.Size = new Size(124, 21);
            letterSpacingCombo.TabIndex = 9;
            letterSpacingCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            letterSpacingCombo.Items.AddRange(new object[]
                                           {
                                               SR.GetString(SR.TxtSP_SpcCombo_1),
                                               SR.GetString(SR.TxtSP_SpcCombo_2)
                                           });
            letterSpacingCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedSpcLetters);

            letterSpacingUnit.Location = new Point(224, 116);
            letterSpacingUnit.Size = new Size(88, 21);
            letterSpacingUnit.TabIndex = 10;
            letterSpacingUnit.AllowPercentValues = false;
            letterSpacingUnit.MinValue = -512;
            letterSpacingUnit.MaxValue = 512;
            letterSpacingUnit.Changed += new EventHandler(this.OnChangedSpcLettersValue);

    #if SUPPORT_WORDSPACING
            wordSpacingLabel.Location = new Point(8, 148);
            wordSpacingLabel.Size = new Size(84, 16);
            wordSpacingLabel.TabIndex = 3;
            wordSpacingLabel.TabStop = false;
            wordSpacingLabel.Text = SR.GetString(SR.TxtSP_SpcWordsLabel);

            wordSpacingCombo.Location = new Point(92, 144);
            wordSpacingCombo.Size = new Size(124, 21);
            wordSpacingCombo.TabIndex = 4;
            wordSpacingCombo.SetStyle(ComboBoxStyle.DropDownList);
            wordSpacingCombo.Items.AddRange(new object[]
                                         {
                                             SR.GetString(SR.TxtSP_SpcCombo_1),
                                             SR.GetString(SR.TxtSP_SpcCombo_2)
                                         });
            wordSpacingCombo.AddOnSelectedIndexChanged(new EventHandler(this.OnSelChangedSpcWords));

            wordSpacingUnit.Location = new Point(224, 144);
            wordSpacingUnit.Size = new Size(88, 21);
            wordSpacingUnit.TabIndex = 5;
            wordSpacingUnit.AllowPercentValues = false;
            wordSpacingUnit.MinValue = -512;
            wordSpacingUnit.MaxValue = 512;
            wordSpacingUnit.AddOnChanged(new EventHandler(this.OnChangedSpcWordsValue));
    #endif // SUPPORT_WORDSPACING

            lineSpacingLabel.Location = new Point(8, 148);
            lineSpacingLabel.Size = new Size(84, 16);
            lineSpacingLabel.TabIndex = 11;
            lineSpacingLabel.TabStop = false;
            lineSpacingLabel.Text = SR.GetString(SR.TxtSP_SpcLinesLabel);

            lineSpacingCombo.Location = new Point(92, 144);
            lineSpacingCombo.Size = new Size(124, 21);
            lineSpacingCombo.TabIndex = 12;
            lineSpacingCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            lineSpacingCombo.Items.AddRange(new object[]
                                         {
                                             SR.GetString(SR.TxtSP_SpcCombo_1),
                                             SR.GetString(SR.TxtSP_SpcCombo_2)
                                         });
            lineSpacingCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedSpcLines);

            lineSpacingUnit.Location = new Point(224, 144);
            lineSpacingUnit.Size = new Size(88, 21);
            lineSpacingUnit.TabIndex = 13;
            lineSpacingUnit.AllowNonUnitValues = true;
            lineSpacingUnit.AllowNegativeValues = false;
            lineSpacingUnit.MaxValue = 512;
            lineSpacingUnit.Changed += new EventHandler(this.OnChangedSpcLinesValue);

            flowLabel.Location = new Point(4, 174);
            flowLabel.Size = new Size(400, 16);
            flowLabel.TabIndex = 14;
            flowLabel.TabStop = false;
            flowLabel.Text = SR.GetString(SR.TxtSP_FlowLabel);

            indentationLabel.Location = new Point(8, 196);
            indentationLabel.Size = new Size(110, 16);
            indentationLabel.TabIndex = 15;
            indentationLabel.TabStop = false;
            indentationLabel.Text = SR.GetString(SR.TxtSP_IndentationLabel);

            indentationUnit.Location = new Point(118, 192);
            indentationUnit.Size = new Size(88, 21);
            indentationUnit.TabIndex = 16;
            indentationUnit.MinValue = -32768;
            indentationUnit.MaxValue = 32767;
            indentationUnit.Changed += new EventHandler(this.OnChangedIndentation);

            directionLabel.Location = new Point(8, 224);
            directionLabel.Size = new Size(110, 16);
            directionLabel.TabIndex = 17;
            directionLabel.TabStop = false;
            directionLabel.Text = SR.GetString(SR.TxtSP_DirectionLabel);

            directionCombo.Location = new Point(118, 220);
            directionCombo.Size = new Size(174, 21);
            directionCombo.TabIndex = 18;
            directionCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            directionCombo.Items.AddRange(new object[]
                                       {
                                           SR.GetString(SR.TxtSP_DirectionCombo_1),
                                           SR.GetString(SR.TxtSP_DirectionCombo_2)
                                       });
            directionCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDirection);

    #if SUPPORT_WHITESPACE
            whitespaceLabel.Location = new Point(8, 252);
            whitespaceLabel.Size = new Size(76, 16);
            whitespaceLabel.TabIndex = 19;
            whitespaceLabel.TabStop = false;
            whitespaceLabel.Text = SR.GetString(SR.TxtSP_WhitespaceLabel);

            whitespaceCombo.Location = new Point(88, 248);
            whitespaceCombo.Size = new Size(112, 21);
            whitespaceCombo.TabIndex = 20;
            whitespaceCombo.SetStyle(ComboBoxStyle.DropDownList);
            whitespaceCombo.Items.AddRange(new object[]
                                        {
                                            SR.GetString(SR.TxtSP_WhitespaceCombo_1),
                                            SR.GetString(SR.TxtSP_WhitespaceCombo_2),
                                            SR.GetString(SR.TxtSP_WhitespaceCombo_3)
                                        });
            whitespaceCombo.AddOnSelectedIndexChanged(new EventHandler(this.OnSelChangedWhitespace));
    #endif // SUPPORT_WHITESPACE

            this.Controls.Clear();                                   
            this.Controls.AddRange(new Control[] {
    #if SUPPORT_WHITESPACE
                                    whitespaceLabel,
                                    whitespaceCombo,
    #endif // SUPPORT_WHITESPACE
                                    directionLabel,
                                    directionCombo,
                                    indentationLabel,
                                    indentationUnit,
                                    flowLabel,
                                    lineSpacingLabel,
                                    lineSpacingCombo,
                                    lineSpacingUnit,
    #if SUPPORT_WORDSPACING
                                    wordSpacingLabel,
                                    wordSpacingCombo,
                                    wordSpacingUnit,
    #endif // SUPPORT_WORDSPACING
                                    letterSpacingLabel,
                                    letterSpacingCombo,
                                    letterSpacingUnit,
                                    spacingLabel,
                                    alignmentLabel,
                                    justificationLabel,
                                    justificationCombo,
                                    vertAlignLabel,
                                    vertAlignCombo,
                                    horzAlignLabel,
                                    horzAlignCombo });
        }

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.DeactivatePage"]/*' />
        /// <devdoc>
        ///     The page is being deactivated, either because the dialog is closing, or
        ///     some other page is replacing it as the active page.
        /// </devdoc>
        protected override bool DeactivatePage(bool closing, bool validate) {
            previewFlowStyle = null;
            previewBlockStyle1 = null;
            previewBlockStyle2 = null;

            return base.DeactivatePage(closing, validate);
        }

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.LoadStyles"]/*' />
        /// <devdoc>
        ///     Loads the values from the styles passed in into the UI. Also initializes
        ///     the state of the UI, and the preview to reflect the values.
        /// </devdoc>
        protected override void LoadStyles() {
            SetInitMode(true);

            // create the attributes if they've not already been created
            if (horzAlignAttribute == null) {
                horzAlignAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TEXTALIGN);
                justificationAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TEXTJUSTIFY);
                verticalAlignAttribute = new CSSAttribute(CSSAttribute.CSSATTR_VERTICALALIGN);
                letterSpacingAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LETTERSPACING);
    #if SUPPORT_WORDSPACING
                wordSpacingAttribute = new CSSAttribute(CSSAttribute.CSSATTR_WORDSPACING);
    #endif // SUPPORT_WORDSPACING
                lineSpacingAttribute = new CSSAttribute(CSSAttribute.CSSATTR_LINEHEIGHT);
                indentationAttribute = new CSSAttribute(CSSAttribute.CSSATTR_TEXTINDENT);
                directionAttribute = new CSSAttribute(CSSAttribute.CSSATTR_DIRECTION);
    #if SUPPORT_WHITESPACE
                whitespaceAttribute = new CSSAttribute(CSSAttribute.CSSATTR_WHITESPACE);
    #endif // SUPPORT_WHITESPACE
            }

            // load the attributes
            IStyleBuilderStyle[] styles = GetSelectedStyles();
            horzAlignAttribute.LoadAttribute(styles);
            justificationAttribute.LoadAttribute(styles);
            verticalAlignAttribute.LoadAttribute(styles);
            letterSpacingAttribute.LoadAttribute(styles);
    #if SUPPORT_WORDSPACING
            wordSpacingAttribute.LoadAttribute(styles);
    #endif // SUPPORT_WORDSPACING
            lineSpacingAttribute.LoadAttribute(styles);
            indentationAttribute.LoadAttribute(styles);
            directionAttribute.LoadAttribute(styles);
    #if SUPPORT_WHITESPACE
            whitespaceAttribute.LoadAttribute(styles);
    #endif // SUPPORT_WHITESPACE

            // initialize the ui with the attributes loaded
            InitHAlignUI();
            InitJustificationUI();
            InitVAlignUI();
            InitSpacingUI(letterSpacingAttribute, letterSpacingCombo, letterSpacingUnit);
    #if SUPPORT_WORDSPACING
            InitSpacingUI(wordSpacingAttribute, wordSpacingCombo, wordSpacingUnit);
    #endif // SUPPORT_WORDSPACING
            InitSpacingUI(lineSpacingAttribute, lineSpacingCombo, lineSpacingUnit);
            InitIndentationUI();
            InitDirectionUI();
    #if SUPPORT_WHITESPACE
            InitWhitespaceUI();
    #endif // SUPPORT_WHITESPACE

            SetEnabledState(true, true, true, true);

            SetInitMode(false);
        }

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.SaveStyles"]/*' />
        /// <devdoc>
        ///     Saves the values from the UI (that have been modified) to the styles
        ///     passed in.
        /// </devdoc>
        protected override void SaveStyles() {
            if (horzAlignAttribute.Dirty)
                SaveHAlign();
            if (justificationAttribute.Dirty)
                SaveJustification();
            if (verticalAlignAttribute.Dirty)
                SaveVAlign();
            if (letterSpacingAttribute.Dirty)
                SaveSpacing(letterSpacingAttribute, letterSpacingCombo, letterSpacingUnit);
    #if SUPPORT_WORDSPACING
            if (wordSpacingAttribute.Dirty)
                SaveSpacing(wordSpacingAttribute, wordSpacingCombo, wordSpacingUnit);
    #endif // SUPPORT_WORDSPACING
            if (lineSpacingAttribute.Dirty)
                SaveSpacing(lineSpacingAttribute, lineSpacingCombo, lineSpacingUnit);
            if (indentationAttribute.Dirty)
                SaveIndentation();
            if (directionAttribute.Dirty)
                SaveDirection();
    #if SUPPORT_WHITESPACE
            if (whitespaceAttribute.IsDirty())
                SaveWhitespace();
    #endif // SUPPORT_WHITESPACE
        }


        ///////////////////////////////////////////////////////////////////////////
        // Form UI related functions

        private void InitForm() {
            this.Font = Control.DefaultFont;
            this.Text = SR.GetString(SR.TxtSP_Caption);
            this.SetAutoScaleBaseSize(new Size(5, 14));
            this.ClientSize = new Size(410, 330);
        }

        private void SetEnabledState(bool justification, bool letterSpacing, bool wordSpacing, bool lineSpacing) {
            if (justification)
                justificationCombo.Enabled = horzAlignCombo.SelectedIndex == IDX_HALIGN_JUSTIFIED;

            if (letterSpacing)
                letterSpacingUnit.Enabled = letterSpacingCombo.SelectedIndex == IDX_SPC_CUSTOM;
    #if SUPPORT_WORDSPACING
            if (wordSpacing)
                wordSpacingUnit.Enabled = wordSpacingCombo.SelectedIndex == IDX_SPC_CUSTOM;
    #endif // SUPPORT_WORDSPACING
            if (lineSpacing)
                lineSpacingUnit.Enabled = lineSpacingCombo.SelectedIndex == IDX_SPC_CUSTOM;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to initialize the UI with values

        private void InitDirectionUI() {
            Debug.Assert(IsInitMode() == true,
                         "initDirectionUI called when page is not in init mode");

            directionCombo.SelectedIndex = -1;

            Debug.Assert(directionAttribute != null,
                         "Expected directionAttribute to be non-null");

            string value = directionAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < DIRECTION_VALUES.Length; i++) {
                    if (DIRECTION_VALUES[i].Equals(value)) {
                        directionCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitHAlignUI() {
            Debug.Assert(IsInitMode() == true,
                         "initHAlignUI called when page is not in init mode");

            horzAlignCombo.SelectedIndex = -1;

            Debug.Assert(horzAlignAttribute != null,
                         "Expected horzAlignAttribute to be non-null");

            string value = horzAlignAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < HALIGN_VALUES.Length; i++) {
                    if (HALIGN_VALUES[i].Equals(value)) {
                        horzAlignCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitIndentationUI() {
            Debug.Assert(IsInitMode() == true,
                         "initIndentationUI called when page is not in init mode");

            indentationUnit.Value = null;

            Debug.Assert(indentationAttribute != null,
                         "Expected indentationAttribute to be non-null");

            string value = indentationAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                indentationUnit.Value = value;
            }
        }

        private void InitJustificationUI() {
            Debug.Assert(IsInitMode() == true,
                         "initJustificationUI called when page is not in init mode");

            justificationCombo.SelectedIndex = -1;

            Debug.Assert(justificationAttribute != null,
                         "Expected justificationAttribute to be non-null");

            string value = justificationAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < JUSTIFY_VALUES.Length; i++) {
                    if (JUSTIFY_VALUES[i].Equals(value)) {
                        justificationCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

        private void InitSpacingUI(CSSAttribute aiSpacing, UnsettableComboBox cbxSpacing, UnitControl unitSpacing) {
            Debug.Assert(IsInitMode() == true,
                         "initSpacingUI called when page is not in init mode");

            cbxSpacing.SelectedIndex = -1;
            unitSpacing.Value = null;

            Debug.Assert(aiSpacing != null,
                         "Expected aiSpacing to be non-null");

            string value = aiSpacing.Value;
            if ((value != null) && (value.Length != 0)) {
                if (SPACE_NORMAL_VALUE.Equals(value))
                    cbxSpacing.SelectedIndex = IDX_SPC_NORMAL;
                else {
                    unitSpacing.Value = value;
                    if (unitSpacing.Value != null)
                        cbxSpacing.SelectedIndex = IDX_SPC_CUSTOM;
                }
            }
        }

        private void InitVAlignUI() {
            Debug.Assert(IsInitMode() == true,
                         "initVAlignUI called when page is not in init mode");

            vertAlignCombo.SelectedIndex = -1;

            Debug.Assert(verticalAlignAttribute != null,
                         "Expected verticalAlignAttribute to be non-null");

            string value = verticalAlignAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < VALIGN_VALUES.Length; i++) {
                    if (VALIGN_VALUES[i].Equals(value)) {
                        vertAlignCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }

    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.InitWhitespaceUI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InitWhitespaceUI() {
            Debug.Assert(IsInitMode() == true,
                         "initWhitespaceUI called when page is not in init mode");

            whitespaceCombo.SelectedIndex = -1;

            Debug.Assert(whitespaceAttribute != null,
                         "Expected whitespaceAttribute to be non-null");

            string value = whitespaceAttribute.Value;
            if ((value != null) && (value.Length != 0)) {
                for (int i = 1; i < WHITESPACE_VALUES.Length; i++) {
                    if (WHITESPACE_VALUES[i].Equals(value)) {
                        whitespaceCombo.SelectedIndex = i;
                        break;
                    }
                }
            }
        }
    #endif // SUPPORT_WHITESPACE


        ///////////////////////////////////////////////////////////////////////////
        // Functions to save UI settings into values

        private string SaveDirectionUI() {
            string strDirection;

            if (directionCombo.IsSet()) {
                int nIndex = directionCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < DIRECTION_VALUES.Length),
                             "Invalid index for direction");
                strDirection = DIRECTION_VALUES[nIndex];
            }
            else
                strDirection = "";

            return strDirection;
        }

        private string SaveHAlignUI() {
            string strHAlign;

            if (horzAlignCombo.IsSet()) {
                int nIndex = horzAlignCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < HALIGN_VALUES.Length),
                             "Invalid index for horizontal alignment");
                strHAlign = HALIGN_VALUES[nIndex];
            }
            else
                strHAlign = "";

            return strHAlign;
        }

        private string SaveIndentationUI() {
            string strIndent = indentationUnit.Value;

            if (strIndent == null)
                strIndent = "";
            return strIndent;
        }

        private string SaveJustificationUI() {
            string strJustification;

            if (justificationCombo.IsSet()) {
                int nIndex = justificationCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < JUSTIFY_VALUES.Length),
                             "Invalid index for justification");
                strJustification = JUSTIFY_VALUES[nIndex];
            }
            else
                strJustification = "";

            return strJustification;
        }

        private string SaveSpacingUI(UnsettableComboBox cbxSpacing, UnitControl unitSpacing) {
            string strSpacing = null;

            if (cbxSpacing.IsSet()) {
                int nIndex = cbxSpacing.SelectedIndex;

                if (nIndex == IDX_SPC_NORMAL)
                    strSpacing = SPACE_NORMAL_VALUE;
                else
                    strSpacing = unitSpacing.Value;
            }
            if (strSpacing == null)
                strSpacing = "";

            return strSpacing;
        }

        private string SaveVAlignUI() {
            string strVAlign;

            if (vertAlignCombo.IsSet()) {
                int nIndex = vertAlignCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < VALIGN_VALUES.Length),
                             "Invalid index for vertical alignment");
                strVAlign = VALIGN_VALUES[nIndex];
            }
            else
                strVAlign = "";

            return strVAlign;
        }

    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.SaveWhitespaceUI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string SaveWhitespaceUI() {
            string strWhitespace;

            if (whitespaceCombo.IsSet()) {
                int nIndex = whitespaceCombo.SelectedIndex;

                Debug.Assert((nIndex >= 1) && (nIndex < WHITESPACE_VALUES.Length),
                             "Invalid index for whitespace");
                strWhitespace = WHITESPACE_VALUES[nIndex];
            }
            else
                strWhitespace = "";

            return strWhitespace;
        }
    #endif // SUPPPORT_WHITESPACE


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        private void OnSelChangedHAlign(object source, EventArgs e) {
            if (IsInitMode())
                return;
            horzAlignAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(true, false, false, false);
            UpdateHAlignPreview();
        }

        private void OnSelChangedJustification(object source, EventArgs e) {
            if (IsInitMode())
                return;
            justificationAttribute.Dirty = true;
            SetDirty();
            UpdateJustificationPreview();
        }

        private void OnSelChangedVAlign(object source, EventArgs e) {
            if (IsInitMode())
                return;
            verticalAlignAttribute.Dirty = true;
            SetDirty();
            UpdateVAlignPreview();
        }

        private void OnSelChangedSpcLetters(object source, EventArgs e) {
            if (IsInitMode())
                return;
            letterSpacingAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, true, false, false);
            UpdateSpcLettersPreview();
        }

        private void OnChangedSpcLettersValue(object source, EventArgs e) {
            if (IsInitMode())
                return;
            letterSpacingAttribute.Dirty = true;
            SetDirty();
            if (e != null)
                UpdateSpcLettersPreview();
        }

    #if SUPPORT_WORDSPACING
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.OnSelChangedSpcWords"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnSelChangedSpcWords(object source, EventArgs e) {
            if (IsInitMode())
                return;
            wordSpacingAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, false, true, false);
            UpdateSpcWordsPreview();
        }

        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.OnChangedSpcWordsValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnChangedSpcWordsValue(object source, EventArgs e) {
            if (IsInitMode())
                return;
            wordSpacingAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, false, true, false);
            if (e != null)
                UpdateSpcWordsPreview();
        }
    #endif // SUPPORT_WORDSPACING

        private void OnSelChangedSpcLines(object source, EventArgs e) {
            if (IsInitMode())
                return;
            lineSpacingAttribute.Dirty = true;
            SetDirty();
            SetEnabledState(false, false, false, true);
            UpdateSpcLinesPreview();
        }

        private void OnChangedSpcLinesValue(object source, EventArgs e) {
            if (IsInitMode())
                return;
            lineSpacingAttribute.Dirty = true;
            SetDirty();
            if (e != null)
                UpdateSpcLinesPreview();
        }

        private void OnChangedIndentation(object source, EventArgs e) {
            if (IsInitMode())
                return;
            indentationAttribute.Dirty = true;
            SetDirty();
            if (e != null)
                UpdateIndentationPreview();
        }

        private void OnSelChangedDirection(object source, EventArgs e) {
            if (IsInitMode())
                return;
            directionAttribute.Dirty = true;
            SetDirty();
            UpdateDirectionPreview();
        }

    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.OnSelChangedWhitespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnSelChangedWhitespace(object source, EventArgs e) {
            if (IsInitMode())
                return;
            whitespaceAttribute.SetDirty(true);
            SetDirty();
            UpdateWhitespacePreview();
        }
    #endif // SUPPORT_WHITESPACE

        ///////////////////////////////////////////////////////////////////////////
        // Functions to save attributes

        private void SaveDirection() {
            string value = SaveDirectionUI();
            Debug.Assert(value != null,
                         "saveDirectionUI returned null!");

            directionAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveHAlign() {
            string value = SaveHAlignUI();
            Debug.Assert(value != null,
                         "saveHAlignUI returned null!");

            horzAlignAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveIndentation() {
            string value = SaveIndentationUI();
            Debug.Assert(value != null,
                         "saveIndentationUI returned null!");

            indentationAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveJustification() {
            string value = SaveJustificationUI();
            Debug.Assert(value != null,
                         "saveJustificationUI returned null!");

            justificationAttribute.SaveAttribute(GetSelectedStyles(), value);
        }

        private void SaveSpacing(CSSAttribute aiSpacing, UnsettableComboBox cbxSpacing, UnitControl unitSpacing) {
            string value = SaveSpacingUI(cbxSpacing, unitSpacing);
            Debug.Assert(value != null,
                         "saveSpacingUI returned null!");

            aiSpacing.SaveAttribute(GetSelectedStyles(), value);
        }

    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.SaveWhitespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SaveWhitespace() {
            string value = SaveWhitespaceUI();
            Debug.Assert(value != null,
                         "saveWhitespaceUI returned null!");

            whitespaceAttribute.SaveAttribute(GetSelectedStyles(), value);
        }
    #endif // SUPPORT_WHITESPACE

        private void SaveVAlign() {
            string value = SaveVAlignUI();
            Debug.Assert(value != null,
                         "saveVAlignUI returned null!");

            verticalAlignAttribute.SaveAttribute(GetSelectedStyles(), value);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Functions to update the preview

        private void UpdateDirectionPreview() {
            if (previewBlockStyle2 == null)
                return;

            string value = SaveDirectionUI();
            Debug.Assert(value != null,
                         "saveDirectionUI returned null!");

            try {
                previewBlockStyle2.SetDirection(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateDirectionPreview\n\t" + e.ToString());
            }
        }

        private void UpdateHAlignPreview() {
            if (previewBlockStyle1 == null)
                return;

            string value = SaveHAlignUI();
            Debug.Assert(value != null,
                         "saveHAlign returned null!");

            try {
                previewBlockStyle1.SetTextAlign(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateHAlignPreview\n\t" + e.ToString());
            }
        }

        private void UpdateIndentationPreview() {
            if (previewBlockStyle1 == null)
                return;

            string value = SaveIndentationUI();
            Debug.Assert(value != null,
                         "saveHAlign returned null!");

            try {
                previewBlockStyle1.SetTextIndent(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateIndentationPreview\n\t" + e.ToString());
            }
        }

        private void UpdateJustificationPreview() {
            if (previewBlockStyle2 == null)
                return;

            string value = SaveJustificationUI();
            Debug.Assert(value != null,
                         "saveJustificationUI returned null!");

            try {
                previewBlockStyle2.SetTextJustify(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateJustificationPreview\n\t" + e.ToString());
            }
        }

        private void UpdateSpcLettersPreview() {
            if (previewFlowStyle == null)
                return;

            string value = SaveSpacingUI(letterSpacingCombo, letterSpacingUnit);
            Debug.Assert(value != null,
                         "saveSpacing returned null!");

            try {
                previewFlowStyle.SetLetterSpacing(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateSpcLettersPreview\n\t" + e.ToString());
            }
        }

        private void UpdateSpcLinesPreview() {
            if (previewFlowStyle == null)
                return;

            string value = SaveSpacingUI(lineSpacingCombo, lineSpacingUnit);
            Debug.Assert(value != null,
                         "saveSpacing returned null!");

            try {
                previewFlowStyle.SetLineHeight(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateSpcLinesPreview\n\t" + e.ToString());
            }
        }

    #if SUPPORT_WORDSPACING
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.UpdateSpcWordsPreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void UpdateSpcWordsPreview() {
            if (previewFlowStyle == null)
                return;

            string value = SaveSpacingUI(wordSpacingCombo, wordSpacingUnit);
            Debug.Assert(value != null,
                         "saveSpacing returned null!");

            try {
                previewFlowStyle.SetWordSpacing(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateSpLWordsPreview\n\t" + e.ToString());
            }
        }
    #endif // SUPPORT_WORDSPACING

        private void UpdateVAlignPreview() {
            if (previewFlowStyle == null)
                return;

            string value = SaveVAlignUI();
            Debug.Assert(value != null,
                         "saveVAlignUI returned null!");

            try {
                previewFlowStyle.SetVerticalAlign(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateVAlignPreview\n\t" + e.ToString());
            }
        }

    #if SUPPORT_WHITESPACE
        /// <include file='doc\TextStylePage.uex' path='docs/doc[@for="TextStylePage.UpdateWhitespacePreview"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void UpdateWhitespacePreview() {
            if (previewFlowStyle == null)
                return;

            string value = SaveWhitespaceUI();
            Debug.Assert(value != null,
                         "saveWhitespaceUI returned null!");

            try {
                previewFlowStyle.SetWhiteSpace(value);
            }
            catch (Exception e) {
                Debug.WriteLineIf(StyleBuilder.StyleBuilderSwitch.TraceVerbose, "Exception in StyleTextPage::updateWhitespacePreview\n\t" + e.ToString());
            }
        }
    #endif // SUPPORT_WHITESPACE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\axtowfc\commandline.cs ===
///////////////////////////////////////////////////////////////////////////////
// Common Language Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
// Copyright (c) 2000, Microsoft Corp.  All rights reserved.
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace System.Tools {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foozle, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_AmbigousOption, strOpt));

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_UnknownOption, strOpt));
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_NoValueRequired, strOpt));

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_ValueRequired, strOpt));
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_ValueRequired, strOpt));
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException(AxImpSR.GetString(AxImpSR.Err_ValueRequired, strOpt));

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\changeiid\changeiid.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChangeIID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.ChangeIID {
    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Globalization;
    
    /// <include file='doc\ChangeIID.uex' path='docs/doc[@for="ChangeIID"]/*' />
    /// <devdoc>
    ///     This program is used to update a series if interface GUIDS
    ///     It searches an entire directory structure looking for
    ///     matching guids.
    /// </devdoc>
    public class ChangeIID {
        private static Mode mode;
        private static string interfaceFile;
        private static string fileSpec;

        private const string usage = 
            "\r\n" + 
            "Usage:\r\n" + 
            "    ChangeIID -i <interface file> -f <filespec> -l | -c\r\n" + 
            "    \r\n" + 
            "    -i <interface file>     The input file that contains the interface\r\n" + 
            "                            remappings.  Interfaces should be in the \r\n" + 
            "                            format of GuidNew, GuidOld<newline>.\r\n" + 
            "                            \r\n" + 
            "    -f <filespec>           The wildcard and directory specification of\r\n" + 
            "                            the files to scan, such as \"c:\\foo\\*.cs\".\r\n" + 
            "                        \r\n" + 
            "    -l | -c                 You must include one (but not both) of these.\r\n" + 
            "                            -l indicates that you only want to list the\r\n" + 
            "                            files that contain the old guids to change,\r\n" + 
            "                            and -c indicates that you want to make the\r\n" + 
            "                            actual changes to the files.\r\n" + 
            "\r\n";
        
        private static void ChangeFile(File file, Hashtable guidTable, Mode mode) {
            Stream stream = file.OpenRead();
            
            TextReader reader = new StreamReader(stream);
            string contents = reader.ReadToEnd();
            reader.Close();
            stream.Close();
            
            string upperContents = contents.ToUpper(CultureInfo.InvariantCulture);
            StringBuilder newContents = null;
            
            foreach(DictionaryEntry entry in guidTable) {
                string newGuid = (string)entry.Key;
                string oldGuid = (string)entry.Value;
                
                int index = upperContents.IndexOf(oldGuid);
                if (index != -1) {
                    Console.WriteLine(file.FullName);
                    
                    if (mode == Mode.ChangeFiles) {
                    
                        if (newContents == null) {
                            newContents = new StringBuilder(contents);
                        }
                        
                        int guidLen = newGuid.Length;
                        
                        do {
                            newContents.Remove(index, guidLen);
                            newContents.Insert(index, newGuid);
                        }
                        while((index = upperContents.IndexOf(oldGuid, index + 1)) != -1);
                    }
                }
            }
            
            if (newContents != null) {
                stream = file.Open(FileMode.Open, FileAccess.ReadWrite);
                TextWriter writer = new StreamWriter(stream);
                writer.Write(newContents.ToString());
                writer.Close();
                stream.Close();
            }
        }

        private static Hashtable CreateGuidTable(string interfaceFile) {
            Hashtable guidTable = new Hashtable();
            
            try {
                Stream stream = File.OpenRead(interfaceFile);
                TextReader reader = new StreamReader(stream);
                char[] tokens = new char[] {','};
                
                string line;
            
                while((line = reader.ReadLine()) != null) {
                    if (line.Length > 0 && !line.StartsWith("//")) {
                        string[] guids = line.Split(tokens);
                        if (guids.Length == 2) {
                            guids[0] = guids[0].Trim();
                            guids[1] = guids[1].Trim();
                            if (guids[0].Length == 36 && guids[1].Length == 36) {
                                guidTable[Guids[0].ToUpper(CultureInfo.InvariantCulture)] = guids[1].ToUpper(CultureInfo.InvariantCulture);
                            }
                        }
                    }
                }
            
                stream.Close();
            }
            catch(Exception e) {
                Console.Error.WriteLine("Error parsing interface file: " + e.ToString());
                Environment.Exit(1);
            }
            
            return guidTable;
        }

        /// <include file='doc\ChangeIID.uex' path='docs/doc[@for="ChangeIID.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(string[] args) {
            mode = Mode.Undefined;
            
            // Parse command line
            for (int i = 0; i < args.Length; i++) {
                string arg = args[i];
                if (arg.Length > 0 && arg[0] == '-' || arg[0] == '/') {
                    string argFlag = arg.Substring(1).ToLower(CultureInfo.InvariantCulture);
                    if (argFlag.Equals("i")) {
                        if (args.Length > i+1 && interfaceFile == null) {
                            i++;
                            interfaceFile = args[i];
                        }
                        else {
                            UsageError();
                        }
                    }
                    else if (argFlag.Equals("f")) {
                        if (args.Length > i+1 && fileSpec == null) {
                            i++;
                            fileSpec = args[i];
                        }
                        else {
                            UsageError();
                        }
                    }
                    else if (argFlag.Equals("l") && mode == Mode.Undefined) {
                        mode = Mode.ListFiles;
                    }
                    else if (argFlag.Equals("c") && mode == Mode.Undefined) {
                        mode = Mode.ChangeFiles;
                    }
                    else {
                        UsageError();
                    }
                }
            }
            
            // Validate that we got all the required arguments
            if (interfaceFile == null || fileSpec == null || mode == Mode.Undefined) {
                UsageError();
            }
            
            // Now process some files. First, build up a big table of the new guids.
            Hashtable guidTable = CreateGuidTable(interfaceFile);
            
            string directoryPart = Path.GetDirectoryName(fileSpec);
            string filePart = Path.GetFileName(fileSpec);
            RecurseChangeFiles(directoryPart, filePart, guidTable, mode);
        }
        
        private static void RecurseChangeFiles(string directory, string search, Hashtable guidTable, Mode mode) {
            FileInfo[] files = Directory.GetFilesInDirectory(directory, search);
            
            foreach(File f in files) {
                ChangeFile(f, guidTable, mode);
            }
            
            // Now recurse child directories.
            //
            Directory[] directories = Directory.GetDirectoriesInDirectory(directory);
            foreach(Directory d in directories) {
                RecurseChangeFiles(d.FullName, search, guidTable, mode);
            }
        }
        
        private static void UsageError() {
            Console.Error.WriteLine(usage);
            Environment.Exit(1);
        }
    
        private enum Mode {
            // Just listing files that need to be changed (SD compliant list)
            ListFiles = 0,
            
            // Actually making the changes and saving the files.
            ChangeFiles = 1,
            
            Undefined = 2
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\designer\microsoft\visualstudio\winforms\inheritancepicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritancePicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Windows.Forms {

    using EnvDTE;
    using Microsoft.VisualStudio.Designer;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Shell;
    using Microsoft.VisualStudio.Designer.Shell;
    using System;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Drawing.Drawing2D;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Text;
    using VSLangProj;


    /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Guid("7494683A-37A0-11d2-A273-00C04F8EF4FF"), CLSCompliantAttribute(false)]
    public class InheritancePicker : Form, IDTWizard {
        //controls for the dialog
        private Button btnCancel;
        private Button btnOK;
        private Button btnBrowse;
        private Button btnHelp;
        private Label lblMain;
        private Label lblName; 
        private Label lblNoAssemblies;
        private ListView lvComponents;
        private ColumnHeader columnHeader3;
        private ColumnHeader columnHeader2;
        private ColumnHeader columnHeader1;
        private OpenFileDialog openFileDialog1;

        //member variable representing parts of the DTE
        private _DTE            dte                 = null;     //the extensibility project
        private ProjectItems    projectItems        = null;     //DTE's project items (passed in by the wizard)
        private Project         activeProject       = null;     //This is the active project we will be adding to
        private bool            isForm              = false;    //Indicates if we are inheriting from form or usercontrol
        private String          validExtension      = ".dll";   //This is the only valid extension in which we can inherit from
        private Project         scanningProject     = null;     // The project we are currently scanning
        private Hashtable       projectMap          = null;     // A map of file names to projects.
        private Hashtable       projectAssemblies   = null;     // assembly name to assembly mapping for our assembly resolver.

        private String          targetLocation;//The location of the current project - where we need to create our inherited form/control
        private String          templateName;//The name of the template that we will parse & replace
        private String          localNamespace;//This is the namespace of the current project - we'll use this with the template
        private String          newComponentName;//The name of the new inherited component, ex: "myInheritedForm2.vb"
        private String          newFileName;//The file name of the new inherited component, ex: "myInheritedForm2.vb"
        private const String    vsViewKindDesigner = "{7651A702-06E5-11D1-8EBD-00A0C90F26EA}";//represents the designer view for opening the file
        private const String    helpTopic = "VS.InheritancePickerDialogBox"; //the VS help topic we will show when help is invoked
        private Guid            typeVB = new Guid("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}");//used to determine if the current project is using VB
        private Guid            typeFile = new   Guid("{6BB5F8EE-4483-11D3-8BCF-00C04F8EC28C}");//used to determine if a projectItem is a file

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.InheritancePicker"]/*' />
        /// <devdoc>
        ///      Constructor for our inheritance picker.  This simply calls initialize.
        /// </devdoc>
        public InheritancePicker() {
            InitializeComponent();
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.InheritancePicker2"]/*' />
        /// <devdoc>
        ///      This private constructor for the inheritance picker will attempt to get VS'd default font.
        /// </devdoc>
        private InheritancePicker(_DTE dte) {

            InitializeComponent();

            try {
                string fontFamily = (string)(dte.get_Properties("FontsAndColors", "Dialogs and Tool Windows").Item("FontFamily").Value);
                int    fontSize   = (int)((Int16)dte.get_Properties("FontsAndColors", "Dialogs and Tool Windows").Item("FontSize").Value);

                this.Font = new Font(fontFamily, fontSize);
            }
            catch {
                //no penalty here - we just failed to get VS's default font
            }
        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.InitializeComponent"]/*' />
        /// <devdoc>
        ///      Initialization of our ui
        /// </devdoc>
        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(InheritancePicker));

            this.lvComponents = new System.Windows.Forms.ListView();
            this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
            this.btnCancel = new System.Windows.Forms.Button();
            this.lblNoAssemblies = new System.Windows.Forms.Label();
            this.btnBrowse = new System.Windows.Forms.Button();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.btnHelp = new System.Windows.Forms.Button();
            this.lblMain = new System.Windows.Forms.Label();
            this.btnOK = new System.Windows.Forms.Button();
            this.lblName = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // lvComponents
            // 
            this.lvComponents.AccessibleDescription = ((string)(resources.GetObject("lvComponents.AccessibleDescription")));
            this.lvComponents.AccessibleName = ((string)(resources.GetObject("lvComponents.AccessibleName")));
            this.lvComponents.Alignment = ((System.Windows.Forms.ListViewAlignment)(resources.GetObject("lvComponents.Alignment")));
            this.lvComponents.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lvComponents.Anchor")));
            this.lvComponents.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("lvComponents.BackgroundImage")));
            this.lvComponents.Columns.AddRange(new System.Windows.Forms.ColumnHeader[]{this.columnHeader1,
                                               this.columnHeader2,
                                               this.columnHeader3});
            this.lvComponents.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("lvComponents.Cursor")));
            this.lvComponents.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("lvComponents.Dock")));
            this.lvComponents.Enabled = ((bool)(resources.GetObject("lvComponents.Enabled")));
            this.lvComponents.Font = ((System.Drawing.Font)(resources.GetObject("lvComponents.Font")));
            this.lvComponents.FullRowSelect = true;
            this.lvComponents.HideSelection = false;
            this.lvComponents.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("lvComponents.ImeMode")));
            this.lvComponents.LabelWrap = ((bool)(resources.GetObject("lvComponents.LabelWrap")));
            this.lvComponents.Location = ((System.Drawing.Point)(resources.GetObject("lvComponents.Location")));
            this.lvComponents.MultiSelect = false;
            this.lvComponents.Name = "lvComponents";
            this.lvComponents.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("lvComponents.RightToLeft")));
            this.lvComponents.Size = ((System.Drawing.Size)(resources.GetObject("lvComponents.Size")));
            this.lvComponents.TabIndex = ((int)(resources.GetObject("lvComponents.TabIndex")));
            this.lvComponents.Text = resources.GetString("lvComponents.Text");
            this.lvComponents.View = System.Windows.Forms.View.Details;
            this.lvComponents.Visible = ((bool)(resources.GetObject("lvComponents.Visible")));
            this.lvComponents.DoubleClick += new System.EventHandler(this.lvComponents_DoubleClick);
            this.lvComponents.SelectedIndexChanged += new System.EventHandler(this.lvComponents_SelChange);
            // 
            // columnHeader1
            // 
            this.columnHeader1.Text = resources.GetString("columnHeader1.Text");
            this.columnHeader1.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("columnHeader1.TextAlign")));
            this.columnHeader1.Width = ((int)(resources.GetObject("columnHeader1.Width")));
            // 
            // columnHeader2
            // 
            this.columnHeader2.Text = resources.GetString("columnHeader2.Text");
            this.columnHeader2.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("columnHeader2.TextAlign")));
            this.columnHeader2.Width = ((int)(resources.GetObject("columnHeader2.Width")));
            // 
            // columnHeader3
            // 
            this.columnHeader3.Text = resources.GetString("columnHeader3.Text");
            this.columnHeader3.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("columnHeader3.TextAlign")));
            this.columnHeader3.Width = ((int)(resources.GetObject("columnHeader3.Width")));
            // 
            // btnCancel
            // 
            this.btnCancel.AccessibleDescription = ((string)(resources.GetObject("btnCancel.AccessibleDescription")));
            this.btnCancel.AccessibleName = ((string)(resources.GetObject("btnCancel.AccessibleName")));
            this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnCancel.Anchor")));
            this.btnCancel.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnCancel.BackgroundImage")));
            this.btnCancel.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("btnCancel.Cursor")));
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("btnCancel.Dock")));
            this.btnCancel.Enabled = ((bool)(resources.GetObject("btnCancel.Enabled")));
            this.btnCancel.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("btnCancel.FlatStyle")));
            this.btnCancel.Font = ((System.Drawing.Font)(resources.GetObject("btnCancel.Font")));
            this.btnCancel.Image = ((System.Drawing.Image)(resources.GetObject("btnCancel.Image")));
            this.btnCancel.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnCancel.ImageAlign")));
            this.btnCancel.ImageIndex = ((int)(resources.GetObject("btnCancel.ImageIndex")));
            this.btnCancel.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("btnCancel.ImeMode")));
            this.btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("btnCancel.Location")));
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("btnCancel.RightToLeft")));
            this.btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("btnCancel.Size")));
            this.btnCancel.TabIndex = ((int)(resources.GetObject("btnCancel.TabIndex")));
            this.btnCancel.Text = resources.GetString("btnCancel.Text");
            this.btnCancel.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnCancel.TextAlign")));
            this.btnCancel.Visible = ((bool)(resources.GetObject("btnCancel.Visible")));
            // 
            // lblNoAssemblies
            // 
            this.lblNoAssemblies.AccessibleDescription = ((string)(resources.GetObject("lblNoAssemblies.AccessibleDescription")));
            this.lblNoAssemblies.AccessibleName = ((string)(resources.GetObject("lblNoAssemblies.AccessibleName")));
            this.lblNoAssemblies.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblNoAssemblies.Anchor")));
            this.lblNoAssemblies.AutoSize = ((bool)(resources.GetObject("lblNoAssemblies.AutoSize")));
            this.lblNoAssemblies.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("lblNoAssemblies.Cursor")));
            this.lblNoAssemblies.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("lblNoAssemblies.Dock")));
            this.lblNoAssemblies.Enabled = ((bool)(resources.GetObject("lblNoAssemblies.Enabled")));
            this.lblNoAssemblies.FlatStyle = System.Windows.Forms.FlatStyle.System;
            this.lblNoAssemblies.Font = ((System.Drawing.Font)(resources.GetObject("lblNoAssemblies.Font")));
            this.lblNoAssemblies.Image = ((System.Drawing.Image)(resources.GetObject("lblNoAssemblies.Image")));
            this.lblNoAssemblies.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblNoAssemblies.ImageAlign")));
            this.lblNoAssemblies.ImageIndex = ((int)(resources.GetObject("lblNoAssemblies.ImageIndex")));
            this.lblNoAssemblies.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("lblNoAssemblies.ImeMode")));
            this.lblNoAssemblies.Location = ((System.Drawing.Point)(resources.GetObject("lblNoAssemblies.Location")));
            this.lblNoAssemblies.Name = "lblNoAssemblies";
            this.lblNoAssemblies.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("lblNoAssemblies.RightToLeft")));
            this.lblNoAssemblies.Size = ((System.Drawing.Size)(resources.GetObject("lblNoAssemblies.Size")));
            this.lblNoAssemblies.TabIndex = ((int)(resources.GetObject("lblNoAssemblies.TabIndex")));
            this.lblNoAssemblies.Text = resources.GetString("lblNoAssemblies.Text");
            this.lblNoAssemblies.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblNoAssemblies.TextAlign")));
            this.lblNoAssemblies.Visible = ((bool)(resources.GetObject("lblNoAssemblies.Visible")));
            // 
            // btnBrowse
            // 
            this.btnBrowse.AccessibleDescription = ((string)(resources.GetObject("btnBrowse.AccessibleDescription")));
            this.btnBrowse.AccessibleName = ((string)(resources.GetObject("btnBrowse.AccessibleName")));
            this.btnBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnBrowse.Anchor")));
            this.btnBrowse.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnBrowse.BackgroundImage")));
            this.btnBrowse.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("btnBrowse.Cursor")));
            this.btnBrowse.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("btnBrowse.Dock")));
            this.btnBrowse.Enabled = ((bool)(resources.GetObject("btnBrowse.Enabled")));
            this.btnBrowse.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("btnBrowse.FlatStyle")));
            this.btnBrowse.Font = ((System.Drawing.Font)(resources.GetObject("btnBrowse.Font")));
            this.btnBrowse.Image = ((System.Drawing.Image)(resources.GetObject("btnBrowse.Image")));
            this.btnBrowse.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnBrowse.ImageAlign")));
            this.btnBrowse.ImageIndex = ((int)(resources.GetObject("btnBrowse.ImageIndex")));
            this.btnBrowse.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("btnBrowse.ImeMode")));
            this.btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("btnBrowse.Location")));
            this.btnBrowse.Name = "btnBrowse";
            this.btnBrowse.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("btnBrowse.RightToLeft")));
            this.btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("btnBrowse.Size")));
            this.btnBrowse.TabIndex = ((int)(resources.GetObject("btnBrowse.TabIndex")));
            this.btnBrowse.Text = resources.GetString("btnBrowse.Text");
            this.btnBrowse.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnBrowse.TextAlign")));
            this.btnBrowse.Visible = ((bool)(resources.GetObject("btnBrowse.Visible")));
            this.btnBrowse.Click += new System.EventHandler(this.btnBrowse_Click);
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.Filter = resources.GetString("openFileDialog1.Filter");
            this.openFileDialog1.Title = resources.GetString("openFileDialog1.Title");
            // 
            // btnHelp
            // 
            this.btnHelp.AccessibleDescription = ((string)(resources.GetObject("btnHelp.AccessibleDescription")));
            this.btnHelp.AccessibleName = ((string)(resources.GetObject("btnHelp.AccessibleName")));
            this.btnHelp.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnHelp.Anchor")));
            this.btnHelp.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnHelp.BackgroundImage")));
            this.btnHelp.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("btnHelp.Cursor")));
            this.btnHelp.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("btnHelp.Dock")));
            this.btnHelp.Enabled = ((bool)(resources.GetObject("btnHelp.Enabled")));
            this.btnHelp.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("btnHelp.FlatStyle")));
            this.btnHelp.Font = ((System.Drawing.Font)(resources.GetObject("btnHelp.Font")));
            this.btnHelp.Image = ((System.Drawing.Image)(resources.GetObject("btnHelp.Image")));
            this.btnHelp.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnHelp.ImageAlign")));
            this.btnHelp.ImageIndex = ((int)(resources.GetObject("btnHelp.ImageIndex")));
            this.btnHelp.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("btnHelp.ImeMode")));
            this.btnHelp.Location = ((System.Drawing.Point)(resources.GetObject("btnHelp.Location")));
            this.btnHelp.Name = "btnHelp";
            this.btnHelp.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("btnHelp.RightToLeft")));
            this.btnHelp.Size = ((System.Drawing.Size)(resources.GetObject("btnHelp.Size")));
            this.btnHelp.TabIndex = ((int)(resources.GetObject("btnHelp.TabIndex")));
            this.btnHelp.Text = resources.GetString("btnHelp.Text");
            this.btnHelp.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnHelp.TextAlign")));
            this.btnHelp.Visible = ((bool)(resources.GetObject("btnHelp.Visible")));
            this.btnHelp.Click += new System.EventHandler(this.btnHelp_Click);
            // 
            // lblMain
            // 
            this.lblMain.AccessibleDescription = ((string)(resources.GetObject("lblMain.AccessibleDescription")));
            this.lblMain.AccessibleName = ((string)(resources.GetObject("lblMain.AccessibleName")));
            this.lblMain.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblMain.Anchor")));
            this.lblMain.AutoSize = ((bool)(resources.GetObject("lblMain.AutoSize")));
            this.lblMain.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("lblMain.Cursor")));
            this.lblMain.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("lblMain.Dock")));
            this.lblMain.Enabled = ((bool)(resources.GetObject("lblMain.Enabled")));
            this.lblMain.FlatStyle = System.Windows.Forms.FlatStyle.System;
            this.lblMain.Font = ((System.Drawing.Font)(resources.GetObject("lblMain.Font")));
            this.lblMain.Image = ((System.Drawing.Image)(resources.GetObject("lblMain.Image")));
            this.lblMain.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblMain.ImageAlign")));
            this.lblMain.ImageIndex = ((int)(resources.GetObject("lblMain.ImageIndex")));
            this.lblMain.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("lblMain.ImeMode")));
            this.lblMain.Location = ((System.Drawing.Point)(resources.GetObject("lblMain.Location")));
            this.lblMain.Name = "lblMain";
            this.lblMain.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("lblMain.RightToLeft")));
            this.lblMain.Size = ((System.Drawing.Size)(resources.GetObject("lblMain.Size")));
            this.lblMain.TabIndex = ((int)(resources.GetObject("lblMain.TabIndex")));
            this.lblMain.Text = resources.GetString("lblMain.Text");
            this.lblMain.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblMain.TextAlign")));
            this.lblMain.Visible = ((bool)(resources.GetObject("lblMain.Visible")));
            // 
            // btnOK
            // 
            this.btnOK.AccessibleDescription = ((string)(resources.GetObject("btnOK.AccessibleDescription")));
            this.btnOK.AccessibleName = ((string)(resources.GetObject("btnOK.AccessibleName")));
            this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnOK.Anchor")));
            this.btnOK.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("btnOK.BackgroundImage")));
            this.btnOK.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("btnOK.Cursor")));
            this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.btnOK.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("btnOK.Dock")));
            this.btnOK.Enabled = ((bool)(resources.GetObject("btnOK.Enabled")));
            this.btnOK.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("btnOK.FlatStyle")));
            this.btnOK.Font = ((System.Drawing.Font)(resources.GetObject("btnOK.Font")));
            this.btnOK.Image = ((System.Drawing.Image)(resources.GetObject("btnOK.Image")));
            this.btnOK.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnOK.ImageAlign")));
            this.btnOK.ImageIndex = ((int)(resources.GetObject("btnOK.ImageIndex")));
            this.btnOK.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("btnOK.ImeMode")));
            this.btnOK.Location = ((System.Drawing.Point)(resources.GetObject("btnOK.Location")));
            this.btnOK.Name = "btnOK";
            this.btnOK.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("btnOK.RightToLeft")));
            this.btnOK.Size = ((System.Drawing.Size)(resources.GetObject("btnOK.Size")));
            this.btnOK.TabIndex = ((int)(resources.GetObject("btnOK.TabIndex")));
            this.btnOK.Text = resources.GetString("btnOK.Text");
            this.btnOK.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnOK.TextAlign")));
            this.btnOK.Visible = ((bool)(resources.GetObject("btnOK.Visible")));
            // 
            // lblName
            // 
            this.lblName.AccessibleDescription = ((string)(resources.GetObject("lblName.AccessibleDescription")));
            this.lblName.AccessibleName = ((string)(resources.GetObject("lblName.AccessibleName")));
            this.lblName.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblName.Anchor")));
            this.lblName.AutoSize = ((bool)(resources.GetObject("lblName.AutoSize")));
            this.lblName.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.lblName.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("lblName.Cursor")));
            this.lblName.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("lblName.Dock")));
            this.lblName.Enabled = ((bool)(resources.GetObject("lblName.Enabled")));
            this.lblName.FlatStyle = System.Windows.Forms.FlatStyle.System;
            this.lblName.Font = ((System.Drawing.Font)(resources.GetObject("lblName.Font")));
            this.lblName.Image = ((System.Drawing.Image)(resources.GetObject("lblName.Image")));
            this.lblName.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblName.ImageAlign")));
            this.lblName.ImageIndex = ((int)(resources.GetObject("lblName.ImageIndex")));
            this.lblName.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("lblName.ImeMode")));
            this.lblName.Location = ((System.Drawing.Point)(resources.GetObject("lblName.Location")));
            this.lblName.Name = "lblName";
            this.lblName.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("lblName.RightToLeft")));
            this.lblName.Size = ((System.Drawing.Size)(resources.GetObject("lblName.Size")));
            this.lblName.TabIndex = ((int)(resources.GetObject("lblName.TabIndex")));
            this.lblName.Text = resources.GetString("lblName.Text");
            this.lblName.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("lblName.TextAlign")));
            this.lblName.Visible = ((bool)(resources.GetObject("lblName.Visible")));
            // 
            // InheritancePicker
            // 
            this.AcceptButton = this.btnOK;
            this.AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
            this.AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
            this.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("$this.Anchor")));
            this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
            this.AutoScroll = ((bool)(resources.GetObject("$this.AutoScroll")));
            this.AutoScrollMargin = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMargin")));
            this.AutoScrollMinSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMinSize")));
            this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
            this.CancelButton = this.btnCancel;
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.Controls.AddRange(new System.Windows.Forms.Control[]{this.btnCancel,
                                   this.btnOK,
                                   this.btnHelp,
                                   this.lblMain,
                                   this.lvComponents,
                                   this.btnBrowse,
                                   this.lblName,
                                   this.lblNoAssemblies});
            this.ControlBox = false;
            this.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("$this.Cursor")));
            this.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("$this.Dock")));
            this.Enabled = ((bool)(resources.GetObject("$this.Enabled")));
            this.Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
            this.HelpRequested += new HelpEventHandler(this.Inheritance_HelpRequested);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("$this.ImeMode")));
            this.Location = ((System.Drawing.Point)(resources.GetObject("$this.Location")));
            this.MaximizeBox = false;
            this.MaximumSize = ((System.Drawing.Size)(resources.GetObject("$this.MaximumSize")));
            this.MinimizeBox = false;
            this.MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
            this.Name = "InheritancePicker";
            this.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("$this.RightToLeft")));
            this.ShowInTaskbar = false;
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Show;
            this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            this.Text = resources.GetString("$this.Text");
            this.Visible = ((bool)(resources.GetObject("$this.Visible")));
            this.ResumeLayout(false);

        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.btnBrowse_Click"]/*' />
        /// <devdoc>
        ///      This event fires when the user wants to "hand-pick" an assembly
        ///     to inherit from, if the user selects one, we skip a bunch of our
        ///     logic and immediately parse the file
        /// </devdoc>
        private void btnBrowse_Click(object sender, EventArgs e) {
            //set the initial directory...
            openFileDialog1.InitialDirectory = targetLocation;

            //run the dialog 
            if (openFileDialog1.ShowDialog() == DialogResult.OK) {

                // Keep track of the # of previous built assemblies in our list view.
                // We do this so we can determine if we need to display our assembly error.
                int previousAssemblyCount = lvComponents.Items.Count;

                //Parse selected file
                ParseFiles(openFileDialog1.FileName);

                //if we didn't find any built assemblies to inherit from AND we never
                //had items in our listview in the first place, show our fancy error...
                if (previousAssemblyCount == 0 && lvComponents.Items.Count == 0) {
                    ShowBuiltAssembliesError(true);
                }
                else {
                    ShowBuiltAssembliesError(false);
                }
            }
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.btnHelp_Click"]/*' />
        /// <devdoc>
        ///      Calls the HelpRequested helper function to launch context sensitive help.
        // </devdoc>
        private void btnHelp_Click(object sender, EventArgs e) {
            HelpEventArgs empty = new HelpEventArgs(new Point(0,0));
            //call our helprequested helper method
            Inheritance_HelpRequested(sender, empty);
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.btnHelp_Click"]/*' />
        /// <devdoc>
        ///      Launches VS's help engine with our inheritance picker topic.
        // </devdoc>
        private void Inheritance_HelpRequested(object sender, HelpEventArgs e) {
            object helpObject = dte.GetObject("Help");
            if (helpObject is IVsHelp) {
                try {
                    ((IVsHelp)helpObject).DisplayTopicFromF1Keyword(helpTopic);
                }
                catch (Exception) {
                    // IVsHelp causes a ComException to be thrown if the help
                    // topic isn't found.
                }
            }
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.lvComponents_DoubleClick"]/*' />
        /// <devdoc>
        ///      This is just the user selecting an assembly, goto click from here
        /// </devdoc>
        private void lvComponents_DoubleClick(object sender, EventArgs e) {
            if (lvComponents.SelectedItems != null && 
                lvComponents.SelectedItems.Count > 0) {

                // Here, the user dbl clicked on a form to inherit from, so we will...
                // by setting the DialogResult to OK - this will invoke the OnClosing()
                //
                DialogResult = DialogResult.OK;
            }
        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.lvComponents_SelChange"]/*' />
        /// <devdoc>
        ///      Monitoring the selection change in our list box
        /// </devdoc>
        private void lvComponents_SelChange(object sender, EventArgs e) {
            //we will use sel change to monitor the listview's item selection
            if (lvComponents.SelectedItems.Count > 0) {
                btnOK.Enabled = true;
            }
            else btnOK.Enabled = false;
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.OkToFullyQualifyNamespace"]/*' />
        /// <devdoc>
        ///      This method will return true if we want to fully qualify the namespace that 
        ///      we are trying to inherit from. i.e. "NewForm inherits NameSpace.OldForm"
        ///      We will return false from here if we are dealing with VB, and we are in
        ///      the same project.
        /// </devdoc>
        private bool OkToFullyQualifyNamespace(string intendedNamespace, string fullPath) {

            //check to see if we are dealing with VB
            //
            try {
                if (!typeVB.Equals(new Guid(activeProject.Kind))) {
                    //not dealing with VB, ok to fully qualify
                    return true;
                }
            }
            //if we catch here, then we're most likely not a vb proj
            catch {
                return true;
            }

            //check to see that we are working within the same project
            //
            if (projectMap != null) {
                Project projectRef = (Project)projectMap[fullPath];
                if (projectRef != null) {
                    if (projectRef == activeProject) {
                        //projects are the same, so we shouldn't fully qualify.
                        return false;
                    }
                }
            }
            
            // Not the same project, so we always want to fully qualify.
            return true;
        }



        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.OnClosing"]/*' />
        /// <devdoc>
        ///      Here is where a lot of the magic happens.  We first extract
        ///     the selection from the list box, read our template into a buffer
        ///     swap the template key phrases for the info in the current selection
        ///     and finally add the project item.
        /// </devdoc>
        protected override void OnClosing(CancelEventArgs e ) {
            if (DialogResult == DialogResult.OK) {
                String baseName = lvComponents.SelectedItems[0].Text;
                baseName = baseName.Replace('+', '.');

                String fullPath = lvComponents.SelectedItems[0].SubItems[2].Text;
                String nameSpace = lvComponents.SelectedItems[0].SubItems[1].Text;
                Type type = (Type)lvComponents.SelectedItems[0].Tag;
                string fullName = baseName;

                //determine the class modifier
                String classModifier = ResolveClassModifier(type); 

                //build up the fully qualified namespace & class name to inherit from
                if (nameSpace.Length > 0) {
                    if (!OkToFullyQualifyNamespace(nameSpace, fullPath)) {
                        if (localNamespace.Length > 0 && nameSpace.StartsWith(localNamespace)) {
                            int index = nameSpace.IndexOf('.');
                            nameSpace = nameSpace.Substring(index+1);
                        }
                    }
                    fullName = nameSpace + "." + baseName;
                }

                //Here, we'll verify that while this picker was up, the assembly 
                //that we're trying to inherit from hasn't been deleted or renamed etc...
                if (!File.Exists(fullPath)) {
                    MessageBox.Show(SR.GetString(SR.IP_Error2a, fullPath), SR.GetString(SR.IP_Error2b));
                    e.Cancel = true;
                    return;
                }

                //Open template file and read into stream
                String templateLoc = GetTemplateLocation();
                if (templateLoc == null || templateLoc.Length == 0) {
                    MessageBox.Show(SR.GetString(SR.IP_Error1a), SR.GetString(SR.IP_Error1b));
                    e.Cancel = true;
                    return;
                }

                StreamReader sr = new StreamReader(templateLoc, Encoding.Default);
                StringBuilder template = new StringBuilder("");
                String line = "";

                while ((line = sr.ReadLine())!=null) {
                    template.Append(line+"\n");
                }
                sr.Close();

                //Replace all the generic "baseform" names with our target name and what not
                template.Replace("[!output NAMESPACE]", localNamespace, 0, template.Length);
                template.Replace("[!output SAFE_ITEM_NAME]", newComponentName, 0, template.Length);
                template.Replace("[!output BASE_FULL_NAME]", fullName, 0, template.Length);
                template.Replace("[!output CLASS_MODIFIER]", classModifier, 0, template.Length);

                //if appropriate, add reference to active project
                bool referenceOk = true;

                referenceOk = AddReferenceToActiveProject(fullPath, nameSpace, type.Assembly);

                //attempt to add the new file to the list of project items
                if (projectItems != null && referenceOk) {

                    // Is Encoding.Default sufficient to encode this template?
                    // To find out, we do a test encoding: we encode the template using
                    // Encoding.Default (into the defaultEncoding variable), and then
                    // we decode this result (into the decoded variable). We then compare
                    // this decoded string with the original template string. If they're the same,
                    // we're good - otherwise, we'll have to use Unicode encoding to ensure
                    // that the template is properly encoded.
                    //
                    Byte[] defaultEncoding = Encoding.Default.GetBytes(template.ToString());
                    string decoded = Encoding.Default.GetString(defaultEncoding);
                    
                    Encoding encoding = Encoding.Default;
                    
                    if (!decoded.Equals(template.ToString())) {
                        encoding = Encoding.Unicode;
                    }

                    //create new file
                    StreamWriter sw = new StreamWriter(Path.Combine(targetLocation, newFileName), false, encoding);
                    sw.Write(template.ToString());
                    sw.Close();

                    ProjectItem item = projectItems.AddFromFile(Path.Combine(targetLocation, newFileName));

                    //Sometime the designer gets in a state where it simply cannot open our inherited item
                    //even though it has been added to the project correctly.  When trying to open into the
                    //designer view, if some exception is thrown, we'll ignore it (it'll still be added to
                    //the project).
                    //
                    try {
                        String subType = "Form";
                        if (!isForm)
                            subType = "UserControl";

                        item.Properties.Item("SubType").Value = subType;
                        Window editor = item.Open(vsViewKindDesigner);
                        editor.Visible = true;
                    }
                    catch (Exception) {
                    }
                }
            }

            base.OnClosing(e);
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.AddAppropriateTypes"]/*' />
        /// <devdoc>
        ///      This method enumerates all of the types being passed into it.  If any of the type
        ///     meets the criteria for inheritance (!abstract or sealed), then we add
        ///     the name of the type along with the project and file location to our list view
        /// </devdoc>
        private void AddAppropriateTypes(Type[] types, String projectName, String fileName) {
            //loop through all the types
            for (int i = 0; i < types.Length; i ++) {
                String typeName = types[i].FullName;

                //verify valid type - the quick ones first...
                if (!(types[i].IsAbstract || types[i].IsSealed)) {

                    bool assignableFrom = false;

                    if (isForm) {
                        //check to see if a new form is assignable from the type(s) we have
                        assignableFrom = typeof(Form).IsAssignableFrom(types[i]);
                    }
                    else {
                        //check to see if a new user control is assignable from the type(s) we have
                        assignableFrom = typeof(UserControl).IsAssignableFrom(types[i]);
                    }

                    if (assignableFrom) {

                        if (types[i].IsNestedPublic) {
                            typeName = types[i].FullName;
                            int nsLen = types[i].Namespace.Length;
                            if (nsLen > 0)
                                typeName = typeName.Substring(nsLen + 1, typeName.Length - nsLen - 1);
                        }
                        else {
                            typeName = types[i].Name;
                        }

                        //Search to see if this already exists in our list, if not 
                        //add the type name (like Form1) and the project name (As a sub item) to the list view
                        //
                        for (int j = 0; j < lvComponents.Items.Count; j++) {
                            ListViewItem currentItem = lvComponents.Items[j];
                            if (currentItem.Text.Equals(typeName)) {
                                //we'll nest this next "if" for perf reasons, we'll hardly ever have to compare this...
                                if (currentItem.SubItems.Count > 1 && currentItem.SubItems[1].Text.Equals(types[i].Namespace)) {
                                    //dup of existing item already added (the user is probably browsing to the same .exe
                                    return;
                                }
                            }
                        }

                        ListViewItem newItem = new System.Windows.Forms.ListViewItem(new string[]{typeName, types[i].Namespace, fileName});
                        newItem.Tag = types[i];

                        lvComponents.Items.Add(newItem);

                        // If there is a project key setup, associate this filename with that project key.  This allows
                        // us to propertly create inter-project references.
                        if (scanningProject != null) {
                            if (projectMap == null) {
                                projectMap = new Hashtable();
                            }
                            projectMap[fileName] = scanningProject;
                        }
                    }
                }
            }
        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.AddReferenceToActiveProject"]/*' />
        /// <devdoc>
        ///      Here, we attempt to add a reference (of what we just inherited from)
        ///     to our currently active project.
        /// </devdoc>
        private bool AddReferenceToActiveProject(String fullPath, String nameSpace, Assembly assembly) {
            if (activeProject == null) {
                return false;
            }

            VSProject vsProject = activeProject as VSProject;
            if (vsProject == null) {
                vsProject = activeProject.Object as VSProject;
            }

            if (vsProject == null) {
                return false;
            }

            References refs = vsProject.References;
            if (refs == null) {
                return false;
            }

            // Seach for a mapping to a Project object.  If we can find one,
            // we add an inter-project reference
            try {
                Project projectRef = null;
                if (projectMap != null) {
                    projectRef = (Project)projectMap[fullPath];
                }
                if (projectRef != null) {
                    if (projectRef == activeProject) {
                        //no need to add a reference here
                        //it's in the same project
                        return true;
                    }
                    refs.AddProject(projectRef);
                }
                else {
                    refs.Add(fullPath);
                }

                // Now walk assembly dependencies
                AssemblyName[] dependencies = assembly.GetReferencedAssemblies();
                foreach(AssemblyName dependency in dependencies) {

                    string name = dependency.Name;

                    // Skip mscorlib; it's implicit.
                    if (name != null && string.Compare(name, "mscorlib", true, CultureInfo.InvariantCulture) == 0) {
                        continue;
                    }

                    bool added = false;
                    if (dependency.CodeBase != null && dependency.CodeBase.Length > 0) {
                        refs.Add(NativeMethods.GetLocalPath(dependency.CodeBase));
                        added = true;
                    }

                    if (!added && projectAssemblies != null) {
                        // now locate the key.  It has the real codebase (possibly)
                        foreach(AssemblyName an in projectAssemblies.Keys) {
                            if (an.FullName.Equals(dependency.FullName)) {
                                if (an.CodeBase != null && an.CodeBase.Length > 0) {
                                    refs.Add(NativeMethods.GetLocalPath(an.CodeBase));
                                    added = true;
                                }
                                break;
                            }
                        }
                    }

                    if (!added && name != null && name.Length > 0) {
                        refs.Add(name);
                        added = true;
                    }
                }
            }
            catch (Exception) {
                MessageBox.Show(SR.GetString(SR.IP_Error6a, nameSpace), SR.GetString(SR.IP_Error6b));
                return false;
            }

            return true;
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.EnumerateOutputGroups"]/*' />
        /// <devdoc>
        ///      Given a set of output groups from vs, we try to find the built assemblies
        ///     then pass them on to our parsefiles method
        /// </devdoc>
        private void EnumerateOutputGroups(OutputGroups outputs, bool loadAssemblies) {

            // Now walk each output group.  From each group we can get a list of filenames to add to the
            // assembly entries.
            //
            for (int i = 0; i < outputs.Count; i++) {
                OutputGroup output = outputs.Item(i + 1); // DTE is 1 based

                // We are only interested in built dlls and their satellites.
                //
                string groupName = output.CanonicalName;

                if (output.FileCount > 0 && (groupName.Equals("Built"))) {
                    Object obj = output.FileURLs;
                    object objNames = obj;
                    Array names = (Array)objNames;
                    int nameCount = names.Length;

                    for (int j = 0; j < nameCount; j++) {
                        string fileName = StripURL((string)names.GetValue(j));

                        if (!File.Exists(fileName)) {
                            //Couldn't find: "+fileName+"!"
                            continue;
                        }

                        // Config files show up in this list as well, so filter the noise.
                        //
                        if (fileName.ToLower(CultureInfo.InvariantCulture).EndsWith(".config")) {
                            continue;
                        }

                        if (loadAssemblies) {
                            //Parse the file, and look for any types we can inherit from
                            ParseFiles (fileName);
                        }
                        else {
                            // we're not loading assemblies; we're just scanning.  So add
                            // this assembly to our scan list.
                            //
                            try {
                                AssemblyName an = AssemblyName.GetAssemblyName(fileName);
                                if (projectAssemblies == null) {
                                    projectAssemblies = new Hashtable();
                                }
                                projectAssemblies[an] = null;
                            }
                            catch {
                                // just eat this
                            }
                        }
                    }
                }
            }

            if (lvComponents.Items.Count == 0) {
                ShowBuiltAssembliesError(true);
            }
            else {
                ShowBuiltAssembliesError(false);
            }

        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.EnumerateProjects"]/*' />
        /// <devdoc>
        ///      Here, we simply take our project and request the output groups,
        ///     so we can find our built assemblies
        /// </devdoc>
        private void EnumerateProjects(Projects projects, bool loadAssemblies) {

            //loop through projects
            for (int i = 0; i < projects.Count; i++) {

                Project project = projects.Item(i + 1); //DTE is 1 based

                //call on the configuration manager so that we can eventually extract the assemblies
                ConfigurationManager configMan = null;
                try {
                    configMan = project.ConfigurationManager;
                    if (configMan == null) {
                        //Could not get the Configuration Manager
                        continue;
                    }
                }
                catch {
                    continue;
                }

                Configuration config = configMan.ActiveConfiguration;
                if (config == null) {
                    //Could not resolve the active configuration
                    continue;
                }

                OutputGroups outputs = config.OutputGroups;
                if (outputs == null) {
                    //could not get OutputGroups
                    continue;
                }

                //Go through our output groups - and look at the assemblies
                scanningProject = project;
                try {
                    EnumerateOutputGroups(outputs, loadAssemblies);
                }
                finally {
                    scanningProject = null;
                }
            }
        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.Execute"]/*' />
        /// <devdoc>
        ///      This is called by the wizard interface (IDTWizard) to instantiate the wizard.
        /// </devdoc>
        public void Execute( Object dteObject, int hwndOwner, ref Object[] ContextParams,
                             ref Object[] CustomParams, ref wizardResult retval) {

            retval = wizardResult.wizardResultFailure;

            //validate arguments
            if (dteObject != null && hwndOwner != 0 && ContextParams != null &&
                CustomParams != null && (CustomParams.Length == 2)) {

                //extract info from arguments...
                _DTE dte                = null;
                bool isForm             = false;
                ProjectItems pi         = null;
                String targetName       = null;
                String targetLocation   = null;
                String templateName     = null;

                if (dteObject is _DTE) dte = (_DTE)dteObject;
                if (ContextParams[2] != null && ContextParams[2] is ProjectItems) pi = (ProjectItems)ContextParams[2];
                if (ContextParams[3] != null && ContextParams[3] is String) targetLocation = (String)ContextParams[3];
                if (ContextParams[4] != null && ContextParams[4] is String) targetName = (String)ContextParams[4];
                if (CustomParams[1] != null && CustomParams[1] is String) templateName = (String)CustomParams[1];
                if (CustomParams[0] != null && CustomParams[0] is String) {
                    if ( ((String)CustomParams[0]).Equals("Form")) isForm = true;
                }

                //if all our info is valid, we'll setup the DTE stuff, then show our dialog
                if (dte != null && pi != null && targetName != null && targetLocation != null && templateName != null) {
                    InheritancePicker picker = new InheritancePicker(dte);

                    // Configure the domain resolve event so we can resolve assemblies between projects
                    //
                    AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(picker.OnAssemblyResolve);

                    try {
                        //setup our DTE information - all the projects and built assemblies, 
                        //if we can do this with no naming conflict, launch the dialog.
                        //
                        if (picker.SetupDTEInfo(dte, pi, targetName, targetLocation, templateName, isForm)) {
                            if (picker.ShowDialog() == DialogResult.OK) {
                                retval = wizardResult.wizardResultSuccess;
                            }
                        }
                    }
                    finally {
                        AppDomain.CurrentDomain.AssemblyResolve -= new ResolveEventHandler(picker.OnAssemblyResolve);
                    }
                }
            }
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.Dispose"]/*' />
        /// <devdoc>
        ///      Standard dispose method.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                projectMap = null;
            }
            base.Dispose(disposing);
        }


        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.GetTemplateLocation"]/*' />
        /// <devdoc>
        ///      Request the DesignerTemplateDir key from the registry so we can locate the templates.
        /// </devdoc>
        private String GetTemplateLocation() {

            if (projectItems == null)
                return String.Empty;

            String clsId = projectItems.ContainingProject.Kind;
            RegistryKey key = Registry.LocalMachine.OpenSubKey(VsRegistry.GetDefaultBase() + "\\Projects\\" + clsId);

            if (key == null)
                return String.Empty;

            String templateLocation = (String)key.GetValue("DesignerTemplatesDir");
            key.Close();

            if (templateLocation == null)
                return String.Empty;

            String fullPath = Path.Combine(Path.Combine(templateLocation, dte.LocaleID.ToString()), templateName);
            if (!File.Exists(fullPath)) {
                return String.Empty;
            }

            return fullPath;
        }

        /// <devdoc>
        ///     Called by the app domain to satisfy the request for an assembly the
        ///     domain couldn't otherwise locate.
        /// </devdoc>
        private Assembly OnAssemblyResolve(object sender, ResolveEventArgs e) {
            if (projectAssemblies != null) {
                AssemblyName matchingName = null;

                foreach(DictionaryEntry de in projectAssemblies) {
                    AssemblyName name = (AssemblyName)de.Key;
                    if (name.FullName.Equals(e.Name)) {
                        // This is our match.  If we already have
                        // an assembly, return it.  Otherwise,
                        // fall down and we will load it.
                        //
                        matchingName = name;
                        if (de.Value != null) {
                            return (Assembly)de.Value;
                        }
                        break;
                    }
                }

                if (matchingName != null) {
                    return ShellTypeLoader.CreateDynamicAssembly(NativeMethods.GetLocalPath(matchingName.CodeBase));
                }
            }

            return null;
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.ParseFiles"]/*' />
        /// <devdoc>
        ///      This method reads the file into a byte array.  From here, we can create
        ///     an assembly around the bytes, then query the assembly for it's modules.
        /// </devdoc>
        private void ParseFiles (String fileName) {
            
            // Read the file as an array of bytes and create an assembly out of it.
            //
            Assembly assembly = null;

            try {
                assembly = ShellTypeLoader.CreateDynamicAssembly(fileName);
            }
            catch (Exception) {
                //Just return here.  We could be trying to parse an unmanaged
                //assembly in the project system (like a setup project) - so
                //we can just ignore it.
                return;
            }

            //get the project name
            String projectName = assembly.GetName().ToString();

            //strip the "," and version info
            if (projectName.IndexOf(',') > 0) {
                projectName = projectName.Substring(0, projectName.IndexOf(','));
            }

            Type[] types = null;
            try {
                types = assembly.GetTypes();
            }
            catch (Exception) {
                // thow an "Assembly Load Error \n Unable to load assembly 'filename'" here...
                // NOTE: We should be using IUIService here, but VS does not allow us to get to
                //     : a service provider, so we use the ever-popular MessageBox.
                MessageBox.Show(SR.GetString(SR.IP_Error5a, fileName), SR.GetString(SR.IP_Error5b));
                return;
            }
            if (types == null) {
                //could not get the types from the module
                return;
            }

            //If the file we are about to parse is NOT in our current project, then verify that
            //it has a valid extension...
            //
            if (scanningProject != null && scanningProject != activeProject) {
                if (String.Compare(Path.GetExtension(fileName), validExtension, true, CultureInfo.InvariantCulture) != 0) {
                    return;
                }
            }


            //Add the appropriate types to the picker
            AddAppropriateTypes(types, projectName, fileName);
        }  

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.ResolveClassModifier"]/*' />
        /// <devdoc>
        ///      This method attempts to identify the class modifier of the type we're inheriting from.
        ///      From here, we can put "Friend", "Internal", etc... in our new form/usercontrol.
        /// </devdoc>
        private string ResolveClassModifier(Type type) {

            TypeAttributes attr = type.Attributes;

            //if we have a non-public attribute, then our class is either
            //a "friend" or "internal" depending on the language
            if ((attr & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic) {
                //if vb, return "friend"
                //
                if (typeVB.Equals(new Guid(activeProject.Kind))) {
                    return "Friend";
                }

                //must be an internal class
                return "internal";
            }

            //always default to public...

            //if vb - watch our casing
            if (typeVB.Equals(new Guid(activeProject.Kind))) {
                return "Public";
            }

            return "public";
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.SetupDTEInfo"]/*' />
        /// <devdoc>
        ///      This is our initialization of the shell's extensibility object.  We look at 
        ///      the projects and all built assemblies that we can inherit from, then add them 
        ///      to the dialog.  If there is a naming conflict, we return false, to signify that
        ///      we don't want to launch the dialog.
        /// </devdoc>
        private bool SetupDTEInfo(_DTE dte, ProjectItems projectItems, String targetName, String targetLoc,
                                  String templateName, bool isForm) {
            //assign our member variables            
            this.dte = dte;
            this.projectItems = projectItems;
            this.targetLocation = targetLoc;
            this.templateName = templateName;
            this.newFileName = Path.GetFileName(targetName);
            this.newComponentName = ValidateTargetName(newFileName);
            this.isForm = isForm;

            //append the component name to the label
            this.lblName.Text += newComponentName;


            string localProject = null;

            //get the active project, so we can get the localNamespace
            Object obj = dte.ActiveSolutionProjects;
            if (obj != null && obj is Array) {
                Object proj = ((Array)obj).GetValue(0);
                if (proj != null && proj is Project) {
                    activeProject = (Project)proj;
                    localProject = activeProject.Name;
                    localNamespace = (string)activeProject.Properties.Item("DefaultNamespace").Value;
                }
            }

            //lets look at the true location of the selected item,
            //we may be trying to create an inherited form/control
            //in a subfolder
            try {
                SelectedItems selItems = dte.SelectedItems;
                if (selItems != null && selItems.Count > 0) {
                    //look at item[1] - 'cause DTE is 1-based, not 0
                    SelectedItem item = selItems.Item(1);
                    if (item != null) {
                        ProjectItem pi = item.ProjectItem;
                        if (pi != null) {
                            //if the selected projectitem is a file, then 
                            //we'll ask its parent for the defaultnamespace
                            //
                            if (typeFile.Equals(new Guid(pi.Kind))) {
                                ProjectItems pis = pi.Collection;
                                if (pis != null) {
                                    object parent = pis.Parent;
                                    if (parent is ProjectItem) {
                                        localNamespace = (string)((ProjectItem)parent).Properties.Item("DefaultNamespace").Value;
                                        targetLocation = ((ProjectItem)parent).get_FileNames(0);
                                        localProject = ((ProjectItem)parent).Name;
                                    }
                                }
                            }
                            else{
                                localNamespace = (string)pi.Properties.Item("DefaultNamespace").Value;
                                targetLocation = pi.get_FileNames(0);
                                localProject = pi.Name;
                            }
    
                        }
                    }
                }
            }
            catch {
                //noop
            }
                          
            // get a pointer to all the projects in the solution.  We make
            // two passes here -- the first pass gathers all the project output
            // files so we can demand load them through the app domain assembly
            // resolve event. The second actually loads the assemblies and 
            // scans them.
            _Solution solution = dte.Solution;
            if (solution != null && solution.Projects != null) {
                EnumerateProjects(solution.Projects, false);
                EnumerateProjects(solution.Projects, true);
            }

            //loop through the class names in the project that the 
            //user wants to creat a new inherited component in.  If
            //we find a dup - we'll through the appropriate exception 
            //below.
            //
            bool duplicateNameFound = false;
            for (int i = 0; i < lvComponents.Items.Count; i ++) {
                //automatically select the first item
                if (i == 0) {
                    lvComponents.Items[0].Selected = true;
                }
                if (lvComponents.Items[i].Text.Equals(newComponentName) && lvComponents.Items[i].SubItems[1].Text.Equals(localProject)) {
                    duplicateNameFound = true;
                    break;
                }
            }

            if (duplicateNameFound || File.Exists(Path.Combine(targetLocation, newFileName))) {
                MessageBox.Show(SR.GetString(SR.IP_Error3a, newComponentName, localNamespace), SR.GetString(SR.IP_Error3b));
                btnCancel.PerformClick();
                return false;
            }

            return true;
        }

        /// <devdoc>
        ///      This method is called when the inheritance picker
        ///     cannot locate any build assemblies to inherit from.
        ///     We simply set most of our UI's visible = false, and
        ///     display our localized error message in it's place.
        ///     If the user browses to a built assembly, we pass in
        ///     false, which hides the error message (the label) and
        ///     displays the UI once again.
        /// </devdoc>
        private void ShowBuiltAssembliesError(bool visible) {
            lvComponents.Visible = !visible;
            lblMain.Visible = !visible;
            lblName.Enabled = !visible;
            lblNoAssemblies.Visible = visible;
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.StripURL"]/*' />
        /// <devdoc>
        ///      Strips the URL file syntax off of a filename.
        /// </devdoc>
        private string StripURL(string url) {
            string filePrefix = "file:///";
            string lowerUrl = url.ToLower(CultureInfo.InvariantCulture);
            if (lowerUrl.StartsWith(filePrefix)) {
                return url.Substring(filePrefix.Length);
            }
            return url;
        }

        /// <include file='doc\InheritancePicker.uex' path='docs/doc[@for="InheritancePicker.ValidateTargetName"]/*' />
        /// <devdoc>
        ///      This method takes the target name such as "Form1.vb" and attempts to 
        ///     validate all the characters in the name.  We follow the same logic
        ///     as the shell does in this scenario.  First, we rid ourselves with
        ///     everything beyond the first '.'.  Next, we take any characters in the 
        ///     string and convert them to '_' if they're not a digit or a letter.
        ///     Finally, if the string starts with a digit, it gets a '_' in front of it.
        /// </devdoc>
        private String ValidateTargetName(String targetName) {
            char unkownSymbol = '_';

            //first, if we have valid length and a '.' then strip the extension....
            if (targetName.Length > 0) {

                int dotOffset = targetName.IndexOf('.');

                if (dotOffset > 0)
                    targetName = targetName.Substring(0, dotOffset );

                //convert to an array of chars
                char[] arrayChars = targetName.ToCharArray();

                //replace any symbols with our "unkown symbol"
                for (int i = 0; i < arrayChars.Length; i ++) {
                    //if the current character is something other than a letter or digit, then 
                    //replace it
                    if (!Char.IsLetterOrDigit(arrayChars[i])) {
                        arrayChars[i] = unkownSymbol;
                    }
                }

                targetName = new String(arrayChars);

                //also, if the name starts with a digit - then precede this with our unkown symbol
                if (Char.IsDigit(arrayChars[0])) {
                    targetName = unkownSymbol + targetName;
                }

            }
            return targetName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\storagegenerator\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\resgen\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif


$(O)\ResGen.exe.config : ..\..\..\..\public\tools\inc\private\version\app.config
	copy ..\..\..\..\public\tools\inc\private\version\app.config $(O)\ResGen.exe.config
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\resgen\resgen.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResGen.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ResGen.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Tools {
    using System;
    using System.IO; 
    using System.Collections; 
    using System.Resources; 
    using System.Text;
    using System.Diagnostics;
    using System.Globalization;
    
    /**
     * .NET Development Platform Resource file Generator
     * 
     * This program will read in text files or ResX files of name-value pairs and 
     * produces a .NET .resources file.  Additionally ResGen can change data from
     * any of these three formats to any of the other formats (though text files
     * only support strings).
     *
     * The text files must have lines of the form name=value, and comments are 
     * allowed ('#' at the beginning of the line).  
     * 
     * @author Brian Grunkemeyer, with Nick Kramer & Sreeram Nivarthi
     * @version 1.0
     */
    /// <include file='doc\ResGen.uex' path='docs/doc[@for="ResGen"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ResGen {
        private const int errorCode = unchecked((int)0xbaadbaad);
    
        private static int errors = 0;
    
        // We use a list to preserve the resource ordering (primarily for easier testing),
        // but also use a hash table to check for duplicate names.
        private static ArrayList resources = new ArrayList();
        private static Hashtable resourcesHashTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
    
        private static void AddResource(string name, object value) {
            Entry entry = new Entry(name, value);
    
            if (resourcesHashTable.ContainsKey(name.ToString())) {
                Error(SR.GetString(SR.DuplicateResourceKey, name));
                return;
            }
    
            resources.Add(entry);
            resourcesHashTable.Add(name, value);
        }
    
        /**
         * This is a work-around to a build problem.  String.EndsWith relies on the 
         * NLS tables for part of its calculations.  Unfortunately, these tables aren't
         * present in the assembly yet at the point when we need to call EndsWith.  This
         * gets around that problem (and is somewhat more performant anyway.)
         */
        private static Boolean EndsWithOrdinal(String value, String suffix) {
            int valueLen = value.Length;
            int suffixLen = suffix.Length;
            if (suffixLen>valueLen) {
                return false;
            }
            return(0==String.CompareOrdinal(value, valueLen-suffixLen, suffix, 0, suffixLen));
        }
    
        private static void Error(string message) {
            Console.Error.WriteLine(SR.GetString(SR.ErrorOutput, message));
            errors++;
        }

        private static void Warning(string message) {
            Console.Error.WriteLine(SR.GetString(SR.WarningOutput, message));
        }
    
        private static Format GetFormat(string filename) {
            string extension = Path.GetExtension(filename);
            if (String.Compare(extension, ".txt", true, CultureInfo.InvariantCulture) == 0)
                return Format.Text;
            else if (String.Compare(extension, ".resx", true, CultureInfo.InvariantCulture) == 0)
                return Format.XML;
            else if (String.Compare(extension, ".resources", true, CultureInfo.InvariantCulture) == 0)
                return Format.Binary;
            else {
                Error(SR.GetString(SR.UnknownFileExtension, extension));
                Environment.Exit(errorCode);
                Debug.Fail("Why didn't Environment.Exit exit?");
                return Format.Text; // never reached
            }
        }
    
        /// <include file='doc\ResGen.uex' path='docs/doc[@for="ResGen.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(String[] args) {
            // Tell build we had an error, then set this to 0 if we complete successfully.
            Environment.ExitCode = errorCode;
            if (args.Length < 1 || args[0].Equals("-h") || args[0].Equals("-?") ||
                args[0].Equals("/h") || args[0].Equals("/?")) {
                Usage();
                return;
            }
    
            String[] inFiles;
            String[] outFiles;
            if (args[0].Equals("/compile")) {
                inFiles = new String[args.Length - 1];
                outFiles = new String[args.Length - 1];
                for(int i=0; i<inFiles.Length; i++) {
                    inFiles[i] = args[i+1];
                    int index = inFiles[i].IndexOf(",");
                    if (index != -1) {
                        String tmp = inFiles[i];
                        inFiles[i] = tmp.Substring(0, index);
                        if (index == tmp.Length-1) {
                            Error(SR.GetString(SR.MalformedCompileString, tmp));
                            inFiles = new String[0];
                            break;
                        }
                        outFiles[i] = tmp.Substring(index+1);
                    }
                    else {
                        string resourceFileName = GetResourceFileName(inFiles[i]);
                        if (resourceFileName == null) {
                            Usage();
                            return;
                        }
                        outFiles[i] = resourceFileName;
                    }
                }
            }
            else if (args.Length <= 2) {
                inFiles = new String[1];
                inFiles[0] = args[0];
                outFiles = new String[1];
                if (args.Length == 2) {
                    outFiles[0] = args[1];
                }
                else {
                    string resourceFileName = GetResourceFileName(inFiles[0]);
                    if (resourceFileName == null) {
                        Usage();
                        return;
                    }
                    outFiles[0] = resourceFileName;
                }
            }
            else {
                Usage();
                return;
            }            
    
            // Do all the work.
            for(int i=0; i<inFiles.Length; i++) {
                ProcessFile(inFiles[i], outFiles[i]);
            }
    
            // Quit & report errors, if necessary.
            if (errors != 0) {
                Console.Error.WriteLine(SR.GetString(SR.ErrorCount, errors));
            }
            else {
                // Tell build we succeeded.
                Environment.ExitCode = 0;
            }
        }
    
        private static String GetResourceFileName(String inFile) {
            if (inFile == null) {
                return null;
            }
        
            // Note that the naming scheme is basename.[en-US.]resources
            int end = inFile.LastIndexOf('.');
            if (end == -1) {
                return null;
            }
            return inFile.Substring(0, end) + ".resources";
        }
    
        private static void ProcessFile(String inFile, String outFile) {
            //Console.WriteLine("Processing {0} --> {1}", inFile, outFile);
            // Reset state
            resources.Clear();
            resourcesHashTable.Clear();
    
            try {
                // Explicitly handle missing input files here - don't catch a 
                // FileNotFoundException since we can get them from the loader
                // if we try loading an assembly version we can't find.
                if (!File.Exists(inFile)) {
                    Error(SR.GetString(SR.FileNotFound, inFile));
                    return;
                }

                ReadResources(inFile);
            }
            catch (System.Xml.XmlException xe) {
                Error(SR.GetString(SR.InvalidResX, xe.Message));

                if (xe.Message != null)
                    Error(SR.GetString(SR.SpecificError, xe.GetType(), xe.Message));

                return;
            }
            catch (Exception e) {
                Error(e.Message);
                // We need to give meaningful error messages to the user. 
                // Note that ResXResourceReader wraps any exception it gets
                // in an ArgumentException with the message "Invalid ResX input."
                // If you don't look at the InnerException, you have to attach
                // a debugger to find the problem.
                if (e.InnerException != null) {
                    Exception inner = e.InnerException;
                    StringBuilder sb = new StringBuilder(200);
                    sb.Append(e.Message);
                    while (inner != null) {
                        sb.Append(" ---> ");
                        sb.Append(inner.GetType().Name);
                        sb.Append(": ");
                        sb.Append(inner.Message);
                        inner = inner.InnerException;
                    }
                    Error(SR.GetString(SR.SpecificError, e.InnerException.GetType().Name, sb.ToString()));
                }
                return;
            }
    
            try {
                WriteResources(outFile);
            }
            catch (IOException io) {
                Error(SR.GetString(SR.WriteError, outFile));
                if (io.Message != null)
                    Error(SR.GetString(SR.SpecificError, io.GetType().Name, io.Message));
                if (File.Exists(outFile)) {
                    Error(SR.GetString(SR.CorruptOutput, outFile));
                    try {
                        File.Delete(outFile);
                    }
                    catch (Exception) {
                        Error(SR.GetString(SR.DeleteOutputFileFailed, outFile));
                    }
                }
                return;
            }
            catch (Exception e) {
                Error(SR.GetString(SR.GenericWriteError, outFile));
                if (e.Message != null)
                    Error(SR.GetString(SR.SpecificError, e.GetType().Name, e.Message));
            }
        }
    
        // <doc>
        // <desc>
        //     Reads the resources out of the specified file and populates the
        //     resources hashtable.
        // </desc>
        // <param term='filename'>
        //     Filename to load.
        // </param>
        // </doc>   
        private static void ReadResources(String filename) {
            Format format = GetFormat(filename);
            switch (format) {
                case Format.Text:
                    ReadTextResources(filename);
                    break;
    
                case Format.XML:
                    ReadResources(new ResXResourceReader(filename)); // closes reader for us
                    break;
    
                case Format.Binary:
                    ReadResources(new ResourceReader(filename)); // closes reader for us
                    break;
    
                default:
                    Debug.Fail("Unknown format " + format.ToString());
                    break;
            }
            Console.WriteLine(SR.GetString(SR.ReadIn, resources.Count, filename));
        }
    
        // closes reader when done
        private static void ReadResources(IResourceReader reader) {
            IDictionaryEnumerator resEnum = reader.GetEnumerator();
            while (resEnum.MoveNext()) {
                string name = (string)resEnum.Key;
                object value = resEnum.Value;
                AddResource(name, value);
            }
            reader.Close();
        }
    
        private static void ReadTextResources(String filename) {
            // Check for byte order marks in the beginning of the input file, but
            // default to UTF-8.
            StreamReader sr = new StreamReader(filename, new UTF8Encoding(true), true);
            StringBuilder name = new StringBuilder(255);
            StringBuilder value = new StringBuilder(2048);
    
            int ch = sr.Read();
            while (ch != -1) {
                if (ch == '\n' || ch == '\r') {
                    ch = sr.Read();
                    continue;
                }
    
                // Skip over commented lines or ones starting with whitespace.
                // Support LocStudio INF format's comment char, ';'
                if (ch == '#' || ch == '\t' || ch == ' ' || ch == ';') {
                    // comment char (or blank line) - skip line.
                    sr.ReadLine();
                    ch = sr.Read();
                    continue;
                }
                // Note that in Beta we recommended users should put a [strings] 
                // section in their file.  Now it's completely unnecessary and can 
                // only cause bugs.  We will not parse anything using '[' stuff now
                // and we should give a warning about seeing [strings] stuff.
                // In V1.1 or V2, we can rip this out completely, I hope.
                if (ch == '[') {
                    String skip = sr.ReadLine();
                    if (skip.Equals("strings]"))
                        Warning(SR.GetString(SR.StringsTagObsolete));
                    else
                        throw new Exception(SR.GetString(SR.INFFileBracket, skip));
                    ch = sr.Read();
                    continue;
                }
    
                // Read in name
                name.Length = 0;
                while (ch != '=') {
                    if (ch == '\r' || ch == '\n')
                        throw new Exception(SR.GetString(SR.NoEqualsWithNewLine, name.Length, name));
                    
                    name.Append((char)ch);
                    ch = sr.Read();
                    if (ch == -1)
                        break;
                }
                if (name.Length == 0)
                    throw new Exception(SR.GetString(SR.NoEquals));
    
                // For the INF file, we must allow a space on both sides of the equals
                // sign.  Deal with it.
                if (name[name.Length-1] == ' ') {
                    name.Length = name.Length - 1;
                }
                ch = sr.Read(); // move past =
                // If it exists, move past the first space after the equals sign.
                if (ch == ' ')
                    ch = sr.Read();
    
                // Read in value
                value.Length = 0;
    
                for (;;) {
                    if (ch == '\\') {
                        ch = sr.Read();
                        switch (ch) {
                            case '\\':
                                // nothing needed
                                break;
                            case 'n':
                                ch = '\n';
                                break;
                            case 'r':
                                ch = '\r';
                                break;
                            case 't':
                                ch = '\t';
                                break;
                            case '"':
                                ch = '\"';
                                break;
                            default:
                                throw new Exception(SR.GetString(SR.BadEscape, name.ToString()));
                        }
                    }
    
                    value.Append((char)ch);
                    ch = sr.Read();
    
                    // Consume endline...
                    //   Endline can be \r\n or \n.
                    if (ch == '\r') {
                        ch = sr.Read();
                        if (ch == -1) {
                            break;
                        }
                        else if (ch == '\n') {
                            ch = sr.Read();
                        }
                        break;
                    }
                    else if (ch == '\n') {
                        ch = sr.Read();
                        break;
                    }
    
                    if (ch == -1)
                        break;
                }
    
    
                if (value.Length == 0)
                    throw new Exception(SR.GetString(SR.NoName, name));
    
                AddResource(name.ToString(), value.ToString());
            }
            sr.Close();
        }
    
        private static void WriteResources(String filename) {
            Format format = GetFormat(filename);
            switch (format) {
                case Format.Text:
                    WriteTextResources(filename);
                    break;
    
                case Format.XML:
                    WriteResources(new ResXResourceWriter(filename)); // closes writer for us
                    break;
    
                case Format.Binary:
                    WriteResources(new ResourceWriter(filename)); // closes writer for us
                    break;
    
                default:
                    Debug.Fail("Unknown format " + format.ToString());
                    break;
            }
        }
    
        // closes writer automatically
        private static void WriteResources(IResourceWriter writer) {
            foreach (Entry entry in resources) {
                string key = entry.name;
                object value = entry.value;
                writer.AddResource(key, value);
            }
            Console.Write(SR.GetString(SR.BeginWriting));
            writer.Close();
            Console.WriteLine(SR.GetString(SR.DoneDot));
        }
    
        private static void WriteTextResources(String filename) {
            StreamWriter writer = new StreamWriter(filename);
            foreach (Entry entry in resources) {
                string key = entry.name;
                object value = entry.value;
                if (!(value is string)) {
                    Error(SR.GetString(SR.OnlyString, key, value.GetType().FullName));
                }
                writer.WriteLine("{0}={1}", key, value.ToString());
            }
            writer.Close();
        }
    
        private static void Usage() {
            Console.WriteLine(SR.GetString(SR.Usage, Environment.Version, ThisAssembly.Copyright));
        }
    
        private enum Format {
            Text, // .txt
            XML, // .resx
            Binary, // .resources
        }
    
        // name/value pair
        private class Entry {
            public Entry(string name, object value) {
                this.name = name;
                this.value = value;
            }
    
            public string name;
            public object value;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\resxtoresources\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\vsdesignerreg\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------

!endif

$(O)\VSDesigner.vrg : VSDesigner.vrgpp
    $(CXX_COMPILER_NAME) $(GLOBAL_C_FLAGS) /E $? | findstr /V /B /R "#line ^$$" > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\coolsyntaxoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="CoolSyntaxOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Diagnostics;

    /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CoolSyntaxOutput : SyntaxOutput {                

        private void OutputTypeRef(string nameSpace, string type) {
            OutputTypeRef(nameSpace, type, true);
        }

         private void OutputTypeRef(string nameSpace, string type, bool appendSpace) {
            if (type.EndsWith("[]")) {
                OutputTypeRef(nameSpace, type.Substring(0, type.Length - 2), false);
                Output("[]");
                if (appendSpace) {
                    Output(" ");
                }
                return;
            }

            if (type.Equals("System.Int64")) {
                type = "long";
            }
            else if (type.Equals("System.UInt64")) {
                type = "ulong";
            }
            else if (type.Equals("System.Int32")) {
                type = "int";
            }
            else if (type.Equals("System.UInt32")) {
                type = "uint";
            }
            else if (type.Equals("System.Int16")) {
                type = "short";
            }
            else if (type.Equals("System.UInt16")) {
                type = "ushort";
            }
            else if (type.Equals("System.Byte")) {
                type = "byte";
            }
            else if (type.Equals("System.SByte")) {
                type = "sbyte";
            }
            else if (type.Equals("System.Single")) {
                type = "float";
            }
            else if (type.Equals("System.Double")) {
                type = "double";
            }
            else if (type.Equals("System.Void")) {
                type = "void";
            }
            else if (type.Equals("System.Char")) {
                type = "char";
            }
            else if (type.Equals("System.Boolean")) {
                type = "bool";
            }
            else if (type.Equals("System.Variant")) {
                type = "variant";
            }
            else if (type.Equals("System.String")) {
                type = "string";
            }
            else if (type.Equals("System.Object")) {
                type = "object";
            }
            /*
            UE Change - don't generate correct code, rather always only show the name

            else if (type.StartsWith(nameSpace)) {
                type = type.Substring(nameSpace.Length + 1);
            }
            */
            else {
                type = type.Substring(type.LastIndexOf(".") + 1);
            }
            
            Output(type.Replace( '$', '.' ));

            if (appendSpace) {
                Output(" ");
            }
        }

        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.Language"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Language {
            get {
                return "C#";
            }
        }
        
        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputTypeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputTypeDeclaration(TextWriter tw,
                                                   string ns,
                                                   string name,
                                                   Type type,
                                                   int attributes,
                                                   Type baseType,
                                                   Type[] implements,
                                                   bool isDelegate,
                                                   MethodInfo delegateInvoke) {
            textWriter = tw;

            Debug.Assert(tw != null, "Must have writer!");
            Debug.Assert(ns != null, "Must have namespace!");
            Debug.Assert(name != null, "Must have name!");
            Debug.Assert(type != null, "Must have type!");
            // baseType is OK to be null
            Debug.Assert(implements != null, "Must have implements array!");
            Debug.Assert(!isDelegate || delegateInvoke != null, "Must have delegateInvoke for delegates!");

            if (isDelegate) {
                OutputDecorationOfType((attributes & (~((int)TypeAttributes.Sealed))));
                Output("delegate ");
                OutputTypeRef(ns, delegateInvoke.ReturnType.FullName);
                Output(name.Replace( '$', '.' ));
                Output("(");
                OutputParameters(ns, delegateInvoke.GetParameters());
                Output(");");
            }
            else {
                OutputDecorationOfType(attributes);
                OutputTypeOfType(type);
                Output(name.Replace( '$', '.' ));

                bool outputColon = false;
                if (baseType != null && baseType != typeof(object) && baseType != typeof( System.Enum ) && baseType != typeof( System.ValueType )) {
                    outputColon = true;
                    Output(" : ");
                    OutputTypeRef(ns, baseType.FullName, false);
                }

                for (int i=0; implements != null && i<implements.Length; i++) {
                    if (!outputColon) {
                        Output(" : ");
                        outputColon = true;
                    }
                    else {
                        Output(", ");
                    }

                    Debug.Assert( implements[i] != null, "Empty entry in implements array, element " + i );
                    if (implements[ i ] != null)
                        OutputTypeRef(ns, implements[i].FullName, false);
                }
            }

            textWriter = null;
        }

        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputFieldDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputFieldDeclaration(TextWriter tw, string ns, FieldInfo fi, string name, string fieldTypeFullName, int attributes) {
            textWriter = tw;

            OutputDecorationOfField(attributes);
            OutputTypeRef(ns, fieldTypeFullName);
            Output(name);
            Output(";");


            textWriter = null;
        }

        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputMethodDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputMethodDeclaration(TextWriter tw, string ns, MethodInfo fi, string name, string returnTypeFullName, int attributes, ParameterInfo[] parameters, bool isInterface) {
            textWriter = tw;
            if (isInterface)
                OutputDecorationOfMethod(fi, MethodAttributesNone );
            else
                OutputDecorationOfMethod(fi, MethodAttributesAll);

            OutputTypeRef(ns, returnTypeFullName);
            Output(name);

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");
            Output(";");

            textWriter = null;
        }

        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputConstructorDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputConstructorDeclaration(TextWriter tw, string ns, ConstructorInfo fi, string name, int attributes, ParameterInfo[] parameters) {
            textWriter = tw;

            OutputDecorationOfMethod(attributes, MethodAttributesAll, (fi.DeclaringType == fi.ReflectedType));
            Output(fi.ReflectedType.Name.Replace( '$', '.' ));

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");
            Output(";");

            textWriter = null;
        }

        /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputPropertyDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputPropertyDeclaration(TextWriter tw, string ns, PropertyInfo pi, string name, string returnTypeFullName, int attributes, MethodInfo getter, MethodInfo setter, ParameterInfo[] parameters, bool isInterface) {
            textWriter = tw;

            Debug.Assert(getter != null || setter != null, "invalid property declaration");

            if (getter != null) {
                if (isInterface)
                    OutputDecorationOfMethod((int)getter.Attributes, MethodAttributesNone, (pi.DeclaringType == pi.ReflectedType));
                else
                    OutputDecorationOfMethod((int)getter.Attributes, MethodAttributesProperty, (pi.DeclaringType == pi.ReflectedType));
            }

            OutputTypeRef(ns, returnTypeFullName);
            if (parameters.Length > 0) {
                Output("this");
            }
            else {
                Output(name);
            }

            if (parameters.Length > 0) {
                Output("[");
                OutputParameters(ns, parameters);
                Output("]");
            }

            Output(" {");

            if (getter != null) {
                OutputDecorationOfMethod(getter, MethodAttributesAccessor);
                Output("get;");
            }
            if (setter != null) {
                if (getter != null) {
                    Output(" ");
                }
                OutputDecorationOfMethod(setter, MethodAttributesAccessor);
                Output("set;");
            }

            Output("}");

            textWriter = null;
        }

        private void OutputParameters(string ns, ParameterInfo[] parameters) {
            for (int i=0; i<parameters.Length; i++) {
                if (i > 0) {
                    Output(", ");
                }
                OutputParameter(ns, parameters[i]);
            }
        }

        private void OutputParameter(string ns, ParameterInfo param) {
            if (param.ParameterType.IsByRef) {
                Output("ref ");
            }
            else {
                if (param.IsIn) {
                    Output("in ");
                }
                if (param.IsOut) {
                    Output("out ");
                }
            }
            OutputTypeRef(ns, WFCGenUEGenerator.GetUnrefTypeName( param.ParameterType ));
            Output(param.Name);
        }

        private void OutputDecorationOfMethod( int methodAttributes, int mask, 
                                               bool declaredOnCurrentType )
        {
            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("internal ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*protected && internal*/ internal ");
                        Output("internal ");
                        break;
                    case MethodAttributes.FamORAssem:
                        Output("protected internal ");
                        break;
                    case MethodAttributes.Public:
                        Output("public ");
                        break;
                    case MethodAttributes.Private:
                        Output("private ");
                        break;
                    case MethodAttributes.Family:
                        Output("protected ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*private scope*/ private ");
                        Output("private ");
                        break;
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("static ");
                }
            }

            bool overrided = false;

            int vtableLayout = methodAttributes & (int)MethodAttributes.VtableLayoutMask;
            switch ((MethodAttributes)vtableLayout) {
                case MethodAttributes.NewSlot:
                    if (!declaredOnCurrentType) {
                        Output("new ");
                    }
                    break;
                case MethodAttributes.ReuseSlot:
                    if (!declaredOnCurrentType) {
                        Output("override ");
                        overrided = true;
                    }
                    break;
            }

            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) 
                {
                  // BL changes {{
                  if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                      Output("abstract ");
                  // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("virtual ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputDecorationOfMethod(MethodInfo mi, int mask) {
            int methodAttributes = (int)mi.Attributes;
            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("internal ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*protected && internal*/ internal ");
                        Output("internal ");
                        break;
                    case MethodAttributes.FamORAssem:
                        Output("protected internal ");
                        break;
                    case MethodAttributes.Public:
                        Output("public ");
                        break;
                    case MethodAttributes.Private:
                        Output("private ");
                        break;
                    case MethodAttributes.Family:
                        Output("protected ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*private scope*/ private ");
                        Output("private ");
                        break;
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("static ");
                }
            }

            bool overrided = false;

            int decl = MemberDecl.FromMethodInfo(mi);
            switch (decl) {
                case MemberDecl.Inherited:
                    // Output("/*inherited*/ ");
                    break;
                case MemberDecl.New:
                    Output("new ");
                    break;
                case MemberDecl.Override:
                    Output("override ");
                    overrided = true;
                    break;
                case MemberDecl.DeclaredOnType:
                    // nothing;
                    break;
            }


            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0)
                {
                   // BL changes {{
                   if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                      Output( "abstract " );
                   // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("virtual ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                    // Output("/*lock*/ ");
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputTypeOfType(Type type) {
            int cls = (int) type.Attributes & (int)TypeAttributes.ClassSemanticsMask;

            if ((cls & (int)TypeAttributes.Interface) != 0) {
                Output("interface ");
            }
            else if (type.BaseType == typeof( System.Enum )) {      
                Output("enum ");
            }                                        
            else if (type.BaseType == typeof( System.ValueType  )) {                
                Output("struct ");
            }
            else {
                Output("class ");
            }
        }

        private void OutputDecorationOfType(int typeAttributes) {
            int cls = typeAttributes & (int)TypeAttributes.ClassSemanticsMask;
            if ((typeAttributes & (int)TypeAttributes.Public) != 0 ||
                (typeAttributes & (int)TypeAttributes.NestedPublic) != 0) {
                Output("public ");
            }
            if ((typeAttributes & (int)TypeAttributes.Sealed) != 0){
                Output("sealed ");
            }
            if ((typeAttributes & (int)TypeAttributes.Abstract) != 0
                && (typeAttributes & (int)TypeAttributes.Interface) == 0) {
                Output("abstract ");
            }
        }
        private void OutputDecorationOfField(int fieldAttributes) {
            int access = fieldAttributes & (int)FieldAttributes.FieldAccessMask;
            switch ((FieldAttributes)access) {
                case FieldAttributes.Assembly:
                    Output("internal ");
                    break;
                case FieldAttributes.FamANDAssem:
                    // Output("/*protected && internal*/ internal ");
                    Output("internal ");
                    break;
                case FieldAttributes.FamORAssem:
                    Output("protected internal ");
                    break;
                case FieldAttributes.Public:
                    Output("public ");
                    break;
                case FieldAttributes.Private:
                    Output("private ");
                    break;
                case FieldAttributes.Family:
                    Output("protected ");
                    break;
                case FieldAttributes.PrivateScope:
                    // Output("/*private scope*/ private ");
                    Output("private ");
                    break;
            }

            if ((fieldAttributes & (int)FieldAttributes.Literal) != 0) {
                Output("const ");
            }
            else {
                if ((fieldAttributes & (int)FieldAttributes.Static) != 0) {
                    Output("static ");
                }
                if ((fieldAttributes & (int)FieldAttributes.InitOnly) != 0) {
                    Output("readonly ");
                }
            }
            if ((fieldAttributes & (int)FieldAttributes.NotSerialized) != 0) {
                Output("transient ");
            }

            if ((fieldAttributes & (int)FieldAttributes.PinvokeImpl) != 0) {
                Output("extern ");
            }
        }

         // BL changes begin
         /// <include file='doc\CoolSyntaxOutput.uex' path='docs/doc[@for="CoolSyntaxOutput.OutputOperatorDeclaration"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public override void OutputOperatorDeclaration( TextWriter tw, string ns, MethodInfo fi,
                                                      string strName, string returnTypeFullName,
                                                      int attributes, ParameterInfo[] parameters, bool isInterface )
         {
            textWriter = tw;

            if ( isInterface )
               OutputDecorationOfMethod( fi, MethodAttributesNone );
            else
               OutputDecorationOfMethod( fi, MethodAttributesAll );
            
            if ( strName == "op_Explicit" || strName == "op_Implicit" ) // Conversion operators
            {
               if ( strName == "op_Implicit" )
                  Output( "implicit " );
               else
                  Output( "explicit " );

               Output( "operator " );
               OutputTypeRef( ns, returnTypeFullName, false );
            }   
            else if ( parameters.Length == 1 || parameters.Length == 2 )  // Unary and binray operators
            {
               if ( returnTypeFullName != "System.Void" )
                  OutputTypeRef( ns, returnTypeFullName );

               Output( "operator " );
               Output( GetOperatorSymbol( strName ) );            
            }
            else
            {
               Debug.Assert( true, "Wrong number of parameters in the operator method" );
            }

            Output( "(" );
            OutputParameters( ns, parameters );
            Output( ")" );
         
            Output( ";" );
            textWriter = null;
         }
         // BL changes end
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\jscriptsyntaxoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="JScriptSyntaxOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

   using System;
   using System.Collections;
   using System.IO;
   using System.Reflection;
   using System.Diagnostics;

   /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public class JScriptSyntaxOutput : SyntaxOutput {
      
      private string m_strClassName = "Foo";

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.GenerateOutput"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override bool GenerateOutput( Type type )
      {         
         base.GenerateOutput( type );

         // Get the class name
         m_strClassName = type.Name;         

         // Don't show anything for any of the following:
         // Interface, Struct, Enum, Delegate

         int cls = (int)type.Attributes & (int)TypeAttributes.ClassSemanticsMask;

         if ( ( ( cls & (int)TypeAttributes.Interface ) != 0 ) ||    // Interface
              ( type.BaseType == typeof( System.Enum ) ) ||         // Enum
              ( type.BaseType == typeof( System.ValueType ) ))     // Struct
            return false;
         
         // Delegate
         if ( ( type.BaseType == typeof( Delegate ) || type.BaseType == typeof( MulticastDelegate ) ) && 
              ( type != typeof( Delegate ) && type != typeof( MulticastDelegate ) ) )
            return false;

         return true;
      }

      private void OutputTypeRef( string nameSpace, string type )
      {
         OutputTypeRef( nameSpace, type, false );
      }

      private void OutputTypeRef( string nameSpace, string type, bool appendSpace )
      {
         if ( type.EndsWith( "[]" ) )
         {
            OutputTypeRef( nameSpace, type.Substring( 0, type.Length - 2 ), false );
            Output( "[]" );
            if ( appendSpace )
               Output( " " );
            return;
         }

         if ( type == "System.Int64" )
            type = "long";
         else if ( type == "System.Int32" )
            type = "int";
         else if ( type == "System.Single" )
            type = "float";
         else if ( type == "System.Double" )
            type = "double";
         else
            type = type.Substring( type.LastIndexOf( "." ) + 1 );

         Output( type.Replace( '$', '.' ) );
         if ( appendSpace )
            Output( " " );
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.Language"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override string Language
      {
         get { return "JScript"; }
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputTypeDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputTypeDeclaration( TextWriter tw,
                                                  string ns,
                                                  string name,
                                                  Type type,
                                                  int attributes,
                                                  Type baseType,
                                                  Type[] implements,
                                                  bool isDelegate,
                                                  MethodInfo delegateInvoke )
      {         
         textWriter = tw;

         Debug.Assert( tw != null, "Must have writer!" );
         Debug.Assert( ns != null, "Must have namespace!" );
         Debug.Assert( name != null, "Must have name!" );
         Debug.Assert( type != null, "Must have type!" );

         // baseType is OK to be null
         Debug.Assert( implements != null, "Must have implements array!" );
         Debug.Assert( !isDelegate || delegateInvoke != null, "Must have delegateInvoke for delegates!" );

         if ( isDelegate ) // Delegate: <n/a--don't include anything>
         {            
            /*
            OutputDecorationOfType( ( attributes & (~( (int)TypeAttributes.Sealed ) ) ) );
            Output( "delegate " );
            OutputTypeRef( ns, delegateInvoke.ReturnType.FullName );
            Output( name );
            Output( "(" );
            OutputParameters( ns, delegateInvoke.GetParameters() );
            Output( ");" );
            */
         }
         else 
         {
            OutputDecorationOfType( attributes );
            OutputTypeOfType(type, attributes );
            Output( name.Replace( '$', '.' ) );

            bool bExtends = false;
            if ( baseType != null && baseType != typeof( object ) && 
                 baseType != typeof( System.Enum ) && baseType != typeof( System.ValueType ) )
            {
               bExtends = true;
               Output( " extends " );
               OutputTypeRef( ns, baseType.FullName, false );
            }

            for ( int i = 0; implements != null && i < implements.Length; i++ )
            {
               if ( !bExtends )
               {
                  Output( " implements " );
                  bExtends = true;
               }
               else
                  Output( ", " );

               if ( implements[i] != null )
                  OutputTypeRef( ns, implements[i].FullName, false );

               Debug.Assert( implements[i] != null, "Empty entry in implements array, element " + i );
            }
         }

         textWriter = null;
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputFieldDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputFieldDeclaration( TextWriter tw, string ns, FieldInfo fi,
                                                   string name, string fieldTypeFullName, int attributes )
      {
         textWriter = tw;

         OutputDecorationOfField( attributes );
         Output( "var " );
         Output( name );
         Output( " : " );
         OutputTypeRef( ns, fieldTypeFullName );
         Output( ";" );

         textWriter = null;
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputMethodDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputMethodDeclaration( TextWriter tw, string ns, MethodInfo fi, 
                                                    string name, string returnTypeFullName, 
                                                    int attributes, ParameterInfo[] parameters, bool isInterface )
      {
         textWriter = tw;
         if ( isInterface )
            OutputDecorationOfMethod( fi, MethodAttributesNone );
         else
            OutputDecorationOfMethod( fi, MethodAttributesAll );

         Output( "function " );
         Output( name );

         Output( "(" );
         OutputParameters( ns, parameters );
         Output( ")" );

         if ( returnTypeFullName != "System.Void" )
         {
            Output( " : " );
            OutputTypeRef( ns, returnTypeFullName );
         }

         Output( ";" );
         textWriter = null;
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputConstructorDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputConstructorDeclaration( TextWriter tw, string ns, ConstructorInfo fi, 
                                                         string name, int attributes, ParameterInfo[] parameters ) 
      {
         textWriter = tw;

         OutputDecorationOfMethod( attributes, MethodAttributesAll, ( fi.DeclaringType == fi.ReflectedType ) );
         Output( "function " );
         Output( fi.ReflectedType.Name.Replace( '$', '.' ) );

         Output( "(" );
         OutputParameters( ns, parameters );
         Output( ")" );
         Output( ";" );

         textWriter = null;
      }            

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputPropertyDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputPropertyDeclaration( TextWriter tw, string ns, PropertyInfo pi, string name,
                                                      string returnTypeFullName, int attributes,
                                                      MethodInfo getter, MethodInfo setter, ParameterInfo[] parameters,
                                                      bool isInterface ) 
      {
         textWriter = tw;

         Debug.Assert( getter != null || setter != null, "invalid property declaration" );

         bool bIndexed = ( parameters.Length > 0 );

         if ( !bIndexed && getter != null )
         {
            if ( isInterface )
               OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesNone,
                                         (pi.DeclaringType == pi.ReflectedType ) );
            else
               OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesProperty, 
                                         ( pi.DeclaringType == pi.ReflectedType ) );
         }
         
         if ( getter != null )
         {
            if ( !bIndexed )
               Output( "function get " );
            else         
            {
               Output( "value = " );
               Output( m_strClassName );
               Output( "Object." );
            }
         
            Output( name );

            if ( !bIndexed )
            {
               // OutputDecorationOfMethod( getter, MethodAttributesAccessor );
               Output( "() : " );
               OutputTypeRef( (string)ns, returnTypeFullName );
            }
            else
            {
               Output( "(" );
               OutputParameters( ns, parameters, false );
               Output( ")" );
            }

            Output( ";" );
         }
         
         if ( setter != null )
         {
            if ( !bIndexed )
            {
               OutputDecorationOfMethod( (int)setter.Attributes, MethodAttributesProperty,
                                         ( pi.DeclaringType == pi.ReflectedType ) );
               Output( "function set " );
            }
            else
            {
               Output( m_strClassName );
               Output( "Object." );
            }

            Output( name );
            Output( "(" );
            if ( !bIndexed )
               OutputTypeRef( (string)ns, returnTypeFullName );
            else
               OutputParameters( ns, parameters, false );
            Output( ")" );
            if ( bIndexed )
               Output( " = value" );
            Output( ";" );
         }

         textWriter = null;
      }

      private void OutputParameters( string ns, ParameterInfo[] parameters )
      {
         OutputParameters( ns, parameters, true );
      }

      private void OutputParameters( string ns, ParameterInfo[] parameters, bool bShowType )
      {
         for ( int i = 0; i < parameters.Length; i++ )
         {
            if ( i > 0 )
               Output( ", " );
            OutputParameter( ns, parameters[i], bShowType );
         }
      }
      
      private void OutputParameter( string ns, ParameterInfo param, bool bShowType )
      {         
         if ( !param.ParameterType.IsByRef )
         {
            if ( param.IsIn )
               Output( "in " );

            /* 
            There's no JScript equivalent for the C# keyword 'out'
            if ( param.IsOut )
               Output( "out " );
            */
         }

         Output( param.Name );
         if ( bShowType )
         {
            Output( " : " );
            OutputTypeRef( ns, WFCGenUEGenerator.GetUnrefTypeName( param.ParameterType ) );
         }
      }

      private void OutputDecorationOfMethod( int methodAttributes, int mask, bool declaredOnCurrentType )
      {
         if ( ( mask & MethodAttributesProperty ) != 0 )
         {
            int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;

            switch ( ( MethodAttributes)access )
            {
               case MethodAttributes.Assembly:
                  Output( "internal " );
                  break;

               case MethodAttributes.FamANDAssem:
                  // Output( "/*protected && internal*/ internal " );
                  Output( "internal " );
                  break;

               case MethodAttributes.FamORAssem:
                  Output( "package " );
                  break;

               case MethodAttributes.Public:
                  Output( "public " );
                  break;

               case MethodAttributes.Private:
                  Output( "private " );
                  break;

               case MethodAttributes.Family:
                  Output( "protected " );
                  break;

               case MethodAttributes.PrivateScope:
                  // Output( "/*private scope*/ private " );
                  Output( "private " );
                  break;
            }

            if ( ( methodAttributes & (int)MethodAttributes.Static ) != 0 )
               Output( "static " );
         }

         int vtableLayout = methodAttributes & (int)MethodAttributes.VtableLayoutMask;

         switch ( (MethodAttributes)vtableLayout )
         {
            case MethodAttributes.NewSlot:
               if ( !declaredOnCurrentType )
                  Output( "new " );
                  break;

            case MethodAttributes.ReuseSlot:
               if ( !declaredOnCurrentType ) 
                  Output( "override " );
               break;
         }

         if ( ( mask & MethodAttributesAccessor ) != 0 ) 
         {
            if ( ( methodAttributes & (int)MethodAttributes.Abstract ) != 0 )             
               Output( "abstract " );

            // virtual = no JScript equivalent--don't translate 
            /*
            else if ( ( methodAttributes & (int)MethodAttributes.Virtual ) != 0 && !bOverrided )
               Output( "virtual " );
            */

            if ( ( methodAttributes & (int)MethodImplAttributes.Synchronized ) != 0 ) 
            {
               // Output( "/*lock*/ " );
            }
            // do nothing: SpecialName
            // do nothing: RTSpecialName

            if ( ( methodAttributes & (int)MethodAttributes.PinvokeImpl ) != 0 ) 
               Output( "extern " );            
         }
      }

      private void OutputDecorationOfMethod( MethodInfo mi, int mask )
      {
         int methodAttributes = (int)mi.Attributes;
         if ( ( mask & MethodAttributesProperty ) != 0 )
         {
            int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;

            switch ( (MethodAttributes)access )
            {
               case MethodAttributes.Assembly:
                  Output( "internal " );
                  break;

               case MethodAttributes.FamANDAssem:
                  // Output( "/*protected && internal*/ internal " );
                  Output( "internal " );
                  break;

               case MethodAttributes.FamORAssem:
                  Output( "package " );
                  break;

               case MethodAttributes.Public:
                  Output( "public " );
                  break;

               case MethodAttributes.Private:
                  Output( "private " );
                  break;

               case MethodAttributes.Family:
                  Output( "protected " );
                  break;

               case MethodAttributes.PrivateScope:
                  // Output( "/*private scope*/ private " );
                  Output( "private " );
                  break;
            }

            if ( ( methodAttributes & (int)MethodAttributes.Static ) != 0 )
               Output( "static " );
         }

         int decl = MemberDecl.FromMethodInfo( mi );
         switch ( decl )
         {
            case MemberDecl.Inherited:
               // Output( "/*inherited*/ " );
               break;

            case MemberDecl.New:
               Output( "new " );
               break;

            case MemberDecl.Override:
               Output( "override " );
               break;

            case MemberDecl.DeclaredOnType:
               // nothing;
               break;
         }


         if ( ( mask & MethodAttributesAccessor ) != 0 )
         {
            if ( ( methodAttributes & (int)MethodAttributes.Abstract ) != 0 ) 
               Output( "abstract " );                

            // virtual = no JScript equivalent--don't translate 
            /*
            else if ( ( methodAttributes & (int)MethodAttributes.Virtual ) != 0 && !bOverrided ) 
               Output( "virtual " );
            */

            if ( ( methodAttributes & (int)MethodImplAttributes.Synchronized ) != 0 ) 
            {
               // Output( "/*lock*/ " );
            }
            // do nothing: SpecialName
            // do nothing: RTSpecialName
            if ( ( methodAttributes & (int)MethodAttributes.PinvokeImpl ) != 0 )
               Output( "extern " );
         }
      }

      private void OutputTypeOfType(Type type, int typeAttributes )
      {
         int cls = typeAttributes & (int)TypeAttributes.ClassSemanticsMask;

         if ( ( cls & (int)TypeAttributes.Interface ) != 0 )
            Output( "interface " );
         else if (type.BaseType == typeof( System.Enum ))
            Output("enum ");                                                    
        else if (type.BaseType == typeof( System.ValueType  ))
            Output("struct ");           
        else
            Output( "class " );
      }

      private void OutputDecorationOfType( int typeAttributes )
      {
         int cls = typeAttributes & (int)TypeAttributes.ClassSemanticsMask;

         if ( ( typeAttributes & (int)TypeAttributes.Public ) != 0 ||
              ( typeAttributes & (int)TypeAttributes.NestedPublic ) != 0 )
            Output( "public " );

         // sealed = no JScript equivalent--don't translate
         /*
         if ( ( typeAttributes & (int)TypeAttributes.Sealed ) != 0 &&
              ( cls & (int)TypeAttributes.ValueType ) == 0 &&
              ( cls & (int)TypeAttributes.Enum ) == 0 )
            Output( "sealed " );
         */

         if ( ( typeAttributes & (int)TypeAttributes.Abstract ) != 0 &&
              ( typeAttributes & (int)TypeAttributes.Interface ) == 0 )
            Output( "abstract " );
      }

      private void OutputDecorationOfField( int fieldAttributes )
      {
         int access = fieldAttributes & (int)FieldAttributes.FieldAccessMask;

         switch ( (FieldAttributes)access ) 
         {
            case FieldAttributes.Assembly:
               Output( "internal " );
               break;

            case FieldAttributes.FamANDAssem:
               // Output( "/*protected && internal*/ internal " );
               Output( "internal " );
               break;

            case FieldAttributes.FamORAssem:
               Output( "package " );
               break;

            case FieldAttributes.Public:
               Output( "public " );
               break;

            case FieldAttributes.Private:
               Output( "private " );
               break;

            case FieldAttributes.Family:
               Output( "protected " );
               break;

            case FieldAttributes.PrivateScope:
               // Output( "/*private scope*/ private " );
               Output( "private " );
               break;
         }

         if ( ( fieldAttributes & (int)FieldAttributes.Literal ) != 0 ) {
            // Output( "const " ); // const = <no JScript equivalent--don't translate>
         }
         else
         {
            if ( ( fieldAttributes & (int)FieldAttributes.Static ) != 0 )
               Output( "static " );

            // readonly = <no equivalent--don't translate>
            /*
            if ( ( fieldAttributes & (int)FieldAttributes.InitOnly ) != 0 )
               Output( "readonly " );
            */
         }

         if ( ( fieldAttributes & (int)FieldAttributes.NotSerialized ) != 0 )
             Output( "transient " );

         if ( ( fieldAttributes & (int)FieldAttributes.PinvokeImpl ) != 0 )
            Output( "extern " );
      }

      /// <include file='doc\JScriptSyntaxOutput.uex' path='docs/doc[@for="JScriptSyntaxOutput.OutputOperatorDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public override void OutputOperatorDeclaration( TextWriter tw, string ns, MethodInfo fi, 
                                                      string strName, string returnTypeFullName, 
                                                      int attributes, ParameterInfo[] parameters, bool isInterface )
      {
         textWriter = tw;         
         Output( "value = " );
            
         if ( strName == "op_Explicit" )        // Explicit conversion
         {
            // syntax pattern:  value = <CLS return type>(<param name>);
            // e.g.  value = Int32(a);
            Output( returnTypeFullName.Substring( returnTypeFullName.LastIndexOf( "." ) + 1 ) );
            Output( "(" );
            Output( parameters[0].Name );
            Output( ")" );
         }
         else if ( strName == "op_Implicit" )   // Implicit conversion
         {
            // syntax pattern:  value = <param name>;
            // e.g.  value = a;
            Output( parameters[0].Name );
         }
         else if ( parameters.Length == 1 )     // Unary operator
         {
            if ( strName == "op_UnaryNegation" ||
                 strName == "op_UnaryPlus" ||
                 strName == "op_Negation" )
            {
               Output( GetOperatorSymbol( strName ) );
               Output( parameters[0].Name );
            }
            else
            {
               Output( parameters[0].Name );
               Output( GetOperatorSymbol( strName ) );
            }
         }
         else if ( parameters.Length == 2 )     // Binary operator
         {
            Output( parameters[0].Name );
            Output( " " );
            Output( GetOperatorSymbol( strName ) );
            Output( " " );
            Output( parameters[1].Name );
         }
         else
         {
            Debug.Assert( true, "Wrong number of parameters in the operator method" );
         }

         Output( ";" );
         textWriter = null;
      }

   } // class JScriptSyntaxOutput

} // namespace Microsoft.Tools.WFCGenUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\resxtoresources\resxtoresources.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXtoResources.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.DNA.ResXtoResources {

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Resources;
    using System.ComponentModel;

    // A remarkably trivial program to convert .resX files to .resources format.
    /// <include file='doc\ResXtoResources.uex' path='docs/doc[@for="ResXtoResources"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ResXtoResources {
        private static void DemandArguments(string[] args, int count) {
            if (args.Length < count) {
                Usage();
            }
        }

        private static void Usage() {
            Console.WriteLine("Usage:");
            Console.WriteLine("    ResXtoResources /compile input.resX output.resources");
            Console.WriteLine("    ResXtoResources /decompile input.resources output.resX");
            // undocumented: Console.WriteLine("    ResXtoResources /dump input.resources");
            // undocumented: Console.WriteLine("    ResXtoResources /dumpX input.resX");
            
            Environment.Exit(1);
        }

        /// <include file='doc\ResXtoResources.uex' path='docs/doc[@for="ResXtoResources.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(string[] args) {
            DemandArguments(args, 1);

            IResourceReader reader = null;
            IResourceWriter writer = null;
            Task task = Task.Convert;

            // process arguments
            if (args[0].Equals("/compile")) {
                DemandArguments(args, 3);
                reader = new ResXResourceReader(args[1]);
                writer = new ResourceWriter(args[2]);
                task = Task.Convert;
            }
            else if (args[0].Equals("/decompile")) {
                DemandArguments(args, 3);
                reader = new ResourceReader(args[1]);
                writer = new ResXResourceWriter(args[2]);
                task = Task.Convert;
            }
            else if (args[0].Equals("/dump")) {
                DemandArguments(args, 2);
                reader = new ResourceReader(args[1]);
                task = Task.Dump;
            }
            else if (args[0].Equals("/dumpX")) {
                DemandArguments(args, 2);
                reader = new ResXResourceReader(args[1]);
                task = Task.Dump;
            }
            else {
                Usage();
            }

            // main loop
            IDictionaryEnumerator resEnum = reader.GetEnumerator();
            while (resEnum.MoveNext()) {
                string name = (string)resEnum.Key;
                object value = resEnum.Value;
                switch (task) {
                    case Task.Convert:
                        writer.AddResource(name, value);
                        // Console.WriteLine("Adding " + name + " = " + value);
                        break;

                    case Task.Dump:
                        Console.WriteLine(name + " = " + value);
                        break;
                }
            }

            // cleanup
            reader.Close();
            if (writer != null) {
                writer.Close();
            }
        }


        private enum Task {
            Convert,
            Dump,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\storagegenerator\storagegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="StorageGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                ",
//------------------------------------------------------------------------------

namespace Microsoft.Tools.StorageGenerator {
    using System.Threading;
    

    using System;
    using System.Diagnostics;
    using System.IO;

    /// <include file='doc\StorageGenerator.uex' path='docs/doc[@for="StorageGenerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class StorageGenerator {
        internal TypeData[] typeData;

        /// <include file='doc\StorageGenerator.uex' path='docs/doc[@for="StorageGenerator.StorageGenerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StorageGenerator() {
            this.typeData = new TypeData[] {
/////////////////////////////////////////////////
new TypeData("Boolean", "", true, "const Boolean defaultValue = ", "false", TypeData.aggregateMaxMinFirst, "valueNo1 == valueNo2 ? 0 : (valueNo1 ? 1 : -1)", "false", "true", "max=values[record] || max", "min=values[record] && min", null, null),
new TypeData("Byte", "Int64", true, "const Byte defaultValue = ", "0", TypeData.aggregateAll, null, "Byte.MinValue", "Byte.MaxValue", null, null, null, null),
new TypeData("Char", "Int64", true, "const Char defaultValue = ", "\'\\0\'", TypeData.aggregateMaxMinFirst, null, "Char.MinValue", "Char.MaxValue", "max=(values[record] > max) ? values[record] : max", "min=(values[record] < min) ? values[record] : min", null, null),
new TypeData("Currency", "Decimal", true, "static readonly Currency defaultValue = ", "Currency.Zero", TypeData.aggregateAll, "Currency.Compare(valueNo1, valueNo2)", "Currency.MinValue", "Currency.MaxValue", "max=Currency.Max(values[records[i]], max)", "min=Currency.Min(values[records[i]], min)", null, null),
new TypeData("DateTime", "", true, "static readonly DateTime defaultValue = ", "DateTime.MinValue",  TypeData.aggregateMaxMinFirst, "DateTime.Compare(valueNo1, valueNo2)", "DateTime.MinValue", "DateTime.MaxValue", "max=(DateTime.Compare(values[record],max) >= 0) ? values[record] : max", "min=(DateTime.Compare(values[record],min) < 0) ? values[record] : min", null, null),
new TypeData("Decimal", "Decimal", true, "static readonly Decimal defaultValue = ", "Decimal.Zero", TypeData.aggregateAll, null, "Decimal.MinValue", "Decimal.MaxValue", "max=Decimal.Max(values[record], max)", "min=Decimal.Min(values[record], min)", null, null),
new TypeData("Double", "Double", true, "const Double defaultValue = ", "0.0d", TypeData.aggregateAll, null, "Double.MinValue", "Double.MaxValue", null, null, null, null),
new TypeData("Int16", "Int64", true, "const Int16 defaultValue = ", "0", TypeData.aggregateAll, null, "Int16.MinValue", "Int16.MaxValue", null, null, null, null),
new TypeData("Int32", "Int64", true, "const Int32 defaultValue = ", "0", TypeData.aggregateAll, null, "Int32.MinValue", "Int32.MaxValue", null, null, null, null),
new TypeData("Int64", "Int64", true, "const Int64 defaultValue = ", "0", TypeData.aggregateAll, null, "Int64.MinValue", "Int64.MaxValue", null, null, null, null),
new TypeData("SByte", "Int64", false, "const SByte defaultValue = ", "0", TypeData.aggregateAll, "valueNo1.CompareTo(valueNo2)", "SByte.MinValue", "SByte.MaxValue", null, null, "!value.Equals(defaultValue)", "valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)"),
new TypeData("Single", "Double", true, "const Single defaultValue = ", "0.0f", TypeData.aggregateAll, null, "Single.MinValue", "Single.MaxValue", null, null, null, null),
new TypeData("TimeSpan", "", true, "static readonly TimeSpan defaultValue = ", "TimeSpan.Zero", TypeData.aggregateMaxMinFirst, "TimeSpan.Compare(valueNo1, valueNo2)", "TimeSpan.MinValue", "TimeSpan.MaxValue", "max=(TimeSpan.Compare(values[record],max) >= 0) ? values[record] : max", "min=(TimeSpan.Compare(values[record],min) < 0) ? values[record] : min", null, null),
new TypeData("UInt16", "Int64", false, "static readonly UInt16 defaultValue = ", "UInt16.MinValue", TypeData.aggregateAll, "valueNo1.CompareTo(valueNo2)", "UInt16.MinValue", "UInt16.MaxValue", null, null, "!value.Equals(defaultValue)", "valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)"),
new TypeData("UInt32", "Int64", false, "static readonly UInt32 defaultValue = ", "UInt32.MinValue", TypeData.aggregateAll, "valueNo1.CompareTo(valueNo2)", "UInt32.MinValue", "UInt32.MaxValue", null, null, "!value.Equals(defaultValue)", "valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)"),
new TypeData("UInt64", "UInt64", false, "static readonly UInt64 defaultValue = ", "UInt64.MinValue", TypeData.aggregateAll, "valueNo1.CompareTo(valueNo2)", "UInt64.MinValue", "UInt64.MaxValue", null, null, "!value.Equals(defaultValue)", "valueNo1.Equals(defaultValue) || valueNo2.Equals(defaultValue)"),
////////////////////////////////////////////////
            };
        }

        internal void Generate(string dest, TypeData typeData) {
            Stream s = File.Create(dest + "\\" + typeData.FileName);
            TextWriter w = new StreamWriter(s);
            if(w == null) {
                s.Close();
                return;
            }

            WriteCommonBegin(typeData, w);
            if(typeData.aggregateBitMask != 0) {
                WriteAggregateMethod(typeData, w);
            }
            WriteCommonEnd(typeData, w);

            w.Flush();
            w.Close();
        }

        private void WriteCommonBegin(TypeData typeData, TextWriter w) {
            string[] header = new string[] {
/////////////////////////////////////////////
"//------------------------------------------------------------------------------",
"/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           ",
"///    Copyright (c) Microsoft Corporation. All Rights Reserved.                ",
"///    Information Contained Herein is Proprietary and Confidential.            ",
"/// </copyright>                                                                ",
"//------------------------------------------------------------------------------",
"",
"/******************************************************************/",
"/* This file is auto-generated by the StorageGenerator tool.      */",
"/* Please make any changes in that tool and regenerate the files. */",
"/******************************************************************/",
"namespace System.Data.Internal {",    
"",
"    using System;",
"",
///////////////////////////////////////////////
            };
            for (int i=0; i<header.Length; i++) {
                w.WriteLine(header[i]);
            }
            if(!typeData.CLSCompliant) {
                w.WriteLine("    [CLSCompliantAttribute(false)]");
            }

            string[] text = new string[] {
"    public class "+typeData.typeName+"Storage : DataStorage {",
"",
"        "+typeData.DefaultValue+";",
"        static private readonly Object defaultValueAsObject = defaultValue;",
"",
"        private "+typeData.typeName+"[] values;",
"",
"        public "+typeData.typeName+"Storage()",
"            : base(typeof("+typeData.typeName+")) {",
"        }",
"",
"        public override Object DefaultValue {",
"            get {",
"                return defaultValueAsObject;",
"            }",
"        }",
""
///////////////////////////////////////////////
            };
            for (int i=0; i<text.Length; i++) {
                w.WriteLine(text[i]);
            }
        }

        private void WriteAggregateMethod(TypeData typeData, TextWriter w) {
            string[] commonBeginText = new string[] {
/////////////////////////////////////////////
"        override public Object Aggregate(int[] records, AggregateType kind) {",
"            bool hasData = false;",
"            try {",
"            switch (kind) {"
/////////////////////////////////////////////
            };
            string[] caseSumText = new string[] {
/////////////////////////////////////////////
"                case AggregateType.Sum:",
"                    "+typeData.typeName+" sum = defaultValue;",
"                    foreach (int record in records) {",
"                        if(IsNull(record))",
"                            continue;",
"                        checked { sum += values[record]; }",
"                        hasData = true;",
"                    }",
"                    if(hasData) {",
"                        return sum;",
"                    }",
"                    return Convert.DBNull;",
""
///////////////////////////////////////////////////////
            };
            string[] caseMeanText = new string[] {
/////////////////////////////////////////////
"                case AggregateType.Mean:",
"                    "+typeData.sumTypeName+" meanSum = ("+typeData.sumTypeName+")defaultValue;",
"                    int"+" meanCount = 0;",
"                    foreach (int record in records) {",
"                        if(IsNull(record))",
"                            continue;",
"                        checked { meanSum += ("+typeData.sumTypeName+")values[record]; }",
"                        meanCount++;",
"                        hasData = true;",
"                    }",
"                    if(hasData) {",
"                        "+typeData.typeName+" mean;",
"                        checked {mean = ("+typeData.typeName+")(meanSum / meanCount);}",
"                        return mean;",
"                    }",
"                    return Convert.DBNull;",
""
///////////////////////////////////////////////////////
            };
            string[] caseVarStDevText = new string[] {
/////////////////////////////////////////////
"                case AggregateType.Var:",
"                case AggregateType.StDev:",
"                    int count = 0;",
"                    double"+" var = (double)defaultValue;",
"                    double"+" sqrtsum = (double)defaultValue;",
"                    double"+" dsum = (double)defaultValue;",
"                    foreach (int record in records) {",
"                        if(IsNull(record))",
"                            continue;",
"                        dsum += (double)values[record];",
"                        sqrtsum += (double)values[record] * (double)values[record];",
"                        count++;",
"                    }",
"                    if(count > 1) {",
"                        var = (count * sqrtsum - (double)(dsum * dsum)) / (count*(count-1));",
"                        if(kind == AggregateType.StDev) {",
"                            return Math.Sqrt(var);",
"                        }",
"                        return var;",
"                    }",
"                    return Convert.DBNull;",
""
///////////////////////////////////////////////////////
            };
            string[] caseMinText = new string[] {
///////////////////////////////////////////////////////
"                case AggregateType.Min:",
"                    "+typeData.typeName+" min = "+typeData.MaxValue+";",
"                    for (int i = 0; i < records.Length; i++) {",
"                        int record = records[i];",
"                        if(IsNull(record))",
"                            continue;",
"                        "+typeData.GetMin+";",
"                        hasData = true;",
"                    }",
"                    if(hasData) {",
"                        return min;",
"                    }",
"                    return Convert.DBNull;",
""
////////////////////////////////////////////////////////
            };
            string[] caseMaxText = new string[] {
////////////////////////////////////////////////////////
"                case AggregateType.Max:",
"                    "+typeData.typeName+" max = "+typeData.MinValue+";",
"                    for (int i = 0; i < records.Length; i++) {",
"                        int record = records[i];",
"                        if(IsNull(record))",
"                            continue;",
"                        "+typeData.GetMax+";",
"                        hasData = true;",
"                    }",
"                    if(hasData) {",
"                        return max;",
"                    }",
"                    return Convert.DBNull;",
""
////////////////////////////////////////////////////////
            };
            string[] caseFirstText = new string[] {
////////////////////////////////////////////////////////
"                case AggregateType.First:",
"                    if(records.Length > 0) {",
"                        return values[records[0]];",
"                    }",
"                    return null;",
""
////////////////////////////////////////////////////////
            };
            string[] caseCountText = new string[] {
////////////////////////////////////////////////////////
"                case AggregateType.Count:",
"                   return base.Aggregate(records, kind);",
""
////////////////////////////////////////////////////////
            };
            string[] commonEndText = new string[] {
////////////////////////////////////////////////////////
"            }",
"            }",
"            catch(OverflowException) {",
"                throw InvalidExpressionException.Overflow(typeof("+typeData.typeName+"));",
"            }",
"            throw DataException.AggregateException(kind, DataType);",
"        }",
""
///////////////////////////////////////////////
            };

            for (int i=0; i<commonBeginText.Length; i++) {
                w.WriteLine(commonBeginText[i]);
            }
            
            if((typeData.aggregateBitMask & TypeData.aggregateSumMean) != 0) {
                for (int i=0; i<caseSumText.Length; i++) {
                    w.WriteLine(caseSumText[i]);
                }
                for (int i=0; i<caseMeanText.Length; i++) {
                    w.WriteLine(caseMeanText[i]);
                }
                for (int i=0; i<caseVarStDevText.Length; i++) {
                    w.WriteLine(caseVarStDevText[i]);
                }
            }
            if((typeData.aggregateBitMask & TypeData.aggregateMin) != 0) {
                for (int i=0; i<caseMinText.Length; i++) {
                    w.WriteLine(caseMinText[i]);
                }
            }
            if((typeData.aggregateBitMask & TypeData.aggregateMax) != 0) {
                for (int i=0; i<caseMaxText.Length; i++) {
                    w.WriteLine(caseMaxText[i]);
                }
            }
            if((typeData.aggregateBitMask & TypeData.aggregateFirst) != 0) {
                for (int i=0; i<caseFirstText.Length; i++) {
                    w.WriteLine(caseFirstText[i]);
                }
            }

            for (int i=0; i<caseCountText.Length; i++) {
                w.WriteLine(caseCountText[i]);
            }
            for (int i=0; i<commonEndText.Length; i++) {
                w.WriteLine(commonEndText[i]);
            }
        }

        private void WriteCommonEnd(TypeData typeData, TextWriter w) {
            string[] text = new string[] {
////////////////////////////////////////////////////////
"        override public int Compare(int recordNo1, int recordNo2) {",
"            "+typeData.typeName+" valueNo1 = values[recordNo1];",
"            "+typeData.typeName+" valueNo2 = values[recordNo2];",
"",
"            if(" + typeData.CompareOptimization + ") {",
"                int bitCheck = CompareBits(recordNo1, recordNo2);",
"                if(0 != bitCheck)",
"                    return bitCheck;",
"            }",
"            return "+typeData.CompareString+";",
"        }",
"",
"        override public int CompareToValue(int recordNo, Object value) {",
"            bool recordNull = IsNull(recordNo);",
"",
"            if(recordNull && Convert.IsDBNull(value))",
"                return 0;",
"            if(recordNull)",
"                return -1;",
"            if(Convert.IsDBNull(value))",
"                return 1;",
"",
"            "+typeData.typeName+" valueNo1 = values[recordNo];",
"            "+typeData.typeName+" valueNo2 = ("+typeData.typeName+")value;",
"            return "+typeData.CompareString+";",
"        }",
"",
"        override public void Copy(int recordNo1, int recordNo2) {",
"            CopyBits(recordNo1, recordNo2);",
"            values[recordNo2] = values[recordNo1];",
"        }",
"",
"        override public Object Get(int record) {",
"            "+typeData.typeName+" value = values[record];",
"            if("+typeData.ValueNotEqaulToDefault+") {",
"                return value;",
"            }",
"            return GetBits(record);",
"        }",
"",
"        override public void Set(int record, Object value) {",
"            if(SetBits(record, value)) {",
"                values[record] = " +typeData.typeName+"Storage.defaultValue;",
"            }",
"            else {",
"                values[record] = Convert.To" +typeData.typeName+"(value);",
"            }",
"        }",
"",
"        override public void SetCapacity(int capacity) {",
"            "+typeData.typeName+"[] newValues = new "+typeData.typeName+"[capacity];",
"            if(null != values) {",
"                Array.Copy(values, 0, newValues, 0, Math.Min(capacity, values.Length));",
"            }",
"            values = newValues;",
"            base.SetCapacity(capacity);",
"        }",
"",
"        override public void ShiftByOffset(int index, int length, int offset) {",
"            if(index + offset + length > values.Length) {",
"                SetCapacity(Math.Max(index + offset + length, 2 * values.Length));",
"            }",
"            Array.Copy(values, index, values, index + offset, length);",
"        }",
"    }",
"}"
////////////////////////////////////////////////////////////
            };
            for (int i=0; i<text.Length; i++) {
                w.WriteLine(text[i]);
            }

        }
        /// <include file='doc\StorageGenerator.uex' path='docs/doc[@for="StorageGenerator.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(string[] args) {
            string target = Environment.GetEnvironmentVariable("STORAGESRC");
            if(target == null) {
                string dnaroot = Environment.GetEnvironmentVariable("DNAROOT");

                if(dnaroot == null) {
                    throw new Exception("Missing required envaironment 'DNAROOT'");
                }
                target = dnaroot + "\\src\\Data\\System\\Data\\Internal";
            }

            StorageGenerator generator = new StorageGenerator();
            Console.WriteLine("Generate storages, target dir: " + target);
            for (int i=0; i<generator.typeData.Length; i++) {
                Console.WriteLine(generator.typeData[i].TypeName);
                generator.Generate(target, generator.typeData[i]);
            }
        }

        internal class TypeData {
            internal static int aggregateSumMean = 1;
            internal static int aggregateMax = 2;
            internal static int aggregateMin = 4;
            internal static int aggregateFirst = 8;
            internal static int aggregateAll = 15;
            internal static int aggregateMaxMinFirst = 14;

            internal string typeName = "";
            internal string sumTypeName = "";
            internal bool CLSCompliant = true;
            internal int aggregateBitMask = 0;
            internal string defaultValue = null;
            internal string defaultValueString = null;
            internal string compareString = null;
            internal string minValueString = null;
            internal string maxValueString = null;
            internal string getMaxString = null;
            internal string getMinString = null;
            internal string valueNotEqaulToDefaultString = null;
            internal string compareOptimization = null;

            internal TypeData() {
            }

            internal TypeData(
                string typeName, string sumTypeName, bool CLSCompliant, string defaultValueDeclaration, string defaultValueString, int aggregateBitMask,
                string compareString, string minValueString, string maxValueString,
                string getMaxString, string getMinString, string valueNotEqaulToDefaultString, string compareOptimization)
            {
                this.typeName = typeName;
                this.sumTypeName = sumTypeName;
                this.CLSCompliant = CLSCompliant;
                this.defaultValue = defaultValueDeclaration + defaultValueString;
                this.defaultValueString = defaultValueString;
                this.aggregateBitMask = aggregateBitMask;
                this.compareString = compareString;
                this.minValueString = minValueString;
                this.maxValueString = maxValueString;
                this.getMinString = getMinString;
                this.getMaxString = getMaxString;
                this.valueNotEqaulToDefaultString = valueNotEqaulToDefaultString;
                this.compareOptimization = compareOptimization;
            }


            internal string CompareString {
                get {
                    if(compareString == null)
                        return "(valueNo1 > valueNo2 ? 1 : (valueNo1 == valueNo2 ? 0 : -1))";
                    else
                        return compareString;
                }
            }

            internal string DefaultValue {
                get {
                    if(defaultValue == null)
                        return "private const "+typeName+" defaultValue = ("+typeName+")0";
                    else 
                        return "private "+defaultValue;
                }
            }

            internal string FileName {
                get {
                    return typeName + "Storage.cs";
                }
            }

            internal string GetMin {
                get {
                    if(getMinString == null) {
                        return "min=Math.Min(values[record], min)";
                    }
                    return getMinString;
                }
            }

            internal string GetMax {
                get {
                    if(getMaxString == null) {
                        return "max=Math.Max(values[record], max)";
                    }
                    return getMaxString;
                }
            }

            internal string MinValue {
                get {
                    if(minValueString == null)
                        return "("+typeName+")0";
                    return minValueString;
                }
            }

            internal string MaxValue {
                get {
                    if(maxValueString == null)
                        return "("+typeName+")1";
                    return maxValueString;
                }
            }

            internal string TypeName {
                get {
                    return typeName;
                }
            }

            internal string ValueNotEqaulToDefault {
                get {
                    if(valueNotEqaulToDefaultString != null)
                        return valueNotEqaulToDefaultString;
                    else 
                        return "value != defaultValue";
                }
            }

            internal string CompareOptimization {
                get {
                    if(compareOptimization != null)
                        return compareOptimization;
                    else 
                        return "valueNo1 == defaultValue || valueNo2 == defaultValue";
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\mcsyntaxoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="MCSyntaxOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {
    
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Diagnostics;

    /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class MCSyntaxOutput : SyntaxOutput {

         // BL changes {{
         private string m_strClassName = "Foo";

         /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.GenerateOutput"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public override bool GenerateOutput( Type type )
         {
            base.GenerateOutput( type );

            // Get the class name
            m_strClassName = type.Name;
            return true;
         }
         // BL changes }}

        private void OutputTypeRef(string nameSpace, Type realType, string type) {
            OutputTypeRef(nameSpace, realType, type, true);
        }

        // BL changes {{
        private void OutputTypeRef(string nameSpace, Type realType, string type, bool appendSpace) 
        {
            if ( type.EndsWith( "[]" ) )
            {            
               OutputTypeRef( nameSpace, realType, type.Substring( 0, type.Length - 2 ), false );
               // Output( " []" );
               if ( appendSpace )
                  Output( " " );
               return;
            }

            if ( type.Equals( "System.Int64" ) )
               type = "__int64";
            else if ( type.Equals( "System.UInt64" ) )
               type = "unsigned __int64";
            else if ( type.Equals( "System.Int32" ) )
               type = "int";
            else if ( type.Equals( "System.UInt32" ) )
               type = "unsigned int";
            else if ( type.Equals( "System.Int16" ) )
               type = "short";
            else if ( type.Equals( "System.UInt16" ) )
               type = "unsigned short";
            else if ( type.Equals( "System.Byte" ) )
               type = "unsigned char";
            else if ( type.Equals( "System.SByte" ) )
               type = "char";
            else if ( type.Equals( "System.Single" ) )
               type = "float";
            else if ( type.Equals( "System.Double" ) )
               type = "double";
            else if ( type.Equals( "System.Void" ) )
               type = "void";
            else if ( type.Equals( "System.Char" ) )
               type = "wchar_t";
            else if ( type.Equals( "System.Boolean" ) )
               type = "bool";
            else if ( type.Equals( "System.String" ) )
               type = "String";
            else if ( type.Equals( "System.Object" ) )
               type = "Object";
            else                                 
                type = type.Substring( type.LastIndexOf( "." ) + 1 );
            
            Output( type.Replace( '$', '.' ) );

            if ( realType != null && realType != typeof(void))
            {
               if ( !( realType.IsValueType || realType.IsPrimitive || realType.IsEnum ) )
                  Output( "*" );
            }

            if ( appendSpace )
               Output( " " );
        }
        // BL changes }}

        /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.Language"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Language {
            get {
                return "C++";
            }
        }
                
        /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputTypeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputTypeDeclaration(TextWriter tw, string ns, string name, Type type, int attributes, Type baseType, Type[] implements, bool isDelegate, MethodInfo delegateInvoke) {
            textWriter = tw;

            if (isDelegate) {
                OutputDecorationOfType((attributes & (~((int)TypeAttributes.Sealed))), false, false);
               // BL changes {{
                Output( "__delegate " );
               // BL changes }}
                OutputTypeRef(ns, delegateInvoke.ReturnType, delegateInvoke.ReturnType.FullName);
                Output(name.Replace( '$', '.' ));
                Output("(");
                OutputParameters(ns, delegateInvoke.GetParameters());
                Output(");");
            }
            else {
                bool isStruct = baseType != null && baseType == typeof( System.ValueType );
                bool isEnum = baseType != null && baseType == typeof( System.Enum );
                
                OutputDecorationOfType(attributes, isStruct, isEnum);
                OutputTypeOfType(type);
                Output(name.Replace( '$', '.' ));

                bool outputColon = false;
                if (baseType != null && baseType != typeof(object) && !isStruct && !isEnum) {
                    outputColon = true;
                    Output(" : public ");
                    OutputTypeRef(ns, null, baseType.FullName, false);
                }

                for (int i=0; i<implements.Length; i++) {
                    if (!outputColon) {
                        Output(" : public ");
                        outputColon = true;
                    }
                    else {
                        Output(", ");
                    }
                    OutputTypeRef(ns, null, implements[i].FullName, false);
                }
            }

            textWriter = null;
        }

        /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputFieldDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputFieldDeclaration(TextWriter tw, string ns, FieldInfo fi, string name, string fieldTypeFullName, int attributes) {
            textWriter = tw;

            OutputDecorationOfField(attributes);
            OutputTypeRef(ns, fi.FieldType, fieldTypeFullName);
            Output(name);
           // BL changes {{
            if ( fieldTypeFullName.EndsWith( "[]" ) )
               Output( "[]" );
           // BL changes }}
            Output(";");

            textWriter = null;
        }

        /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputMethodDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputMethodDeclaration(TextWriter tw, string ns, MethodInfo fi, string name, string returnTypeFullName, int attributes, ParameterInfo[] parameters, bool isInterface) {
            textWriter = tw;

            if (isInterface)
                OutputDecorationOfMethod( fi, MethodAttributesNone, false );
            else
                OutputDecorationOfMethod(fi, MethodAttributesAll, false);

            OutputTypeRef(ns, fi.ReturnType, returnTypeFullName);
            Output(name);

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");
           // BL changes {{
            if ( returnTypeFullName.EndsWith( "[]" ) )
               Output( " []" );
           // BL changes }}
            Output(";");

            textWriter = null;
        }

        /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputConstructorDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputConstructorDeclaration(TextWriter tw, string ns, ConstructorInfo fi, string name, int attributes, ParameterInfo[] parameters) {
            textWriter = tw;

            OutputDecorationOfMethod(attributes, MethodAttributesAll, false, (fi.DeclaringType == fi.ReflectedType));
            Output(fi.ReflectedType.Name.Replace( '$', '.' ));

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");
            Output(";");

            textWriter = null;
        }

        // BL changes {{
         /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputPropertyDeclaration"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public override void OutputPropertyDeclaration( TextWriter tw, string ns, 
                                                         PropertyInfo pi, string name, 
                                                         string returnTypeFullName, int attributes, 
                                                         MethodInfo getter, MethodInfo setter, 
                                                         ParameterInfo[] parameters, bool isInterface )
         {
            textWriter = tw;

            bool bIndexed = ( parameters.Length > 0 );

          #if true
            // new discrete prop syntax for Managed Extensions for C++, requested by ASURT 20245
            if ( getter != null )
            {
               if ( isInterface )
                  OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesNone, true, ( pi.DeclaringType == pi.ReflectedType ) );
               else
                  OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesProperty, true, ( pi.DeclaringType == pi.ReflectedType ) );

               if ( ( getter.Attributes & MethodAttributes.Abstract ) != 0 )
               {
                  // BL changes {{
                   if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )                  
                  // BL changes }}
                  Output( "abstract " );
               }
               else if ( ( getter.Attributes & MethodAttributes.Virtual ) != 0 ) // && !overrided )
                  Output( "virtual " );

               OutputTypeRef( ns, getter.ReturnType, returnTypeFullName );
               Output( getter.Name );

               Output( "(" );
               OutputParameters( ns, getter.GetParameters() );
               Output( ")" );
               Output( ";" );
            }
            
            if ( setter != null ) 
            {
               if ( isInterface )
                  OutputDecorationOfMethod( (int)setter.Attributes, MethodAttributesNone, true, ( pi.DeclaringType == pi.ReflectedType ) );
               else
                  OutputDecorationOfMethod( (int)setter.Attributes, MethodAttributesProperty, true, ( pi.DeclaringType == pi.ReflectedType ) );

               // OutputTypeRef( ns, setter.ReturnType, returnTypeFullName );

               if ( ( setter.Attributes & MethodAttributes.Abstract ) != 0 )
               {
                  // BL changes {{
                  if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )                  
                  // BL changes }}
                  Output( "abstract " );
               }
               else if ( ( setter.Attributes & MethodAttributes.Virtual ) != 0 ) // && !overrided )
                  Output( "virtual " );
               Output( "void " );            
               Output( setter.Name );

               Output( "(" );
               OutputParameters( ns, setter.GetParameters(), false );
               Output( ")" );
               Output( ";" );
            }
         #else
            Debug.Assert( getter != null || setter != null, "invalid property declaration" );

            if ( getter != null )
            {
               if ( isInterface )
                  OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesNone, true, ( pi.DeclaringType == pi.ReflectedType ) );
               else
                  OutputDecorationOfMethod( (int)getter.Attributes, MethodAttributesProperty, true, ( pi.DeclaringType == pi.ReflectedType ) );
            }

            OutputTypeRef( (string)ns, pi.PropertyType, returnTypeFullName );
            Output( name );

            if ( parameters.Length > 0 )
            {
               Output( "[" );
               OutputParameters( ns, parameters );
               Output( "]" );
            }

            Output( " {" );

            if ( getter != null )
            {
               OutputDecorationOfMethod( getter, MethodAttributesAccessor, true );
               Output( "get;" );
            }

            if ( setter != null )
            {
               if ( getter != null )
                  Output( " " );

               OutputDecorationOfMethod( setter, MethodAttributesAccessor, true );
               Output( "set;" );
            }

            Output( "}" );
         #endif

            textWriter = null;
         }
        // BL changes }}

        // BL changes {{
         private void OutputParameters( string ns, ParameterInfo[] parameters, bool bName )
         {
            for ( int i = 0; i < parameters.Length; i++ )
            {
               if ( i > 0 )
                  Output( ", " );
               OutputParameter( ns, parameters[i], bName );
            }
         }
        // BL changes }}

        // BL changes {{
         private void OutputParameters( string ns, ParameterInfo[] parameters )
         {
            OutputParameters( ns, parameters, true );
         }
        // BL changes }}

        // BL changes {{         
         private void OutputParameter( string ns, ParameterInfo param, bool bName )
         {
            bName = ( bName || !param.Name.Equals( "value" ) );

            /*
            if ( param.IsOut )
               ; // Output( "__out " );
            else if ( param.ParameterType.IsByRef )
               Output( "__byref " );
            else
            */
            if ( param.IsIn )
               Output( "__in " );
            
            string strType = WFCGenUEGenerator.GetUnrefTypeName( param.ParameterType );
         
            if ( param.IsOut || param.ParameterType.IsByRef )   // Add the second "*"
            {
               OutputTypeRef( ns, param.ParameterType, strType, false );
               Output( "* " );
            }
            else
               OutputTypeRef( ns, param.ParameterType, strType, bName );
         
            if ( bName )
               Output( param.Name );

            if ( strType.EndsWith( "[]" ) )
               Output( "[]" );
         }
        // BL changes }}

        private void OutputDecorationOfMethod(int methodAttributes, int mask, bool isProperty, bool declaredOnCurrentType) {
            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("internal: ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*protected && internal*/ internal: ");
                        Output("internal: ");
                        break;
                    case MethodAttributes.FamORAssem:
                        // Output("/*protected || internal*/ internal: ");
                        Output("internal: ");
                        break;
                    case MethodAttributes.Public:
                        Output("public: ");
                        break;
                    case MethodAttributes.Private:
                        Output("private: ");
                        break;
                    case MethodAttributes.Family:
                        Output("protected: ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*private scope*/ private: ");
                        Output("private: ");
                        break;
                }

                if (isProperty) {
                    Output("__property ");
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("static ");
                }
            }

            bool overrided = false;

            int vtableLayout = methodAttributes & (int)MethodAttributes.VtableLayoutMask;
            switch ((MethodAttributes)vtableLayout) {
                case MethodAttributes.NewSlot:
                    if (!declaredOnCurrentType) {
                        Output("new ");
                    }
                    break;
                case MethodAttributes.ReuseSlot:
                    if (!declaredOnCurrentType) {
                        Output("override ");
                        overrided = true;
                    }
                    break;
            }

            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) 
                {
                  // BL changes {{
                   if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                     Output("abstract ");
                  // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("virtual ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                    // Output("/*lock*/ ");
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputDecorationOfMethod(MethodInfo mi, int mask, bool isProperty) {
            int methodAttributes = (int)mi.Attributes;
            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("internal: ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*protected && internal*/ internal: ");
                        Output("internal: ");
                        break;
                    case MethodAttributes.FamORAssem:
                        Output("protected public: ");
                        break;
                    case MethodAttributes.Public:
                        Output("public: ");
                        break;
                    case MethodAttributes.Private:
                        Output("private: ");
                        break;
                    case MethodAttributes.Family:
                        Output("protected: ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*private scope*/ private: ");
                        Output("private: ");
                        break;
                }

                if (isProperty) {
                    Output("__property ");
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("static ");
                }
            }

            bool overrided = false;

            int decl = MemberDecl.FromMethodInfo(mi);
            switch (decl) {
                case MemberDecl.Inherited:
                    // Output("/*inherited*/ ");
                    break;
                case MemberDecl.New:
                    Output("new ");
                    break;
                case MemberDecl.Override:
                    Output("override ");
                    overrided = true;
                    break;
                case MemberDecl.DeclaredOnType:
                    // nothing;
                    break;
            }



            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) 
                {
                  // BL changes {{
                   if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                     Output("abstract ");
                  // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("virtual ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                    // Output("/*lock*/ ");
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputTypeOfType(Type type) {
            int cls = (int) type.Attributes & (int)TypeAttributes.ClassSemanticsMask;

            if ((cls & (int)TypeAttributes.Interface) != 0) {
                Output("__interface ");
            }
            else if (type.BaseType == typeof( System.Enum )) {      
                Output("enum ");
            }                                        
            else if (type.BaseType == typeof( System.ValueType  )) {                
                Output("__value struct ");
            }                        
            else {
                Output("class ");
            }
        }

         private void OutputDecorationOfType( int typeAttributes, bool isStruct, bool isEnum )
         {
            int cls = typeAttributes & (int)TypeAttributes.ClassSemanticsMask;
                          
            if (isStruct) 
               Output( "__value " );

            if ( ( typeAttributes & (int)TypeAttributes.Public ) != 0 ||
                 ( typeAttributes & (int)TypeAttributes.NestedPublic ) != 0 )
               Output( "public " );

            if ( !isStruct && !isEnum )
               Output( "__gc " );

            if (( typeAttributes & (int)TypeAttributes.Sealed ) != 0)     
               Output( "__sealed " );
                        
            if ( ( typeAttributes & (int)TypeAttributes.Abstract ) != 0 &&
                 ( typeAttributes & (int)TypeAttributes.Interface ) == 0 )
               Output( "__abstract " );
         }

        private void OutputDecorationOfField(int fieldAttributes) {
            int access = fieldAttributes & (int)FieldAttributes.FieldAccessMask;
            switch ((FieldAttributes)access) {
                case FieldAttributes.Assembly:
                    Output("internal: ");
                    break;
                case FieldAttributes.FamANDAssem:
                    // Output("/*protected && internal*/ internal: ");
                    Output("internal: ");
                    break;
                case FieldAttributes.FamORAssem:
                    Output("protected public: ");
                    break;
                case FieldAttributes.Public:
                    Output("public: ");
                    break;
                case FieldAttributes.Private:
                    Output("private: ");
                    break;
                case FieldAttributes.Family:
                    Output("protected: ");
                    break;
                case FieldAttributes.PrivateScope:
                    // Output("/*private scope*/ private: ");
                    Output("private: ");
                    break;
            }

            if ((fieldAttributes & (int)FieldAttributes.Literal) != 0) {
                Output("const ");
            }
            else {
                if ((fieldAttributes & (int)FieldAttributes.Static) != 0) {
                    Output("static ");
                }
                if ((fieldAttributes & (int)FieldAttributes.InitOnly) != 0) {
                    Output("readonly ");
                }
            }
            if ((fieldAttributes & (int)FieldAttributes.NotSerialized) != 0) {
                Output("transient ");
            }

            if ((fieldAttributes & (int)FieldAttributes.PinvokeImpl) != 0) {
                Output("extern ");
            }
        }

         // BL changes {{
         /// <include file='doc\MCSyntaxOutput.uex' path='docs/doc[@for="MCSyntaxOutput.OutputOperatorDeclaration"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public override void OutputOperatorDeclaration( TextWriter tw, string ns, MethodInfo fi,
                                                         string strName, string returnTypeFullName,
                                                         int attributes, ParameterInfo[] parameters, bool isInterface )
         {
            textWriter = tw;
         
            if ( strName == "op_Explicit" || strName == "op_Implicit" )        // Conversion operators
            {                        
               string temp = returnTypeFullName.Substring( returnTypeFullName.LastIndexOf( "." ) + 1 );
               if ( temp == m_strClassName )
               {               
                  // syntax pattern:  public: static <return type> <CLS operator name>(<param type> <param name>);
                  // e.g. public: static Foo op_Explicit(int a);
                  Output( "public: static " );
                  OutputTypeRef( ns, fi.ReturnType, returnTypeFullName );
                  Output( strName );
                  Output( "(" );
                  OutputParameters( ns, parameters );
                  Output( ")" );
               }
               else
               {
                  // syntax pattern:  public: operator <return type>();
                  // e.g. public: operator int();
                  Output( "public: operator " );
                  OutputTypeRef( ns, fi.ReturnType, returnTypeFullName, false );
                  Output( "()" );
               }
            }   
            else if ( parameters.Length > 0 && parameters.Length < 3 )     // Unary and binary operators
            {
               if ( isInterface )
                  OutputDecorationOfMethod( fi, MethodAttributesNone, false );
               else
                  OutputDecorationOfMethod( fi, MethodAttributesAll, false );
   
               if ( returnTypeFullName != "System.Void" )
                  OutputTypeRef( ns, fi.ReturnType, returnTypeFullName );            

               Output( "operator " );
               Output( strName );            

               Output( "(" );
               OutputParameters( ns, parameters );
               Output( ")" );
            }         
            else                                   // What's that?
            {
               Debug.Assert( true, "Wrong number of parameters in the operator method" );      
            }                     
         
            Output( ";" );
            textWriter = null;
         }
         // BL changes }}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\vsdesignerreg\vsdesignerreg.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSDesignerReg.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Tools.VSDesignerReg {
    using System.Text;
    using System.Threading;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Globalization;
    using System.IO;
    using System.Reflection;

    //
    /// <include file='doc\VSDesignerReg.uex' path='docs/doc[@for="VSDesignerReg"]/*' />
    /// <devdoc>
    ///      Visual Studio registration code for the VS forms designer.
    ///      This code is a small substitution engine for the VSDesigner.VRG
    ///      file.  This VRG file is the actual setup file that is used by
    ///      the Darwin setup installer.  This EXE is only used during vsreg
    ///      to run the .VRG file.  If you need to make changes to registration,
    ///      update the .VRG file.
    ///
    ///      DO NOT ADD REGISTRY CODE TO THIS FILE!  THIS FILE DOES NOT
    ///      GET INSTALLED BY SETUP.
    /// </devdoc>
    public sealed class VSDesignerReg {
    
        private const string usage = "Usage:\r\n\r\nVSDesignerReg [/root <registry root>] [/vrg <vrg file>] [/path <path to components>]\r\n";
    
        private static string registryRoot = null;
        private static string componentPath = null;
        private static string vrgFile = "VSDesigner.VRG";
    
        /// <include file='doc\VSDesignerReg.uex' path='docs/doc[@for="VSDesignerReg.ConvertSlashes"]/*' />
        /// <devdoc>
        ///      Converts all single slashes to double.
        /// </devdoc>
        private static string ConvertSlashes(string s) {
            StringBuilder b = new StringBuilder(s);
            
            int i = 0;
            
            while(i < b.Length) {
                if (b[i] == '\\') {
                    b.Insert(i, '\\');
                    i++;
                }
                i++;
            }
            
            return b.ToString();
        }

        private static string DoReplace(string search, string replace, string data) {
            StringBuilder sb = new StringBuilder(data);
            sb.Replace(search, replace);
            return sb.ToString();
        }
        
        /// <include file='doc\VSDesignerReg.uex' path='docs/doc[@for="VSDesignerReg.Exec"]/*' />
        /// <devdoc>
        ///     Executes the given command line and waits for it to finish.
        /// </devdoc>
        private static void Exec(string dir, string cmd, string parameters) {
            Process proc = new Process();
            proc.StartInfo.Arguments = parameters;
            proc.StartInfo.FileName = cmd;
            proc.StartInfo.WorkingDirectory = dir;            

            proc.Start();
            while (!proc.HasExited) {
                Thread.Sleep(100);
            }
        }
        
        /// <include file='doc\VSDesignerReg.uex' path='docs/doc[@for="VSDesignerReg.Main"]/*' />
        /// <devdoc>
        ///      Program entrypoint.
        /// </devdoc>
        public static void Main(string[] args) {
        
            try {
                ProcessCommandLine(args);
                
                // If we weren't provided a component path, try to resolve one based on 
                // Microsoft.VisualStudio.dll
                //
                if (componentPath == null) {
                    try {
                        Assembly a = Assembly.Load(AssemblyRef.MicrosoftVisualStudio);
                        if (a != null) {
                            Uri u = new Uri(a.EscapedCodeBase);
                            string p = u.LocalPath;
                            componentPath = Path.GetDirectoryName(p);
                        }
                    }
                    catch {
                    }
                }
                
                if (componentPath == null) {
                    throw new Exception("Unable to locate Microsoft.VisualStudio assembly, and no component path specified with /path.  Unable to register.");
                }
                
                string filePath = Path.GetDirectoryName(typeof(VSDesignerReg).Module.FullyQualifiedName);
                string fileName = Path.Combine(filePath, vrgFile);
                
                Stream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                
                int byteCount = (int)fileStream.Length;
                byte[] bytes = new byte[byteCount];
                fileStream.Read(bytes, 0, byteCount);
                string regData = Encoding.Default.GetString(bytes);
                fileStream.Close();
                
                // We build up a set of replacement hashtable strings
                //
                string eePath = "mscoree.dll";

                try {
                    ProcessModuleCollection modules = Process.GetCurrentProcess().Modules;
                    foreach (ProcessModule m in ((IEnumerable)modules)) {
                        if (m.ModuleName.Equals("mscoree.dll")) {
                            eePath = Path.Combine(Path.GetDirectoryName(m.FileName), "mscoree.dll");
                            break;
                        }
                    }
                }
                catch (Exception) {
                }

                regData = DoReplace("[SystemFolder]mscoree.dll", ConvertSlashes(eePath), regData);
                regData = DoReplace("VSREG 7", "REGEDIT4", regData);
                regData = DoReplace("VSREG7", "REGEDIT4", regData);
                regData = DoReplace("[SystemFolder]", ConvertSlashes(componentPath) + "\\\\", regData);
                regData = DoReplace("[$ComponentPath]", ConvertSlashes(componentPath) + "\\\\", regData);
                regData = DoReplace("[Designer.3643236F_FC70_11D3_A536_0090278A1BB8]", ConvertSlashes(componentPath) + "\\\\", regData);
                regData = DoReplace("[CommonIDE.3643236F_FC70_11D3_A536_0090278A1BB8]", ConvertSlashes(componentPath) + "\\\\", regData);
                
                if (registryRoot != null) {
                    regData = DoReplace("SOFTWARE\\Microsoft\\VisualStudio\\7.1", registryRoot, regData);
                }
                
                // Now output the massaged registry info to a temporary file.
                //
                StringBuilder tempBuilder = new StringBuilder(512);
                GetTempFileName(filePath, "VSDesignerReg", 0, tempBuilder);
                string tempFile = tempBuilder.ToString();
                
                byte[] bytesToWrite = Encoding.Default.GetBytes(regData);
                fileStream = File.Create(tempFile);
                fileStream.Write(bytesToWrite, 0, bytesToWrite.Length);
                fileStream.Close();
                
                // And spawn regedit to party on the file.
                //
                Exec(filePath, "regedit.exe", "/s \"" + tempFile + "\"");
                File.Delete(tempFile);
                
                if (registryRoot == null) {
                    registryRoot = "Default Root";
                }
                
                Console.WriteLine("Registration data for " + vrgFile + " successfully entered into the registry at root '" + registryRoot + "'.");
            }
            catch(CommandException ce) {
                Console.Error.WriteLine(ce.Message);
            }
            catch(Exception e) {
                string message = e.Message;
                if (message == null || message.Length == 0) {
                    message = e.ToString();
                }
                Console.Error.WriteLine("Registration of " + vrgFile + " failed with the following error:\r\n" + message);
            }
        }
        
        private static void ProcessCommandLine(string[] args) {
            if (args == null) {
                return;
            }
            
            for (int i = 0; i < args.Length; i++) {
                char ch = args[i][0];
                
                if (ch == '/' || ch == '-') {
                    string option = args[i].Substring(1);
                    if (String.Compare(option, "root", true, CultureInfo.InvariantCulture) == 0) {
                        i++;
                        if (i >= args.Length) {
                            throw new CommandException("Missing parameter.\r\n" + usage);
                        }
                        registryRoot = args[i];
                    }
                    else if (String.Compare(option, "?", true, CultureInfo.InvariantCulture) == 0 || String.Compare(option, "help", true, CultureInfo.InvariantCulture) == 0) {
                        throw new CommandException(usage);
                    }
                    else if (String.Compare(option, "vrg", true, CultureInfo.InvariantCulture) == 0) {
                        i++;
                        if (i >= args.Length) {
                            throw new CommandException("Missing parameter.\r\n" + usage);
                        }
                        vrgFile = args[i];
                    }
                    else if (String.Compare(option, "path", true, CultureInfo.InvariantCulture) == 0) {
                        i++;
                        if (i >= args.Length) {
                            throw new CommandException("Missing parameter.\r\n" + usage);
                        }
                        componentPath = args[i];
                    }
                    else {
                        throw new CommandException("Unknown option '" + option + "'.\r\n" + usage);
                    }
                }
                else {
                    throw new CommandException(usage);
                }
            }
        }
        
        private class CommandException : Exception {
            public CommandException(string text) : base(text) {
            }
        }
        
        [System.Runtime.InteropServices.DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int GetTempFileName(String lpPathName, String lpPrefixString, int uUnique, StringBuilder lpTempFileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcversion\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\docloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

    using System;
    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Diagnostics;

    // knows how to open and scan a .csx (c# compiler doc output) file
    class DocLoader {
        ArrayList  list = null;
        
        public DocLoader() {
            list = new ArrayList();
        }
        
        // call this to add a csx file to the list
        public void AddStream( string name ) {
            FileStream  stream = null;
            TextReader  reader = null;
            string      line = null;
        
            Console.WriteLine(" loading CSX file '" + name + "'" );
            
            try {
                stream = new FileStream( name, FileMode.Open, FileAccess.Read );
                if (stream != null) {
                    reader = new StreamReader( stream );
                }
                
                line = reader.ReadLine();
            }
            catch (FileNotFoundException) {
                Console.Error.WriteLine( "file '" + name + "' not found" );
            }
            catch (Exception ex) {
                Console.Error.WriteLine( "error opening/reading file '" + name + "': " + ex.ToString() );
            }
            
            try {
                while (line != null) {
                    if (line.IndexOf( "<member name=" ) != -1) {
                        CommentEntry ce = new CommentEntry( reader, line );
                        list.Add( ce );
                    }
                    
                    line = reader.ReadLine();
                }
            }
            catch (Exception e) {
                Console.Error.WriteLine( "loadlist failed reading from file, " + e.ToString() );
            }
        }

        // add brackets to the type if it's an array
        private void AppendArrayBrackets( StringBuilder sb, Type cls ) {
            while (cls.IsArray && cls != typeof(Array)) {
                cls = cls.GetElementType();
                sb.Append("[]");
            }
        }

        // add the parameter type decls to the string
        private void AppendParameters( StringBuilder sb, ParameterInfo[] pi ) {
            // if there are any parms...
            if (pi.Length != 0) {
                sb.Append("(");
                
                // for each one...
                for (int i = 0; i < pi.Length; i++) {
                    // setup the proper spacing and/or separation
                    if (i != 0)
                        sb.Append(",");

                    AppendTypeName( sb, pi[i].ParameterType, pi[i].ParameterType.IsByRef );
                }
                sb.Append(")");
            }
        }
        
        // add a type name (normalized for ref types, etc) to the string
        private void AppendTypeName( StringBuilder sb, Type cls, bool isByRef ) {
            Type basetype = GetUnderlyingType(cls);
            string name = ConvertNestedTypeName( basetype.FullName );
            
            // in order to match the tags in the CSX format, ref types must have
            // a trailing '@' instead of an ampersand
            if (isByRef && name.EndsWith( "&" )) {
                name = name.Substring( 0, name.Length - 1 ) + "@";
            }       
            sb.Append( name );
            AppendArrayBrackets(sb, cls);
        }
        
        // encode a field decl to match the csx tag
        public string EncodeField( FieldInfo field ) {
            return "F:" + field.ReflectedType.FullName + "." + field.Name;
        }
               
        // encode a method decl to match the csx tag 
        public string EncodeMethod( MethodBase method ) {
            string name = method.Name;
            
            if (name.Equals( ".ctor" ))
                name = "#ctor";
                
            StringBuilder sb = new StringBuilder();
            sb.Append( "M:" );
            sb.Append( method.ReflectedType.FullName );
            sb.Append( "." );
            sb.Append( name );
            AppendParameters( sb, method.GetParameters() );
            
            return sb.ToString();
        }
        
        // encode a property decl to match the csx tag
        public string EncodeProperty( PropertyInfo prop ) {
            ParameterInfo[] parms = prop.GetIndexParameters();
            
            if (parms != null && parms.Length != 0) {
                StringBuilder sb = new StringBuilder();
                sb.Append( "P:" );
                sb.Append( prop.ReflectedType.FullName );
                sb.Append( "." );
                sb.Append( prop.Name );
                AppendParameters( sb, parms );
                return sb.ToString();
            }
            else
                return "P:" + prop.ReflectedType.FullName + "." + prop.Name;
        }
        
        // encode a type decl to match the csx tag
        public string EncodeType( Type type ) {
            return "T:" + ConvertNestedTypeName( type.FullName );
        }
        
        private string ConvertNestedTypeName( string name ) {
            return name.Replace( '$', '.' );
        }
        
        // search the list for the matching tag
        public CommentEntry FindEncodedMember( string name ) {
            // CONSIDER:  order the list??? and make this way faster with something
            // other than a linear search.  duh.
            foreach (CommentEntry ce in list ) {
                if (ce.Tag.Equals( name )) {
                    return ce;
                }
            }
            
            return null;
        }
        
        // find a field in the list
        public CommentEntry FindField( FieldInfo field ) {
            return FindEncodedMember( EncodeField( field ) );
        }
        
        // find a method in the list
        public CommentEntry FindMethod( MethodBase method ) {
            return FindEncodedMember( EncodeMethod( method ) );
        }
        
        // find a property in the list
        public CommentEntry FindProperty( PropertyInfo prop ) {
            return FindEncodedMember( EncodeProperty( prop ) );
        }
        
        // find a type in the list
        public CommentEntry FindType( Type type ) {
            return FindEncodedMember( EncodeType( type ) );
        }
        
        // get the element type of an array
        private Type GetUnderlyingType(Type cls) {
            while (cls.IsArray && cls != typeof(Array)) {
                cls = cls.GetElementType();
            }
            return cls;
        }
    }

    // a little class to provide access to the comment block of a csx file    
    /// <include file='doc\DocLoader.uex' path='docs/doc[@for="CommentEntry"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CommentEntry {
        private string  comment = null;
        private string  tag = null;
        
        /// <include file='doc\DocLoader.uex' path='docs/doc[@for="CommentEntry.CommentEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CommentEntry( TextReader reader, string line ) {
            int pos = line.IndexOf( "name=\"" );
            int endpos = line.LastIndexOf( "\"" );
            tag = line.Substring( pos + 6, endpos - (pos + 6) );
        
            StringBuilder sbldr = new StringBuilder();
            sbldr.Append( line );
            sbldr.Append( "\r\n" );
            
            string s = reader.ReadLine();
            
            while (s.IndexOf( "</member>" ) == -1) {
                sbldr.Append( s );
                sbldr.Append( "\r\n" );
                s = reader.ReadLine();
            }
            
            sbldr.Append( s );
            sbldr.Append( "\r\n" );
            comment = sbldr.ToString();
        }
        
        /// <include file='doc\DocLoader.uex' path='docs/doc[@for="CommentEntry.Comment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Comment {
            get {
                return comment;
            }
        }
        
        /// <include file='doc\DocLoader.uex' path='docs/doc[@for="CommentEntry.Tag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Tag {
            get {
                return tag;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\vsinterfaces\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\vslangproj\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\memberdecl.cs ===
//------------------------------------------------------------------------------
// <copyright file="MemberDecl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

    using System.Diagnostics;
    using System;
    using System.Reflection;

    class MemberDecl {
        public const int Inherited = 1;
        public const int Override = 2;
        public const int New = 3;
        public const int DeclaredOnType = 4;

        public static int FromMethodInfo(MethodBase mi) {
            Type declared = mi.DeclaringType;
            Type reflected = mi.ReflectedType;

            if (declared != reflected) {
                return MemberDecl.Inherited;
            }
            else {
                if ((mi.Attributes & MethodAttributes.NewSlot) == MethodAttributes.NewSlot) {
                    return MemberDecl.DeclaredOnType;
                }
                else {
                    // no good way to find a "new virtual" but that is truely wierd!
                    //
                    if ((mi.Attributes & MethodAttributes.Virtual) == MethodAttributes.Virtual) {
                        return MemberDecl.Override;
                    }
                    else {
                        bool match = false;

                        if (reflected != typeof(object)) {
                            Type current = reflected.BaseType;
                            ParameterInfo[] parameters = mi.GetParameters();
                            Type[] paramTypes = new Type[parameters.Length];
                            string methodName = mi.Name;
                            for (int i=0; i<parameters.Length; i++) {
                                paramTypes[i] = parameters[i].ParameterType;
                            }

                            do {
                                if (current.GetMethod(methodName, paramTypes) != null) {
                                    match = true;
                                    break;
                                }
                                if (current == typeof(object)) {
                                    current = null;
                                }
                                else {
                                    current = current.BaseType;
                                }
                            } while ( current != null );
                        }

                        if (match) {
                            return MemberDecl.New;
                        }
                        else {
                            return MemberDecl.DeclaredOnType;
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\syntaxoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="SyntaxOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

   using System.Diagnostics;

   using System;
   using System.IO;
   // BL changes begin
   using System.Text;
   // BL changes end
   using System.Windows.Forms;
   using System.Collections;   
   using System.Reflection;   

   /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public abstract class SyntaxOutput {
     // BL changes {{
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.m_type"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      protected Type m_type = null;
     // BL changes }}
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.MethodAttributesProperty"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public const int MethodAttributesProperty = 0x01;
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.MethodAttributesAccessor"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public const int MethodAttributesAccessor = 0x02;
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.MethodAttributesAll"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public const int MethodAttributesAll = MethodAttributesProperty | MethodAttributesAccessor;
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.MethodAttributesNone"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public const int MethodAttributesNone = 0;

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.textWriter"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public TextWriter textWriter = null;            

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.Output"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public void Output( string s )
      {
         if ( textWriter != null )
            textWriter.Write( s );
      }

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.Language"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract string Language { get; }  

      // BL changes {{
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.GenerateOutput"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public virtual bool GenerateOutput( Type type )
      {
         m_type = type;
         return true;
      }
      // BL changes }}

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.GenerateOutput1"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public virtual bool GenerateOutput( string name )
      {
         return true;
      }      
      
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.GetOperatorSymbol"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public static string GetOperatorSymbol( string strName )
      {
         string str = "Unknown";         
         if ( strName == "op_Increment" )
            str = "++";
         else if ( strName == "op_Decrement" )
            str = "--";
         else if ( strName == "op_Negation" )
            str = "!";
         else if ( strName == "op_UnaryPlus" )
            str = "+";
         else if ( strName == "op_UnaryNegation" )
            str = "-";
         else if ( strName == "op_Addition" )
            str = "+";
         else if ( strName == "op_Subtraction" )
            str = "-";
         else if ( strName == "op_Multiply" )
            str = "*";
         else if ( strName == "op_Division" )
            str = "/";
         else if ( strName == "op_Modulus" )
            str = "%";
         else if ( strName == "op_ExclusiveOr" )
            str = "^";
         else if ( strName == "op_BitwiseAnd" )
            str = "&";
         else if ( strName == "op_BitwiseOr" )
            str = "|";
         else if ( strName == "op_LogicalAnd" )
            str = "&&";
         else if ( strName == "op_LogicalOr" )
            str = "||";
         else if ( strName == "op_Assign" )
            str = "=";
         else if ( strName == "op_Equality" )
            str = "==";
         else if ( strName == "op_Inequality" )
            str = "!=";
         else if ( strName == "op_GreaterThan" )
            str = ">";
         else if ( strName == "op_LessThan" )
            str = "<";
         else if ( strName == "op_GreaterThanOrEqual" )
            str = ">=";
         else if ( strName == "op_LessThanOrEqual" )
            str = "<=";
         else if ( strName == "op_LeftShift" )
            str = "<<";
         else if ( strName == "op_RightShift" )
            str = ">>";

         StringBuilder temp = new StringBuilder( str );
         temp.Replace( "&", "&#38;" );
         temp.Replace( ">", "&gt;" );
         temp.Replace( "<", "&lt;" );
         
         return temp.ToString();
      }

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputOperatorDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public virtual void OutputOperatorDeclaration( TextWriter tw, string ns, MethodInfo fi, string name, string returnTypeFullName, int attributes, ParameterInfo[] parameters, bool isInterface ) 
      { 
      }
      // BL changes }}

      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputTypeDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract void OutputTypeDeclaration( TextWriter tw, string ns, string name, Type type, int attributes, Type baseType, Type[] implements, bool isDelegate, MethodInfo delegateInvoke );
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputFieldDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract void OutputFieldDeclaration( TextWriter tw, string ns, FieldInfo fi, string name, string fieldTypeFullName, int attributes );
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputMethodDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract void OutputMethodDeclaration( TextWriter tw, string ns, MethodInfo fi, string name, string returnTypeFullName, int attributes, ParameterInfo[] parameters, bool isInterface );
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputConstructorDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract void OutputConstructorDeclaration( TextWriter tw, string ns, ConstructorInfo fi, string name, int attributes, ParameterInfo[] parameters );
      /// <include file='doc\SyntaxOutput.uex' path='docs/doc[@for="SyntaxOutput.OutputPropertyDeclaration"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      public abstract void OutputPropertyDeclaration( TextWriter tw, string ns, PropertyInfo pi, string name, string returnTypeFullName, int attributes, MethodInfo getter, MethodInfo setter, ParameterInfo[] parameters, bool isInterface );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\visualbasicsyntaxoutput.cs ===
//------------------------------------------------------------------------------
// <copyright file="VisualBasicSyntaxOutput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Diagnostics;

    /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class VisualBasicSyntaxOutput : SyntaxOutput {
        
        private void OutputTypeRef(string nameSpace, string type) {
            OutputTypeRef(nameSpace, type, true);
        }

        private void OutputTypeRefParens(string nameSpace, string type) {
            if (type.EndsWith("[]")) {
                Output("()");
                OutputTypeRefParens(nameSpace, type.Substring(0, type.Length - 2));
            }
        }

        private void OutputTypeRef(string nameSpace, string type, bool appendSpace) {
            if (type.EndsWith("[]")) {
                OutputTypeRef(nameSpace, type.Substring(0, type.Length - 2), false);
                if (appendSpace) {
                    Output(" ");
                }
                return;
            }

            if (type.Equals("System.Int64")) {
                type = "Long";
            }
            else if (type.Equals("System.Int32")) {
                type = "Integer";
            }
            else if (type.Equals("System.Int16")) {
                type = "Short";
            }
            else if (type.Equals("System.Byte")) {
                type = "Byte";
            }
            else if (type.Equals("System.Single")) {
                type = "Single";
            }
            else if (type.Equals("System.Double")) {
                type = "Double";
            }
            else if (type.Equals("System.Void")) {
                type = "Void";
            }
            else if (type.Equals("System.Char")) {
                type = "Char";
            }
            else if (type.Equals("System.Boolean")) {
                type = "Boolean";
            }
            else if (type.Equals("System.Variant")) {
                type = "Variant";
            }
            else if (type.Equals("System.String")) {
                type = "String";
            }
            else if (type.Equals("System.Object")) {
                type = "Object";
            }
            /*
            UE Change - don't generate correct code, rather always only show the name

            else if (type.StartsWith(nameSpace)) {
                type = type.Substring(nameSpace.Length + 1);
            }
            */
            else {
                type = type.Substring(type.LastIndexOf(".") + 1);
            }
            Output(type.Replace( '$', '.' ));
            if (appendSpace) {
                Output(" ");
            }
        }

        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.Language"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Language {
            get {
                return "VB";
            }
        }
        
        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.OutputTypeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputTypeDeclaration(TextWriter tw, string ns, string name, Type type, int attributes, Type baseType, Type[] implements, bool isDelegate, MethodInfo delegateInvoke) {
            textWriter = tw;

            if (isDelegate) {
                OutputDecorationOfType((attributes & (~((int)TypeAttributes.Sealed))));
                Output("Delegate Sub ");
                Output(name.Replace( '$', '.' ));
                Output("(");
                OutputParameters(ns, delegateInvoke.GetParameters());
                Output(")");

                if (delegateInvoke.ReturnType != typeof(void)) {
                    Output(" As ");
                    OutputTypeRef(ns, delegateInvoke.ReturnType.FullName);
                }
            }
            else {
                OutputDecorationOfType(attributes);
                OutputTypeOfType(type);
                Output(name.Replace( '$', '.' ));

                bool needSpace = true;
                if (baseType != null && baseType != typeof(object) && baseType != typeof( System.Enum ) && baseType != typeof( System.ValueType )) {
                    Output(" Inherits ");
                    OutputTypeRef(ns, baseType.FullName);
                    needSpace = false;
                }

                if (implements.Length > 0) {
                    if (needSpace) {
                        Output(" ");
                    }
                    Output("Implements ");
                }

                bool outputComma = false;
                for (int i=0; i<implements.Length; i++) {
                    if (outputComma) {
                        Output(", ");
                    }
                    outputComma = true;
                    OutputTypeRef(ns, implements[i].FullName, false);
                }
            }

            textWriter = null;
        }

        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.OutputFieldDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputFieldDeclaration(TextWriter tw, string ns, FieldInfo fi, string name, string fieldTypeFullName, int attributes) {
            textWriter = tw;

            OutputDecorationOfField(attributes);
            Output(name);
            OutputTypeRefParens(ns, fieldTypeFullName);
            Output(" As ");
            OutputTypeRef(ns, fieldTypeFullName, false);

            textWriter = null;
        }

        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.OutputMethodDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputMethodDeclaration(TextWriter tw, string ns, MethodInfo fi, string name, string returnTypeFullName, int attributes, ParameterInfo[] parameters, bool isInterface) {
            textWriter = tw;

            if (isInterface)
                OutputDecorationOfMethod(fi, MethodAttributesNone);
            else
                OutputDecorationOfMethod(fi, MethodAttributesAll);

            if (returnTypeFullName.Equals("System.Void")) {
                Output("Sub ");
            }
            else {
                Output("Function ");
            }
            Output(name);

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");

            if (!returnTypeFullName.Equals("System.Void")) {
                Output(" As ");
                OutputTypeRef(ns, returnTypeFullName);
                OutputTypeRefParens(ns, returnTypeFullName);
            }

            textWriter = null;
        }

        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.OutputConstructorDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputConstructorDeclaration(TextWriter tw, string ns, ConstructorInfo fi, string name, int attributes, ParameterInfo[] parameters) {
            textWriter = tw;

            OutputDecorationOfMethod(attributes, MethodAttributesAll, (fi.DeclaringType == fi.ReflectedType));
            Output("Sub New");

            Output("(");
            OutputParameters(ns, parameters);
            Output(")");

            textWriter = null;
        }

        /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.OutputPropertyDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void OutputPropertyDeclaration(TextWriter tw, string ns, PropertyInfo pi, string name, string returnTypeFullName, int attributes, MethodInfo getter, MethodInfo setter, ParameterInfo[] parameters, bool isInterface) {
            textWriter = tw;

            Debug.Assert(getter != null || setter != null, "invalid property declaration");

            if (getter != null) {
                if (isInterface)
                    OutputDecorationOfMethod((int)getter.Attributes, MethodAttributesNone, (pi.DeclaringType == pi.ReflectedType));
                else
                    OutputDecorationOfMethod((int)getter.Attributes, MethodAttributesProperty, (pi.DeclaringType == pi.ReflectedType));
            }

            // all indexed properties are 'Default' for our purposes.
            if (parameters.Length > 0) {
                Output("Default ");
            }

            if (setter == null)
                Output( "ReadOnly " );
                
            Output("Property ");

            Output(name);

            if (parameters.Length > 0) {
                Output("(");
                OutputParameters(ns, parameters);
                Output(")");
            }

            Output(" As ");

            OutputTypeRef((string)ns, returnTypeFullName);
            OutputTypeRefParens(ns, returnTypeFullName);

            // Output(" : ");
            // 
            // if (getter != null) {
            //     OutputDecorationOfMethod(getter, MethodAttributesAccessor);
            //     Output("Get");
            // }
            // if (setter != null) {
            //     if (getter != null) {
            //         Output(" : ");
            //     }
            //     OutputDecorationOfMethod(setter, MethodAttributesAccessor);
            //     Output("Set");
            // }

            textWriter = null;
        }

        private void OutputParameters(string ns, ParameterInfo[] parameters) {
            for (int i=0; i<parameters.Length; i++) {
                if (i > 0) {
                    Output(", ");
                }
                OutputParameter(ns, parameters[i]);
            }
        }

        private void OutputParameter(string ns, ParameterInfo param) {
            string paramTypeFullName = WFCGenUEGenerator.GetUnrefTypeName( param.ParameterType );
            if (param.ParameterType.IsByRef) {
                Output("ByRef ");
            }
            else {
                Output("ByVal ");
            }

            Output(param.Name);
            OutputTypeRefParens(ns, paramTypeFullName);
            Output(" As ");
            OutputTypeRef(ns, paramTypeFullName, false);
        }

        private void OutputDecorationOfMethod(int methodAttributes, int mask, bool declaredOnCurrentType) {
            bool overrided = false;

            int vtableLayout = methodAttributes & (int)MethodAttributes.VtableLayoutMask;
            switch ((MethodAttributes)vtableLayout) {
                case MethodAttributes.NewSlot:
                    if (!declaredOnCurrentType) {
                        Output("Shadows ");
                    }
                    break;
                case MethodAttributes.ReuseSlot:
                    if (!declaredOnCurrentType) {
                        Output("Overrides ");
                        overrided = true;
                    }
                    break;
            }

            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("Dim ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*Protected && Internal*/ Dim ");
                        Output("Dim ");
                        break;
                    case MethodAttributes.FamORAssem:
                        Output("Protected Friend Dim ");
                        break;
                    case MethodAttributes.Public:
                        Output("Public ");
                        break;
                    case MethodAttributes.Private:
                        Output("Private ");
                        break;
                    case MethodAttributes.Family:
                        Output("Protected ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*Private scope*/ Private ");
                        Output("Private ");
                        break;
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("Shared ");
                }
            }

            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) 
                {
                  // BL changes {{
                  if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                     Output("MustOverride ");
                  // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("Overridable ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                    //Output("Locked ");

                    // nothing
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputDecorationOfMethod(MethodInfo mi, int mask) {
            int methodAttributes = (int)mi.Attributes;
            bool overrided = false;

            int decl = MemberDecl.FromMethodInfo(mi);
            switch (decl) {
                case MemberDecl.Inherited:
                    // nothing
                    break;
                case MemberDecl.New:
                    Output("Shadows ");
                    break;
                case MemberDecl.Override:
                    Output("Overrides ");
                    overrided = true;
                    break;
                case MemberDecl.DeclaredOnType:
                    // nothing;
                    break;
            }

            if ((mask & MethodAttributesProperty) != 0) {
                int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
                switch ((MethodAttributes)access) {
                    case MethodAttributes.Assembly:
                        Output("Dim ");
                        break;
                    case MethodAttributes.FamANDAssem:
                        // Output("/*Protected && Internal*/ Dim ");
                        Output("Dim ");
                        break;
                    case MethodAttributes.FamORAssem:
                        Output("Protected Friend Dim ");
                        break;
                    case MethodAttributes.Public:
                        Output("Public ");
                        break;
                    case MethodAttributes.Private:
                        Output("Private ");
                        break;
                    case MethodAttributes.Family:
                        Output("Protected ");
                        break;
                    case MethodAttributes.PrivateScope:
                        // Output("/*Private scope*/ Private ");
                        Output("Private ");
                        break;
                }

                if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                    Output("Shared ");
                }
            }

            if ((mask & MethodAttributesAccessor) != 0) {
                if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) 
                {
                   // BL changes {{
                   if ( ( m_type.Attributes & TypeAttributes.Interface ) == 0 )
                      Output("MustOverride ");
                   // BL changes }}
                }
                else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0 && !overrided) {
                    Output("Overridable ");
                }

                if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                    //Output("Locked ");

                    // nothing
                }
                // do nothing: SpecialName
                // do nothing: RTSpecialName
                if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                    Output("extern ");
                }
            }
        }

        private void OutputTypeOfType(Type type) {
            int cls = (int) type.Attributes & (int)TypeAttributes.ClassSemanticsMask;

            if ((cls & (int)TypeAttributes.Interface) != 0) {
                Output("Interface ");
            }
            else if (type.BaseType == typeof( System.Enum )) {      
                Output("Enum ");
            }                                        
            else if (type.BaseType == typeof( System.ValueType  )) {                
                Output("Structure ");
            }                                  
            else {
                Output("Class ");
            }
        }

        private void OutputDecorationOfType(int typeAttributes) {
            int cls = typeAttributes & (int)TypeAttributes.ClassSemanticsMask;
            if ((typeAttributes & (int)TypeAttributes.Public) != 0 ||
                (typeAttributes & (int)TypeAttributes.NestedPublic) != 0) {
                Output("Public ");
            }
            if ((typeAttributes & (int)TypeAttributes.Sealed) != 0) {
                Output("NotInheritable ");
            }
            if ((typeAttributes & (int)TypeAttributes.Abstract) != 0
                && (typeAttributes & (int)TypeAttributes.Interface) == 0) {
                Output("MustInherit ");
            }
        }

        private void OutputDecorationOfField(int fieldAttributes) {
            int access = fieldAttributes & (int)FieldAttributes.FieldAccessMask;
            switch ((FieldAttributes)access) {
                case FieldAttributes.Assembly:
                    Output("Internal ");
                    break;
                case FieldAttributes.FamANDAssem:
                    // Output("/*Protected && Internal*/ Internal ");
                    Output("Internal ");
                    break;
                case FieldAttributes.FamORAssem:
                    // Output("/*Protected || Internal*/ Internal ");
                    Output("Internal ");
                    break;
                case FieldAttributes.Public:
                    Output("Public ");
                    break;
                case FieldAttributes.Private:
                    Output("Private ");
                    break;
                case FieldAttributes.Family:
                    Output("Protected ");
                    break;
                case FieldAttributes.PrivateScope:
                    // Output("/*Private Scope*/ Private ");
                    Output("Private ");
                    break;
            }

            if ((fieldAttributes & (int)FieldAttributes.Literal) != 0) {
                Output("Const ");
            }
            else {
                if ((fieldAttributes & (int)FieldAttributes.Static) != 0) {
                    Output("Shared ");
                }
                if ((fieldAttributes & (int)FieldAttributes.InitOnly) != 0) {
                    Output("ReadOnly ");

                    // nothing
                }
            }
            if ((fieldAttributes & (int)FieldAttributes.NotSerialized) != 0) {
                Output("Transient ");
            }

            if ((fieldAttributes & (int)FieldAttributes.PinvokeImpl) != 0) {
                Output("Extern ");
            }
        }

         // BL changes begin
         /// <include file='doc\VisualBasicSyntaxOutput.uex' path='docs/doc[@for="VisualBasicSyntaxOutput.GenerateOutput"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public override bool GenerateOutput( string strName )
         {
            if ( strName.StartsWith( "op_" ) )  // Do not handle operators
               return false;
            return true;
         }
         // BL changes end
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\wfcgenuemain.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCGenUEMain.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {
    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System.Globalization;

    /// <include file='doc\WFCGenUEMain.uex' path='docs/doc[@for="WFCGenUEMain"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class WFCGenUEMain {
        private string[] searchStrings = new string[ 12 ];
        private int searchCount = 0;
        private string xmlFilename = null;
        private Assembly[] modules = new Assembly[0];
        private ArrayList docfiles = new ArrayList();
        private bool includeAllMembers = false;
        private bool regex = false;
        private bool individualFiles = false;
        private string indivDirectory = ".";
        private string indivExtension = ".xdc";
        private bool namespaces = false;
        private string csxpath = null;

        /// <include file='doc\WFCGenUEMain.uex' path='docs/doc[@for="WFCGenUEMain.WFCGenUEMain"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WFCGenUEMain(string[] args) {
            Environment.ExitCode = 0;

            if (ProcessArgs(args)) {
                StreamWriter sw = null;

                if (xmlFilename != null && xmlFilename.Length > 3) {
                    FileStream fs = new FileStream(xmlFilename, FileMode.Create, FileAccess.ReadWrite);
                    sw = new StreamWriter(fs);
                }

                try {
                    string[] searchExprs = null;

                    if (searchCount != 0) {
                        searchExprs = new string[ searchCount ];
                        Array.Copy( searchStrings, searchExprs, searchExprs.Length );
                    }

                    string[] temp = new string[docfiles.Count];
                    docfiles.CopyTo(temp, 0);
                    WFCGenUEGenerator gen = new WFCGenUEGenerator(sw, searchExprs, regex, namespaces, includeAllMembers, modules, csxpath, temp);
                    if (individualFiles) {
                        gen.EnableIndividualFiles(indivDirectory, indivExtension);
                    }
                    gen.Generate();
                }
                finally {
                    if (sw != null) {
                        sw.Close();
                    }
                }
            }
        }

        /// <include file='doc\WFCGenUEMain.uex' path='docs/doc[@for="WFCGenUEMain.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(string[] args) {
            new WFCGenUEMain(args);
        }


        private void OutputLine(string s) {
            Console.WriteLine(s);
        }

        private void OutputLogo() {
            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(Assembly.Load("mscorlib").GetModules()[0].FullyQualifiedName);
            OutputLine(string.Format("Microsoft (R) .Net Framework Classes User Documentation Generator {0} [Common Language Runtime version {1}]", Application.ProductVersion, fvi.FileVersion));
            OutputLine("Copyright (C) Microsoft Corp 1999-2000. All rights reserved.");
            OutputLine("");
        }

        private void OutputUsage() {
            OutputLine("usage:");
            OutputLine("  wfcgenue [options] [<str> [<str>...]]");
            OutputLine("");
            OutputLine("options:");
            OutputLine("  /Purge                     Purges the cache of invalid types");
            OutputLine("  /I:<str>                   Specify modules to load");
            OutputLine("  /CD:<str>                  Specify a C# document file (allowed multiple times)");
            OutputLine("  /CP:<str>                  Specify a C# doc path (CSX file assumed to be <assem>.csx)");
            OutputLine("  /X:<str>                   Output data to specified XML file");
            OutputLine("  /IXDIR:<str>               Output individual XML files into the specified directory");
            OutputLine("  /IXEXT:<str>               Output individual XML files with the specified extension");
            OutputLine("  /Internal                  Include ALL members (instead of just public & protected)");
            OutputLine("  /regex                     Treat search expression as regular expression");
            OutputLine("  /ns                        Expression is a namespace, don't recurse (can't use with regex)");
            OutputLine("  /nologo                    Do not display copyright banner");
            OutputLine("");
            OutputLine("  <str>                      String or expression to search for in classnames");
            OutputLine("");
        }

        private bool ProcessArgs(string[] args) {
            bool needOutputUsage = false;
            bool needLogo = true;

            ArrayList includeModules = new ArrayList();
            ArrayList realModules = new ArrayList();

            for (int i=0; i<args.Length; i++) {
                string currentArg = args[i];

                if (currentArg[0] == '-'
                    || currentArg[0] == '/') {

                    string option = currentArg.Substring(1);

                    bool consumed = false;

                    if (!consumed) {
                        if (option.Equals("?")
                            || option.ToUpper(CultureInfo.InvariantCulture).Equals("H")
                            || option.ToUpper(CultureInfo.InvariantCulture).Equals("HELP")) {

                            needOutputUsage = true;
                            consumed = true;
                            break;
                        }
                    }

                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("NOLOGO")) {
                            needLogo = false;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("INTERNAL")) {
                            includeAllMembers = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("REGEX")) {
                            regex = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("NS")) {
                            namespaces = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 2 && option.Substring(0, 2).ToUpper(CultureInfo.InvariantCulture).Equals("I:")) {
                            string moduleName = option.Substring(2);
                            if (moduleName.Length > 0) {
                                includeModules.Add(moduleName);
                            }
                            consumed = true;
                        }
                    }
                    
                    string path = null;
                    
                    if (!consumed) {
                        if (option.Length > 3 && option.Substring(0, 3).ToUpper(CultureInfo.InvariantCulture).Equals("CD:")) {
                            path = option.Substring(3);
                            if (path.Length > 0) {
                                docfiles.Add(path);
                            }
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 3 && option.Substring(0, 3).ToUpper(CultureInfo.InvariantCulture).Equals("CP:")) {
                            path = option.Substring(3);
                            if (path.Length > 0) {
                                csxpath = path;
                            }
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 6 && option.Substring(0, 6).ToUpper(CultureInfo.InvariantCulture).Equals("IXDIR:")) {
                            indivDirectory = option.Substring(6);
                            individualFiles = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 6 && option.Substring(0, 6).ToUpper(CultureInfo.InvariantCulture).Equals("IXEXT:")) {
                            indivExtension = option.Substring(6);
                            individualFiles = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 2 && option.Substring(0, 2).ToUpper(CultureInfo.InvariantCulture).Equals("X:")) {
                            string arg = option.Substring(2);
                            if (arg.Length > 0) {
                                xmlFilename = arg;
                            }
                            consumed = true;
                        }
                    }

                    // Unknown command!
                    //
                    if (!consumed) {
                        needOutputUsage = true;
                        break;
                    }
                }

                // No '/' or '-', must be the "main" DLL
                //
                else {
                    if (searchCount >= searchStrings.Length) {
                        string[] newStrings = new string[ searchStrings.Length * 2 ];
                        Array.Copy( searchStrings, newStrings, searchStrings.Length );
                        searchStrings = newStrings;
                    }

                    searchStrings[ searchCount++ ] = currentArg;
                }
            }

            if (needLogo || needOutputUsage) {
                OutputLogo();
            }

            if (needOutputUsage) {
                OutputUsage();
                return false;
            }

            if (includeModules.Count == 0) {
                OutputUsage();
                return false;
            }

            string[] mods = new string[includeModules.Count];
            includeModules.CopyTo(mods, 0);
            for (int i=0; i<mods.Length; i++) {
                try {
                    Assembly a = Assembly.Load(mods[i]);
                    //Module m = LoadModule(mods[i], false);
                    if (a == null) {
                        Console.Error.WriteLine("Failed to load module for '" + mods[i] + "'");
                    }
                    else {
                        realModules.Add(a);
                    }
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }

            modules = new Assembly[realModules.Count];
            realModules.CopyTo(modules, 0);
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\resources\resxfileref.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXFileRef.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Resources {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;
    using System.ComponentModel;
    using System.Collections;
    using System.Resources;
    using System.Data;
    using System.Globalization;

    /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef"]/*' />
    /// <devdoc>
    ///     ResX File Reference class. This allows the developer to represent
    ///     a link to an external resource. When the resource manager asks
    ///     for the value of the resource item, the external resource is loaded.
    /// </devdoc>
    [TypeConverterAttribute(typeof(ResXFileRef.Converter)), Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ResXFileRef {
        private string fileName;
        private string typeName;

        /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.ResXFileRef"]/*' />
        /// <devdoc>
        ///     Creates a new ResXFileRef that points to the specified file.
        ///     The type refered to by typeName must support a constructor
        ///     that accepts a System.IO.Stream as a parameter.
        /// </devdoc>
        public ResXFileRef(string fileName, string typeName) {
            this.fileName = fileName;
            this.typeName = typeName;
        }

        /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return fileName + ";" + typeName;
        }

        /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.Converter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class Converter : TypeConverter {
            /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.Converter.CanConvertFrom"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override bool CanConvertFrom(ITypeDescriptorContext context,
                                                Type sourceType) {
                if (sourceType == typeof(string)) {
                    return true;
                }
                return false;
            }

            /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.Converter.CanConvertTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override bool CanConvertTo(ITypeDescriptorContext context, 
                                              Type destinationType) {
                if (destinationType == typeof(string)) {
                    return true;
                }
                return false;
            }

            /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.Converter.ConvertTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override Object ConvertTo(ITypeDescriptorContext context, 
                                             CultureInfo culture, 
                                             Object value, 
                                             Type destinationType) {
                Object created = null;
                if (destinationType == typeof(string)) {
                    created = ((ResXFileRef)value).ToString();
                }
                return created;
            }

            /// <include file='doc\ResXFileRef.uex' path='docs/doc[@for="ResXFileRef.Converter.ConvertFrom"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override Object ConvertFrom(ITypeDescriptorContext context, 
                                               CultureInfo culture,
                                               Object value) {
                Object created = null;
                string stringValue = value as string;
                if (stringValue != null) {
                    string[] parts = stringValue.Split(new char[] {';'});
                    Type toCreate = Type.GetType(parts[1], true);

                    byte[] temp = null;

                    using (FileStream s = new FileStream(parts[0], FileMode.Open, FileAccess.Read, FileShare.Read)) {
                        Debug.Assert(s != null, "Couldn't open " + parts[0]);
                        temp = new byte[s.Length];
                        s.Read(temp, 0, (int)s.Length);
                    }

                    created = Activator.CreateInstance(toCreate, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, new Object[] {new MemoryStream(temp)}, null);
                }
                return created;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\resources\resxnullref.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXNullRef.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Resources {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;
    using System.ComponentModel;
    using System.Collections;
    using System.Resources;
    using System.Data;
    using System.Globalization;

    /// <include file='doc\ResXNullRef.uex' path='docs/doc[@for="ResXNullRef"]/*' />
    /// <devdoc>
    ///     ResX Null Reference class.  This class allows ResX to store null values.
    ///     It is a placeholder that is written into the file.  On read, it is replaced
    ///     with null.
    /// </devdoc>
    [Serializable]
    internal class ResXNullRef {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\componentmodel\coreswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CoreSwitches {   
    
        private static BooleanSwitch perfTrack;                        
        
        public static BooleanSwitch PerfTrack {
            get {
                if (perfTrack == null) {
                    perfTrack  = new BooleanSwitch("PERFTRACK", "Debug performance critical sections.");       
                }
                return perfTrack;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcversion\wfcver.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCVer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCVersion {
    using System.Text;
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.IO;
    using Microsoft.Win32;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\WFCVer.uex' path='docs/doc[@for="WFCVer"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class WFCVer {
        private static readonly string[] files = new string[] {
            "GDIplus.dll",
            "Microsoft.JScript.DLL",
            "Microsoft.VisualStudio.DLL",
            "RichEd20.dll",
            "System.Configuration.Install.DLL ",
            "System.DLL ",
            "System.Data.DLL ",
            "System.Design.DLL",
            "System.DirectoryServices.DLL",
            "System.Drawing.DLL",
            "System.Drawing.Design.DLL",
            "System.Messaging.DLL ",
            "System.ServiceProcess.DLL ",
            "System.Web.Services.DLL ",
            "System.Web.dll",
            "System.Windows.Forms.DLL ",
            "System.XML.dll",
            "System.Runtime.Serialization.Formatters.Soap.dll",
            "fusion.dll",
            "mscorrc.dll",
            "mscoree.dll",
            "mscorpe.dll",
            "mscorlib.dll",
            "mscorsec.dll",
            "mscorjit.dll",
            "mscordbi.dll",
            "mscordbc.dll",
            "mscorwks.dll",
        };
        private static readonly string[] clsidInProc = new string[] {
            "{25336920-03F9-11cf-8FD0-00AA00686F13}", // MSHTML... HTML Document
        };

        /// <include file='doc\WFCVer.uex' path='docs/doc[@for="WFCVer.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void Main(string[] args) {
            Environment.ExitCode = -1;
            if (args.Length > 0) {
                Console.WriteLine("------------------------------------------------------------------------------");
                Console.WriteLine("Additional Files:\n");
                for (int i=0; i<args.Length; i++) {
                    ProcessEntry(args[i]);
                }
            }
            Console.WriteLine("------------------------------------------------------------------------------");
            Console.WriteLine(".NET Framework Files:\n");
            for (int i=0; i<files.Length; i++) {
                ProcessEntry(files[i]);
            }
            Console.WriteLine("------------------------------------------------------------------------------");
            Console.WriteLine("Registered COM2 Servers:\n");
            for (int i=0; i<clsidInProc.Length; i++) {
                ProcessCLSIDEntry(clsidInProc[i]);
            }
            Environment.ExitCode = 0;
        }

        private static void ProcessEntry(string name) {
            string fileName = Path.GetFileName(name);
            fileName = fileName.Substring(0, fileName.LastIndexOf("."));
            string assemblyVersion;
            try {
                assemblyVersion = Assembly.Load(fileName).GetName().Version.ToString();
            }
            catch (Exception) {
                assemblyVersion = "- none -";
            }
            string fullName;
            bool fromGac;

            FindDLL(name, out fullName, out fromGac);

            if (fullName.Length == 0) {
                DumpSingleEntry(name, assemblyVersion, null, fromGac);
            }
            else {
                DumpSingleEntry(name, assemblyVersion, FileVersionInfo.GetVersionInfo(fullName), fromGac);
            }
        }

        private static void ProcessCLSIDEntry(string clsid) {
            string fullName = "CLSID\\" + clsid + "\\InProcServer32";
            string fileName = (string)Registry.ClassesRoot.OpenSubKey(fullName).GetValue("");

            DumpSingleEntry(fileName, "- none -", FileVersionInfo.GetVersionInfo(fileName), false);
        }

        static string ComPlus_InstallRoot {
            get {
                string v = Environment.GetEnvironmentVariable("COMPLUS_InstallRoot");
                if (v == null || v.Length == 0) {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework")) {
                        if (key != null) {
                            v = (string)key.GetValue("InstallRoot");
                        }
                    }
                }
                return v;
            }
        }

        static string ComPlus_Version {
            get {
                string v = Environment.GetEnvironmentVariable("COMPLUS_Version");
                if (v == null || v.Length == 0) {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework")) {
                        if (key != null) {
                            v = (string)key.GetValue("Version");
                        }
                    }
                }
                return v;
            }
        }

        static string DevPath {
            get {
                string v = Environment.GetEnvironmentVariable("DEVPATH");
                if (v == null || v.Length == 0) {
                    using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\.NETFramework\" + ComPlus_Version)) {
                        v = (string)key.GetValue("DevPath");
                    }
                }
                return v;
            }
        }

        private static void FindDLL(string name, out string fullPath, out bool fromGac) {
            StringBuilder sb = new StringBuilder(512);
            int[] ignore = new int[] {0};
            string search = DevPath;
            if (search == null || search.Length == 0) {

                string fileName = Path.GetFileName(name);
                fileName = fileName.Substring(0, fileName.LastIndexOf("."));
                try {
                    fromGac = true;
                    fullPath = Assembly.Load(fileName).GetModules()[0].FullyQualifiedName;
                    return;
                }
                catch {
                }

                search = null;
            }
            SearchPath(search, name, null, sb.Capacity, sb, ignore);
            fullPath = sb.ToString();
            fromGac = false;
        }

        private static void DumpSingleEntry(string name, string assemblyVersion, FileVersionInfo f, bool fromGac) {
            Console.Write(name);
            if (f != null && string.Compare(f.FileName, name, true, CultureInfo.InvariantCulture) != 0) {
                Console.Write(" (");
                if (fromGac) {
                    Console.Write("GAC");
                }
                else {
                    Console.Write(f.FileName);
                }
                Console.Write(")");
            }
            Console.WriteLine("");
            Console.WriteLine("    assembly     : " + assemblyVersion);

            if (f == null) {
                Console.Write("    win32 version: - none -");
            }
            else {
                Console.Write("    win32 version: ");

                int l = f.FileVersion.Length;
                if (l == 0) {
                    Console.Write(" - none -");
                }
                else {
                    Console.Write(f.FileVersion);
                    if (f.IsDebug) {
                        Console.Write("(D)");
                    }
                    else {
                        Console.Write("(R)");
                    }
                }
            }
            Console.WriteLine();
        }

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int SearchPath(string lpPath, string lpFileName, string lpExtension, int nBufferLength, StringBuilder lpBuffer, int[] lpFilePart);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static BooleanSwitch lifetimeTracing;
        private static TraceSwitch imeMode;
        private static TraceSwitch activeX;
        private static TraceSwitch richLayout;
        private static TraceSwitch dragDrop;
        private static TraceSwitch msaa;
        private static TraceSwitch debugGridView;
        private static TraceSwitch dataGridCursor;
        private static TraceSwitch dataGridEditing;
        private static TraceSwitch dataGridKeys;
        private static TraceSwitch dataGridLayout;
        private static TraceSwitch dataGridPainting;
        private static TraceSwitch dataGridParents;        
        private static TraceSwitch dataGridScrolling;
        private static TraceSwitch dataGridSelection;           
        private static TraceSwitch dataCursor;
        private static TraceSwitch dataView;
        private static TraceSwitch dgRowPaint;        
        private static TraceSwitch msoComponentManager;
        private static TraceSwitch dgCaptionPaint;     
        private static TraceSwitch dgRelationShpRowLayout;
        private static TraceSwitch dgRelationShpRowPaint;
        private static TraceSwitch dgEditColumnEditing;                                                                
        private static TraceSwitch dataObject;        
        private static TraceSwitch handleLeak;
        private static BooleanSwitch traceCollect;
                                                                                                                                                                                                                                                                                                                
        public static TraceSwitch ActiveX {
            get {
                if (activeX == null) {
                    activeX = new TraceSwitch("ActiveX", "Debug ActiveX sourcing");
                }
                return activeX;
            }
        }         

        public static TraceSwitch DataCursor {
            get {
                if (dataCursor == null) {
                    dataCursor = new TraceSwitch("Microsoft.WFC.Data.DataCursor", "DataCursor");
                }
                return dataCursor;
            }
        }

        public static TraceSwitch DataView {
            get {
                if (dataView == null) {
                    dataView = new TraceSwitch("DataView", "DataView");
                }
                return dataView;
            }
        }
        
        public static TraceSwitch DataGridCursor {
            get {
                if (dataGridCursor == null) {
                    dataGridCursor = new TraceSwitch("DataGridCursor", "DataGrid cursor tracing");
                }
                return dataGridCursor;
            }
        }

        public static TraceSwitch DataGridEditing {
            get {
                if (dataGridEditing == null) {
                    dataGridEditing = new TraceSwitch("DataGridEditing", "DataGrid edit related tracing");
                }
                return dataGridEditing;
            }
        }

        public static TraceSwitch DataGridKeys {
            get {
                if (dataGridKeys == null) {
                    dataGridKeys = new TraceSwitch("DataGridKeys", "DataGrid keystroke management tracing");
                }
                return dataGridKeys;
            }
        }
                
        public static TraceSwitch DataGridLayout {
            get {
                if (dataGridLayout == null) {
                    dataGridLayout = new TraceSwitch("DataGridLayout", "DataGrid layout tracing");
                }
                return dataGridLayout;
            }
        }

        public static TraceSwitch DataGridPainting {
            get {
                if (dataGridPainting == null) {
                    dataGridPainting = new TraceSwitch("DataGridPainting" , "DataGrid Painting related tracing");
                }
                return dataGridPainting;
            }
        }
                                                                                        
        public static TraceSwitch DataGridParents {
            get {
                if (dataGridParents == null) {
                    dataGridParents = new TraceSwitch("DataGridParents", "DataGrid parent rows");
                }
                return dataGridParents;
            }
        }

        public static TraceSwitch DataGridSelection {
            get {
                if (dataGridSelection == null) {
                    dataGridSelection = new TraceSwitch("DataGridSelection", "DataGrid selection management tracing");
                }
                return dataGridSelection;
            }
        }
                                                                                
        public static TraceSwitch DataGridScrolling {
            get {
                if (dataGridScrolling == null) {
                    dataGridScrolling = new TraceSwitch("DataGridScrolling", "DataGrid scrolling");
                }
                return dataGridScrolling;
            }
        }

        public static TraceSwitch DataObject {
            get {
                if (dataObject == null) {
                    dataObject = new TraceSwitch("DataObject", "Enable tracing for the DataObject class.");
                }
                return dataObject;
            }
        }

        public static TraceSwitch DebugGridView {
            get {
                if (debugGridView == null) {
                    debugGridView = new TraceSwitch("PSDEBUGGRIDVIEW", "Debug PropertyGridView");
                }
                return debugGridView;
            }
        }        
        
        public static TraceSwitch DGCaptionPaint {
            get {
                if (dgCaptionPaint == null) {
                    dgCaptionPaint = new TraceSwitch("DGCaptionPaint", "DataGridCaption");
                }
                return dgCaptionPaint;
            }
        }
        
        public static TraceSwitch DGEditColumnEditing {
            get {
                if (dgEditColumnEditing == null) {
                    dgEditColumnEditing = new TraceSwitch("DGEditColumnEditing", "Editing related tracing");
                }
                return dgEditColumnEditing;
            }
        }
        
        public static TraceSwitch DGRelationShpRowLayout {
            get {
                if (dgRelationShpRowLayout == null) {
                    dgRelationShpRowLayout = new TraceSwitch("DGRelationShpRowLayout", "Relationship row layout");
                }
                return dgRelationShpRowLayout;
            }
        }
                                                                            
        public static TraceSwitch DGRelationShpRowPaint {
            get {
                if (dgRelationShpRowPaint == null) {
                    dgRelationShpRowPaint = new TraceSwitch("DGRelationShpRowPaint", "Relationship row painting");
                }
                return dgRelationShpRowPaint;
            }
        }    
        
        public static TraceSwitch DGRowPaint {
            get {
                if (dgRowPaint == null) {
                    dgRowPaint = new TraceSwitch("DGRowPaint", "DataGrid Simple Row painting stuff");
                }
                return dgRowPaint;
            }
        }

        public static TraceSwitch DragDrop {
            get {
                if (dragDrop == null) {
                    dragDrop = new TraceSwitch("DragDrop", "Debug OLEDragDrop support in Controls");
                }
                return dragDrop;
            }
        }
        
        public static TraceSwitch HandleLeak {
            get {
                if (handleLeak == null) {
                    handleLeak = new TraceSwitch("HANDLELEAK", "HandleCollector: Track Win32 Handle Leaks");
                }
                return handleLeak;
            }
        }
                
        public static TraceSwitch ImeMode {
            get {
                if (imeMode == null) {
                    imeMode = new TraceSwitch("ImeMode", "Debug IME Mode");
                }
                return imeMode;
            }
        }
                                
        public static BooleanSwitch LifetimeTracing {
            get {
                if (lifetimeTracing == null) {
                    lifetimeTracing = new BooleanSwitch("LifetimeTracing", "Track lifetime events. This will cause objects to track the stack at creation and dispose.");
                }
                return lifetimeTracing;
            }
        }
        
        public static TraceSwitch MSAA {
            get {
                if (msaa == null) {
                    msaa = new TraceSwitch("MSAA", "Debug Microsoft Active Accessibility");
                }
                return msaa;
            }
        }
        
        public static TraceSwitch MSOComponentManager {
            get {
                if (msoComponentManager == null) {
                    msoComponentManager = new TraceSwitch("MSOComponentManager", "Debug MSO Component Manager support");
                }
                return msoComponentManager;
            }
        }
                                
        public static TraceSwitch RichLayout {
            get {
                if (richLayout == null) {
                    richLayout = new TraceSwitch("RichLayout", "Debug layout in RichControls");
                }
                return richLayout;
            }
        }    
        
        public static BooleanSwitch TraceCollect {
            get {
                if (traceCollect == null) {
                    traceCollect = new BooleanSwitch("TRACECOLLECT", "HandleCollector: Trace HandleCollector operations");
                }
                return traceCollect;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\resources\resxresourcereader.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXResourceReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Resources {

    using System.Diagnostics;
    using System.Runtime.Serialization;
    using System;
    using System.Windows.Forms;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.ComponentModel;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using System.Resources;
    using System.Xml;
    using System.ComponentModel.Design;
    using System.Globalization;
    
    /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader"]/*' />
    /// <devdoc>
    ///     ResX resource reader.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ResXResourceReader : IResourceReader {

        static readonly char[] SpecialChars = new char[]{' ', '\r', '\n'};

        IFormatter binaryFormatter = null;
        string fileName = null;
        TextReader reader = null;
        Stream stream = null;
        string fileContents = null;

        ITypeResolutionService typeResolver;

        IDictionary resData = null;
        string resHeaderVersion = null;
        string resHeaderMimeType = null;
        string resHeaderReaderType = null;
        string resHeaderWriterType = null;

        private ResXResourceReader(ITypeResolutionService typeResolver) {
            this.typeResolver = typeResolver;
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader"]/*' />
        /// <devdoc>
        ///     Creates a reader for the specified file.
        /// </devdoc>
        public ResXResourceReader(string fileName) : this(fileName, null) {
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader1"]/*' />
        /// <devdoc>
        ///     Creates a reader for the specified stream.
        /// </devdoc>
        public ResXResourceReader(Stream stream) : this(stream, null) {
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader2"]/*' />
        /// <devdoc>
        ///     Creates a reader for the specified TextReader.
        /// </devdoc>
        public ResXResourceReader(TextReader reader) : this(reader, null) {
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader3"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Creates a reader for the specified file.
        /// </devdoc>
        public ResXResourceReader(string fileName, ITypeResolutionService typeResolver) {
            this.fileName = fileName;
            this.typeResolver = typeResolver;
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader4"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Creates a reader for the specified stream.
        /// </devdoc>
        public ResXResourceReader(Stream stream, ITypeResolutionService typeResolver) {
            this.stream = stream;
            this.typeResolver = typeResolver;
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.ResXResourceReader5"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Creates a reader for the specified TextReader.
        /// </devdoc>
        public ResXResourceReader(TextReader reader, ITypeResolutionService typeResolver) {
            this.reader = reader;
            this.typeResolver = typeResolver;
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for=".Finalize"]/*' />
        ~ResXResourceReader() {
            Dispose(false);
        }

        /// <devdoc>
        ///     Retrieves the resource data set. This will demand load it.
        /// </devdoc>
        private IDictionary ResData {
            get {
                EnsureResData();
                return resData;
            }
        }

        /// <devdoc>
        ///     Returns the typeResolver used to find types defined in the ResX contents.
        /// </devdoc>
        private ITypeResolutionService TypeResolver {
            get {
                return this.typeResolver;
            }
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.Close"]/*' />
        /// <devdoc>
        ///     Closes and files or streams being used by the reader.
        /// </devdoc>
        public void Close() {
            ((IDisposable)this).Dispose();
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            GC.SuppressFinalize(this);
            Dispose(true);
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (fileName != null && stream != null) {
                    stream.Close();
                    stream = null;
                }

                if (reader != null) {
                    reader.Close();
                    reader = null;
                }
            }
        }

        private void SetupNameTable(XmlReader reader) {
            reader.NameTable.Add(ResXResourceWriter.TypeStr);
            reader.NameTable.Add(ResXResourceWriter.NameStr);
            reader.NameTable.Add(ResXResourceWriter.DataStr);
            reader.NameTable.Add(ResXResourceWriter.MimeTypeStr);
            reader.NameTable.Add(ResXResourceWriter.ValueStr);
            reader.NameTable.Add(ResXResourceWriter.ResHeaderStr);
            reader.NameTable.Add(ResXResourceWriter.VersionStr);
            reader.NameTable.Add(ResXResourceWriter.ResMimeTypeStr);
            reader.NameTable.Add(ResXResourceWriter.ReaderStr);
            reader.NameTable.Add(ResXResourceWriter.WriterStr);
            reader.NameTable.Add(ResXResourceWriter.BinSerializedObjectMimeType);
            reader.NameTable.Add(ResXResourceWriter.SoapSerializedObjectMimeType);
        }

        /// <devdoc>
        ///     Demand loads the resource data.
        /// </devdoc>
        private void EnsureResData() {
            if (resData == null) {
                resData = new Hashtable();

                XmlTextReader contentReader = null;

                try {
                    // Read data in any which way
                    if (fileContents != null) {
                        contentReader = new XmlTextReader(new StringReader(fileContents));
                    }
                    else if (reader != null) {
                        contentReader = new XmlTextReader(reader);
                    }
                    else if (fileName != null || stream != null) {
                        if (stream == null) {
                            stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                        }

                        contentReader = new XmlTextReader(stream);
                    }

                    SetupNameTable(contentReader);
                    contentReader.WhitespaceHandling = WhitespaceHandling.None;
                    ParseXml(contentReader);
                }
                finally {
                    if (fileName != null && stream != null) {
                        stream.Close();
                        stream = null;
                    }
                }
            }
        }                                

        static byte[] FromBase64WrappedString(string text) {

            if (text.IndexOfAny(SpecialChars) != -1) {
                StringBuilder sb = new StringBuilder(text.Length);
                for (int i=0; i<text.Length; i++) {
                    switch (text[i]) {
                        case ' ':
                        case '\r':
                        case '\n':
                            break;
                        default:
                            sb.Append(text[i]);
                            break;
                    }
                }
                return Convert.FromBase64String(sb.ToString());
            }
            else {
                return Convert.FromBase64String(text);
            }
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.FromFileContents"]/*' />
        /// <devdoc>
        ///     Creates a reader with the specified file contents.
        /// </devdoc>
        public static ResXResourceReader FromFileContents(string fileContents) {
            return FromFileContents(fileContents, null);
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.FromFileContents1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Creates a reader with the specified file contents.
        /// </devdoc>
        public static ResXResourceReader FromFileContents(string fileContents, ITypeResolutionService typeResolver) {
            ResXResourceReader result = new ResXResourceReader(typeResolver);
            result.fileContents = fileContents;
            return result;
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        /// <include file='doc\ResXResourceReader.uex' path='docs/doc[@for="ResXResourceReader.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            EnsureResData();
            return resData.GetEnumerator();
        }

        // CONSIDER: We will have to add support for pseudo-partial binding here
        // to support bind ResX content to newer version of TypeConverters when
        // policy files do not exist. See comments in ResXResourceWriter.TypeNameWithAssembly
        // for more information.
        //
        private Type ResolveType(string typeName) {
            Type t = null;

            if (this.typeResolver != null) {
                t = this.typeResolver.GetType(typeName);

                // If we cannot find the strong-named type, then try to see
                // if the TypeResolver can bind to partial names. For this, 
                // we will strip out the partial names and keep the rest of the
                // strong-name informatio to try again.
                //
                if (t == null) {
                    string[] typeParts = typeName.Split(new char[] {','});

                    // Break up the type name from the rest of the assembly strong name.
                    //
                    if (typeParts != null && typeParts.Length > 2) {
                        string partialName = typeParts[0].Trim();

                        for (int i = 1; i < typeParts.Length; ++i) {
                            string s = typeParts[i].Trim();
                            if (!s.StartsWith("Version=") && !s.StartsWith("version=")) {
                                partialName = partialName + ", " + s;
                            }
                        }

                        t = this.typeResolver.GetType(partialName);
                    }
                }
            }

            if (t == null) {
                t = Type.GetType(typeName);
            }

            return t;
        }

        private void ParseXml(XmlReader reader) {
            try {
                while (reader.Read()) {
                    if (reader.NodeType == XmlNodeType.Element) {
                        string s = reader.LocalName;
                        if (object.ReferenceEquals(reader.LocalName, ResXResourceWriter.DataStr)) {
                            ParseDataNode(reader);
                        }
                        else if (object.ReferenceEquals(reader.LocalName, ResXResourceWriter.ResHeaderStr)) {
                            ParseResHeaderNode(reader);
                        }
                        int n = s.Length;
                    }
                }
            }
            catch (Exception e) {
                // If we fail to parse, then we should throw an exception indicating that
                // this wasn't a valid ResX file
                // 
                resData = null;
                throw new ArgumentException(SR.GetString(SR.InvalidResXFile), e);
            }

            bool validFile = false;

            if (object.Equals(resHeaderMimeType, ResXResourceWriter.ResMimeType)) {

                Type readerType = typeof(ResXResourceReader);
                Type writerType = typeof(ResXResourceWriter);

                string readerTypeName = resHeaderReaderType;
                string writerTypeName = resHeaderWriterType;
                if (readerTypeName != null &&readerTypeName.IndexOf(',') != -1) {
                    readerTypeName = readerTypeName.Split(new char[] {','})[0].Trim();
                }
                if (writerTypeName != null && writerTypeName.IndexOf(',') != -1) {
                    writerTypeName = writerTypeName.Split(new char[] {','})[0].Trim();
                }

                if (readerTypeName != null && 
                    writerTypeName != null && 
                    readerTypeName.Equals(readerType.FullName) && 
                    writerTypeName.Equals(writerType.FullName)) {
                    validFile = true;
                }
            }

            if (!validFile) {
                resData = null;
                throw new ArgumentException(SR.GetString(SR.InvalidResXFileReaderWriterTypes));
            }
        }

        private void ParseResHeaderNode(XmlReader reader) {
            string name = reader[ResXResourceWriter.NameStr];
            if (name != null) {
                reader.ReadStartElement();

                // The "1.1" schema requires the correct casing of the strings
                // in the resheader, however the "1.0" schema had a different
                // casing. By checking the Equals first, we should 
                // see significant performance improvements.
                //

                if (object.Equals(name, ResXResourceWriter.VersionStr)) {
                    if (reader.NodeType == XmlNodeType.Element) {
                        resHeaderVersion = reader.ReadElementString();
                    }
                    else {
                        resHeaderVersion = reader.Value.Trim();
                    }
                }
                else if (object.Equals(name, ResXResourceWriter.ResMimeTypeStr)) {
                    if (reader.NodeType == XmlNodeType.Element) {
                        resHeaderMimeType = reader.ReadElementString();
                    }
                    else {
                        resHeaderMimeType = reader.Value.Trim();
                    }
                }
                else if (object.Equals(name, ResXResourceWriter.ReaderStr)) {
                    if (reader.NodeType == XmlNodeType.Element) {
                        resHeaderReaderType = reader.ReadElementString();
                    }
                    else {
                        resHeaderReaderType = reader.Value.Trim();
                    }
                }
                else if (object.Equals(name, ResXResourceWriter.WriterStr)) {
                    if (reader.NodeType == XmlNodeType.Element) {
                        resHeaderWriterType = reader.ReadElementString();
                    }
                    else {
                        resHeaderWriterType = reader.Value.Trim();
                    }
                }
                else {
                    switch (name.ToLower(CultureInfo.InvariantCulture)) {
                        case ResXResourceWriter.VersionStr:
                            if (reader.NodeType == XmlNodeType.Element) {
                                resHeaderVersion = reader.ReadElementString();
                            }
                            else {
                                resHeaderVersion = reader.Value.Trim();
                            }
                            break;
                        case ResXResourceWriter.ResMimeTypeStr:
                            if (reader.NodeType == XmlNodeType.Element) {
                                resHeaderMimeType = reader.ReadElementString();
                            }
                            else {
                                resHeaderMimeType = reader.Value.Trim();
                            }
                            break;
                        case ResXResourceWriter.ReaderStr:
                            if (reader.NodeType == XmlNodeType.Element) {
                                resHeaderReaderType = reader.ReadElementString();
                            }
                            else {
                                resHeaderReaderType = reader.Value.Trim();
                            }
                            break;
                        case ResXResourceWriter.WriterStr:
                            if (reader.NodeType == XmlNodeType.Element) {
                                resHeaderWriterType = reader.ReadElementString();
                            }
                            else {
                                resHeaderWriterType = reader.Value.Trim();
                            }
                            break;
                    }
                }
            }
        }
        private void ParseDataNode(XmlReader reader) {
            string name = reader[ResXResourceWriter.NameStr];
            string typeName = reader[ResXResourceWriter.TypeStr];
            string mimeTypeName = reader[ResXResourceWriter.MimeTypeStr];

            reader.Read();
            object value = null;
            if (reader.NodeType == XmlNodeType.Element) {
                value = reader.ReadElementString();
            }
            else {
                value = reader.Value.Trim();
            }

            if (mimeTypeName != null && mimeTypeName.Length > 0) {
                if (String.Equals(mimeTypeName, ResXResourceWriter.BinSerializedObjectMimeType)
                    || String.Equals(mimeTypeName, ResXResourceWriter.Beta2CompatSerializedObjectMimeType)
                    || String.Equals(mimeTypeName, ResXResourceWriter.CompatBinSerializedObjectMimeType)) {
                    string text = (string)value;
                    byte[] serializedData;
                    serializedData = FromBase64WrappedString(text);

                    if (binaryFormatter == null) {
                        binaryFormatter = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
                        binaryFormatter.Binder = new ResXSerializationBinder(typeResolver);
                    }
                    IFormatter formatter = binaryFormatter;
                    if (serializedData != null && serializedData.Length > 0) {
                        value = formatter.Deserialize(new MemoryStream(serializedData));
                        if (value is ResXNullRef) {
                            value = null;
                        }
                    }
                }
                else if (String.Equals(mimeTypeName, ResXResourceWriter.SoapSerializedObjectMimeType)
                         || String.Equals(mimeTypeName, ResXResourceWriter.CompatSoapSerializedObjectMimeType)) {
                    string text = (string)value;
                    byte[] serializedData;
                    serializedData = FromBase64WrappedString(text);

                    if (serializedData != null && serializedData.Length > 0) {

                        // Performance : don't inline a new SoapFormatter here.  That will always bring in
                        //               the soap assembly, which we don't want.  Throw this in another
                        //               function so the class doesn't have to get loaded.
                        //
                        IFormatter formatter = CreateSoapFormatter();
                        value = formatter.Deserialize(new MemoryStream(serializedData));
                        if (value is ResXNullRef) {
                            value = null;
                        }
                    }
                }
                else if (String.Equals(mimeTypeName, ResXResourceWriter.ByteArraySerializedObjectMimeType)) {
                    if (typeName != null && typeName.Length > 0) {
                        Type type = ResolveType(typeName);
                        if (type != null) {
                            TypeConverter tc = TypeDescriptor.GetConverter(type);
                            if (tc.CanConvertFrom(typeof(byte[]))) {
                                string text = (string)value;
                                byte[] serializedData;
                                serializedData = FromBase64WrappedString(text);
        
                                if (serializedData != null) {
                                    value = tc.ConvertFrom(serializedData);
                                }
                            }
                        }
                        else {
                            Debug.Fail("Could not find type for " + typeName);
                            // Throw a TypeLoadException here, don't silently 
                            // eat this info.  ResolveType failed, so 
                            // Type.GetType should as well.
                            Type.GetType(typeName, true);
                        }
                    }
                }
            }
            else if (typeName != null && typeName.Length > 0) {
                Type type = ResolveType(typeName);
                if (type != null) {
                    if (type == typeof(ResXNullRef)) {
                        value = null;
                    }
                    else if (typeName.IndexOf("System.Byte[]") != -1 && typeName.IndexOf("mscorlib") != -1) {
                        // Handle byte[]'s, which are stored as base-64 encoded strings.
                        // We can't hard-code byte[] type name due to version number
                        // updates & potential whitespace issues with ResX files.
                        value = FromBase64WrappedString((string)value);
                    }
                    else {
                        TypeConverter tc = TypeDescriptor.GetConverter(type);
                        if (tc.CanConvertFrom(typeof(string))) {
                            string text = (string)value;
                            value = tc.ConvertFromInvariantString(text);
                        }
                        else {
                            Debug.WriteLine("Converter for " + type.FullName + " doesn't support string conversion");
                        }
                    }
                }
                else {
                    Debug.Fail("Could not find type for " + typeName);
                    // Throw a TypeLoadException for this type which we 
                    // couldn't load to include fusion binding info, etc.
                    Type.GetType(typeName, true);
                }
            }
            else {
                // if mimeTypeName and typeName are not filled in, the value must be a string
                Debug.Assert(value is string, "Resource entries with no Type or MimeType must be encoded as strings");
            }

            if (name==null)
                throw new ArgumentException(SR.GetString(SR.InvalidResXResourceNoName, value));
            resData[name] = value;

        }

        /// <devdoc>
        ///     As a performance optimization, we isolate the soap class here in a separate
        ///     function.  We don't care about the binary formatter because it lives in 
        ///     mscorlib, which is already loaded.  The soap formatter lives in a separate
        ///     assembly, however, so there is value in preventing it from needlessly
        ///     being loaded.
        /// </devdoc>
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        private IFormatter CreateSoapFormatter() {
            return new System.Runtime.Serialization.Formatters.Soap.SoapFormatter();
        }

        // This class implements a partial type resolver for the BinaryFormatter.
        // This is needed to be able to read binary serialized content from older
        // NDP types and map them to newer versions.
        //
        private class ResXSerializationBinder : SerializationBinder {
            private ITypeResolutionService typeResolver;

            public ResXSerializationBinder(ITypeResolutionService typeResolver) {
                this.typeResolver = typeResolver;
            }

            public override Type BindToType(string assemblyName, string typeName) {
                if (typeResolver == null) {
                    return null;
                }

                typeName = typeName + ", " + assemblyName;

                Type t = typeResolver.GetType(typeName);
                if (t == null) {
                    string[] typeParts = typeName.Split(new char[] {','});

                    // Break up the assembly name from the rest of the assembly strong name.
                    //
                    if (typeParts != null && typeParts.Length > 2) {
                        string partialName = typeParts[0].Trim();

                        for (int i = 1; i < typeParts.Length; ++i) {
                            string s = typeParts[i].Trim();
                            if (!s.StartsWith("Version=") && !s.StartsWith("version=")) {
                                partialName = partialName + ", " + s;
                            }
                        }

                        t = typeResolver.GetType(partialName);
                    }
                }

                // Binder couldn't handle it, let the default loader take over.
                return t;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\resources\resxresourceset.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXResourceSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Resources {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;
    using System.ComponentModel;
    using System.Collections;
    using System.Resources;
    using System.Data;

    /// <include file='doc\ResXResourceSet.uex' path='docs/doc[@for="ResXResourceSet"]/*' />
    /// <devdoc>
    ///     ResX resource set.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ResXResourceSet : ResourceSet {

        /// <include file='doc\ResXResourceSet.uex' path='docs/doc[@for="ResXResourceSet.ResXResourceSet"]/*' />
        /// <devdoc>
        ///     Creates a resource set for the specified file.
        /// </devdoc>
        public ResXResourceSet(String fileName) {
            this.Reader = new ResXResourceReader(fileName);
            this.Table = new Hashtable();
            ReadResources();
        }

        /// <include file='doc\ResXResourceSet.uex' path='docs/doc[@for="ResXResourceSet.ResXResourceSet1"]/*' />
        /// <devdoc>
        ///     Creates a resource set for the specified stream.
        /// </devdoc>
        public ResXResourceSet(Stream stream) {
            this.Reader = new ResXResourceReader(stream);
            this.Table = new Hashtable();
            ReadResources();
        }

        /// <include file='doc\ResXResourceSet.uex' path='docs/doc[@for="ResXResourceSet.GetDefaultReader"]/*' />
        /// <devdoc>
        ///     Gets the default reader type associated with this set.
        /// </devdoc>
        public override Type GetDefaultReader() {
            return typeof(ResXResourceReader);
        }

        /// <include file='doc\ResXResourceSet.uex' path='docs/doc[@for="ResXResourceSet.GetDefaultWriter"]/*' />
        /// <devdoc>
        ///     Gets the default writer type associated with this set.
        /// </devdoc>
        public override Type GetDefaultWriter() {
            return typeof(ResXResourceWriter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessiblenavigation.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleNavigation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies values for navigating between accessible objects.
    ///    </para>
    /// </devdoc>
    public enum AccessibleNavigation {

        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Down"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation
        ///       to a sibling object located
        ///       below the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Down = 0x2,

        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.FirstChild"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation to
        ///       the
        ///       first child of the object.
        ///    </para>
        /// </devdoc>
        FirstChild = 0x7,

        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.LastChild"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation to
        ///       the
        ///       last child of the object
        ///    </para>
        /// </devdoc>
        LastChild = 0x8,

        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation
        ///       to the sibling object located
        ///       to the left
        ///       of the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Left = 0x3,

        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Next"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation
        ///       to the next logical object, generally from a
        ///       sibling
        ///       object to the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Next = 0x5,
        
        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Previous"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation to the previous logical object, generally
        ///       from
        ///       a sibling
        ///       object to the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Previous = 0x6,
        
        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation to the sibling object
        ///       located to the right of the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Right = 0x4,
        
        /// <include file='doc\AccessibleNavigation.uex' path='docs/doc[@for="AccessibleNavigation.Up"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigation to a sibling object
        ///       located above the
        ///       starting object.
        ///    </para>
        /// </devdoc>
        Up = 0x1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessibleroles.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleRoles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies values representing possible roles for an accessible object.
    ///    </para>
    /// </devdoc>
    public enum AccessibleRole {

        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A system provided role.
        ///    </para>
        /// </devdoc>
        Default = -1,
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No role.
        ///    </para>
        /// </devdoc>
        None = 0,
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.TitleBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A title or caption bar
        ///       for a window.
        ///    </para>
        /// </devdoc>
        TitleBar =    ( 0x1 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.MenuBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A menu bar, usually beneath the
        ///       title bar of a window, from which menus can be selected
        ///       by the user.
        ///    </para>
        /// </devdoc>
        MenuBar =     ( 0x2 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ScrollBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A vertical or horizontal scroll bar, which
        ///       can be either part of the client area or used
        ///       in a control.
        ///    </para>
        /// </devdoc>
        ScrollBar =   ( 0x3 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Grip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A special mouse pointer, which
        ///       allows a user to manipulate user interface elements such as a window. For
        ///       example, a user can click and drag a sizing grip in the lower-right corner of a
        ///       window to
        ///       resize it.
        ///    </para>
        /// </devdoc>
        Grip =        ( 0x4 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Sound"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A system sound, which is associated with
        ///       various
        ///       system events.
        ///    </para>
        /// </devdoc>
        Sound =       ( 0x5 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Cursor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A mouse pointer.
        ///    </para>
        /// </devdoc>
        Cursor =      ( 0x6 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Caret"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A caret, which is a flashing line, block, or bitmap
        ///       that marks the location of the insertion point in a
        ///       window's client area.
        ///    </para>
        /// </devdoc>
        Caret =       ( 0x7 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Alert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An alert or condition that a
        ///       user should be notified about. This role should be used only for objects that
        ///       embody an alert but are not associated with another user interface element, such
        ///       as a message box, graphic, text,
        ///       or sound.
        ///    </para>
        /// </devdoc>
        Alert =       ( 0x8 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Window"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A window frame, which usually contains child
        ///       objects such as a title bar, client, and other objects typically contained in
        ///       a window.
        ///    </para>
        /// </devdoc>
        Window =      ( 0x9 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Client"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       window's user area.
        ///    </para>
        /// </devdoc>
        Client =      ( 0xa ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.MenuPopup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A menu, which presents a list of
        ///       options from which the user can make a selection to perform an action. All menu
        ///       types must have this role, including drop-down menus that are displayed by
        ///       selection from a menu bar, and shortcut menus that are displayed when the right
        ///       mouse button is
        ///       clicked.
        ///    </para>
        /// </devdoc>
        MenuPopup =   ( 0xb ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.MenuItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A menu item, which is an entry in
        ///       a menu that a user can choose to carry out a command, select
        ///       an option, or display another menu.
        ///       Functionally, a menu item can be equivalent to a push button, radio button, check
        ///       box, or menu.
        ///    </para>
        /// </devdoc>
        MenuItem =    ( 0xc ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ToolTip"]/*' />
        /// <devdoc>
        ///    A tool tip, which is a small rectangular pop-up
        ///    window that displays a brief description of a command bar button's
        ///    purpose.
        /// </devdoc>
        ToolTip =     ( 0xd ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Application"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The main window for
        ///       an application.
        ///    </para>
        /// </devdoc>
        Application = ( 0xe ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       document window, which is always
        ///       contained within an application window. This role applies only to
        ///       multiple document interface (MDI) windows and refers to an object that contains
        ///       the MDI title bar.
        ///    </para>
        /// </devdoc>
        Document =    ( 0xf ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Pane"]/*' />
        /// <devdoc>
        ///    <para>
        ///       One of the separate areas in a frame, a split document
        ///       window, or a rectangular area of the status
        ///       bar that can be used to display
        ///       information. Users can navigate between panes and within the contents of the current
        ///       pane, but cannot navigate between items in different panes. Thus, panes
        ///       represent a level of grouping lower than frame windows or documents, but above
        ///       individual controls. Typically the user navigates between panes by pressing TAB,
        ///       F6, or CTRL+TAB, depending on the
        ///       context.
        ///    </para>
        /// </devdoc>
        Pane =        ( 0x10 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Chart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A graphical image used to
        ///       represent data.
        ///    </para>
        /// </devdoc>
        Chart =       ( 0x11 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Dialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dialog box
        ///       or message box.
        ///    </para>
        /// </devdoc>
        Dialog =      ( 0x12 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Border"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A window border. The entire border
        ///       is represented by a single object, rather than by separate objects for
        ///       each side.
        ///    </para>
        /// </devdoc>
        Border =      ( 0x13 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Grouping"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Objects grouped in a logical
        ///       manner. There can be a parent-child relationship between the grouping object and the
        ///       objects
        ///       it contains.
        ///    </para>
        /// </devdoc>
        Grouping =    ( 0x14 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Separator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Visually divides a space into two regions, such as a separator menu item or a
        ///       bar dividing split panes within a window.
        ///    </para>
        /// </devdoc>
        Separator =   ( 0x15 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ToolBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A toolbar, which is a grouping of controls that provide
        ///       easy access to frequently
        ///       used features.
        ///    </para>
        /// </devdoc>
        ToolBar =     ( 0x16 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.StatusBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A status bar, which is an area typically at the bottom
        ///       of an application window
        ///       that displays information about the current operation, state of the application,
        ///       or selected object. The status bar can have multiple fields that display different
        ///       kinds of information, such as an explanation of the currently selected menu
        ///       command in the status bar.
        ///    </para>
        /// </devdoc>
        StatusBar =   ( 0x17 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Table"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A table containing rows and columns of cells, and
        ///       optionally, row headers and column headers.
        ///    </para>
        /// </devdoc>
        Table =       ( 0x18 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ColumnHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A column header, which provides a visual label for a column
        ///       in a table.
        ///    </para>
        /// </devdoc>
        ColumnHeader =        ( 0x19 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.RowHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A row header, which provides a visual
        ///       label for
        ///       a table row.
        ///    </para>
        /// </devdoc>
        RowHeader =   ( 0x1a ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Column"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A column of cells within a table.
        ///    </para>
        /// </devdoc>
        Column =      ( 0x1b ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Row"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A row of cells within
        ///       a table.
        ///    </para>
        /// </devdoc>
        Row = ( 0x1c ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Cell"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A cell within
        ///       a table.
        ///    </para>
        /// </devdoc>
        Cell =        ( 0x1d ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Link"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A link, which is a connection between a source
        ///       document and a destination document. This
        ///       object might look like text or a graphic, but it acts like
        ///       a button.
        ///    </para>
        /// </devdoc>
        Link =        ( 0x1e ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.HelpBalloon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Help display in the form of a ToolTip or Help
        ///       balloon, which
        ///       contains
        ///       buttons and labels that users can click to open
        ///       custom Help topics.
        ///    </para>
        /// </devdoc>
        HelpBalloon = ( 0x1f ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Character"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A cartoon-like graphic object,
        ///       such as Microsoft Office Assistant, which is typically displayed to provide help
        ///       to users of
        ///       an application.
        ///    </para>
        /// </devdoc>
        Character =   ( 0x20 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.List"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A list box, which allows the user
        ///       to select one or
        ///       more items.
        ///    </para>
        /// </devdoc>
        List =        ( 0x21 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ListItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An item in a list box or the list
        ///       portion of a combo box, drop-down list box, or
        ///       drop-down combo box.
        ///    </para>
        /// </devdoc>
        ListItem =    ( 0x22 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Outline"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An outline or tree structure, such
        ///       as a tree view control, which displays a hierarchical list and usually allows
        ///       the
        ///       user to expand and collapse branches.
        ///    </para>
        /// </devdoc>
        Outline =     ( 0x23 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.OutlineItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An item
        ///       in an outline or tree structure.
        ///    </para>
        /// </devdoc>
        OutlineItem = ( 0x24 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.PageTab"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A property page that allows a user
        ///       to view the attributes for a page, such as the page's title, whether it is a
        ///       home page, or
        ///       whether the page has been modified.
        ///       Normally the only child of this control is a grouped object that contains
        ///       the contents of the associated page.
        ///    </para>
        /// </devdoc>
        PageTab =     ( 0x25 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.PropertyPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A property page, which is a dialog box that
        ///       controls the appearance and the behavior of an object, such as a file or
        ///       resource. A property page's appearance differs according
        ///       to its purpose.
        ///    </para>
        /// </devdoc>
        PropertyPage =        ( 0x26 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Indicator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An indicator, such as a pointer
        ///       graphic, that points to the
        ///       current item.
        ///    </para>
        /// </devdoc>
        Indicator =   ( 0x27 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Graphic"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A picture.
        ///    </para>
        /// </devdoc>
        Graphic =     ( 0x28 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.StaticText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Read-only text,
        ///       such as in a label, for other
        ///       controls or instructions in a dialog box. Static text cannot be modified
        ///       or selected.
        ///    </para>
        /// </devdoc>
        StaticText =  ( 0x29 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selectable text
        ///       that can be editable or read-only.
        ///    </para>
        /// </devdoc>
        Text =        ( 0x2a ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.PushButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A push button control, which is a
        ///       small rectangular control that a user can turn on or off. A push button, also known
        ///       as a command button, has a raised appearance in its default off state and
        ///       a sunken appearance when it is turned
        ///       on.
        ///    </para>
        /// </devdoc>
        PushButton =  ( 0x2b ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.CheckButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A check box control, which is an option
        ///       that can be turned on or off independently
        ///       of other options.
        ///    </para>
        /// </devdoc>
        CheckButton = ( 0x2c ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.RadioButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An option button, also known as a
        ///       radio button. All objects sharing a single parent that have this attribute are
        ///       assumed to be part of a single mutually exclusive group. You can use
        ///       grouped objects to divide option buttons into separate groups when
        ///       necessary.
        ///    </para>
        /// </devdoc>
        RadioButton = ( 0x2d ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ComboBox"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       combo box, which is an edit
        ///       control with an associated list box that provides a set of predefined
        ///       choices.
        ///    </para>
        /// </devdoc>
        ComboBox =    ( 0x2e ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.DropList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A drop-down list box. This control shows one
        ///       item and allows the user to display and select another
        ///       from a list of alternative choices.
        ///    </para>
        /// </devdoc>
        DropList =    ( 0x2f ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ProgressBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A progress bar, which indicates the progress of a
        ///       lengthy operation by displaying a colored bar inside a horizontal rectangle. The
        ///       length of the bar in relation
        ///       to the length of the rectangle corresponds
        ///       to the percentage of the operation that is complete. This control does
        ///       not take user
        ///       input.
        ///    </para>
        /// </devdoc>
        ProgressBar = ( 0x30 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Dial"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dial or knob. This can also be a
        ///       read-only object, like a speedometer.
        ///    </para>
        /// </devdoc>
        Dial =        ( 0x31 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.HotkeyField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A hot-key field that allows the user to enter a combination or sequence of
        ///       keystrokes to be used as a hot key, which enables users to perform an action
        ///       quickly. A hot-key control displays the keystrokes entered by the user and
        ///       ensures that the user selects a valid key combination.
        ///    </para>
        /// </devdoc>
        HotkeyField = ( 0x32 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Slider"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A control, sometimes called a trackbar,
        ///       that allows a user to adjust a setting in given increments between
        ///       minimum and maximum values by moving a slider. The volume controls in the
        ///       Windows operating system are slider
        ///       controls.
        ///    </para>
        /// </devdoc>
        Slider =      ( 0x33 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.SpinButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A spin box, also
        ///       known as an up-down control, which contains a pair of arrow buttons that a
        ///       user click with a mouse to increment or decrement a value. A spin button control is
        ///       most often used with a companion control, called a buddy window, where the current
        ///       value is
        ///       displayed.
        ///    </para>
        /// </devdoc>
        SpinButton =  ( 0x34 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Diagram"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A graphical image used to diagram data.
        ///    </para>
        /// </devdoc>
        Diagram =     ( 0x35 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Animation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An animation control, which
        ///       contains content that is changing over time, such as a control that displays a
        ///       series of bitmap frames, like a film strip. Animation controls are usually
        ///       displayed when files are being copied, or when some other time-consuming task is
        ///       being
        ///       performed.
        ///    </para>
        /// </devdoc>
        Animation =   ( 0x36 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Equation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A mathematical equation.
        ///    </para>
        /// </devdoc>
        Equation =    ( 0x37 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ButtonDropDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A button that
        ///       drops down a list of items.
        ///    </para>
        /// </devdoc>
        ButtonDropDown =      ( 0x38 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ButtonMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A button that drops down a menu.
        ///    </para>
        /// </devdoc>
        ButtonMenu =  ( 0x39 ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.ButtonDropDownGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A button that drops down a grid.
        ///    </para>
        /// </devdoc>
        ButtonDropDownGrid =  ( 0x3a ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.WhiteSpace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A blank space between other objects.
        ///    </para>
        /// </devdoc>
        WhiteSpace =  ( 0x3b ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.PageTabList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A container of page tab controls.
        ///    </para>
        /// </devdoc>
        PageTabList = ( 0x3c ),
        
        /// <include file='doc\AccessibleRoles.uex' path='docs/doc[@for="AccessibleRole.Clock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       control that displays the time.
        ///    </para>
        /// </devdoc>
        Clock =       ( 0x3d ),
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessibleevents.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents"]/*' />
    /// <devdoc>
    ///    <para>Specifies
    ///       events that are reported by accessible applications.</para>
    /// </devdoc>
    public enum AccessibleEvents {
    
        //
        //  EVENT_SYSTEM_SOUND
        //  Sent when a sound is played.  Currently nothing is generating this, we
        //  are going to be cleaning up the SOUNDSENTRY feature in the control panel
        //  and will use this at that time.  Applications implementing WinEvents
        //  are perfectly welcome to use it.  Clients of IAccessible* will simply
        //  turn around and get back a non-visual object that describes the sound.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemSound"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemSound = 0x0001,

        //
        // EVENT_SYSTEM_ALERT
        // Sent when an alert needs to be given to the user.  MessageBoxes generate
        // alerts for example.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemAlert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemAlert = 0x0002,

        //
        // EVENT_SYSTEM_FOREGROUND
        // Sent when the foreground (active) window changes, even if it is changing
        // to another window in the same thread as the previous one.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemForeground"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemForeground = 0x0003,

        //
        // EVENT_SYSTEM_MENUSTART
        // EVENT_SYSTEM_MENUEND
        // Sent when entering into and leaving from menu mode (system, app bar, and
        // track popups).
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMenuStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMenuStart = 0x0004,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMenuEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMenuEnd = 0x0005,

        //
        // EVENT_SYSTEM_MENUPOPUPSTART
        // EVENT_SYSTEM_MENUPOPUPEND
        // Sent when a menu popup comes up and just before it is taken down.  Note
        // that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
        // followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
        // being shown.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMenuPopupStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMenuPopupStart = 0x0006,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMenuPopupEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMenuPopupEnd = 0x0007,

        
        //
        // EVENT_SYSTEM_CAPTURESTART
        // EVENT_SYSTEM_CAPTUREEND
        // Sent when a window takes the capture and releases the capture.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemCaptureStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemCaptureStart = 0x0008,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemCaptureEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemCaptureEnd = 0x0009,
        
        //
        // EVENT_SYSTEM_MOVESIZESTART
        // EVENT_SYSTEM_MOVESIZEEND
        // Sent when a window enters and leaves move-size dragging mode.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMoveSizeStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMoveSizeStart = 0x000A,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMoveSizeEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMoveSizeEnd = 0x000B,
        
        //
        // EVENT_SYSTEM_CONTEXTHELPSTART
        // EVENT_SYSTEM_CONTEXTHELPEND
        // Sent when a window enters and leaves context sensitive help mode.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemContextHelpStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemContextHelpStart = 0x000C,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemContextHelpEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemContextHelpEnd = 0x000D,
        
        //
        // EVENT_SYSTEM_DRAGDROPSTART
        // EVENT_SYSTEM_DRAGDROPEND
        // Sent when a window enters and leaves drag drop mode.  Note that it is up
        // to apps and OLE to generate this, since the system doesn't know.  Like
        // EVENT_SYSTEM_SOUND, it will be a while before this is prevalent.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemDragDropStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemDragDropStart = 0x000E,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemDragDropEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemDragDropEnd = 0x000F,
        
        //
        // EVENT_SYSTEM_DIALOGSTART
        // EVENT_SYSTEM_DIALOGEND
        // Sent when a dialog comes up and just before it goes away.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemDialogStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemDialogStart = 0x0010,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemDialogEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemDialogEnd = 0x0011,
        
        //
        // EVENT_SYSTEM_SCROLLINGSTART
        // EVENT_SYSTEM_SCROLLINGEND
        // Sent when beginning and ending the tracking of a scrollbar in a window,
        // and also for scrollbar controls.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemScrollingStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemScrollingStart = 0x0012,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemScrollingEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemScrollingEnd = 0x0013,
        
        //
        // EVENT_SYSTEM_SWITCHSTART
        // EVENT_SYSTEM_SWITCHEND
        // Sent when beginning and ending alt-tab mode with the switch window.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemSwitchStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemSwitchStart = 0x0014,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemSwitchEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemSwitchEnd = 0x0015,
        
        //
        // EVENT_SYSTEM_MINIMIZESTART
        // EVENT_SYSTEM_MINIMIZEEND
        // Sent when a window minimizes and just before it restores.
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMinimizeStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMinimizeStart = 0x0016,
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SystemMinimizeEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SystemMinimizeEnd = 0x0017,
        
        
        
        //
        // Object events
        //
        // The system AND apps generate these.  The system generates these for 
        // real windows.  Apps generate these for objects within their window which
        // act like a separate control, e.g. an item in a list view.
        //
        // For all events, if you want detailed accessibility information, callers
        // should
        //      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
        //          of the event, and IID_IAccessible as the REFIID, to get back an 
        //          IAccessible* to talk to
        //      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
        //          parameter of the event.
        //      * If idChild isn't zero, call get_accChild() in the container to see
        //          if the child is an object in its own right.  If so, you will get
        //          back an IDispatch* object for the child.  You should release the
        //          parent, and call QueryInterface() on the child object to get its
        //          IAccessible*.  Then you talk directly to the child.  Otherwise,
        //          if get_accChild() returns you nothing, you should continue to
        //          use the child VARIANT.  You will ask the container for the properties
        //          of the child identified by the VARIANT.  In other words, the
        //          child in this case is accessible but not a full-blown object.
        //          Like a button on a titlebar which is 'small' and has no children.
        //          
        
        //
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Create =                0x8000,  // hwnd + ID + idChild is created item
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Destroy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Destroy =               0x8001,  // hwnd + ID + idChild is destroyed item
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Show"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Show =                  0x8002,  // hwnd + ID + idChild is shown item
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Hide"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Hide =                  0x8003,  // hwnd + ID + idChild is hidden item
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Reorder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Reorder =               0x8004,  // hwnd + ID + idChild is parent of zordering children
        //
        // NOTE:
        // Minimize the number of notifications!  
        //
        // When you are hiding a parent object, obviously all child objects are no 
        // longer visible on screen.  They still have the same "visible" status, 
        // but are not truly visible.  Hence do not send HIDE notifications for the
        // children also.  One implies all.  The same goes for SHOW.
        //
        
        
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Focus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Focus =                 0x8005,  // hwnd + ID + idChild is focused item
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.Selection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Selection =             0x8006,  // hwnd + ID + idChild is selected item (if only one), or idChild is OBJID_WINDOW if complex
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SelectionAdd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SelectionAdd =          0x8007,  // hwnd + ID + idChild is item added
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SelectionRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SelectionRemove =       0x8008,  // hwnd + ID + idChild is item removed
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.SelectionWithin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SelectionWithin =       0x8009,  // hwnd + ID + idChild is parent of changed selected items
        
        //
        // NOTES:
        // There is only one "focused" child item in a parent.  This is the place
        // keystrokes are going at a given moment.  Hence only send a notification 
        // about where the NEW focus is going.  A NEW item getting the focus already 
        // implies that the OLD item is losing it.
        //
        // SELECTION however can be multiple.  Hence the different SELECTION
        // notifications.  Here's when to use each:
        //
        // (1) Send a SELECTION notification in the simple single selection
        //     case (like the focus) when the item with the selection is
        //     merely moving to a different item within a container.  hwnd + ID
        //     is the container control, idChildItem is the new child with the
        //     selection.
        //
        // (2) Send a SELECTIONADD notification when a new item has simply been added 
        //     to the selection within a container.  This is appropriate when the
        //     number of newly selected items is very small.  hwnd + ID is the
        //     container control, idChildItem is the new child added to the selection.
        //
        // (3) Send a SELECTIONREMOVE notification when a new item has simply been
        //     removed from the selection within a container.  This is appropriate
        //     when the number of newly selected items is very small, just like
        //     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
        //     new child removed from the selection.
        //
        // (4) Send a SELECTIONWITHIN notification when the selected items within a
        //     control have changed substantially.  Rather than propagate a large
        //     number of changes to reflect removal for some items, addition of
        //     others, just tell somebody who cares that a lot happened.  It will
        //     be faster an easier for somebody watching to just turn around and
        //     query the container control what the new bunch of selected items
        //     are.
        //
        
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.StateChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        StateChange =                           0x800A,  // hwnd + ID + idChild is item w/ state change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.LocationChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LocationChange =                        0x800B,  // hwnd + ID + idChild is moved/sized item
        
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.NameChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NameChange =                            0x800C,  // hwnd + ID + idChild is item w/ name change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.DescriptionChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DescriptionChange =                     0x800D,  // hwnd + ID + idChild is item w/ desc change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.ValueChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ValueChange =                           0x800E,  // hwnd + ID + idChild is item w/ value change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.ParentChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ParentChange =                          0x800F,  // hwnd + ID + idChild is item w/ new parent
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.HelpChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HelpChange =                            0x8010,  // hwnd + ID + idChild is item w/ help change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.DefaultActionChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DefaultActionChange =                   0x8011,  // hwnd + ID + idChild is item w/ def action change
        /// <include file='doc\AccessibleEvents.uex' path='docs/doc[@for="AccessibleEvents.AcceleratorChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AcceleratorChange =                     0x8012,  // hwnd + ID + idChild is item w/ keybd accel change
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessibleselection.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleSelection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how an accessible object will be selected or receive focus.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum AccessibleSelection {

        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The selection or focus of an object is unchanged.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.TakeFocus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Assigns focus to an object and makes
        ///       it the anchor, which is the starting point for
        ///       the selection. Can be combined with <see langword='TakeSelection'/>,
        ///    <see langword='ExtendSelection'/>, <see langword='AddSelection'/>, or 
        ///    <see langword='RemoveSelection'/>.
        ///    </para>
        /// </devdoc>
        TakeFocus = 1,

        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.TakeSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects the object and deselects all other objects in the container.
        ///    </para>
        /// </devdoc>
        TakeSelection = 2,

        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.ExtendSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects all objects between the anchor and the selected object.
        ///    </para>
        /// </devdoc>
        ExtendSelection = 4,

        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.AddSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the object to the selection.
        ///    </para>
        /// </devdoc>
        AddSelection = 8,
        
        /// <include file='doc\AccessibleSelection.uex' path='docs/doc[@for="AccessibleSelection.RemoveSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the object from the selection.
        ///    </para>
        /// </devdoc>
        RemoveSelection = 16,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessiblestates.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleStates.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies values representing possible states for an accessible object
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum AccessibleStates {

        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No state.
        ///    </para>
        /// </devdoc>
        None = 0,
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Unavailable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An unavailable object.
        ///    </para>
        /// </devdoc>
        Unavailable =     ( 0x1 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Selected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A selected object.
        ///    </para>
        /// </devdoc>
        Selected =        ( 0x2 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Focused"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object with the keyboard focus.
        ///    </para>
        /// </devdoc>
        Focused =         ( 0x4 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Pressed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pressed object.
        ///    </para>
        /// </devdoc>
        Pressed =         ( 0x8 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object with a
        ///       selected check box.
        ///    </para>
        /// </devdoc>
        Checked =    ( 0x10 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Mixed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-state check box or toolbar button
        ///       whose state is indeterminate. The check box is neither checked nor unchecked and
        ///       it is in the
        ///       third or mixed state.
        ///    </para>
        /// </devdoc>
        Mixed =      ( 0x20 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Indeterminate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-state check box or toolbar button
        ///       whose state is indeterminate. The check box is neither checked nor unchecked and it
        ///       is in the third
        ///       or mixed state.
        ///    </para>
        /// </devdoc>
        Indeterminate =      ( Mixed ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A read-only object.
        ///    </para>
        /// </devdoc>
        ReadOnly =   ( 0x40 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.HotTracked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is hot-tracked by
        ///       the mouse, meaning its appearance is highlighted to indicate the mouse
        ///       pointer is located over it.
        ///    </para>
        /// </devdoc>
        HotTracked = ( 0x80 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       default button or menu item.
        ///    </para>
        /// </devdoc>
        Default =    ( 0x100 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Expanded"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Children of the object that are items in an outline or tree
        ///       structure are displayed.
        ///    </para>
        /// </devdoc>
        Expanded =   ( 0x200 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Collapsed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Children of the object that are items in an outline or tree structure are
        ///       hidden.
        ///    </para>
        /// </devdoc>
        Collapsed =  ( 0x400 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Busy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       control
        ///       that cannot accept input in its current condition.
        ///    </para>
        /// </devdoc>
        Busy =       ( 0x800 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Floating"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is not fixed to the boundary of its parent object, and
        ///       does not move automatically along with the parent.
        ///    </para>
        /// </devdoc>
        Floating =   ( 0x1000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Marqueed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object with scrolling
        ///       or moving text or graphics.
        ///    </para>
        /// </devdoc>
        Marqueed =   ( 0x2000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Animated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object has a rapidly or constantly changing
        ///       appearance. Graphics that are occasionally animated, but not always, should be
        ///       defined as <see langword='AccessibleRole.Graphic '/>|
        ///    <see langword='AccessibleStates.Animated '/>. This state should
        ///       not be used to indicate that
        ///       the object's location is changing.
        ///    </para>
        /// </devdoc>
        Animated =   ( 0x4000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Invisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object that is currently invisible.
        ///    </para>
        /// </devdoc>
        Invisible =  ( 0x8000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Offscreen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No on-screen representation. A
        ///       sound or alert object would have this state, or a
        ///       hidden window that is never made visible.
        ///    </para>
        /// </devdoc>
        Offscreen =  ( 0x10000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Sizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A sizable object.
        ///    </para>
        /// </devdoc>
        Sizeable =   ( 0x20000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Moveable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A movable object.
        ///    </para>
        /// </devdoc>
        Moveable =   ( 0x40000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.SelfVoicing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object or child can use text-to-speech (TTS) to describe itself. A
        ///       speech-based accessibility aid should not announce information when an object
        ///       with this state has the focus because the object will automatically announce
        ///       information about itself.
        ///    </para>
        /// </devdoc>
        SelfVoicing =        ( 0x80000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Focusable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is on the active window
        ///       and can receive keyboard focus.
        ///    </para>
        /// </devdoc>
        Focusable =  ( 0x100000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Selectable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object that can accept selection.
        ///    </para>
        /// </devdoc>
        Selectable = ( 0x200000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Linked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A linked object that has not
        ///       been previously selected.
        ///    </para>
        /// </devdoc>
        Linked =     ( 0x400000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Traversed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A linked object that has previously been selected.
        ///    </para>
        /// </devdoc>
        Traversed =  ( 0x800000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.MultiSelectable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An object
        ///       that accepts multiple selected items.
        ///    </para>
        /// </devdoc>
        MultiSelectable =    ( 0x1000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.ExtSelectable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Alters the selection so that all objects
        ///       between the selection anchor, which is the object with the
        ///       keyboard focus, and this object take on the anchor object's selection
        ///       state. If the anchor object is not selected, the objects are removed from
        ///       the selection. If the anchor object is selected, the selection is extended to
        ///       include this object and all the objects in between. You can set the selection
        ///       state by combining this flag with <see langword='AccessibleSelection.AddSelection '/>or <see langword='AccessibleSelection.RemoveSelection'/>. This flag does
        ///       not change the focus or the selection anchor unless it is combined with
        ///    <see langword='AccessibleSelection.TakeFocus'/>. The behavior of 
        ///    <see langword='AccessibleStates.ExtendSelection'/> | 
        ///    <see langword='AccessibleSelection.TakeFocus '/>is equivalent to adding an item 
        ///       to a selection manually by holding down the SHIFT key and clicking an unselected
        ///       object. This flag may not be combined with
        ///    <see langword='AccessibleSelection.TakeSelection'/>
        ///    .
        /// </para>
        /// </devdoc>
        ExtSelectable =      ( 0x2000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.AlertLow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Low-priority information that may not be important to the user.
        ///    </para>
        /// </devdoc>
        AlertLow =  ( 0x4000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.AlertMedium"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Important information that does not need to be conveyed to the user
        ///       immediately. For example, when a battery level indicator is starting to reach a
        ///       low level, it could generate a medium-level alert. Blind access utilities could
        ///       then generate a sound to let the user know that important information is
        ///       available, without actually interrupting the user's work. The user could then
        ///       query the alert information at his or her leisure.
        ///    </para>
        /// </devdoc>
        AlertMedium =       ( 0x8000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.AlertHigh"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Important information that should be conveyed to the user immediately. For
        ///       example, a battery level indicator reaching a critical low level would
        ///       transition to this state, in which case a blind access utility would announce
        ///       this information immediately to the user, and a screen magnification program
        ///       would scroll the screen so that the battery indicator is in view. This state is
        ///       also appropriate for any prompt or operation that must be completed before the
        ///       user can continue.
        ///    </para>
        /// </devdoc>
        AlertHigh = ( 0x10000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Protected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A password-protected edit control.
        ///    </para>
        /// </devdoc>
        Protected =  ( 0x20000000 ),
        
        
        /// <include file='doc\AccessibleStates.uex' path='docs/doc[@for="AccessibleStates.Valid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A valid object.
        ///    </para>
        /// </devdoc>
        Valid =      ( 0x3fffffff ),
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\ambientproperties.cs ===
//------------------------------------------------------------------------------
// <copyright file="AmbientProperties.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.Windows.Forms {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Windows.Forms.Design;
    using System.ComponentModel.Design;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\AmbientProperties.uex' path='docs/doc[@for="AmbientProperties"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides ambient property values to top-level controls.
    ///    </para>
    /// </devdoc>
    //
    // NOTE: internally, this class does double duty as storage for Control's inherited properties.
    public sealed class AmbientProperties {
    
        // Public ambient properties
        private Color    backColor; 
        private Color    foreColor;
        private Cursor   cursor;
        private Font     font;
        
        /// <include file='doc\AmbientProperties.uex' path='docs/doc[@for="AmbientProperties.BackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the ambient BackColor, or Color.Empty if there is none.
        ///    </para>
        /// </devdoc>
        public Color BackColor {
            get {
                return backColor;
            }
            set {
                backColor = value;
            }
        }

        /// <include file='doc\AmbientProperties.uex' path='docs/doc[@for="AmbientProperties.Cursor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the ambient BackColor, or null if there is none.
        ///    </para>
        /// </devdoc>
        public Cursor Cursor {
            get {
                return cursor;
            }
            set {
                cursor = value;
            }
        }

        /// <include file='doc\AmbientProperties.uex' path='docs/doc[@for="AmbientProperties.Font"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the ambient Font, or null if there is none.
        ///    </para>
        /// </devdoc>
        public Font Font {
            get {
                return font;
            }
            set {
                font = value;
            }
        }
        
        /// <include file='doc\AmbientProperties.uex' path='docs/doc[@for="AmbientProperties.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the ambient ForeColor, or Color.Empty if there is none.
        ///    </para>
        /// </devdoc>
        public Color ForeColor {
            get {
                return foreColor;
            }
            set {
                foreColor = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\vsdesigner\tools\wfcgenue\wfcgenuegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCGenUEGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Tools.WFCGenUE {

    using System;
    using System.Diagnostics;
    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Xml;
    using System.Reflection;
    using System.Text.RegularExpressions;
    using ElementType = Microsoft.Tools.WFCGenUE.DocComment.ElementType;
    using Element = Microsoft.Tools.WFCGenUE.DocComment.Element;
    using Parser = Microsoft.Tools.WFCGenUE.DocComment.Parser;
    using System.Globalization;
    
    /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class WFCGenUEGenerator {

        // private static readonly string AddingMessage        = " adding '{0}' to list of classes";
        private static readonly string ProcessingMessage    = " processing '{0}'";
        private static readonly string SourceLoadedMessage  = " loaded CSX block for '{0}'";
#if true
        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.GenDCXML"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static BooleanSwitch GenDCXML = new BooleanSwitch("GenDCXML", ".Net Framework Classes UE Generator Debug Doc Comment XML Parsing.");
#else        
        /// <summary>
        ///    <para>[To be supplied.]</para>
        /// </summary>
        public class Bloak {
            private bool value;
            /// <summary>
            ///    <para>[To be supplied.]</para>
            /// </summary>
            public Bloak( bool value ) {
                this.value = value;
            }
            /// <summary>
            ///    <para>[To be supplied.]</para>
            /// </summary>
            public bool Enabled {
                get { return value; }
            }
        }
        
        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.noParams"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Bloak GenDCXML = new Bloak( false );
#endif
        
        private static Element[] noParams = new Element[0];
        private static ParameterInfo[] noParamInfos = new ParameterInfo[0];

        private TextWriter outputWriter;
        private string[] searchStrings;
        private Assembly[] searchModules;

        private int indentLevel = 0;

        private Type[] types;
        private string[] namespaces;
        private Parser docCommentParser = new Parser();
        private SyntaxOutput[] outputGenerators = null;
        private bool includeAllMembers = false;
        private Regex[] searchRegexes;
        private bool useRegex = false;
        private bool individualFiles = false;
        private bool useNamespaces = false;
        private string indivDirectory = ".";
        private string indivExtension = ".xdc";
        private DocLoader docloader = null;

        private SourceErrorInfo errorInfo = null;
        private bool errorThrown = false;
        
        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.WFCGenUEGenerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WFCGenUEGenerator(TextWriter outputWriter, string[] searchStrings, bool regex, bool namespaces, bool includeAllMembers, Assembly[] searchModules, string csxpath, string[] searchDocFiles) {
            // Trace.Listeners.Add( new TextWriterTraceListener( Console.Out ) );
            this.outputWriter = outputWriter;
            if (searchStrings == null) {
                this.searchStrings = new string[] { "" };
            }
            else {
                this.searchStrings = searchStrings;
            }

            this.useRegex = regex;
            this.useNamespaces = namespaces;
            this.searchModules = searchModules;
            this.includeAllMembers = includeAllMembers;
            
            docloader = new DocLoader();
            
            int i = 0;
            
            for (i = 0; searchDocFiles != null && i < searchDocFiles.Length; i++) {
                docloader.AddStream( searchDocFiles[ i ] );
            }
            
            if (csxpath != null && csxpath.Length != 0) {
                for (i = 0; searchModules != null && i < searchModules.Length; i++) {
                    Module[] modules = searchModules[ i ].GetModules();
                    for (int j = 0; modules != null && j < modules.Length; j++) {
                        string filename = Path.ChangeExtension( csxpath + "\\" + modules[ j ].Name, ".csx" );
                        docloader.AddStream( filename );
                    }
                }
            }

            // add new languages here            
            this.outputGenerators = new SyntaxOutput[] {
                     new CoolSyntaxOutput(),
                     new MCSyntaxOutput(),
                     new VisualBasicSyntaxOutput(),
                     new JScriptSyntaxOutput()
                  };
        }

        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.EnableIndividualFiles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnableIndividualFiles(string dir, string ext) {
            individualFiles = true;
            indivDirectory = dir;
            indivExtension = ext;
        }

        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.ErrorThrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool ErrorThrown {
            get {
                return errorThrown;
            }
            set {
                errorThrown = true;
            }
        }

        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.IndentLevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndentLevel {
            get {
                return indentLevel;
            }
            set {
                indentLevel = value;
            }
        }

        private string ConvertSIGToReadable(string str) {
            if (str != null && str.Length > 0) {
                return str.Replace('/', '.');
            }
            
            return str;
        }

        private void Error(string errorMessage) {
            ErrorThrown = true;
            if (errorInfo != null) {
                errorInfo.OutputError(Console.Error, errorMessage);
                Console.Error.WriteLine("");
            }
            else {
                Console.Error.Write("Unknown error context: ");
                Console.Error.WriteLine(errorMessage);
            }
        }

        private Element[] ExtractParamElements(Element root) {
            ArrayList items = new ArrayList();
            ExtractParamElementsWorker(root, items);
            Element[] temp = new Element[items.Count];
            items.CopyTo(temp, 0);
            if (WFCGenUEGenerator.GenDCXML.Enabled)
                Debug.WriteLine( "ExtractParamElements for " + root.FetchTagName() );
                
            return temp;
        }

        private void ExtractParamElementsWorker(Element current, ArrayList items) {
            if (current.Type == ElementType.Param) {
                if (WFCGenUEGenerator.GenDCXML.Enabled)
                    Debug.WriteLine( "found param element " + current.FetchTagName() + ", " + current.Text );
                    
                current.Parent = null;
                items.Add(current);
            }
            else {
                if (WFCGenUEGenerator.GenDCXML.Enabled)
                    Debug.WriteLine( "groking " + current.FetchTagName() );
                    
                if (current.HasChildren) {
                    // Can't use enum... because we remove things...
                    //
                    Element[] children = new Element[current.Children.Count];
                    current.Children.CopyTo(children, 0);
                    for (int i=0; i<children.Length; i++) {
                        ExtractParamElementsWorker(children[i], items);
                    }
                }
            }
        }

        private Type[] FilterInheritedInterfaces( Type type ) {
            // jeezum crow this is ugly, there's got to be a better way...

            Type[] typeIFC = type.GetInterfaces();

            Type baseType = type.BaseType;
            if (baseType == null)
                return typeIFC;

            Type[] inhIFC = baseType.GetInterfaces();
            Type[] netIFC = new Type[ typeIFC.Length ];

            int netCount = 0;

            // so, we walk thru all the actual interfaces, looking for matches
            // between the actuals, and the interfaces from the base type
            for (int i = 0; i < typeIFC.Length; i++) {
                int j = 0;
                for (; j < inhIFC.Length; j ++) {
                    if (inhIFC[ j ].Equals( (Type) typeIFC[ i ] ))
                        break;
                }

                // if we're out of the loop and no match was found, it must
                // be a unique interface for this subclass.
                if (j == inhIFC.Length)
                    netIFC[ netCount++ ] = typeIFC[ i ];
            }

            // make another friggin array copy
            Type[] newIFC = new Type[ netCount ];
            if (netCount != 0)
                Array.Copy( netIFC, newIFC, netCount );

            return newIFC;
        }

        private string FindDeclaringBaseType( MethodInfo mi ) {
            return mi.DeclaringType.BaseType.FullName;
        }

        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.Generate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Generate() {
            try {
                PreProcessTypes();
                if (outputWriter != null) {
                    ProcessNamespacesSingle();
                }
                if (individualFiles) {
                    ProcessNamespacesIndividual();
                }
            }
            catch (Exception e) {
                Console.Error.WriteLine("failed generating docs");
                Console.Error.WriteLine(e.ToString());
            }
        }

        private string GetParamElementName(Element element) {
            if (element.Type == ElementType.Param) {
                return(string)element.Attributes["name"];
            }
            return "";
        }

        /// <include file='doc\WFCGenUEGenerator.uex' path='docs/doc[@for="WFCGenUEGenerator.GetUnrefTypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string GetUnrefTypeName( Type type ) {
            if (type.IsByRef)
                return type.GetElementType().FullName;
            else
                return type.FullName;
        }
        
        private bool IsPublicClass(int typeAttributes) {
            if ((typeAttributes & (int)TypeAttributes.Public) != 0 ||
                (typeAttributes & (int)TypeAttributes.NestedPublic) != 0) {
                return true;
            }
            return false;
        }

        private bool IsSealedClass(int typeAttributes) {
            if ((typeAttributes & (int)TypeAttributes.Sealed) != 0) {
                return true;
            }
            return false;
        }

        private bool IsAbstractClass(int typeAttributes) {
            if ((typeAttributes & (int)TypeAttributes.Abstract) != 0
                && (typeAttributes & (int)TypeAttributes.Interface) == 0) {
                return true;
            }
            return false;
        }

        private void OutputLineStart() {
            Debug.Assert(outputWriter != null, "OutputWriter null!");
            for (int i=0; i<IndentLevel; i++) {
                outputWriter.Write("  ");
            }
        }

        private void Output(string s) {
            Debug.Assert(outputWriter != null, "OutputWriter null!");
            outputWriter.Write(s);
        }

        private void OutputLine(string s) {
            Debug.Assert(outputWriter != null, "OutputWriter null!");
            outputWriter.WriteLine(s);
        }

        private void OutputStartOpenTag(string tagname) {
            OutputLineStart();
            Output("<");
            Output(tagname);
        }

        private void OutputTagAttribute(string attributeName, string value) {
            if (value != null && value.Length > 0) {
                Output(" ");
                Output(attributeName);
                Output("='");
                Output(value);
                Output("'");
            }
        }

        private void OutputTypeHierarchy(Type type) {

            Debug.Assert(type != null, "Must pass in a non-null type!");

            OutputStartOpenTag("hierarchy");
            OutputEndOpenTag();

            try {
                // Reverse order, i.e. "System.Object;System.Component;..."
                //

                Stack baseTypes = new Stack();
                Type cur = type;

                if (!cur.IsInterface) {
                    try {
                        do {
                            cur = cur.BaseType;

                            // only ever occurs if type==typeof(object)....
                            //
                            if (cur != null) {
                                baseTypes.Push(cur);
                            }
                        } while (cur != null && cur != typeof(object));
                    }
                    catch (Exception e) {
                        Console.Error.WriteLine("failed walking hierarchy for '" + type.FullName + "'");
                        Console.Error.WriteLine(e.ToString());
                        baseTypes = null;

                    }
                }

                if (baseTypes != null) {
                    cur = (Type)baseTypes.Pop();
                    if (cur != null) {

                        try {
                            while (cur != null) {
                                Output(cur.FullName.Replace( '$', '.' ));
                                cur = (Type)baseTypes.Pop();
                                if (cur != null) {
                                    Output(";");
                                }
                            }
                        }
                        catch (Exception e) {
                            Console.Error.WriteLine("failed generating hierarchy for '" + type.FullName + "'");
                            Console.Error.WriteLine(e.ToString());
                        }

                    }
                }
            }
            finally {
                OutputCloseTag("hierarchy");
                OutputNewLine();
            }
        }

        private void OutputEndOpenTag() {
            Output(">");
        }

        private void OutputEndOpenTagNoClose() {
            Output("/>");
        }

        private void OutputCloseTag(string tagname) {
            Output("</");
            Output(tagname);
            Output(">");
        }

        private void OutputNewLine() {
            OutputLine("");
        }

        private void OutputFullLine(string s) {
            OutputLineStart();
            OutputLine(s);
        }

        private void OutputMethodAttributeTag(int methodAttributes, bool declaredOnCurrentType, Type type) {
            OutputStartOpenTag("access");

            int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
            switch ((MethodAttributes)access) {
                case MethodAttributes.Assembly:
                    OutputTagAttribute("assembly", "True");
                    break;
                case MethodAttributes.FamANDAssem:
                    OutputTagAttribute("famandassem", "True");
                    break;
                case MethodAttributes.FamORAssem:
                    OutputTagAttribute("famorassem", "True");
                    break;
                case MethodAttributes.Public:
                    OutputTagAttribute("public", "True");
                    break;
                case MethodAttributes.Private:
                    OutputTagAttribute("private", "True");
                    break;
                case MethodAttributes.Family:
                    OutputTagAttribute("protected", "True");
                    break;
                case MethodAttributes.PrivateScope:
                    OutputTagAttribute("privatescope", "True");
                    break;
                default:
                    OutputTagAttribute("default", "True");
                    break;
            }

            if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                OutputTagAttribute("static", "True");
            }

            if (!declaredOnCurrentType) {
                OutputTagAttribute("inherited", "True");
                if (type != null)
                    OutputTagAttribute( "base", type.FullName.Replace( '$', '.' ) );
            }

            if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) {
                OutputTagAttribute("abstract", "True");
            }
            else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0) {
                OutputTagAttribute("virtual", "True");
            }

            if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                OutputTagAttribute("synchronized", "True");
            }
            // do nothing: SpecialName
            // do nothing: RTSpecialName
            if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                OutputTagAttribute("pinvokeimpl", "True");
            }

            OutputEndOpenTagNoClose();
            OutputNewLine();
        }

        private void OutputMethodAttributeTag(MethodBase mi) {
            int methodAttributes = (int)mi.Attributes;
            int methodDecl = MemberDecl.FromMethodInfo(mi);
            OutputStartOpenTag("access");

            int access = methodAttributes & (int)MethodAttributes.MemberAccessMask;
            switch ((MethodAttributes)access) {
                case MethodAttributes.Assembly:
                    OutputTagAttribute("assembly", "True");
                    break;
                case MethodAttributes.FamANDAssem:
                    OutputTagAttribute("famandassem", "True");
                    break;
                case MethodAttributes.FamORAssem:
                    OutputTagAttribute("famorassem", "True");
                    break;
                case MethodAttributes.Public:
                    OutputTagAttribute("public", "True");
                    break;
                case MethodAttributes.Private:
                    OutputTagAttribute("private", "True");
                    break;
                case MethodAttributes.Family:
                    OutputTagAttribute("protected", "True");
                    break;
                case MethodAttributes.PrivateScope:
                    OutputTagAttribute("privatescope", "True");
                    break;
                default:
                    OutputTagAttribute("default", "True");
                    break;
            }

            if ((methodAttributes & (int)MethodAttributes.Static) != 0) {
                OutputTagAttribute("static", "True");
            }

            switch (methodDecl) {
                case MemberDecl.Inherited:
                    OutputTagAttribute("inherited", "True");
                    OutputTagAttribute( "base", mi.DeclaringType.FullName.Replace( '$', '.' ) );
                    break;
                case MemberDecl.New:
                    if ((methodAttributes & (int)MethodAttributes.Abstract) == 0) {
                        OutputTagAttribute("new", "True");
                    }
                    break;
                case MemberDecl.Override:
                    if ((methodAttributes & (int)MethodAttributes.Abstract) == 0) {
                        OutputTagAttribute("override", "True");
                        // safe to cast, since we'll never be in an override case for a ctor
                        OutputTagAttribute( "base", FindDeclaringBaseType( (MethodInfo) mi ).Replace( '$', '.' ) );
                    }
                    break;
                case MemberDecl.DeclaredOnType:
                    // nothing;
                    break;
            }

            if ((methodAttributes & (int)MethodAttributes.Abstract) != 0) {
                OutputTagAttribute("abstract", "True");
            }
            else if ((methodAttributes & (int)MethodAttributes.Virtual) != 0) {
                OutputTagAttribute("virtual", "True");
            }

            if ((methodAttributes & (int)MethodImplAttributes.Synchronized) != 0) {
                OutputTagAttribute("synchronized", "True");
            }
            // do nothing: SpecialName
            // do nothing: RTSpecialName
            if ((methodAttributes & (int)MethodAttributes.PinvokeImpl) != 0) {
                OutputTagAttribute("pinvokeimpl", "True");
            }

            OutputEndOpenTagNoClose();
            OutputNewLine();
        }

        private Element[] OutputParamDocComment(string docComment) {
            Element[] parameters = noParams;
            Element de = ParseDocComment(docComment);
            
            if (de != null) {
                parameters = ExtractParamElements(de);
                de.OutputChildXml(outputWriter);
            }

            return parameters;
        }

        private void OutputSimpleDocComment(string docComment) {
            Element de = null;
            de = ParseDocComment(docComment);

            if (de != null) {
                de.OutputChildXml(outputWriter);
            }
        }

        private Element ParseDocComment(string comment) {
            Element root = null;
            Element errorelement = null;
            
            lock(docCommentParser) {
                try {
                    if (WFCGenUEGenerator.GenDCXML.Enabled) {
                        Debug.WriteLine("--------- comment parse -------------");
                        Debug.WriteLine(comment);
                        Debug.WriteLine("-------------------------------------");
                        Debug.WriteLine("");
                    }

                    MemoryStream ms = new MemoryStream(System.Text.Encoding.ASCII.GetBytes(comment));
                    XmlReader reader = new XmlTextReader( new StreamReader( ms ) );
                    docCommentParser.Start();
                    docCommentParser.Parse( reader );
                    docCommentParser.Finish();
                }
                catch (Exception e) {
                    Error("XML comment error: " + e.Message);
                    errorelement = Element.CreateComment( e.Message );
                }

                root = docCommentParser.RootElement;
                if (errorelement != null)
                    root.Children.Add( errorelement );
            }
            return root;
        }

        private void PreProcessTypes() {
            ArrayList namespacesList = new ArrayList();
            ArrayList typeList = new ArrayList();

            for (int curMod=0; curMod < searchModules.Length; curMod++) {       
                Type[] allTypes = null;
                try {
                    allTypes = searchModules[curMod].GetModules()[0].GetTypes();
                }
                catch (Exception e) {
                    allTypes = new Type[0];
                    Console.Error.WriteLine("Exception occured getting all types for '" + searchModules[curMod].GetModules()[0].FullyQualifiedName + "'");
                    Console.Error.WriteLine(e.ToString());
                }

                if (allTypes == null) {
                    Console.Error.WriteLine("'null' returned getting all types for '" + searchModules[curMod].GetModules()[0].FullyQualifiedName + "'");
                }

                for (int curType = 0; curType < allTypes.Length; curType++) {
                    if (ShouldProcessType(allTypes[curType])) {
                        typeList.Add(allTypes[curType]);
                        
                        string ns = ConvertSIGToReadable(allTypes[curType].Namespace);

                        if (ns != null && !namespacesList.Contains(ns)) {
                            namespacesList.Add(ns);
                        }
                    }
                }
            }

            types = new Type[typeList.Count];
            typeList.CopyTo(types, 0);
            
            namespaces = new string[namespacesList.Count];
            namespacesList.CopyTo(namespaces, 0);
        }
        
        private void ProcessNamespace(string ns) {
            OutputStartOpenTag("namespace");
            OutputTagAttribute("name", ns);
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
                for (int curType=0; curType<types.Length; curType++) {
                    string curTypeNameSpace = ConvertSIGToReadable(types[curType].Namespace);
                    if (curTypeNameSpace.Equals(ns)) {
                        ProcessType(ns, types[curType]);
                    }
                }
            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("namespace");
                OutputNewLine();
            }
        }

        private void ProcessNamespacesIndividual() {   
            for (int curType=0; curType<types.Length; curType++) {
                string curTypeName = ConvertSIGToReadable(types[curType].FullName);
                string ns = ConvertSIGToReadable(types[curType].Namespace);
                Stream current = File.Create(indivDirectory + "\\" + curTypeName + indivExtension);
                StreamWriter currentWriter = new StreamWriter(current);
                TextWriter original = outputWriter;
                try {
                    outputWriter = currentWriter;

                    OutputStartOpenTag("namespace");
                    OutputTagAttribute("name", ns);
                    OutputEndOpenTag();
                    OutputNewLine();
                    IndentLevel++;

                    try {   
                        ProcessType(ns, types[curType]);
                    }
                    finally {
                        IndentLevel--;
                        OutputLineStart();
                        OutputCloseTag("namespace");
                        OutputNewLine();
                    }
                }
                finally {
                    outputWriter = original;
                    currentWriter.Close();
                    current.Close();
                }
            }
        }

        private void ProcessNamespacesSingle() {
            OutputStartOpenTag("root");
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
                for (int curNamespace=0; curNamespace<namespaces.Length; curNamespace++) {   
                    ProcessNamespace(namespaces[curNamespace]);
                }
            }
            finally {    
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("root");
                OutputNewLine();
            }

        }

        private void ProcessType(string ns, Type type) {
            Type                baseType = type.BaseType;
            Type[]              interfaces = FilterInheritedInterfaces( type );
            PropertyInfo[]      properties = type.GetProperties(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            MethodInfo[]        methods = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            EventInfo[]         events = type.GetEvents();
            FieldInfo[]         fields = type.GetFields(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            ConstructorInfo[]   constructors = type.GetConstructors(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            bool                isDelegate = false;
            MethodInfo          delegateInvoke = null;

            MemberInfoSorter sort = new MemberInfoSorter();

            Console.WriteLine(string.Format(ProcessingMessage, type.FullName.Replace( '$', '.' ) ));

            Array.Sort(fields,sort);
            Array.Sort(events, sort);
            Array.Sort(methods, sort);
            Array.Sort(properties, sort);

            string name = type.Name;
            string fullName = ns + "." + name;

            OutputStartOpenTag("class");
            OutputTagAttribute("name", name.Replace( '$', '.' ));
            if ((baseType == typeof(Delegate)
                 || baseType == typeof(MulticastDelegate))
                && (type != typeof(Delegate) && type != typeof(MulticastDelegate))) {

                OutputTagAttribute("type", "delegate");
                isDelegate = true;

                for (int i=0; i<methods.Length; i++) {
                    if (methods[i].Name.Equals("Invoke")) {
                        delegateInvoke = methods[i];
                        break;
                    }
                }
            }
            else {
                OutputTagAttribute("type", TypeOfType(type));
            }

            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
                OutputStartOpenTag( "assembly" );
                OutputTagAttribute( "name", type.Module.Name );
                OutputEndOpenTagNoClose();
                OutputNewLine();

                OutputTypeHierarchy(type);

                CommentEntry comment = docloader.FindType( type );
                if ( comment != null )
                    Console.WriteLine( string.Format( SourceLoadedMessage, type.FullName.Replace( '$', '.' ) ) );

                PushErrorContext( new SourceErrorInfo( type.FullName, null, null ) );
                
                try {
                    OutputStartOpenTag("access");
                    OutputTagAttribute("public", (IsPublicClass((int)type.Attributes)).ToString());
                    OutputTagAttribute("private", (!IsPublicClass((int)type.Attributes)).ToString());
                    OutputTagAttribute("sealed", (IsSealedClass((int)type.Attributes)).ToString());
                    OutputTagAttribute("abstract", (IsAbstractClass((int)type.Attributes)).ToString());
                    OutputEndOpenTagNoClose();
                    OutputNewLine();
                    
                    // BL changes {{
                    for ( int i = 0; i < outputGenerators.Length; i++ ) 
                    {                        
                        if ( outputGenerators[i].GenerateOutput( type ) )
                        {
                           OutputStartOpenTag( "syntax" );
                           OutputTagAttribute( "lang", outputGenerators[i].Language );
                           OutputEndOpenTag();
                           OutputNewLine();
                           IndentLevel++;
                           try 
                           {
                               OutputLineStart();
                               outputGenerators[i].OutputTypeDeclaration( outputWriter, ns, name, type, (int)type.Attributes, baseType, interfaces, isDelegate, delegateInvoke );
                               OutputNewLine();
                           }
                           finally 
                           {
                               IndentLevel--;
                               OutputLineStart();
                               OutputCloseTag( "syntax" );
                               OutputNewLine();
                           }
                        }                        
                     }
                     // BL changes }}

                    if (comment != null) {
                        OutputLineStart();
                        OutputSimpleDocComment(comment.Comment);
                        OutputNewLine();
                    }
                    
                    // if this is a delegate, skip the members (per lisahe) since
                    // they're auto-gen'd by the compiler and never have any docs.
                    if (!isDelegate) {
                        OutputStartOpenTag("members");
                        OutputEndOpenTag();
                        OutputNewLine();
                        IndentLevel++;
                        try {
                            if (fields.Length > 0) {
                                for (int i=0; i<fields.Length; i++) {
                                    if (ShouldProcessField(type, fields[i])) {
                                        PushErrorContext(new SourceErrorInfo(null, fields[i].Name, "Field"));
                                        try {
                                            ProcessField(ns, type, fields[i]);
                                        }
                                        finally {
                                            PopErrorContext();
                                        }
                                    }
                                }
                            }
    
                            if (constructors.Length > 0) {
                                for (int i=0; i<constructors.Length; i++) {
                                    if (ShouldProcessConstructor(type, constructors[i])) {
                                        PushErrorContext(new SourceErrorInfo(null, constructors[i].Name, "Constructor"));
                                        try {
                                            ProcessConstructor(ns, type, constructors[i]);
                                        }
                                        finally {
                                            PopErrorContext();
                                        }
                                    }
                                }
                            }
    
                            if (properties.Length > 0) {
                                for (int i=0; i<properties.Length; i++) {
                                    if (ShouldProcessProperty(type, properties[i])) {
                                        PushErrorContext(new SourceErrorInfo(null, properties[i].Name, "Property"));
                                        try {
                                            ProcessProperty(ns, type, properties[i]);
                                        }
                                        finally {
                                            PopErrorContext();
                                        }
                                    }
                                }
                            }
    
                            if (methods.Length > 0) {
                                for (int i=0; i<methods.Length; i++) {
                                    if (ShouldProcessMethod(type, methods[i])) {
                                        PushErrorContext(new SourceErrorInfo(null, methods[i].Name, "Method"));
                                        try {
                                            ProcessMethod(ns, type, methods[i]);
                                        }
                                        finally {
                                            PopErrorContext();
                                        }
                                    }
                                }
                            }
                        }
                        finally {
                            IndentLevel--;
                            OutputLineStart();
                            OutputCloseTag("members");
                            OutputNewLine();
                        }
                    }
                }
                finally {
                    PopErrorContext();
                }

            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("class");
                OutputNewLine();
            }

        }

        private void ProcessField(string ns, Type type, FieldInfo fi) {
            int attributes = (int)fi.Attributes;
            string name = fi.Name;
            string fieldTypeFullName = GetUnrefTypeName( fi.FieldType );

            if (name.Equals("<value>")) {
                name = ".value";
            }

            OutputStartOpenTag("field");
            OutputTagAttribute("name", name);
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;
            try {
                OutputMethodAttributeTag(attributes, (fi.DeclaringType == type), fi.DeclaringType);

                OutputStartOpenTag("fieldvalue");
                OutputTagAttribute("type", fieldTypeFullName.Replace( '$', '.' ));
                OutputEndOpenTagNoClose();
                OutputNewLine();

               for ( int i = 0; i < outputGenerators.Length; i++ )
               {
                  //if ( outputGenerators[i].GenerateOutput( type ) ) // Fields
                  {
                     OutputStartOpenTag( "syntax" );
                     OutputTagAttribute( "lang", outputGenerators[i].Language );
                     OutputEndOpenTag();
                     OutputNewLine();
                     IndentLevel++;

                     try 
                     {
                        OutputLineStart();
                        outputGenerators[i].OutputFieldDeclaration( outputWriter, ns, fi, name, fieldTypeFullName, attributes );
                        OutputNewLine();
                     }
                     finally 
                     {
                        IndentLevel--;
                        OutputLineStart();
                        OutputCloseTag( "syntax" );
                        OutputNewLine();
                     }
                  }
               }

               CommentEntry comment = docloader.FindField( fi );
               if ( comment != null )
               {
                  OutputLineStart();
                  OutputSimpleDocComment( comment.Comment );
                  OutputNewLine();
               }
            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag( "field" );
                OutputNewLine();
            }
        }

         private void ProcessConstructor( string ns, Type type, ConstructorInfo ci )
         {
            int attributes = (int)ci.Attributes;
            ParameterInfo[] parameters = ci.GetParameters();
            string name = ci.Name;

            OutputStartOpenTag( "constructor" );
            OutputTagAttribute( "name", name );
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try 
            {
               OutputMethodAttributeTag( ci );
             
               for ( int i = 0; i < outputGenerators.Length; i++ )
               {                  
                  OutputStartOpenTag( "syntax" );
                  OutputTagAttribute( "lang", outputGenerators[i].Language );
                  OutputEndOpenTag();
                  OutputNewLine();
                  IndentLevel++;
                  try 
                  {
                     OutputLineStart();
                     outputGenerators[i].OutputConstructorDeclaration( outputWriter, ns, ci, name, attributes, parameters );
                     OutputNewLine();
                  }
                  finally 
                  {
                     IndentLevel--;
                     OutputLineStart();
                     OutputCloseTag( "syntax" );
                     OutputNewLine();
                  }
               }

               Element[] paramDocComments = noParams;
               CommentEntry comment = docloader.FindMethod( ci );
               if ( comment != null )
               {
                  OutputLineStart();
                  paramDocComments = OutputParamDocComment( comment.Comment );
                  OutputNewLine();
               }
               ProcessParameters( ns, parameters, paramDocComments );
            }
            finally
            {
               IndentLevel--;
               OutputLineStart();
               OutputCloseTag( "constructor" );
               OutputNewLine();
            }
         }

        private void ProcessProperty(string ns, Type type, PropertyInfo property) {
            int attributes = (int)property.Attributes;
            string name = property.Name;
            string propertyTypeFullName = GetUnrefTypeName( property.PropertyType );
            ParameterInfo[] parameters = noParamInfos;
            MethodInfo getAccessor = property.GetGetMethod(true);
            MethodInfo setAccessor = property.GetSetMethod(true);
            if (getAccessor != null) {
                parameters = getAccessor.GetParameters();
            }

            if (getAccessor == null && setAccessor == null) {
                Console.Error.WriteLine("Invalid property decalaration '" + type.FullName + "." + property.Name + "' no get or set method defined");
                return;
            }

            OutputStartOpenTag("property");
            OutputTagAttribute("name", name);
            OutputTagAttribute("type", propertyTypeFullName.Replace( '$', '.' ));
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
                if (getAccessor != null) {
                    OutputMethodAttributeTag(getAccessor);
                }
                else if (setAccessor != null) {
                    OutputMethodAttributeTag(setAccessor);
                }

                OutputStartOpenTag("behavior");
                if (getAccessor != null && setAccessor != null) {
                    OutputTagAttribute("type", "readwrite");
                }
                else if (getAccessor != null) {
                    OutputTagAttribute("type", "read");
                }
                else if (setAccessor != null) {
                    OutputTagAttribute("type", "write");
                }
                OutputEndOpenTagNoClose();
                OutputNewLine();

               for ( int i = 0; i < outputGenerators.Length; i++ ) 
               {
                  //if ( outputGenerators[i].GenerateOutput( type ) ) // Properties
                  {
                     OutputStartOpenTag( "syntax" );
                     OutputTagAttribute( "lang", outputGenerators[i].Language );
                     OutputEndOpenTag();
                     OutputNewLine();
                     IndentLevel++;

                     try 
                     {
                        OutputLineStart();
                        outputGenerators[ i ].OutputPropertyDeclaration(outputWriter, ns, property, name, propertyTypeFullName, attributes, getAccessor, setAccessor, parameters, type.IsInterface);
                        OutputNewLine();
                     }
                     finally 
                     {
                        IndentLevel--;
                        OutputLineStart();
                        OutputCloseTag("syntax");
                        OutputNewLine();
                     }
                  }
               }

               Element[] paramDocComments = noParams;
                
               CommentEntry comment = docloader.FindProperty( property );
               if ( comment != null ) 
               {
                  OutputLineStart();
                  paramDocComments = OutputParamDocComment( comment.Comment );
                  OutputNewLine();
               }
               ProcessParameters( ns, parameters, paramDocComments );
            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("property");
                OutputNewLine();
            }
        }

        private void ProcessParameters(string ns, ParameterInfo[] parameters, Element[] paramDocComments) {
            string[] paramDocCommentNames = new string[paramDocComments.Length];
            for (int i=0; i<paramDocCommentNames.Length; i++) {
                paramDocCommentNames[i] = GetParamElementName(paramDocComments[i]);
            }
            
            if (WFCGenUEGenerator.GenDCXML.Enabled) {
               Debug.WriteLine( "parameters for processing:  " + parameters.Length );
               Debug.WriteLine( "paramDocComments for processing:  " + paramDocComments.Length );
            }

            for (int i=0; i<parameters.Length; i++) {
                Element paramDocComment = null;
                string name = parameters[i].Name;

                for (int j=0; j<paramDocComments.Length; j++) {
                    if (paramDocCommentNames[j] != null
                        && string.Compare(paramDocCommentNames[j], name, true, CultureInfo.InvariantCulture) == 0) {

                        paramDocComment = paramDocComments[j];
                        break;
                    }
                }

                ProcessParameter(ns, parameters[i], name, paramDocComment);
            }
        }

        private void ProcessParameter(string ns, ParameterInfo param, string name, Element paramDocComment) {
            int attributes = (int)param.Attributes;

            OutputStartOpenTag("param");
            OutputTagAttribute("name", name);
            OutputTagAttribute("type", GetUnrefTypeName( param.ParameterType ).Replace( '$', '.' ) );
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
                if (paramDocComment != null) {
                    OutputLineStart();
                    paramDocComment.OutputChildXml(outputWriter);
                    OutputNewLine();
                }
            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("param");
                OutputNewLine();
            }
        }

        private void ProcessMethod(string ns, Type type, MethodInfo mi) {
            ParameterInfo[] parameters = null;
            try {
                parameters = mi.GetParameters();
            }
            catch (Exception e) {
                Console.Error.WriteLine("Failed to get parameters for '" + type.FullName + "." + mi.Name + "'");
                Console.Error.WriteLine(e.ToString());
                parameters = new ParameterInfo[0];
            }

            int attributes = (int)mi.Attributes;
            string name = mi.Name;
            string returnTypeFullName = GetUnrefTypeName( mi.ReturnType ).Replace( '$', '.' );
            Element[] paramDocComments = noParams;
            string description = null;

            CommentEntry comment = docloader.FindMethod( mi );
            if ( comment != null )
               description = comment.Comment;

            OutputStartOpenTag( "method" );
            OutputTagAttribute( "name", mi.Name );
            OutputTagAttribute( "type", returnTypeFullName.Replace( '$', '.' ) );
            OutputEndOpenTag();
            OutputNewLine();
            IndentLevel++;

            try {
               OutputMethodAttributeTag( mi );
                
               for ( int i = 0; i < outputGenerators.Length; i++ )
               {
                  // BL changes {{
                  if ( outputGenerators[i].GenerateOutput( name ) )
                  {
                     OutputLineStart();
                     OutputStartOpenTag( "syntax" );
                     OutputTagAttribute( "lang", outputGenerators[i].Language );
                     OutputEndOpenTag();
                     OutputNewLine();
                     IndentLevel++;

                     try 
                     {
                        OutputLineStart();
                  
                        if ( name.StartsWith( "op_" ) )  // Handle operators
                           outputGenerators[i].OutputOperatorDeclaration( outputWriter, ns, mi, name, returnTypeFullName,
                                                                          attributes, parameters, type.IsInterface );
                        else
                           outputGenerators[i].OutputMethodDeclaration( outputWriter, ns, mi, name, returnTypeFullName,
                                                                        attributes, parameters, type.IsInterface );
                     
                        OutputNewLine();
                     }   
                     finally 
                     {
                        IndentLevel--;
                        OutputLineStart();
                        OutputCloseTag( "syntax" );
                        OutputNewLine();
                     }                  
                  }
                  // BL changes }}
               }

               if ( description != null && description.Length > 0 )
               {
                  OutputLineStart();
                  paramDocComments = OutputParamDocComment( description );
                  OutputNewLine();
               }

               ProcessParameters( ns, parameters, paramDocComments );
            }
            finally {
                IndentLevel--;
                OutputLineStart();
                OutputCloseTag("method");
                OutputNewLine();
            }
        }

        private void PushErrorContext(SourceErrorInfo info) {
            if (errorInfo == null) {
                errorInfo = info;
            }
            else {
                info.Parent = errorInfo;
                errorInfo = info;
            }
        }

        private void PopErrorContext() {
            if (errorInfo != null) {
                SourceErrorInfo old = errorInfo;
                errorInfo = errorInfo.Parent;
                old.Parent = null;
            }
        }

        // BL changes {{
        private bool ShouldProcessMethod( Type reflect, MethodInfo method )
        {
           // Omit property accessors
           if ( ( method.Attributes & MethodAttributes.SpecialName ) == MethodAttributes.SpecialName )
           {
              if ( method.Name.StartsWith( "op_" ) )  // Handle operators
                 return true;
              return false;
           }
           
           if ( !includeAllMembers )
           {
              if ( !( method.IsPublic || method.IsFamily ||
                      method.IsFamilyOrAssembly || method.IsFamilyAndAssembly ) )
                 return false;              
           }
           return true;
        }
        // BL changes }}

        private bool ShouldProcessField(Type reflect, FieldInfo field) {
            if (!includeAllMembers) {
                if (field.IsSpecialName ||
                     !(field.IsPublic || field.IsFamily || field.IsFamilyOrAssembly || field.IsFamilyAndAssembly)) {
                    return false;
                }
            }

            return true;
        }
        
        private bool ShouldProcessConstructor( Type reflect, ConstructorInfo constructor ) 
        {
           if ( !includeAllMembers ) 
           {
              if ( !( constructor.IsPublic || constructor.IsFamily ||
                      constructor.IsFamilyOrAssembly || constructor.IsFamilyAndAssembly ) )
                 return false;              
           }

           // BL changes {{
           // Don't show constructors for abstract classes (bugid 32170)
           if ( ( reflect.Attributes & TypeAttributes.Abstract ) != 0 )
              return false;
           // BL changes }}

           return true;
        }        

        private bool ShouldProcessProperty(Type reflect, PropertyInfo property) {
            MethodInfo mi = property.GetGetMethod( true );
            
            if (mi == null) {
                mi = property.GetSetMethod( true );
            }
            
            if (mi == null) {
                return false;
            }

            if (!includeAllMembers) {
                if (!(mi.IsPublic
                      || mi.IsFamily
                      || mi.IsFamilyOrAssembly
                      || mi.IsFamilyAndAssembly)) {

                    return false;
                }
            }

            return true;
        }

        private bool ShouldProcessType(Type type) {
            if (type == null) {
                return false;
            }
            
            if (type.Namespace == null) {
                return false;
            }

            if (!includeAllMembers) {
                if (!type.IsPublic && !type.IsNestedPublic) {
                    return false;
                }
            }

            if (searchStrings.Length > 0) {
                string name = ConvertSIGToReadable(type.FullName);
                int i = 0;

                if (name.Equals("System.Windows.Forms.MaskedEdit")) {
                    return false;
                }

                if (useRegex) {
                    if (searchRegexes == null) {
                        searchRegexes = new Regex[ searchStrings.Length ];
                        for (i = 0; i < searchRegexes.Length; i++)
                            searchRegexes[ i ] = new Regex( searchStrings[ i ] );
                    }

                    for (i = 0; i < searchRegexes.Length; i++) {
                        if (searchRegexes[ i ].IsMatch( name ))
                            return true;
                    }
                }
                else {
                    for (i = 0; i < searchStrings.Length; i++) {
                        if (useNamespaces) {
                            if (type.Namespace.Equals( searchStrings[ i ] ))
                                return true;
                        }
                        else {
                            if (name.IndexOf( searchStrings[ i ]) != -1)
                                return true;
                        }
                    }
                }
                return false;
            }

            return true;
        }

        private string TypeOfType(Type type) {
            int cls = (int)type.Attributes & (int)TypeAttributes.ClassSemanticsMask;

            if ((cls & (int)TypeAttributes.Interface) != 0) {
                return "interface";
            }
            else if (type.BaseType == typeof( System.Enum )) {      
                return "enumeration";
            }                                        
            else if (type.BaseType == typeof( System.ValueType  )) {                
                return "structure";
            }            
            else {
                return "class";
            }
        }

        private class Stack {
            class Node {
                public object data;
                public Node next;

                public Node(object data, Node next) {
                    this.data = data;
                    this.next = next;
                }
            }

            Node head = null;

            public void Push(object value) {
                if (head == null) {
                    head = new Node(value, null);
                }
                else {
                    head = new Node(value, head);
                }
            }

            public object Pop() {
                if (head != null) {
                    object r = head.data;
                    head = head.next;
                    return r;
                }
                return null;
            }
        }
    }

    class MemberInfoSorter : IComparer {
        public int Compare(object left, object right) {
            return string.Compare(((MemberInfo)left).Name, ((MemberInfo)right).Name, false, CultureInfo.InvariantCulture);
        }
    }

    class SourceErrorInfo {
        private SourceErrorInfo parent;
        private readonly string fileName = null;
        private readonly string memberName = null;
        private readonly string memberType = null;
        private readonly int lineNumber = -1;
        private readonly int columnNumber = -1;

        public SourceErrorInfo(string fileName, string memberName, string memberType) {
            this.fileName = fileName;
            this.memberName = memberName;
            this.memberType = memberType;
        }

        public string FileName {
            get {
                if (fileName == null) {
                    if (parent != null) {
                        return parent.FileName;
                    }
                    else {
                        return "";
                    }
                }
                return fileName;
            }
        }

        public string MemberName {
            get {
                if (memberName == null) {
                    return "";
                }
                return memberName;
            }
        }

        public string MemberType {
            get {
                if (memberType == null) {
                    return "";
                }
                return memberType;
            }
        }

        public SourceErrorInfo Parent {
            get {
                return parent;
            }
            set {
                parent = value;
            }
        }

        public int LineNumber {
            get {
                return lineNumber;
            }
        }

        public int ColumnNumber {
            get {
                return columnNumber;
            }
        }

        public void OutputError(TextWriter tw, string message) {
            tw.Write(FileName);
            tw.Write("(");
            tw.Write((Math.Max(LineNumber, 0)).ToString());
            tw.Write(",");
            tw.Write((Math.Max(ColumnNumber, 0)).ToString());
            tw.Write(")");
            tw.Write(" : error WFCUE0001: ");
            tw.Write(MemberType);
            tw.Write(" ");
            tw.Write(MemberName);
            tw.Write(", ");
            tw.Write(message);
        }
    }

    namespace DocComment {      
        enum ElementType {
            Alert,              //  1
            Code,               //  2
            Desc,               //  3
            DescEvent,          //  4
            Doc,                //  5
            EmbedCode,          //  6
            Example,            //  7
            Exception,          //  8
            Hidden,             //  9
            InternalOnly,       // 10
            Item,               // 11
            Keyword,            // 12
            List,               // 13
            ListHeader,         // 14
            NewPara,            // 15
            Overload,           // 16
            Param,              // 17
            ParamRef,           // 18
            Permission,         // 19
            PropValue,          // 20
            Remarks,            // 21
            RemarksEvent,       // 22
            RetValue,           // 23
            See,                // 24
            SeeAlso,            // 25
            Term,               // 26
            Text,               // 27
            Summary,            // 28
            EventSummary,       // 29
            Returns,            // 30
            Para,               // 31
            Value,              // 32
            Member,             // 33
            Description,        // 34
            Note,               // 35
            SeeAlsoEvent,
            ClassOnly,
            SummaryEvent,
            ExampleEvent,
            KeywordEvent,
            Bold,
            Span,
            Comment,
            HideInheritance,
            C,
        }

        class Element {
            protected readonly ElementType type;
            private ArrayList children;
            private Hashtable attributes;
            private string text;
            private Element parent;

            private static string EncodeCharData(string text) {
                if (text.IndexOf('>') != -1 || text.IndexOf('<') != -1 || text.IndexOf('&') != -1 || text.IndexOf('"') != -1) {
                    StringBuilder sb = new StringBuilder();
                    
                    if (text != null) {
                        int len = text.Length;
                        for (int i = 0; i < len; i++) {
                            char ch = text[i];
                            switch (ch) {
                            case '<':
                                sb.Append( "&lt;" );
                                break;
                            case '>':
                                sb.Append( "&gt;" );
                                break;
                            case '&':
                                sb.Append( "&amp;" );
                                break;
                            case '"':
                                sb.Append( "&quot;" );
                                break;
                            default:
                                sb.Append( ch );
                                break;
                            }
                        }
                    }
                    return sb.ToString();
                }
                else
                    return text;
            }
        
            protected Element(ElementType type) {
                this.type = type;
            }

            public Hashtable Attributes {
                get {
                    if (attributes == null) {
                        attributes = new Hashtable();
                    }
                    return attributes;
                }
            }

            public ArrayList Children {
                get {
                    if (children == null) {
                        children = new ArrayList();
                    }
                    return children;
                }
            }

            public bool HasChildren {
                get {
                    if (children != null) {
                        return true;
                    }
                    return false;
                }
            }

            public Element Parent {
                get {
                    return parent;
                }
                set {
                    if (parent != null) {
                        parent.Children.Remove(this);
                    }
                    parent = value;
                    if (parent != null) {
                        parent.Children.Add(this);
                    }
                }
            }

            internal Element InternalParent {
                get {
                    return parent;
                }
                set {
                    parent = value;
                }
            }

            public string Text {
                get {
                    return text;
                }
                set {
                    text = value;
                }
            }

            public ElementType Type {
                get {
                    return type;
                }
            }

            public static Element Create(string type) {
                if (type.Equals("alert")) {
                    return Create(ElementType.Alert);
                }
                if (type.Equals("code")) {
                    return Create(ElementType.Code);
                }
                if (type.Equals("desc")) {
                    return Create(ElementType.Desc);
                }
                if (type.Equals("descevent")) {
                    return Create(ElementType.DescEvent);
                }
                if (type.Equals("doc")) {
                    return Create(ElementType.Doc);
                }
                if (type.Equals("embedcode")) {
                    return Create(ElementType.EmbedCode);
                }
                if (type.Equals("example")) {
                    return Create(ElementType.Example);
                }
                if (type.Equals("exception")) {
                    return Create(ElementType.Exception);
                }
                if (type.Equals("hidden")) {
                    return Create(ElementType.Hidden);
                }
                if (type.Equals("internalonly")) {
                    return Create(ElementType.InternalOnly);
                }
                if (type.Equals("item")) {
                    return Create(ElementType.Item);
                }
                if (type.Equals("keyword")) {
                    return Create(ElementType.Keyword);
                }
                if (type.Equals("list")) {
                    return Create(ElementType.List);
                }
                if (type.Equals("listheader")) {
                    return Create(ElementType.ListHeader);
                }
                if (type.Equals("newpara")) {
                    return Create(ElementType.NewPara);
                }
                if (type.Equals("overload")) {
                    return Create(ElementType.Overload);
                }
                if (type.Equals("param")) {
                    return Create(ElementType.Param);
                }
                if (type.Equals("paramref")) {
                    return Create(ElementType.ParamRef);
                }
                if (type.Equals("permission")) {
                    return Create(ElementType.Permission);
                }
                if (type.Equals("propvalue")) {
                    return Create(ElementType.PropValue);
                }
                if (type.Equals("remarks")) {
                    return Create(ElementType.Remarks);
                }
                if (type.Equals("remarksevent")) {
                    return Create(ElementType.RemarksEvent);
                }
                if (type.Equals("retvalue")) {
                    return Create(ElementType.RetValue);
                }
                if (type.Equals("see")) {
                    return Create(ElementType.See);
                }
                if (type.Equals("seealso")) {
                    return Create(ElementType.SeeAlso);
                }
                if (type.Equals("term")) {
                    return Create(ElementType.Term);
                }
                if (type.Equals("text")) {
                    return Create(ElementType.Text);
                }
                if (type.Equals("summary")) {
                    return Create(ElementType.Summary);
                }
                if (type.Equals("eventsummary")) {
                    return Create(ElementType.EventSummary);
                }
                if (type.Equals("returns")) {
                    return Create(ElementType.Returns);
                }
                if (type.Equals("para")) {
                    return Create(ElementType.Para);
                }
                if (type.Equals("value")) {
                    return Create(ElementType.Value);
                }
                if (type.Equals("member")) {
                    return Create(ElementType.Member);
                }
                if (type.Equals("description")) {
                    return Create(ElementType.Description);
                }
                if (type.Equals("note")) {
                    return Create(ElementType.Note);
                }
                if (type.Equals("seealsoevent")) {
                    return Create(ElementType.SeeAlsoEvent);
                }
                if (type.Equals("classonly")) {
                    return Create(ElementType.ClassOnly);
                }
                if (type.Equals("summaryevent")) {
                    return Create(ElementType.SummaryEvent);
                }
                if (type.Equals("exampleevent")) {
                    return Create(ElementType.ExampleEvent);
                }
                if (type.Equals("keywordevent")) {
                    return Create(ElementType.KeywordEvent);
                }
                if (type.Equals("b")) {
                    return Create(ElementType.Bold);
                }
                if (type.Equals("span")) {
                    return Create(ElementType.Span);
                }
                if (type.Equals("!--")) {
                    return Create(ElementType.Comment);
                }
                if (type.Equals("hideinheritance")) {
                    return Create(ElementType.HideInheritance);
                }
                if (type.Equals("c")) {
                    return Create(ElementType.C);
                }
                
                throw new Exception("bad doc comment, element type: " + type);
            }

            public static Element CreateText(string text) {
                Element e = Create(ElementType.Text);
                e.Text = Element.EncodeCharData( text );
                return e;
            }

            public static Element CreateComment(string text) {
                Element e = Create(ElementType.Comment);
                e.Text = Element.EncodeCharData( text );
                return e;
            }

            public static Element Create(ElementType type) {
                switch (type) {
                    case ElementType.Alert:
                    case ElementType.Code:
                    case ElementType.Desc:
                    case ElementType.DescEvent:
                    case ElementType.Doc:
                    case ElementType.EmbedCode:
                    case ElementType.Example:
                    case ElementType.Exception:
                    case ElementType.Hidden:
                    case ElementType.InternalOnly:
                    case ElementType.Item:
                    case ElementType.Keyword:
                    case ElementType.List:
                    case ElementType.ListHeader:
                    case ElementType.NewPara:
                    case ElementType.Overload:
                    case ElementType.Param:
                    case ElementType.ParamRef:
                    case ElementType.Permission:
                    case ElementType.PropValue:
                    case ElementType.Remarks:
                    case ElementType.RemarksEvent:
                    case ElementType.RetValue:
                    case ElementType.See:
                    case ElementType.SeeAlso:
                    case ElementType.Term:
                    case ElementType.Text:
                    case ElementType.Summary:
                    case ElementType.EventSummary:
                    case ElementType.Returns:
                    case ElementType.Para:
                    case ElementType.Value:
                    case ElementType.Member:
                    case ElementType.Description:
                    case ElementType.Note:
                    case ElementType.SeeAlsoEvent:
                    case ElementType.ClassOnly:
                    case ElementType.SummaryEvent:
                    case ElementType.ExampleEvent:
                    case ElementType.KeywordEvent:
                    case ElementType.Bold:
                    case ElementType.Span:
                    case ElementType.Comment:
                    case ElementType.HideInheritance:
                    case ElementType.C:
                    default:
                        return new Element(type);
                }
            }

            public void OutputChildXml(TextWriter tw) {
                if (children != null) {
                    IEnumerator e = children.GetEnumerator();
                    if (e != null) {
                        while (e.MoveNext()) {
                            ((Element)e.Current).OutputXml(tw);
                        }
                    }
                }
            }

            public void OutputXml(TextWriter tw) {
                if (type == ElementType.Text) {
                    tw.Write(text);
                    return;
                }
                if (type == ElementType.Comment) {
                    tw.Write( "<!--" );
                    tw.Write( text );
                    tw.Write( "-->" );
                    return;
                }

                tw.Write("<");
                OutputTagName(tw);

                if (attributes != null) {
                    IDictionaryEnumerator de = (IDictionaryEnumerator)attributes.GetEnumerator();
                    while (de.MoveNext()) {
                        tw.Write(" ");

                        tw.Write((string)de.Key);
                        tw.Write("=\"");
                        tw.Write( Element.EncodeCharData( (string) de.Value ) );
                        tw.Write("\"");
                    }
                }

                if (children != null && children.Count > 0) {
                    tw.Write(">");

                    OutputChildXml(tw);

                    tw.Write("</");
                    OutputTagName(tw);
                    tw.Write(">");
                }
                else {
                    tw.Write("/>");
                }
            }

            public string FetchTagName() {
                switch (type) {
                    case ElementType.Alert:
                        return "alert";
                    case ElementType.Code:
                        return "code";
                    case ElementType.Desc:
                        return "desc";
                    case ElementType.DescEvent:
                        return "descevent";
                    case ElementType.Doc:
                        return "doc";
                    case ElementType.EmbedCode:
                        return "embedcode";
                    case ElementType.Example:
                        return "example";
                    case ElementType.Exception:
                        return "exception";
                    case ElementType.Hidden:
                        return "hidden";
                    case ElementType.InternalOnly:
                        return "internalonly";
                    case ElementType.Item:
                        return "item";
                    case ElementType.Keyword:
                        return "keyword";
                    case ElementType.List:
                        return "list";
                    case ElementType.ListHeader:
                        return "listheader";
                    case ElementType.NewPara:
                        return "newpara";
                    case ElementType.Overload:
                        return "overload";
                    case ElementType.Param:
                        return "param";
                    case ElementType.ParamRef:
                        return "paramref";
                    case ElementType.Permission:
                        return "permission";
                    case ElementType.PropValue:
                        return "propvalue";
                    case ElementType.Remarks:
                        return "remarks";
                    case ElementType.RemarksEvent:
                        return "remarksevent";
                    case ElementType.RetValue:
                        return "retvalue";
                    case ElementType.See:
                        return "see";
                    case ElementType.SeeAlso:
                        return "seealso";
                    case ElementType.Term:
                        return "term";
                    case ElementType.Summary:
                        return "summary";
                    case ElementType.EventSummary:
                        return "eventsummary";
                    case ElementType.Returns:
                        return "returns";
                    case ElementType.Para:
                        return "para";
                    case ElementType.Value:
                        return "value";
                    case ElementType.Member:
                        return "member";
                    case ElementType.Description:
                        return "description";
                    case ElementType.Note:
                        return "note";
                    case ElementType.SeeAlsoEvent:
                        return "seealsoevent";
                    case ElementType.ClassOnly:
                        return "classonly";
                    case ElementType.SummaryEvent:
                        return "summaryevent";
                    case ElementType.ExampleEvent:
                        return "exampleevent";
                    case ElementType.KeywordEvent:
                        return "keywordevent";
                    case ElementType.Bold:
                        return "b";
                    case ElementType.Span:
                        return "span";
                    case ElementType.Comment:
                        return "!--";
                    case ElementType.HideInheritance:
                        return "hideinheritance";
                    case ElementType.C:
                        return "c";
                    default:
                        return "(none)";
                }
            }
            
            private void OutputTagName(TextWriter tw) {
                tw.Write( FetchTagName() );
            }
        }

        class Parser {
            private Element root = null;
            private Element currentElement = null;
            private string currentAttribute = null;

            public Element RootElement {
                get {
                    return root;
                }
                set {
                    root = value;
                }
            }

            public void CData(string text) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<cdata>");
                    Debug.Indent();
                    Debug.WriteLine(text);
                    Debug.Unindent();
                    Debug.WriteLine("</cdata>");
                }
            }

            public void CharEntity(string name, char value) {
            }

            public void Comment(string body) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<!-- " + body + " -->");
                }
            }

            public void EndAttribute(string prefix, string name, string urn) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.Unindent();
                    Debug.WriteLine("</attribute>");
                }

                currentAttribute = null;
            }

            public void EndElement(string prefix, string name, string urn) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.Unindent();
                    Debug.WriteLine("</element>");
                }

                if (currentElement != null) {
                    currentElement = currentElement.Parent;
                }
            }

            public void Entity(string name) {
            }

            public void Finish() {
                if (root != null) {
                    FixupTree(root);
                }
            }

            private void FixupTree(Element current) {
                if (current == null) {
                    return;
                }

                if (current.Type == ElementType.Desc
                    || current.Type == ElementType.Summary
                    || current.Type == ElementType.EventSummary
                    || current.Type == ElementType.Item
                    || current.Type == ElementType.Remarks
                    || current.Type == ElementType.RemarksEvent
                    || current.Type == ElementType.Returns
                    || current.Type == ElementType.RetValue
                    || current.Type == ElementType.Param) {

                    if (current.HasChildren) {
                        ArrayList children = current.Children;

                        if (((Element)children[ 0 ]).Type == ElementType.Text
                            || ((Element)children[ 0 ]).Type == ElementType.See) {

                            Element fixup = Element.Create(ElementType.Para);
                            Element child = null;
                            int i;

                            for (i=0; i<children.Count; i++) {
                                child = (Element)children[i];

                                if (child != null) {
                                    if (child.Type == ElementType.Para)
                                        break;

                                    child.InternalParent = fixup;
                                    fixup.Children.Add(child);
                                }
                            }

                            for (int j = 0; j < i; ++j) {
                                children.RemoveAt(0);
                            }

                            fixup.InternalParent = current;
                            children.Insert( 0, fixup );
                        }
                    }
                }
                else {
                    if (current.HasChildren) {
                        IEnumerator e = current.Children.GetEnumerator();
                        while (e.MoveNext()) {
                            FixupTree((Element)e.Current);
                        }
                    }
                }
            }

            public void PI(string target, string body) {
            }

            public void Start() {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<!-- reset root -->");
                }
                root = null;
                currentElement = null;
                currentAttribute = null;
            }

            public void StartAttribute(string prefix, string name, string urn) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<attribute prefix='" + prefix + "' name='" + name + "' urn='" + urn + "'>");
                    Debug.Indent();
                }

                currentAttribute = name;
            }

            public void StartElement(string prefix, string name, string urn) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<element prefix='" + prefix + "' name='" + name + "' urn='" + urn + "'>");
                    Debug.Indent();
                }

                string lowerName = name.ToLower(CultureInfo.InvariantCulture);

                if (currentElement == null) {
                    if (WFCGenUEGenerator.GenDCXML.Enabled) {
                        Debug.WriteLine("<!-- element set to be root... name='" + name + "' -->");
                    }
                    root = Element.Create(lowerName);
                    currentElement = root;
                }
                else {
                    Element e = Element.Create(lowerName);
                    e.Parent = currentElement;
                    currentElement = e;
                }
            }

            public void Text(string text) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<text>");
                    Debug.Indent();
                    Debug.WriteLine(text);
                    Debug.Unindent();
                    Debug.WriteLine("</text>");
                }

                if (currentAttribute != null && currentElement != null) {
                    currentElement.Attributes[currentAttribute] = text;
                }
                else if (currentElement != null) {
                    Element.CreateText(text).Parent = currentElement;
                }
            }

            public void Whitespace(string text) {
                if (WFCGenUEGenerator.GenDCXML.Enabled) {
                    Debug.WriteLine("<whitespace>");
                    Debug.Indent();
                    Debug.WriteLine(text);
                    Debug.Unindent();
                    Debug.WriteLine("</whitespace>");
                }
            }

            internal void Parse(XmlReader reader) {
                while( reader.Read() ) {
                    switch (reader.NodeType) {
                        case XmlNodeType.Element:
                            StartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                            while( reader.MoveToNextAttribute() ) {
                                StartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                                Text(reader.Value);
                                EndAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                            }
                            break;

                        case XmlNodeType.EndElement:
                            EndElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                            break;

                        case XmlNodeType.Whitespace:
                            Whitespace(reader.Value);
                            break;

                        case XmlNodeType.Text:
                            Text(reader.Value);
                            break;

                        case XmlNodeType.CDATA:
                            CData(reader.Value);
                            break;

                        case XmlNodeType.Comment:
                            Comment(reader.Value);
                            break;

                        case XmlNodeType.ProcessingInstruction:
                            PI(reader.Name, reader.Value);
                            break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\resources\resxresourcewriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResXResourceWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Resources {

    using System.Diagnostics;
    using System.Reflection;
    using System;
    using System.Windows.Forms;    
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.ComponentModel;
    using System.Collections;
    using System.Resources;
    using System.Data;
    using System.Xml;
    using System.Runtime.Serialization;

    /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter"]/*' />
    /// <devdoc>
    ///     ResX resource writer. See the text in "ResourceSchema" for more 
    ///     information.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ResXResourceWriter : IResourceWriter {
        internal const string TypeStr = "type";
        internal const string NameStr = "name";
        internal const string DataStr = "data";
        internal const string MimeTypeStr = "mimetype";
        internal const string ValueStr = "value";
        internal const string ResHeaderStr = "resheader";
        internal const string VersionStr = "version";
        internal const string ResMimeTypeStr = "resmimetype";
        internal const string ReaderStr = "reader";
        internal const string WriterStr = "writer";

        private static TraceSwitch ResValueProviderSwitch = new TraceSwitch("ResX", "Debug the resource value provider");

        // CONSIDER: This should be removed in v1.1. This is here because Beta 2 ResX files 
        // could "theoretically" contain the psuedoml reference. However, we
        // would have always used the binary serializer for them. We will never
        // (not even in Beta 2) generate this string, however we couldn't make the 
        // breaking change to rip it.
        //
        // Keeping this is probably a bit over-cautious, but...
        // 
        internal static readonly string Beta2CompatSerializedObjectMimeType = "text/microsoft-urt/psuedoml-serialized/base64";

        // These two "compat" mimetypes are here. In Beta 2 and RTM we used the term "URT"
        // internally to refer to parts of the .NET Framework. Since these references
        // will be in Beta 2 ResX files, and RTM ResX files for customers that had 
        // early access to releases, we don't want to break that. We will read 
        // and parse these types correctly in version 1.0, but will always 
        // write out the new version. So, opening and editing a ResX file in VS will
        // update it to the new types.
        //
        internal static readonly string CompatBinSerializedObjectMimeType = "text/microsoft-urt/binary-serialized/base64";
        internal static readonly string CompatSoapSerializedObjectMimeType = "text/microsoft-urt/soap-serialized/base64";

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.BinSerializedObjectMimeType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string BinSerializedObjectMimeType = "application/x-microsoft.net.object.binary.base64";
        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.SoapSerializedObjectMimeType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string SoapSerializedObjectMimeType = "application/x-microsoft.net.object.soap.base64";
        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.DefaultSerializedObjectMimeType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string DefaultSerializedObjectMimeType = BinSerializedObjectMimeType;
        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ByteArraySerializedObjectMimeType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string ByteArraySerializedObjectMimeType = "application/x-microsoft.net.object.bytearray.base64";
        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ResMimeType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string ResMimeType = "text/microsoft-resx";
        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Version"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string Version = "1.3";

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ResourceSchema"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly string ResourceSchema = @"
    <!-- 
    Microsoft ResX Schema 
    
    Version " + Version + @"
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name=""resmimetype"">text/microsoft-resx</resheader>
    <resheader name=""version"">" + Version + @"</resheader>
    <resheader name=""reader"">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name=""writer"">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name=""Name1"">this is my long string</data>
    <data name=""Color1"" type=""System.Drawing.Color, System.Drawing"">Blue</data>
    <data name=""Bitmap1"" mimetype=""" + BinSerializedObjectMimeType + @""">
        [base64 mime encoded serialized .NET Framework object]
    </data>
    <data name=""Icon1"" type=""System.Drawing.Icon, System.Drawing"" mimetype=""" + ByteArraySerializedObjectMimeType + @""">
        [base64 mime encoded string representing a byte array form of the .NET Framework object]
    </data>
                
    There are any number of ""resheader"" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used forserialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - " + BinSerializedObjectMimeType + @" is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: " + BinSerializedObjectMimeType + @"
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: " + SoapSerializedObjectMimeType + @"
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: " + ByteArraySerializedObjectMimeType + @"
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
    <xsd:schema id=""root"" xmlns="""" xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xmlns:msdata=""urn:schemas-microsoft-com:xml-msdata"">
        <xsd:element name=""root"" msdata:IsDataSet=""true"">
            <xsd:complexType>
                <xsd:choice maxOccurs=""unbounded"">
                    <xsd:element name=""data"">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name=""value"" type=""xsd:string"" minOccurs=""0"" msdata:Ordinal=""1"" />
                                <xsd:element name=""comment"" type=""xsd:string"" minOccurs=""0"" msdata:Ordinal=""2"" />
                            </xsd:sequence>
                            <xsd:attribute name=""name"" type=""xsd:string"" msdata:Ordinal=""1"" />
                            <xsd:attribute name=""type"" type=""xsd:string"" msdata:Ordinal=""3"" />
                            <xsd:attribute name=""mimetype"" type=""xsd:string"" msdata:Ordinal=""4"" />
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name=""resheader"">
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:element name=""value"" type=""xsd:string"" minOccurs=""0"" msdata:Ordinal=""1"" />
                            </xsd:sequence>
                            <xsd:attribute name=""name"" type=""xsd:string"" use=""required"" />
                        </xsd:complexType>
                    </xsd:element>
                </xsd:choice>
            </xsd:complexType>
        </xsd:element>
        </xsd:schema>
        ";
        
        IFormatter binaryFormatter = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter ();
        string fileName;
        Stream stream;
        TextWriter textWriter;
        XmlTextWriter xmlTextWriter;

        bool hasBeenSaved;
        bool initialized;

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ResXResourceWriter"]/*' />
        /// <devdoc>
        ///     Creates a new ResXResourceWriter that will write to the specified file.
        /// </devdoc>
        public ResXResourceWriter(string fileName) {
            this.fileName = fileName;
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ResXResourceWriter1"]/*' />
        /// <devdoc>
        ///     Creates a new ResXResourceWriter that will write to the specified stream.
        /// </devdoc>
        public ResXResourceWriter(Stream stream) {
            this.stream = stream;
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.ResXResourceWriter2"]/*' />
        /// <devdoc>
        ///     Creates a new ResXResourceWriter that will write to the specified TextWriter.
        /// </devdoc>
        public ResXResourceWriter(TextWriter textWriter) {
            this.textWriter = textWriter;
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Finalize"]/*' />
        ~ResXResourceWriter() {
            Dispose(false);
        }

        private void InitializeWriter() {
            if (xmlTextWriter == null) {
                // CONSIDER: ASURT 45059: If we give the XmlTextWriter a TextWriter parameter,
                // there's currently no good way to output xml header.
                bool writeHeaderHack = false;

                if (textWriter != null) {
                    textWriter.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
                    writeHeaderHack = true;

                    xmlTextWriter = new XmlTextWriter(textWriter);
                }
                else if (stream != null) {
                    xmlTextWriter = new XmlTextWriter(stream, System.Text.Encoding.UTF8);
                }
                else {
                    Debug.Assert(fileName != null, "Nothing to output to");
                    xmlTextWriter = new XmlTextWriter(fileName, System.Text.Encoding.UTF8);
                }
                xmlTextWriter.Formatting = Formatting.Indented;
                xmlTextWriter.Indentation = 2;

                if (!writeHeaderHack) {
                    xmlTextWriter.WriteStartDocument(); // writes <?xml version="1.0" encoding="utf-8"?>
                }
            }
            else {
                xmlTextWriter.WriteStartDocument();
            }

            xmlTextWriter.WriteStartElement("root");
            XmlTextReader reader = new XmlTextReader(new StringReader(ResourceSchema));
            reader.WhitespaceHandling = WhitespaceHandling.None;
            xmlTextWriter.WriteNode(reader, true);

            xmlTextWriter.WriteStartElement(ResHeaderStr); {
                xmlTextWriter.WriteAttributeString(NameStr, ResMimeTypeStr);
                xmlTextWriter.WriteStartElement(ValueStr); {
                    xmlTextWriter.WriteString(ResMimeType);
                }
                xmlTextWriter.WriteEndElement();
            }
            xmlTextWriter.WriteEndElement();
            xmlTextWriter.WriteStartElement(ResHeaderStr); {
                xmlTextWriter.WriteAttributeString(NameStr, VersionStr);
                xmlTextWriter.WriteStartElement(ValueStr); {
                    xmlTextWriter.WriteString(Version);
                }
                xmlTextWriter.WriteEndElement();
            }
            xmlTextWriter.WriteEndElement();
            xmlTextWriter.WriteStartElement(ResHeaderStr); {
                xmlTextWriter.WriteAttributeString(NameStr, ReaderStr);
                xmlTextWriter.WriteStartElement(ValueStr); {
                    xmlTextWriter.WriteString(typeof(ResXResourceReader).AssemblyQualifiedName);
                }
                xmlTextWriter.WriteEndElement();
            }
            xmlTextWriter.WriteEndElement();
            xmlTextWriter.WriteStartElement(ResHeaderStr); {
                xmlTextWriter.WriteAttributeString(NameStr, WriterStr);
                xmlTextWriter.WriteStartElement(ValueStr); {
                    xmlTextWriter.WriteString(typeof(ResXResourceWriter).AssemblyQualifiedName);
                }
                xmlTextWriter.WriteEndElement();
            }
            xmlTextWriter.WriteEndElement();

            initialized = true;
        }

        private XmlWriter Writer {
            get {
                if (!initialized) {
                    InitializeWriter();
                }
                return xmlTextWriter;
            }
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.AddResource"]/*' />
        /// <devdoc>
        ///     Adds a blob resource to the resources.
        /// </devdoc>
        public void AddResource(string name, byte[] value) {
            AddDataRow(name, ToBase64WrappedString(value), TypeNameWithAssembly(typeof(byte[])), null);
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.AddResource1"]/*' />
        /// <devdoc>
        ///     Adds a resource to the resources. If the resource is a string,
        ///     it will be saved that way, otherwise it will be serialized
        ///     and stored as in binary.
        /// </devdoc>
        public void AddResource(string name, object value) {
            Debug.WriteLineIf(ResValueProviderSwitch.TraceVerbose, "  resx: adding resource "+ name);
            if (value is string) {
                AddResource(name, (string)value);
            }
            else if (value is byte[]) {
                AddResource(name, (byte[])value);
            }
            else {
                Type valueType = (value == null) ? typeof(object) : value.GetType();
                if (value != null && !valueType.IsSerializable) {
                    Debug.WriteLineIf(ResValueProviderSwitch.TraceVerbose, SR.GetString(SR.NotSerializableType, name, valueType.FullName));
                    throw new InvalidOperationException(SR.GetString(SR.NotSerializableType, name, valueType.FullName));
                }
                TypeConverter tc = TypeDescriptor.GetConverter(valueType);
                bool toString = tc.CanConvertTo(typeof(string));
                bool fromString = tc.CanConvertFrom(typeof(string));
                try {
                    if (toString && fromString) {
                        AddDataRow(name, tc.ConvertToInvariantString(value), TypeNameWithAssembly(valueType), null);
                        return;
                    }
                }
                catch (Exception e) {
                    // Some custom type converters will throw in ConvertTo(string)
                    // to indicate that this object should be serialized through ISeriazable
                    // instead of as a string. This is semi-wrong, but something we will have to
                    // live with to allow user created Cursors to be serializable.
                    //
                    Debug.WriteLineIf(ResValueProviderSwitch.TraceVerbose, "Could not convert from string... trying binary serialization " + e.ToString());
                }

                bool toByteArray = tc.CanConvertTo(typeof(byte[]));
                bool fromByteArray = tc.CanConvertFrom(typeof(byte[]));
                if (toByteArray && fromByteArray) {
                    byte[] data = (byte[])tc.ConvertTo(value, typeof(byte[]));
                    string text = ToBase64WrappedString(data);
                    AddDataRow(name, text, TypeNameWithAssembly(valueType), ByteArraySerializedObjectMimeType);
                    return;
                }

                if (value == null) {
                    AddDataRow(name, string.Empty, TypeNameWithAssembly(typeof(ResXNullRef)), null);
                }
                else {
                    MemoryStream ms = new MemoryStream();
                    IFormatter formatter = binaryFormatter;
                    formatter.Serialize(ms, value);
                    string text = ToBase64WrappedString(ms.ToArray());
                    AddDataRow(name, text, null, DefaultSerializedObjectMimeType);
                }
            }
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.AddResource2"]/*' />
        /// <devdoc>
        ///     Adds a string resource to the resources.
        /// </devdoc>
        public void AddResource(string name, string value) {
            AddDataRow(name, value, null, null);
        }

        /// <devdoc>
        ///     Adds a new row to the Resources table. This helper is used because
        ///     we want to always late bind to the columns for greater flexibility.
        /// </devdoc>
        private void AddDataRow(string name, string value, string type, string mimeType) {
            if (hasBeenSaved)
                throw new InvalidOperationException(SR.GetString(SR.ResXResourceWriterSaved));

            Writer.WriteStartElement(DataStr); {
                Writer.WriteAttributeString(NameStr, name);
                if (type != null) {
                    Writer.WriteAttributeString(TypeStr, type);
                }
                if (mimeType != null) {
                    Writer.WriteAttributeString(MimeTypeStr, mimeType);
                }
                Writer.WriteStartElement(ValueStr); {
                    Writer.WriteString(value);
                }
                Writer.WriteEndElement();
            }
            Writer.WriteEndElement();
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Close"]/*' />
        /// <devdoc>
        ///     Closes any files or streams locked by the writer.
        /// </devdoc>
        public void Close() {
            Dispose();
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Dispose1"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (!hasBeenSaved) {
                    Generate();
                }
                if (xmlTextWriter != null) {
                    xmlTextWriter.Close();
                    xmlTextWriter = null;
                }
                if (stream != null) {
                    stream.Close();
                    stream = null;
                }
                if (textWriter != null) {
                    textWriter.Close();
                    textWriter = null;
                }
            }
        }

        static string ToBase64WrappedString(byte[] data) {
            const int lineWrap = 80;
            const string crlf = "\r\n";
            const string prefix = "        ";
            string raw = Convert.ToBase64String(data);
            if (raw.Length > lineWrap) {
                StringBuilder output = new StringBuilder(raw.Length + (raw.Length / lineWrap) * 3); // word wrap on lineWrap chars, \r\n
                int current = 0;
                for (; current < raw.Length - lineWrap; current+=lineWrap) {
                    output.Append(crlf);
                    output.Append(prefix);
                    output.Append(raw, current, lineWrap);
                }
                output.Append(crlf);
                output.Append(prefix);
                output.Append(raw, current, raw.Length - current);
                output.Append(crlf);
                return output.ToString();
            }
            else {
                return raw;
            }
        }

        private string TypeNameWithAssembly(Type type) {
            // CONSIDER: This method used to return "Namespace.MyType, MyAssembly".
            // But, in order to support strict binding, I changed this to return the
            // full strong name of the type. The problem obviously is that now the
            // TypeConverter serialized data will have a strong reference to the type
            // that generated the content, which means you will need a policy file to 
            // read these contents with a newer version of the TypeConverter. That means
            // we will have to add support to our type binding code in ResXResourceReader
            // to support pseudo-partial binding.
            //
            // Assembly assembly = type.Module.Assembly;
            // string result = type.FullName + ", " + assembly.GetName().Name;

            string result = type.AssemblyQualifiedName;
            return result;
        }

        /// <include file='doc\ResXResourceWriter.uex' path='docs/doc[@for="ResXResourceWriter.Generate"]/*' />
        /// <devdoc>
        ///     Writes the resources out to the file or stream.
        /// </devdoc>
        public void Generate() {
            if (hasBeenSaved)
                throw new InvalidOperationException(SR.GetString(SR.ResXResourceWriterSaved));

            hasBeenSaved = true;
            Debug.WriteLineIf(ResValueProviderSwitch.TraceVerbose, "writing XML");

            Writer.WriteEndElement();
            Writer.Flush();

            Debug.WriteLineIf(ResValueProviderSwitch.TraceVerbose, "done");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\appearance.cs ===
//------------------------------------------------------------------------------
// <copyright file="Appearance.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\Appearance.uex' path='docs/doc[@for="Appearance"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       the appearance of a control.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum Appearance {

        /// <include file='doc\Appearance.uex' path='docs/doc[@for="Appearance.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The default appearance defined by the control
        ///       class.
        ///    </para>
        /// </devdoc>
        Normal              = 0,

        /// <include file='doc\Appearance.uex' path='docs/doc[@for="Appearance.Button"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The appearance of a Windows
        ///       button.
        ///    </para>
        /// </devdoc>
        Button              = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\anchorstyles.cs ===
//------------------------------------------------------------------------------
// <copyright file="AnchorStyles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;


    /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how
    ///       a
    ///       control anchors to the edges of its container.
    ///    </para>
    /// </devdoc>
    [Editor("System.Windows.Forms.Design.AnchorEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))]
    [Flags]
    public enum AnchorStyles {

        /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is anchored to the top edge of its container.
        ///    </para>
        /// </devdoc>
        Top         = 0x01,
        /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is anchored to the bottom edge of its container.
        ///    </para>
        /// </devdoc>
        Bottom      = 0x02,
        /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is anchored to the left edge of its container.
        ///    </para>
        /// </devdoc>
        Left        = 0x04,
        /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is anchored to the right edge of its container.
        ///    </para>
        /// </devdoc>
        Right       = 0x08,

        /// <include file='doc\AnchorStyles.uex' path='docs/doc[@for="AnchorStyles.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is not anchored to any edges of its container.
        ///    </para>
        /// </devdoc>
        None            = 0,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\accessibleobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessibleObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using Accessibility;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Reflection;
    using System.Globalization;
    using System.Security;
    
    /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject"]/*' />
    /// <devdoc>
    ///    <para>Provides an implementation for an object that can be inspected by an 
    ///       accessibility application.</para>    
    /// </devdoc>
    [ComVisible(true)]
    public class AccessibleObject : MarshalByRefObject, IReflect, IAccessible, UnsafeNativeMethods.IEnumVariant {


        // Member variables

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.systemIAccessible"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='IAccessible '/>interface used by this <see cref='System.Windows.Forms.AccessibleObject'/>.</para>
        /// </devdoc>
        private IAccessible systemIAccessible = null;
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.systemIEnumVariant"]/*' />
        /// <devdoc>
        ///    <para>Specifies the 
        ///    <see langword='NativeMethods.IEnumVariant '/>used by this <see cref='System.Windows.Forms.AccessibleObject'/> .</para>
        /// </devdoc>
        private UnsafeNativeMethods.IEnumVariant systemIEnumVariant = null;
        private UnsafeNativeMethods.IEnumVariant enumVariant = null;

        private delegate object ChildIdDelegate(object childId);
        private delegate string ChildIdDelegateString(object childId);
        private delegate int    StringChildIdDelegateInt(string[] strArray, object childId);
        private delegate Rectangle ChildIdDelegateRect(object childId);
        private delegate void ChildIdDelegateVoid(object childId);
        private delegate object IntChildDelegate(int intParam, object childId);
        private delegate void IntChildDelegateVoid(int intParam, object childId);
        private delegate object IntIntDelegate(int intParam, int intParam2);
        private delegate object PropertyDelegate();
        private delegate int PropertyDelegateInt();
        private delegate void ChildIdStringDelegate(object childId, string strParam);
        
        private bool systemWrapper = false;     // Indicates this object is being used ONLY to wrap a system IAccessible
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.AccessibleObject"]/*' />
        public AccessibleObject() {
        }
        
        // This constructor is used ONLY for wrapping system IAccessible objects
        //
        private AccessibleObject(IAccessible iAcc) {
            this.systemIAccessible = iAcc;            
            this.systemWrapper = true;
        }
        
        internal AccessibleObject(IAccessible iAcc, UnsafeNativeMethods.IEnumVariant iEnum) {
            this.systemIAccessible = iAcc;
            this.systemIEnumVariant = iEnum;
        }
        
        // Properties

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Bounds"]/*' />
        /// <devdoc>
        ///    <para> Gets the bounds of the accessible object, in screen coordinates.</para>
        /// </devdoc>
        public virtual Rectangle Bounds {
            get {
                // Use the system provided bounds
                if (systemIAccessible != null) {
                    int left = 0;
                    int top = 0;
                    int width = 0;
                    int height = 0;
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            systemIAccessible.accLocation(out left, out top, out width, out height, NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return new Rectangle(left, top, width, height);
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }                        
                    }                    
                }
                return Rectangle.Empty;
            }
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.DefaultAction"]/*' />
        /// <devdoc>
        ///    <para>Gets a description of the default action for an object.</para>
        /// </devdoc>
        public virtual string DefaultAction {
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retval = systemIAccessible.get_accDefaultAction(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                        
                    }
                    catch (COMException e) {
                        // Not all objects provide a default action
                        //
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return null;
            }
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Description"]/*' />
        /// <devdoc>
        ///    <para>Gets a description
        ///       of the object's visual appearance to the user.</para>
        /// </devdoc>
        public virtual string Description {
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retval =  systemIAccessible.get_accDescription(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                        
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return null;
            }
        }
        
        private UnsafeNativeMethods.IEnumVariant EnumVariant {
            get {
                if (enumVariant == null) {
                    enumVariant = new EnumVariantObject(this);
                }
                return enumVariant;                
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Help"]/*' />
        /// <devdoc>
        ///    <para>Gets a description of what the object does or how the object is used.</para>
        /// </devdoc>
        public virtual string Help {
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                           retval = systemIAccessible.get_accHelp(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return null;
            }
        } 
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.KeyboardShortcut"]/*' />
        /// <devdoc>
        ///    <para>Gets the object shortcut key or access key
        ///       for an accessible object.</para>
        /// </devdoc>
        public virtual string KeyboardShortcut {
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retval = systemIAccessible.get_accKeyboardShortcut(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                        
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return null;
            }
        } 
         
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the object name.</para>
        /// </devdoc>
        public virtual string Name {
            // Does nothing by default
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retval = systemIAccessible.get_accName(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return null;
            }
            
            set {
            
                if (systemIAccessible != null) {
                    try {
                        
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            systemIAccessible.set_accName(NativeMethods.CHILDID_SELF, value);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                                            
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
            
            }
        }

        internal virtual Control MarshalingControl {
            get {
                return null;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Parent"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets or sets the parent of an accessible object.</para>
        /// </devdoc>
        public virtual AccessibleObject Parent {
            get {
                AccessibleObject retObject;
                if (systemIAccessible != null) {
                    IntSecurity.UnmanagedCode.Assert();
                        try {
                            retObject = WrapIAccessible(systemIAccessible.accParent);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retObject;
                    
                }
                return null;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Role"]/*' />
        /// <devdoc>
        ///    <para>Gets the role of this accessible object.</para>
        /// </devdoc>
        public virtual AccessibleRole Role {
            get {
                AccessibleRole retRole;
                if (systemIAccessible != null) {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                         retRole =  (AccessibleRole)systemIAccessible.get_accRole(NativeMethods.CHILDID_SELF);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retRole;
                    
                }
                else {
                    return AccessibleRole.None;
                }                
            }
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.State"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the state of this accessible object.</para>
        /// </devdoc>
        public virtual AccessibleStates State {
            get {
                AccessibleStates retState;
                if (systemIAccessible != null) {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retState =  (AccessibleStates)systemIAccessible.get_accState(NativeMethods.CHILDID_SELF);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return  retState;
                    
                }
                else {
                    return AccessibleStates.None;
                }
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value of an accessible object.</para>
        /// </devdoc>
        public virtual string Value {
            // Does nothing by default
            get {
                string retval;
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                             retval =  systemIAccessible.get_accValue(NativeMethods.CHILDID_SELF);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retval;
                       
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                return "";
            }
            set {
            
                if (systemIAccessible != null) {
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            systemIAccessible.set_accValue(NativeMethods.CHILDID_SELF, value);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }                    
            }
        }

        // Methods

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetChild"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets the accessible child corresponding to the specified 
        ///       index.</para>
        /// </devdoc>
        public virtual AccessibleObject GetChild(int index) {
            return null;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetChildCount"]/*' />
        /// <devdoc>
        ///    <para> When overridden in a derived class, gets the number of children
        ///       belonging to an accessible object.</para>
        /// </devdoc>
        public virtual int GetChildCount() {
            return -1;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetFocused"]/*' />
        /// <devdoc>
        ///    <para> When overridden in a derived class,
        ///       gets the object that has the keyboard focus.</para>
        /// </devdoc>
        public virtual AccessibleObject GetFocused() {
        
            // Default behavior for objects with AccessibleObject children
            //
            if (GetChildCount() >= 0) {
                int count = GetChildCount();
                for(int index=0; index < count; ++index) {
                    AccessibleObject child = GetChild(index);
                    Debug.Assert(child != null, "GetChild(" + index.ToString() + ") returned null!");
                    if (child != null && ((child.State & AccessibleStates.Focused) != 0)) {
                        return child;
                    }
                }
                if ((this.State & AccessibleStates.Focused) != 0) {
                    return this;
                }
                return null;
            }
        
            if (systemIAccessible != null) {
                AccessibleObject retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retObject =  WrapIAccessible(systemIAccessible.accFocus);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                    
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            return null;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetHelpTopic"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets an identifier for a Help topic and the path to the Help file associated
        ///       with this accessible object.</para>
        /// </devdoc>
        public virtual int GetHelpTopic(out string fileName) {
        
            if (systemIAccessible != null) {
                int retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval = systemIAccessible.get_accHelpTopic(out fileName, NativeMethods.CHILDID_SELF);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                    
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }                
            } 
            fileName = null;
            return -1;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetSelected"]/*' />
        /// <devdoc>
        ///    <para> When overridden in
        ///       a derived class, gets the currently selected child.</para>
        /// </devdoc>
        public virtual AccessibleObject GetSelected() {
            // Default behavior for objects with AccessibleObject children
            //
            if (GetChildCount() >= 0) {
                int count = GetChildCount();
                for(int index=0; index < count; ++index) {
                    AccessibleObject child = GetChild(index);
                    Debug.Assert(child != null, "GetChild(" + index.ToString() + ") returned null!");
                    if (child != null && ((child.State & AccessibleStates.Selected) != 0)) {
                        return child;
                    }
                }
                if ((this.State & AccessibleStates.Selected) != 0) {
                    return this;
                }
                return null;
            }
        
            if (systemIAccessible != null) {
                AccessibleObject retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retObject = WrapIAccessible(systemIAccessible.accSelection);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                    
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            return null;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.HitTest"]/*' />
        /// <devdoc>
        ///    <para>Return the child object at the given screen coordinates.</para>
        /// </devdoc>
        public virtual AccessibleObject HitTest(int x, int y) {
        
            // Default behavior for objects with AccessibleObject children
            //
            if (GetChildCount() >= 0) {
                int count = GetChildCount();
                for(int index=0; index < count; ++index) {
                    AccessibleObject child = GetChild(index);
                    Debug.Assert(child != null, "GetChild(" + index.ToString() + ") returned null!");
                    if (child != null && child.Bounds.Contains(x, y)) {
                        return child;
                    }
                }
                return this;
            }
            
            if (systemIAccessible != null) {
                AccessibleObject retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                         retObject = WrapIAccessible(systemIAccessible.accHitTest(x, y));
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                    
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            
            if (this.Bounds.Contains(x, y)) {
                return this;
            }
            
            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accDoDefaultAction"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Perform the default action
        /// </para>
        /// </devdoc>
        void IAccessible.accDoDefaultAction(Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                MarshalingControl.Invoke(new ChildIdDelegateVoid(((IAccessible)this).accDoDefaultAction), new object[]{childID});
                return;
            }

            ValidateChildID(ref childID);
            
            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccDoDefaultAction: this = " + 
                this.ToString() + ", childID = " + childID.ToString());

            // If the default action is to be performed on self, do it.
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                DoDefaultAction();
                return;
            }
                
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                child.DoDefaultAction();
                return;
            }            
            
            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.accDoDefaultAction(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    
                }
                catch (COMException e) {
                    // Not all objects provide a default action
                    //
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accHitTest"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Perform a hit test
        /// </para>
        /// </devdoc>
        Object IAccessible.accHitTest(
                                 int xLeft,
                                 int yTop) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                return MarshalingControl.Invoke(new IntIntDelegate(((IAccessible)this).accHitTest), new object[]{xLeft, yTop});
            }

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccHitTest: this = " + 
                this.ToString());
            
            AccessibleObject obj = HitTest(xLeft, yTop);
            if (obj != null) {
                return AsVariant(obj);
            }
            
            if (systemIAccessible != null) {
                Object retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                         retObject =  systemIAccessible.accHitTest(xLeft, yTop);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            
            return null;
        }

        private Rectangle InternalGetAccLocation(object childId) {
            int x = 0;
            int y = 0;
            int w = 0;
            int h = 0;

            ((IAccessible)this).accLocation(out x, out y, out w, out h, childId);
            return new Rectangle(x, y, w, h); 

        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accLocation"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// The location of the Accessible object
        /// </para>
        /// </devdoc>
        void IAccessible.accLocation(
                               out int pxLeft,
                               out int pyTop,
                               out int pcxWidth,
                               out int pcyHeight,
                               Object childID) {
            
            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                Rectangle r = (Rectangle)MarshalingControl.Invoke(new ChildIdDelegateRect(InternalGetAccLocation), new object[]{childID});
                pxLeft = r.X;
                pyTop = r.Y;
                pcxWidth = r.Width;
                pcyHeight = r.Height;
                return;
            }

            pxLeft = 0;
            pyTop = 0;
            pcxWidth = 0;
            pcyHeight = 0;

            ValidateChildID(ref childID);
            
            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccLocation: this = " + 
                this.ToString() + ", childID = " + childID.ToString());

            // Use the Location function's return value if available            
            //
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                Rectangle bounds = this.Bounds;
                pxLeft = bounds.X;
                pyTop = bounds.Y;
                pcxWidth = bounds.Width;
                pcyHeight = bounds.Height;
                
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccLocation: Returning " + 
                    bounds.ToString());
                
                return;
            }
            
            // If we have an accessible object collection, get the appropriate child
            //
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                Rectangle bounds = child.Bounds;
                pxLeft = bounds.X;
                pyTop = bounds.Y;
                pcxWidth = bounds.Width;
                pcyHeight = bounds.Height;
                
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccLocation: Returning " + 
                    bounds.ToString());
                
                return;
            }

            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.accLocation(out pxLeft, out pyTop, out pcxWidth, out pcyHeight, childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccLocation: Setting " + 
                        pxLeft.ToString() + ", " +
                        pyTop.ToString() + ", " +
                        pcxWidth.ToString() + ", " +
                        pcyHeight.ToString());
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
                
                return;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accNavigate"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Navigate to another accessible object.
        /// </para>
        /// </devdoc>
        Object IAccessible.accNavigate(
                                  int navDir,
                                  Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                return MarshalingControl.Invoke(new IntChildDelegate(((IAccessible)this).accNavigate), new object[]{navDir, childID});
            }

            ValidateChildID(ref childID);

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccNavigate: this = " + 
                this.ToString() + ", navdir = " + navDir.ToString() + ", childID = " + childID.ToString());
                           
            // Use the Navigate function's return value if available            
            //
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                AccessibleObject newObject = Navigate((AccessibleNavigation)navDir);
                if (newObject != null) {
                    return AsVariant(newObject);
                }
            }
            
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return AsVariant(child.Navigate((AccessibleNavigation)navDir));
            }

            if (systemIAccessible != null) {
                Object retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retObject = systemIAccessible.accNavigate(navDir, childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                    
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }

            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accSelect"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Select an accessible object.
        /// </para>
        /// </devdoc>
        void IAccessible.accSelect(int flagsSelect, Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                  MarshalingControl.Invoke(new IntChildDelegateVoid(((IAccessible)this).accSelect), new object[]{flagsSelect, childID});
                  return;
              }



            ValidateChildID(ref childID);

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.AccSelect: this = " + 
                this.ToString() + ", flagsSelect = " + flagsSelect.ToString() + ", childID = " + childID.ToString());
            
            // If the selection is self, do it.
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                Select((AccessibleSelection)flagsSelect);    // Uses an Enum which matches SELFLAG
                return;
            }
            
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                child.Select((AccessibleSelection)flagsSelect);
                return;
            }

            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.accSelect(flagsSelect, childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
                return;
            }

        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UnsafeNativeMethods.IEnumVariant.Clone"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clone this accessible object.
        ///    </para>
        /// </devdoc>
        void UnsafeNativeMethods.IEnumVariant.Clone(UnsafeNativeMethods.IEnumVariant[] v) {
            EnumVariant.Clone(v);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.DoDefaultAction"]/*' />
        /// <devdoc>
        ///      Performs the default action associated with this accessible object.
        /// </devdoc>
        public virtual void DoDefaultAction() {
            // By default, just does the system default action if available
            //
            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.accDoDefaultAction(0);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    
                }
                catch (COMException e) {
                    // Not all objects provide a default action
                    //
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }                    
                }
                return;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accChild"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Returns a child Accessible object
        /// </para>
        /// </devdoc>
        object IAccessible.get_accChild(object childID) {

           if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return MarshalingControl.Invoke(new ChildIdDelegate(((IAccessible)this).get_accChild), new object[]{childID});
           }


            ValidateChildID(ref childID);

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.GetAccChild: this = " + 
                this.ToString() + ", childID = " + childID.ToString());

            // Return self for CHILDID_SELF
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return AsIAccessible(this);
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                // Make sure we're not returning ourselves as our own child
                //
                Debug.Assert(child != this, "An accessible object is returning itself as its own child. This can cause Accessibility client applications to hang.");
                if (child == this) {
                    return null;
                }
                
                return AsIAccessible(child);
            }

            // Otherwise, return the default system child for this control
            if (systemIAccessible != null) {
                Object retval;
                IntSecurity.UnmanagedCode.Assert();
                try {
                    retval = systemIAccessible.get_accChild(childID);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return retval;
            }

            // Give up and return null
            return null;
        }

        private int InternalGetAccChildCount() {
            return ((IAccessible)this).accChildCount;
        }


        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accChildCount"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the number of children
        /// </devdoc>
        int IAccessible.accChildCount {
            get {

                if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                  return (int)MarshalingControl.Invoke(new PropertyDelegateInt(InternalGetAccChildCount));
                }

                int childCount = GetChildCount();
                
                if (childCount == -1) {
                    if (systemIAccessible != null) {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            childCount = systemIAccessible.accChildCount;
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    else {
                        childCount = 0;
                    }
                }
                
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.accHildCount: this = " + this.ToString() + ", returning " + childCount.ToString());    
                
                return childCount;                
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accDefaultAction"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the default action
        /// </para>
        /// </devdoc>
        string IAccessible.get_accDefaultAction(Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accDefaultAction), new object[]{childID});
            }


            ValidateChildID(ref childID);

            // Return the default action property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return DefaultAction;
            }
            
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.DefaultAction;
            }

            if (systemIAccessible != null) {
                string retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                       retval = systemIAccessible.get_accDefaultAction(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                    
                }
                catch (COMException e) {
                    // Not all objects provide a default action
                    //
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accDescription"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child description
        /// </para>
        /// </devdoc>
        string IAccessible.get_accDescription(Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accDescription), new object[]{childID});
            }

            ValidateChildID(ref childID);

            // Return the description property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return Description;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.Description;
            }

            if (systemIAccessible != null) {
                string retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval =  systemIAccessible.get_accDescription(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.GetAccessibleChild"]/*' />
        /// <devdoc>
        ///      Returns the appropriate child from the Accessible Child Collection, if available
        /// </devdoc>
        private AccessibleObject GetAccessibleChild(object childID) {
            if (!childID.Equals(NativeMethods.CHILDID_SELF)) {
                int index = (int)childID - 1;   // The first child is childID == 1 (index == 0)
                if (index >= 0 && index < GetChildCount()) {
                    return GetChild(index);
                }
            }
            return null;
        }

        private object InternalAccFocus() {
            return ((IAccessible)this).accFocus;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accFocus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the object or child focus
        /// </devdoc>
        object IAccessible.accFocus {
            get {

                if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                  return MarshalingControl.Invoke(new PropertyDelegate(InternalAccFocus));
                }
    
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.GetAccFocus: this = " + 
                    this.ToString());
    
                AccessibleObject obj = GetFocused();                
                if (obj != null) {
                    return AsVariant(obj);
                }
                
                if (systemIAccessible != null) {
                    Object retObject;
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retObject = systemIAccessible.accFocus;
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retObject;
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                
                return null;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accHelp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return help for this accessible object.
        /// </para>
        /// </devdoc>
        string IAccessible.get_accHelp(Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accHelp), new object[]{childID});
            }

            ValidateChildID(ref childID);

            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return Help;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.Help;
            }

            if (systemIAccessible != null) {
                string retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval = systemIAccessible.get_accHelp(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }

            return null;
        }

        private int InternalGetAccHelpTopic(string [] outString, object childId) {
            string s = null;
            int retVal = ((IAccessible)this).get_accHelpTopic(out s, childId);
            outString[0] = s;
            return retVal;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accHelpTopic"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child help topic
        /// </para>
        /// </devdoc>
        int IAccessible.get_accHelpTopic(out string pszHelpFile, Object childID) {


            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              string[] strArray = new string[1];
              int ret = (int)MarshalingControl.Invoke(new StringChildIdDelegateInt(InternalGetAccHelpTopic), new object[]{strArray, childID});
              pszHelpFile = strArray[0];
              return ret;
            }

            ValidateChildID(ref childID);

            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return GetHelpTopic(out pszHelpFile);
            }
            
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.GetHelpTopic(out pszHelpFile);
            }

            if (systemIAccessible != null) {
                int retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval = systemIAccessible.get_accHelpTopic(out pszHelpFile, childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            
            pszHelpFile = null;
            return -1;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accKeyboardShortcut"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child keyboard shortcut
        /// </para>
        /// </devdoc>
        string IAccessible.get_accKeyboardShortcut(Object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accKeyboardShortcut), new object[]{childID});
            }

            ValidateChildID(ref childID);

            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return KeyboardShortcut;
            } 
             
            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.KeyboardShortcut;
            }

            if (systemIAccessible != null) {
                string retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval = systemIAccessible.get_accKeyboardShortcut(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }

            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child name
        /// </para>
        /// </devdoc>
        string IAccessible.get_accName(object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accName), new object[]{childID});
            }

            ValidateChildID(ref childID);

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.get_accName: this = " + this.ToString() + 
                ", childID = " + childID.ToString());                                                                     

            // Return the name property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return Name;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.Name;
            }

            // Otherwise, use the system provided name
            if (systemIAccessible != null) {
                string retval;
                IntSecurity.UnmanagedCode.Assert();
                try {
                    retval = systemIAccessible.get_accName(childID);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                if (retval == null || retval.Length == 0) {
                    retval = Name;  // Name the child after its parent
                }
                return retval;
            }

            return null;
        }

        private object InternalGetAccParent() {
            return ((IAccessible)this).accParent;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accParent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the parent object
        /// </devdoc>
        object IAccessible.accParent {
            get {

                if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                    return MarshalingControl.Invoke(new PropertyDelegate(InternalGetAccParent));
                }
    

                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.accParent: this = " + this.ToString());
                AccessibleObject parent = Parent;
                if (parent != null) {
                    // Some debugging related tests
                    //
                    Debug.Assert(parent != this, "An accessible object is returning itself as its own parent. This can cause accessibility clients to hang.");
                    if (parent == this) {
                        parent = null;  // This should prevent accessibility clients from hanging
                    }                    
                }
                
                return AsIAccessible(parent);
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accRole"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// The role property describes an object's purpose in terms of its
        /// relationship with sibling or child objects.
        /// </para>
        /// </devdoc>
        object IAccessible.get_accRole(object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return MarshalingControl.Invoke(new ChildIdDelegate(((IAccessible)this).get_accRole), new object[]{childID});
            }

            ValidateChildID(ref childID);

            // Return the role property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return (int)Role;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return (int)child.Role;
            }

            if (systemIAccessible != null) {
                Object retObject;
                IntSecurity.UnmanagedCode.Assert();
                try {
                    retObject = systemIAccessible.get_accRole(childID);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return retObject;
                
            }

            return null;
        }

        private object InternalGetAccSelection() {
            return ((IAccessible)this).accSelection;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.accSelection"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the object or child selection
        /// </devdoc>
        object IAccessible.accSelection { 
            get {

                if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
                  return MarshalingControl.Invoke(new PropertyDelegate(InternalGetAccSelection));
                }

                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.GetAccSelection: this = " + 
                    this.ToString());
    
                AccessibleObject obj = GetSelected();                
                if (obj != null) {
                    return AsVariant(obj);
                }
                
                if (systemIAccessible != null) {
                    Object retObject;
                    try {
                        IntSecurity.UnmanagedCode.Assert();
                        try {
                            retObject = systemIAccessible.accSelection;
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                        return retObject;
                    }
                    catch (COMException e) {
                        if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                            throw e;
                        }
                    }
                }
                
                return null;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child state
        /// </para>
        /// </devdoc>
        object IAccessible.get_accState(object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return MarshalingControl.Invoke(new ChildIdDelegate(((IAccessible)this).get_accState), new object[]{childID});
            }

            ValidateChildID(ref childID);

            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.GetAccState: this = " + 
                this.ToString() + ", childID = " + childID.ToString());

            // Return the state property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return (int)State;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return (int)child.State;
            }

            if (systemIAccessible != null) {
                Object retObject;
                IntSecurity.UnmanagedCode.Assert();
                try {
                    retObject = systemIAccessible.get_accState(childID);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return retObject;
            }

            return null;
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.get_accValue"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Return the object or child value
        /// </para>
        /// </devdoc>
        string IAccessible.get_accValue(object childID) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              return (string)MarshalingControl.Invoke(new ChildIdDelegateString(((IAccessible)this).get_accValue), new object[]{childID});
            }

            ValidateChildID(ref childID);

            // Return the value property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                return Value;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                return child.Value;
            }

            if (systemIAccessible != null) {
                string retval;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retval = systemIAccessible.get_accValue(childID);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retval;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }

            return null;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.set_accName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Set the object or child name
        /// </para>
        /// </devdoc>
        void IAccessible.set_accName(
                              Object childID,
                              string newName) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              MarshalingControl.Invoke(new ChildIdStringDelegate(((IAccessible)this).set_accName), new object[]{childID, newName});
              return;
            }

            ValidateChildID(ref childID);

            // Set the name property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                // Attempt to set the name property
                Name = newName;
                return;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                child.Name = newName;
                return;
            }

            if (systemIAccessible != null) {
                IntSecurity.UnmanagedCode.Assert();
                try {
                    systemIAccessible.set_accName(childID, newName);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.IAccessible.set_accValue"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Set the object or child value
        /// </para>
        /// </devdoc>
        void IAccessible.set_accValue(
                               Object childID,
                               string newValue) {

            if (MarshalingControl != null && MarshalingControl.InvokeRequired) {
              MarshalingControl.Invoke(new ChildIdStringDelegate(((IAccessible)this).set_accValue), new object[]{childID, newValue});
              return;
            }

            ValidateChildID(ref childID);

            // Set the value property if available
            if (childID.Equals(NativeMethods.CHILDID_SELF)) {
                // Attempt to set the value property
                Value = newValue;
                return;
            }

            // If we have an accessible object collection, get the appropriate child
            AccessibleObject child = GetAccessibleChild(childID);
            if (child != null) {
                child.Value = newValue;
                return;
            }

            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.set_accValue(childID, newValue);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
                return;
            }
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UnsafeNativeMethods.IEnumVariant.Next"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Obtain the next n children of this accessible object.
        ///    </para>
        /// </devdoc>
        int UnsafeNativeMethods.IEnumVariant.Next(int n, IntPtr rgvar, int[] ns) {
            return EnumVariant.Next(n, rgvar, ns);
        }
                  
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UnsafeNativeMethods.IEnumVariant.Reset"]/*' />
        /// <devdoc>
        ///      Resets the child accessible object enumerator.
        /// </devdoc>
        void UnsafeNativeMethods.IEnumVariant.Reset() {
            EnumVariant.Reset();
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UnsafeNativeMethods.IEnumVariant.Skip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Skip the next n child accessible objects
        ///    </para>
        /// </devdoc>
        void UnsafeNativeMethods.IEnumVariant.Skip(int n) {
            EnumVariant.Skip(n);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Navigate"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       navigates to another object.</para>
        /// </devdoc>
        public virtual AccessibleObject Navigate(AccessibleNavigation navdir) {
        
            // Some default behavior for objects with AccessibleObject children
            //
            if (GetChildCount() >= 0) {
                switch(navdir) {
                    case AccessibleNavigation.FirstChild:
                        return GetChild(0);
                    case AccessibleNavigation.LastChild:
                        return GetChild(GetChildCount() - 1);
                    case AccessibleNavigation.Previous:
                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                        if (Parent.GetChildCount() > 0) {
                            return null;
                        }
                        break;
                    case AccessibleNavigation.Next:
                    case AccessibleNavigation.Down:
                    case AccessibleNavigation.Right:
                        if (Parent.GetChildCount() > 0) {
                            return null;
                        }
                        break;
                }
            }
        
            if (systemIAccessible != null) {
                AccessibleObject retObject;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        retObject = WrapIAccessible(systemIAccessible.accNavigate((int)navdir, NativeMethods.CHILDID_SELF));
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    return retObject;
                }
                catch (COMException e) {
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
            }
            return null;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects this accessible object.
        ///    </para>
        /// </devdoc>
        public virtual void Select(AccessibleSelection flags) {
        
            // By default, do the system behavior
            //
            if (systemIAccessible != null) {
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        systemIAccessible.accSelect((int)flags, 0);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    
                }
                catch (COMException e) {
                    // Not all objects provide the select function
                    //
                    if (e.ErrorCode != NativeMethods.DISP_E_MEMBERNOTFOUND) {
                        throw e;
                    }
                }
                return;
            }
        }
        
        private object AsVariant(AccessibleObject obj) {
            if (obj == this) {
                return NativeMethods.CHILDID_SELF;
            }
            return AsIAccessible(obj);
        }
        
        private IAccessible AsIAccessible(AccessibleObject obj) {
            if (obj != null && obj.systemWrapper) {
                return obj.systemIAccessible;
            }
            return obj;
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UseStdAccessibleObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        protected void UseStdAccessibleObjects(IntPtr handle) {
            UseStdAccessibleObjects(handle, NativeMethods.OBJID_CLIENT);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.UseStdAccessibleObjects1"]/*' />
        /// <internalonly/>
        protected void UseStdAccessibleObjects(IntPtr handle, int objid) {
            // Get a standard accessible Object
            Guid IID_IAccessible = new Guid(NativeMethods.uuid_IAccessible);
            object acc = null;
            int result = SafeNativeMethods.CreateStdAccessibleObject(
                                                          new HandleRef(this, handle),
                                                          objid,
                                                          ref IID_IAccessible,
                                                          ref acc);

            // Get the IEnumVariant interface
            Guid IID_IEnumVariant = new Guid(NativeMethods.uuid_IEnumVariant);
            object en = null;
            result = SafeNativeMethods.CreateStdAccessibleObject(
                                                      new HandleRef(this, handle),
                                                      objid,
                                                      ref IID_IEnumVariant,
                                                      ref en);

            Debug.Assert(acc != null, "SystemIAccessible is null");
            Debug.Assert(en != null, "SystemIEnumVariant is null");

            if (acc != null || en != null) {
                systemIAccessible = (IAccessible)acc;
                systemIEnumVariant = (UnsafeNativeMethods.IEnumVariant)en;
            }
        }

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.ValidateChildID"]/*' />
        /// <devdoc>
        ///      Make sure that the childID is valid.
        /// </devdoc>
        private void ValidateChildID(ref object childID) {
            // An empty childID is considered to be the same as CHILDID_SELF.
            // Some accessibility programs pass null into our functions, so we
            // need to convert them here.
            if (childID == null) {
                childID = NativeMethods.CHILDID_SELF;
            }
            else if (childID.Equals(NativeMethods.DISP_E_PARAMNOTFOUND)) {
                childID = 0;
            }
            else if (!(childID is Int32)) {
                // AccExplorer seems to occasionally pass in objects instead of an int ChildID.
                //
                childID = 0;
            }
        }

        private AccessibleObject WrapIAccessible(object iacc) {
        
            if (iacc == null || !(iacc is IAccessible)) {
                return null;
            }
        
            // Check to see if this object already wraps iacc
            //
            if (this.systemIAccessible == iacc) {
                return this;
            }
        
            return new AccessibleObject((IAccessible)iacc);
        }                             

        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name and DescriptorInfo which describes the signature
        /// of the method. 
        /// </devdoc>
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers) {
            return typeof(IAccessible).GetMethod(name, bindingAttr, binder, types, modifiers);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the requested method if it is implemented by the Reflection object.  The
        /// match is based upon the name of the method.  If the object implementes multiple methods
        /// with the same name an AmbiguousMatchException is thrown.
        /// </devdoc>
        MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr) {
            return typeof(IAccessible).GetMethod(name, bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
        /// <internalonly/>
        MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
            return typeof(IAccessible).GetMethods(bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the requestion field if it is implemented by the Reflection object.  The
        /// match is based upon a name.  There cannot be more than a single field with
        /// a name.
        /// </devdoc>
        FieldInfo IReflect.GetField(string name, BindingFlags bindingAttr) {
            return typeof(IAccessible).GetField(name, bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
        /// <internalonly/>
        FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
            return typeof(IAccessible).GetFields(bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the property based upon name.  If more than one property has the given
        /// name an AmbiguousMatchException will be thrown.  Returns null if no property
        /// is found.
        /// </devdoc>
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr) {
            return typeof(IAccessible).GetProperty(name, bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the property based upon the name and Descriptor info describing the property
        /// indexing.  Return null if no property is found.
        /// </devdoc>
        PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
            return typeof(IAccessible).GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Returns an array of PropertyInfos for all the properties defined on 
        /// the Reflection object.
        /// </devdoc>
        PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
            return typeof(IAccessible).GetProperties(bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return an array of members which match the passed in name.
        /// </devdoc>
        MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr) {
            return typeof(IAccessible).GetMember(name, bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return an array of all of the members defined for this object.
        /// </devdoc>
        MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
            return typeof(IAccessible).GetMembers(bindingAttr);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Description of the Binding Process.
        /// We must invoke a method that is accessable and for which the provided
        /// parameters have the most specific match.  A method may be called if
        /// 1. The number of parameters in the method declaration equals the number of 
        /// arguments provided to the invocation
        /// 2. The type of each argument can be converted by the binder to the
        /// type of the type of the parameter.
        ///
        /// The binder will find all of the matching methods.  These method are found based
        /// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        /// of methods is filtered by the name, number of arguments and a set of search modifiers
        /// defined in the Binder.
        ///
        /// After the method is selected, it will be invoked.  Accessability is checked
        /// at that point.  The search may be control which set of methods are searched based
        /// upon the accessibility attribute associated with the method.
        ///
        /// The BindToMethod method is responsible for selecting the method to be invoked.
        /// For the default binder, the most specific method will be selected.
        ///
        /// This will invoke a specific member...
        /// @exception If <var>invokeAttr</var> is CreateInstance then all other
        /// Access types must be undefined.  If not we throw an ArgumentException.
        /// @exception If the <var>invokeAttr</var> is not CreateInstance then an
        /// ArgumentException when <var>name</var> is null.
        /// @exception ArgumentException when <var>invokeAttr</var> does not specify the type
        /// @exception ArgumentException when <var>invokeAttr</var> specifies both get and set of
        /// a property or field.
        /// @exception ArgumentException when <var>invokeAttr</var> specifies property set and
        /// invoke method.
        /// </devdoc>
        object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
            
            if (args.Length == 0) {
                MemberInfo[] member = typeof(IAccessible).GetMember(name);
                if (member != null && member.Length > 0 && member[0] is PropertyInfo) {
                    MethodInfo getMethod = ((PropertyInfo)member[0]).GetGetMethod();
                    if (getMethod != null && getMethod.GetParameters().Length > 0) {
                        args = new object[getMethod.GetParameters().Length];
                        for (int i = 0; i < args.Length; i++) {
                            args[i] = NativeMethods.CHILDID_SELF;    
                        }
                    }
                }
            }
            return typeof(IAccessible).InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
        }
        
        /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return the underlying Type that represents the IReflect Object.  For expando object,
        /// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// </devdoc>
        Type IReflect.UnderlyingSystemType {
            get {
                return typeof(IAccessible);
            }
        }
        
        private class EnumVariantObject : UnsafeNativeMethods.IEnumVariant {
        
            private int currentChild = 0;
            private AccessibleObject owner;
            
            public EnumVariantObject(AccessibleObject owner) {
                Debug.Assert(owner != null, "Cannot create EnumVariantObject with a null owner");
                this.owner = owner;
            }
            
            public EnumVariantObject(AccessibleObject owner, int currentChild) {
                Debug.Assert(owner != null, "Cannot create EnumVariantObject with a null owner");
                this.owner = owner;
                this.currentChild = currentChild;
            }
            
            int UnsafeNativeMethods.IEnumVariant.Next(int n, IntPtr rgvar, int[] ns) {
            
                // NOTE: rgvar is a pointer to an array of variants
                
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "EnumVariantObject: owner = " + owner.ToString() + ", n = " + n);
                Debug.Indent();
                
                // If we have an accessible child collection, return the integers 1 to childcount
                int childCount = owner.GetChildCount();
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.IEV.Next: childCount = " + childCount);
                if (childCount >= 0) {
                    int i = 0;
                    
                    for(i=0; i < n && currentChild < childCount; ++i) {
    
                        Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.IEV.Next: adding " + currentChild);
    
                        ++currentChild;
                        
    
                        // The following code pokes the currentChild into rgvar (an array of variants)
                        IntPtr currentAddress = (IntPtr)((long)rgvar + i * 16); // 16 == sizeof(VARIANT); ???
    
                        object v = currentChild;
                        Marshal.GetNativeVariantForObject(v, currentAddress);
                    }
    
                    // Return the number of children retrieved
                    ns[0] = i;
                    
                    if (i != n) {
                        Debug.Unindent();
                        return NativeMethods.S_FALSE;
                    }
                }
    
                //  Otherwise use the system provided behaviour
                else if (owner.systemIEnumVariant != null) {
                    Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.IEV.Next: Delegating to systemIEnumVariant");
                    owner.systemIEnumVariant.Next(n, rgvar, ns);
                }
    
                // Give up and return no integers
                else {
                    Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibleObject.IEV.Next: no children");
                    ns[0] = 0;
                }
    
                Debug.Unindent();
                return NativeMethods.S_OK;
            }
                      
            /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.EnumVariantObject.UnsafeNativeMethods.IEnumVariant.Reset"]/*' />
            /// <devdoc>
            ///      Resets the child accessible object enumerator.
            /// </devdoc>
            void UnsafeNativeMethods.IEnumVariant.Reset() {
                // If we have an accessible children collection, reset the child ID counter
                if (owner.GetChildCount() >= 0) {
                    currentChild = 0;
                }
    
                // Otherwise, use system behaviour
                else if (owner.systemIEnumVariant != null) {
                    owner.systemIEnumVariant.Reset();
                }
            }
            
            /// <include file='doc\AccessibleObject.uex' path='docs/doc[@for="AccessibleObject.EnumVariantObject.UnsafeNativeMethods.IEnumVariant.Skip"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Skip the next n child accessible objects
            ///    </para>
            /// </devdoc>
            void UnsafeNativeMethods.IEnumVariant.Skip(int n) {
                // If we have an accessible children collection, increment the child ID counter
                int childCount = owner.GetChildCount();
                if (childCount >= 0) {
                    
                    // Adjust child ID counter
                    currentChild += n;
                    
                    if (currentChild > childCount) {
                        currentChild = childCount;
                    }
                }
    
                // Otherwise, use the default system behaviour
                else if (owner.systemIEnumVariant != null) {
                    owner.systemIEnumVariant.Skip(n);
                }
            }    
            
            void UnsafeNativeMethods.IEnumVariant.Clone(UnsafeNativeMethods.IEnumVariant[] v) {
                v[0] = new EnumVariantObject(owner, currentChild);
            }
        }

    } // end class AccessibleObject
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\applicationcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplicationContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System;
    using System.Diagnostics;

    /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext"]/*' />
    /// <devdoc>
    ///    ApplicationContext provides contextual information about an application
    ///    thread. Specifically this allows an application author to redifine what
    ///    circurmstances cause a message loop to exit. By default the application
    ///    context listens to the close event on the mainForm, then exits the
    ///    thread's message loop.
    /// </devdoc>
    public class ApplicationContext {
        Form mainForm;

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.ApplicationContext"]/*' />
        /// <devdoc>
        ///     Creates a new ApplicationContext with no mainForm.
        /// </devdoc>
        public ApplicationContext() : this(null) {
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.ApplicationContext1"]/*' />
        /// <devdoc>
        ///     Creates a new ApplicationContext with the specified mainForm.
        ///     If OnMainFormClosed is not overriden, the thread's message
        ///     loop will be terminated when mainForm is closed.
        /// </devdoc>
        public ApplicationContext(Form mainForm) {
            this.MainForm = mainForm;
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for=".Finalize"]/*' />
        ~ApplicationContext() {
            Dispose(false);
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.MainForm"]/*' />
        /// <devdoc>
        ///     Determines the mainForm for this context. This may be changed
        ///     at anytime.
        ///     If OnMainFormClosed is not overriden, the thread's message
        ///     loop will be terminated when mainForm is closed.
        /// </devdoc>
        public Form MainForm {
            get {
                return mainForm;
            }
            set {
                EventHandler onClose = new EventHandler(OnMainFormDestroy);
                if (mainForm != null) {
                    mainForm.HandleDestroyed -= onClose;
                }

                mainForm = value;

                if (mainForm != null) {
                    mainForm.HandleDestroyed += onClose;
                }
            }
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.ThreadExit"]/*' />
        /// <devdoc>
        ///     Is raised when the thread's message loop should be terminated.
        ///     This is raised by calling ExitThread.
        /// </devdoc>
        public event EventHandler ThreadExit;

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes the context. This should dispose the mainForm. This is
        ///     called immediately after the thread's message loop is terminated.
        ///     Application will dispose all forms on this thread by default.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (mainForm != null) {
                    mainForm = null;
                }
            }
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.ExitThread"]/*' />
        /// <devdoc>
        ///     Causes the thread's message loop to be terminated. This
        ///     will call ExitThreadCore.
        /// </devdoc>
        public void ExitThread() {
            ExitThreadCore();
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.ExitThreadCore"]/*' />
        /// <devdoc>
        ///     Causes the thread's message loop to be terminated.
        /// </devdoc>
        protected virtual void ExitThreadCore() {
            if (ThreadExit != null) {
                ThreadExit(this, EventArgs.Empty);
            }
        }

        /// <include file='doc\ApplicationContext.uex' path='docs/doc[@for="ApplicationContext.OnMainFormClosed"]/*' />
        /// <devdoc>
        ///     Called when the mainForm is closed. The default implementation
        ///     of this will call ExitThreadCore.
        /// </devdoc>
        protected virtual void OnMainFormClosed(object sender, EventArgs e) {
            ExitThreadCore();
        }
    
        /// <devdoc>
        ///     Called when the mainForm is closed. The default implementation
        ///     of this will call ExitThreadCore.
        /// </devdoc>
        private void OnMainFormDestroy(object sender, EventArgs e) {
            Form form = (Form)sender;
            if (!form.RecreatingHandle) {
                form.HandleDestroyed -= new EventHandler(OnMainFormDestroy);
                OnMainFormClosed(sender, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\arrangestartingposition.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrangeStartingPosition.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the starting position that the system uses to
    ///       arrange minimized
    ///       windows.
    ///    </para>
    /// </devdoc>
    public enum ArrangeStartingPosition {

        /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition.BottomLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts at the lower-left corner of the screen, which is the default position.
        ///    </para>
        /// </devdoc>
        BottomLeft = NativeMethods.ARW_BOTTOMLEFT,

        /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition.BottomRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts at the lower-right corner of the screen.
        ///    </para>
        /// </devdoc>
        BottomRight = NativeMethods.ARW_BOTTOMRIGHT,

        /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition.Hide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hides minimized windows by moving them off the visible area of the
        ///       screen.
        ///    </para>
        /// </devdoc>
        Hide = NativeMethods.ARW_HIDE,

        /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition.TopLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts at the upper-left corner of the screen.
        ///    </para>
        /// </devdoc>

        TopLeft = NativeMethods.ARW_TOPLEFT,

        /// <include file='doc\ArrangeStartingPosition.uex' path='docs/doc[@for="ArrangeStartingPosition.TopRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts at the upper-right corner of the screen.
        ///    </para>
        /// </devdoc>
        TopRight = NativeMethods.ARW_TOPRIGHT,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\basecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System;
    using System.ComponentModel;
    using System.Collections;
    using ArrayList = System.Collections.ArrayList;

    /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection"]/*' />
    /// <devdoc>
    ///    <para>Provides the base functionality for creating collections.</para>
    /// </devdoc>
    public class BaseCollection : MarshalByRefObject, ICollection {

        //==================================================
        // the ICollection methods
        //==================================================
        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the total number of elements in a collection.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public virtual int Count {
            get {
                return List.Count;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array ar, int index) {
            List.CopyTo(ar, index);
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Gets an IEnumerator for the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return List.GetEnumerator();
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool IsSynchronized {
            get {
                // so the user will know that it has to lock this object
                return false;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.List"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual ArrayList List {
            get {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\arrangedirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrangeDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1997, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.Windows.Forms {

    using System.Diagnostics;

    /// <include file='doc\ArrangeDirection.uex' path='docs/doc[@for="ArrangeDirection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the direction the system uses to arrange
    ///       minimized windows.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum ArrangeDirection {

        /// <include file='doc\ArrangeDirection.uex' path='docs/doc[@for="ArrangeDirection.Down"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Arranges vertically, from top to bottom.
        ///    </para>
        /// </devdoc>
        Down = NativeMethods.ARW_DOWN,

        /// <include file='doc\ArrangeDirection.uex' path='docs/doc[@for="ArrangeDirection.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Arranges horizontally, from left to right.
        ///    </para>
        /// </devdoc>
        Left = NativeMethods.ARW_LEFT,

        /// <include file='doc\ArrangeDirection.uex' path='docs/doc[@for="ArrangeDirection.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Arranges horizontally, from right to left.
        ///    </para>
        /// </devdoc>
        Right = NativeMethods.ARW_RIGHT,

        /// <include file='doc\ArrangeDirection.uex' path='docs/doc[@for="ArrangeDirection.Up"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Arranges vertically, from bottom to top.
        ///    </para>
        /// </devdoc>
        Up = NativeMethods.ARW_UP,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bindingcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindingContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext"]/*' />
    /// <devdoc>
    /// <para>Manages the collection of System.Windows.Forms.BindingManagerBase
    /// objects for a Win Form.</para>
    /// </devdoc>
    [DefaultEvent("CollectionChanged")]
    public class BindingContext : ICollection {

        private Hashtable listManagers;
        private CollectionChangeEventHandler onCollectionChanged;

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.ICollection.Count"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets the total number of System.Windows.Forms.BindingManagerBases
        /// objects.
        /// </para>
        /// </devdoc>
        int ICollection.Count {
            get {
                ScrubWeakRefs();
                return listManagers.Count;
            }
        }
        
        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Copies the elements of the collection into a specified array, starting
        /// at the collection index.
        /// </para>
        /// </devdoc>
        void ICollection.CopyTo(Array ar, int index)
        {
            IntSecurity.UnmanagedCode.Demand();
            ScrubWeakRefs();
            listManagers.CopyTo(ar, index);
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets an enumerator for the collection.
        /// </para>
        /// </devdoc>
        IEnumerator IEnumerable.GetEnumerator()
        {
            IntSecurity.UnmanagedCode.Demand();
            ScrubWeakRefs();
            return listManagers.GetEnumerator();
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.IsReadOnly"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection is read-only.
        ///    </para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets a value indicating whether the collection is synchronized.
        /// </para>
        /// </devdoc>
        bool ICollection.IsSynchronized {
            get {
                // so the user will know that it has to lock this object
                return false;
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gets an object to use for synchronization (thread safety).</para>
        /// </devdoc>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }
        

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.BindingContext"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Windows.Forms.BindingContext class.</para>
        /// </devdoc>
        public BindingContext() {
            listManagers = new Hashtable();
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the System.Windows.Forms.BindingManagerBase
        ///       associated with the specified data source.
        ///    </para>
        /// </devdoc>
        public BindingManagerBase this[object dataSource] {
            get {
                return this[dataSource, ""];
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.this1"]/*' />
        /// <devdoc>
        /// <para>Gets the System.Windows.Forms.BindingManagerBase associated with the specified data source and
        ///    data member.</para>
        /// </devdoc>
        public BindingManagerBase this[object dataSource, string dataMember] {
            get {
                return EnsureListManager(dataSource, dataMember);
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.Add"]/*' />
        /// <devdoc>
        /// Adds the listManager to the collection.  An ArgumentNullException is thrown if this listManager
        /// is null.  An exception is thrown if a listManager to the same target and Property as an existing listManager or
        /// if the listManager's column isn't a valid column given this DataSource.Table's schema.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        internal protected void Add(object dataSource, BindingManagerBase listManager) {
            AddCore(dataSource, listManager);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, dataSource));
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.AddCore"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void AddCore(object dataSource, BindingManagerBase listManager) {
            if (dataSource == null)
                throw new ArgumentNullException("dataSource");
            if (listManager == null)
                throw new ArgumentNullException("listManager");

            // listManagers[dataSource] = listManager;
            listManagers[GetKey(dataSource, "")] = new WeakReference(listManager, false);
        }


        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the collection has changed.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.collectionChangedEventDescr)]
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                throw new NotImplementedException();
                // onCollectionChanged += value;
            }
            remove {
                onCollectionChanged -= value;
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.Clear"]/*' />
        /// <devdoc>
        /// Clears the collection of any bindings.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        internal protected void Clear() {
            ClearCore();
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.ClearCore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears the collection.
        ///    </para>
        /// </devdoc>
        protected virtual void ClearCore() {
            listManagers.Clear();
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the System.Windows.Forms.BindingManager
        /// contains the specified
        /// data source.</para>
        /// </devdoc>
        public bool Contains(object dataSource) {
            return Contains(dataSource, "");
        }
        
        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.Contains1"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the System.Windows.Forms.BindingManager
        /// contains the specified data source and data member.</para>
        /// </devdoc>
        public bool Contains(object dataSource, string dataMember) {
            return listManagers.ContainsKey(GetKey(dataSource, dataMember));
        }

        internal HashKey GetKey(object dataSource, string dataMember) {
            return new HashKey(dataSource, dataMember);
        }
        
        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.HashKey"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        //
        internal class HashKey {
            WeakReference wRef;
            int dataSourceHashCode;
            string dataMember;

            internal HashKey(object dataSource, string dataMember) {
                if (dataSource == null)
                    throw new ArgumentNullException("dataSource");
                if (dataMember == null)
                    dataMember = "";
                // The dataMember should be case insensitive.
                // so convert the dataMember to lower case
                //
                this.wRef = new WeakReference(dataSource, false);
                this.dataSourceHashCode = dataSource.GetHashCode();
                this.dataMember = dataMember.ToLower(CultureInfo.InvariantCulture);
            }

            /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.HashKey.GetHashCode"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// </devdoc>
            public override int GetHashCode() {
                return dataSourceHashCode * dataMember.GetHashCode();
            }

            /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.HashKey.Equals"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// </devdoc>
            public override bool Equals(object target) {
                if (target is HashKey) {
                    HashKey keyTarget = (HashKey)target;
                    return wRef.Target == keyTarget.wRef.Target && dataMember == keyTarget.dataMember;
                }
                return false;
            }
        }
        
        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.OnCollectionChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    This method is called whenever the collection changes.  Overriders
        ///    of this method should call the base implementation of this method.
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChanged != null) {
                onCollectionChanged(this, ccevent);
            }
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.Remove"]/*' />
        /// <devdoc>
        /// Removes the given listManager from the collection.
        /// An ArgumentNullException is thrown if this listManager is null.  An ArgumentException is thrown
        /// if this listManager doesn't belong to this collection.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        internal protected void Remove(object dataSource) {
            RemoveCore(dataSource);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, dataSource));
        }

        /// <include file='doc\BindingManager.uex' path='docs/doc[@for="BindingContext.RemoveCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void RemoveCore(object dataSource) {
            listManagers.Remove(GetKey(dataSource, ""));
        }

        internal BindingManagerBase EnsureListManager(object dataSource, string dataMember) {
            if (dataMember == null)
                dataMember = "";
            HashKey key = GetKey(dataSource, dataMember);
            WeakReference wRef;
            BindingManagerBase bindingManagerBase = null;
            wRef = listManagers[key] as WeakReference;
            if (wRef != null)
                bindingManagerBase = (BindingManagerBase) wRef.Target;
            if (bindingManagerBase != null) {
                return bindingManagerBase;
            }

            // create base listManager.
            if (dataMember.Length == 0) {
                //IListSource so we can bind the dataGrid to a table and a dataSet
                if (dataSource is IList || dataSource is IListSource)
                    bindingManagerBase = new CurrencyManager(dataSource);
                else
                    bindingManagerBase = new PropertyManager(dataSource);

                // if wRef == null, then it is the first time we want this bindingManagerBase: so add it
                // if wRef != null, then the bindingManagerBase was GC'ed at some point: keep the old wRef and change its target
                if (wRef == null)
                    listManagers.Add(key, new WeakReference(bindingManagerBase, false));
                else
                    wRef.Target = bindingManagerBase;
                return bindingManagerBase;
            }

            // handle relation.
            int lastDot = dataMember.LastIndexOf(".");            
            BindingManagerBase formerManager = EnsureListManager(dataSource, lastDot == -1 ? "" : dataMember.Substring(0, lastDot));
            PropertyDescriptor prop = formerManager.GetItemProperties().Find(dataMember.Substring(lastDot + 1), true);
            if (prop == null)
                throw new ArgumentException(SR.GetString(SR.RelatedListManagerChild, dataMember.Substring(lastDot + 1)));
            if (typeof(IList).IsAssignableFrom(prop.PropertyType))
                bindingManagerBase = new RelatedCurrencyManager(formerManager, dataMember.Substring(lastDot + 1));
            else
                bindingManagerBase = new RelatedPropertyManager(formerManager, dataMember.Substring(lastDot + 1));

            // if wRef == null, then it is the first time we want this bindingManagerBase: so add it
            // if wRef != null, then the bindingManagerBase was GC'ed at some point: keep the old wRef and change its target
            if (wRef == null)
                listManagers.Add(GetKey(dataSource, dataMember), new WeakReference(bindingManagerBase, false));
            else
                wRef.Target = bindingManagerBase;
            return bindingManagerBase;
        }

        // may throw
        private static void CheckPropertyBindingCycles(BindingContext newBindingContext, Binding propBinding) {
            if (newBindingContext == null || propBinding == null)
                return;
            if (newBindingContext.Contains(propBinding.Control, "")) {
                // this way we do not add a bindingManagerBase to the
                // bindingContext if there isn't one already
                BindingManagerBase bindingManagerBase = newBindingContext.EnsureListManager(propBinding.Control, "");
                for (int i = 0; i < bindingManagerBase.Bindings.Count; i++) {
                    Binding binding = bindingManagerBase.Bindings[i];
                    if (binding.DataSource == propBinding.Control) {
                        if (propBinding.BindToObject.BindingMemberInfo.BindingMember.Equals(binding.PropertyName))
                            throw new ArgumentException(SR.GetString(SR.DataBindingCycle, binding.PropertyName), "propBinding");
                    } else if (propBinding.BindToObject.BindingManagerBase is PropertyManager)
                        CheckPropertyBindingCycles(newBindingContext, binding);
                }
            }
        }

        private void ScrubWeakRefs() {
            object[] list = new object[listManagers.Count];
            listManagers.CopyTo(list, 0);
            for (int i = 0; i < list.Length; i++) {
                DictionaryEntry entry = (DictionaryEntry) list[i];
                WeakReference wRef = (WeakReference) entry.Value;
                if (wRef.Target == null) {
                    listManagers.Remove(entry.Key);
                }
            }
        }
        
        internal static void UpdateBinding(BindingContext newBindingContext, Binding binding) {
            BindingManagerBase oldManager = binding.BindingManagerBase;
            if (oldManager != null) {
                oldManager.Bindings.Remove(binding);
            }

            if (newBindingContext != null) {
                // we need to first check for cycles before adding this binding to the collection
                // of bindings.
                if (binding.BindToObject.BindingManagerBase is PropertyManager)
                    CheckPropertyBindingCycles(newBindingContext, binding);

                BindToObject bindTo = binding.BindToObject;
                BindingManagerBase newManager = newBindingContext.EnsureListManager(bindTo.DataSource, bindTo.BindingMemberInfo.BindingPath);
                newManager.Bindings.Add(binding);
            }
        }
        
        private void OnBadIndex(object index) {
            throw new IndexOutOfRangeException(SR.GetString(SR.BindingManagerBadIndex, index.ToString()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\binding.cs ===
//------------------------------------------------------------------------------
// <copyright file="Binding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Security;

    /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a simple binding of a value in a list
    ///       and the property of a control.
    ///    </para>
    /// </devdoc>
    [TypeConverterAttribute(typeof(ListBindingConverter))]
    public class Binding {

        // the two collection owners that this binding belongs to.
        private Control control;
        private BindingManagerBase bindingManagerBase;
        
        private BindToObject bindToObject = null;
        
        private string propertyName = "";

        private PropertyDescriptor propInfo;
        private PropertyDescriptor propIsNullInfo;
        private EventDescriptor changedInfo;
        private EventDescriptor validateInfo;

        private bool bound = false;
        private bool modified = false;
        private bool inSetPropValue = false;

        private ConvertEventHandler onParse = null;
        private ConvertEventHandler onFormat = null;

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.Binding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Binding'/> using the specified property
        ///       name, object, and column.
        ///    </para>
        /// </devdoc>
        public Binding(string propertyName, Object dataSource, string dataMember) {
            this.bindToObject = new BindToObject(this, dataSource, dataMember);

            this.propertyName = propertyName;
            CheckBinding();
        }

        /*
        public Binding(string propertyName, RichControl control, string bindToPropName) {
            this.bindToObject = new PropertyBinding(control, bindToPropName);
            this.propertyName = propertyName;
            CheckBinding();
        }
        */

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.Binding1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Binding'/> class.
        ///    </para>
        /// </devdoc>
        private Binding() {
        }

        internal BindToObject BindToObject {
            get {
                return this.bindToObject;
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.DataSource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object DataSource {
            get {
                return this.bindToObject.DataSource;
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.BindingMemberInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public BindingMemberInfo BindingMemberInfo {
            get {
                return this.bindToObject.BindingMemberInfo;
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.Control"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the control to which the binding belongs.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null)
        ]
        public Control Control {
            [
                SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
            ]
            get {
                return control;
            }
        }

        private void FormLoaded(object sender, EventArgs e) {
            Debug.Assert(sender == control, "which other control can send us the Load event?");
            // update the binding
            CheckBinding();
        }

        internal void SetControl(Control value) {
            if (this.control != value) {
                Control oldTarget = control;
                BindTarget(false);
                this.control = value;
                BindTarget(true);
                try {
                    CheckBinding();
                }
                catch (Exception e) {
                    BindTarget(false);
                    control = oldTarget;
                    BindTarget(true);
                    throw e;
                }

                // We are essentially doing to the listManager what we were doing to the
                // BindToObject: bind only when the control is created and it has a BindingContext
                BindingContext.UpdateBinding((control != null && control.Created ? control.BindingContext: null), this);
                Form form = value as Form;
                if (form != null) {
                    form.Load += new EventHandler(FormLoaded);
                }
            }
        }

        //    TODO: Make the Set non-public.

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.IsBinding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the binding is active.
        ///    </para>
        /// </devdoc>
        public bool IsBinding {
            get {
                return bound;
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.BindingManagerBase"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Windows.Forms.BindingManagerBase'/>
        ///       of this binding that allows enumeration of a set of
        ///       bindings.
        ///    </para>
        /// </devdoc>
        public BindingManagerBase BindingManagerBase{
            get {
                return bindingManagerBase;
            }
        }

        // TODO: setting datasource property should do right thing.
        internal void SetListManager(BindingManagerBase bindingManagerBase) {
            this.bindingManagerBase = bindingManagerBase;
            this.BindToObject.SetBindingManagerBase(bindingManagerBase);
            CheckBinding();
        }
        
        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the property on the control to bind to.
        ///    </para>
        /// </devdoc>
        [DefaultValue("")]
        public string PropertyName {
            get {
                return propertyName;
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event ConvertEventHandler Parse {
            add {
                onParse += value;
            }
            remove {
                onParse -= value;
            }
        }


        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.Format"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event ConvertEventHandler Format {
            add {
                onFormat += value;
            }
            remove {
                onFormat -= value;
            }
        }

        private void BindTarget(bool bind) {
            if (bind) {
                if (IsBinding) {
                    if (changedInfo != null) {
                        EventHandler handler = new EventHandler(this.Target_PropertyChanged);
                        changedInfo.AddEventHandler(control, handler);
                    }
                    if (validateInfo != null) {
                        CancelEventHandler handler = new CancelEventHandler(this.Target_Validate);
                        validateInfo.AddEventHandler(control, handler);
                    }
                }
            }
            else {
                if (changedInfo != null) {
                    EventHandler handler = new EventHandler(this.Target_PropertyChanged);
                    changedInfo.RemoveEventHandler(control, handler);
                }
                if (validateInfo != null) {
                    CancelEventHandler handler = new CancelEventHandler(this.Target_Validate);
                    validateInfo.RemoveEventHandler(control, handler);
                }
            }
        }

        private void CheckBinding() {
            this.bindToObject.CheckBinding();

            if (control != null && propertyName.Length > 0) {
                control.DataBindings.CheckDuplicates(this);
                
                Type controlClass = control.GetType();

                // Check Properties
                string propertyNameIsNull = propertyName + "IsNull";
                Type propType = null;
                PropertyDescriptor tempPropInfo = null;
                PropertyDescriptor tempPropIsNullInfo = null;
                PropertyDescriptorCollection propInfos;
                 
                // If the control is being inherited, then get the properties for
                // the control's type rather than for the control itself.  Getting
                // properties for the control will merge the control's properties with
                // those of its designer.  Normally we want that, but for 
                // inherited controls we don't because an inherited control should 
                // "act" like a runtime control.
                //
                InheritanceAttribute attr = (InheritanceAttribute)TypeDescriptor.GetAttributes(control)[typeof(InheritanceAttribute)];
                if (attr != null && attr.InheritanceLevel != InheritanceLevel.NotInherited) {
                    propInfos = TypeDescriptor.GetProperties(controlClass);
                }
                else {
                    propInfos = TypeDescriptor.GetProperties(control);
                }
                
                for (int i = 0; i < propInfos.Count; i++) {
                    if (String.Compare(propInfos[i].Name, propertyName, true, CultureInfo.InvariantCulture) == 0) {
                        tempPropInfo = propInfos[i];
                        if (tempPropIsNullInfo != null)
                            break;
                    }
                    if (String.Compare(propInfos[i].Name, propertyNameIsNull, true, CultureInfo.InvariantCulture) == 0) {
                        tempPropIsNullInfo = propInfos[i];
                        if (tempPropInfo != null)
                            break;
                    }
                }

                if (tempPropInfo == null) {
                    throw new ArgumentException(SR.GetString(SR.ListBindingBindProperty, propertyName), "PropertyName");
                }
                if (tempPropInfo.IsReadOnly) {
                    throw new ArgumentException(SR.GetString(SR.ListBindingBindPropertyReadOnly, propertyName), "PropertyName");
                }

                propInfo = tempPropInfo;
                propType = propInfo.PropertyType;
                if (tempPropIsNullInfo != null && tempPropIsNullInfo.PropertyType == typeof(bool) && !tempPropIsNullInfo.IsReadOnly)
                    propIsNullInfo = tempPropIsNullInfo;

                // Check events
                EventDescriptor tempChangedInfo = null;
                string changedName = propertyName + "Changed";
                EventDescriptor tempValidateInfo = null;
                string validateName = "Validating";
                EventDescriptorCollection eventInfos = TypeDescriptor.GetEvents(control);
                for (int i = 0; i < eventInfos.Count; i++) {
                    if (String.Compare(eventInfos[i].Name, changedName, true, CultureInfo.InvariantCulture) == 0) {
                        tempChangedInfo = eventInfos[i];
                        if (tempValidateInfo != null)
                            break;
                    }
                    if (String.Compare(eventInfos[i].Name, validateName, true, CultureInfo.InvariantCulture) == 0) {
                        tempValidateInfo = eventInfos[i];
                        if (tempChangedInfo != null)
                            break;
                    }
                }
                changedInfo = tempChangedInfo;
                validateInfo = tempValidateInfo;
            }
            else {
                propInfo = null;
                changedInfo = null;
                validateInfo = null;
            }

            // go see if we become bound now.
            UpdateIsBinding();
        }

        private bool ControlAtDesignTime() {
            ISite site = this.control.Site;

            if (site == null)
                return false;
            return site.DesignMode;
        }

        private Object GetPropValue() {
            bool isNull = false;
            if (propIsNullInfo != null) {
                isNull = (bool) propIsNullInfo.GetValue(control);
            }
            Object value;
            if (isNull) {
                value = Convert.DBNull;
            }
            else {
                value =  propInfo.GetValue(control);
                // bug 92443: the code before was changing value to Convert.DBNull if the value
                // was the empty string. we can't do this, because we need to format the value
                // in the property in the control and then push it back into the control.
                if (value == null) {
                    value = Convert.DBNull;
                }
            }
            return value;
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.OnParse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnParse(ConvertEventArgs cevent) {
            if (onParse != null) {
                onParse(this, cevent);
            }
            if (!(cevent.Value is System.DBNull) && cevent.Value != null && cevent.DesiredType != null && !cevent.DesiredType.IsInstanceOfType(cevent.Value) && (cevent.Value is IConvertible)) {
                cevent.Value = Convert.ChangeType(cevent.Value, cevent.DesiredType);
            }
        }

        /// <include file='doc\ListBinding.uex' path='docs/doc[@for="Binding.OnFormat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnFormat(ConvertEventArgs cevent) {
            if (onFormat!= null) {
                onFormat(this, cevent);
            }
            if (!(cevent.Value is System.DBNull) && cevent.DesiredType != null && !cevent.DesiredType.IsInstanceOfType(cevent.Value) && (cevent.Value is IConvertible)) {
                cevent.Value = Convert.ChangeType(cevent.Value, cevent.DesiredType);
            }
        }

        // will not throw.
        private object ParseObject(object value) {
            object ret;
            Type type = this.bindToObject.BindToType;

            ConvertEventArgs e = new ConvertEventArgs(value, type);
            // first try: use the OnParse event
            OnParse(e);

            // bug 75825: if the user choose to push a null in to the back end,
            // then we should push it like it is.
            //
            if (e.Value.GetType().IsSubclassOf(type) || e.Value.GetType() == type || e.Value is System.DBNull)
                return e.Value;
            // second try: use the TypeConverter
            TypeConverter typeConverter = TypeDescriptor.GetConverter(value.GetType());
            if (typeConverter != null && typeConverter.CanConvertTo(type)) {
                return typeConverter.ConvertTo(value, type);
            }
            // last try: use Convert.ToType
            if (value is IConvertible) {
                ret = Convert.ChangeType(value, type);
                if (ret.GetType().IsSubclassOf(type) || ret.GetType() == type)
                    return ret;
            }
            return null;
        }

        // when the user leaves the control, it will call validating.
        // the Target_Validate method will be called, and Target_Validate will call PullData in turn.
        internal void PullData() {
            if (IsBinding && (modified || changedInfo == null)) {
                Object value = GetPropValue();
                bool parseFailed = false;
                object parsedValue;

                try {
                    parsedValue = ParseObject(value);
                } catch (Exception) {
                    parseFailed = true;
                    parsedValue = this.bindToObject.GetValue();
                }

                if (parsedValue == null) {
                    parseFailed = true;
                    parsedValue = this.bindToObject.GetValue();
                }

                // now format the parsed value to be redisplayed
                object formattedObject = FormatObject(parsedValue);
                SetPropValue(formattedObject);

                // put the value into the data model
                if (!parseFailed)
                    this.bindToObject.SetValue(parsedValue);

                modified = false;
            }
        }

        // will throw when fail
        // we will not format the object when the control is in design time.
        // this is because if we bind a boolean property on a control
        // to a row that is full of DBNulls then we cause problems in the shell.
        private object FormatObject(object value) {
            if (ControlAtDesignTime())
                return value;
            object ret;
            Type type = propInfo.PropertyType;

            if (type == typeof(object))
                return value;

            // first try: use the Format event
            ConvertEventArgs e = new ConvertEventArgs(value, type);
            OnFormat(e);
            ret = e.Value;

            if (ret.GetType().IsSubclassOf(type) || ret.GetType() == type)
                return ret;
            
            // second try: use type converter for the desiredType
            TypeConverter typeConverter = TypeDescriptor.GetConverter(value.GetType());
            if (typeConverter != null && typeConverter.CanConvertTo(type)) {
                ret = typeConverter.ConvertTo(value, type);
                return ret;
            }

            // last try: use Convert.ChangeType
            if (value is IConvertible) {
                ret = Convert.ChangeType(value, type);
                if (ret.GetType().IsSubclassOf(type) || ret.GetType() == type)
                    return ret;
            }

            // time to fail:
            throw new FormatException(SR.GetString(SR.ListBindingFormatFailed));
        }

        internal void PushData() {
            if (IsBinding) {
                Object value = bindToObject.GetValue();
                value = FormatObject(value);
                SetPropValue(value);
                modified = false;
            }
            else {
                SetPropValue(null);
            }
        }

        // we will not pull the data from the back end into the control
        // when the control is in design time. this is because if we bind a boolean property on a control
        // to a row that is full of DBNulls then we cause problems in the shell.
        private void SetPropValue(Object value) {
            if(ControlAtDesignTime())
                return;
            inSetPropValue = true;

            try {
                bool isNull = value == null || Convert.IsDBNull(value);
                if (isNull) {
                    if (propIsNullInfo != null) {
                        propIsNullInfo.SetValue(control, true);
                    }
                    // TODO: turn to passing real Convert.DBNull once we do formatting or controls support IsNull.
                    else {
                        if (propInfo.PropertyType == typeof(object)) {
                            propInfo.SetValue(control, Convert.DBNull);
                        }
                        else {
                            propInfo.SetValue(control, null);
                        }

                    }
                }
                else {
                    propInfo.SetValue(control, value);
                }
            }
            finally {
                inSetPropValue = false;
            }
        }

        private void Target_PropertyChanged(Object sender, EventArgs e) {
            if (inSetPropValue)
                return;

            if (IsBinding) {
                //dataSource.BeginEdit();
                modified = true;
            }
        }

        private void Target_Validate(Object sender, CancelEventArgs e) {
            try {
                PullData();
            }
            catch (Exception) {
                e.Cancel = true;
            }
        }

        internal bool IsBindable {
            get {
                return (control != null && propertyName.Length > 0 && // TODO: validate columnName
                                bindToObject.DataSource != null && bindingManagerBase != null);
            }
        }
        
        internal void UpdateIsBinding() {
            bool newBound =  IsBindable && Control.IsBinding && bindingManagerBase.IsBinding;
            if (bound != newBound) {
                bound = newBound;
                BindTarget(newBound);
                if (bound)
                    PushData();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bindingmanagerbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindingMAnagerBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   BindingMAnagerBase.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms {
    using System;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Collections;

    /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class BindingManagerBase {
        private BindingsCollection bindings;
        private bool pullingData = false;

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.onCurrentChangedHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected EventHandler onCurrentChangedHandler;
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.onPositionChangedHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected EventHandler onPositionChangedHandler;

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.Bindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public BindingsCollection Bindings {
            get {
                if (bindings == null)
                    bindings = new ListManagerBindingsCollection(this);
                return bindings;
            }
        }

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.OnCurrentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal protected abstract void OnCurrentChanged(EventArgs e);

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract Object Current {
            get;
        }

        internal abstract void SetDataSource(Object dataSource);

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.BindingManagerBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public BindingManagerBase() {}

        internal BindingManagerBase(Object dataSource) {
            this.SetDataSource(dataSource);
        }

        internal abstract Type BindType{
            get;
        }

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.GetItemProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract PropertyDescriptorCollection GetItemProperties();

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.GetItemProperties1"]/*' />
        protected internal virtual PropertyDescriptorCollection GetItemProperties(ArrayList dataSources, ArrayList listAccessors) {
            IList list = null;
            if (this is CurrencyManager) {
                list = ((CurrencyManager)this).List;
            }
            if (list is ITypedList) {
                PropertyDescriptor[] properties = new PropertyDescriptor[listAccessors.Count];
                listAccessors.CopyTo(properties, 0);
                return ((ITypedList)list).GetItemProperties(properties);
            }
            return this.GetItemProperties(this.BindType, 0, dataSources, listAccessors);
        }

        // listType is the type of the top list in the list.list.list.list reference
        // offset is how far we are in the listAccessors
        // listAccessors is the list of accessors (duh)
        //
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.GetItemProperties2"]/*' />
        protected virtual PropertyDescriptorCollection GetItemProperties(Type listType, int offset, ArrayList dataSources, ArrayList listAccessors) {
            if (listAccessors.Count < offset)
                return null;

            if (listAccessors.Count == offset) {
                if (typeof(IList).IsAssignableFrom(listType)) {
                    System.Reflection.PropertyInfo[] itemProps = listType.GetProperties();
                    // PropertyDescriptorCollection itemProps = TypeDescriptor.GetProperties(listType);
                    for (int i = 0; i < itemProps.Length; i ++) {
                        if ("Item".Equals(itemProps[i].Name) && itemProps[i].PropertyType != typeof(object))
                            return TypeDescriptor.GetProperties(itemProps[i].PropertyType, new Attribute[] {new BrowsableAttribute(true)});
                    }
                    // return the properties on the type of the first element in the list
                    IList list = dataSources[offset - 1] as IList;
                    if (list != null && list.Count > 0)
                        return TypeDescriptor.GetProperties(list[0]);
                } else {
                    return TypeDescriptor.GetProperties(listType);
                }
                return null;
            }

            System.Reflection.PropertyInfo[] props = listType.GetProperties();
            // PropertyDescriptorCollection props = TypeDescriptor.GetProperties(listType);
            if (typeof(IList).IsAssignableFrom(listType)) {
                PropertyDescriptorCollection itemProps = null;
                for (int i = 0; i < props.Length; i++) {
                    if ("Item".Equals(props[i].Name) && props[i].PropertyType != typeof(object)) {
                        // get all the properties that are not marked as Browsable(false)
                        //
                        itemProps = TypeDescriptor.GetProperties(props[i].PropertyType, new Attribute[] {new BrowsableAttribute(true)});
                    }
                }

                if (itemProps == null) {
                    // use the properties on the type of the first element in the list
                    // if offset == 0, then this means that the first dataSource did not have a strongly typed Item property.
                    // the dataSources are added only for relatedCurrencyManagers, so in this particular case
                    // we need to use the dataSource in the currencyManager. See ASURT 83035.
                    IList list;
                    if (offset == 0)
                        list = this.DataSource as IList;
                    else
                        list = dataSources[offset - 1] as IList;
                    if (list != null && list.Count > 0) {
                        itemProps = TypeDescriptor.GetProperties(list[0]);
                    }
                }

                if (itemProps != null) {
                    for (int j=0; j<itemProps.Count; j++) {
                        if (itemProps[j].Equals(listAccessors[offset]))
                            return this.GetItemProperties(itemProps[j].PropertyType, offset + 1, dataSources, listAccessors);
                    }
                }

            } else {
                for (int i = 0; i < props.Length; i++) {
                    if (props[i].Name.Equals(((PropertyDescriptor)listAccessors[offset]).Name))
                        return this.GetItemProperties(props[i].PropertyType, offset + 1, dataSources, listAccessors);
                }
            }
            return null;
        }

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.CurrentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler CurrentChanged {
            add {
                onCurrentChangedHandler += value;
            }
            remove {
                onCurrentChangedHandler -= value;
            }
        }

        internal abstract String GetListName();
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.CancelCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void CancelCurrentEdit();
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.EndCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void EndCurrentEdit();

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.AddNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void AddNew();
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void RemoveAt(int index);

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.Position"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract int Position{get; set;}

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.PositionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PositionChanged {
            add {
                this.onPositionChangedHandler += value;
            }
            remove {
                this.onPositionChangedHandler -= value;
            }
        }
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.UpdateIsBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void UpdateIsBinding();

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.GetListName"]/*' />
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal abstract String GetListName(ArrayList listAccessors);

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.SuspendBinding"]/*' />
        public abstract void SuspendBinding();

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.ResumeBinding"]/*' />
        public abstract void ResumeBinding();

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.PullData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void PullData() {
            pullingData = true;
            try {
                UpdateIsBinding();
                int numLinks = Bindings.Count;
                for (int i = 0; i < numLinks; i++) {
                    Bindings[i].PullData();
                }
            }
            finally {
                pullingData = false;
            }
        }

        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.PushData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void PushData() {
            if (pullingData)
                return;

            UpdateIsBinding();
            int numLinks = Bindings.Count;
            for (int i = 0; i < numLinks; i++) {
                Bindings[i].PushData();
            }
        }

        internal abstract object DataSource {
            get;
        }

        internal abstract bool IsBinding {
            get;
        }
        
        /// <include file='doc\BindingMAnagerBase.uex' path='docs/doc[@for="BindingManagerBase.Count"]/*' />
        public abstract int Count {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bindingmemberinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindingMemberInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using System.Globalization;
    
    /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public struct BindingMemberInfo {
        private string dataList;
        private string dataField;
            
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.BindingMemberInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public BindingMemberInfo(string dataMember) {
            if (dataMember == null)
                dataMember = "";
                    
            int lastDot = dataMember.LastIndexOf(".");
            if (lastDot != -1) {
                dataList = dataMember.Substring(0,lastDot);
                dataField = dataMember.Substring(lastDot+1);
            }
            else {
                dataList = "";
                dataField = dataMember;
            }
        }
            
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.BindingPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BindingPath {
            get {
                return (dataList != null ? dataList : "");
            }
        }
            
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.BindingField"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BindingField {
            get {
                return (dataField != null ? dataField : "");
            }
        }
            
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.BindingMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BindingMember {
            get {
                return (BindingPath.Length > 0 ? BindingPath + "." + BindingField : BindingField);
            }
        }
            
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object otherObject) {
            if (otherObject is BindingMemberInfo) {
                BindingMemberInfo otherMember = (BindingMemberInfo) otherObject;
                return (String.Compare(this.BindingMember, otherMember.BindingMember, true, CultureInfo.InvariantCulture) == 0);
            }
            return false;
        }
        
        /// <include file='doc\DataMemberInfo.uex' path='docs/doc[@for="BindingMemberInfo.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bindingscollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindingsCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;
    
    /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection"]/*' />
    /// <devdoc>
    ///    <para>Represents a collection of data bindings on a control.</para>
    /// </devdoc>
    [DefaultEvent("CollectionChanged")]
    public class BindingsCollection : System.Windows.Forms.BaseCollection {

        private ArrayList list;
        private CollectionChangeEventHandler onCollectionChanged;

        // internalonly
        internal BindingsCollection() {
        }

        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.Count"]/*' />
        public override int Count {
            get {
                if (list == null) {
                    return 0;
                }
                return base.Count;
            }
        }

        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.List"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the bindings in the collection as an object.
        ///    </para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                if (list == null)
                    list = new ArrayList();
                return list;
            }
        }
        
        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Windows.Forms.Binding'/> at the specified index.</para>
        /// </devdoc>
        public Binding this[int index] {
            get {
                return (Binding) List[index];
            }
        }

        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.Add"]/*' />
        // internalonly
        internal protected void Add(Binding binding) {
            AddCore(binding);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, binding));
        }

        // internalonly
        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.AddCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Adds a <see cref='System.Windows.Forms.Binding'/>
        ///       to the collection.
        ///    </para>
        /// </devdoc>
        protected virtual void AddCore(Binding dataBinding) {
            if (dataBinding == null)
                throw new ArgumentNullException("dataBinding");

            List.Add(dataBinding);
        }

        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the collection is changed.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.collectionChangedEventDescr)]
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChanged += value;
            }
            remove {
                onCollectionChanged -= value;
            }
        }


        // internalonly
        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.Clear"]/*' />
        internal protected void Clear() {
            ClearCore();
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        // internalonly
        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.ClearCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Clears the collection of any members.
        ///    </para>
        /// </devdoc>
        protected virtual void ClearCore() {
            List.Clear();
        }

        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.BindingsCollection.CollectionChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChanged != null) {
                onCollectionChanged(this, ccevent);
            }
        }


        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.Remove"]/*' />
        // internalonly
        internal protected void Remove(Binding binding) {
            RemoveCore(binding);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, binding));
        }


        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.RemoveAt"]/*' />
        // internalonly
        internal protected void RemoveAt(int index) {
            Remove(this[index]);
        }

        // internalonly
        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.RemoveCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Removes the specified <see cref='System.Windows.Forms.Binding'/> from the collection.
        ///    </para>
        /// </devdoc>
        protected virtual void RemoveCore(Binding dataBinding) {
            List.Remove(dataBinding);
        }


        /// <include file='doc\BindingsCollection.uex' path='docs/doc[@for="BindingsCollection.ShouldSerializeMyAll"]/*' />
        // internalonly
        internal protected bool ShouldSerializeMyAll() {
            return Count > 0;
        }

        // internalonly
        private void OnBadIndex(object index) {
            throw new IndexOutOfRangeException(SR.GetString(SR.BindingsCollectionBadIndex, index.ToString()));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bindtoobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindToObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
   
    internal class BindToObject {
        private PropertyDescriptor fieldInfo;
        private BindingMemberInfo dataMember;
        private Object dataSource;
        private BindingManagerBase bindingManager;
        private Binding owner;

        private void PropValueChanged(object sender, EventArgs e) {
            this.bindingManager.OnCurrentChanged(EventArgs.Empty);
        }

        internal BindToObject(Binding owner, Object dataSource, string dataMember) {
            this.owner = owner;
            this.dataSource = dataSource;
            this.dataMember = new BindingMemberInfo(dataMember);
            CheckBinding();
        }

        internal void SetBindingManagerBase(BindingManagerBase lManager) {
            if (bindingManager == lManager)
                return;

            // remove notification from the backEnd
            if (bindingManager != null && fieldInfo != null && bindingManager.IsBinding && !(bindingManager is CurrencyManager)) {
                fieldInfo.RemoveValueChanged(bindingManager.Current, new EventHandler(PropValueChanged));
                fieldInfo = null;
            }

            this.bindingManager = lManager;
            CheckBinding();
        }

        internal Object GetValue() {
            object obj = bindingManager.Current;
            if (fieldInfo != null) {
               obj = fieldInfo.GetValue(obj);
            } else {
                return bindingManager.Current;
            }
            return obj;
        }

        internal Type BindToType {
            get {
                if (dataMember.BindingField.Length == 0) {
                    // if we are bound to a list w/o any properties, then
                    // take the type from the BindingManager
                    Type type = this.bindingManager.BindType;
                    if (typeof(Array).IsAssignableFrom(type))
                        type = type.GetElementType();
                    return type;
                }
                else
                    return fieldInfo == null ? null : fieldInfo.PropertyType;
            }
        }

        internal void SetValue(Object value) {
            if (fieldInfo != null) {
                object obj = bindingManager.Current;
                if (obj is IEditableObject)
                    ((IEditableObject) obj).BeginEdit();
                //(bug 112947) .. checkif the Column is readonly while pushing data...
                if (!fieldInfo.IsReadOnly) {
                    fieldInfo.SetValue(obj, value);
                }
                
            }
            else {
                CurrencyManager cm = bindingManager as CurrencyManager;
                if (cm != null)
                    cm[cm.Position] = value;
            }
        }

        internal BindingMemberInfo BindingMemberInfo {
            get {
                return this.dataMember;
            }
        }

        internal Object DataSource {
            get {
                return dataSource;
            }
            set {
                if (dataSource != value) {
                    Object oldDataSource = dataSource;
                    this.dataSource = value;
                    try {
                        CheckBinding();
                    }
                    catch {
                        dataSource = oldDataSource;
                        throw;
                    }
                }
            }
        }

        internal BindingManagerBase BindingManagerBase {
            get {
                return this.bindingManager;
            }
        }

        internal void CheckBinding() {

            // At design time, don't check anything.
            //
            if (owner != null && owner.Control != null) {
                ISite site = owner.Control.Site;

                if (site != null && site.DesignMode) {
                    return;
                }
            }

            // force Column to throw if it's currently a bad column.
            //DataColumn tempColumn = this.Column;

            // remove propertyChangedNotification when this binding is deleted
            if(this.owner.BindingManagerBase != null && this.fieldInfo != null && this.owner.BindingManagerBase.IsBinding && !(this.owner.BindingManagerBase is CurrencyManager))
                fieldInfo.RemoveValueChanged(owner.BindingManagerBase.Current, new EventHandler(PropValueChanged));

            if (owner != null && owner.BindingManagerBase != null && owner.Control != null && owner.Control.Created) {
                string dataField = dataMember.BindingField;

                fieldInfo = owner.BindingManagerBase.GetItemProperties().Find(dataField, true);
                if (fieldInfo == null && dataField.Length > 0) {
                    throw new ArgumentException(SR.GetString(SR.ListBindingBindField, dataField), "dataMember");
                }
                // Do not add propertyChange notification if
                // the fieldInfo is null                
                //
                // we add an event handler to the dataSource in the BindingManagerBase because
                // if the binding is of the form (Control, ControlProperty, DataSource, Property1.Property2.Property3)
                // then we want to get notification from Current.Property1.Property2 and not from DataSource
                // when we get the backEnd notification we push the new value into the Control's property
                //
                if (fieldInfo != null && owner.BindingManagerBase.IsBinding && !(this.owner.BindingManagerBase is CurrencyManager))
                    fieldInfo.AddValueChanged(this.owner.BindingManagerBase.Current, new EventHandler(PropValueChanged));
            }
            else {
                fieldInfo = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\border3dside.cs ===
//------------------------------------------------------------------------------
// <copyright file="Border3DSide.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       the sides of a rectangle to apply a three-dimensional border to.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true), Flags]
    public enum Border3DSide {

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border on
        ///       the left edge
        ///       of the control.
        ///    </para>
        /// </devdoc>
        Left = NativeMethods.BF_LEFT,

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border on
        ///       the top edge
        ///       of the rectangle.
        ///    </para>
        /// </devdoc>
        Top = NativeMethods.BF_TOP,

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border on
        ///       the right side
        ///       of the rectangle.
        ///    </para>
        /// </devdoc>
        Right = NativeMethods.BF_RIGHT,

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border on
        ///       the bottom side
        ///       of the rectangle.
        ///    </para>
        /// </devdoc>
        Bottom = NativeMethods.BF_BOTTOM,

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.Middle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The interior of the rectangle is filled with the
        ///       color defined for three-dimensional controls instead of the
        ///       background color
        ///       for the form.
        ///    </para>
        /// </devdoc>
        Middle = NativeMethods.BF_MIDDLE,

        /// <include file='doc\Border3DSide.uex' path='docs/doc[@for="Border3DSide.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border on all four
        ///       edges and fill the middle of
        ///       the rectangle with
        ///       the color defeined for three-dimensional controls.
        ///    </para>
        /// </devdoc>
        All  = Left | Top | Right | Bottom | Middle,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\application.cs ===
//------------------------------------------------------------------------------
// <copyright file="Application.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Diagnostics;    
    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Globalization;

    using System.Reflection;
    using System.ComponentModel;
    using System.Drawing;
    using System.Windows.Forms;
    using File=System.IO.File;
    using Directory=System.IO.Directory;

    /// <include file='doc\Application.uex' path='docs/doc[@for="Application"]/*' />
    /// <devdoc>
    /// <para>Provides <see langword='static '/>
    /// methods and properties
    /// to manage an application, such as methods to run and quit an application,
    /// to process Windows messages, and properties to get information about an application. This
    /// class cannot be inherited.</para>
    /// </devdoc>
    public sealed class Application {
        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.eventHandlers"]/*' />
        /// <devdoc>
        ///     Hash table for our event list
        /// </devdoc>
        static EventHandlerList eventHandlers;
        static string startupPath;
        static string executablePath;
        static object appFileVersion;
        static Type mainType;
        static string companyName;
        static string productName;
        static string productVersion;
        static string safeTopLevelCaptionSuffix;


        static bool useVisualStyles = false;

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.exiting"]/*' />
        /// <devdoc>
        ///     in case Application.exit gets called recursively
        /// </devdoc>
        private static bool exiting;

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.EVENT_APPLICATIONEXIT"]/*' />
        /// <devdoc>
        ///     Events the user can hook into
        /// </devdoc>
        private static readonly object EVENT_APPLICATIONEXIT = new object();
        private static readonly object EVENT_THREADEXIT      = new object();

        private static readonly int MSG_APPQUIT = SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + "AppQuit");

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Application"]/*' />
        /// <devdoc>
        ///     This class is static, there is no need to ever create it.
        /// </devdoc>
        private Application() {
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.AllowQuit"]/*' />
        /// <devdoc>
        ///    <para>
        ///      Determines if the caller should be allowed to quit the application.  This will return false,
        ///      for example, if being called from a windows forms control being hosted within a web browser.  The
        ///      windows forms control should not attempt to quit the application.
        ///
        ///    </para>
        /// </devdoc>
        public static bool AllowQuit {
            get {
                return ThreadContext.FromCurrent().GetAllowQuit();
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CommonAppDataRegistry"]/*' />
        /// <devdoc>
        ///    <para>Gets the registry
        ///       key for the application data that is shared among all users.</para>
        /// </devdoc>
        public static RegistryKey CommonAppDataRegistry {
            get {
                string template = @"Software\{0}\{1}\{2}";
                return Registry.LocalMachine.CreateSubKey(string.Format(template,
                                                                      CompanyName,
                                                                      ProductName,
                                                                      ProductVersion));
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CommonAppDataPath"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the path for the application data that is shared among all users.</para>
        /// </devdoc>
        public static string CommonAppDataPath {
            // NOTE   : Don't obsolete these. GetDataPath isn't on SystemInformation, and it
            //        : provides the Win2K logo required adornments to the directory (Company\Product\Version)
            //
            get {
                return GetDataPath(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData));
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CompanyName"]/*' />
        /// <devdoc>
        ///    <para>Gets the company name associated with the application.</para>
        /// </devdoc>
        public static string CompanyName {
            get {
                lock(typeof(Application)) {
                    if (companyName == null) {
                        
                        // custom attribute
                        //
                        Type t = GetAppMainType();

                        if (t == null) {
                            companyName = "";
                            return companyName;
                        }

                        object[] attrs = t.Module.Assembly.GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                        if (attrs != null && attrs.Length > 0) {
                            companyName = ((AssemblyCompanyAttribute)attrs[0]).Company;
                        }

                        // win32 version
                        //
                        if (companyName == null || companyName.Length == 0) {
                            companyName = GetAppFileVersionInfo().CompanyName;
                            if (companyName != null) {
                                companyName = companyName.Trim();
                            }
                        }

                        // fake it with a namespace
                        //
                        if (companyName == null || companyName.Length == 0) {
                            string ns = GetAppMainType().Namespace;

                            if (ns == null)
                                ns = "";

                            int firstDot = ns.IndexOf(".");
                            if (firstDot != -1) {
                                companyName = ns.Substring(0, firstDot);
                            }
                            else {
                                companyName = ns;
                            }
                        }

                        // last ditch... no namespace, use product name...
                        //
                        if (companyName == null || companyName.Length == 0) {
                            companyName = ProductName;
                        }
                    }
                }
                return companyName;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CurrentCulture"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the locale information for the current thread.</para>
        /// </devdoc>
        public static CultureInfo CurrentCulture {
            get {
                return Thread.CurrentThread.CurrentCulture;
            }
            set {
                Thread.CurrentThread.CurrentCulture = value;
            }
        }


        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CurrentInputLanguage"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the current input language for the current thread.</para>
        /// </devdoc>
        public static InputLanguage CurrentInputLanguage {
            get {
                return InputLanguage.CurrentInputLanguage;
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AffectThreadBehavior Demanded");
                IntSecurity.AffectThreadBehavior.Demand();
                InputLanguage.CurrentInputLanguage = value;
            }
        }

        internal static bool CustomThreadExceptionHandlerAttached {
            get {
                return ThreadContext.FromCurrent().CustomThreadExceptionHandlerAttached;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ExecutablePath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       path for the executable file that started the application.
        ///    </para>
        /// </devdoc>
        public static string ExecutablePath {
            get {
                if (executablePath == null) {
                    Assembly asm = Assembly.GetEntryAssembly();
                    if (asm == null) {
                        StringBuilder sb = new StringBuilder(NativeMethods.MAX_PATH);
                        UnsafeNativeMethods.GetModuleFileName(NativeMethods.NullHandleRef, sb, sb.Capacity);
                        
                        executablePath = IntSecurity.UnsafeGetFullPath(sb.ToString());
                    }
                    else {
                        AssemblyName name = asm.GetName();
                        Uri codeBase = new Uri(name.EscapedCodeBase);
                        if (codeBase.Scheme == "file") {
                            executablePath = NativeMethods.GetLocalPath(name.EscapedCodeBase);
                        }
                        else {
                            executablePath = codeBase.ToString();
                        }
                    }
                }
                Uri exeUri = new Uri(executablePath);
                if (exeUri.Scheme == "file") {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + executablePath + ") Demanded");
                    new FileIOPermission(FileIOPermissionAccess.PathDiscovery, executablePath).Demand();
                }
                return executablePath;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.LocalUserAppDataPath"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the path for the application data specific to a local, non-roaming
        ///       user.</para>
        /// </devdoc>
        public static string LocalUserAppDataPath {
            // NOTE   : Don't obsolete these. GetDataPath isn't on SystemInformation, and it
            //        : provides the Win2K logo required adornments to the directory (Company\Product\Version)
            //
            get {
                return GetDataPath(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.MessageLoop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a message loop exists on this thread.
        ///    </para>
        /// </devdoc>
        public static bool MessageLoop {
            get {
                return ThreadContext.FromCurrent().GetMessageLoop();
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ProductName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the product name associated with this application.
        ///    </para>
        /// </devdoc>
        public static string ProductName {
            get {
                lock(typeof(Application)) {
                    if (productName == null) {
                        
                        // custom attribute
                        //
                        Type t = GetAppMainType();

                        if (t == null) {
                            productName = "";
                            return productName;
                        }

                        object[] attrs = t.Module.Assembly.GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                        if (attrs != null && attrs.Length > 0) {
                            productName = ((AssemblyProductAttribute)attrs[0]).Product;
                        }

                        // win32 version info
                        //
                        if (productName == null || productName.Length == 0) {
                            productName = GetAppFileVersionInfo().ProductName;
                            if (productName != null) {
                                productName = productName.Trim();
                            }
                        }

                        // fake it with namespace
                        //
                        if (productName == null || productName.Length == 0) {
                            string ns = GetAppMainType().Namespace;

                            if (ns == null)
                                ns = "";

                            int lastDot = ns.LastIndexOf(".");
                            if (lastDot != -1 && lastDot < ns.Length - 1) {
                                productName = ns.Substring(lastDot+1);
                            }
                            else {
                                productName = ns;
                            }
                        }

                        // last ditch... use the main type
                        //
                        if (productName == null || productName.Length == 0) {
                            productName = GetAppMainType().Name;
                        }
                    }
                }

                return productName;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ProductVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the product version associated with this application.
        ///    </para>
        /// </devdoc>
        public static string ProductVersion {
            get {
                lock(typeof(Application)) {
                    if (productVersion == null) {
                        
                        // custom attribute
                        //
                        Type t = GetAppMainType();
                        if (t != null) {
                            
                            object[] attrs = t.Module.Assembly.GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute), false);
                            if (attrs != null && attrs.Length > 0) {
                                productVersion = ((AssemblyInformationalVersionAttribute)attrs[0]).InformationalVersion;
                            }
    
                            // win32 version info
                            //
                            if (productVersion == null || productVersion.Length == 0) {
                                productVersion = GetAppFileVersionInfo().ProductVersion;
                                if (productVersion != null) {
                                    productVersion = productVersion.Trim();
                                }
                            }
                        }

                        // fake it
                        //
                        if (productVersion == null || productVersion.Length == 0) {
                            productVersion = "1.0.0.0";
                        }
                    }
                }
                return productVersion;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.SafeTopLevelCaptionFormat"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the format string to apply to top level window captions
        ///       when they are displayed with a warning banner.</para>
        /// </devdoc>
        public static string SafeTopLevelCaptionFormat {
            get {
                if (safeTopLevelCaptionSuffix == null) {
                    safeTopLevelCaptionSuffix = SR.GetString(SR.SafeTopLevelCaptionFormat); // 0 - original, 1 - zone, 2 - site
                }
                return safeTopLevelCaptionSuffix;
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "WindowAdornmentModification Demanded");
                IntSecurity.WindowAdornmentModification.Demand();
                if (value == null) value = string.Empty;
                safeTopLevelCaptionSuffix = value;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.StartupPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       path for the executable file that started the application.
        ///    </para>
        /// </devdoc>
        public static string StartupPath {
            get {
                if (startupPath == null) {
                    StringBuilder sb = new StringBuilder(NativeMethods.MAX_PATH);
                    UnsafeNativeMethods.GetModuleFileName(NativeMethods.NullHandleRef, sb, sb.Capacity);
                    startupPath = Path.GetDirectoryName(sb.ToString());
                }
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + startupPath + ") Demanded");
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, startupPath).Demand();
                return startupPath;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.UserAppDataPath"]/*' />
        /// <devdoc>
        ///    <para>Gets the path for the application data specific to the roaming
        ///       user.</para>
        /// </devdoc>
        public static string UserAppDataPath {
            // NOTE   : Don't obsolete these. GetDataPath isn't on SystemInformation, and it
            //        : provides the Win2K logo required adornments to the directory (Company\Product\Version)
            //
            get {
                return GetDataPath(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.UserAppDataRegistry"]/*' />
        /// <devdoc>
        ///    <para>Gets the registry key of
        ///       the application data specific to the roaming user.</para>
        /// </devdoc>
        public static RegistryKey UserAppDataRegistry {
            get {
                string template = @"Software\{0}\{1}\{2}";
                return Registry.CurrentUser.CreateSubKey(string.Format(template, CompanyName, ProductName, ProductVersion));
            }
        }

        internal static string WindowsFormsVersion {
            get {
                return "WindowsForms10";
            }
        }

        internal static string WindowMessagesVersion {
            get {
                return "WindowsForms11";
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ApplicationExit"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the application is about to shut down.</para>
        /// </devdoc>
        public static event EventHandler ApplicationExit {
            add {
                AddEventHandler(EVENT_APPLICATIONEXIT, value);
            }
            remove {
                RemoveEventHandler(EVENT_APPLICATIONEXIT, value);
            }
        }

        private static void AddEventHandler(object key, Delegate value) {
            lock(typeof(Application)) {
                if (null == eventHandlers) {
                    eventHandlers = new EventHandlerList();
                }
                eventHandlers.AddHandler(key, value);
            }
        }
        private static void RemoveEventHandler(object key, Delegate value) {
            lock(typeof(Application)) {
                if (null == eventHandlers) {
                    return;
                }
                eventHandlers.RemoveHandler(key, value);
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.AddMessageFilter"]/*' />
        /// <devdoc>
        ///    <para>Adds a message filter to monitor Windows messages as they are routed to their 
        ///       destinations.</para>
        /// </devdoc>
        public static void AddMessageFilter(IMessageFilter value) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ManipulateWndProcAndHandles Demanded");
            IntSecurity.UnmanagedCode.Demand();
            ThreadContext.FromCurrent().AddMessageFilter(value);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Idle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the application has finished processing and is about to enter the
        ///       idle state.
        ///    </para>
        /// </devdoc>
        public static event EventHandler Idle {
            add {
                ThreadContext current = ThreadContext.FromCurrent();
                lock(current) {
                    current.idleHandler += value;
                    
                    // This just ensures that the component manager is hooked up.  We
                    // need it for idle time processing.
                    //
                    object o = current.ComponentManager;
                }
            }
            remove {
                ThreadContext current = ThreadContext.FromCurrent();
                lock(current) {
                    current.idleHandler -= value;
                }
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadException"]/*' />
        /// <devdoc>
        ///    <para>Occurs when an untrapped thread exception is thrown.</para>
        /// </devdoc>
        public static event ThreadExceptionEventHandler ThreadException {
            add {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AffectThreadBehavior Demanded");
                IntSecurity.AffectThreadBehavior.Demand();

                ThreadContext current = ThreadContext.FromCurrent();
                lock(current) {
                    current.threadExceptionHandler = value;
                }
            }
            remove {
                ThreadContext current = ThreadContext.FromCurrent();
                lock(current) {
                    current.threadExceptionHandler -= value;
                }
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadExit"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a thread is about to shut down.  When 
        ///     the main thread for an application is about to be shut down, 
        ///     this event will be raised first, followed by an ApplicationExit
        ///     event.</para>
        /// </devdoc>
        public static event EventHandler ThreadExit {
            add {
                AddEventHandler(EVENT_THREADEXIT, value);
            }
            remove {
                RemoveEventHandler(EVENT_THREADEXIT, value);
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.BeginModalMessageLoop"]/*' />
        /// <devdoc>
        ///     Called immediately before we begin pumping messages for a modal message loop.
        ///     Does not actually start a message pump; that's the caller's responsibility.
        /// </devdoc>
        /// <internalonly/>
        internal static void BeginModalMessageLoop() {
            ThreadContext.FromCurrent().BeginModalMessageLoop();
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.CollectAllGarbage"]/*' />
        /// <devdoc>
        ///     Garbage collects until there isn't anything left to collect.
        /// </devdoc>
        internal static void CollectAllGarbage() {
            
            //REVIEW: jruiz - This is exactly what GC.GetTotalMemory(forceFullCollection) 
            //                is about.
            GC.GetTotalMemory(true);
             
            //long isAllocated = GC.TotalMemory();
            //long wasAllocated;
            //do {
            //    wasAllocated = isAllocated;
            //    GC.Collect();
            //    isAllocated = GC.TotalMemory;
            //    GC.WaitForPendingFinalizers();
            //} while (isAllocated < wasAllocated);
        }

        /// <devdoc>
        ///     Internal method that is called by controls performing
        ///     ActiveX sourcing when the last ActiveX sourced control
        ///     goes away and we are being hosted in IE.
        /// </devdoc>
        internal static void DisposeParkingWindow(Control control) {
            lock(typeof(Application)) {
                ThreadContext cxt = null;

                if (control != null && control.IsHandleCreated) {
                    int pid;
                    int id = SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(control, control.Handle), out pid);
                    cxt = ThreadContext.FromId(id);
                }
                else {
                    cxt = ThreadContext.FromCurrent();
                }

                if (cxt != null) {
                    cxt.DisposeParkingWindow();
                }
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.DoEvents"]/*' />
        /// <devdoc>
        ///    <para>Processes
        ///       all Windows messages currently in the message queue.</para>
        /// </devdoc>
        public static void DoEvents() {
            ThreadContext.FromCurrent().RunMessageLoop(NativeMethods.MSOCM.msoloopDoEvents, null);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.EnableVisualStyles"]/*' />
        /// <devdoc>
        ///    <para>Enables visual styles for all subsequent Application.Run()'s.</para>
        /// </devdoc>
        public static void EnableVisualStyles()
        {
            useVisualStyles = true;
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.EndModalMessageLoop"]/*' />
        /// <devdoc>
        ///     Called immediately after we stop pumping messages for a modal message loop.
        ///     Does not actually end the message pump itself.
        /// </devdoc>
        /// <internalonly/>
        internal static void EndModalMessageLoop() {
            ThreadContext.FromCurrent().EndModalMessageLoop();
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Exit"]/*' />
        /// <devdoc>
        ///    <para>Informs all message pumps that they are to terminate and 
        ///       then closes all application windows after the messages have been processed.</para>
        /// </devdoc>
        public static void Exit() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AffectThreadBehavior Demanded");
            IntSecurity.AffectThreadBehavior.Demand();

            lock(typeof(Application)) {
                if (exiting) return;

                exiting = true;

                try {
                    ThreadContext.ExitApplication();
                }
                finally {
                    exiting = false;
                }
            }
            CollectAllGarbage();
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ExitThread"]/*' />
        /// <devdoc>
        ///    <para>Exits the message loop on the
        ///       current thread and closes all windows on the thread.</para>
        /// </devdoc>
        public static void ExitThread() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AffectThreadBehavior Demanded");
            IntSecurity.AffectThreadBehavior.Demand();

            ExitThreadInternal();
        }

        private static void ExitThreadInternal() {
            ThreadContext context = ThreadContext.FromCurrent();
            if (context.ApplicationContext != null) {
                context.ApplicationContext.ExitThread();
            }
            else {
                context.Dispose();
            }
            CollectAllGarbage();
        }

        // When a Form receives a WM_ACTIVATE message, it calls this method so we can do the
        // appropriate MsoComponentManager activation magic
        internal static void FormActivated(bool modal, bool activated) {
                if (modal) {
                    return;
                }
                
                ThreadContext.FromCurrent().FormActivated(activated);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.GetAppFileVersionInfo"]/*' />
        /// <devdoc>
        ///     Retrieves the FileVersionInfo associated with the main module for
        ///     the application.
        /// </devdoc>
        private static FileVersionInfo GetAppFileVersionInfo() {
            lock (typeof(Application)) {
                if (appFileVersion == null) {
                    Type t = GetAppMainType();
                    if (t != null) {
                        
                        FileIOPermission fiop = new FileIOPermission( PermissionState.None );
                        fiop.AllFiles = FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read;
                        fiop.Assert();

                        try {
                            appFileVersion = FileVersionInfo.GetVersionInfo(GetAppMainType().Module.FullyQualifiedName); 
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    else {
                        appFileVersion = FileVersionInfo.GetVersionInfo(ExecutablePath);
                    }
                }
            }

            return(FileVersionInfo)appFileVersion;
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.GetAppMainType"]/*' />
        /// <devdoc>
        ///     Retrieves the Type that contains the "Main" method.
        /// </devdoc>
        private static Type GetAppMainType() {
            lock(typeof(Application)) {
                if (mainType == null) {
                    Assembly exe = Assembly.GetEntryAssembly();
                    
                    if (exe != null) {
                        mainType = exe.EntryPoint.ReflectedType;
                    }
                }
                Debug.Assert(mainType != null, "You must have a main!!");
            }

            return mainType;
        }


        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.GetDataPath"]/*' />
        /// <devdoc>
        ///     Returns a string that is the combination of the
        ///     basePath + CompanyName + ProducName + ProductVersion. This
        ///     will also create the directory if it doesn't exist.
        /// </devdoc>
        private static string GetDataPath(String basePath) {
            string template = @"{0}\{1}\{2}\{3}";

            string company = CompanyName;
            string product = ProductName;
            string version = ProductVersion;

            string path = string.Format(template, new object[] {basePath, company, product, version});
            lock(typeof(Application)) {
                if (!Directory.Exists(path)) {
                    Directory.CreateDirectory(path);
                }
            }
            return path;
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.RaiseExit"]/*' />
        /// <devdoc>
        ///     Called by the last thread context before it shuts down.
        /// </devdoc>
        private static void RaiseExit() {
            if (eventHandlers != null) {
                Delegate exit = eventHandlers[EVENT_APPLICATIONEXIT];
                if (exit != null)
                    ((EventHandler)exit).Invoke(null, EventArgs.Empty);
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.RaiseThreadExit"]/*' />
        /// <devdoc>
        ///     Called by the each thread context before it shuts down.
        /// </devdoc>
        private static void RaiseThreadExit() {
            if (eventHandlers != null) {
                Delegate exit = eventHandlers[EVENT_THREADEXIT];
                if (exit != null) {
                    ((EventHandler)exit).Invoke(null, EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.GetParkingWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Retrieves
        ///       the parking window for the thread that owns
        ///       the <paramref term="control"/>
        ///       .
        ///
        ///    </para>
        /// </devdoc>
        internal static Control GetParkingWindow(Control control) {
            lock(typeof(Application)) {
                ThreadContext cxt = null;

                if (control != null && control.IsHandleCreated) {
                    int pid;
                    int id = SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(control, control.Handle), out pid);
                    cxt = ThreadContext.FromId(id);
                }
                else {
                    cxt = ThreadContext.FromCurrent();
                }

                if (cxt == null) {
                    return null;
                }

                return cxt.GetParkingWindow();
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.OleRequired"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes OLE on the current thread.
        ///    </para>
        /// </devdoc>
        public static System.Threading.ApartmentState OleRequired() {
            return ThreadContext.FromCurrent().OleRequired();
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.OnThreadException"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Application.ThreadException'/> event.</para>
        /// </devdoc>
        public static void OnThreadException(Exception t) {
            ThreadContext.FromCurrent().OnThreadException(t);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.RemoveMessageFilter"]/*' />
        /// <devdoc>
        ///    <para>Removes a message
        ///       filter from the application's message pump.</para>
        /// </devdoc>
        public static void RemoveMessageFilter(IMessageFilter value) {
            ThreadContext.FromCurrent().RemoveMessageFilter(value);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Run"]/*' />
        /// <devdoc>
        ///    <para>Begins running a
        ///       standard
        ///       application message loop on the current thread,
        ///       without a form.</para>
        /// </devdoc>
        public static void Run() {
            ThreadContext.FromCurrent().RunMessageLoop(NativeMethods.MSOCM.msoloopMain, new ApplicationContext());
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Run1"]/*' />
        /// <devdoc>
        ///    <para>Begins running a standard application message loop on the current
        ///       thread, and makes the specified form visible.</para>
        /// </devdoc>
        public static void Run(Form mainForm) {
            ThreadContext.FromCurrent().RunMessageLoop(NativeMethods.MSOCM.msoloopMain, new ApplicationContext(mainForm));
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.Run2"]/*' />
        /// <devdoc>
        ///    <para>Begins running a
        ///       standard
        ///       application message loop on the current thread,
        ///       without a form.</para>
        /// </devdoc>
        public static void Run(ApplicationContext context) {
            ThreadContext.FromCurrent().RunMessageLoop(NativeMethods.MSOCM.msoloopMain, context);
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.RunDialog"]/*' />
        /// <devdoc>
        ///     Runs a modal dialog.  This starts a special type of message loop that runs until
        ///     the dialog has a valid DialogResult.  This is called internally by a form
        ///     when an application calls System.Windows.Forms.Form.ShowDialog().
        /// </devdoc>
        /// <internalonly/>
        internal static void RunDialog(Form form) {
            ThreadContext.FromCurrent().RunMessageLoop(NativeMethods.MSOCM.msoloopModalForm, new ModalApplicationContext(form));
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager"]/*' />
        /// <devdoc>
        ///      This is our implementation of the MSO ComponentManager.  The Componoent Manager is
        ///      an object that is responsible for handling all message loop activity in a process.
        ///      The idea is that someone in the process implements the component manager and then
        ///      anyone who wants access to the message loop can get to it.  We implement this
        ///      so we have good interop with office and VS.  The first time we need a
        ///      component manager, we search the OLE message filter for one.  If that fails, we
        ///      create our own and install it in the message filter.
        ///
        ///      This class is not used when running inside the Visual Studio shell.
        /// </devdoc>
        private class ComponentManager : UnsafeNativeMethods.IMsoComponentManager {

            // ComponentManager instance data.
            //
            private class ComponentHashtableEntry {
                public UnsafeNativeMethods.IMsoComponent component;
                public NativeMethods.MSOCRINFOSTRUCT componentInfo;
            }

            private Hashtable oleComponents;
            private int cookieCounter = 0;
            private UnsafeNativeMethods.IMsoComponent activeComponent = null;
            private UnsafeNativeMethods.IMsoComponent trackingComponent = null;
            private int currentState = 0;

            private Hashtable OleComponents {
                get {
                    if (oleComponents == null) {
                        oleComponents = new Hashtable();
                        cookieCounter = 0;
                    }

                    return oleComponents;
                }
            }                             

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.QueryService"]/*' />
            /// <devdoc>
            ///      Return in *ppvObj an implementation of interface iid for service
            ///      guidService (same as IServiceProvider::QueryService).
            ///      Return NOERROR if the requested service is supported, otherwise return
            ///      NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE).
            /// </devdoc>
            int UnsafeNativeMethods.IMsoComponentManager.QueryService(
                                                 ref Guid guidService,
                                                 ref Guid iid,
                                                 out object ppvObj) {

                ppvObj = null;                             
                return NativeMethods.E_NOINTERFACE;

            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FDebugMessage"]/*' />
            /// <devdoc>
            ///      Standard FDebugMessage method.
            ///      Since IMsoComponentManager is a reference counted interface, 
            ///      MsoDWGetChkMemCounter should be used when processing the 
            ///      msodmWriteBe message.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FDebugMessage(
                                                   IntPtr hInst, 
                                                   int msg, 
                                                   IntPtr wparam, 
                                                   IntPtr lparam) {

                return true;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FRegisterComponent"]/*' />
            /// <devdoc>
            ///      Register component piComponent and its registration info pcrinfo with
            ///      this component manager.  Return in *pdwComponentID a cookie which will
            ///      identify the component when it calls other IMsoComponentManager
            ///      methods.
            ///      Return TRUE if successful, FALSE otherwise.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FRegisterComponent(UnsafeNativeMethods.IMsoComponent component,
                                                         NativeMethods.MSOCRINFOSTRUCT pcrinfo,
                                                         out int dwComponentID) {

                // Construct Hashtable entry for this component
                //
                ComponentHashtableEntry entry = new ComponentHashtableEntry();
                entry.component = component;
                entry.componentInfo = pcrinfo;
                OleComponents.Add(++cookieCounter, entry);

                // Return the cookie
                //
                dwComponentID = cookieCounter;
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager: Component registered.  ID: " + cookieCounter.ToString());
                return true;
            }                                

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FRevokeComponent"]/*' />
            /// <devdoc>
            ///      Undo the registration of the component identified by dwComponentID
            ///      (the cookie returned from the FRegisterComponent method).
            ///      Return TRUE if successful, FALSE otherwise.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FRevokeComponent(int dwComponentID) {

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager: Revoking component " + dwComponentID.ToString());

                ComponentHashtableEntry entry = (ComponentHashtableEntry)OleComponents[dwComponentID];
                if (entry == null) {
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Compoenent not registered.");
                    return false;
                }

                if (entry.component == activeComponent) {
                    activeComponent = null;
                }
                if (entry.component == trackingComponent) {
                    trackingComponent = null;
                }

                OleComponents.Remove(dwComponentID);                

                return true;                                

            }                                

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FUpdateComponentRegistration"]/*' />
            /// <devdoc>
            ///      Update the registration info of the component identified by
            ///      dwComponentID (the cookie returned from FRegisterComponent) with the
            ///      new registration information pcrinfo.
            ///      Typically this is used to update the idle time registration data, but
            ///      can be used to update other registration data as well.
            ///      Return TRUE if successful, FALSE otherwise.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FUpdateComponentRegistration(
                                                                  int dwComponentID,
                                                                  NativeMethods.MSOCRINFOSTRUCT info
                                                                  ) {

                // Update the registration info
                //
                ComponentHashtableEntry entry = (ComponentHashtableEntry)OleComponents[dwComponentID];
                if (entry == null) {
                    return false;
                }

                entry.componentInfo = info;

                return true;                                            
            }                                            

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FOnComponentActivate"]/*' />
            /// <devdoc>
            ///      Notify component manager that component identified by dwComponentID
            ///      (cookie returned from FRegisterComponent) has been activated.
            ///      The active component gets the chance to process messages before they
            ///      are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
            ///      gets first crack at idle time after the host.
            ///      This method fails if another component is already Exclusively Active.
            ///      In this case, FALSE is returned and SetLastError is set to 
            ///      msoerrACompIsXActive (comp usually need not take any special action
            ///      in this case).
            ///      Return TRUE if successful.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FOnComponentActivate(int dwComponentID) {

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager: Component activated.  ID: " + dwComponentID.ToString());

                ComponentHashtableEntry entry = (ComponentHashtableEntry)OleComponents[dwComponentID];
                if (entry == null) {
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "*** Component not registered ***");
                    return false;
                }

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "New active component is : " + entry.component.ToString());
                activeComponent = entry.component;
                return true;
            }                                   

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FSetTrackingComponent"]/*' />
            /// <devdoc>
            ///      Called to inform component manager that  component identified by 
            ///      dwComponentID (cookie returned from FRegisterComponent) wishes
            ///      to perform a tracking operation (such as mouse tracking).
            ///      The component calls this method with fTrack == TRUE to begin the
            ///      tracking operation and with fTrack == FALSE to end the operation.
            ///      During the tracking operation the component manager routes messages
            ///      to the tracking component (via IMsoComponent::FPreTranslateMessage)
            ///      rather than to the active component.  When the tracking operation ends,
            ///      the component manager should resume routing messages to the active
            ///      component.  
            ///      Note: component manager should perform no idle time processing during a
            ///              tracking operation other than give the tracking component idle
            ///              time via IMsoComponent::FDoIdle.
            ///      Note: there can only be one tracking component at a time.
            ///      Return TRUE if successful, FALSE otherwise.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FSetTrackingComponent(int dwComponentID, bool fTrack) {

                ComponentHashtableEntry entry = (ComponentHashtableEntry)OleComponents[dwComponentID];
                if (entry == null) {
                    return false;
                }

                if (entry.component == trackingComponent ^ fTrack) {
                    return false;
                }

                if (fTrack) {
                    trackingComponent = entry.component;
                }
                else {
                    trackingComponent = null;
                }

                return true;
            }                                    

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.OnComponentEnterState"]/*' />
            /// <devdoc>
            ///      Notify component manager that component identified by dwComponentID
            ///      (cookie returned from FRegisterComponent) is entering the state
            ///      identified by uStateID (msocstateXXX value).  (For convenience when
            ///      dealing with sub CompMgrs, the host can call this method passing 0 for
            ///      dwComponentID.)  
            ///      Component manager should notify all other interested components within
            ///      the state context indicated by uContext (a msoccontextXXX value),
            ///      excluding those within the state context of a CompMgr in rgpicmExclude,
            ///      via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
            ///      above).
            ///      Component Manager should also take appropriate action depending on the 
            ///      value of uStateID (see msocstate comments, above).
            ///      dwReserved is reserved for future use and should be zero.
            ///      
            ///      rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
            ///      include root CompMgr and/or sub CompMgrs); components within the state
            ///      context of a CompMgr appearing in this     array should NOT be notified of 
            ///      the state change (note: if uContext        is msoccontextMine, the only 
            ///      CompMgrs in rgpicmExclude that are checked for exclusion are those that 
            ///      are sub CompMgrs of this Component Manager, since all other CompMgrs 
            ///      are outside of this Component Manager's state context anyway.)
            ///      
            ///      Note: Calls to this method are symmetric with calls to 
            ///      FOnComponentExitState. 
            ///      That is, if n OnComponentEnterState calls are made, the component is
            ///      considered to be in the state until n FOnComponentExitState calls are
            ///      made.  Before revoking its registration a component must make a 
            ///      sufficient number of FOnComponentExitState calls to offset any
            ///      outstanding OnComponentEnterState calls it has made.
            ///      
            ///      Note: inplace objects should not call this method with
            ///      uStateID == msocstateModal when entering modal state. Such objects
            ///      should call IOleInPlaceFrame::EnableModeless instead.
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponentManager.OnComponentEnterState(
                                                           int dwComponentID,
                                                           int uStateID,
                                                           int uContext,
                                                           int cpicmExclude,
                                                           int rgpicmExclude,          // IMsoComponentManger**
                                                           int dwReserved) {

                currentState |= uStateID;

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager: Component enter state.  ID: " + dwComponentID.ToString() + " state: " + uStateID.ToString());

                if (uContext == NativeMethods.MSOCM.msoccontextAll || uContext == NativeMethods.MSOCM.msoccontextMine) {

                    Debug.Indent();

                    // We should notify all components we contain that the state has changed.
                    //
                    foreach (ComponentHashtableEntry entry in OleComponents.Values) {
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Notifying " + entry.component.ToString());
                        entry.component.OnEnterState(uStateID, true);
                    }

                    Debug.Unindent();
                }
            }                                    

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FOnComponentExitState"]/*' />
            /// <devdoc>
            ///      Notify component manager that component identified by dwComponentID
            ///      (cookie returned from FRegisterComponent) is exiting the state
            ///      identified by uStateID (a msocstateXXX value).  (For convenience when
            ///      dealing with sub CompMgrs, the host can call this method passing 0 for
            ///      dwComponentID.)
            ///      uContext, cpicmExclude, and rgpicmExclude are as they are in 
            ///      OnComponentEnterState.
            ///      Component manager  should notify all appropriate interested components
            ///      (taking into account uContext, cpicmExclude, rgpicmExclude) via
            ///      IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
            ///      Component Manager should also take appropriate action depending on
            ///      the value of uStateID (see msocstate comments, above).
            ///      Return TRUE if, at the end of this call, the state is still in effect
            ///      at the root of this component manager's state context
            ///      (because the host or some other component is still in the state),
            ///      otherwise return FALSE (ie. return what FInState would return).
            ///      Caller can normally ignore the return value.
            ///      
            ///      Note: n calls to this method are symmetric with n calls to 
            ///      OnComponentEnterState (see OnComponentEnterState comments, above).
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FOnComponentExitState(
                                                           int dwComponentID,
                                                           int uStateID,
                                                           int uContext,
                                                           int cpicmExclude,
                                                           int rgpicmExclude       // IMsoComponentManager**
                                                           ) {

                currentState &= ~uStateID;

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager: Component exit state.  ID: " + dwComponentID.ToString() + " state: " + uStateID.ToString());

                if (uContext == NativeMethods.MSOCM.msoccontextAll || uContext == NativeMethods.MSOCM.msoccontextMine) {

                    Debug.Indent();

                    // We should notify all components we contain that the state has changed.
                    //
                    foreach (ComponentHashtableEntry entry in OleComponents.Values) {
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Notifying " + entry.component.ToString());
                        entry.component.OnEnterState(uStateID, false);
                    }

                    Debug.Unindent();
                }

                return false;
            }                                   

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FInState"]/*' />
            /// <devdoc>
            ///      Return TRUE if the state identified by uStateID (a msocstateXXX value)
            ///      is in effect at the root of this component manager's state context, 
            ///      FALSE otherwise (see "Comments on State Contexts", above).
            ///      pvoid is reserved for future use and should be NULL.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FInState(int uStateID, IntPtr pvoid) {
                return(currentState & uStateID) != 0;
            }                       

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FContinueIdle"]/*' />
            /// <devdoc>
            ///      Called periodically by a component during IMsoComponent::FDoIdle.
            ///      Return TRUE if component can continue its idle time processing, 
            ///      FALSE if not (in which case component returns from FDoIdle.) 
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FContinueIdle() {

                // Essentially, if we have a message on queue, then don't continue
                // idle processing.
                //
                NativeMethods.MSG msg = new NativeMethods.MSG();
                return !UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE);
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop"]/*' />
            /// <devdoc>
            ///      Component identified by dwComponentID (cookie returned from 
            ///      FRegisterComponent) wishes to push a message loop for reason uReason.
            ///      uReason is one the values from the msoloop enumeration (above).
            ///      pvLoopData is data private to the component.
            ///      The component manager should push its message loop, 
            ///      calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
            ///      during each loop iteration (see IMsoComponent::FContinueMessageLoop
            ///      comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
            ///      component manager terminates the loop.
            ///      Returns TRUE if component manager terminates loop because component
            ///      told it to (by returning FALSE from IMsoComponent::FContinueMessageLoop),
            ///      FALSE if it had to terminate the loop for some other reason.  In the 
            ///      latter case, component should perform any necessary action (such as 
            ///      cleanup).
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop(
                                                      int dwComponentID,
                                                      int reason,
                                                      int pvLoopData          // PVOID 
                                                      ) {

                // Hold onto old state to allow restore before we exit...
                //
                int currentLoopState = currentState;
                bool continueLoop = true;

                if (!OleComponents.ContainsKey(dwComponentID)) {
                    return false;
                }

                UnsafeNativeMethods.IMsoComponent prevActive = this.activeComponent;

                try {
                    // Execute the message loop until the active component tells us to stop.
                    //
                    NativeMethods.MSG msg = new NativeMethods.MSG();  
                    bool unicodeWindow = false;
                    UnsafeNativeMethods.IMsoComponent requestingComponent;

                    ComponentHashtableEntry entry = (ComponentHashtableEntry)OleComponents[dwComponentID];
                    if (entry == null) {
                        return false;
                    }

                    
                    
                    requestingComponent = entry.component;

                    this.activeComponent = requestingComponent;

                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Pushing message loop " + reason.ToString());
                    Debug.Indent();

                    while (continueLoop) {

                        // Determine the component to route the message to
                        //
                        UnsafeNativeMethods.IMsoComponent component;

                        if (trackingComponent != null) {
                            component = trackingComponent;
                        }
                        else if (activeComponent != null) {
                            component = activeComponent;
                        }
                        else {
                            component = requestingComponent;
                        }

                        bool peeked = UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE);

                        if (peeked) {

                            continueLoop = component.FContinueMessageLoop(reason, pvLoopData, ref msg);

                            // If the component wants us to process the message, do it.
                            // The component manager hosts windows from many places.  We must be sensitive
                            // to ansi / Unicode windows here.
                            //
                            if (continueLoop) {
                                if (msg.hwnd != IntPtr.Zero && SafeNativeMethods.IsWindowUnicode(new HandleRef(null, msg.hwnd))) {
                                    unicodeWindow = true;
                                    UnsafeNativeMethods.GetMessageW(ref msg, NativeMethods.NullHandleRef, 0, 0);
                                }
                                else {
                                    unicodeWindow = false;
                                    UnsafeNativeMethods.GetMessageA(ref msg, NativeMethods.NullHandleRef, 0, 0);
                                }

                                if (msg.message == Application.MSG_APPQUIT) {
                                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Application : Processing APPQUIT message");
                                    Application.ThreadContext.FromCurrent().DisposeThreadWindows();
                                    Application.ThreadContext.FromCurrent().PostQuit();
                                }

                                if (msg.message == NativeMethods.WM_QUIT) {
                                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Normal message loop termination");
                                    if (reason != NativeMethods.MSOCM.msoloopMain) {
                                        UnsafeNativeMethods.PostQuitMessage((int)msg.wParam);
                                    }
                                    continueLoop = false;
                                    break;
                                }
                                        
                                // Now translate and dispatch the message.
                                //
                                // Reading through the rather sparse documentation,
                                // it seems we should only call FPreTranslateMessage 
                                // on the active component.  But frankly, I'm afraid of what that might break.
                                // See ASURT 29415 for more background.
                                if (!component.FPreTranslateMessage(ref msg)) {
                                    UnsafeNativeMethods.TranslateMessage(ref msg);
                                    if (unicodeWindow) {
                                        UnsafeNativeMethods.DispatchMessageW(ref msg);
                                    }
                                    else {
                                        UnsafeNativeMethods.DispatchMessageA(ref msg);
                                    }
                                }
                            }
                        }
                        else {

                            // If this is a DoEvents loop, then get out.  There's nothing left
                            // for us to do.
                            //
                            if (reason == NativeMethods.MSOCM.msoloopDoEvents) {
                                break;
                            }

                            // Nothing is on the message queue.  Perform idle processing
                            // and then do a WaitMessage.
                            //
                            bool continueIdle = false;

                            if (OleComponents != null) {
                                IEnumerator enumerator = OleComponents.Values.GetEnumerator();

                                while (enumerator.MoveNext()) {
                                    ComponentHashtableEntry idleEntry = (ComponentHashtableEntry)enumerator.Current;
                                    continueIdle |= idleEntry.component.FDoIdle(-1);
                                }
                            }

                            // give the component one more chance to terminate the
                            // message loop.
                            //
                            msg.hwnd = IntPtr.Zero;
                            msg.message = 0;
                            continueLoop = component.FContinueMessageLoop(reason, pvLoopData, ref msg);

                            if (continueLoop && !continueIdle) {

                                // We should call GetMessage here, but we cannot because
                                // the component manager requires that we notify the
                                // active component before we pull the message off the
                                // queue.  This is a bit of a problem, because WaitMessage
                                // waits for a NEW message to appear on the queue.  If a
                                // message appeared between processing and now WaitMessage
                                // would wait for the next message.  We minimize this here
                                // by calling PeekMessage.
                                //
                                if (!UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE)) {
                                    UnsafeNativeMethods.WaitMessage();
                                }
                            }

                        }
                    }

                    Debug.Unindent();
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : message loop " + reason.ToString() + " complete.");
                }
                finally {
                    currentState = currentLoopState;
                    this.activeComponent = prevActive;
                }

                return !continueLoop;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FCreateSubComponentManager"]/*' />
            /// <devdoc>
            ///      Cause the component manager to create a "sub" component manager, which
            ///      will be one of its children in the hierarchical tree of component
            ///      managers used to maintiain state contexts (see "Comments on State
            ///      Contexts", above).
            ///      piunkOuter is the controlling unknown (can be NULL), riid is the
            ///      desired IID, and *ppvObj returns   the created sub component manager.
            ///      piunkServProv (can be NULL) is a ptr to an object supporting
            ///      IServiceProvider interface to which the created sub component manager
            ///      will delegate its IMsoComponentManager::QueryService calls. 
            ///      (see objext.h or docobj.h for definition of IServiceProvider).
            ///      Returns TRUE if successful.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FCreateSubComponentManager(
                                                                object punkOuter,
                                                                object punkServProv,
                                                                ref Guid riid,
                                                                out IntPtr ppvObj) {

                // We do not support sub component managers.
                //
                ppvObj = IntPtr.Zero;
                return false;                                            
            }                                        

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FGetParentComponentManager"]/*' />
            /// <devdoc>
            ///      Return in *ppicm an AddRef'ed ptr to this component manager's parent
            ///      in the hierarchical tree of component managers used to maintain state
            ///      contexts (see "Comments on State   Contexts", above).
            ///      Returns TRUE if the parent is returned, FALSE if no parent exists or
            ///      some error occurred.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FGetParentComponentManager(out UnsafeNativeMethods.IMsoComponentManager ppicm) {
                ppicm = null;
                return false;                                        
            }                                        

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FGetActiveComponent"]/*' />
            /// <devdoc>
            ///      Return in *ppic an AddRef'ed ptr to the current active or tracking
            ///      component (as indicated by dwgac (a msogacXXX value)), and
            ///      its registration information in *pcrinfo.  ppic and/or pcrinfo can be
            ///      NULL if caller is not interested these values.  If pcrinfo is not NULL,
            ///      caller should set pcrinfo->cbSize before calling this method.
            ///      Returns TRUE if the component indicated by dwgac exists, FALSE if no 
            ///      such component exists or some error occurred.
            ///      dwReserved is reserved for future use and should be zero.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponentManager.FGetActiveComponent(
                                                         int dwgac,
                                                         UnsafeNativeMethods.IMsoComponent[] ppic,
                                                         NativeMethods.MSOCRINFOSTRUCT info,
                                                         int dwReserved) {

                UnsafeNativeMethods.IMsoComponent component = null;

                if (dwgac == NativeMethods.MSOCM.msogacActive) {
                    component = activeComponent;
                }
                else if (dwgac == NativeMethods.MSOCM.msogacTracking) {
                    component = trackingComponent;
                }
                else if (dwgac == NativeMethods.MSOCM.msogacTrackingOrActive) {
                    if (trackingComponent != null) {
                        component = trackingComponent;
                    }
                    else {
                        component = activeComponent;
                    }
                }
                else {
                    Debug.Fail("Unknown dwgac in FGetActiveComponent");
                }

                if (ppic != null) {
                    ppic[0] = component;
                }
                if (info != null && component != null) {
                    foreach(ComponentHashtableEntry entry in OleComponents.Values) {
                        if (entry.component == component) {
                            info = entry.componentInfo;
                            break;
                        }
                    }
                }

                return component != null;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext"]/*' />
        /// <devdoc>
        ///     This class is the embodiment of TLS for windows forms.  We do not expose this to end users because
        ///     TLS is really just an unfortunate artifact of using Win 32.  We want the world to be free
        ///     threaded.
        /// </devdoc>
        /// <internalonly/>
        [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        internal sealed class ThreadContext : UnsafeNativeMethods.IMsoComponent {

            private const int STATE_OLEINITIALIZED       = 0x00000001;
            private const int STATE_EXTERNALOLEINIT      = 0x00000002;
            private const int STATE_INTHREADEXCEPTION    = 0x00000004;
            private const int STATE_POSTEDQUIT           = 0x00000008;
            private const int STATE_POSTEDAPPQUIT        = 0x00000010;

            private const int INVALID_ID                 = unchecked((int)0xFFFFFFFF);

            private static LocalDataStoreSlot tlsSlot = null;
            private static Hashtable        contextHash;

            // When this gets to zero, we'll invoke a full garbage
            // collect and check for root/window leaks.
            //
            private static int              totalMessageLoopCount;
            private static int              baseLoopReason;

            internal ThreadExceptionEventHandler threadExceptionHandler;
            internal EventHandler           idleHandler;
            private ApplicationContext      applicationContext;
            private ParkingWindow           parkingWindow;
            private CultureInfo             culture;
            private ArrayList               messageFilters;
            private IntPtr                  handle;
            private int                     id;
            private int                     messageLoopCount;
            private int                     threadState = 0;

            // IMsoComponentManager stuff
            //
            private UnsafeNativeMethods.IMsoComponentManager componentManager;
            private bool externalComponentManager;

            // IMsoComponent stuff
            private int componentID = INVALID_ID;
            private Form currentForm;
            private ThreadWindows threadWindows = null;
            private NativeMethods.MSG tempMsg = new NativeMethods.MSG();

            private int disposeCount = 0;   // To make sure that we don't allow
                                                // reentrancy in Dispose()

            // Debug helper variable
#if DEBUG   
            private int debugModalCounter = 0;
#endif                     

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.ThreadContext"]/*' />
            /// <devdoc>
            ///     Creates a new thread context object.
            /// </devdoc>
            public ThreadContext() {
                IntPtr address = IntPtr.Zero;

                UnsafeNativeMethods.DuplicateHandle(new HandleRef(null, SafeNativeMethods.GetCurrentProcess()), new HandleRef(null, SafeNativeMethods.GetCurrentThread()),
                                                    new HandleRef(null, SafeNativeMethods.GetCurrentProcess()), ref address, 0, false,
                                                    NativeMethods.DUPLICATE_SAME_ACCESS);

                handle = address;
                id = SafeNativeMethods.GetCurrentThreadId();
                messageLoopCount = 0;

                EnsureTLS();
                Thread.SetData(tlsSlot, this);
                contextHash[(object)SafeNativeMethods.GetCurrentThreadId()] = this;
            }

            public ApplicationContext ApplicationContext {
                get {
                    return applicationContext;
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.ComponentManager"]/*' />
            /// <devdoc>
            ///      Retrieves the component manager for this process.  If there is no component manager
            ///      currently installed, we install our own.
            /// </devdoc>
            internal UnsafeNativeMethods.IMsoComponentManager ComponentManager {
                get {  

                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Application.ComponentManager.Get:");

                    if (componentManager == null) {

                        Application.OleRequired();
                        
                        // Attempt to obtain the Host Application MSOComponentManager
                        //
                        IntPtr msgFilterPtr = (IntPtr)0;
                        
                        if (NativeMethods.Succeeded(UnsafeNativeMethods.CoRegisterMessageFilter(NativeMethods.NullHandleRef, ref msgFilterPtr)) && msgFilterPtr != (IntPtr)0) {

                            IntPtr dummy = (IntPtr)0;
                            UnsafeNativeMethods.CoRegisterMessageFilter(new HandleRef(null, msgFilterPtr), ref dummy);
                            
                            object msgFilterObj = Marshal.GetObjectForIUnknown(msgFilterPtr);
                            Marshal.Release(msgFilterPtr);
                            
                            if (msgFilterObj is UnsafeNativeMethods.IOleServiceProvider) {
                                UnsafeNativeMethods.IOleServiceProvider sp = (UnsafeNativeMethods.IOleServiceProvider)msgFilterObj;

                                try {
                                    IntPtr retval = IntPtr.Zero;
                                    
                                    // PERF ALERT (sreeramn): Using typeof() of COM object spins up COM at JIT time.
                                    // Guid compModGuid = typeof(UnsafeNativeMethods.SMsoComponentManager).GUID;
                                    //
                                    Guid compModGuid = new Guid("000C060B-0000-0000-C000-000000000046");
                                    Guid iid = new Guid("{00000000-0000-0000-C000-000000000046}");
                                    int hr = sp.QueryService(
                                                   ref compModGuid, 
                                                   ref iid, 
                                                   out retval);

                                    if (NativeMethods.Succeeded(hr) && retval != IntPtr.Zero) {
                                        object retObj = Marshal.GetObjectForIUnknown(retval);
                                        Marshal.Release(retval);

                                        if (retObj is UnsafeNativeMethods.IMsoComponentManager) {
                                            componentManager = (UnsafeNativeMethods.IMsoComponentManager)retObj;
                                            externalComponentManager = true;
                                            Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Using MSO Component manager");

                                            // Now attach app domain unload events so we can 
                                            // detect when we need to revoke our component
                                            //
                                            AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnDomainUnload);
                                            AppDomain.CurrentDomain.ProcessExit += new EventHandler(OnDomainUnload);
                                        }
                                    }
                                }
                                catch (Exception) {
                                }
                            }
                        }

                        // Otherwise, we implement component manager ourselves
                        //
                        if (componentManager == null) {
                            componentManager = new ComponentManager();
                            externalComponentManager = false;

                            // We must also store this back into the message filter for others 
                            // to use.
                            //
                            // CONSIDER: Implement this part of the equation!

                            Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Using our own component manager");
                        }
                    }

                    if (componentManager != null && componentID == INVALID_ID) {
                        // Finally, if we got a compnent manager, register ourselves with it.
                        //
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "Registering MSO component with the component manager");
                        NativeMethods.MSOCRINFOSTRUCT info = new NativeMethods.MSOCRINFOSTRUCT();
                        info.cbSize = Marshal.SizeOf(typeof(NativeMethods.MSOCRINFOSTRUCT));
                        info.uIdleTimeInterval = 0;
                        info.grfcrf = NativeMethods.MSOCM.msocrfPreTranslateAll | NativeMethods.MSOCM.msocrfNeedIdleTime;
                        info.grfcadvf = NativeMethods.MSOCM.msocadvfModal;

                        bool result = componentManager.FRegisterComponent(this, info, out componentID);
                        Debug.Assert(componentID != INVALID_ID, "Our ID sentinel was returned as a valid ID");

                        if (result && !(componentManager is ComponentManager)) {
                            messageLoopCount++;
                        }

                        Debug.Assert(result, "Failed to register WindowsForms with the ComponentManager -- DoEvents and modal dialogs will be broken. size: " + info.cbSize);
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager.FRegisterComponent returned " + result.ToString());
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager.FRegisterComponent assigned a componentID == [0x" + Convert.ToString(componentID, 16) + "]");
                    }

                    return componentManager;
                }
            }

            internal bool CustomThreadExceptionHandlerAttached {
                get {
                    return threadExceptionHandler != null;
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.AddMessageFilter"]/*' />
            /// <devdoc>
            ///     Allows you to setup a message filter for the application's message pump.  This
            ///     installs the filter on the current thread.
            /// </devdoc>
            /// <internalonly/>
            internal void AddMessageFilter(IMessageFilter f) {
                if (messageFilters == null) messageFilters = new ArrayList();

                if (f != null) messageFilters.Add(f);
            }

            // Called immediately before we begin pumping messages for a modal message loop.
            internal void BeginModalMessageLoop() {
#if DEBUG
                debugModalCounter++;
#endif            
                ComponentManager.OnComponentEnterState(componentID, NativeMethods.MSOCM.msocstateModal, NativeMethods.MSOCM.msoccontextAll, 0, 0, 0);
                DisableWindowsForModalLoop(false); // onlyWinForms = false
            }

            // Disables windows in preparation of going modal.  If parameter is true, we disable all 
            // windows, if false, only windows forms windows (i.e., windows controlled by this MsoComponent).
            // See also IMsoComponent.OnEnterState.
            private void DisableWindowsForModalLoop(bool onlyWinForms) {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Entering modal state");
                ThreadWindows old = threadWindows;
                threadWindows = new ThreadWindows(currentForm, onlyWinForms);
                threadWindows.Enable(false);
                threadWindows.previousThreadWindows = old;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.Dispose"]/*' />
            /// <devdoc>
            ///     Disposes this thread context object.  Note that this will marshal to the owning thread.
            /// </devdoc>
            /// <internalonly/>
            internal void Dispose() {

                try {
                    if (disposeCount++ == 0) {  // make sure that we are not reentrant
                        
                        // Unravel our message loop.  this will marshal us over to
                        // the right thread, making the dispose() method async.
                        //
                        if (messageLoopCount > 0) {
                            PostAppQuit();
                        }
                        else {
                            bool ourThread = SafeNativeMethods.GetCurrentThreadId() == id;

                            try {
                                // We can only clean up if we're being called on our
                                // own thread.
                                //
                                if (ourThread) {

                                    // If we had a component manager, detach from it.
                                    //
                                    if (componentManager != null) {
                                        RevokeComponent();

                                        // CONSIDER : When we hook our CM into the message filter, we should
                                        // check to see if this is us.  If so, rip us from the message filter.
                                        //
                                        componentManager = null;
                                    }

                                    DisposeThreadWindows();

                                    try {
                                        Application.RaiseThreadExit();
                                    }
                                    finally {
                                        if (GetState(STATE_OLEINITIALIZED) && !GetState(STATE_EXTERNALOLEINIT)) {
                                            SetState(STATE_OLEINITIALIZED, false);
                                            UnsafeNativeMethods.OleUninitialize();
                                        }
                                    }
                                }
                            }
                            finally {
                                // We can always clean up this handle, though
                                //
                                if (handle != IntPtr.Zero) {
                                    UnsafeNativeMethods.CloseHandle(new HandleRef(this, handle));
                                    handle = IntPtr.Zero;
                                }

                                try {
                                    if (totalMessageLoopCount == 0) {
                                        Application.RaiseExit();
    #if DEBUG
                                        DebugHandleTracker.CheckLeaks();
    #endif
                                    }
                                }
                                finally {
                                    contextHash.Remove((object)id);
                                }
                            }
                        }

                        GC.SuppressFinalize(this);
                    }
                }
                finally {
                    disposeCount--;
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.DisposeParkingWindow"]/*' />
            /// <devdoc>
            ///     Disposes of this thread's parking form.
            /// </devdoc>
            /// <internalonly/>
            internal void DisposeParkingWindow() {
                if (parkingWindow != null && parkingWindow.IsHandleCreated) {

                    // We take two paths here.  If we are on the same thread as
                    // the parking window, we can destroy its handle.  If not,
                    // we just null it and let it GC.  When it finalizes it
                    // will disconnect its handle and post a WM_CLOSE.
                    //
                    // It is important that we just call DestroyHandle here
                    // and do not call Dispose.  Otherwise we would destroy
                    // controls that are living on the parking window.
                    //
                    int pid;
                    int hwndThread = SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(parkingWindow, parkingWindow.Handle), out pid);
                    int currentThread = SafeNativeMethods.GetCurrentThreadId();

                    if (hwndThread == currentThread) {
                        parkingWindow.Destroy();
                    }
                    else {
                        parkingWindow = null;
                    }
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.DisposeThreadWindows"]/*' />
            /// <devdoc>
            ///     Gets rid of all windows in this thread context.  Nulls out
            ///     window objects that we hang on to.
            /// </devdoc>
            internal void DisposeThreadWindows() {

                // We dispose the main window first, so it can perform any
                // cleanup that it may need to do.
                //
                try {
                    if (applicationContext != null) {
                        applicationContext.Dispose();
                        applicationContext = null;
                    }

                    // Then, we rudely nuke all of the windows on the thread
                    //
                    ThreadWindows tw = new ThreadWindows(null, true);
                    tw.Dispose();

                    // And dispose the parking form, if it isn't already
                    //
                    DisposeParkingWindow();
                }
                catch (Exception) {
                }
            }

            // Enables windows in preparation of stopping modal.  If parameter is true, we enable all windows, 
            // if false, only windows forms windows (i.e., windows controlled by this MsoComponent).
            // See also IMsoComponent.OnEnterState.
            private void EnableWindowsForModalLoop(bool onlyWinForms) {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Leaving modal state");
                if (threadWindows != null) {
                    threadWindows.Enable(true);
                    Debug.Assert(threadWindows != null, "OnEnterState recursed, but it's not supposed to be reentrant");
                    threadWindows = threadWindows.previousThreadWindows;
                }
            }

            // Called immediately after we end pumping messages for a modal message loop.
            internal void EndModalMessageLoop() {
#if DEBUG
                debugModalCounter--;
                Debug.Assert(debugModalCounter >= 0, "Mis-matched calls to Application.BeginModalMessageLoop() and Application.EndModalMessageLoop()");
#endif            
                EnableWindowsForModalLoop(false); // onlyWinForms = false
                ComponentManager.FOnComponentExitState(componentID, NativeMethods.MSOCM.msocstateModal, NativeMethods.MSOCM.msoccontextAll, 0, 0);
            
                // We have no message loops on this thread. So, destroy the parking window
                // created on this thread right away. If we don't do this, we may never get a chance
                // to clean up the window if the cleanup does hot happen on this thread.  We also
                // terminate our association with the component manager.
                // 
                if (messageLoopCount == 0) {
                    DisposeParkingWindow();

                    // If we had a component manager, detach from it.
                    //
                    RevokeComponent();
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.EnsureTLS"]/*' />
            /// <devdoc>
            ///      Ensures that our TLS has been appropriately setup.
            /// </devdoc>
            /// <internalonly/>
            private static void EnsureTLS() {
                if (tlsSlot == null) {
                    lock (typeof(ThreadContext)) {
                        if (tlsSlot == null) {
                            tlsSlot = Thread.AllocateDataSlot();
                            contextHash = new Hashtable();
                        }
                    }
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.ExitApplication"]/*' />
            /// <devdoc>
            ///     Exits the program by disposing of all thread contexts and message loops.
            /// </devdoc>
            /// <internalonly/>
            internal static void ExitApplication() {
                lock(typeof(ThreadContext)) {
                    if (contextHash != null) {
                        ThreadContext[] ctxs = new ThreadContext[contextHash.Values.Count];
                        contextHash.Values.CopyTo(ctxs, 0);
                        for (int i = 0; i < ctxs.Length; ++i) {
                            if (ctxs[i].ApplicationContext != null) {
                                ctxs[i].ApplicationContext.ExitThread();
                            }
                            else {
                                ctxs[i].Dispose();
                            }
                        }
                    }
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.Finalize"]/*' />
            /// <devdoc>
            ///     Our finalization.  Minimal stuff... this shouldn't be called... We should always be disposed.
            /// </devdoc>
            /// <internalonly/>
            ~ThreadContext() {

                // Unravel our message loop.  this will marshal us over to
                // the right thread, making the dispose() method async.
                //
                if (messageLoopCount > 0) {
                    PostAppQuit();
                }
                else {
                    bool ourThread = SafeNativeMethods.GetCurrentThreadId() == id;

                    try {
                        if (GetState(STATE_OLEINITIALIZED) && !GetState(STATE_EXTERNALOLEINIT)) {
                            SetState(STATE_OLEINITIALIZED, false);
                            UnsafeNativeMethods.OleUninitialize();
                        }
                    }
                    finally {
                        // We can always clean up this handle, though
                        //
                        if (handle != IntPtr.Zero) {
                            UnsafeNativeMethods.CloseHandle(new HandleRef(this, handle));
                            handle = IntPtr.Zero;
                        }
                    }
                }
            }

            // When a Form receives a WM_ACTIVATE message, it calls this method so we can do the
            // appropriate MsoComponentManager activation magic
            internal void FormActivated(bool activate) {
                if (activate && !(this.ComponentManager is ComponentManager)) {
                    ComponentManager.FOnComponentActivate(componentID);
                }
            }
            
            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.FromCurrent"]/*' />
            /// <devdoc>
            ///     Retrieves a ThreadContext object for the current thread
            /// </devdoc>
            /// <internalonly/>
            internal static ThreadContext FromCurrent() {
                EnsureTLS();
                ThreadContext context = (ThreadContext)Thread.GetData(tlsSlot);

                if (context == null) {
                    context = new ThreadContext();
                }

                return context;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.FromId"]/*' />
            /// <devdoc>
            ///     Retrieves a ThreadContext object for the given thread ID
            /// </devdoc>
            /// <internalonly/>
            internal static ThreadContext FromId(int id) {
                EnsureTLS();
                ThreadContext context = (ThreadContext)contextHash[(object)id];
                if (context == null && id == SafeNativeMethods.GetCurrentThreadId()) {
                    context = new ThreadContext();
                }

                return context;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetAllowQuit"]/*' />
            /// <devdoc>
            ///      Determines if it is OK to allow an application to quit and shutdown
            ///      the runtime.  We only allow this if we own the base message pump.
            /// </devdoc>
            internal bool GetAllowQuit() {
                return totalMessageLoopCount > 0 && baseLoopReason == NativeMethods.MSOCM.msoloopMain;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetHandle"]/*' />
            /// <devdoc>
            ///     Retrieves the handle to this thread.
            /// </devdoc>
            /// <internalonly/>
            internal IntPtr GetHandle() {
                return handle;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetId"]/*' />
            /// <devdoc>
            ///     Retrieves the ID of this thread.
            /// </devdoc>
            /// <internalonly/>
            internal int GetId() {
                return id;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetCulture"]/*' />
            /// <devdoc>
            ///     Retrieves the culture for this thread.
            /// </devdoc>
            /// <internalonly/>
            internal CultureInfo GetCulture() {
                if (culture == null || culture.LCID != SafeNativeMethods.GetThreadLocale())
                    culture = new CultureInfo(SafeNativeMethods.GetThreadLocale());
                return culture;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetMessageLoop"]/*' />
            /// <devdoc>
            ///     Determines if a message loop exists on this thread.
            /// </devdoc>
            internal bool GetMessageLoop() {

                // If we are already running a loop, we're fine.
                //
                if (messageLoopCount > 0) return true;

                // Also, access the ComponentManager property to demand create it, and we're also
                // fine if it is an external manager, because it has already pushed a loop.
                //
                if (ComponentManager != null && externalComponentManager) return true;
                
                // Otherwise, we do not have a loop running.
                //
                return false;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.GetParkingWindow"]/*' />
            /// <devdoc>
            ///     Retrieves the actual parking form.  This will demand create the parking window
            ///     if it needs to.
            /// </devdoc>
            /// <internalonly/>
            internal Control GetParkingWindow() {
                lock(this) {
                    if (parkingWindow == null) {
#if DEBUG
                        // if we use Debug.WriteLine instead of "if", we need extra security permissions
                        // to get the stack trace!
                        if (CoreSwitches.PerfTrack.Enabled) {
                            Debug.WriteLine("Creating parking form!");
                            Debug.WriteLine(CoreSwitches.PerfTrack.Enabled, Environment.StackTrace);
                        }
#endif

                        // SECREVIEW : We need to create the parking window. Since this is a top
                        //           : level hidden form, we must assert this. However, the parking
                        //           : window is complete internal to the assembly, so no one can
                        //           : ever get at it.
                        //
                        IntSecurity.ManipulateWndProcAndHandles.Assert();
                        try {
                            parkingWindow = new ParkingWindow();
                            parkingWindow.CreateControl();
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    return parkingWindow;
                }
            }

            private bool GetState(int bit) {
                return(threadState & bit) != 0;
            }

            internal System.Threading.ApartmentState OleRequired() {
                Thread current = Thread.CurrentThread;
                if (!GetState(STATE_OLEINITIALIZED)) {
                
                    int ret = UnsafeNativeMethods.OleInitialize();

#if false
                    // PERFTRACK : ChrisAn, 7/26/1999 - To avoid constructing the string in
                    //           : non-failure cases (vast majority), we will do the debug.fail
                    //           : inside an if statement.
                    //
                    if (!(ret == NativeMethods.S_OK || ret == NativeMethods.S_FALSE || ret == NativeMethods.RPC_E_CHANGED_MODE)) {
                        Debug.Assert(ret == NativeMethods.S_OK || ret == NativeMethods.S_FALSE || ret == NativeMethods.RPC_E_CHANGED_MODE,
                                     "OLE Failed to Initialize!. RetCode: 0x" + Convert.ToString(ret, 16) +
                                     " LastError: " + Marshal.GetLastWin32Error().ToString());
                    }
#endif

                    SetState(STATE_OLEINITIALIZED, true);
                    if (ret == NativeMethods.RPC_E_CHANGED_MODE) {
                        // This could happen if the thread was already initialized for MTA
                        // and then we call OleInitialize which tries to initialized it for STA
                        // This currently happens while profiling...
                        SetState(STATE_EXTERNALOLEINIT, true);
                    }
                    
                }
                
                if ( GetState( STATE_EXTERNALOLEINIT )) {
                    return System.Threading.ApartmentState.MTA;
                }
                else {
                    return System.Threading.ApartmentState.STA;
                }
            }

            private void OnAppThreadExit(object sender, EventArgs e) {
                Dispose();
            }

            /// <devdoc>
            ///     Revokes our component if needed.
            /// </devdoc>
            private void OnDomainUnload(object sender, EventArgs e) {
                RevokeComponent();

                // Also, release the component manager now.
                //
                if (componentManager != null && Marshal.IsComObject(componentManager)) {
                    Marshal.ReleaseComObject(componentManager);
                    componentManager = null;
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.OnThreadException"]/*' />
            /// <devdoc>
            ///     Called when an untrapped exception occurs in a thread.  This allows the
            ///     programmer to trap these, and, if left untrapped, throws a standard error
            ///     dialog.
            /// </devdoc>
            /// <internalonly/>
            internal void OnThreadException(Exception t) {
                if (GetState(STATE_INTHREADEXCEPTION)) return;

                SetState(STATE_INTHREADEXCEPTION, true);
                try {
                    Debug.WriteLine("Unhandled thread exception: ");
                    Debug.WriteLine(t.ToString());

                    if (threadExceptionHandler != null) {
                        threadExceptionHandler(Thread.CurrentThread, new ThreadExceptionEventArgs(t));
                    }
                    else {
                        if (SystemInformation.UserInteractive) {
                            ThreadExceptionDialog td = new ThreadExceptionDialog(t);
                            DialogResult result = DialogResult.OK;
                            IntSecurity.ModifyFocus.Assert();
                            try {
                                result = td.ShowDialog();
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                                td.Dispose();
                            }
                            switch (result) {
                                case DialogResult.Abort:
                                    // SECREVIEW : The user clicked "Quit" in response to a exception dialog.
                                    //           : We only show the quit option when we own the message pump,
                                    //           : so this won't ever tear down IE or any other ActiveX host.
                                    //           :
                                    //           : This has a potential problem where a component could 
                                    //           : cause a failure, then try a "trick" the user into hitting
                                    //           : quit. However, no component or application outside of
                                    //           : the windows forms assembly can modify the dialog, so this is 
                                    //           : a really minor concern.
                                    //
                                    IntSecurity.AffectThreadBehavior.Assert();
                                    try {
                                        Application.Exit();
                                    }
                                    finally {
                                        CodeAccessPermission.RevertAssert();
                                    }

                                    // SECREVIEW : We can't revert this assert... after Exit(0) is called, no
                                    //           : more code is executed...
                                    //
                                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
                                    Environment.Exit(0);
                                    break;
                                case DialogResult.Yes:
                                    if (t is WarningException) {
                                        WarningException w = (WarningException)t;
                                        Help.ShowHelp(GetParkingWindow(), w.HelpUrl, w.HelpTopic);
                                    }
                                    break;
                            }
                        }
                        else {
                            // Ignore unhandled thread exceptions. The user can
                            // override if they really care.
                            //
                        }

                    }
                }
                finally {
                    SetState(STATE_INTHREADEXCEPTION, false);
                }
            }

            void PostAppQuit() {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Attempting to terminate message loop");

                UnsafeNativeMethods.PostThreadMessage(id, MSG_APPQUIT, IntPtr.Zero, IntPtr.Zero);
                SetState(STATE_POSTEDAPPQUIT, true);
            }

            internal void PostQuit() {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Attempting to terminate message loop");

                // Per http://support.microsoft.com/support/kb/articles/Q183/1/16.ASP
                //
                // WM_QUIT may be consumed by another message pump under very specific circumstances.
                // When that occurs, we rely on the STATE_POSTEDQUIT to be caught in the next
                // idle, at which point we can tear down.
                //
                // We can't follow the KB article exactly, becasue we don't have an HWND to PostMessage
                // to.
                //
                UnsafeNativeMethods.PostThreadMessage(id, NativeMethods.WM_QUIT, IntPtr.Zero, IntPtr.Zero);
                SetState(STATE_POSTEDQUIT, true);
            }


            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.RemoveMessageFilter"]/*' />
            /// <devdoc>
            ///     Removes a message filter previously installed with addMessageFilter.
            /// </devdoc>
            /// <internalonly/>
            internal void RemoveMessageFilter(IMessageFilter f) {
                if (messageFilters != null) messageFilters.Remove(f);
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.RunMessageLoop"]/*' />
            /// <devdoc>
            ///     Starts a message loop for the given reason.
            /// </devdoc>
            /// <internalonly/>
            internal void RunMessageLoop(int reason, ApplicationContext context) {
                // Ensure that we attempt to apply theming before doing anything
                // that might create a window.

                using (new SafeNativeMethods.EnableThemingInScope(useVisualStyles))
                {
                    RunMessageLoopInner(reason, context);
                }
            }

            private void RunMessageLoopInner(int reason, ApplicationContext context) {

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ThreadContext.PushMessageLoop {");
                Debug.Indent();

                if (reason == NativeMethods.MSOCM.msoloopModalForm && !SystemInformation.UserInteractive) {
                    throw new InvalidOperationException(SR.GetString(SR.CantShowModalOnNonInteractive));
                }

                // if we've entered because of a Main message loop being pushed
                // (different than a modal message loop or DoEVents loop)
                // then clear the QUIT flag to allow normal processing.
                // this flag gets set during loop teardown for another form.
                if (reason == NativeMethods.MSOCM.msoloopMain) {
                    SetState(STATE_POSTEDQUIT, false);
                }

                if (totalMessageLoopCount++ == 0) {
                    baseLoopReason = reason;
                }

                messageLoopCount++;

                if (reason == NativeMethods.MSOCM.msoloopMain) {
                    // If someone has tried to push another main message loop on this thread, ignore
                    // it.
                    if (messageLoopCount != 1) {
                        throw new InvalidOperationException(SR.GetString(SR.CantNestMessageLoops));
                    }

                    applicationContext = context;

                    applicationContext.ThreadExit += new EventHandler(OnAppThreadExit);

                    if (applicationContext.MainForm != null) {
                        applicationContext.MainForm.Visible = true;
                    }
                }

                NativeMethods.MSG msg = new NativeMethods.MSG();
                Form oldForm = currentForm;                                       
                if (context != null) {
                    currentForm = context.MainForm;                                          
                }

                bool modal = false;

                if (reason == NativeMethods.MSOCM.msoloopModalForm || reason == NativeMethods.MSOCM.msoloopModalAlert) {
                    modal = true;
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "[0x" + Convert.ToString(componentID, 16) + "] Notifying component manager that we are entering a modal loop");
                    BeginModalMessageLoop();
                }

                try {
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "[0x" + Convert.ToString(componentID, 16) + "] Calling ComponentManager.FPushMessageLoop...");
                    bool result;

                    if (ComponentManager is ComponentManager) {
                        result = ComponentManager.FPushMessageLoop(componentID, reason, 0);
                    }
                    else {
                        // we always want to push our own message loop here.
                        // why? ask douglash...
                        //
                        // but we won't get idle processing with our own loop...
                        //
                             result = LocalModalMessageLoop(reason == NativeMethods.MSOCM.msoloopDoEvents ? null : currentForm);

                        //     result = ComponentManager.FPushMessageLoop(componentID, reason, 0);

                    }
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "[0x" + Convert.ToString(componentID, 16) + "] ComponentManager.FPushMessageLoop returned " + result.ToString());
                }
                finally {

                    if (modal) {
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "[0x" + Convert.ToString(componentID, 16) + "] Notifying component manager that we are exiting a modal loop");
                        EndModalMessageLoop();
                    }

                    currentForm = oldForm;
                    totalMessageLoopCount--;
                    messageLoopCount--;

                    if (reason == NativeMethods.MSOCM.msoloopMain) {
                        Dispose();
                    }
                    else if (messageLoopCount == 0 && componentManager != null) {
                        // If we had a component manager, detach from it.
                        //
                        RevokeComponent();
                    }
                }

                Debug.Unindent();
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "}");
            }

            private bool LocalModalMessageLoop(Form form) {
                try {
                    // Execute the message loop until the active component tells us to stop.
                    //
                    NativeMethods.MSG msg = new NativeMethods.MSG();  
                    bool unicodeWindow = false;
                    bool continueLoop = true;
                    
                    while (continueLoop) {

                        bool peeked = UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE);

                        if (peeked) {

                            // If the component wants us to process the message, do it.
                            // The component manager hosts windows from many places.  We must be sensitive
                            // to ansi / Unicode windows here.
                            //
                            if (continueLoop) {
                                if (msg.hwnd != IntPtr.Zero && SafeNativeMethods.IsWindowUnicode(new HandleRef(null, msg.hwnd))) {
                                    unicodeWindow = true;
                                    if (!UnsafeNativeMethods.GetMessageW(ref msg, NativeMethods.NullHandleRef, 0, 0)) {
                                        continue;
                                    }

                                }
                                else {
                                    unicodeWindow = false;
                                    if (!UnsafeNativeMethods.GetMessageA(ref msg, NativeMethods.NullHandleRef, 0, 0)) {
                                        continue;
                                    }
                                }

                                Message m = Message.Create(msg.hwnd, msg.message, msg.wParam, msg.lParam);

                                bool processed = false;

                                // see if the component would like to handle the message
                                // Call FromChildHandleInternal so that the msg passes from child to parent..
                                //
                                Control c = Control.FromChildHandleInternal(msg.hwnd);
                                
                                if (c != null && c.PreProcessMessage(ref m)) {
                                    processed = true;
                                }

                                if (!processed) {
                                    UnsafeNativeMethods.TranslateMessage(ref msg);
                                    if (unicodeWindow) {
                                        UnsafeNativeMethods.DispatchMessageW(ref msg);
                                    }
                                    else {
                                        UnsafeNativeMethods.DispatchMessageA(ref msg);
                                    }
                                }

                                if (form != null) {
                                    continueLoop = !form.CheckCloseDialog();
                                }
                            }
                        }
                        else if (form == null) {
                            break;
                        }
                        else {
                            UnsafeNativeMethods.MsgWaitForMultipleObjects(1, 0, true, 100, NativeMethods.QS_ALLINPUT);
                        }
                    }
                    return continueLoop;
                }
                catch {
                    return false;
                }
            }

            /// <devdoc>
            ///     Revokes our component from the active component manager.  Does
            ///     nothing if there is no active component manager or we are
            ///     already invoked.
            /// </devdoc>
            private void RevokeComponent() {
                if (componentManager != null && componentID != INVALID_ID) {
                    int id = componentID;
                    componentID = INVALID_ID;
                    componentManager.FRevokeComponent(id);
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.SetCulture"]/*' />
            /// <devdoc>
            ///     Sets the culture for this thread.
            /// </devdoc>
            /// <internalonly/>
            internal void SetCulture(CultureInfo culture) {
                if (culture != null && culture.LCID != SafeNativeMethods.GetThreadLocale()) {
                    SafeNativeMethods.SetThreadLocale(culture.LCID);
                }
            }

            private void SetState(int bit, bool value) {
                if (value) {
                    threadState |= bit;
                }
                else {
                    threadState &= (~bit);
                }
            }



            ///////////////////////////////////////////////////////////////////////////////////////////////////////



            /****************************************************************************************
             *
             *                                  IMsoComponent
             *
             ****************************************************************************************/

            // Things to test in VS when you change this code:
            // - You can bring up dialogs multiple times (ie, the editor for TextBox.Lines -- ASURT 41876)
            // - Double-click DataFormWizard, cancel wizard (ASURT 41562)
            // - When a dialog is open and you switch to another application, when you switch
            //   back to VS the dialog gets the focus (ASURT 38961)
            // - If one modal dialog launches another, they are all modal (ASURT 37154.  Try web forms Table\Rows\Cell)
            // - When a dialog is up, VS is completely disabled, including moving and resizing VS.
            // - After doing all this, you can ctrl-shift-N start a new project and VS is enabled.

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FDebugMessage"]/*' />
            /// <devdoc>
            ///      Standard FDebugMessage method.
            ///      Since IMsoComponentManager is a reference counted interface, 
            ///      MsoDWGetChkMemCounter should be used when processing the 
            ///      msodmWriteBe message.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponent.FDebugMessage(IntPtr hInst, int msg, IntPtr wparam, IntPtr lparam) {

                return false;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FPreTranslateMessage"]/*' />
            /// <devdoc>
            ///      Give component a chance to process the message pMsg before it is
            ///      translated and dispatched. Component can do TranslateAccelerator
            ///      do IsDialogMessage, modify pMsg, or take some other action.
            ///      Return TRUE if the message is consumed, FALSE otherwise.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponent.FPreTranslateMessage(ref NativeMethods.MSG msg) {

                if (messageFilters != null) {
                    IMessageFilter f;
                    int count = messageFilters.Count;

                    Message m = Message.Create(msg.hwnd, msg.message, msg.wParam, msg.lParam);

                    for (int i = 0; i < count; i++) {
                        f = (IMessageFilter)messageFilters[i];
                        if (f.PreFilterMessage(ref m)) {
                            return true;
                        }
                    }
                }

                if (msg.message >= NativeMethods.WM_KEYFIRST
                        && msg.message <= NativeMethods.WM_KEYLAST) {
                    if (msg.message == NativeMethods.WM_CHAR) {
                        int breakLParamMask = 0x1460000; // 1 = extended keyboard, 46 = scan code
                        if ((int)msg.wParam == 3 && ((int)msg.lParam & breakLParamMask) == breakLParamMask) { // ctrl-brk
                            // wParam is the key character, which for ctrl-brk is the same as ctrl-C.
                            // So we need to go to the lparam to distinguish the two cases.
                            // You might also be able to do this with WM_KEYDOWN (again with wParam=3)

                            if (Debugger.IsAttached) {
                                Debugger.Break();
                            }
                        }
                    }
                    Control target = Control.FromChildHandleInternal(msg.hwnd);
                    bool retValue = false;

                    Message m = Message.Create(msg.hwnd, msg.message, msg.wParam, msg.lParam);

                    if (target != null) {
                        try {
                            if (target.PreProcessMessage(ref m)) {
                                retValue = true;
                            }
                        }
                        catch (Exception e) {
                            if (NativeWindow.WndProcShouldBeDebuggable) 
                            {
                                throw;
                            }
                            else
                            {
                                OnThreadException(e);
                            }
                        }
                    }

                    msg.wParam = m.WParam;
                    msg.lParam = m.LParam;

                    if (retValue) {
                        return true;
                    }
                }

                return false;

            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnEnterState"]/*' />
            /// <devdoc>  
            ///      Notify component when app enters or exits (as indicated by fEnter)
            ///      the state identified by uStateID (a value from olecstate enumeration).
            ///      Component should take action depending on value of uStateID
            ///       (see olecstate comments, above).
            ///
            ///      Note: If n calls are made with TRUE fEnter, component should consider 
            ///      the state to be in effect until n calls are made with FALSE fEnter.
            ///      
            ///     Note: Components should be aware that it is possible for this method to
            ///     be called with FALSE fEnter more    times than it was called with TRUE 
            ///     fEnter (so, for example, if component is maintaining a state counter
            ///     (incremented when this method is called with TRUE fEnter, decremented
            ///     when called with FALSE fEnter), the counter should not be decremented
            ///     for FALSE fEnter if it is already at zero.)  
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponent.OnEnterState(int uStateID, bool fEnter) {

                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : OnEnterState(" + uStateID + ", " + fEnter + ")");

                if (uStateID == NativeMethods.MSOCM.msocstateModal) {
                    // We should only be messing with windows we own.  See the "ctrl-shift-N" test above.
                    if (fEnter) {
                        DisableWindowsForModalLoop(true); // WinFormsOnly = true
                    }
                    else {
                        EnableWindowsForModalLoop(true); // WinFormsOnly = true
                    }
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnAppActivate"]/*' />
            /// <devdoc>  
            ///      Notify component when the host application gains or loses activation.
            ///      If fActive is TRUE, the host app is being activated and dwOtherThreadID
            ///      is the ID of the thread owning the window being deactivated.
            ///      If fActive is FALSE, the host app is being deactivated and 
            ///      dwOtherThreadID is the ID of the thread owning the window being 
            ///      activated.
            ///      Note: this method is not called when both the window being activated
            ///      and the one being deactivated belong to the host app.
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponent.OnAppActivate(bool fActive, int dwOtherThreadID) {
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnLoseActivation"]/*' />
            /// <devdoc>      
            ///      Notify the active component that it has lost its active status because
            ///      the host or another component has become active.
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponent.OnLoseActivation() {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Our component is losing activation.");
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnActivationChange"]/*' />
            /// <devdoc> 
            ///      Notify component when a new object is being activated.
            ///      If pic is non-NULL, then it is the component that is being activated.
            ///      In this case, fSameComponent is TRUE if pic is the same component as
            ///      the callee of this method, and pcrinfo is the reg info of pic.
            ///      If pic is NULL and fHostIsActivating is TRUE, then the host is the
            ///      object being activated, and pchostinfo is its host info.
            ///      If pic is NULL and fHostIsActivating is FALSE, then there is no current
            ///      active object.
            ///
            ///      If pic is being activated and pcrinfo->grf has the 
            ///      olecrfExclusiveBorderSpace bit set, component should hide its border
            ///      space tools (toolbars, status bars, etc.);
            ///      component should also do this if host is activating and 
            ///      pchostinfo->grfchostf has the olechostfExclusiveBorderSpace bit set.
            ///      In either of these cases, component should unhide its border space
            ///      tools the next time it is activated.
            ///
            ///      if pic is being activated and pcrinfo->grf has the
            ///      olecrfExclusiveActivation bit is set, then pic is being activated in
            ///      "ExclusiveActive" mode.  
            ///      Component should retrieve the top frame window that is hosting pic
            ///      (via pic->HwndGetWindow(olecWindowFrameToplevel, 0)).  
            ///      If this window is different from component's own top frame window, 
            ///         component should disable its windows and do other things it would do
            ///         when receiving OnEnterState(olecstateModal, TRUE) notification. 
            ///      Otherwise, if component is top-level, 
            ///         it should refuse to have its window activated by appropriately
            ///         processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
            ///      Component should remain in one of these states until the 
            ///      ExclusiveActive mode ends, indicated by a future call to 
            ///      OnActivationChange with ExclusiveActivation bit not set or with NULL
            ///      pcrinfo.
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponent.OnActivationChange(UnsafeNativeMethods.IMsoComponent component, bool fSameComponent,
                                                  int pcrinfo,
                                                  bool fHostIsActivating,
                                                  int pchostinfo,
                                                  int dwReserved) {
                Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : OnActivationChange");
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FDoIdle"]/*' />
            /// <devdoc> 
            ///      Give component a chance to do idle time tasks.  grfidlef is a group of
            ///      bit flags taken from the enumeration of oleidlef values (above),
            ///      indicating the type of idle tasks to perform.  
            ///      Component may periodically call IOleComponentManager::FContinueIdle; 
            ///      if this method returns FALSE, component should terminate its idle 
            ///      time processing and return.  
            ///      Return TRUE if more time is needed to perform the idle time tasks, 
            ///      FALSE otherwise.
            ///      Note: If a component reaches a point where it has no idle tasks
            ///      and does not need FDoIdle calls, it should remove its idle task
            ///      registration via IOleComponentManager::FUpdateComponentRegistration.
            ///      Note: If this method is called on while component is performing a 
            ///      tracking operation, component should only perform idle time tasks that
            ///      it deems are appropriate to perform during tracking.
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponent.FDoIdle(int grfidlef) {

                if (idleHandler != null) {
                    idleHandler.Invoke(Thread.CurrentThread, EventArgs.Empty);
                }

                return false;

            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FContinueMessageLoop"]/*' />
            /// <devdoc>         
            ///      Called during each iteration of a message loop that the component
            ///      pushed. uReason and pvLoopData are the reason and the component private 
            ///      data that were passed to IOleComponentManager::FPushMessageLoop.
            ///      This method is called after peeking the next message in the queue
            ///      (via PeekMessage) but before the message is removed from the queue.
            ///      The peeked message is passed in the pMsgPeeked param (NULL if no
            ///      message is in the queue).  This method may be additionally called when
            ///      the next message has already been removed from the queue, in which case
            ///      pMsgPeeked is passed as NULL.
            ///      Return TRUE if the message loop should continue, FALSE otherwise.
            ///      If FALSE is returned, the component manager terminates the loop without
            ///      removing pMsgPeeked from the queue. 
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponent.FContinueMessageLoop(int reason, int pvLoopData, ref NativeMethods.MSG msgPeeked) {

                bool continueLoop = true;

                // If we get a null message, and we have previously posted the WM_QUIT message, 
                // then someone ate the message... 
                //
                if (msgPeeked.hwnd == IntPtr.Zero && msgPeeked.message == 0 && GetState(STATE_POSTEDQUIT)) {
                    Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Abnormal loop termination, no WM_QUIT received");
                    continueLoop = false;
                }
                else {
                    switch (reason) {
                        case NativeMethods.MSOCM.msoloopFocusWait:

                            // For focus wait, check to see if we are now the active application.
                            //
                            int pid;
                            SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(null, UnsafeNativeMethods.GetActiveWindow()), out pid);
                            if (pid == SafeNativeMethods.GetCurrentProcessId()) {
                                continueLoop = false;
                            }
                            break;

                        case NativeMethods.MSOCM.msoloopModalAlert:
                        case NativeMethods.MSOCM.msoloopModalForm:

                            // For modal forms, check to see if the current active form has been
                            // dismissed.  If there is no active form, then it is an error that
                            // we got into here, so we terminate the loop.
                            //
                            if (currentForm == null || currentForm.CheckCloseDialog()) {
                                continueLoop = false;
                            }
                            break;

                        case NativeMethods.MSOCM.msoloopDoEvents:
                            // For DoEvents, just see if there are more messages on the queue.
                            //
                            if (!UnsafeNativeMethods.PeekMessage(ref tempMsg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE)) {
                                continueLoop = false;
                            }

                            break;
                    }
                }

                return continueLoop;
            }


            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FQueryTerminate"]/*' />
            /// <devdoc> 
            ///      Called when component manager wishes to know if the component is in a
            ///      state in which it can terminate.  If fPromptUser is FALSE, component
            ///      should simply return TRUE if it can terminate, FALSE otherwise.
            ///      If fPromptUser is TRUE, component should return TRUE if it can
            ///      terminate without prompting the user; otherwise it should prompt the
            ///      user, either 1.) asking user if it can terminate and returning TRUE
            ///      or FALSE appropriately, or 2.) giving an indication as to why it
            ///      cannot terminate and returning FALSE. 
            /// </devdoc>
            bool UnsafeNativeMethods.IMsoComponent.FQueryTerminate(bool fPromptUser) {
                return true;
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.Terminate"]/*' />
            /// <devdoc>     
            ///      Called when component manager wishes to terminate the component's
            ///      registration.  Component should revoke its registration with component
            ///      manager, release references to component manager and perform any
            ///      necessary cleanup. 
            /// </devdoc>
            void UnsafeNativeMethods.IMsoComponent.Terminate() {
                if (this.messageLoopCount > 0 && !(ComponentManager is ComponentManager)) {
                    this.messageLoopCount--;
                }
            }

            /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.HwndGetWindow"]/*' />
            /// <devdoc> 
            ///      Called to retrieve a window associated with the component, as specified
            ///      by dwWhich, a olecWindowXXX value (see olecWindow, above).
            ///      dwReserved is reserved for future use and should be zero.
            ///      Component should return the desired window or NULL if no such window
            ///      exists. 
            /// </devdoc>
            IntPtr UnsafeNativeMethods.IMsoComponent.HwndGetWindow(int dwWhich, int dwReserved) {
                return IntPtr.Zero;
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ParkingWindow"]/*' />
        /// <devdoc>
        ///     This class embodies our parking window, which we create when the
        ///     first message loop is pushed onto the thread.
        /// </devdoc>
        /// <internalonly/>
        private sealed class ParkingWindow : ContainerControl {
            public ParkingWindow() {
                SetState(STATE_TOPLEVEL, true);
                Text = "WindowsFormsParkingWindow";
                Visible = false;
            }

            public void Destroy() {
                DestroyHandle();
            }

            protected override void WndProc(ref Message m) {
                if (m.Msg != NativeMethods.WM_SHOWWINDOW) {
                    base.WndProc(ref m);
                }
            }
        }

        /// <include file='doc\Application.uex' path='docs/doc[@for="Application.ThreadWindows"]/*' />
        /// <devdoc>
        ///     This class enables or disables all windows in the current thread.  We use this to
        ///     disable other windows on the thread when a modal dialog is to be shown.  It can also
        ///     be used to dispose all windows in a thread, which we do before returning from a message
        ///     loop.
        /// </devdoc>
        /// <internalonly/>
        private sealed class ThreadWindows {
            private IntPtr[] windows;
            private int windowCount;
            private Control parent;
            internal ThreadWindows previousThreadWindows;
            private bool onlyWinForms = true;

            internal ThreadWindows(Control parent, bool onlyWinForms) {
                windows = new IntPtr[16];
                this.parent = parent; // null is ok
                this.onlyWinForms = onlyWinForms;
                UnsafeNativeMethods.EnumThreadWindows(SafeNativeMethods.GetCurrentThreadId(),
                                                new NativeMethods.EnumThreadWindowsCallback(this.Callback),
                                                NativeMethods.NullHandleRef);
            }

            private bool Callback(IntPtr hWnd, IntPtr lparam) {

                // We only do visible and enabled windows.  Also, we only do top level windows.  
                // Finally, we only include windows that are DNA windows, since other MSO components
                // will be responsible for disabling their own windows.
                //
                if (SafeNativeMethods.IsWindowVisible(new HandleRef(null, hWnd)) && SafeNativeMethods.IsWindowEnabled(new HandleRef(null, hWnd))) {
                    bool add = false;

                    if (onlyWinForms) {
                        Control c = Control.FromHandleInternal(hWnd);
                        if (c != null && c != parent) {
                            add = true;
                        }
                    }
                    else {
                        if (parent == null || hWnd != parent.Handle) {
                            add = true;
                        }
                    }
                    if (add) {
                        if (windowCount == windows.Length) {
                            IntPtr[] newWindows = new IntPtr[windowCount * 2];
                            Array.Copy(windows, 0, newWindows, 0, windowCount);
                            windows = newWindows;
                        }
                        windows[windowCount++] = hWnd;
                    }
                }
                return true;
            }

            // Disposes all top-level Controls on this thread
            internal void Dispose() {
                for (int i = 0; i < windowCount; i++) {
                    IntPtr hWnd = windows[i];
                    if (UnsafeNativeMethods.IsWindow(new HandleRef(null, hWnd))) {
                        Control c = Control.FromHandleInternal(hWnd);
                        if (c != null) {
                            c.Dispose();
                        }
                    }
                }
            }

            // Enables/disables all top-level Controls on this thread
            internal void Enable(bool state) {
                bool parentEnabled = false;
                if (parent != null && parent.IsHandleCreated) {
                    parentEnabled = SafeNativeMethods.IsWindowEnabled(new HandleRef(parent, parent.Handle));
                }

                try {
                    for (int i = 0; i < windowCount; i++) {
                        IntPtr hWnd = windows[i];
                        Debug.WriteLineIf(CompModSwitches.MSOComponentManager.TraceInfo, "ComponentManager : Changing enabled on window: " + Convert.ToString((int)hWnd, 16) + " : " + state.ToString());
                        if (UnsafeNativeMethods.IsWindow(new HandleRef(null, hWnd))) SafeNativeMethods.EnableWindow(new HandleRef(null, hWnd), state);
                    }
                }
                finally {
                    // We need to guarantee that our dialog is still enabled, even though we skipped over
                    // disabling it above.  The reason is that if we're contained in some other host
                    // (i.e. visual basic), it may disable us as a result of us disabling one of its windows.
                    if (parentEnabled && !state && parent != null && parent.IsHandleCreated)
                        SafeNativeMethods.EnableWindow(new HandleRef(parent, parent.Handle), true);
                }
            }
        }

        class ModalApplicationContext : ApplicationContext {
            public ModalApplicationContext(Form modalForm) : base(modalForm) {
            }

            protected override void ExitThreadCore() {
                // do nothing... modal dialogs exit by setting dialog result
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\bootmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="BootMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    /// <include file='doc\BootMode.uex' path='docs/doc[@for="BootMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the mode to start the computer
    ///       in.
    ///    </para>
    /// </devdoc>
    public enum BootMode {
        /// <include file='doc\BootMode.uex' path='docs/doc[@for="BootMode.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts the computer in standard mode.
        ///    </para>
        /// </devdoc>
        Normal = 0,
        /// <include file='doc\BootMode.uex' path='docs/doc[@for="BootMode.FailSafe"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts the computer by using only the basic
        ///       files and
        ///       drivers.
        ///    </para>
        /// </devdoc>
        FailSafe = 1,
        /// <include file='doc\BootMode.uex' path='docs/doc[@for="BootMode.FailSafeWithNetwork"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts the computer by using the basic files, drivers and
        ///       the services and drivers
        ///       necessary to start networking.
        ///    </para>
        /// </devdoc>
        FailSafeWithNetwork = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\borderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="BorderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the
    ///       border style for a control or form.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum BorderStyle {

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No border.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.FixedSingle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A single-line border.
        ///    </para>
        /// </devdoc>
        FixedSingle = 1,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Fixed3D"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A three-dimensional border.
        ///    </para>
        /// </devdoc>
        Fixed3D = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\border3dstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="Border3DStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the style of a three-dimensional border.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum Border3DStyle {

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Adjust"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border is drawn
        ///       outside the
        ///       specified rectangle, preserving the dimensions of the rectangle for drawing.
        ///    </para>
        /// </devdoc>
        Adjust = NativeMethods.BF_ADJUST,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Bump"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has
        ///       a raised outer edge and a sunken inner edge.
        ///    </para>
        /// </devdoc>
        Bump = NativeMethods.EDGE_BUMP,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Etched"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a
        ///       with a sunken inner edge and a raised outer edge.
        ///    </para>
        /// </devdoc>
        Etched = NativeMethods.EDGE_ETCHED,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Flat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with no three-dimensional effects.
        ///    </para>
        /// </devdoc>
        Flat = NativeMethods.BF_FLAT | NativeMethods.EDGE_SUNKEN,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Raised"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with
        ///       raised inner and outer edges.
        ///    </para>
        /// </devdoc>
        Raised = NativeMethods.EDGE_RAISED,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.RaisedInner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with a raised inner edge and no outer edge.
        ///    </para>
        /// </devdoc>
        RaisedInner = NativeMethods.BDR_RAISEDINNER,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.RaisedOuter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a
        ///       with a raised outer edge and no inner edge.
        ///    </para>
        /// </devdoc>
        RaisedOuter = NativeMethods.BDR_RAISEDOUTER,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.Sunken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with sunken inner and outer edges.
        ///    </para>
        /// </devdoc>
        Sunken = NativeMethods.EDGE_SUNKEN,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.SunkenInner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with
        ///       a sunken inner edge and no outer edge.
        ///    </para>
        /// </devdoc>
        SunkenInner = NativeMethods.BDR_SUNKENINNER,

        /// <include file='doc\Border3DStyle.uex' path='docs/doc[@for="Border3DStyle.SunkenOuter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The border has a with a sunken outer edge and no inner edge.
        ///    </para>
        /// </devdoc>
        SunkenOuter = NativeMethods.BDR_SUNKENOUTER,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\boundsspecified.cs ===
//------------------------------------------------------------------------------
// <copyright file="BoundsSpecified.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;

    /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the bounds of the control to
    ///       use when defining a control's size and position.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum BoundsSpecified {
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the
        ///       left
        ///       edge of the
        ///       control is defined.
        ///    </para>
        /// </devdoc>
        X = 0x1,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the
        ///       top edge of the
        ///       control of the
        ///       control is defined.
        ///    </para>
        /// </devdoc>
        Y = 0x2,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       the width
        ///       of the control is defined.
        ///    </para>
        /// </devdoc>
        Width = 0x4,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       the
        ///       height of the control is defined.
        ///    </para>
        /// </devdoc>
        Height = 0x8,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.Location"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both <see langword='X'/> and <see langword='Y'/> coordinates of the control are
        ///       defined.
        ///    </para>
        /// </devdoc>
        Location = X | Y,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both <see cref='System.Windows.Forms.Control.Width'/> and <see cref='System.Windows.Forms.Control.Height'/> property values of the control are
        ///       defined.
        ///    </para>
        /// </devdoc>
        Size = Width | Height,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both <see cref='System.Windows.Forms.Control.Location'/> and <see cref='System.Windows.Forms.Control.Size'/> property values are
        ///       defined.
        ///    </para>
        /// </devdoc>
        All = Location | Size,
        /// <include file='doc\BoundsSpecified.uex' path='docs/doc[@for="BoundsSpecified.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No
        ///       bounds
        ///       are specified.
        ///    </para>
        /// </devdoc>
        None = 0,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\axhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="AxHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;
    using System.IO;
    using System.Drawing;    
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.ComponentModel.Com2Interop;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing.Imaging;
    using System.Drawing.Design;
    

    /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost"]/*' />
    /// <devdoc>
    ///    <para>
    ///
    ///       Wraps ActiveX controls and exposes them as
    ///       fully featured windows forms controls.
    ///    </para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultEvent("Enter"),
    Designer("System.Windows.Forms.Design.AxHostDesigner, " + AssemblyRef.SystemDesign),
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class AxHost : Control, ISupportInitialize, ICustomTypeDescriptor {

        private static TraceSwitch AxHTraceSwitch     = new TraceSwitch("AxHTrace", "ActiveX handle tracing");
        private static TraceSwitch AxPropTraceSwitch  = new TraceSwitch("AxPropTrace", "ActiveX property tracing");
        private static TraceSwitch AxHostSwitch       = new TraceSwitch("AxHost", "ActiveX host creation");
        private static BooleanSwitch AxIgnoreTMSwitch = new BooleanSwitch("AxIgnoreTM", "ActiveX switch to ignore thread models");
        private static BooleanSwitch AxAlwaysSaveSwitch = new BooleanSwitch("AxAlwaysSave", "ActiveX to save all controls regardless of their IsDirty function return value");

        /// <devdoc>
        ///     Flags which may be passed to the AxHost constructor
        /// </devdoc>
        internal class AxFlags {
            /// <devdoc>
            ///     Indicates that the context menu for the control should not contain an
            ///     "Edit" verb unless the activeX controls itself decides to proffer it.
            ///     By default, all wrapped activeX controls will contain an edit verb.
            /// </devdoc>
            internal const int PreventEditMode  = 0x1;

            /// <devdoc>
            ///     Indicated that the context menu for the control should contain
            ///     a "Properties..." verb which may be used to show the property
            ///     pages for the control.  Note that even if this flag is
            ///     specified, the verb will not appear unless the control
            ///     proffers a set of property pages.
            ///     [Since most activeX controls alreay have their own properties verb
            ///     on the context menu, the default is not to include one specified by
            ///     this flag.]
            /// </devdoc>
            internal const int IncludePropertiesVerb = 0x2;
        
            /// <devdoc>
            /// </devdoc>
            /// <internalonly/>
            internal const int IgnoreThreadModel     = 0x10000000;
        }

        private static COMException E_NOTIMPL = new COMException("Not implemented", unchecked((int)0x80000001));
        private static COMException E_INVALIDARG = new COMException("Invalid argument", unchecked((int)0x80070057));
        private static COMException E_FAIL   = new COMException("Unknown error", unchecked((int)0x80004005));
        private static COMException E_NOINTERFACE = new COMException("Interface not supported", unchecked((int)0x80004002));

        private const int INPROC_SERVER = 1;
        private const int OC_PASSIVE = 0;
        private const int OC_LOADED = 1;  // handler, but no server   [ocx created]
        private const int OC_RUNNING = 2; // server running, invisible [iqa & depersistance]
        private const int OC_INPLACE = 4; // server in-place active [inplace]
        private const int OC_UIACTIVE = 8;// server is UI active [uiactive]
        private const int OC_OPEN = 16;    // server is being open edited [not used]

        private const int EDITM_NONE = 0;   // object not being edited
        private const int EDITM_OBJECT = 1; // object provided an edit verb and we invoked it
        private const int EDITM_HOST = 2;   // we invoked our own edit verb

        private const int STG_UNKNOWN = -1;
        private const int STG_STREAM = 0;
        private const int STG_STREAMINIT = 1;
        private const int STG_STORAGE = 2;

        private const int OLEIVERB_SHOW = -1;
        private const int OLEIVERB_HIDE = -3;
        private const int OLEIVERB_UIACTIVATE = -4;
        private const int OLEIVERB_INPLACEACTIVATE =-5;
        private const int OLEIVERB_PROPERTIES = -7;
        private const int OLEIVERB_PRIMARY = 0;

        private readonly int REGMSG_MSG = SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + "_subclassCheck");
        private const int REGMSG_RETVAL = 123;

        private static int logPixelsX = -1;
        private static int logPixelsY = -1;

        private static Guid   icf2_Guid                = typeof(UnsafeNativeMethods.IClassFactory2).GUID;
        private static Guid   ifont_Guid               = typeof(SafeNativeMethods.IFont).GUID;
        private static Guid   ifontDisp_Guid           = typeof(SafeNativeMethods.IFontDisp).GUID;
        private static Guid   ipicture_Guid            = typeof(SafeNativeMethods.IPicture).GUID;
        private static Guid   ipictureDisp_Guid        = typeof(SafeNativeMethods.IPictureDisp).GUID;
        private static Guid   ivbformat_Guid           = typeof(UnsafeNativeMethods.IVBFormat).GUID;
        private static Guid   ioleobject_Guid          = typeof(UnsafeNativeMethods.IOleObject).GUID;
        private static Guid   dataSource_Guid          = new Guid("{7C0FFAB3-CD84-11D0-949A-00A0C91110ED}");
        private static Guid   windowsMediaPlayer_Clsid = new Guid("{22d6f312-b0f6-11d0-94ab-0080c74c7e95}");
        private static Guid   comctlImageCombo_Clsid   = new Guid("{a98a24c0-b06f-3684-8c12-c52ae341e0bc}");
        private static Guid   maskEdit_Clsid           = new Guid("{c932ba85-4374-101b-a56c-00aa003668dc}");

        // Static state for perf optimization
        //
        private static Hashtable fontTable;

        // BitVector32 masks for various internal state flags.
        //
        private static readonly int     ocxStateSet = BitVector32.CreateMask();
        private static readonly int     editorRefresh = BitVector32.CreateMask(ocxStateSet);
        private static readonly int     listeningToIdle = BitVector32.CreateMask(editorRefresh);
        private static readonly int     refreshProperties = BitVector32.CreateMask(listeningToIdle);
        
        private static readonly int     checkedIppb = BitVector32.CreateMask(refreshProperties);
        private static readonly int     checkedCP = BitVector32.CreateMask(checkedIppb);
        private static readonly int     fNeedOwnWindow = BitVector32.CreateMask(checkedCP);
        private static readonly int     fOwnWindow = BitVector32.CreateMask(fNeedOwnWindow);
        
        private static readonly int     fSimpleFrame = BitVector32.CreateMask(fOwnWindow);
        private static readonly int     fFakingWindow = BitVector32.CreateMask(fSimpleFrame);
        private static readonly int     rejectSelection = BitVector32.CreateMask(fFakingWindow);
        private static readonly int     ownDisposing = BitVector32.CreateMask(rejectSelection);
        
        private static readonly int     sinkAttached = BitVector32.CreateMask(ownDisposing);
        private static readonly int     disposed = BitVector32.CreateMask(sinkAttached);
        private static readonly int     manualUpdate = BitVector32.CreateMask(disposed);
        private static readonly int     addedSelectionHandler = BitVector32.CreateMask(manualUpdate);
        
        private static readonly int     valueChanged = BitVector32.CreateMask(addedSelectionHandler);
        private static readonly int     handlePosRectChanged = BitVector32.CreateMask(valueChanged);
        private static readonly int     siteProcessedInputKey = BitVector32.CreateMask(handlePosRectChanged);
        private static readonly int     needLicenseKey = BitVector32.CreateMask(siteProcessedInputKey);
        
        private static readonly int     inTransition = BitVector32.CreateMask(needLicenseKey);
        private static readonly int     processingKeyUp = BitVector32.CreateMask(inTransition);
        private static readonly int     assignUniqueID = BitVector32.CreateMask(processingKeyUp);
        private static readonly int     renameEventHooked  = BitVector32.CreateMask(assignUniqueID);



        private BitVector32 axState = new BitVector32();

        private int storageType = STG_UNKNOWN;
        private int ocState = OC_PASSIVE;
        private int miscStatusBits;
        private int freezeCount = 0;
        private int flags = 0;
        private int selectionStyle = 0;
        private int editMode = EDITM_NONE;
        private int noComponentChange = 0;
        
        private IntPtr wndprocAddr = IntPtr.Zero;

        private Guid   clsid;
        private string text = "";
        private string licenseKey = null;

        private readonly OleInterfaces oleSite;
        private AxComponentEditor editor;
        private AxContainer container;
        private ContainerControl containingControl;
        private State ocxState;
        private IntPtr hwndFocus = IntPtr.Zero;

        // CustomTypeDescriptor related state
        //
        private Hashtable properties = null;
        private Hashtable propertyInfos = null;
        private PropertyDescriptorCollection propsStash = null;
        private Attribute[] attribsStash = null;

        // interface pointers to the ocx
        //
        private Object instance;
        private UnsafeNativeMethods.IOleInPlaceObject iOleInPlaceObject;
        private UnsafeNativeMethods.IOleObject iOleObject;
        private UnsafeNativeMethods.IOleControl iOleControl;
        private UnsafeNativeMethods.IOleInPlaceActiveObject iOleInPlaceActiveObject;
        private NativeMethods.IPerPropertyBrowsing iPerPropertyBrowsing;
        private NativeMethods.ICategorizeProperties iCategorizeProperties;
        private UnsafeNativeMethods.IPersistPropertyBag iPersistPropBag;
        private UnsafeNativeMethods.IPersistStream iPersistStream;
        private UnsafeNativeMethods.IPersistStreamInit iPersistStreamInit;
        private UnsafeNativeMethods.IPersistStorage iPersistStorage;
        
        private AboutBoxDelegate aboutBoxDelegate = null;
        private EventHandler selectionChangeHandler;

        private bool isMaskEdit;
        private bool ignoreDialogKeys;

        
        // These should be in the order given by the PROPCAT_X values
        // Also, note that they are not to be localized...

        private static CategoryAttribute[] categoryNames = new CategoryAttribute [] {
            null,
            new WinCategoryAttribute("Default"),
            new WinCategoryAttribute("Default"),
            new WinCategoryAttribute("Font"),
            new WinCategoryAttribute("Layout"),
            new WinCategoryAttribute("Appearance"),
            new WinCategoryAttribute("Behavior"),
            new WinCategoryAttribute("Data"),
            new WinCategoryAttribute("List"),
            new WinCategoryAttribute("Text"),
            new WinCategoryAttribute("Scale"),
            new WinCategoryAttribute("DDE")
        };

        private Hashtable objectDefinedCategoryNames = null; // Integer -> String

#if DEBUG
        static AxHost() {
            Debug.Assert((int)DockStyle.None == (int)NativeMethods.ActiveX.ALIGN_NO_CHANGE,"align value mismatch");
            Debug.Assert((int)DockStyle.Top == (int)NativeMethods.ActiveX.ALIGN_TOP,"align value mismatch");
            Debug.Assert((int)DockStyle.Bottom == (int)NativeMethods.ActiveX.ALIGN_BOTTOM,"align value mismatch");
            Debug.Assert((int)DockStyle.Left == (int)NativeMethods.ActiveX.ALIGN_LEFT,"align value mismatch");
            Debug.Assert((int)DockStyle.Right == (int)NativeMethods.ActiveX.ALIGN_RIGHT,"align value mismatch");
            Debug.Assert((int)MouseButtons.Left == 0x00100000, "mb.left mismatch");
            Debug.Assert((int)MouseButtons.Right == 0x00200000, "mb.right mismatch");
            Debug.Assert((int)MouseButtons.Middle == 0x00400000, "mb.middle mismatch");
            Debug.Assert((int)Keys.Shift == 0x00010000, "key.shift mismatch");
            Debug.Assert((int)Keys.Control == 0x00020000, "key.control mismatch");
            Debug.Assert((int)Keys.Alt == 0x00040000, "key.alt mismatch");
        }
#endif 

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxHost1"]/*' />
        /// <devdoc>
        ///     Creates a new instance of a control which wraps an activeX control given by the
        ///     clsid parameter and flags of 0.
        /// </devdoc>
        protected AxHost(string clsid) : this(clsid, 0) {
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxHost2"]/*' />
        /// <devdoc>
        ///    <para>Creates a new instance of a control which wraps an activeX control given by the
        ///       clsid and flags parameters.</para>
        /// </devdoc>
        protected AxHost(string clsid, int flags) : base() {
            if (Application.OleRequired() != ApartmentState.STA) {
                throw new ThreadStateException(SR.GetString(SR.AXMTAThread, clsid));
            }

            this.oleSite = new OleInterfaces(this);
            this.selectionChangeHandler = new EventHandler(this.OnNewSelection);
            this.clsid = new Guid(clsid);
            this.flags = flags;

            this.axState[assignUniqueID] = !this.GetType().GUID.Equals(comctlImageCombo_Clsid);
            this.axState[needLicenseKey] = true;
            this.axState[rejectSelection] = true;

            isMaskEdit = this.clsid.Equals(AxHost.maskEdit_Clsid);
        }

        private bool CanUIActivate {
            get {
                return IsUserMode() || editMode != EDITM_NONE;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the CreateParams used to create the handle for this control.
        /// </devdoc>
        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;
                if (axState[fOwnWindow] && IsUserMode()) {
                    cp.Style = cp.Style & (~NativeMethods.WS_VISIBLE);
                }
                return cp;
            }
        }

        private bool GetAxState(int mask) {
            return this.axState[mask];
        }
        
        private void SetAxState(int mask, bool value) {
            this.axState[mask] = value;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AttachInterfaces"]/*' />
        /// <devdoc>
        ///     AxHost will call this when it is ready to create the underlying ActiveX object.
        ///     Wrappers will override this and cast the pointer obtained by calling getOcx() to
        ///     their own interfaces.  getOcx() should not usually be called before this function.
        ///     Note: calling begin will result in a call to this function.
        /// </devdoc>
        protected virtual void AttachInterfaces() {
        }

        private void RealizeStyles() {
            SetStyle(ControlStyles.UserPaint, false);
            int bits = 0;
            int hr = GetOleObject().GetMiscStatus(NativeMethods.ActiveX.DVASPECT_CONTENT, out bits);
            if (!NativeMethods.Failed(hr)) {
                miscStatusBits = bits;
                ParseMiscBits(miscStatusBits);
            }
        }

        // Control overrides:

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                return base.BackColor;
            }

            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }

            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Cursor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Cursor Cursor {
            get {
                return base.Cursor;
            }

            set {
                base.Cursor = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ContextMenu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override ContextMenu ContextMenu {
            get {
                return base.ContextMenu;
            }

            set {
                base.ContextMenu = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(75, 23);
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Enabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public virtual new bool Enabled {
            get {
                return base.Enabled;
            }

            set {
                base.Enabled = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }

            set {
                base.Font = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }

            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RightToLeft"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            Browsable(false), 
            EditorBrowsable(EditorBrowsableState.Never),
            Localizable(true)
        ]
        public new virtual bool RightToLeft {
            get {
                RightToLeft rtol = base.RightToLeft;
                return rtol == System.Windows.Forms.RightToLeft.Yes;
            }

            set {
                base.RightToLeft = (value) ? System.Windows.Forms.RightToLeft.Yes : System.Windows.Forms.RightToLeft.No;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override string Text {
            get {
                return text;
            }

            set {
                text = value;
            }
        }

        internal override bool CanAccessProperties {
            get {
                int ocState = GetOcState();
                return(axState[fOwnWindow] &&
                       (ocState > OC_RUNNING || (IsUserMode() && ocState >= OC_RUNNING)) ||
                       ocState >= OC_INPLACE);
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.PropsValid"]/*' />
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected bool PropsValid() {
            return CanAccessProperties;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void BeginInit() {
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.EndInit"]/*' />
        /// <devdoc>
        ///     Signals the object that loading of all peer components and property
        ///     sets are complete.
        ///     It should be possible to invoke any property get or set after calling this method.
        ///     Note that a sideeffect of this method is the creation of the parent control's
        ///     handle, therefore, this control must be parented before begin is called
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void EndInit() {
            if (ParentInternal != null) {
                ParentInternal.CreateControl(true);

                ContainerControl f = ContainingControl;
                if (f != null) {
                    f.VisibleChanged += new EventHandler(this.OnContainerVisibleChanged);
                }
            }
        }

        private void OnContainerVisibleChanged(object sender, EventArgs e) {
            ContainerControl f = ContainingControl;
            if (f != null) {
                if (f.Visible && Visible && !axState[fOwnWindow]) {
                    MakeVisibleWithShow();
                }
                else if (!f.Visible && Visible && IsHandleCreated && GetOcState() >= OC_INPLACE) {
                    HideAxControl();
                }
                else if (f.Visible && !GetState(STATE_VISIBLE) && IsHandleCreated && GetOcState() >= OC_INPLACE) {
                    HideAxControl();
                }
            }
        }

        //
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.EditMode"]/*' />
        /// <devdoc>
        ///      Determines if the control is in edit mode.
        /// </devdoc>
        [   Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool EditMode {
            get {
                return editMode != EDITM_NONE;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.HasAboutBox"]/*' />
        /// <devdoc>
        ///      Determines if this control has an about box.
        /// </devdoc>
        [   Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool HasAboutBox {
            get {
                return aboutBoxDelegate != null;
            }
        }

        private int NoComponentChangeEvents {
            get {
                return noComponentChange;
            }

            set {
                noComponentChange = value;
            }
        }

        //
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ShowAboutBox"]/*' />
        /// <devdoc>
        ///      Shows the about box for this control.
        /// </devdoc>
        public void ShowAboutBox() {
            if (aboutBoxDelegate != null) {
                aboutBoxDelegate();
            }
        }

        //
        /// <devdoc>
        ///      Retrieves the OCX control flags.
        /// </devdoc>
        [   Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        private int OcxFlags {
            get {
                return flags;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "BackColorChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "BackColorChanged"));
            }
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BackgroundImageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "BackgroundImageChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "BackgroundImageChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.BindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BindingContextChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "BindingContextChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "BindingContextChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ContextMenuChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ContextMenuChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "ContextMenuChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "ContextMenuChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.CursorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CursorChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "CursorChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "CursorChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.EnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is enabled.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler EnabledChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "EnabledChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "EnabledChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.FontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "FontChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "FontChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "ForeColorChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "ForeColorChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RightToLeftChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler RightToLeftChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "RightToLeftChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "RightToLeftChanged"));
            }
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.TabIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabIndexChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "TabIndexChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "TabIndexChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.TabStopChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "TabStopChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "TabStopChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.TextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                throw new NotSupportedException(SR.GetString("AXAddInvalidEvent", "TextChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString("AXRemoveInvalidEvent", "TextChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Click"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is clicked.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler Click {
            add { 
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "Click"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "Click"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DragDrop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event DragEventHandler DragDrop {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "DragDrop"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "DragDrop"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DragEnter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event DragEventHandler DragEnter {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "DragEnter"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "DragEnter"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DragOver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event DragEventHandler DragOver {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "DragOver"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "DragOver"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DragLeave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DragLeave {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "DragLeave"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "DragLeave"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GiveFeedback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event GiveFeedbackEventHandler GiveFeedback {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "GiveFeedback"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "GiveFeedback"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.HelpRequested"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event HelpEventHandler HelpRequested {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "HelpRequested"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "HelpRequested"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Paint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event PaintEventHandler Paint {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "Paint"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "Paint"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.QueryContinueDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event QueryContinueDragEventHandler QueryContinueDrag {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "QueryContinueDrag"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "QueryContinueDrag"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.QueryAccessibilityHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event QueryAccessibilityHelpEventHandler QueryAccessibilityHelp {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "QueryAccessibilityHelp"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "QueryAccessibilityHelp"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DoubleClick"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is double clicked.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DoubleClick {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "DoubleClick"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "DoubleClick"));
            }
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ImeModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ImeModeChanged {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "ImeModeChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "ImeModeChanged"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.KeyDown"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a key is pressed down while the control has focus.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event KeyEventHandler KeyDown {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "KeyDown"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "KeyDown"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.KeyPress"]/*' />
        /// <devdoc>
        ///    <para> Occurs when a key is pressed while the control has focus.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event KeyPressEventHandler KeyPress {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "KeyPress"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "KeyPress"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.KeyUp"]/*' />
        /// <devdoc>
        ///    <para> Occurs when a key is released while the control has focus.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event KeyEventHandler KeyUp {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "KeyUp"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "KeyUp"));
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Layout"]/*' />
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event LayoutEventHandler Layout {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "Layout"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "Layout"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseDown"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the mouse pointer is over the control and a mouse button is 
        ///       pressed.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event MouseEventHandler MouseDown {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseDown"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseDown"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseEnter"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer enters the AxHost.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler MouseEnter {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseEnter"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseEnter"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseLeave"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer leaves the AxHost.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler MouseLeave {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseLeave"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseLeave"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseHover"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer hovers over the contro.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler MouseHover {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseHover"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseHover"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseMove"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer is moved over the AxHost.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event MouseEventHandler MouseMove {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseMove"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseMove"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseUp"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the mouse pointer is over the control and a mouse button is released.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event MouseEventHandler MouseUp {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseUp"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseUp"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MouseWheel"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse wheel moves while the control has focus.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event MouseEventHandler MouseWheel {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "MouseWheel"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "MouseWheel"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ChangeUICues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event UICuesEventHandler ChangeUICues {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "ChangeUICues"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "ChangeUICues"));
            }
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.StyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler StyleChanged {
            add {
                throw new NotSupportedException(SR.GetString(SR.AXAddInvalidEvent, "StyleChanged"));
            }
            remove {
                throw new NotSupportedException(SR.GetString(SR.AXRemoveInvalidEvent, "StyleChanged"));
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            AmbientChanged(NativeMethods.ActiveX.DISPID_AMBIENT_FONT);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnForeColorChanged(EventArgs e) {
            base.OnForeColorChanged(e);
            AmbientChanged(NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            base.OnBackColorChanged(e);
            AmbientChanged(NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR);
        }

        private void AmbientChanged(int dispid) {
            if (GetOcx() != null) {
                try {
                    Invalidate();
                    GetOleControl().OnAmbientPropertyChange(dispid);
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                }
            }
        }

        private bool OwnWindow() {
            return axState[fOwnWindow] || axState[fFakingWindow];
        }

        private IntPtr GetHandleNoCreate() {
            if (IsHandleCreated) return Handle;
            return IntPtr.Zero;
        }

        private ISelectionService GetSelectionService() {
            return GetSelectionService(this);
        }

        private static ISelectionService GetSelectionService(Control ctl) {
            ISite site = ctl.Site;
            if (site != null) {
                Object o = site.GetService(typeof(ISelectionService));
                Debug.Assert(o == null || o is ISelectionService, "service must implement ISelectionService");
                if (o is ISelectionService) {
                    return(ISelectionService) o;
                }
            }
            return null;
        }

        private void AddSelectionHandler() {
            if (axState[addedSelectionHandler]) return;
            ISelectionService iss = GetSelectionService();
            if (iss != null) {
                iss.SelectionChanging += selectionChangeHandler;
            }
            axState[addedSelectionHandler] = true;
        }

        private void OnComponentRename(object sender, ComponentRenameEventArgs e) 
        {
            // When we're notified of a rename, see if this is the componnent that is being
            // renamed.
            //
            if (e.Component == this) 
            {
                // if it is, call DISPID_AMBIENT_DISPLAYNAME directly on the
                // control itself.
                //
                UnsafeNativeMethods.IOleControl oleCtl = this.GetOcx() as UnsafeNativeMethods.IOleControl;
                if (oleCtl != null) 
                {   
                    oleCtl.OnAmbientPropertyChange(NativeMethods.ActiveX.DISPID_AMBIENT_DISPLAYNAME);
                }
            }
        }



        private bool RemoveSelectionHandler() {
            if (!axState[addedSelectionHandler]) return false;
            ISelectionService iss = GetSelectionService();
            if (iss != null) {
                iss.SelectionChanging -= selectionChangeHandler;
            }
            axState[addedSelectionHandler] = false;
            return true;
        }

        private void SyncRenameNotification(bool hook) {
            if (DesignMode && hook != axState[renameEventHooked]) 
            {
                // if we're in design mode, listen to the following events from the component change service
                //
                IComponentChangeService changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
    
                if (changeService != null) 
                {
                    if (hook) {
                        changeService.ComponentRename += new ComponentRenameEventHandler(OnComponentRename);
                    }
                    else {
                        changeService.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                    }
                    axState[renameEventHooked] = hook;
                }
            }
        }




        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Site"]/*' />
        /// <devdoc>
        ///     Sets the site of this component. A non-null value indicates that the
        ///     component has been added to a container, and a null value indicates that
        ///     the component is being removed from a container.
        /// </devdoc>
        public override ISite Site {
            set {
                bool reAddHandler = RemoveSelectionHandler();
                bool olduMode = IsUserMode();

                // clear the old hook
                //
                SyncRenameNotification(false);


                base.Site = value;
                bool newuMode = IsUserMode();
                if (!newuMode) GetOcxCreate();
                if (reAddHandler) AddSelectionHandler();

                SyncRenameNotification(value != null);



                // For inherited forms we create the OCX first in User mode
                // and then we get sited. At that time, we have to re-activate
                // the OCX by transitioning down to and up to the current state.
                //
                if (value != null && !newuMode && olduMode != newuMode && GetOcState() > OC_LOADED) {
                    TransitionDownTo(OC_LOADED);
                    TransitionUpTo(OC_INPLACE);
                    ContainerControl f = ContainingControl;
                    if (f != null && f.Visible && Visible)
                        MakeVisibleWithShow();
                }

                if (olduMode != newuMode && !IsHandleCreated && !axState[disposed]) {
                    if (GetOcx() != null) {
                        RealizeStyles();
                    }
                }
                if (!newuMode) {
                    //SetupClass_Info(this);
                }
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnLostFocus"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.LostFocus'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnLostFocus(EventArgs e) {
            // ASURT 93669
            // Office WebControl and MS DDS control create a child window that gains
            // focus in order to handle keyboard input. Since, UIDeactivate() could
            // destroy that window, these controls will crash trying to process WM_CHAR.
            // We now check to see if we are losing focus to a child, and if so, not call
            // UIDeactivate().
            //

            bool uiDeactivate = (GetHandleNoCreate() != hwndFocus);

            if (uiDeactivate && IsHandleCreated) {
                uiDeactivate = !UnsafeNativeMethods.IsChild(new HandleRef(this, GetHandleNoCreate()), new HandleRef(null, hwndFocus));
            }

            base.OnLostFocus(e);
            if (uiDeactivate) {
                UiDeactivate();
            }

        }

        private void OnNewSelection(Object sender, EventArgs e) {
            if (IsUserMode()) return;
            ISelectionService iss = GetSelectionService();
            // What we care about:
            // if we are uiactive and we loose selection, then we need to uideactivate ourselves...
            if (iss != null) {
                if (GetOcState() >= OC_UIACTIVE && !iss.GetComponentSelected(this)) {
                    // need to deactivate...
                    int hr = UiDeactivate();
                    if (NativeMethods.Failed(hr)) {
                        // not much we can do here...
                        Debug.Fail("Failed to UiDeactivate: " + hr.ToString());
                    }
                }
                if (!iss.GetComponentSelected(this)) {
                    if (editMode != EDITM_NONE) {
                        GetParentContainer().OnExitEditMode(this);
                        editMode = EDITM_NONE;
                    }
                    // need to exit edit mode...
                    SetSelectionStyle(1);
                    RemoveSelectionHandler();
                }
                else {
                    // The AX Host designer will offer an extender property called "SelectionStyle" 
                    // 
                    PropertyDescriptor prop = TypeDescriptor.GetProperties(this)["SelectionStyle"];
                    
                    if (prop != null && prop.PropertyType == typeof(int)) {
                        int curSelectionStyle = (int)prop.GetValue(this);
                        if (curSelectionStyle != this.selectionStyle) {
                            prop.SetValue(this, selectionStyle);
                        }
                    }
                }
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.CreateHandle"]/*' />
        /// <devdoc>
        ///     Creates a handle for this control. This method is called by the .NET framework, this should
        ///     not be called.
        /// </devdoc>
        protected override void CreateHandle() {
            if (!IsHandleCreated) {
                TransitionUpTo(OC_RUNNING);
                if (!axState[fOwnWindow]) {
                    if (axState[fNeedOwnWindow]) {
                        Debug.Assert(!Visible, "if we were visible we would not be needing a fake window...");
                        axState[fNeedOwnWindow] = false;
                        axState[fFakingWindow] = true;
                        base.CreateHandle();
                        // note that we do not need to attach the handle because the work usually done in there
                        // will be done in Control's wndProc on WM_CREATE...
                    }
                    else {
                        TransitionUpTo(OC_INPLACE);
                        // it is possible that we were hidden while in place activating, in which case we don't
                        // really have a handle now because the act of hiding could have destroyed it
                        // so, just call ourselves again recursively, and if we dont't have a handle, we will
                        // just take the "axState[fNeedOwnWindow]" path above...
                        if (axState[fNeedOwnWindow]) {
                            Debug.Assert(!IsHandleCreated, "if we need a fake window, we can't have a real one");
                            CreateHandle();
                            return;
                        }
                    }
                }
                else {
                    SetState(STATE_VISIBLE, false);
                    base.CreateHandle();
                }
                GetParentContainer().ControlCreated(this);
            }
        }

        private NativeMethods.COMRECT GetClipRect(NativeMethods.COMRECT clipRect) {
            if (clipRect != null) {
                FillInRect(clipRect, new Rectangle(0, 0, 32000, 32000));
            }
            return clipRect;
        }

        private static int SetupLogPixels(bool force) {
            if (logPixelsX == -1 || force) {
                IntPtr hDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                if (hDC == IntPtr.Zero)
                    return NativeMethods.E_FAIL;
                logPixelsX = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hDC), NativeMethods.LOGPIXELSX);
                logPixelsY = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hDC), NativeMethods.LOGPIXELSY);
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "log pixels are: "+logPixelsX.ToString()+" "+logPixelsY.ToString());
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hDC));
            }
            
            return NativeMethods.S_OK;
        }

        private void HiMetric2Pixel(NativeMethods.tagSIZEL sz, NativeMethods.tagSIZEL szout) {
            NativeMethods._POINTL phm = new NativeMethods._POINTL();
            phm.x = sz.cx;
            phm.y = sz.cy;
            NativeMethods.tagPOINTF pcont = new NativeMethods.tagPOINTF();
            ((UnsafeNativeMethods.IOleControlSite)oleSite).TransformCoords(phm, pcont, NativeMethods.ActiveX.XFORMCOORDS_SIZE | NativeMethods.ActiveX.XFORMCOORDS_HIMETRICTOCONTAINER);
            szout.cx = (int)pcont.x;
            szout.cy = (int)pcont.y;
        }

        private void Pixel2hiMetric(NativeMethods.tagSIZEL sz, NativeMethods.tagSIZEL szout) {
            NativeMethods.tagPOINTF pcont = new NativeMethods.tagPOINTF();
            pcont.x = (float) sz.cx;
            pcont.y = (float) sz.cy;
            NativeMethods._POINTL phm = new NativeMethods._POINTL();
            ((UnsafeNativeMethods.IOleControlSite)oleSite).TransformCoords(phm, pcont, NativeMethods.ActiveX.XFORMCOORDS_SIZE | NativeMethods.ActiveX.XFORMCOORDS_CONTAINERTOHIMETRIC);
            szout.cx = phm.x;
            szout.cy = phm.y;
        }

        private static int Pixel2Twip(int v, bool xDirection) {
            SetupLogPixels(false);
            int logP = xDirection ? logPixelsX : logPixelsY;
            return(int) ((((double)v) / logP) * 72.0 * 20.0);
        }

        private static int Twip2Pixel(double v, bool xDirection) {
            SetupLogPixels(false);
            int logP = xDirection ? logPixelsX : logPixelsY;
            return(int) (((v / 20.0) / 72.0) * logP);
        }

        private static int Twip2Pixel(int v, bool xDirection) {
            SetupLogPixels(false);
            int logP = xDirection ? logPixelsX : logPixelsY;
            return(int) (((((double) v) / 20.0) / 72.0) * logP);
        }


        private Size SetExtent(int width, int height) {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "setting extent to "+width.ToString()+" "+height.ToString());
            NativeMethods.tagSIZEL sz = new NativeMethods.tagSIZEL();
            sz.cx = width;
            sz.cy = height;
            bool resetExtents = !IsUserMode();
            try {
                Pixel2hiMetric(sz, sz);
                GetOleObject().SetExtent(NativeMethods.ActiveX.DVASPECT_CONTENT, sz);
            }
            catch (COMException) {
                resetExtents = true;
            }
            if (resetExtents) {
                GetOleObject().GetExtent(NativeMethods.ActiveX.DVASPECT_CONTENT, sz);
                try {
                    GetOleObject().SetExtent(NativeMethods.ActiveX.DVASPECT_CONTENT, sz);
                }
                catch (COMException e) {
                    Debug.Fail(e.ToString());
                }
            }
            return GetExtent();        
        }


        private Size GetExtent() {
            NativeMethods.tagSIZEL sz = new NativeMethods.tagSIZEL();
            GetOleObject().GetExtent(NativeMethods.ActiveX.DVASPECT_CONTENT, sz);
            HiMetric2Pixel(sz, sz);
            return new Size(sz.cx, sz.cy);
        }

        private void SetObjectRects(Rectangle bounds) {
            if (GetOcState() < OC_INPLACE) return;
            GetInPlaceObject().SetObjectRects(FillInRect(new NativeMethods.COMRECT(), bounds), GetClipRect(new NativeMethods.COMRECT()));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the bounds of this control.
        ///     User code should usually not call this function.
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            axState[handlePosRectChanged] = true;

            try {
                if (axState[fFakingWindow]) {
                    base.SetBoundsCore(x, y, width, height, specified);
                    return;
                }
                Rectangle oldBounds = Bounds;

                if (oldBounds.X == x && oldBounds.Y == y && oldBounds.Width == width &&
                    oldBounds.Height == height) {
                    return;
                }
                if (!IsHandleCreated) {
                    UpdateBounds(x, y, width, height);
                    return;
                }

                if (GetOcState() > OC_RUNNING) {
                    CheckSubclassing();
                    if (width != oldBounds.Width || height != oldBounds.Height) {
                        Size p = SetExtent(width, height);
                        width = p.Width;
                        height = p.Height;
                    }
                }
                if (axState[manualUpdate]) {
                    SetObjectRects(new Rectangle(x, y, width, height));
                    CheckSubclassing();
                    UpdateBounds();
                }
                else {
                    SetObjectRects(new Rectangle(x, y, width, height));
                    base.SetBoundsCore(x, y, width, height, specified);
                    Invalidate();
                }
            }
            finally {
                axState[handlePosRectChanged] = false;
            }
        }


        private bool CheckSubclassing() {
            if (!IsHandleCreated || wndprocAddr == IntPtr.Zero) return true;
            IntPtr handle = Handle;
            IntPtr currentWndproc = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC);
            if (currentWndproc == wndprocAddr) return true;
            if ((int)SendMessage(REGMSG_MSG, 0, 0) == REGMSG_RETVAL) {
                wndprocAddr = currentWndproc;
                return true;
            }
            // yikes, we were resubclassed...
            Debug.WriteLineIf(AxHostSwitch.TraceVerbose, "The horrible control subclassed itself w/o calling the old wndproc...");
            // we need to resubclass outselves now...
            Debug.Assert(!OwnWindow(), "why are we here if we own our window?");
            window.ReleaseHandle();
            UnsafeNativeMethods.SetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC, new HandleRef(this, currentWndproc));
            window.AssignHandle(handle, axState[assignUniqueID]);
            InformOfNewHandle();
            axState[manualUpdate] = true;
            return false;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DestroyHandle"]/*' />
        /// <devdoc>
        ///     Destroys the handle associated with this control.
        ///     User code should in general not call this function.
        /// </devdoc>
        protected override void DestroyHandle() {
            if (axState[fOwnWindow]) {
                base.DestroyHandle();
            }
            else {
                if (IsHandleCreated) {
                    TransitionDownTo(OC_RUNNING);
                }
            }
        }

        private void TransitionTo(int state) {
            if (state > GetOcState()) {
                TransitionUpTo(state);
            }
            else if (state < GetOcState()) {
                TransitionDownTo(state);
            }
        }

        private void TransitionDownTo(int state) {
            if (axState[inTransition]) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Recursively entering TransitionDownTo...");
                return;
            }

            try {
                axState[inTransition] = true;

                while (state < GetOcState()) {
                    switch (GetOcState()) {
                        case OC_OPEN:
                            Debug.Fail("how did we ever get into the open state?");
                            SetOcState(OC_UIACTIVE);
                            break;
                        case OC_UIACTIVE:
                            int hr = UiDeactivate();
                            Debug.Assert(NativeMethods.Succeeded(hr), "Failed in UiDeactivate: " + hr.ToString());
                            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose && GetOcState() == OC_INPLACE, "failed transition");
                            SetOcState(OC_INPLACE);
                            break;
                        case OC_INPLACE:
                            if (axState[fFakingWindow]) {
                                DestroyFakeWindow();
                                SetOcState(OC_RUNNING);
                            }
                            else {
                                InPlaceDeactivate();
                            }
                            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose && GetOcState() == OC_RUNNING, "failed transition");
                            SetOcState(OC_RUNNING);
                            break;
                        case OC_RUNNING:
                            StopEvents();
                            DisposeAxControl();
                            Debug.Assert(GetOcState() == OC_LOADED," failed transition");
                            SetOcState(OC_LOADED);
                            break;
                        case OC_LOADED:
                            ReleaseAxControl();
                            Debug.Assert(GetOcState() == OC_PASSIVE," failed transition");
                            SetOcState(OC_PASSIVE);
                            break;
                        default:
                            Debug.Fail("bad state");
                            SetOcState(GetOcState() - 1);
                            break;
                    }
                }
            }
            finally {
                axState[inTransition] = false;
            }
        }

        private void TransitionUpTo(int state) {
            if (axState[inTransition]) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Recursively entering TransitionUpTo...");
                return;
            }

            try {
                axState[inTransition] = true;

                while (state > GetOcState()) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Transitioning up from: " + GetOcState().ToString() + " to: " + state.ToString());
                    switch (GetOcState()) {
                        case OC_PASSIVE:
                            axState[disposed] = false;
                            GetOcxCreate();
                            Debug.Assert(GetOcState() == OC_LOADED, " failed transition");
                            SetOcState(OC_LOADED);
                            break;
                        case OC_LOADED:
                            ActivateAxControl();
                            Debug.Assert(GetOcState() == OC_RUNNING, " failed transition");
                            SetOcState(OC_RUNNING);
                            if (IsUserMode()) {
                                // start the events flowing!
                                //createSink();
                                StartEvents();
                            }
                            break;
                        case OC_RUNNING:
                            axState[ownDisposing] = false;
                            Debug.Assert(!axState[fOwnWindow], "If we are invis at runtime, we should never be going beynd OC_RUNNING");
                            if (!axState[fOwnWindow]) {
                                InPlaceActivate();

                                if (!Visible && ContainingControl != null && ContainingControl.Visible) {
                                    HideAxControl();
                                }
                                else {
                                    // if we do this in both codepaths, then we will force handle creation of the fake window
                                    // even if we don't need it...
                                    // This optimization will break, however, if:
                                    // a) the hWnd goes away on a OLEIVERB_HIDE and
                                    // b) this is a simple frame control
                                    // However, if you satisfy both of these conditions then you must be REALLY
                                    // brain dead and you don't deserve to work anyway...
                                    CreateControl(true);
                                    // if our default size is wrong for the control, let's resize ourselves...
                                    // Note: some controls haven't updated their extents at this time
                                    // (even though they got it from the DoVerb call and
                                    // also from GetWindowContext) so we don't poke in a new value.
                                    // The reason to do this at design time is that that's the only way we
                                    // can find out if the control has a default which we have to obey.
                                    if (!IsUserMode() && !axState[ocxStateSet]) {
                                        Size p = GetExtent();
                                        Rectangle b = Bounds;

                                        if ((b.Size.Equals(DefaultSize)) && (!b.Size.Equals(p))) {
                                            b.Width = p.Width;
                                            b.Height = p.Height;
                                            Bounds = b;
                                        }
                                    }
                                }
                            }
                            
                            Debug.Assert(GetOcState() == OC_INPLACE, " failed transition");
                            SetOcState(OC_INPLACE);
                            OnInPlaceActive();
                            break;
                        case OC_INPLACE:
                            DoVerb(OLEIVERB_SHOW);
                            Debug.Assert(GetOcState() == OC_UIACTIVE, " failed transition");
                            SetOcState(OC_UIACTIVE);
                            break;
                        default:
                            Debug.Fail("bad state");
                            SetOcState(GetOcState() + 1);
                            break;
                    }
                }
            }
            finally {
                axState[inTransition] = false;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnInPlaceActive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        protected virtual void OnInPlaceActive() {
        }

        private void InPlaceActivate() {
            try {
                DoVerb(OLEIVERB_INPLACEACTIVATE);
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw new TargetInvocationException(SR.GetString(SR.AXNohWnd,GetType().Name), t);
            }
            EnsureWindowPresent();
        }


        private void InPlaceDeactivate() {
            axState[ownDisposing] = true;
            ContainerControl f = ContainingControl;
            if (f != null) {
                if (f.ActiveControl == this) {
                    f.ActiveControl = null;
                }
            }

            try {
                GetInPlaceObject().InPlaceDeactivate();
            }
            catch(Exception e) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception calling InPlaceDeactivate: "+ e.ToString());
            }
        }

        private void UiActivate() {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "calling uiActivate for "+this.ToString());
            Debug.Assert(GetOcState() >= OC_INPLACE, "we have to be in place in order to ui activate...");
            Debug.Assert(CanUIActivate, "we have to be able to uiactivate");
            if (CanUIActivate) {
                DoVerb(OLEIVERB_UIACTIVATE);
            }
        }

        private void DestroyFakeWindow() {
            Debug.Assert(axState[fFakingWindow], "have to be faking it in order to destroy it...");

            // ASURT 70740: The problem seems to be that when we try to destroy the fake window,
            // we recurse in and transition the control down to OC_RUNNING. This causes the control's
            // new window to get destroyed also, and the control never shows up.
            // We now prevent this by changing our state about the fakeWindow _before_ we actually
            // destroy the window.
            //
            axState[fFakingWindow] = false;
            base.DestroyHandle();
        }

        private void EnsureWindowPresent() {
            // if the ctl didn't call showobject, we need to do it for it...
            if (!IsHandleCreated) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Naughty control didn't call showObject...");
                try {
                    ((UnsafeNativeMethods.IOleClientSite)oleSite).ShowObject();
                }
                catch (Exception) {
                    // The exception, if any was already dumped in ShowObject
                }
            }
            if (IsHandleCreated) return;

            Debug.Fail("extremely naughty ctl is refusing to give us an hWnd... giving up...");
            throw new InvalidOperationException(SR.GetString(SR.AXNohWnd,GetType().Name));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.SetVisibleCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetVisibleCore(bool value) {
            if (GetState(STATE_VISIBLE) != value) {
                bool oldVisible = Visible;
                if ((IsHandleCreated || value) && ParentInternal != null && ParentInternal.Created) {
                    if (!axState[fOwnWindow]) {
                        TransitionUpTo(OC_RUNNING);
                        if (value) {
                            if (axState[fFakingWindow]) {
                                // first we need to destroy the fake window...
                                DestroyFakeWindow();
                            }
                            // We want to avoid using SHOW since that may uiactivate us, and we don't
                            // want that...
                            if (!IsHandleCreated) {
                                // So, if we don't have a handle, we just try to create it and hope that this will make
                                // us appear...
                                try {
                                    SetExtent(Width, Height);
                                    InPlaceActivate();
                                    CreateControl(true);
                                }
                                catch (Exception) {
                                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Could not make ctl visible by using INPLACE. Will try SHOW");
                                    MakeVisibleWithShow();
                                }
                            }
                            else {
                                // if, otoh, we had a handle to begin with, we need to use show since INPLACE is just
                                // a noop...
                                MakeVisibleWithShow();
                            }
                        }
                        else {
                            Debug.Assert(!axState[fFakingWindow], "if we were visible, we could not have had a fake window...");
                            HideAxControl();
                        }
                    }
                }
                if (!value) {
                    axState[fNeedOwnWindow] = false;
                }
                if (!axState[fOwnWindow]) {
                    SetState(STATE_VISIBLE, value);
                    if (Visible != oldVisible)
                        OnVisibleChanged(EventArgs.Empty);
                }
            }
        }

        private void MakeVisibleWithShow() {
            ContainerControl f = ContainingControl;
            Control ctl = f == null ? null : f.ActiveControl;
            try {
                DoVerb(OLEIVERB_SHOW);
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw new TargetInvocationException(SR.GetString(SR.AXNohWnd,GetType().Name), t);
            }
            EnsureWindowPresent();
            CreateControl(true);
            if (f != null && f.ActiveControl != ctl) {
                f.ActiveControl = ctl;
            }
        }

        private void HideAxControl() {
            Debug.Assert(!axState[fOwnWindow], "can't own our window when hiding");
            Debug.Assert(IsHandleCreated, "gotta have a window to hide");
            Debug.Assert(GetOcState() >= OC_INPLACE, "have to be in place in order to hide.");
            
            DoVerb(OLEIVERB_HIDE);
            if (GetOcState() < OC_INPLACE) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Naughty control inplace deactivated on a hide verb...");
                Debug.Assert(!IsHandleCreated, "if we are inplace deactivated we should not have a window.");
                // all we do here is set a flag saying that we need the window to be created if
                // create handle is ever called...
                axState[fNeedOwnWindow] = true;

                // also, set the state to our "pretend oc_inplace state"
                //
                SetOcState(OC_INPLACE);
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.IsInputChar"]/*' />
        /// <devdoc>
        ///     Determines if charCode is an input character that the control
        ///     wants. This method is called during window message pre-processing to
        ///     determine whether the given input character should be pre-processed or
        ///     sent directly to the control. If isInputChar returns true, the
        ///     given character is sent directly to the control. If isInputChar
        ///     returns false, the character is pre-processed and only sent to the
        ///     control if it is not consumed by the pre-processing phase. The
        ///     pre-processing of a character includes checking whether the character
        ///     is a mnemonic of another control.
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected override bool IsInputChar(char charCode) {
            return true;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) 
        {
            return ignoreDialogKeys ? false : base.ProcessDialogKey(keyData);
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.PreProcessMessage"]/*' />
        /// <devdoc>
        ///     This method is called by the application's message loop to pre-process
        ///     input messages before they are dispatched. Possible values for the
        ///     msg.message field are WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, and WM_SYSCHAR.
        ///     If this method processes the message it must return true, in which case
        ///     the message loop will not dispatch the message.
        ///     This method should not be called directly by the user.
        ///
        ///     The keyboard processing of input keys to AxHost controls go in 3 steps inside AxHost.PreProcessMessage()
        ///
        ///    (1) Call the OCX's TranslateAccelarator. This may or may not call back into us using IOleControlSite::TranslateAccelarator()
        ///
        ///    (2) If the control completely processed this without calling us back: 
        ///         -- If this returns S_OK, then it means that the control already processed this message and we return true,
        ///            forcing us to not do any more processing or dispatch the message.
        ///         -- If this returns S_FALSE, then it means that the control wants us to dispatch the message without doing any processing on our side.
        ///
        ///    (3) If the control completely processed this by calling us back: 
        ///         -- If this returns S_OK, then it means that the control processed this message and we return true,
        ///            forcing us to not do any more processing or dispatch the message.
        ///         -- If this returns S_FALSE, then it means that the control did not process this message,
        ///            but we did, and so we should route it through our PreProcessMessage().
        /// </devdoc>
        public override bool PreProcessMessage(ref Message msg) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "AxHost.PreProcessMessage " + msg.ToString());
            
            if (IsUserMode()) {
                if (axState[siteProcessedInputKey]) {
                    // In this case, the control called the us back through the IControlSite
                    // and giving us a chance to see if we want to process it. We in turn
                    // call the base implementation which normally would call the control's
                    // IsInputKey() or IsInputChar(). So, we short-circuit those to return false
                    // and only return true, if the container-chain wanted to process the keystroke
                    // (e.g. tab, accelarators etc.)
                    //
                    return base.PreProcessMessage(ref msg);
                }

                NativeMethods.MSG win32Message = new NativeMethods.MSG();
                win32Message.message = msg.Msg;
                win32Message.wParam = msg.WParam;
                win32Message.lParam = msg.LParam;
                win32Message.hwnd = msg.HWnd;
    
                axState[siteProcessedInputKey] = false;
                try {
                    int hr = GetInPlaceActiveObject().TranslateAccelerator(ref win32Message);
                    msg.Msg = win32Message.message;
                    msg.WParam = win32Message.wParam;
                    msg.LParam = win32Message.lParam;
                    msg.HWnd = win32Message.hwnd;
    
                    //if (NativeMethods.Succeeded(hr)) {
                    if (hr == NativeMethods.S_OK) {
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "\t Message translated by control to " + msg);
                        return true;
                    }
                    else if (hr == NativeMethods.S_FALSE) {
                        bool ret = false;
                        ignoreDialogKeys = true;
                        try {
                            ret = base.PreProcessMessage(ref msg);
                        }
                        finally {
                            ignoreDialogKeys = false;
                        }
                        return ret;
                    }
                    else if (axState[siteProcessedInputKey]) {
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "\t Message processed by site. Calling base.PreProcessMessage() " + msg);
                        return base.PreProcessMessage(ref msg);
                    }
                    else {
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "\t Message not processed by site. Returning false. " + msg);
                        return false;
                    }
                }
                finally {
                    axState[siteProcessedInputKey] = false;
                }
            }
            
            return false;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ProcessMnemonic"]/*' />
        /// <devdoc>
        ///     Process a mnemonic character.
        ///     This is done by manufacturing a WM_SYSKEYDOWN message and passing it
        ///     to the ActiveX control.
        /// </devdoc>
        protected override bool ProcessMnemonic(char charCode) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "In AxHost.ProcessMnemonic: " + (int)charCode);
            if (CanSelect) {
                try {
                    NativeMethods.tagCONTROLINFO ctlInfo = new NativeMethods.tagCONTROLINFO();
                    int hr = GetOleControl().GetControlInfo(ctlInfo);
                    if (NativeMethods.Failed(hr)) {
                        return false;
                    }
                    NativeMethods.MSG msg = new NativeMethods.MSG();
                    // Sadly, we don't have a message so we must fake one ourselves...
                    // A bit of ugliness here (a bit?  more like a bucket...)
                    // The message we are faking is a WM_SYSKEYDOWN w/ the right alt key setting...
                    msg.hwnd = (ContainingControl == null) ? IntPtr.Zero : ContainingControl.Handle;
                    msg.message = NativeMethods.WM_SYSKEYDOWN;
                    msg.wParam = (IntPtr) Char.ToUpper(charCode, CultureInfo.CurrentCulture);
                    msg.lParam = (IntPtr) 0x20180001;
                    msg.time = SafeNativeMethods.GetTickCount();
                    NativeMethods.POINT p = new NativeMethods.POINT();
                    UnsafeNativeMethods.GetCursorPos(p);
                    msg.pt_x = p.x;
                    msg.pt_y = p.y;
                    if (SafeNativeMethods.IsAccelerator(new HandleRef(ctlInfo, ctlInfo.hAccel), ctlInfo.cAccel, ref msg, null)) {
                        GetOleControl().OnMnemonic(ref msg);
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "\t Processed mnemonic " + msg);
                        Focus();
                        return true;
                    }
                }
                catch (Exception t) {
                    Debug.Fail("error in processMnemonic");
                    Debug.Fail(t.ToString());
                    return false;
                }
            }
            return false;
        }

        // misc methods:

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.SetAboutBoxDelegate"]/*' />
        /// <devdoc>
        ///     Sets the delegate which will be called when the user selects the "About..."
        ///     entry on the context menu.
        /// </devdoc>
        protected void SetAboutBoxDelegate(AboutBoxDelegate d) {
            aboutBoxDelegate += d;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OcxState"]/*' />
        /// <devdoc>
        ///     Sets the persisted state of the control.
        ///     This should either be null, obtained from getOcxState, or
        ///     read from a resource.  The value of this property will
        ///     be used after the control is created but before it is
        ///     shown.
        ///     Computes the persisted state of the underlying ActiveX control and
        ///     returns it in the encapsulated State object.
        ///     If the control has been modified since it was last saved to a
        ///     persisted state, it will be asked to save itself.
        /// </devdoc>
        [
        DefaultValue(null),
        RefreshProperties(RefreshProperties.All),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public State OcxState {
            get {
                if (IsDirty() || ocxState == null) {
                    Debug.Assert(!axState[disposed], "we chould not be asking for the object when we are axState[disposed]...");
                    ocxState = CreateNewOcxState(ocxState);
                }
                return ocxState;
            }

            set {
                axState[ocxStateSet] = true;

                if (storageType != STG_UNKNOWN && storageType != value.type) {
                    Debug.Fail("Trying to reload with a OcxState that is of a different type.");
                    throw new InvalidOperationException(SR.GetString(SR.AXOcxStateLoaded));
                }
                
                if (this.ocxState == value)
                    return;
                
                this.ocxState = value;
                
                if (this.ocxState != null) {
                    this.axState[manualUpdate] = ocxState._GetManualUpdate();
                    this.licenseKey = ocxState._GetLicenseKey();
                }
                else {
                    this.axState[manualUpdate] = false;
                    this.licenseKey = null;
                }

                if (this.ocxState != null && GetOcState() >= OC_RUNNING) {
                    DepersistControl();
                }
            }
        }

        private State CreateNewOcxState(State oldOcxState) {
            NoComponentChangeEvents++;

            try {
                if (GetOcState() < OC_RUNNING) {
                    return null;
                }

                try {
                    PropertyBagStream propBag = null;

                    if (iPersistPropBag != null) {
                        propBag = new PropertyBagStream();
                        iPersistPropBag.Save(propBag, true, true);
                    }

                    MemoryStream ms = null;
                    switch (storageType) {
                        case STG_STREAM:
                        case STG_STREAMINIT:
                            ms = new MemoryStream();
                            if (storageType == STG_STREAM) {
                                iPersistStream.Save(new UnsafeNativeMethods.ComStreamFromDataStream(ms), true);
                            }
                            else {
                                iPersistStreamInit.Save(new UnsafeNativeMethods.ComStreamFromDataStream(ms), true);
                            }
                            break;
                        case STG_STORAGE:
                            Debug.Assert(oldOcxState != null, "we got to have an old state which holds out scribble storage...");
                            if (oldOcxState != null) return oldOcxState.RefreshStorage(iPersistStorage);
                            return null;
                        default:
                            Debug.Fail("unknown storage type.");
                            return null;
                    }
                    if (ms != null) {
                        return new State(ms, storageType, this, propBag);
                    }
                    else if (propBag != null) {
                        return new State(propBag);
                    }
                }
                catch (Exception e) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Could not create new OCX State: " + e.ToString());
                }
            }
            finally {
                NoComponentChangeEvents--;
            }

            return null;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ContainerControl"]/*' />
        /// <devdoc>
        ///     Returns this control's logicaly containing form.
        ///     At design time this is always the form being designed.
        ///     At runtime it is either the form set with setContainingForm or,
        ///     by default, the parent form.
        ///     Sets the form which is the logical container of this control.
        ///     By default, the parent form performs that function.  It is
        ///     however possible for another form higher in the parent chain
        ///     to serve in that role.  The logical container of this
        ///     control determines the set of logical sibling control.
        ///     In general this property exists only to enable some speficic
        ///     behaviours of ActiveX controls and should in general not be set
        ///     by the user.
        /// </devdoc>
        [
            Browsable(false),
            EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public ContainerControl ContainingControl {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();

                if (containingControl == null) {
                    containingControl = FindContainerControlInternal();
                }
                
                return containingControl;
            }

            set {
                containingControl = value;
            }
        }

        /// <devdoc>
        ///     Determines whether to persist the ContainingControl property.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool ShouldSerializeContainingControl() {
            return ContainingControl != ParentInternal;
        }

        private ContainerControl FindContainerControlInternal() {
            if (Site != null) {
                IDesignerHost host = (IDesignerHost)Site.GetService(typeof(IDesignerHost));
                if (host != null) {
                    IComponent comp = host.RootComponent;
                    if (comp != null && comp is ContainerControl) {
                        return (ContainerControl)comp;
                    }
                }
            }

            ContainerControl cc = null;
            Control control = this;
            while (control != null) {
                ContainerControl tempCC = control as ContainerControl;
                if (tempCC != null)
                    cc = tempCC;
                
                control = control.ParentInternal;
            }

            if (cc == null)
                cc = Application.GetParkingWindow(this) as ContainerControl;
            
            return cc;
        }

        private bool IsDirty() {
            if (GetOcState() < OC_RUNNING) return false;
            Debug.Assert(storageType != STG_UNKNOWN, "if we are loaded, out storage type must be set!");

            if (axState[valueChanged]) {
                axState[valueChanged] = false;
                return true;
            }

#if DEBUG
            if (AxAlwaysSaveSwitch.Enabled) return true;
#endif
            int hr = NativeMethods.E_FAIL;
            switch (storageType) {
                case STG_STREAM:
                    hr = iPersistStream.IsDirty();
                    break;
                case STG_STREAMINIT:
                    hr = iPersistStreamInit.IsDirty();
                    break;
                case STG_STORAGE:
                    hr = iPersistStorage.IsDirty();
                    break;
                default:
                    Debug.Fail("unknown storage type");
                    return true;
            }
            if (hr == NativeMethods.S_FALSE) {
                // NOTE: This was a note from the old AxHost codebase. The problem
                // with doing this is that the some controls that do not run in
                // unlicensed mode (e.g. ProtoView ScheduleX pvtaskpad.ocx) will 
                // always return S_FALSE to disallow design-time support.

                // Sadly, some controls lie and never say that they are dirty...
                // SO, we don't believe them unless they told us that they were
                // dirty at least once...
                return false;
            }
            else if (NativeMethods.Failed(hr)) {
                return true;
            }
            return true;
        }

        internal bool IsUserMode() {
            ISite site = Site;
            return site == null || !site.DesignMode;
        }

        private Object GetAmbientProperty(int dispid) {

            Control richParent = ParentInternal;

            switch (dispid) {
                case NativeMethods.ActiveX.DISPID_AMBIENT_USERMODE:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for usermode");
                    return IsUserMode();
                case NativeMethods.ActiveX.DISPID_AMBIENT_AUTOCLIP:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for autoclip");
                    return true;
                case NativeMethods.ActiveX.DISPID_AMBIENT_MESSAGEREFLECT:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for message reflect");
                    return true;
                case NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for uidead");
                    return false;
                case NativeMethods.ActiveX.DISPID_AMBIENT_DISPLAYASDEFAULT:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for displayasdefault");
                    return false;
                case NativeMethods.ActiveX.DISPID_AMBIENT_FONT:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for font");
                    if (richParent != null) {
                        return GetIFontFromFont(richParent.Font);
                    }
                    return null;
                case NativeMethods.ActiveX.DISPID_AMBIENT_SHOWGRABHANDLES:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for showGrabHandles");
                    return false;
                case NativeMethods.ActiveX.DISPID_AMBIENT_SHOWHATCHING:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for showHatching");
                    return false;
                case NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR:
                    if (richParent != null) {
                        return GetOleColorFromColor(richParent.BackColor);
                    }
                    return null;
                case NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR:
                    if (richParent != null) {
                        return GetOleColorFromColor(richParent.ForeColor);
                    }
                    return null;
                case NativeMethods.ActiveX.DISPID_AMBIENT_DISPLAYNAME:
                    string rval = GetParentContainer().GetNameForControl(this);
                    if (rval == null) rval = "";
                    return rval;
                case NativeMethods.ActiveX.DISPID_AMBIENT_LOCALEID:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for localeid");
                    return Thread.CurrentThread.CurrentCulture.LCID;
                case NativeMethods.ActiveX.DISPID_AMBIENT_RIGHTTOLEFT:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "asked for right to left");
                    Control ctl = this;
                    while (ctl != null) {
                        if (ctl.RightToLeft == System.Windows.Forms.RightToLeft.No)
                            return false;
                        if (ctl.RightToLeft == System.Windows.Forms.RightToLeft.Yes)
                            return true;
                        if (ctl.RightToLeft == System.Windows.Forms.RightToLeft.Inherit)
                            ctl = ctl.Parent;
                    }
                    return null;
                default:
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "unsupported ambient "+dispid.ToString());
                    return null;
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DoVerb"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DoVerb(int verb) {
            GetOleObject().DoVerb(verb, IntPtr.Zero, oleSite, -1, ParentInternal.Handle, FillInRect(new NativeMethods.COMRECT(), Bounds));
        }

        private bool AwaitingDefreezing() {
            return freezeCount > 0;
        }

        private void Freeze(bool v) {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "freezing "+v.ToString());
            if (v) {
                try {
                    GetOleControl().FreezeEvents(-1);
                }
                catch (COMException t) {
                    Debug.Fail(t.ToString());
                }
                freezeCount ++;
            }
            else {
                try {
                    GetOleControl().FreezeEvents(0);
                }
                catch (COMException t) {
                    Debug.Fail(t.ToString());
                }
                freezeCount --;
            }
            Debug.Assert(freezeCount >=0, "invalid freeze count!");
        }

        private int UiDeactivate() {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "calling uiDeactivate for "+this.ToString());
            bool ownDispose = this.axState[ownDisposing];
            this.axState[ownDisposing] = true;
            int hr = 0;
            try {
                hr = GetInPlaceObject().UIDeactivate();
            }
            finally {
                this.axState[ownDisposing] = ownDispose;
            }
            return hr;
        }

        private int GetOcState() {
            return ocState;
        }

        private void SetOcState(int nv) {
            ocState = nv;
        }

        private string GetLicenseKey() {
            if (licenseKey != null || !axState[needLicenseKey]) {
                return licenseKey;
            }

            try {
                UnsafeNativeMethods.IClassFactory2 icf2 = UnsafeNativeMethods.CoGetClassObject(ref this.clsid, INPROC_SERVER, 0, ref icf2_Guid);
                NativeMethods.tagLICINFO licInfo = new NativeMethods.tagLICINFO();
                icf2.GetLicInfo(licInfo);
                if (licInfo.fRuntimeAvailable != 0) {
                    string[] rval = new string[1];
                    icf2.RequestLicKey(0, rval);
                    licenseKey = rval[0];
                    return licenseKey;
                }
            }
            catch (COMException e) {
                if (e.ErrorCode == E_NOINTERFACE.ErrorCode) return null;
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to get the license key: " + e.ToString());
                axState[needLicenseKey] = false;
            }
            catch (Exception t) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to get the license key: " + t.ToString());
                axState[needLicenseKey] = false;
            }
            return null;
        }

        private void CreateWithoutLicense() {
            object ret = null;
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Creating object without license: " + clsid.ToString());
            ret = UnsafeNativeMethods.CoCreateInstance(ref clsid, null, INPROC_SERVER, ref NativeMethods.ActiveX.IID_IUnknown);
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\t" + (ret != null).ToString());
            instance = ret;
        }

        private void CreateWithLicense(string license) {
            if (license != null) {
                try {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Creating object with license: " + clsid.ToString());
                    UnsafeNativeMethods.IClassFactory2 icf2 = UnsafeNativeMethods.CoGetClassObject(ref clsid, INPROC_SERVER, 0, ref icf2_Guid);
                    
                    if (icf2 != null) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\tClassFactory" + (icf2 != null).ToString());
                        icf2.CreateInstanceLic(null, null, ref NativeMethods.ActiveX.IID_IUnknown, license, out instance);
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\t" + (instance != null).ToString());
                    }
                }
                catch (Exception t) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to create with license: " + t.ToString());
                }
            }
            
            if (instance == null) {
                CreateWithoutLicense();
            }
        }

        private void CreateInstance() {
            Debug.Assert(instance == null, "instance must be null");
            //Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "before created "+Windows.GetCurrentThreadId());
            //Debug.WriteStackTraceIf("AxHTrace");
            //checkThreadingModel();
            try {
                if (IsUserMode()) {
                    CreateWithLicense(licenseKey);
                }
                else {
                    CreateWithoutLicense();
                }
                Debug.Assert(instance != null, "w/o an exception being thrown we must have an object...");
            }
            catch (ExternalException e) {
                if (e.ErrorCode == unchecked((int)0x80040112)) { // CLASS_E_NOTLICENSED
                    throw new LicenseException(GetType(), this, SR.GetString(SR.AXNoLicenseToUse));
                }
                throw e;
            }

            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "created");
            SetOcState(OC_LOADED);
        }

        private CategoryAttribute GetCategoryForDispid(int dispid) {
            NativeMethods.ICategorizeProperties icp = GetCategorizeProperties();
            if (icp == null) return null;
            CategoryAttribute rval = null;
            int propcat = 0;
            try {
                icp.MapPropertyToCategory(dispid, ref propcat);
                if (propcat != 0) {
                    int cat = -propcat;
                    if (cat > 0 && cat < categoryNames.Length && categoryNames[cat] != null) {
                        return categoryNames[cat];
                    }
                    cat = - cat;
                    Int32 key = cat;
                    if (objectDefinedCategoryNames != null) {
                        rval = (CategoryAttribute) objectDefinedCategoryNames[key];
                        if (rval != null) return rval;
                    }
                    
                    string name = null;
                    int hr = icp.GetCategoryName(cat, SafeNativeMethods.GetUserDefaultLCID(), out name);
                    if (hr == NativeMethods.S_OK && name != null) {
                        rval = new CategoryAttribute(name);
                        if (objectDefinedCategoryNames == null) {
                            objectDefinedCategoryNames = new Hashtable();
                        }
                        objectDefinedCategoryNames.Add(key, rval);
                        return rval;
                    }
                }
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
            }
            return null;
        }

        private void SetSelectionStyle(int selectionStyle) {
            if (!this.IsUserMode()) {
                // selectionStyle can be 0 (not selected), 1 (selected) or 2 (active)
                Debug.Assert(selectionStyle >= 0 && selectionStyle <= 2, "Invalid selection style");

                ISelectionService iss = GetSelectionService();
                this.selectionStyle = selectionStyle;
                if (iss != null && iss.GetComponentSelected(this)) {
                    // The AX Host designer will offer an extender property called "SelectionStyle" 
                    // 
                    PropertyDescriptor prop = TypeDescriptor.GetProperties(this)["SelectionStyle"];
                    if (prop != null && prop.PropertyType == typeof(int)) {
                        prop.SetValue(this, selectionStyle);
                    }
                }
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.InvokeEditMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void InvokeEditMode() {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "invoking EditMode for "+this.ToString());
            Debug.Assert((flags & AxFlags.PreventEditMode) == 0, "edit mode should have been disabled");
            if (editMode != EDITM_NONE) return;
            AddSelectionHandler();
            editMode = EDITM_HOST;
            SetSelectionStyle(2);
            IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
            try {
                UiActivate();
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
            }
            // It so happens that some controls don't get focus in this case, so
            // we have got to force it onto them...
            //         int hwndFocusNow = NativeMethods.GetFocus();
            //         Windows.SetFocus(getHandle());
            //         while (hwndFocusNow != getHandle()) {
            //             if (hwndFocusNow == 0) {
            //                 break;
            //             }
            //             hwndFocusNow = Windows.GetParent(hwndFocusNow);
            //         }
        }

        //
        // ICustomTypeDescriptor implementation.
        //

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            if (!axState[editorRefresh] && HasPropertyPages()) {
                axState[editorRefresh] = true;
                TypeDescriptor.Refresh(this.GetType());
            }
            return TypeDescriptor.GetAttributes(this, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetClassName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the class name for this object.  If null is returned,
        /// the type name is used.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        string ICustomTypeDescriptor.GetClassName() {
            return null;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetComponentName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the name for this object.  If null is returned,
        /// the default is used.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetConverter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the type converter for this object.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetDefaultEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return TypeDescriptor.GetDefaultEvent(this, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetDefaultProperty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
            return TypeDescriptor.GetDefaultProperty(this, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetEditor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the an editor for this object.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        Object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            if (editorBaseType != typeof(ComponentEditor))
                return null;
            
            if (editor != null)
                return editor;

            if (editor == null && HasPropertyPages())
                editor = new AxComponentEditor();
            
            return editor;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetEvents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return TypeDescriptor.GetEvents(this, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ICustomTypeDescriptor.GetEvents(Attribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return TypeDescriptor.GetEvents(this, attributes, true);
        }

        private void OnIdle(object sender, EventArgs e) {
            if (axState[refreshProperties]) {
                TypeDescriptor.Refresh(this.GetType());
            }
        }

        private bool RefreshAllProperties {
            get {
                return axState[refreshProperties];
            }
            set {
                axState[refreshProperties] = value;
                if (value && !axState[listeningToIdle]) {
                    Application.Idle += new EventHandler(this.OnIdle);
                    axState[listeningToIdle] = true;
                }
                else if (!value && axState[listeningToIdle]) {
                    Application.Idle -= new EventHandler(this.OnIdle);
                    axState[listeningToIdle] = false;
                }
            }
        }

        private PropertyDescriptorCollection FillProperties(Attribute[] attributes) {
            if (RefreshAllProperties) {
                RefreshAllProperties = false;
                propsStash = null;
                attribsStash = null;
            }
            else if (propsStash != null) {
                if (attributes == null && attribsStash == null) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Returning stashed values for : " + "<null>");
                    return propsStash;
                }
                else if (attributes != null && attribsStash != null && attributes.Length == attribsStash.Length) {
                    bool attribsEqual = true;
                    int i = 0;
                    foreach(Attribute attrib in attributes) {
                        if (!attrib.Equals(attribsStash[i++])) {
                            attribsEqual = false;
                            break;
                        }
                    }

                    if (attribsEqual) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Returning stashed values for : " + attributes.Length);
                        return propsStash;
                    }
                }
            }

            ArrayList retProps = new ArrayList();

            if (properties == null)
                properties = new Hashtable();

            if (propertyInfos == null) {
                propertyInfos = new Hashtable();

                PropertyInfo[] propInfos = this.GetType().GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance);

                foreach(PropertyInfo propInfo in propInfos)
                    propertyInfos.Add(propInfo.Name, propInfo);
            }

            PropertyDescriptorCollection baseProps = TypeDescriptor.GetProperties(this, null, true);
            if (baseProps != null) {
                for (int i = 0; i < baseProps.Count; ++i) {
                    Debug.Assert(baseProps[i] != null, "Null base prop at location: " + i.ToString());

                    if (baseProps[i].DesignTimeOnly) {
                        retProps.Add(baseProps[i]);
                        continue;
                    }

                    string propName = baseProps[i].Name;
                    PropertyDescriptor prop = null;
                    PropertyInfo propInfo = (PropertyInfo)propertyInfos[propName];

                    // We do not support "write-only" properties that some activex controls support.
                    if (propInfo != null && !propInfo.CanRead)
                        continue;

                    if (!properties.ContainsKey(propName)) {
                        if (propInfo != null) {
                            Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Added AxPropertyDescriptor for: " + propName);
                            prop = new AxPropertyDescriptor(baseProps[i], this);
                            ((AxPropertyDescriptor)prop).UpdateAttributes();
                        }
                        else {
                            Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Added PropertyDescriptor for: " + propName);
                            prop = baseProps[i];
                        }
                        properties.Add(propName, prop);
                        retProps.Add(prop);
                    }
                    else {
                        PropertyDescriptor propDesc = (PropertyDescriptor)properties[propName];
                        Debug.Assert(propDesc != null, "Cannot find cached entry for: " + propName);
                        if ((propInfo == null && propDesc is AxPropertyDescriptor) || (propInfo != null && !(propDesc is AxPropertyDescriptor))) {
                            Debug.Fail("Duplicate property with same name: " + propName);
                            Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Duplicate property with same name: " + propName);
                        }
                        else {
                            if (propDesc is AxPropertyDescriptor)
                                ((AxPropertyDescriptor)propDesc).UpdateAttributes();
                            retProps.Add(propDesc);
                        }
                    }
                }

                // Filter only the Browsable attribute, since that is the only
                // one we mess with.
                //
                if (attributes != null) {
                    Attribute browse = null;
                    foreach(Attribute attr in attributes) {
                        if (attr is BrowsableAttribute) {
                            browse = attr;
                        }
                    }

                    if (browse != null) {
                        ArrayList removeList = null;

                        foreach(PropertyDescriptor prop in retProps) {
                            if (prop is AxPropertyDescriptor) {
                                Attribute attr = prop.Attributes[typeof(BrowsableAttribute)];
                                if (attr != null && !attr.Equals(browse)) {
                                    if (removeList == null) {
                                        removeList = new ArrayList();
                                    }
                                    removeList.Add(prop);
                                }
                            }
                        }

                        if (removeList != null) {
                            foreach(object prop in removeList)
                                retProps.Remove(prop);
                        }
                    }
                }
            }

            PropertyDescriptor[] temp = new PropertyDescriptor[retProps.Count];
            retProps.CopyTo(temp, 0);
            
            // Update our stashed values.
            //
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Updating stashed values for : " + ((attributes != null) ? attributes.Length.ToString() : "<null>"));
            propsStash = new PropertyDescriptorCollection(temp);
            attribsStash = attributes;
            
            return propsStash;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
            return FillProperties(null);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetProperties1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            return FillProperties(attributes);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        Object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }

        private AxPropertyDescriptor GetPropertyDescriptorFromDispid(int dispid) {
            Debug.Assert(dispid != NativeMethods.ActiveX.DISPID_UNKNOWN, "Wrong dispid sent to GetPropertyDescriptorFromDispid");

            PropertyDescriptorCollection props = FillProperties(null);
            foreach (PropertyDescriptor prop in props) {
                if (prop is AxPropertyDescriptor) {
                    AxPropertyDescriptor axprop = (AxPropertyDescriptor)prop;
                    if (axprop.Dispid == dispid)
                        return axprop;
                }
            }

            return null;
        }

        private void CheckThreadingModel() {
#if DEBUG
            if (AxIgnoreTMSwitch.Enabled) return;
#endif
            if ((flags & AxFlags.IgnoreThreadModel) != 0) return;
            
            bool singleThreaded = true;

            new RegistryPermission(PermissionState.Unrestricted).Assert();
            try {
                try {
                    using (RegistryKey rk = Registry.ClassesRoot.OpenSubKey("CLSID\\" + clsid.ToString() + "\\InprocServer32", /*writable*/false)) {
                        object value = rk.GetValue("ThreadingModel");

                        if (value != null && value is string) {
                            if (value.Equals("Both") 
                                || value.Equals("Apartment") 
                                || value.Equals("Free")) {

                                singleThreaded = false;
                            }
                        }
                    }
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    throw new InvalidOperationException(SR.GetString(SR.AXNoThreadInfo));
                }
            }
            finally {
                System.Security.CodeAccessPermission.RevertAssert();
            }

            if (singleThreaded) {
                throw new InvalidOperationException(SR.GetString(SR.AXSingleThreaded));
            }
        }

        private void ActivateAxControl() {
            if (QuickActivate()) {
                DepersistControl();
            }
            else {
                SlowActivate();
            }

            SetOcState(OC_RUNNING);
        }


        private void DepersistFromIPropertyBag(UnsafeNativeMethods.IPropertyBag propBag) {
            iPersistPropBag.Load(propBag, null);
        }

        private void DepersistFromIStream(UnsafeNativeMethods.IStream istream) {
            storageType = STG_STREAM;
            iPersistStream.Load(istream);
        }

        private void DepersistFromIStreamInit(UnsafeNativeMethods.IStream istream) {
            storageType = STG_STREAMINIT;
            iPersistStreamInit.Load(istream);
        }

        private void DepersistFromIStorage(UnsafeNativeMethods.IStorage storage) {
            storageType = STG_STORAGE;

            // ASURT 65913 Looks like MapPoint control does not create a valid IStorage
            // until some property has changed. Since we end up creating a bogus (empty)
            // storage, we end up not being able to re-create a valid one and this would
            // fail.
            //
            if (storage != null) {
                int hr = iPersistStorage.Load(storage);
                if (hr != NativeMethods.S_OK) Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Error trying load depersist from IStorage: " + hr);
            }
        }

        private void DepersistControl() {
            Freeze(true);

            if (ocxState == null) {
                // must init new:
                //
                if (instance is UnsafeNativeMethods.IPersistStreamInit) {
                    iPersistStreamInit = (UnsafeNativeMethods.IPersistStreamInit) instance;
                    try {
                        storageType = STG_STREAMINIT;
                        iPersistStreamInit.InitNew();
                    }
                    catch (Exception e1) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistStreamInit.InitNew(). Is this good?"  + e1.ToString());
                    }
                    return;
                }
                if (instance is UnsafeNativeMethods.IPersistStream) {
                    storageType = STG_STREAM;
                    iPersistStream = (UnsafeNativeMethods.IPersistStream) instance;
                    return;
                }
                if (instance is UnsafeNativeMethods.IPersistStorage) {
                    storageType = STG_STORAGE;
                    ocxState = new State(this);
                    iPersistStorage = (UnsafeNativeMethods.IPersistStorage) instance;
                    try {
                        iPersistStorage.InitNew(ocxState.GetStorage());
                    }
                    catch (Exception e2) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistStorage.InitNew(). Is this good?"  + e2.ToString());
                    }
                    return;
                }
                if (instance is UnsafeNativeMethods.IPersistPropertyBag) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, this + " supports IPersistPropertyBag.");
                    iPersistPropBag = (UnsafeNativeMethods.IPersistPropertyBag) instance;
                    try {
                        iPersistPropBag.InitNew();
                    }
                    catch (Exception e1) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistPropertyBag.InitNew(). Is this good?"  + e1.ToString());
                    }
                }
                
                Debug.Fail("no implemented persitance interfaces on object");
                throw new InvalidOperationException(SR.GetString(SR.UnableToInitComponent));
            }
            
            // Otherwise, we have state to deperist from:
            switch (ocxState.Type) {
                case STG_STREAM:
                    try {
                        iPersistStream = (UnsafeNativeMethods.IPersistStream) instance;
                        DepersistFromIStream(ocxState.GetStream());
                    }
                    catch (Exception e) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistStream.DepersistFromIStream(). Is this good?"  + e.ToString());
                    }
                    break;
                case STG_STREAMINIT:
                    if (instance is UnsafeNativeMethods.IPersistStreamInit) {
                        try {
                            iPersistStreamInit = (UnsafeNativeMethods.IPersistStreamInit) instance;
                            DepersistFromIStreamInit(ocxState.GetStream());
                        }
                        catch (Exception e) {
                            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistStreamInit.DepersistFromIStreamInit(). Is this good?"  + e.ToString());
                        }
                        GetControlEnabled();
                    }
                    else {
                        ocxState.Type = STG_STREAM;
                        DepersistControl();
                        return;
                    }
                    break;
                case STG_STORAGE:
                    try {
                        iPersistStorage = (UnsafeNativeMethods.IPersistStorage) instance;
                        DepersistFromIStorage(ocxState.GetStorage());
                    }
                    catch (Exception e) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistStorage.DepersistFromIStorage(). Is this good?"  + e.ToString());
                    }
                    break;
                default:
                    Debug.Fail("unknown storage type.");
                    throw new InvalidOperationException(SR.GetString(SR.UnableToInitComponent));
            }
        
            if (ocxState.GetPropBag() != null) {
                try {
                    iPersistPropBag = (UnsafeNativeMethods.IPersistPropertyBag)instance;
                    DepersistFromIPropertyBag(ocxState.GetPropBag());
                }
                catch (Exception e) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Exception thrown trying to IPersistPropertyBag.DepersistFromIPropertyBag(). Is this good?"  + e.ToString());
                }
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetOcx"]/*' />
        /// <devdoc>
        ///     Returns the IUnknown pointer to the enclosed ActiveX control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public object GetOcx() {
            return instance;
        }

        private Object GetOcxCreate() {
            if (instance == null) {
                CreateInstance();
                RealizeStyles();
                AttachInterfaces();
                oleSite.OnOcxCreate();
            }
            return instance;
        }

        private void StartEvents() {
            if (!axState[sinkAttached]) {
                try {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Creating sink for events...");
                    CreateSink();
                    oleSite.StartEvents();
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                }
                axState[sinkAttached] = true;
            }
        }

        private void StopEvents() {
            if (axState[sinkAttached]) {
                try {
                    DetachSink();
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                }
                axState[sinkAttached] = false;
            }
            oleSite.StopEvents();
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.CreateSink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void CreateSink() {
            lock(this) {
                // nop...  windows forms wrapper will override...
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.DetachSink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void DetachSink() {
            lock(this) {
                // nop...  windows forms wrapper will override...
            }
        }


        private bool CanShowPropertyPages() {
            if (GetOcState() < OC_RUNNING) return false;
            return(GetOcx() is NativeMethods.ISpecifyPropertyPages);
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.HasPropertyPages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HasPropertyPages() {
            if (!CanShowPropertyPages()) return false;
            NativeMethods.ISpecifyPropertyPages ispp = (NativeMethods.ISpecifyPropertyPages) GetOcx();
            try {
                NativeMethods.tagCAUUID uuids = new NativeMethods.tagCAUUID();
                try {
                    ispp.GetPages(uuids);
                    if (uuids.cElems > 0) return true;
                }
                finally {
                    if (uuids.pElems != IntPtr.Zero) {
                        Marshal.FreeCoTaskMem(uuids.pElems);
                    }
                }
            }
            catch (Exception) {
            }
            return false;
        }

        unsafe private void ShowPropertyPageForDispid(int dispid, Guid guid) {
            try {
                IntPtr pUnk = Marshal.GetIUnknownForObject(GetOcx());
                UnsafeNativeMethods.OCPFIPARAMS opcparams = new UnsafeNativeMethods.OCPFIPARAMS();
                opcparams.hwndOwner = (ContainingControl == null) ? IntPtr.Zero : ContainingControl.Handle;
                opcparams.lpszCaption = Name;
                opcparams.ppUnk = (IntPtr) (long) &pUnk;
                opcparams.uuid = (IntPtr)(int) &guid;
                opcparams.dispidInitial = dispid;
                UnsafeNativeMethods.OleCreatePropertyFrameIndirect(opcparams);
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw t;
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.MakeDirty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void MakeDirty() {
            ISite isite = Site;
            if (isite == null)
                return;
            
            IComponentChangeService ccs = (IComponentChangeService)isite.GetService(typeof(IComponentChangeService));
            if (ccs == null)
                return;
            
            ccs.OnComponentChanging(this, null);
            
            ccs.OnComponentChanged(this, null, null, null);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ShowPropertyPages"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ShowPropertyPages() {
            if (ParentInternal == null) return;
            if (!ParentInternal.IsHandleCreated) return;
            ShowPropertyPages(ParentInternal);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ShowPropertyPages1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ShowPropertyPages(Control control) {
            try {
                if (!CanShowPropertyPages()) return;
                NativeMethods.ISpecifyPropertyPages ispp = (NativeMethods.ISpecifyPropertyPages) GetOcx();
                NativeMethods.tagCAUUID uuids = new NativeMethods.tagCAUUID();
                try {
                    ispp.GetPages(uuids);
                    if (uuids.cElems <= 0) return;
                }
                catch (Exception) {
                    return;
                }

                // State oldOcxState = OcxState;

                IDesignerHost host = null;
                if (Site != null)
                    host = (IDesignerHost)Site.GetService(typeof(IDesignerHost));
                
                DesignerTransaction trans = null;
                try {
                    if (host != null)
                        trans = host.CreateTransaction(SR.GetString(SR.AXEditProperties));

                    string name = null;
                    object o = GetOcx();
                    IntPtr handle = (ContainingControl == null) ? IntPtr.Zero : ContainingControl.Handle;
                    SafeNativeMethods.OleCreatePropertyFrame(new HandleRef(this, handle), 0, 0, name, 1, ref o, uuids.cElems, new HandleRef(null, uuids.pElems), Application.CurrentCulture.LCID, 0, IntPtr.Zero);
                }
                finally {
                    if (oleSite != null)
                        ((UnsafeNativeMethods.IPropertyNotifySink)oleSite).OnChanged(NativeMethods.MEMBERID_NIL);

                    if (trans != null)
                        trans.Commit();

                    if (uuids.pElems != IntPtr.Zero)
                        Marshal.FreeCoTaskMem(uuids.pElems);
                }
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw t;
            }
        }

        internal override IntPtr InitializeDCForWmCtlColor(IntPtr dc, int msg) {
            if (isMaskEdit) {
                return base.InitializeDCForWmCtlColor(dc, msg);
            }
            else {
                return IntPtr.Zero; // bypass Control's anti-reflect logic
            }
        }
        
        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.WndProc"]/*' />
        /// <devdoc>
        ///     AxHost wndProc. All messages are sent to wndProc after getting filtered
        ///     through the preProcessMessage function.
        ///     Certain messages are forwarder directly to the ActiveX control,
        ///     others are first processed by the wndProc of Control
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if (false && (axState[manualUpdate] && IsUserMode())) {
                DefWndProc(ref m);
                return;
            }

            switch (m.Msg) {
                // Things we explicitly ignore and pass to the ocx's windproc
                case NativeMethods.WM_ERASEBKGND:
                
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFYFORMAT:

                case NativeMethods.WM_SETCURSOR:
                case NativeMethods.WM_SYSCOLORCHANGE:

                // Some of the MSComCtl controls respond to this message
                // to do some custom painting. So, we should just pass this message
                // through.
                //
                case NativeMethods.WM_DRAWITEM:
                
                case NativeMethods.WM_LBUTTONDBLCLK:
                case NativeMethods.WM_LBUTTONUP:
                case NativeMethods.WM_MBUTTONDBLCLK:
                case NativeMethods.WM_MBUTTONUP:
                case NativeMethods.WM_RBUTTONDBLCLK:
                case NativeMethods.WM_RBUTTONUP:
                    DefWndProc(ref m);
                    break;

                case NativeMethods.WM_LBUTTONDOWN:
                case NativeMethods.WM_MBUTTONDOWN:
                case NativeMethods.WM_RBUTTONDOWN:
                    if (IsUserMode()) {
                        Focus();
                    }
                    DefWndProc(ref m);
                    break;

                case NativeMethods.WM_KILLFOCUS:
                {
                    hwndFocus = (IntPtr)m.WParam;
                    try {
                        base.WndProc(ref m);
                    }
                    finally {
                         hwndFocus = IntPtr.Zero;
                    }
                    break;    
                }

                case NativeMethods.WM_COMMAND:
                    if (!ReflectMessageInternal(m.LParam, ref m))
                        DefWndProc(ref m);
                    break;
                
                case NativeMethods.WM_CONTEXTMENU:
                    DefWndProc(ref m);
                    break;

                case NativeMethods.WM_DESTROY:
#if DEBUG
                    if (!OwnWindow()) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "WM_DESTROY naughty control is destroying the window from under us..." + GetType().ToString());
                    }
#endif
                    bool visible = GetState(STATE_VISIBLE);

                    TransitionDownTo(OC_RUNNING);
                    DetachAndForward(ref m);

                    if (visible != GetState(STATE_VISIBLE)) {
                        SetState(STATE_VISIBLE, visible);
                    }

                    break;
                case NativeMethods.WM_HELP:
                    // We want to both fire the event, and let the ocx have the message...
                    base.WndProc(ref m);
                    DefWndProc(ref m);
                    break;

                case NativeMethods.WM_KEYUP:
                    if (axState[processingKeyUp])
                        break;
                    
                    axState[processingKeyUp] = true;
                    try {
                        if (!PreProcessMessage(ref m))
                            DefWndProc(ref m);
                    }
                    finally {
                        axState[processingKeyUp] = false;
                    }

                    break;

                case NativeMethods.WM_NCDESTROY:
#if DEBUG
                    if (!OwnWindow()) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "WM_NCDESTROY naughty control is destroying the window from under us..." + GetType().ToString());
                    }
#endif
                    // need to detach it now...
                    DetachAndForward(ref m);
                    break;

                default:
                    if (m.Msg == REGMSG_MSG) {
                        m.Result = (IntPtr)REGMSG_RETVAL;
                        return;
                    }
                    // Other things we may care about and we will pass them to the Control's wndProc
                    base.WndProc(ref m);
                    break;
            }
        }

        private void DetachAndForward(ref Message m) {
            IntPtr handle = GetHandleNoCreate();
            DetachWindow();
            if (handle != IntPtr.Zero) {
                IntPtr wndProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC);
                m.Result = UnsafeNativeMethods.CallWindowProc(wndProc, handle, m.Msg, m.WParam, m.LParam);
            }
        }

        private void DetachWindow() {
            if (IsHandleCreated) {
                OnHandleDestroyed(EventArgs.Empty);
                for (Control c = this; c != null; c = c.ParentInternal) {
                    /* NOT NEEDED
                    if (c.GetAxState(STATE_HANDLEHOOK)) {
                        ((IHandleHook)c.Site.GetService(IHandleHook.class)).OnDestroyHandle(GetHandle());
                        break;
                    }
                    */
                }
                window.ReleaseHandle();
            }
        }

        private void InformOfNewHandle() {
            Debug.Assert(IsHandleCreated, "we got to have a handle to be here...");
            for (Control c = this; c != null; c = c.ParentInternal) {
                /* NOT NEEDED
                if (c.GetAxState(STATE_HANDLEHOOK)) {
                    ((IHandleHook)c.Site.GetService(IHandleHook.class)).OnCreateHandle(GetHandle());
                    break;
                }
                */
            }
            wndprocAddr = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_WNDPROC);
            /* NOT NEEDED
            SetAxState(STATE_CREATENOTIFIED, true);
            */
        }

        private void AttachWindow(IntPtr hwnd) {
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "attaching window for "+this.ToString()+" "+hwnd.ToString());
            if (!axState[fFakingWindow]) {
                window.AssignHandle(hwnd, axState[assignUniqueID]);
            }
            UpdateZOrder();

            // Get the latest bounds set by the user.
            Size setExtent = Size;
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "SetBounds " + setExtent.ToString());

            // Get the default bounds set by the ActiveX control.
            UpdateBounds();
            Size ocxExtent = GetExtent();
            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "OcxBounds " + ocxExtent.ToString());

            Point location = Location;

            // Choose the setBounds unless it is smaller than the default bounds.
            if (setExtent.Width < ocxExtent.Width || setExtent.Height < ocxExtent.Height)
                Bounds = new Rectangle(location.X, location.Y, ocxExtent.Width, ocxExtent.Height);
            else {
                Size newSize = SetExtent(setExtent.Width, setExtent.Height);
                if (!newSize.Equals(setExtent)) {
                    Bounds = new Rectangle(location.X, location.Y, newSize.Width, newSize.Height);
                }
            }

            OnHandleCreated(EventArgs.Empty);
            InformOfNewHandle();
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to find out when the
        ///     handle has been created.
        ///     Call base.OnHandleCreated first.
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            // ASURT 43741 This is needed to prevent some controls (for e.g. Office Web Components) from 
            // failing to InPlaceActivate() when they call RegisterDragDrop() but do not call 
            // OleInitialize(). The EE calls CoInitializeEx() on the thread, but I believe
            // that is not good enough for DragDrop.
            //
            if (Application.OleRequired() != System.Threading.ApartmentState.STA) {
                throw new ThreadStateException(SR.GetString(SR.ThreadMustBeSTA));
            }

            SetAcceptDrops(AllowDrop);
            RaiseCreateHandleEvent(e);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ClsidAttribute"]/*' />
        [AttributeUsage(AttributeTargets.Class, Inherited = false)] 
        public sealed class ClsidAttribute : Attribute {
            private String val;

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ClsidAttribute.ClsidAttribute"]/*' />
            public ClsidAttribute(String clsid) {
                val = clsid;
            }
            
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ClsidAttribute.Value"]/*' />
            public String Value {
                get {
                    return val;
                }       
            }
        }       

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="TypeLibraryTimeStampAttribute"]/*' />
        [AttributeUsage(AttributeTargets.Assembly, Inherited = false)] 
        public sealed class TypeLibraryTimeStampAttribute : Attribute {
            private DateTime val;

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxImporter.TypeLibraryTimeStampAttribute.TypeLibraryTimeStampAttribute"]/*' />
            public TypeLibraryTimeStampAttribute(string timestamp) {
                val = DateTime.Parse(timestamp);
            }
            
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxImporter.TypeLibraryTimeStampAttribute.Value"]/*' />
            public DateTime Value {
                get {
                    return val;
                }
            }   
        }       

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ConnectionPointCookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(false)]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class ConnectionPointCookie {
            private UnsafeNativeMethods.IConnectionPoint connectionPoint;
            private int cookie;

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ConnectionPointCookie.ConnectionPointCookie"]/*' />
            /// <devdoc>
            /// Creates a connection point to of the given interface type.
            /// which will call on a managed code sink that implements that interface.
            /// </devdoc>
            public ConnectionPointCookie(object source, object sink, Type eventInterface) {
                Exception ex = null;
                if (source is UnsafeNativeMethods.IConnectionPointContainer) {
                    UnsafeNativeMethods.IConnectionPointContainer cpc = (UnsafeNativeMethods.IConnectionPointContainer)source;

                    try {
                        Guid tmp = eventInterface.GUID;
                        connectionPoint = cpc.FindConnectionPoint(ref tmp);
                    }
                    catch (Exception) {
                        connectionPoint = null;
                    }

                    if (connectionPoint == null) {
                        ex = new ArgumentException(SR.GetString(SR.AXNoEventInterface, eventInterface.Name));
                    }
                    else if (sink == null || !eventInterface.IsInstanceOfType(sink)) {
                        ex = new InvalidCastException(SR.GetString(SR.AXNoSinkImplementation, eventInterface.Name));
                    }
                    else {
                        int hr = connectionPoint.Advise(sink, ref cookie);
                        if (hr != NativeMethods.S_OK) {
                            cookie = 0;
                            Marshal.ReleaseComObject(connectionPoint);
                            connectionPoint = null;
                            ex = new InvalidOperationException(String.Format(SR.GetString(SR.AXNoSinkAdvise, eventInterface.Name), hr));
                        }
                    }
                }
                else {
                    ex = new InvalidCastException(SR.GetString(SR.AXNoConnectionPointContainer));
                }


                if (connectionPoint == null || cookie == 0) {
                    if (connectionPoint != null) {
                        Marshal.ReleaseComObject(connectionPoint);
                    }

                    if (ex == null) {
                        throw new ArgumentException(SR.GetString(SR.AXNoConnectionPoint, eventInterface.Name));
                    }
                    else {
                        throw ex;
                    }
                }
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ConnectionPointCookie.Disconnect"]/*' />
            /// <devdoc>
            /// Disconnect the current connection point.  If the object is not connected,
            /// this method will do nothing.
            /// </devdoc>
            public void Disconnect() {
                if (connectionPoint != null && cookie != 0) {
                    connectionPoint.Unadvise(cookie);
                    cookie = 0;

                    System.Runtime.InteropServices.Marshal.ReleaseComObject(connectionPoint);
                    connectionPoint = null;
                }
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.ConnectionPointCookie.Finalize"]/*' />
            /// <internalonly/>
            ~ConnectionPointCookie(){
                Disconnect();
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="ActiveXInvokeKind"]/*' />
        public enum ActiveXInvokeKind {
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="ActiveXInvokeKind.MethodInvoke"]/*' />
            MethodInvoke,
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="ActiveXInvokeKind.PropertyGet"]/*' />
            PropertyGet,
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="ActiveXInvokeKind.PropertySet"]/*' />
            PropertySet
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="InvalidActiveXStateException"]/*' />
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class InvalidActiveXStateException : Exception {
            private string name;
            private ActiveXInvokeKind kind;
            
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="InvalidActiveXStateException.InvalidActiveXStateException"]/*' />
            public InvalidActiveXStateException(string name, ActiveXInvokeKind kind) {
                this.name = name;
                this.kind = kind;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="InvalidActiveXStateException.ToString"]/*' />
            public override string ToString() {
                switch (kind) {
                    case ActiveXInvokeKind.MethodInvoke:
                        return SR.GetString(SR.AXInvalidMethodInvoke, name);
                    case ActiveXInvokeKind.PropertyGet:
                        return SR.GetString(SR.AXInvalidPropertyGet, name);
                    case ActiveXInvokeKind.PropertySet:
                        return SR.GetString(SR.AXInvalidPropertySet, name);
                    default:
                        return base.ToString();
                }
            }
        }
        
        // This private class encapsulates all of the ole interfaces so that users
        // will not be able to access and call them directly...

        /// <devdoc>
        /// </devdoc>
        private class OleInterfaces
            : UnsafeNativeMethods.IOleControlSite, UnsafeNativeMethods.IOleClientSite, UnsafeNativeMethods.IOleInPlaceSite, UnsafeNativeMethods.ISimpleFrameSite, UnsafeNativeMethods.IVBGetControl, UnsafeNativeMethods.IGetVBAObject, UnsafeNativeMethods.IPropertyNotifySink, IReflect {

            private AxHost host;
            private ConnectionPointCookie connectionPoint;

            internal OleInterfaces(AxHost host) {
                if (host == null)
                    throw new ArgumentNullException("host");
                this.host = host;
            }

            ~OleInterfaces() {
                StopEvents();
            }

            internal AxHost GetAxHost() {
                return host;
            }

            internal void OnOcxCreate() {
                StartEvents();
            }

            internal void StartEvents() {
                if (connectionPoint != null)
                    return;

                Object nativeObject = host.GetOcx();

                try {
                    connectionPoint = new ConnectionPointCookie(nativeObject, this, typeof(UnsafeNativeMethods.IPropertyNotifySink));
                }
                catch (Exception) {
                }
            }

            internal void StopEvents() {
                if (connectionPoint != null) {
                    connectionPoint.Disconnect();
                    connectionPoint = null;
                }
            }

            // IGetVBAObject methods:

            int UnsafeNativeMethods.IGetVBAObject.GetObject(ref Guid riid, UnsafeNativeMethods.IVBFormat[] rval, int dwReserved) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetObject");
                
                if (rval == null || riid.Equals(Guid.Empty))
                    return NativeMethods.E_INVALIDARG;
                
                if (riid.Equals(ivbformat_Guid)) {
                    rval[0] = new VBFormat();
                    return NativeMethods.S_OK;
                }
                else {
                    rval[0] = null;
                    return NativeMethods.E_NOINTERFACE;
                }
            }

            // IVBGetControl methods:

            int UnsafeNativeMethods.IVBGetControl.EnumControls(int dwOleContF, int dwWhich, out UnsafeNativeMethods.IEnumUnknown ppenum) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in EnumControls");
                ppenum = null;
                ppenum = host.GetParentContainer().EnumControls(host, dwOleContF, dwWhich);
                return NativeMethods.S_OK;
            }

            // ISimpleFrameSite methods:

            int UnsafeNativeMethods.ISimpleFrameSite.PreMessageFilter(IntPtr hwnd, int msg, IntPtr wp, IntPtr lp, ref IntPtr plResult, ref int pdwCookie) {
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.ISimpleFrameSite.PostMessageFilter(IntPtr hwnd, int msg, IntPtr wp, IntPtr lp, ref IntPtr plResult, int dwCookie) {
                return NativeMethods.S_FALSE;
            }

            // IReflect methods:

            MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr,Binder binder, Type[] types,ParameterModifier[] modifiers) {
                return null;
            }

            MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr) {
                return null;
            }

            MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
                return new MethodInfo[0];
            }

            FieldInfo IReflect.GetField(String name, BindingFlags bindingAttr) {
                return null;
            }

            FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
                return new FieldInfo[0];
            }

            PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr) {
                return null;
            }

            PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
                return null;
            }

            PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
                return new PropertyInfo[0];
            }

            MemberInfo[] IReflect.GetMember(String name, BindingFlags bindingAttr) {
                return new MemberInfo[0];
            }

            MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
                return new MemberInfo[0];
            }

            Object IReflect.InvokeMember(String name, BindingFlags invokeAttr, Binder binder,
                                                    Object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters) {
                if (name.StartsWith("[DISPID=")) {
                    int endIndex = name.IndexOf("]");
                    int dispid = Int32.Parse(name.Substring(8, endIndex - 8));
                    object ambient = host.GetAmbientProperty(dispid);
                    if (ambient != null) return ambient;
                }

                throw E_FAIL;
            }

            Type IReflect.UnderlyingSystemType {
                get {
                    return null;
                }
            }   

            // IOleControlSite methods:


            int UnsafeNativeMethods.IOleControlSite.OnControlInfoChanged() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnControlInfoChanged");
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleControlSite.LockInPlaceActive(int fLock) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in LockInPlaceActive");
                return NativeMethods.E_NOTIMPL;
            }

            int UnsafeNativeMethods.IOleControlSite.GetExtendedControl(out object ppDisp) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetExtendedControl " + host.ToString());
                ppDisp = host.GetParentContainer().GetProxyForControl(host);
                if (ppDisp == null)
                    return NativeMethods.E_NOTIMPL;

                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleControlSite.TransformCoords(NativeMethods._POINTL pPtlHimetric, NativeMethods.tagPOINTF pPtfContainer, int dwFlags) {
                int hr = SetupLogPixels(false);
                if (NativeMethods.Failed(hr))
                    return hr;

                if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_HIMETRICTOCONTAINER)  != 0) {
                    if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_SIZE) != 0) {
                        pPtfContainer.x = (float) host.HM2Pix(pPtlHimetric.x, logPixelsX);
                        pPtfContainer.y = (float) host.HM2Pix(pPtlHimetric.y, logPixelsY);
                    }
                    else if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_POSITION) != 0) {
                        pPtfContainer.x = (float) host.HM2Pix(pPtlHimetric.x, logPixelsX);
                        pPtfContainer.y = (float) host.HM2Pix(pPtlHimetric.y, logPixelsY);
                    }
                    else {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose,"\t dwFlags not supported: " + dwFlags);
                        return NativeMethods.E_INVALIDARG;
                    }
                }
                else if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_CONTAINERTOHIMETRIC) != 0) {
                    if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_SIZE) != 0) {
                        pPtlHimetric.x = host.Pix2HM((int)pPtfContainer.x, logPixelsX);
                        pPtlHimetric.y = host.Pix2HM((int)pPtfContainer.y, logPixelsY);
                    }
                    else if ((dwFlags & NativeMethods.ActiveX.XFORMCOORDS_POSITION) != 0) {
                        pPtlHimetric.x = host.Pix2HM((int)pPtfContainer.x, logPixelsX);
                        pPtlHimetric.y = host.Pix2HM((int)pPtfContainer.y, logPixelsY);
                    }
                    else {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\t dwFlags not supported: " + dwFlags);
                        return NativeMethods.E_INVALIDARG;
                    }
                }
                else {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\t dwFlags not supported: " + dwFlags);
                    return NativeMethods.E_INVALIDARG;
                }

                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleControlSite.TranslateAccelerator(ref NativeMethods.MSG pMsg, int grfModifiers) {
                Debug.Assert(!host.GetAxState(AxHost.siteProcessedInputKey), "Re-entering UnsafeNativeMethods.IOleControlSite.TranslateAccelerator!!!");
                host.SetAxState(AxHost.siteProcessedInputKey, true);

                Message msg = new Message();
                msg.Msg = pMsg.message;
                msg.WParam = pMsg.wParam;
                msg.LParam = pMsg.lParam;
                msg.HWnd = pMsg.hwnd;
                
                try {
                    bool f = ((Control)host).PreProcessMessage(ref msg);
                    return f ? NativeMethods.S_OK : NativeMethods.S_FALSE;
                }
                finally {
                    host.SetAxState(AxHost.siteProcessedInputKey, false);
                }
            }

            int UnsafeNativeMethods.IOleControlSite.OnFocus(int fGotFocus) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnFocus " + ((fGotFocus == 0) ? "lost" : "gained"));
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleControlSite.ShowPropertyFrame() {
                if (host.CanShowPropertyPages()) {
                    host.ShowPropertyPages();
                    return NativeMethods.S_OK;
                }
                return NativeMethods.E_NOTIMPL;
            }

            // IOleClientSite methods:

            int UnsafeNativeMethods.IOleClientSite.SaveObject() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in SaveObject");
                return NativeMethods.E_NOTIMPL;
            }

            int UnsafeNativeMethods.IOleClientSite.GetMoniker(int dwAssign, int dwWhichMoniker, out Object moniker) {
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetMoniker");
                moniker = null;
                return NativeMethods.E_NOTIMPL;
            }

            UnsafeNativeMethods.IOleContainer UnsafeNativeMethods.IOleClientSite.GetContainer() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getContainer");
                return host.GetParentContainer();
            }


            int UnsafeNativeMethods.IOleClientSite.ShowObject() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in ShowObject");
                if (host.GetAxState(AxHost.fOwnWindow)) {
                    Debug.Fail("we can't be in showobject if we own our window...");
                    return NativeMethods.S_OK;
                }
                if (host.GetAxState(AxHost.fFakingWindow)) {
                    // we really should not be here...
                    // this means that the ctl inplace deactivated and didn't call on inplace activate before calling showobject
                    // so we need to destroy our fake window first...
                    host.DestroyFakeWindow();

                    // ASURT 46393
                    // The fact that we have a fake window means that the OCX inplace deactivated when we hid it. It means
                    // that we have to bring it back from RUNNING to INPLACE so that it can re-create its handle properly.
                    //
                    host.TransitionDownTo(OC_LOADED);
                    host.TransitionUpTo(OC_INPLACE);
                }
                if (host.GetOcState() < OC_INPLACE)
                    return NativeMethods.S_OK;

                IntPtr hwnd;
                if (NativeMethods.Succeeded(host.GetInPlaceObject().GetWindow(out hwnd))) {
                    if (host.GetHandleNoCreate() != hwnd) {
                        host.DetachWindow();
                        if (hwnd != IntPtr.Zero) {
                            host.AttachWindow(hwnd);
                        }
                    }
                }
                else if (host.GetInPlaceObject() is UnsafeNativeMethods.IOleInPlaceObjectWindowless) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Windowless control.");
                    throw new InvalidOperationException(SR.GetString(SR.AXWindowlessControl));
                }

                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleClientSite.OnShowWindow(int fShow) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnShowWindow");
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleClientSite.RequestNewObjectLayout() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in RequestNewObjectLayout");
                return NativeMethods.E_NOTIMPL;
            }

            // IOleInPlaceSite methods:

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.OleInterfaces.GetWindow"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            IntPtr UnsafeNativeMethods.IOleInPlaceSite.GetWindow() {
                try {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetWindow");
                    return host.ParentInternal.Handle;
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    throw t;
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceSite.ContextSensitiveHelp(int fEnterMode) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in ContextSensitiveHelp");
                return NativeMethods.E_NOTIMPL;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.CanInPlaceActivate() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in CanInPlaceActivate");
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceActivate() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnInPlaceActivate");
                host.SetAxState(AxHost.ownDisposing, false);
                host.SetAxState(AxHost.rejectSelection, false);
                host.SetOcState(OC_INPLACE);
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.OnUIActivate() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnUIActivate for " + host.ToString());
                host.SetOcState(OC_UIACTIVE);
                host.GetParentContainer().OnUIActivate(host);
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext(out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc,
                                                 NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) {
                ppDoc = null;
                ppFrame = host.GetParentContainer();
                FillInRect(lprcPosRect, host.Bounds);
                host.GetClipRect(lprcClipRect);
                if (lpFrameInfo != null) {
                    lpFrameInfo.cb = Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
                    lpFrameInfo.fMDIApp = 0;
                    lpFrameInfo.hAccel = IntPtr.Zero;
                    lpFrameInfo.cAccelEntries = 0;
                    lpFrameInfo.hwndFrame = host.ParentInternal.Handle;
                }
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.Scroll(NativeMethods.tagSIZE scrollExtant) {
                try {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in Scroll");
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    throw t;
                }
                return(NativeMethods.S_FALSE);
            }

            int UnsafeNativeMethods.IOleInPlaceSite.OnUIDeactivate(int fUndoable) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnUIDeactivate for " + host.ToString());
                host.GetParentContainer().OnUIDeactivate(host);
                if (host.GetOcState() > OC_INPLACE) {
                    host.SetOcState(OC_INPLACE);
                }
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceDeactivate() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnInPlaceDeactivate");
                if (host.GetOcState() == OC_UIACTIVE) {
                    ((UnsafeNativeMethods.IOleInPlaceSite)this).OnUIDeactivate(0);
                }

                host.GetParentContainer().OnInPlaceDeactivate(host);
                host.DetachWindow();
                host.SetOcState(OC_RUNNING);
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.DiscardUndoState() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in DiscardUndoState");
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IOleInPlaceSite.DeactivateAndUndo() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in DeactivateAndUndo for "+host.ToString());
                return host.GetInPlaceObject().UIDeactivate();
            }

            int UnsafeNativeMethods.IOleInPlaceSite.OnPosRectChange(NativeMethods.COMRECT lprcPosRect) {
                // ASURT 68752
                // The MediaPlayer control has a AllowChangeDisplaySize property that users
                // can set to control size changes at runtime, but the control itself ignores that and sets the new size.
                // We prevent this by not allowing controls to call OnPosRectChange(), unless we instantiated the resize.
                // visual basic6 does the same.
                //
                bool useRect = true;
                if (AxHost.windowsMediaPlayer_Clsid.Equals(host.clsid))
                    useRect = host.GetAxState(AxHost.handlePosRectChanged);
                
                if (useRect) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnPosRectChange" + lprcPosRect.ToString());
                    host.GetInPlaceObject().SetObjectRects(lprcPosRect, host.GetClipRect(new NativeMethods.COMRECT()));
                    host.MakeDirty();
                }
                else {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Control directly called OnPosRectChange... ignoring the new size");
                }
                return NativeMethods.S_OK;
            }

            // IPropertyNotifySink methods

            void UnsafeNativeMethods.IPropertyNotifySink.OnChanged(int dispid) {
                // Some controls fire OnChanged() notifications when getting values of some properties. ASURT 20190.
                // To prevent this kind of recursion, we check to see if we are already inside a OnChanged() call.
                //
                if (host.NoComponentChangeEvents != 0)
                    return;

                host.NoComponentChangeEvents++;
                try {
                    AxPropertyDescriptor prop = null;

                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnChanged");

                    if (dispid != NativeMethods.ActiveX.DISPID_UNKNOWN) {
                        prop = host.GetPropertyDescriptorFromDispid(dispid);
                        if (prop != null) {
                            prop.OnValueChanged(this.host);
                            if (!prop.SettingValue) {
                                prop.UpdateTypeConverterAndTypeEditor(true, dispid);
                            }   
                        }
                    }
	            else {
                        // update them all for DISPID_UNKNOWN.
                        //
                        PropertyDescriptorCollection props = ((ICustomTypeDescriptor)host).GetProperties();
                        foreach(PropertyDescriptor p in props) {
                            prop = p as AxPropertyDescriptor;
                            if (prop != null && !prop.SettingValue) {
                                prop.UpdateTypeConverterAndTypeEditor(true, prop.Dispid);
                            }   
                        }
                     }

                    ISite site = host.Site;
                    if (site != null) {
                        IComponentChangeService changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));

                        if (changeService != null) {
                            try {
                                changeService.OnComponentChanging(host, prop);
                            }
                            catch (CheckoutException coEx) {
                                if (coEx == CheckoutException.Canceled) {
                                    return;
                                }
                                throw coEx;
                            }

                            // Now notify the change service that the change was successful.
                            //
                            changeService.OnComponentChanged(host, prop, null, ((prop != null) ? prop.GetValue(host) : null));
                        }
                    }
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    throw t;
                }
                finally {
                    host.NoComponentChangeEvents--;
                }
            }

            int UnsafeNativeMethods.IPropertyNotifySink.OnRequestEdit(int dispid) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in OnRequestEdit for "+host.ToString());
                return NativeMethods.S_OK;
            }
        }

        private const int HMperInch = 2540;
        private int Pix2HM(int pix, int logP) {
            return(HMperInch * pix + ( logP >> 1)) / logP;
        }

        private int HM2Pix(int hm, int logP) {
            return(logP * hm + HMperInch / 2) / HMperInch;
        }

        private bool QuickActivate() {
            if (!(instance is UnsafeNativeMethods.IQuickActivate)) return false;
            UnsafeNativeMethods.IQuickActivate iqa = (UnsafeNativeMethods.IQuickActivate) instance;

            UnsafeNativeMethods.tagQACONTAINER qaContainer = new UnsafeNativeMethods.tagQACONTAINER();
            UnsafeNativeMethods.tagQACONTROL qaControl = new UnsafeNativeMethods.tagQACONTROL();

            qaContainer.pClientSite = oleSite;
            qaContainer.pPropertyNotifySink = oleSite;
            //         qaContainer.pControlSite = oleSite;
            //         qaContainer.pAdviseSink = null;
            //         qaContainer.pUnkEventSink = null;
            //         qaContainer.pUndoMgr = null;
            //         qaContainer.pBindHost = null;
            //         qaContainer.pServiveProvider = null;
            //         qaContainer.hpal = 0;
            qaContainer.pFont = GetIFontFromFont(GetParentContainer().parent.Font);
            qaContainer.dwAppearance = 0;
            qaContainer.lcid = Application.CurrentCulture.LCID;

            Control p = ParentInternal;

            if (p != null) {
                qaContainer.colorFore = GetOleColorFromColor(p.ForeColor);
                qaContainer.colorBack = GetOleColorFromColor(p.BackColor);
            }
            else {
                qaContainer.colorFore = GetOleColorFromColor(SystemColors.WindowText);
                qaContainer.colorBack = GetOleColorFromColor(SystemColors.Window);
            }
            qaContainer.dwAmbientFlags = NativeMethods.ActiveX.QACONTAINER_AUTOCLIP | NativeMethods.ActiveX.QACONTAINER_MESSAGEREFLECT |
                                         NativeMethods.ActiveX.QACONTAINER_SUPPORTSMNEMONICS;
            if (IsUserMode()) {
                qaContainer.dwAmbientFlags |= NativeMethods.ActiveX.QACONTAINER_USERMODE;
            }
            else {
                // Can't set ui dead becuase MFC controls return NOWHERE on NCHITTEST which
                // messes up the designer...
                // But, without this the FarPoint SpreadSheet and the Office SpreadSheet 
                // controls take keyboard input at design time.
                //qaContainer.dwAmbientFlags |= NativeMethods.ActiveX.QACONTAINER_UIDEAD;
                // qaContainer.dwAmbientFlags |= ActiveX.QACONTAINER_SHOWHATCHING;
            }

            try {
                iqa.QuickActivate(qaContainer, qaControl);
            }
            catch (Exception t) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to QuickActivate: " + t.ToString());
                DisposeAxControl();
                return false;
            }
            miscStatusBits = qaControl.dwMiscStatus;
            ParseMiscBits(miscStatusBits);
            return true;
        }

        internal override void DisposeAxControls() {
            axState[rejectSelection] = true;
            base.DisposeAxControls();
            TransitionDownTo(OC_PASSIVE);
        }


        private bool GetControlEnabled() {
            try {
                return IsHandleCreated;
            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                return true;
            }
        }

        internal override bool CanSelectCore() {
            if (!GetControlEnabled() || axState[rejectSelection]) return false;
            return base.CanSelectCore();
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.Dispose"]/*' />
        /// <devdoc>
        ///     Frees all resources assocaited with this control. This method may not be
        ///     called at runtime. Any resources used by the control should be setup to
        ///     be released when the control is garbage collected. Inheriting classes should always
        ///     call base.dispose.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                TransitionDownTo(OC_PASSIVE);
            }
            base.Dispose(disposing);
        }

        private bool GetSiteOwnsDeactivation() {
            return axState[ownDisposing];
        }

        private void DisposeAxControl() {
            if (GetParentContainer() != null) {
                GetParentContainer().RemoveControl(this);
            }
            TransitionDownTo(OC_RUNNING);
            if (GetOcState() == OC_RUNNING) {
                GetOleObject().SetClientSite(null);
                SetOcState(OC_LOADED);
            }
        }

        private void ReleaseAxControl() {
            // This line is like a bit of magic...
            // sometimes, we crash with it on,
            // sometimes, with it off...
            // Lately, I have decided to leave it on...
            // (oh, yes, and the crashes seemed to disappear...)
            //cpr: ComLib.Release(instance);

            this.NoComponentChangeEvents++;

            try {
                if (instance != null) {
                    Marshal.ReleaseComObject(instance);
                    instance = null;
                }

                if (iOleInPlaceObject != null) {
                    Marshal.ReleaseComObject(iOleInPlaceObject);
                    iOleInPlaceObject = null;
                }

                if (iOleObject != null) {
                    Marshal.ReleaseComObject(iOleObject);
                    iOleObject = null;
                }

                if (iOleControl != null) {
                    Marshal.ReleaseComObject(iOleControl);
                    iOleControl = null;
                }

                if (iOleInPlaceActiveObject != null) {
                    Marshal.ReleaseComObject(iOleInPlaceActiveObject);
                    iOleInPlaceActiveObject = null;
                }

                if (iPerPropertyBrowsing != null) {
                    Marshal.ReleaseComObject(iPerPropertyBrowsing);
                    iPerPropertyBrowsing = null;
                }

                if (iCategorizeProperties != null) {
                    Marshal.ReleaseComObject(iCategorizeProperties);
                    iCategorizeProperties = null;
                }

                axState[checkedIppb] = false;
                axState[checkedCP] = false;
                axState[disposed] = true;

                if (iPersistStream != null) {
                    Marshal.ReleaseComObject(iPersistStream);
                    iPersistStream = null;
                }

                if (iPersistStreamInit != null) {
                    Marshal.ReleaseComObject(iPersistStreamInit);
                    iPersistStreamInit = null;
                }

                if (iPersistStorage != null) {
                    Marshal.ReleaseComObject(iPersistStorage);
                    iPersistStorage = null;
                }

                freezeCount = 0;
                axState[sinkAttached] = false;
                wndprocAddr = IntPtr.Zero;

                SetOcState(OC_PASSIVE);
            }
            finally {
                this.NoComponentChangeEvents--;
            }

            Application.CollectAllGarbage();
        }

        private void ParseMiscBits(int bits) {
            axState[fOwnWindow] = ((bits & NativeMethods.ActiveX.OLEMISC_INVISIBLEATRUNTIME) != 0) && IsUserMode();
            axState[fSimpleFrame] = ((bits & NativeMethods.ActiveX.OLEMISC_SIMPLEFRAME) != 0);
        }

        private void SlowActivate() {

            bool setClientSite = false;

            if ((miscStatusBits & NativeMethods.ActiveX.OLEMISC_SETCLIENTSITEFIRST) != 0) {
                GetOleObject().SetClientSite(oleSite);
                setClientSite = true;
            }

            DepersistControl();

            if (!setClientSite) {
                GetOleObject().SetClientSite(oleSite);
            }
        }


        private static NativeMethods.COMRECT FillInRect(NativeMethods.COMRECT dest, Rectangle source) {
            dest.left = source.X;
            dest.top = source.Y;
            dest.right = source.Width + source.X;
            dest.bottom = source.Height + source.Y;
            return dest;
        }

        private AxContainer GetParentContainer() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
            IntSecurity.GetParent.Demand();

            if (container == null) {
                container = AxContainer.FindContainerForControl(this);
            }
            if (container == null) {
                ContainerControl f = ContainingControl;
                if (f == null) {
                    Debug.Fail(SR.GetString(SR.AXNoTopLevelContainerControl, this.GetType().FullName));
                    throw new InvalidOperationException(SR.GetString(SR.AXNoTopLevelContainerControl, this.GetType().FullName));
                }
                else {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "calling upon "+f.ToString()+" to create a container");
                    container = f.CreateAxContainer();
                    container.AddControl(this);
                    containingControl = f;
                }
            }
            return container;
        }

        private UnsafeNativeMethods.IOleControl GetOleControl() {
            if (iOleControl == null) {
                Debug.Assert(instance != null, "must have the ocx");
                iOleControl = (UnsafeNativeMethods.IOleControl) instance;
            }
            return iOleControl;
        }

        private UnsafeNativeMethods.IOleInPlaceActiveObject GetInPlaceActiveObject() {
            if (iOleInPlaceActiveObject == null) {
                Debug.Assert(instance != null, "must have the ocx");
                iOleInPlaceActiveObject = (UnsafeNativeMethods.IOleInPlaceActiveObject) instance;
            }
            return iOleInPlaceActiveObject;
        }

        private UnsafeNativeMethods.IOleObject GetOleObject() {
            if (iOleObject == null) {
                Debug.Assert(instance != null, "must have the ocx");
                iOleObject = (UnsafeNativeMethods.IOleObject) instance;
            }
            return iOleObject;
        }

        private UnsafeNativeMethods.IOleInPlaceObject GetInPlaceObject() {
            if (iOleInPlaceObject == null) {
                Debug.Assert(instance != null, "must have the ocx");
                iOleInPlaceObject = (UnsafeNativeMethods.IOleInPlaceObject) instance;
                
#if DEBUG
                if (iOleInPlaceObject is UnsafeNativeMethods.IOleInPlaceObjectWindowless)
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, GetType().FullName + " Can also be a Windowless control.");
#endif //DEBUG
            }
            return iOleInPlaceObject;
        }

        private NativeMethods.ICategorizeProperties GetCategorizeProperties() {
            if (iCategorizeProperties == null && !axState[checkedCP] && instance != null) {
                axState[checkedCP] = true;
                if (instance is NativeMethods.ICategorizeProperties) {
                    iCategorizeProperties = (NativeMethods.ICategorizeProperties) instance;
                }
            }
            return iCategorizeProperties;
        }

        private NativeMethods.IPerPropertyBrowsing GetPerPropertyBrowsing() {
            if (iPerPropertyBrowsing == null && !axState[checkedIppb] && instance != null) {
                axState[checkedIppb] = true;
                if (instance is NativeMethods.IPerPropertyBrowsing) {
                    iPerPropertyBrowsing = (NativeMethods.IPerPropertyBrowsing) instance;
                }
            }
            return iPerPropertyBrowsing;
        }


        // Mapping functions:

        private static IntPtr CopyPalette(IntPtr hPal) {
            if (hPal == IntPtr.Zero) return IntPtr.Zero;
            int[] nEntries = new int[1];
            UnsafeNativeMethods.GetObject(new HandleRef(null, hPal), 4, nEntries);
            IntPtr memory = Marshal.AllocHGlobal(nEntries[0] * 4 + 8);
            IntPtr ret = IntPtr.Zero;

            try {
                Marshal.WriteInt32(memory, 0, 0x300);
                Marshal.WriteInt32(memory, 4, nEntries[0]);
                SafeNativeMethods.GetPaletteEntries(new HandleRef(null, hPal), 0, nEntries[0], (IntPtr)((long)memory + 8));
                ret = SafeNativeMethods.CreatePalette(new HandleRef(null, memory));
            }
            finally {
                Marshal.FreeHGlobal(memory);
            }
            return ret;
        }

        private static Object GetPICTDESCFromPicture(Image image) {
            Object obj = null;
            if (image is Bitmap) {
                obj = new NativeMethods.PICTDESCbmp((Bitmap)image);
            }
                        /*gpr            else if (image is Icon) {
                            obj = new PICTDESCicon((Icon)image);
                        }
                 */
            else if (image is Metafile) {
                obj = new NativeMethods.PICTDESCemf((Metafile)image);
            }
            if (obj == null) {
                throw new ArgumentException(SR.GetString(SR.AXUnknownImage), "image");
            }
            return obj;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetIPictureFromPicture"]/*' />
        /// <devdoc>
        ///     Maps from a System.Drawing.Image to an OLE IPicture
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static object GetIPictureFromPicture(Image image) {
            if (image == null) return null;
            Object pictdesc = GetPICTDESCFromPicture(image);
            return SafeNativeMethods.OleCreateIPictureIndirect(pictdesc, ref ipicture_Guid, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetIPictureFromCursor"]/*' />
        /// <devdoc>
        ///     Maps from a System.Drawing.Cursor to an OLE IPicture
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static object GetIPictureFromCursor(Cursor cursor) {
            if (cursor == null) return null;
            NativeMethods.PICTDESCicon pictdesc = new NativeMethods.PICTDESCicon(Icon.FromHandle(cursor.Handle));
            return SafeNativeMethods.OleCreateIPictureIndirect(pictdesc, ref ipicture_Guid, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetIPictureDispFromPicture"]/*' />
        /// <devdoc>
        ///     Maps from a System.Drawing.Image to an OLE IPictureDisp
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static object GetIPictureDispFromPicture(Image image) {
            if (image == null) return null;
            Object pictdesc = GetPICTDESCFromPicture(image);
            return SafeNativeMethods.OleCreateIPictureDispIndirect(pictdesc, ref ipictureDisp_Guid, true);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetPictureFromIPicture"]/*' />
        /// <devdoc>
        ///     Maps from an OLE IPicture to a System.Drawing.Image
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static Image GetPictureFromIPicture(object picture) {
            if (picture == null) return null;
            IntPtr hPal = IntPtr.Zero;
            SafeNativeMethods.IPicture pict = (SafeNativeMethods.IPicture)picture;
            int type = pict.GetPictureType();
            if (type == NativeMethods.Ole.PICTYPE_BITMAP) {
                try {
                    hPal = pict.GetHPal();
                }
                catch (COMException) {
                }
            }
            return GetPictureFromParams(pict, pict.GetHandle(), type, hPal, pict.GetWidth(), pict.GetHeight());
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetPictureFromIPictureDisp"]/*' />
        /// <devdoc>
        ///     Maps from an OLE IPictureDisp to a System.Drawing.Image
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static Image GetPictureFromIPictureDisp(object picture) {
            if (picture == null) return null;
            IntPtr hPal = IntPtr.Zero;
            SafeNativeMethods.IPictureDisp pict = (SafeNativeMethods.IPictureDisp)picture;
            int type = pict.PictureType;
            if (type == NativeMethods.Ole.PICTYPE_BITMAP) {
                try {
                    hPal = pict.HPal;
                }
                catch (COMException) {
                }
            }
            return GetPictureFromParams(pict, pict.Handle, type, hPal, pict.Width, pict.Height);
        }

        private static Image GetPictureFromParams(object pict, IntPtr handle, int type, IntPtr paletteHandle, int width, int height) {
            switch (type) {
                case NativeMethods.Ole.PICTYPE_ICON:
                    return(Image)(Icon.FromHandle(handle)).Clone();
                case NativeMethods.Ole.PICTYPE_METAFILE:
                    WmfPlaceableFileHeader header = new WmfPlaceableFileHeader();
                    header.BboxRight = (short)width;
                    header.BboxBottom = (short)height;
                    return(Image)(new Metafile(handle, header, false)).Clone();
                case NativeMethods.Ole.PICTYPE_ENHMETAFILE:
                    return(Image)(new Metafile(handle, false)).Clone();
                case NativeMethods.Ole.PICTYPE_BITMAP:
                    return Image.FromHbitmap(handle, paletteHandle);
                case NativeMethods.Ole.PICTYPE_NONE:
                    // MSDN sez this should not be a valid value, but comctl32 returns it...
                    return null;
                case NativeMethods.Ole.PICTYPE_UNINITIALIZED:
                    return null;
                default:
                    Debug.Fail("Invalid image type "+ type.ToString());
                    throw new ArgumentException(SR.GetString(SR.AXUnknownImage), "type");
            }
        }

        private static NativeMethods.FONTDESC GetFONTDESCFromFont(Font font) {
            NativeMethods.FONTDESC fdesc = null;

            if (fontTable == null) {
                fontTable = new Hashtable();
            }
            else {
                fdesc = (NativeMethods.FONTDESC)fontTable[font];
            }

            if (fdesc == null) {
                fdesc = new NativeMethods.FONTDESC();
                fdesc.lpstrName = font.Name;
                fdesc.cySize = (long)(font.SizeInPoints * 10000);
                NativeMethods.LOGFONT logfont = new NativeMethods.LOGFONT();
                font.ToLogFont(logfont);
                fdesc.sWeight = (short) logfont.lfWeight;
                fdesc.sCharset = logfont.lfCharSet;
                fdesc.fItalic = font.Italic;
                fdesc.fUnderline = font.Underline;
                fdesc.fStrikethrough = font.Strikeout;

                fontTable[font] = fdesc;
            }

            return fdesc;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetColorFromOleColor"]/*' />
        /// <devdoc>
        ///     Maps from an OLE COLOR to a System.Drawing.Color
        /// </devdoc>
        [CLSCompliantAttribute(false)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static Color GetColorFromOleColor(uint color) {
            return ColorTranslator.FromOle((int)color);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetOleColorFromColor"]/*' />
        /// <devdoc>
        ///     Maps from an System.Drawing.Color to an OLE COLOR
        /// </devdoc>
        [CLSCompliantAttribute(false)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static uint GetOleColorFromColor(Color color) {
            return (uint)ColorTranslator.ToOle(color);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetIFontFromFont"]/*' />
        /// <devdoc>
        ///     Maps from a System.Drawing.Font object to an OLE IFont
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static object GetIFontFromFont(Font font) {
            if (font == null) return null;

            if (font.Unit != GraphicsUnit.Point)
                throw new ArgumentException(SR.GetString(SR.AXFontUnitNotPoint), "font");

            try {
                return (SafeNativeMethods.IFont)SafeNativeMethods.OleCreateIFontIndirect(GetFONTDESCFromFont(font), ref ifont_Guid);
            }
            catch (Exception) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to create IFrom from font: " + font.ToString());
                return null;
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetFontFromIFont"]/*' />
        /// <devdoc>
        ///     Maps from an OLE IFont to a System.Drawing.Font object
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static Font GetFontFromIFont(object font) {
            if (font == null) return null;

            SafeNativeMethods.IFont oleFont = (SafeNativeMethods.IFont)font;
            try {
                Font f = Font.FromHfont(oleFont.GetHFont());

                if (f.Unit != GraphicsUnit.Point)
                    f = new Font(f.Name, f.SizeInPoints, f.Style, GraphicsUnit.Point, f.GdiCharSet, f.GdiVerticalFont);

                return f;
            }
            catch (Exception e) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Could not create font." + e.Message);
                return DefaultFont;
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetIFontDispFromFont"]/*' />
        /// <devdoc>
        ///     Maps from a System.Drawing.Font object to an OLE IFontDisp
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static object GetIFontDispFromFont(Font font) {
            if (font == null) return null;
            
            if (font.Unit != GraphicsUnit.Point)
                throw new ArgumentException(SR.GetString(SR.AXFontUnitNotPoint), "font");

            SafeNativeMethods.IFontDisp rval = SafeNativeMethods.OleCreateIFontDispIndirect(GetFONTDESCFromFont(font), ref ifontDisp_Guid);
            return rval;
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetFontFromIFontDisp"]/*' />
        /// <devdoc>
        ///     Maps from an IFontDisp to a System.Drawing.Font object
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static Font GetFontFromIFontDisp(object font) {
            if (font == null) return null;
            
            if (font is SafeNativeMethods.IFont)
                return GetFontFromIFont((SafeNativeMethods.IFont) font);

            SafeNativeMethods.IFontDisp oleFont = (SafeNativeMethods.IFontDisp)font;
            FontStyle style = FontStyle.Regular;
            
            Font f = null;
            try {
                if (oleFont.Bold)
                    style |= FontStyle.Bold;
    
                if (oleFont.Italic)
                    style |= FontStyle.Italic;
    
                if (oleFont.Underline)
                    style |= FontStyle.Underline;
    
                if (oleFont.Strikethrough)
                    style |= FontStyle.Strikeout;
    
                if ((int) oleFont.Weight >= 700) // bold
                    style |= FontStyle.Bold;

                f = new Font(oleFont.Name, (float)oleFont.Size/(float)10000, style, GraphicsUnit.Point, (byte)oleFont.Charset);
                return f;
            }
            catch(Exception e) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Could not create font from: " + oleFont.Name + ". " + e.Message);
                return DefaultFont;
            }
        }


        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetOADateFromTime"]/*' />
        /// <devdoc>
        ///     Maps from a DateTime object to an OLE DATE (expressed as a double)
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static double GetOADateFromTime(DateTime time) {
            return time.ToOADate();
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.GetTimeFromOADate"]/*' />
        /// <devdoc>
        ///     Maps from an OLE DATE (expressed as a double) to a DateTime object
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static DateTime GetTimeFromOADate(double date) {
            return DateTime.FromOADate(date);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private int Convert2int(Object o, bool xDirection) {
            o = ((Array)o).GetValue(0);
            // yacky yacky yacky...
            // so, usercontrols & other visual basic related controls give us coords as floats in twips
            // but mfc controls give us integers as pixels...
            if (o.GetType() == typeof(Single)) {
                return Twip2Pixel(Convert.ToDouble(o), xDirection);
            }
            return Convert.ToInt32(o);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private short Convert2short(Object o) {
            o = ((Array)o).GetValue(0);
            return Convert.ToInt16(o);
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseMove"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseMove(Object o1, Object o2, Object o3, Object o4) {
            RaiseOnMouseMove(Convert2short(o1), Convert2short(o2), Convert2int(o3, true), Convert2int(o4, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseMove1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseMove(short button, short shift, float x, float y) {
            RaiseOnMouseMove(button, shift, Twip2Pixel((int) x, true), Twip2Pixel((int) y, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseMove2"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseMove(short button, short shift, int x, int y) {
            base.OnMouseMove(new MouseEventArgs( (MouseButtons)(((int)button) << 20), 1, x, y, 0));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseUp"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseUp(Object o1, Object o2, Object o3, Object o4) {
            RaiseOnMouseUp(Convert2short(o1), Convert2short(o2), Convert2int(o3, true), Convert2int(o4, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseUp1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseUp(short button, short shift, float x, float y) {
            RaiseOnMouseUp(button, shift, Twip2Pixel((int) x, true), Twip2Pixel((int) y, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseUp2"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseUp(short button, short shift, int x, int y) {
            base.OnMouseUp(new MouseEventArgs((MouseButtons)(((int)button) << 20), 1, x, y, 0));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseDown"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseDown(Object o1, Object o2, Object o3, Object o4) {
            RaiseOnMouseDown(Convert2short(o1), Convert2short(o2), Convert2int(o3, true), Convert2int(o4, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseDown1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseDown(short button, short shift, float x, float y) {
            RaiseOnMouseDown(button, shift, Twip2Pixel((int) x,true), Twip2Pixel((int) y, false));
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.RaiseOnMouseDown2"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseOnMouseDown(short button, short shift, int x, int y) {
            base.OnMouseDown(new MouseEventArgs((MouseButtons)(((int)button) << 20), 1, x, y, 0));
        }

        /// <devdoc>
        /// </devdoc>
        private class VBFormat : UnsafeNativeMethods.IVBFormat {

            // IVBFormat methods:
            //
            int UnsafeNativeMethods.IVBFormat.Format(ref Object var, IntPtr pszFormat, IntPtr lpBuffer, short cpBuffer, int lcid, short firstD, short firstW, short[] result) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in Format");
                if (result == null)
                    return NativeMethods.E_INVALIDARG;

                result[0] = 0;
                if (lpBuffer == IntPtr.Zero || cpBuffer < 2)
                    return NativeMethods.E_INVALIDARG;

                IntPtr pbstr = IntPtr.Zero;
                int hr = UnsafeNativeMethods.VarFormat(ref var, new HandleRef(null, pszFormat), firstD, firstW, 32 /* VAR_FORMAT_NOSUBSTITUTE */, ref pbstr);
                
                try {
                    int i = 0;
                    if (pbstr != IntPtr.Zero) {
                        short ch = 0;
                        cpBuffer --;
                        for (;i < cpBuffer && (ch = Marshal.ReadInt16(pbstr, i * 2)) != 0; i++) {
                            Marshal.WriteInt16(lpBuffer, i * 2, ch);
                        }
                    }
                    Marshal.WriteInt16(lpBuffer, i * 2, (short) 0);
                    result[0] = (short) i;
                }
                finally {
                    SafeNativeMethods.SysFreeString(new HandleRef(null, pbstr));
                }

                return NativeMethods.S_OK;
            }
        }



        /// <devdoc>
        /// </devdoc>
        private class EnumUnknown : UnsafeNativeMethods.IEnumUnknown {
            private Object[] arr;
            private int loc;
            private int size;

            internal EnumUnknown(Object[] arr) {
                //if (AxHTraceSwitch.TraceVerbose) Debug.WriteObject(arr);
                this.arr = arr;
                loc = 0;
                size = (arr == null) ? 0 : arr.Length;
            }

            private EnumUnknown(Object[] arr, int loc) : this(arr) {
                this.loc = loc;
            }

            unsafe int UnsafeNativeMethods.IEnumUnknown.Next(int celt, IntPtr rgelt, IntPtr pceltFetched) {
                if (pceltFetched != IntPtr.Zero)
                    Marshal.WriteInt32(pceltFetched, 0, 0);

                if (celt < 0) {
                    return NativeMethods.E_INVALIDARG;
                }
                
                int fetched = 0;
                if (loc >= size) {
                    fetched = 0;
                }
                else {
                    for (; loc < size && fetched < celt; ++loc, ++fetched) {
                        Marshal.WriteIntPtr(rgelt, Marshal.GetIUnknownForObject(arr[loc]));
                        rgelt = (IntPtr)((int)rgelt + sizeof(IntPtr));
                    }
                }
                
                if (pceltFetched != IntPtr.Zero)
                    Marshal.WriteInt32(pceltFetched, 0, fetched);

                if (fetched != celt) {
                    return(NativeMethods.S_FALSE);
                }
                return NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IEnumUnknown.Skip(int celt) {
                loc += celt;
                if (loc >= size) {
                    return(NativeMethods.S_FALSE);
                }
                return NativeMethods.S_OK;
            }

            void UnsafeNativeMethods.IEnumUnknown.Reset() {
                loc = 0;
            }

            void UnsafeNativeMethods.IEnumUnknown.Clone(out UnsafeNativeMethods.IEnumUnknown ppenum) {
                ppenum = new EnumUnknown(arr, loc);
            }
        }


        /// <devdoc>
        /// </devdoc>
        internal class AxContainer : UnsafeNativeMethods.IOleContainer, UnsafeNativeMethods.IOleInPlaceFrame, IReflect {
            internal ContainerControl parent;
            private IContainer assocContainer; // associated IContainer...
            // the assocContainer may be null, in which case all this container does is
            // forward [de]activation messages to the requisite container...
            private AxHost siteUIActive;
            private AxHost siteActive;
            private bool formAlreadyCreated = false;
            private Hashtable containerCache = new Hashtable();  // name -> Control
            private int lockCount = 0;
            private Hashtable components = null;  // Control -> any
            private Hashtable proxyCache = null;
            private AxHost ctlInEditMode = null;

            private const int GC_CHILD = 0x1;
            private const int GC_LASTSIBLING = 0x2;
            private const int GC_FIRSTSIBLING = 0x4;
            private const int GC_CONTAINER = 0x20;
            private const int GC_PREVSIBLING = 0x40;
            private const int GC_NEXTSIBLING = 0x80;

            internal AxContainer(ContainerControl parent) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in constructor.  Parent created : "+parent.Created.ToString());
                this.parent = parent;
                if (parent.Created) FormCreated();
            }

            // IReflect methods:

            MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr,Binder binder, Type[] types,ParameterModifier[] modifiers) {
                return null;
            }

            MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr) {
                return null;
            }

            MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
                return new MethodInfo[0];
            }

            FieldInfo IReflect.GetField(String name, BindingFlags bindingAttr) {
                return null;
            }

            FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
                return new FieldInfo[0];
            }

            PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr) {
                return null;
            }

            PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
                return null;
            }

            PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
                return new PropertyInfo[0];
            }

            MemberInfo[] IReflect.GetMember(String name, BindingFlags bindingAttr) {
                return new MemberInfo[0];
            }

            MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
                return new MemberInfo[0];
            }

            Object IReflect.InvokeMember(String name, BindingFlags invokeAttr, Binder binder,
                                                    Object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters) {
                
                foreach(DictionaryEntry e in containerCache) {
                    string ctlName = GetNameForControl((Control)e.Key);
                    if (ctlName.Equals(name)) {
                        return GetProxyForControl((Control)e.Value);
                    }
                }
                
                throw E_FAIL;
            }

            Type IReflect.UnderlyingSystemType {
                get {
                    return null;
                }
            }   

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal UnsafeNativeMethods.IExtender GetProxyForControl(Control ctl) {
                UnsafeNativeMethods.IExtender rval = null;
                if (proxyCache == null) {
                    proxyCache = new Hashtable();
                }
                else {
                    rval = (UnsafeNativeMethods.IExtender) proxyCache[ctl];
                }
                if (rval == null) {
                    if (ctl != parent && !GetControlBelongs(ctl)) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "!parent || !belongs NYI");
                        AxContainer c = FindContainerForControl(ctl);
                        if (c != null) {
                            rval = new ExtenderProxy(ctl, c);
                        }
                        else {
                            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "unable to find proxy, returning null");
                            return null;
                        }
                    }
                    else {
                        rval = new ExtenderProxy(ctl, this);
                    }
                    proxyCache.Add(ctl, rval);
                }
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "found proxy "+rval.ToString());
                return rval;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal string GetNameForControl(Control ctl) {
                string name = (ctl.Site != null) ? ctl.Site.Name : ctl.Name;
                return (name == null) ? "" : name;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal Object GetProxyForContainer() {
                return this;
            }

            /// <devdoc>
            ///      Retrieves an array of child controls in tab index order.
            /// </devdoc>
            private Control[] GetTabArray(Control ctl) {
                ControlTabIndexHolder[] holders = new ControlTabIndexHolder[ctl.Controls.Count];
                for (int i = 0; i < ctl.Controls.Count; i++) {
                    holders[i] = new ControlTabIndexHolder(i, ctl.Controls[i]);
                }

                Array.Sort(holders, new ControlTabIndexHolderComparer());

                Control[] ctls = new Control[holders.Length];
                for (int i = 0; i < holders.Length; i++) {
                    ctls[i] = holders[i].control;
                }

                return ctls;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void AddControl(Control ctl) {
                lock(this) {
                    if (containerCache.Contains(ctl))
                        throw new ArgumentException(SR.GetString(SR.AXDuplicateControl, GetNameForControl(ctl)), "ctl");

                    containerCache.Add(ctl, ctl);
                    
                    if (assocContainer == null) {
                        ISite site = ctl.Site;
                        if (site != null) {
                            assocContainer = site.Container;
                            IComponentChangeService ccs = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                            if (ccs != null) {
                                ccs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                            }
                        }
                    }
                    else {
#if DEBUG
                            ISite site = ctl.Site;
                            if (site != null && assocContainer != site.Container) {
                                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "mismatch between assoc container & added control");
                            }
#endif
                    }
                }
            }

            internal void RemoveControl(Control ctl) {
                lock(this) {
                    if (containerCache.Contains(ctl)) {
                        containerCache.Remove(ctl);
                    }
                }
            }


            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void LockComponents() {
                lockCount++;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void UnlockComponents() {
                lockCount--;
                if (lockCount == 0) {
                    components = null;
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal UnsafeNativeMethods.IEnumUnknown EnumControls(Control ctl, int dwOleContF, int dwWhich) {
                GetComponents();

                LockComponents();
                try {
                    ArrayList l = null;
                    bool selected = (dwWhich & NativeMethods.ActiveX.GC_WCH_FSELECTED) != 0;
                    bool reverse = (dwWhich & NativeMethods.ActiveX.GC_WCH_FREVERSEDIR) != 0;
                    // Note that visual basic actually ignores the next/prev flags... we will not
                    bool onlyNext = (dwWhich & NativeMethods.ActiveX.GC_WCH_FONLYNEXT) != 0;
                    bool onlyPrev = (dwWhich & NativeMethods.ActiveX.GC_WCH_FONLYPREV) != 0;
                    dwWhich = dwWhich & ~(NativeMethods.ActiveX.GC_WCH_FSELECTED | NativeMethods.ActiveX.GC_WCH_FREVERSEDIR |
                                          NativeMethods.ActiveX.GC_WCH_FONLYNEXT | NativeMethods.ActiveX.GC_WCH_FONLYPREV);
                    if (onlyNext && onlyPrev) {
                        Debug.Fail("onlyNext && onlyPrev are both set!");
                        throw E_INVALIDARG;
                    }
                    if (dwWhich == NativeMethods.ActiveX.GC_WCH_CONTAINER || dwWhich == NativeMethods.ActiveX.GC_WCH_CONTAINED) {
                        if (onlyNext || onlyPrev) {
                            Debug.Fail("GC_WCH_FONLYNEXT or FONLYPREV used with CONTANER or CONATINED");
                            throw E_INVALIDARG;
                        }
                    }
                    int first = 0;
                    int last = -1; // meaning all
                    Control[] ctls  = null;
                    switch (dwWhich) {
                        default:
                            Debug.Fail("Bad GC_WCH");
                            throw E_INVALIDARG;
                        case NativeMethods.ActiveX.GC_WCH_CONTAINED:
                            ctls = GetTabArray(ctl);
                            ctl = null;
                            break;
                        case NativeMethods.ActiveX.GC_WCH_SIBLING:
                            Control p = ctl.ParentInternal;
                            if (p != null) {
                                ctls = GetTabArray(p);
                                if (onlyPrev) {
                                    last = ctl.TabIndex;
                                }
                                else if (onlyNext) {
                                    first = ctl.TabIndex + 1;
                                }
                            }
                            else {
                                ctls = new Control[0];
                            }
                            ctl = null;
                            break;
                        case NativeMethods.ActiveX.GC_WCH_CONTAINER:
                            l = new ArrayList();
                            MaybeAdd(l, ctl, selected, dwOleContF, false);
                            while (ctl != null) {
                                AxContainer cont = FindContainerForControl(ctl);
                                if (cont != null) {
                                    MaybeAdd(l, cont.parent, selected, dwOleContF, true);
                                    ctl = cont.parent;
                                }
                                else {
                                    break;
                                }
                            }
                            break;
                        case NativeMethods.ActiveX.GC_WCH_ALL:
                            Hashtable htbl = GetComponents();
                            ctls = new Control[htbl.Keys.Count];
                            htbl.Keys.CopyTo(ctls, 0);
                            ctl = parent;
                            break;
                    }
                    if (l == null) {
                        l = new ArrayList();
                        if (last == -1 && ctls != null) last = ctls.Length;
                        if (ctl != null) MaybeAdd(l, ctl, selected, dwOleContF, false);
                        for (int i = first; i < last; i++) {
                            MaybeAdd(l, ctls[i], selected, dwOleContF, false);
                        }
                    }
                    Object[] rval = new Object[l.Count];
                    l.CopyTo(rval, 0);
                    if (reverse) {
                        for (int i = 0, j = rval.Length - 1; i < j; i++, j--) {
                            Object temp = rval[i];
                            rval[i] = rval[j];
                            rval[j] = temp;
                        }
                    }
                    return new EnumUnknown(rval);
                }
                finally {
                    UnlockComponents();
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void MaybeAdd(ArrayList l, Control ctl, bool selected, int dwOleContF, bool ignoreBelong) {
                if (!ignoreBelong && ctl != parent && !GetControlBelongs(ctl)) return;
                if (selected) {
                    ISelectionService iss = GetSelectionService(ctl);
                    if (iss == null || !iss.GetComponentSelected(this)) return;
                }
                if (ctl is AxHost && (dwOleContF & NativeMethods.ActiveX.OLECONTF_EMBEDDINGS) != 0) {
                    l.Add(((AxHost)ctl).GetOcx());
                }
                else if ((dwOleContF & NativeMethods.ActiveX.OLECONTF_OTHERS) != 0) {
                    Object item = GetProxyForControl(ctl);
                    if (item != null) l.Add(item);
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void FillComponentsTable(IContainer container) {
                if (container != null) {
                    ComponentCollection comps = container.Components;
                    if (comps != null) {
                        components = new Hashtable();
                        foreach (IComponent comp in comps) {
                            if (comp is Control && comp != parent && comp.Site != null) {
                                components.Add(comp, comp);
                            }
                        }
                        return;
                    }
                }

                Debug.Assert(parent.Site == null, "Parent is sited but we could not find IContainer!!!");
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Did not find a container in FillComponentsTable!!!");

                bool checkHashTable = true;
                Control[] ctls = new Control[containerCache.Values.Count];
                containerCache.Values.CopyTo(ctls, 0);
                if (ctls != null) {
                    if (ctls.Length > 0 && components == null) {
                        components = new Hashtable();
                        checkHashTable = false;
                    }
                    for (int i = 0; i < ctls.Length; i ++) {
                        if (checkHashTable && !components.Contains(ctls[i])) {
                            components.Add(ctls[i], ctls[i]);
                        }
                    }
                }

                GetAllChildren(this.parent);
            }

            private void GetAllChildren(Control ctl) {
                if (ctl == null)
                    return;

                if (components == null) {
                    components = new Hashtable();
                }

                if (ctl != this.parent && !components.Contains(ctl))
                    components.Add(ctl, ctl);

                foreach(Control c in ctl.Controls) {
                    GetAllChildren(c);
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private Hashtable GetComponents() {
                return GetComponents(GetParentsContainer());
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private Hashtable GetComponents(IContainer cont) {
                if (lockCount == 0) {
                    FillComponentsTable(cont);
                }
                return components;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private bool GetControlBelongs(Control ctl) {
                Hashtable comps = GetComponents();
                return comps[ctl] != null;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private IContainer GetParentIsDesigned() {
                ISite site = parent.Site;
                if (site != null && site.DesignMode) return site.Container;
                return null;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private IContainer GetParentsContainer() {
                IContainer rval = GetParentIsDesigned();
                Debug.Assert(rval == null || assocContainer == null || (rval == assocContainer),
                             "mismatch between getIPD & aContainer");
                return rval == null ? assocContainer : rval;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private bool RegisterControl(AxHost ctl) {
                ISite site = ctl.Site;
                if (site != null) {
                    IContainer cont = site.Container;
                    if (cont != null) {
                        if (assocContainer != null) {
                            return cont == assocContainer;
                        }
                        else {
                            assocContainer = cont;
                            IComponentChangeService ccs = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                            if (ccs != null) {
                                ccs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                            }
                            return true;
                        }
                    }
                }
                return false;
            }

            private void OnComponentRemoved(object sender, ComponentEventArgs e) {
                Control c = e.Component as Control;
                if (sender == assocContainer && c != null) {
                    RemoveControl(c);
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal static AxContainer FindContainerForControl(Control ctl) {
                if (ctl is AxHost) {
                    AxHost axctl = (AxHost) ctl;
                    if (axctl.container != null) return axctl.container;
                    ContainerControl f = axctl.ContainingControl;
                    if (f != null) {
                        AxContainer container = f.CreateAxContainer();
                        if (container.RegisterControl(axctl)) {
                            container.AddControl(axctl);
                            return container;
                        }
                    }
                }
                return null;
            }

            private void OnOldActiveControl(Control valueOld, Control valueNew) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "onOAC called with old: "+valueOld.ToString()+" new: "+valueNew.ToString());
                if (!(valueOld is AxHost)) return;
                AxContainer c = FindContainerForControl(valueOld);
                if (c != null) {
                    c.OnOldActiveControlInternal(valueOld);
                }
                else {
                    Debug.Fail("control w/o a container... pretty bad..."+valueOld.ToString());
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void OnOldActiveControlInternal(Control valueOld) {
                if (siteUIActive == valueOld) siteUIActive.UiDeactivate();
            }

            private void OnNewActiveControl(Control value) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "onNAC called with new: "+value.ToString());
                if (!(value is AxHost)) return;
                AxContainer c = FindContainerForControl(value);
                if (c != null) {
                    c.OnNewActiveControlInternal((AxHost)value);
                }
                else {
                    Debug.Fail("control w/o a container... pretty bad..."+value.ToString());
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void OnNewActiveControlInternal(AxHost value) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "New active control. siteUIActive is" +siteUIActive.ToString()+" Control is "+value.ToString());
                if (siteUIActive != null && siteUIActive != value) {
                    Debug.Fail("we should not have an ui active site on this container!"+parent.ToString());
                    siteUIActive.UiDeactivate();
                }
#if DEBUG
                if (siteUIActive != null && siteUIActive != value) Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Why is "+siteUIActive.ToString()+" still active?");
                if (!value.CanUIActivate) Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "why can't "+value.ToString()+" be uiactivated?");
#endif
                if (siteUIActive == null && value.CanUIActivate) {
                    // we need to uiactivate it ourselves...
                    try {
                        ((AxHost)value).UiActivate();
                    }
                    catch (Exception e) {
                        Debug.Fail(e.ToString());
                    }
                }
#if DEBUG
                if (siteUIActive != parent.ActiveControl && value.CanUIActivate) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "form's active control is "+parent.ActiveControl.ToString());
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "could not reconcile active controls... bad things loom on the horizon...");
                }
#endif
                if (siteUIActive == null) {
                    // so now the form thinks that value is the active control but it's not ui active...
                    // this can often lead to bad things unless we are carefull...
                    siteActive = value;
                    // basically, when siteActive goes inplacedeactivate, we need to treat it the same as a
                    // siteuiactive going uiactivedeactivate...
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void OnInPlaceDeactivate(AxHost site) {
                if (siteActive == site) {
                    siteActive = null;
                    if (site.GetSiteOwnsDeactivation()) {
                        parent.ActiveControl = null;
                    }
                    else {
                        // we need to tell the form to switch activation to the next thingie...
                        Debug.Fail("what pathological control is calling inplacedeactivate by itself?");
                    }
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void OnUIDeactivate(AxHost site) {
#if DEBUG
                if (siteUIActive != null)
                    Debug.Assert(siteUIActive == site, "deactivating when not active...");
#endif // DEBUG

                siteUIActive = null;
                site.RemoveSelectionHandler();
                site.SetSelectionStyle(1);
                site.editMode = EDITM_NONE;
                if (site.GetSiteOwnsDeactivation()) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, " our site owns deactivation ");
                    ContainerControl f = site.ContainingControl;
                    Debug.Assert(f != null, "a control has to be on a ContainerControl...");
                    if (f != null) {
                        //    f.setActiveControl(null);
                    }
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void OnUIActivate(AxHost site) {
                // The ShDocVw control repeatedly calls OnUIActivate() with the same
                // site. This causes the assert below to fire.
                //
                if (siteUIActive == site)
                    return;

                if (siteUIActive != null && siteUIActive != site) {
                    AxHost tempSite = siteUIActive;
                    bool ownDisposing = tempSite.GetAxState(AxHost.ownDisposing);
                    try {
                        tempSite.SetAxState(AxHost.ownDisposing, true);
                        tempSite.GetInPlaceObject().UIDeactivate();
                    }
                    finally {
                        tempSite.SetAxState(AxHost.ownDisposing, ownDisposing);
                    }
                }
                site.AddSelectionHandler();
                Debug.Assert(siteUIActive == null, "Object did not call OnUIDeactivate");
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "active Object is now "+site.ToString());
                siteUIActive = site;
                ContainerControl f = site.ContainingControl;
                Debug.Assert(f != null, "a control has to be on a ContainerControl...");
                if (f != null) {
                    f.ActiveControl = site;
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void ListAxControls(ArrayList list, bool fuseOcx) {
                Hashtable components = GetComponents();
                if (components == null) return;
                Control[] ctls = new Control[components.Keys.Count];
                components.Keys.CopyTo(ctls, 0);
                if (ctls != null) {
                    for (int i = 0; i < ctls.Length; i++) {
                        Control ctl = ctls[i];
                        if (ctl is AxHost) {
                            if (fuseOcx) {
                                list.Add(((AxHost)ctl).GetOcx());
                            }
                            else {
                                list.Add(ctl);
                            }
                        }
                    }
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void ControlCreated(AxHost invoker) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in controlCreated for "+invoker.ToString()+" fAC: "+formAlreadyCreated.ToString());
                if (formAlreadyCreated) {
                    if (invoker.IsUserMode() && invoker.AwaitingDefreezing()) {
                        invoker.Freeze(false);
                    }
                }
                else {
                    // the form will be created in the future
                    parent.CreateAxContainer();
                }
            }

            internal void FormCreated() {
                if (formAlreadyCreated) return;
                formAlreadyCreated = true;
                ArrayList l = new ArrayList();
                ListAxControls(l, false);
                AxHost[] axControls = new AxHost[l.Count];
                l.CopyTo(axControls, 0);
                for (int i = 0; i < axControls.Length; i++) {
                    AxHost control = axControls[i];
                    if (control.GetOcState() >= OC_RUNNING && control.IsUserMode() && control.AwaitingDefreezing()) {
                        control.Freeze(false);
                    }
                }
            }


            // IOleContainer methods:

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.ParseDisplayName"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleContainer.ParseDisplayName(Object pbc, string pszDisplayName, int[] pchEaten, Object[] ppmkOut) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in ParseDisplayName");
                if (ppmkOut != null)
                    ppmkOut[0] = null;
                 return NativeMethods.E_NOTIMPL;
            }


            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.EnumObjects"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleContainer.EnumObjects(int grfFlags, out UnsafeNativeMethods.IEnumUnknown ppenum) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in EnumObjects");
                ppenum = null;
                if ((grfFlags & 1) != 0) { // 1 == OLECONTF_EMBEDDINGS
                    Debug.Assert(parent != null, "gotta have it...");
                    ArrayList list = new ArrayList();
                    ListAxControls(list, true);
                    if (list.Count > 0) {
                        Object[] temp = new Object[list.Count];
                        list.CopyTo(temp, 0);
                        ppenum = new EnumUnknown(temp);
                        return NativeMethods.S_OK;
                    }
                }
                ppenum = new EnumUnknown(null);
                return NativeMethods.S_OK;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.LockContainer"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleContainer.LockContainer(int fLock) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in LockContainer");
                return NativeMethods.E_NOTIMPL;
            }

            // IOleInPlaceFrame methods:

            IntPtr UnsafeNativeMethods.IOleInPlaceFrame.GetWindow() {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetWindow");
                return parent.Handle;
            }

            int UnsafeNativeMethods.IOleInPlaceFrame.ContextSensitiveHelp(int fEnterMode) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in ContextSensitiveHelp");
                return NativeMethods.S_OK;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.GetBorder"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.GetBorder(NativeMethods.COMRECT lprectBorder) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetBorder");
                return NativeMethods.E_NOTIMPL;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.RequestBorderSpace"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.RequestBorderSpace(NativeMethods.COMRECT pborderwidths) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in RequestBorderSpace");
                return NativeMethods.E_NOTIMPL;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.SetBorderSpace"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.SetBorderSpace(NativeMethods.COMRECT pborderwidths) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in SetBorderSpace");
                return NativeMethods.E_NOTIMPL;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal void OnExitEditMode(AxHost ctl) {
                Debug.Assert(ctlInEditMode == null || ctlInEditMode == ctl, "who is exiting edit mode?");
                if (ctlInEditMode == null || ctlInEditMode != ctl) return;
                ctlInEditMode = null;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.SetActiveObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.SetActiveObject(UnsafeNativeMethods.IOleInPlaceActiveObject pActiveObject, string pszObjName) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in SetActiveObject " + ((pszObjName == null) ? "<null>" : pszObjName));
                if (pActiveObject == null) {
                    if (ctlInEditMode != null) {
                        ctlInEditMode.editMode = EDITM_NONE;
                        ctlInEditMode = null;
                    }
                    return NativeMethods.S_OK;
                }
                AxHost ctl = null;
                if (pActiveObject is UnsafeNativeMethods.IOleObject) {
                    UnsafeNativeMethods.IOleObject oleObject = (UnsafeNativeMethods.IOleObject) pActiveObject;
                    UnsafeNativeMethods.IOleClientSite clientSite = null;
                    try {
                        clientSite = oleObject.GetClientSite();
                        if (clientSite is OleInterfaces) {
                            ctl = ((OleInterfaces)(clientSite)).GetAxHost();
                        }
                    }
                    catch (COMException t) {
                        Debug.Fail(t.ToString());
                    }
                    if (ctlInEditMode != null) {
                        Debug.Fail("control " + ctlInEditMode.ToString() + " did not reset its edit mode to null");
                        ctlInEditMode.SetSelectionStyle(1);
                        ctlInEditMode.editMode = EDITM_NONE;
                    }
                    
                    if (ctl == null) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "control w/o a valid site called setactiveobject");
                        ctlInEditMode = null;
                    }
                    else {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "resolved to " + ctl.ToString());
                        if (!ctl.IsUserMode()) {
                            ctlInEditMode = ctl;
                            ctl.editMode = EDITM_OBJECT;
                            ctl.AddSelectionHandler();
                            ctl.SetSelectionStyle(2);
                        }
                    }
                }

                return NativeMethods.S_OK;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.InsertMenus"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.InsertMenus(IntPtr hmenuShared, NativeMethods.tagOleMenuGroupWidths lpMenuWidths) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in InsertMenus");
                return NativeMethods.S_OK;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.SetMenu"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in SetMenu");
                return NativeMethods.E_NOTIMPL;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.RemoveMenus"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.RemoveMenus(IntPtr hmenuShared) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in RemoveMenus");
                return NativeMethods.E_NOTIMPL;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.SetStatusText"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.SetStatusText(string pszStatusText) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in SetStatusText");
                return NativeMethods.E_NOTIMPL;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.EnableModeless"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.EnableModeless(int fEnable) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in EnableModeless");
                return NativeMethods.E_NOTIMPL;
            }
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxContainer.TranslateAccelerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            int UnsafeNativeMethods.IOleInPlaceFrame.TranslateAccelerator(ref NativeMethods.MSG lpmsg, short wID) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in IOleInPlaceFrame.TranslateAccelerator");
                return NativeMethods.S_FALSE;
            }

            /// <devdoc>
            ///      This class contains a control and associates it with a z-order.
            ///      This is used when sorting controls based on tab index first, and z-order
            ///      second.
            /// </devdoc>
            private class ControlTabIndexHolder {
                public readonly int zorder;
                public readonly Control control;

                public ControlTabIndexHolder(int zorder, Control control) {
                    this.zorder = zorder;
                    this.control = control;
                }
            }

            /// <devdoc>
            ///      Used to sort controls based on tab index.
            /// </devdoc>
            private class ControlTabIndexHolderComparer : IComparer {
                int IComparer.Compare(Object x, Object y) {

                    ControlTabIndexHolder hx = (ControlTabIndexHolder)x;
                    ControlTabIndexHolder hy = (ControlTabIndexHolder)y;

                    int delta = hx.control.TabIndex - hy.control.TabIndex;
                    if (delta == 0) {
                        delta = hx.zorder - hy.zorder;
                    }
                    return delta;
                }
            }

            // EXPOSED

            /// <devdoc>
            /// </devdoc>
            private class ExtenderProxy : UnsafeNativeMethods.IExtender, UnsafeNativeMethods.IVBGetControl, UnsafeNativeMethods.IGetVBAObject, UnsafeNativeMethods.IGetOleObject, IReflect {
                private WeakReference pRef;
                private WeakReference pContainer;

                internal ExtenderProxy(Control principal, AxContainer container) {
                    pRef = new WeakReference(principal);
                    pContainer = new WeakReference(container);
                }

                private Control GetP() {
                    return(Control) pRef.Target;
                }

                private AxContainer GetC() {
                    return(AxContainer) pContainer.Target;
                }

                int UnsafeNativeMethods.IVBGetControl.EnumControls(int dwOleContF, int dwWhich, out UnsafeNativeMethods.IEnumUnknown ppenum) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in EnumControls for proxy");
                    ppenum = GetC().EnumControls(GetP(), dwOleContF, dwWhich);
                    return NativeMethods.S_OK;
                }

                object UnsafeNativeMethods.IGetOleObject.GetOleObject(ref Guid riid) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetOleObject for proxy");
                    if (!riid.Equals(ioleobject_Guid))
                        throw E_INVALIDARG;

                    Control ctl = GetP();
                    if (ctl != null && ctl is AxHost) {
                        return ((AxHost)ctl).GetOcx();
                    }

                    throw E_FAIL;
                }

                int UnsafeNativeMethods.IGetVBAObject.GetObject(ref Guid riid, UnsafeNativeMethods.IVBFormat[] rval, int dwReserved) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in GetObject for proxy");
                    if (rval == null || riid.Equals(Guid.Empty))
                        return NativeMethods.E_INVALIDARG;

                    if (riid.Equals(ivbformat_Guid)) {
                        rval[0] = new VBFormat();
                        return NativeMethods.S_OK;
                    }
                    else {
                        rval[0] = null;
                        return NativeMethods.E_NOINTERFACE;
                    }
                }

                public int Align {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getAlign for proxy for "+ GetP().ToString());
                        int rval = (int)((Control)GetP()).Dock;
                        if (rval < NativeMethods.ActiveX.ALIGN_MIN || rval > NativeMethods.ActiveX.ALIGN_MAX) {
                            rval = NativeMethods.ActiveX.ALIGN_NO_CHANGE;
                        }
                        return rval;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setAlign for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().Dock = (DockStyle)value;
                    }
                }

                public UInt32 BackColor {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getBackColor for proxy for "+ GetP().ToString());
                        return AxHost.GetOleColorFromColor(((Control)GetP()).BackColor);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setBackColor for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().BackColor = AxHost.GetColorFromOleColor(value);
                    }
                }

                public bool Enabled {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getEnabled for proxy for "+ GetP().ToString());
                        return GetP().Enabled;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setEnabled for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().Enabled = value;
                    }
                }

                public UInt32 ForeColor {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getForeColor for proxy for "+ GetP().ToString());
                        return AxHost.GetOleColorFromColor(((Control)GetP()).ForeColor);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setForeColor for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().ForeColor = AxHost.GetColorFromOleColor(value);
                    }
                }

                public int Height {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getHeight for proxy for "+ GetP().ToString());
                        return Pixel2Twip(GetP().Height, false);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setHeight for proxy for "+ GetP().ToString()+" "+Twip2Pixel(value,false).ToString());
                        GetP().Height = Twip2Pixel(value, false);
                    }
                }

                public int Left {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getLeft for proxy for "+ GetP().ToString());
                        return Pixel2Twip(GetP().Left, true);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setLeft for proxy for "+ GetP().ToString()+" "+Twip2Pixel(value, true).ToString());
                        GetP().Left = Twip2Pixel(value, true);
                    }
                }

                public object Parent {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getParent for proxy for "+ GetP().ToString());
                        return GetC().GetProxyForControl(GetC().parent);
                    }
                }

                public short TabIndex {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getTabIndex for proxy for "+ GetP().ToString());
                        return (short)GetP().TabIndex;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setTabIndex for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().TabIndex = (int)value;
                    }
                }

                public bool TabStop {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getTabStop for proxy for "+ GetP().ToString());
                        return GetP().TabStop;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setTabStop for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().TabStop = value;
                    }
                }

                public int Top {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getTop for proxy for "+ GetP().ToString());
                        return Pixel2Twip(GetP().Top, false);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setTop for proxy for "+ GetP().ToString()+" "+Twip2Pixel(value, false).ToString());
                        GetP().Top = Twip2Pixel(value, false);
                    }
                }

                public bool Visible {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getVisible for proxy for "+ GetP().ToString());
                        return GetP().Visible;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setVisible for proxy for "+ GetP().ToString()+" "+value.ToString());
                        GetP().Visible = value;
                    }
                }

                public int Width {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getWidth for proxy for "+ GetP().ToString());
                        return Pixel2Twip(GetP().Width,true);
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setWidth for proxy for "+ GetP().ToString()+" "+Twip2Pixel(value, true).ToString());
                        GetP().Width = Twip2Pixel(value, true);
                    }
                }

                public string Name {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getName for proxy for "+ GetP().ToString());
                        return GetC().GetNameForControl(GetP());
                    }
                }

                public IntPtr Hwnd {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getHwnd for proxy for "+ GetP().ToString());
                        return GetP().Handle;
                    }
                }

                public object Container {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getContainer for proxy for "+ GetP().ToString());
                        return GetC().GetProxyForContainer();
                    }
                }

                public string Text {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in getText for proxy for "+ GetP().ToString());
                        return GetP().Text;
                    }

                    set {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in setText for proxy for "+ GetP().ToString());
                        GetP().Text = value;
                    }
                }

                public void Move(Object left, Object top, Object width, Object height) {
                }

                // IReflect methods:

                MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr,Binder binder, Type[] types,ParameterModifier[] modifiers) {
                    return null;
                }

                MethodInfo IReflect.GetMethod(String name,BindingFlags bindingAttr) {
                    return null;
                }

                MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr) {
                    return new MethodInfo[] {this.GetType().GetMethod("Move")};
                }

                FieldInfo IReflect.GetField(String name, BindingFlags bindingAttr) {
                    return null;
                }

                FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr) {
                    return new FieldInfo[0];
                }

                PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr) {
                    PropertyInfo prop = GetP().GetType().GetProperty(name, bindingAttr);
                    if (prop == null) {
                        prop = this.GetType().GetProperty(name, bindingAttr);
                    }
                    return prop;
                }

                PropertyInfo IReflect.GetProperty(String name, BindingFlags bindingAttr, Binder binder,Type returnType, Type[] types, ParameterModifier[] modifiers) {
                    PropertyInfo prop = GetP().GetType().GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
                    if (prop == null) {
                        prop = this.GetType().GetProperty(name, bindingAttr, binder, returnType, types, modifiers);
                    }
                    return prop;
                }

                PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr) {
                    PropertyInfo[] extenderProps = this.GetType().GetProperties(bindingAttr);
                    PropertyInfo[] ctlProps = GetP().GetType().GetProperties(bindingAttr);

                    if (extenderProps == null) {
                        return ctlProps;
                    }
                    else if (ctlProps == null) {
                        return extenderProps;
                    }
                    else {
                        int iProp = 0;
                        PropertyInfo[] props = new PropertyInfo[extenderProps.Length + ctlProps.Length];
                        
                        foreach(PropertyInfo prop in extenderProps) {
                            props[iProp++] = prop;
                        }

                        foreach(PropertyInfo prop in ctlProps) {
                            props[iProp++] = prop;
                        }

                        return props;
                    }
                }

                MemberInfo[] IReflect.GetMember(String name, BindingFlags bindingAttr) {
                    MemberInfo[] memb = GetP().GetType().GetMember(name, bindingAttr);
                    if (memb == null) {
                        memb = this.GetType().GetMember(name, bindingAttr);
                    }
                    return memb;
                }

                MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr) {
                    MemberInfo[] extenderMembs = this.GetType().GetMembers(bindingAttr);
                    MemberInfo[] ctlMembs = GetP().GetType().GetMembers(bindingAttr);

                    if (extenderMembs == null) {
                        return ctlMembs;
                    }
                    else if (ctlMembs == null) {
                        return extenderMembs;
                    }
                    else {
                        MemberInfo[] membs = new MemberInfo[extenderMembs.Length + ctlMembs.Length];
                        
                        Array.Copy(extenderMembs, 0, membs, 0, extenderMembs.Length);
                        Array.Copy(ctlMembs, 0, membs, extenderMembs.Length, ctlMembs.Length);

                        return membs;
                    }
                }

                Object IReflect.InvokeMember(String name, BindingFlags invokeAttr, Binder binder,
                                             Object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters) {
                    try {
                        return this.GetType().InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
                    }
                    catch(MissingMethodException) {
                        return this.GetP().GetType().InvokeMember(name, invokeAttr, binder, GetP(), args, modifiers, culture, namedParameters);
                    }
                }

                Type IReflect.UnderlyingSystemType {
                    get {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "In UnderlyingSystemType");
                        return null;
                    }
                }   
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="StateConverter"]/*' />
        /// <devdoc>
        ///      StateConverter is a class that can be used to convert
        ///      State from one data type to another.  Access this
        ///      class through the TypeDescriptor.
        /// </devdoc>
        /// <internalonly/>
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class StateConverter : TypeConverter {

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.StateConverter.CanConvertFrom"]/*' />
            /// <devdoc>
            ///    <para>Gets a value indicating whether this converter can
            ///       convert an object in the given source type to the native type of the converter
            ///       using the context.</para>
            /// </devdoc>
            /// <internalonly/>
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                if (sourceType == typeof(byte[])) {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.StateConverter.CanConvertTo"]/*' />
            /// <devdoc>
            ///    <para>Gets a value indicating whether this converter can
            ///       convert an object to the given destination type using the context.</para>
            /// </devdoc>
            /// <internalonly/>
            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
                if (destinationType == typeof(byte[])) {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.StateConverter.ConvertFrom"]/*' />
            /// <devdoc>
            ///    <para>Converts the given object to the converter's native type.</para>
            /// </devdoc>
            /// <internalonly/>
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
                if (value is byte[]) {
                    MemoryStream ms = new MemoryStream((byte[])value);
                    return new State(ms);
                }

                return base.ConvertFrom(context, culture, value);
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.StateConverter.ConvertTo"]/*' />
            /// <devdoc>
            ///      Converts the given object to another type.  The most common types to convert
            ///      are to and from a string object.  The default implementation will make a call
            ///      to ToString on the object if the object is valid and if the destination
            ///      type is string.  If this cannot convert to the desitnation type, this will
            ///      throw a NotSupportedException.
            /// </devdoc>
            /// <internalonly/>
            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                if (destinationType == null) {
                    throw new ArgumentNullException("destinationType");
                }

                if (destinationType == typeof(byte[])) {
                    if (value != null) {
                        MemoryStream ms = new MemoryStream();
                        State state = (State)value;
                        state.Save(ms);
                        ms.Close();
                        return ms.ToArray();
                    }
                    else 
                        return new byte[0];
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.State"]/*' />
        /// <devdoc>
        ///    <para>The class which encapsulates the persisted state of the underlying activeX control
        ///       An instance of this class my be obtained either by calling getOcxState on an
        ///       AxHost object, or by reading in from a stream.</para>
        /// </devdoc>
        [
            TypeConverterAttribute(typeof(TypeConverter)),
            Serializable
        ]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class State : ISerializable {
            private int VERSION = 1;
            private int length;
            private byte[] buffer;
            internal int type;
            private MemoryStream ms;
            private UnsafeNativeMethods.IStorage storage;
            private UnsafeNativeMethods.ILockBytes iLockBytes;
            private bool manualUpdate = false;
            private string licenseKey = null;
            private PropertyBagStream propBag;
            
            // create on save from ipersist stream
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal State(MemoryStream ms, int storageType, AxHost ctl, PropertyBagStream propBag) {
                type = storageType;
                this.propBag = propBag;
                // dangerous?
                length = (int)ms.Length;
                this.ms = ms;
                this.manualUpdate = ctl.GetAxState(AxHost.manualUpdate);
                this.licenseKey = ctl.GetLicenseKey();
            }

            internal State(PropertyBagStream propBag) {
                this.propBag = propBag;
            }

            internal State(MemoryStream ms) {
                this.ms = ms;
                this.length = (int)ms.Length;
                InitializeFromStream(ms);
            }

            // create on init new w/ storage...
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal State(AxHost ctl) {
                CreateStorage();
                manualUpdate = ctl.GetAxState(AxHost.manualUpdate);
                licenseKey = ctl.GetLicenseKey();
                type = STG_STORAGE;
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.State.State2"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public State(Stream ms, int storageType, bool manualUpdate, string licKey) {
                type = storageType;
                // dangerous?
                length = (int)ms.Length;
                this.manualUpdate = manualUpdate;
                this.licenseKey = licKey;

                InitializeBufferFromStream(ms);
            }

            /**
             * Constructor used in deserialization
             */
            internal State(SerializationInfo info, StreamingContext context) {
                SerializationInfoEnumerator sie = info.GetEnumerator();
                if (sie == null) {
                    return;
                }
                for (; sie.MoveNext();) {
                    if (String.Compare(sie.Name, "Data", true, CultureInfo.InvariantCulture) == 0) {
                        try {
                            byte[] dat = (byte[])sie.Value;
                            if (dat != null) {
                                InitializeFromStream(new MemoryStream(dat));
                            }

                        }
                        catch (Exception e) {
                            Debug.Fail("failure: " + e.ToString());
                        }
                    }
                    else if (String.Compare(sie.Name, "PropertyBagBinary", true, CultureInfo.InvariantCulture) == 0) {
                        try {
                            Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Loading up property bag from stream...");
                            byte[] dat = (byte[])sie.Value;
                            if (dat != null) {
                                this.propBag = new PropertyBagStream();
                                propBag.Read(new MemoryStream(dat));
                            }

                        }
                        catch (Exception e) {
                            Debug.Fail("failure: " + e.ToString());
                        }
                    }
                }
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal int Type {
                get {
                    return type;
                }
                set {
                    type = value;
                }
            }

            internal bool _GetManualUpdate() {
                return manualUpdate;
            }

            internal string _GetLicenseKey() {
                return licenseKey;
            }

            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            private void CreateStorage() {
                Debug.Assert(storage == null, "but we already have a storage!!!");
                IntPtr hglobal = IntPtr.Zero;
                if (buffer != null) {
                    hglobal = UnsafeNativeMethods.GlobalAlloc(NativeMethods.GMEM_MOVEABLE, length);
                    IntPtr pointer = UnsafeNativeMethods.GlobalLock(new HandleRef(null, hglobal));
                    try {
                        if (pointer != IntPtr.Zero) {
                            Marshal.Copy(buffer, 0, pointer, length);
                        }
                    }
                    finally {
                        UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, hglobal));
                    }
                }
                try {
                    iLockBytes = UnsafeNativeMethods.CreateILockBytesOnHGlobal(new HandleRef(null, hglobal), true);
                    if (buffer == null) {
                        storage = UnsafeNativeMethods.StgCreateDocfileOnILockBytes(iLockBytes,
                                                                                   NativeMethods.STGM_CREATE | NativeMethods.STGM_READWRITE | NativeMethods.STGM_SHARE_EXCLUSIVE, 0);
                    }
                    else {
                        storage = UnsafeNativeMethods.StgOpenStorageOnILockBytes(iLockBytes,
                                                                                 null, NativeMethods.STGM_READWRITE | NativeMethods.STGM_SHARE_EXCLUSIVE, 0, 0);
                    }
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                    if (iLockBytes == null && hglobal != IntPtr.Zero) {
                        UnsafeNativeMethods.GlobalFree(new HandleRef(null, hglobal));
                    }
                    else {
                        iLockBytes = null;
                    }
                    storage = null;
                }
            }

            internal UnsafeNativeMethods.IPropertyBag GetPropBag() {
                return propBag;
            }

            internal UnsafeNativeMethods.IStorage GetStorage() {
                if (storage == null)
                    CreateStorage();
                return storage;
            }

           internal UnsafeNativeMethods.IStream GetStream() {
                if (ms == null) {
                    Debug.Assert(buffer != null, "gotta have the buffer already...");
                    if (buffer == null) return null;
                    ms = new MemoryStream(buffer);
                }
                else {
                    ms.Seek(0, SeekOrigin.Begin);
                }
                return new UnsafeNativeMethods.ComStreamFromDataStream(ms);
            }

            private void InitializeFromStream(Stream ids) {
               BinaryReader br = new BinaryReader(ids);
            
               type = br.ReadInt32();
               int version = br.ReadInt32();
               manualUpdate = br.ReadBoolean();
               int cc = br.ReadInt32();
               if (cc != 0) {
                   licenseKey = new string(br.ReadChars(cc));
               }
               for (int skipUnits = br.ReadInt32(); skipUnits > 0; skipUnits --) {
                   int len = br.ReadInt32();
                   ids.Position = ids.Position + len;
               }
            
               length = br.ReadInt32();
               if (length > 0)
                   buffer = br.ReadBytes(length);
            }

            private void InitializeBufferFromStream(Stream ids) {
                BinaryReader br = new BinaryReader(ids);

                length = br.ReadInt32();
                if (length > 0)
                    buffer = br.ReadBytes(length);
            }

            internal State RefreshStorage(UnsafeNativeMethods.IPersistStorage iPersistStorage) {
                Debug.Assert(storage != null, "how can we not have a storage object?");
                Debug.Assert(iLockBytes != null, "how can we have a storage w/o ILockBytes?");
                if (storage == null || iLockBytes == null) return null;
                iPersistStorage.Save(storage, 1);
                storage.Commit(0);
                iPersistStorage.HandsOffStorage();
                try {
                    buffer = null;
                    ms = null;
                    NativeMethods.STATSTG stat = new NativeMethods.STATSTG();
                    iLockBytes.Stat(stat, NativeMethods.Ole.STATFLAG_NONAME);
                    length = (int) stat.cbSize;
                    buffer = new byte[length];
                    IntPtr hglobal = UnsafeNativeMethods.GetHGlobalFromILockBytes(iLockBytes);
                    IntPtr pointer = UnsafeNativeMethods.GlobalLock(new HandleRef(null, hglobal));
                    try {
                        if (pointer != IntPtr.Zero) {
                            Marshal.Copy(pointer, buffer, 0, length);
                        }
                        else {
                            length = 0;
                            buffer = null;
                        }
                    }
                    finally {
                        UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, hglobal));
                    }
                }
                finally {
                    iPersistStorage.SaveCompleted(storage);
                }
                return this;
            }

            internal void Save(MemoryStream stream) {
                BinaryWriter bw = new BinaryWriter(stream);

                bw.Write(type);
                bw.Write(VERSION);
                bw.Write(manualUpdate);
                if (licenseKey != null) {
                    bw.Write(licenseKey.Length);
                    bw.Write(licenseKey.ToCharArray());
                }
                else {
                    bw.Write((int)0);
                }
                bw.Write((int)0); // skip units
                bw.Write(length);
                if (buffer != null) {
                    bw.Write(buffer);
                }
                else if (ms != null) {
                    ms.Position = 0;
                    ms.WriteTo(stream);
                }
                else {
                    Debug.Assert(length == 0, "if we have no data, then our length has to be 0");
                }
            }

            /// <include file='doc\AxHost.uex' path='docs/doc[@for="State.ISerializable.GetObjectData"]/*' />
            /// <devdoc>
            /// ISerializable private implementation
            /// </devdoc>
            /// <internalonly/>
            void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
                IntSecurity.UnmanagedCode.Demand();
                MemoryStream stream = new MemoryStream();
                Save(stream);

                si.AddValue("Data", stream.ToArray());

                if (propBag != null) {
                    try {
                        stream = new MemoryStream();
                        propBag.Write(stream);
                        si.AddValue("PropertyBagBinary", stream.ToArray());
                    }
                    catch (Exception e) {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Failed to serialize the property bag into ResX : " + e.ToString());
                    }
                }
            }
        }

        internal class PropertyBagStream : UnsafeNativeMethods.IPropertyBag {
            private Hashtable bag = new Hashtable();

            internal void Read(Stream stream) {
                BinaryFormatter formatter = new BinaryFormatter();
                try {
                    bag = (Hashtable)formatter.Deserialize(stream);
                }
                catch {
                    // Error reading.  Just init an empty hashtable.
                    bag = new Hashtable();
                }
            }

            int UnsafeNativeMethods.IPropertyBag.Read(string pszPropName, ref object pVar, UnsafeNativeMethods.IErrorLog pErrorLog) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Reading property " + pszPropName +  " from OCXState propertybag.");
                
                if (!bag.Contains(pszPropName))
                    return NativeMethods.E_INVALIDARG;

                pVar = bag[pszPropName];
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\tValue=" + ((pVar == null) ? "<null>" : pVar.ToString()));

                // The EE returns a VT_EMPTY for a null. The problem is that visual basic6 expects the caller to respect the
                // "hint" it gives in the VariantType. For eg., for a VT_BSTR, it expects that the callee will null
                // out the BSTR field of the variant. Since, the EE or us cannot do anything about this, we will return
                // a E_INVALIDARG rather than let visual basic6 crash.
                //
                return (pVar == null) ? NativeMethods.E_INVALIDARG : NativeMethods.S_OK;
            }

            int UnsafeNativeMethods.IPropertyBag.Write(string pszPropName, ref object pVar) {
                Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "Writing property " + pszPropName + " [" + pVar + "] into OCXState propertybag.");
                if (pVar != null && !pVar.GetType().IsSerializable) {
                    Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "\t " + pVar.GetType().FullName + " is not serializable.");
                    return NativeMethods.S_OK;
                }
                
                bag[pszPropName] = pVar;
                return NativeMethods.S_OK;
            }

            internal void Write(Stream stream) {
                BinaryFormatter formatter = new BinaryFormatter();
                formatter.Serialize(stream, bag);
            }
        }

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AboutBoxDelegate"]/*' />
        protected delegate void AboutBoxDelegate();

        /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxComponentEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class AxComponentEditor : WindowsFormsComponentEditor {
            /// <include file='doc\AxHost.uex' path='docs/doc[@for="AxHost.AxComponentEditor.EditComponent"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override bool EditComponent(ITypeDescriptorContext context, object obj, IWin32Window parent) {
                if (obj is AxHost) {
                    AxHost host = (AxHost)obj;
                    try {
                        Debug.WriteLineIf(AxHTraceSwitch.TraceVerbose, "in AxComponentEditor.EditComponent");
                        ((UnsafeNativeMethods.IOleControlSite)host.oleSite).ShowPropertyFrame();
                        return true;
                    }
                    catch (Exception t) {
                        Debug.Fail(t.ToString());
                        throw t;
                    }
                }

                return false;
            }
        }

        /// <devdoc>
        /// </devdoc>
        internal class AxPropertyDescriptor : PropertyDescriptor {
            private  PropertyDescriptor baseProp;
            internal AxHost            owner;
            private  DispIdAttribute   dispid;
            private  bool              updatedEditorAndConverter = false;
            private  TypeConverter     converter;
            private  UITypeEditor      editor;
            private  ArrayList         updateAttrs = new ArrayList();
            private  bool              checkGetter;
            private  bool              getterThrew = false;
            private  bool              ignoreCanAccessProperties = false;
            private  bool              settingValue = false;

            internal AxPropertyDescriptor(PropertyDescriptor baseProp, AxHost owner) : base(baseProp) {
                this.baseProp = baseProp;
                this.owner = owner;

                // Get the category for this dispid.
                //
                dispid = (DispIdAttribute)baseProp.Attributes[typeof(DispIdAttribute)];
                if (dispid != null) {
                    // Look to see if this property has a property page.
                    // If it does, then it needs to be Browsable(true).
                    //
                    if (!this.IsBrowsable && !this.IsReadOnly) {
                        Guid g = GetPropertyPage(dispid.Value);
    
                        if (!Guid.Empty.Equals(g)) {
                           Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Making property: " + this.Name + " browsable because we found an property page.");
                           AddAttribute(new BrowsableAttribute(true));
                        }
                    }
                    
                    // Use the CategoryAttribute provided by the OCX.
                    //
                    CategoryAttribute cat = owner.GetCategoryForDispid(dispid.Value);
                    if (cat != null) {
                        AddAttribute(cat);
                    }

                    // Check to see if this a DataSource property.
                    // If it is, we can always get and set the value of this property.
                    //
                    if (this.PropertyType.GUID.Equals(dataSource_Guid)) {
                        ignoreCanAccessProperties = true;
                    }
                }
            }
            
            public override Type ComponentType {
                get {
                    return baseProp.ComponentType;
                }
            }

            public override TypeConverter Converter {
                get {
                    UpdateTypeConverterAndTypeEditor(false, dispid.Value);

                    return (converter != null) ? converter : base.Converter;
                }
            }

            internal int Dispid {
                get {
                    DispIdAttribute dispid = (DispIdAttribute)baseProp.Attributes[typeof(DispIdAttribute)];
                    if (dispid != null) {
                        return dispid.Value;
                    }

                    return NativeMethods.ActiveX.DISPID_UNKNOWN;
                }
            }
            
            public override bool IsReadOnly {
                get {
                    return baseProp.IsReadOnly;
                }
            }
            
            public override Type PropertyType {
                get {
                    return baseProp.PropertyType;
                }
            }

            internal bool SettingValue {
                get {
                    return settingValue;
                }
            }
            
            private void AddAttribute(Attribute attr) {
                updateAttrs.Add(attr);
            }

            public override bool CanResetValue(object o) {
                return baseProp.CanResetValue(o);
            }

            public override object GetEditor(Type editorBaseType) {
                UpdateTypeConverterAndTypeEditor(false, dispid.Value);

                if (editorBaseType.Equals(typeof(UITypeEditor)) && editor != null) {
                    return editor;
                }

                return base.GetEditor(editorBaseType);
            }

            private Guid GetPropertyPage(int dispid) {
                try {
                    NativeMethods.IPerPropertyBrowsing ippb = owner.GetPerPropertyBrowsing();
                    if (ippb == null) return Guid.Empty;
                    Guid rval;
                    if (NativeMethods.Succeeded(ippb.MapPropertyToPage(dispid, out rval))) {
                        return rval;
                    }
                }
                catch (COMException) {
                }
                catch (Exception t) {
                    Debug.Fail(t.ToString());
                }
                return Guid.Empty;
            }

            public override object GetValue(object component) {
                if ((!ignoreCanAccessProperties && !owner.CanAccessProperties) || getterThrew) {
                    return null;
                }

                try {
                    // Some controls fire OnChanged() notifications when getting values of some properties. ASURT 20190.
                    // To prevent this kind of recursion, we check to see if we are already inside a OnChanged() call.
                    //
                    owner.NoComponentChangeEvents++;
                    return baseProp.GetValue(component);
                }
                catch (Exception e) {
                    if (!checkGetter) {
                        Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Get failed for : " + Name + " with exception: " + e.Message + " .Making property non-browsable.");
                        checkGetter = true;
                        AddAttribute(new BrowsableAttribute(false));
                        owner.RefreshAllProperties = true;
                        getterThrew = true;
                    }
                    throw e;
                }
                finally {
                    owner.NoComponentChangeEvents--;
                }
            }

            public void OnValueChanged(object component) {
                this.OnValueChanged(component, EventArgs.Empty);
            }
            
            public override void ResetValue(object o) {
                baseProp.ResetValue(o);
            }

            public override void SetValue(Object component, Object value) {
                if (!ignoreCanAccessProperties && !owner.CanAccessProperties) {
                    return;
                }

                // State oldOcxState = owner.OcxState;

                try {
                    settingValue = true;
                    if (this.PropertyType.IsEnum && (value.GetType() != this.PropertyType)) {
                        baseProp.SetValue(component, Enum.ToObject(this.PropertyType, value));
                    }
                    else {
                        baseProp.SetValue(component, value);
                    }
                }
                finally {
                    settingValue = false;
                }

                OnValueChanged(component);
                if (owner == component) {
                    owner.SetAxState(AxHost.valueChanged, true);
                }
            }
            
            public override bool ShouldSerializeValue(object o) {
                return baseProp.ShouldSerializeValue(o);
            }

            internal void UpdateAttributes() {
                if (updateAttrs.Count == 0)
                    return;
                
                ArrayList attributes = new ArrayList(AttributeArray);
                foreach(Attribute attr in updateAttrs) {
                    attributes.Add(attr);
                }
                
                Attribute[] temp = new Attribute[attributes.Count];
                attributes.CopyTo(temp, 0);
                AttributeArray = temp;
                
                updateAttrs.Clear();
            }

            internal void UpdateTypeConverterAndTypeEditor(bool force, int dispid) {
                if (updatedEditorAndConverter && !force)
                    return;
                
                if (owner.GetOcx() == null)
                    return;

                try {
                    NativeMethods.IPerPropertyBrowsing ppb = owner.GetPerPropertyBrowsing();

                    if (ppb != null) {
                        bool hasStrings = false;

                        // check for enums
                        NativeMethods.CA_STRUCT caStrings = new NativeMethods.CA_STRUCT();
                        NativeMethods.CA_STRUCT caCookies = new NativeMethods.CA_STRUCT();

                        int hr = NativeMethods.S_OK;

                        try {
                            hr = ppb.GetPredefinedStrings(dispid, caStrings, caCookies);
                        }
                        catch(ExternalException ex) {
                            hr = ex.ErrorCode;
                            Debug.Fail("An exception occurred inside IPerPropertyBrowsing::GetPredefinedStrings(dispid=" +
                                       dispid + "), object type=" + new ComNativeDescriptor().GetClassName(ppb));
                        }


                        if (hr != NativeMethods.S_OK) {
                            hasStrings = false;
                            // Destroy the existing editor if we created the current one
                            // so if the items have disappeared, we don't hold onto the old
                            // items.
                            if (converter is Com2EnumConverter) {
                                converter = null;
                            }
                        }
                        else {
                            hasStrings = true;
                        }

                        if (hasStrings) {
                            OleStrCAMarshaler stringMarshaler = new OleStrCAMarshaler(caStrings);
                            Int32CAMarshaler  intMarshaler = new Int32CAMarshaler(caCookies);

                            if (stringMarshaler.Count > 0 && intMarshaler.Count > 0) {
                                if (converter == null) {
                                    converter = new Com2EnumConverter(new AxPerPropertyBrowsingEnum(this, owner, stringMarshaler, intMarshaler, true));
                                }
                                else if (converter is Com2EnumConverter){
                                    ((Com2EnumConverter)converter).RefreshValues();
                                    AxPerPropertyBrowsingEnum axEnum = ((Com2EnumConverter)converter).com2Enum as AxPerPropertyBrowsingEnum;
                                    if (axEnum != null) {
                                        axEnum.RefreshArrays(stringMarshaler, intMarshaler);
                                    }

                                }
                                
                            }
                            else {
                                //hasStrings = false;
                            }
                        }
                        else {
                            // if we didn't get any strings, try the proppage edtior
                            //
                            // Check to see if this is a property that we have already massaged to be a 
                            // .Net type. If it is, don't bother with custom property pages. We already
                            // have a .Net Editor for this type.
                            //
                            ComAliasNameAttribute comAlias = (ComAliasNameAttribute)baseProp.Attributes[typeof(ComAliasNameAttribute)];
                            if (comAlias == null) {
                                Guid g = GetPropertyPage(dispid);

                                if (!Guid.Empty.Equals(g)) {
                                   editor = new AxPropertyTypeEditor(this, g);
                                
                                   // Show any non-browsable property that has an editor through a 
                                   // property page.
                                   //
                                   if (!this.IsBrowsable) {
                                       Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "Making property: " + this.Name + " browsable because we found an editor.");
                                       AddAttribute(new BrowsableAttribute(true));
                                   }
                                }
                            }
                        }
                    }

                    updatedEditorAndConverter = true;
                 }
                 catch (Exception e) {
                     Debug.WriteLineIf(AxPropTraceSwitch.TraceVerbose, "could not get the type editor for property: " + this.Name + " Exception: " + e);
                 }
            }
        }

        private class AxPropertyTypeEditor : UITypeEditor {
            private AxPropertyDescriptor propDesc;
            private Guid guid;

            public AxPropertyTypeEditor(AxPropertyDescriptor pd, Guid guid) {
                propDesc = pd;
                this.guid = guid;
            }

            /// <include file='doc\AxPropertyTypeEditor.uex' path='docs/doc[@for="AxPropertyTypeEditor.EditValue"]/*' />
            /// <devdoc>
            ///     Takes the value returned from valueAccess.getValue() and modifies or replaces
            ///     the value, passing the result into valueAccess.setValue().  This is where
            ///     an editor can launch a modal dialog or create a drop down editor to allow
            ///     the user to modify the value.  Host assistance in presenting UI to the user
            ///     can be found through the valueAccess.getService function.
            /// </devdoc>
            public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
                try {
                    object instance = context.Instance;
                    propDesc.owner.ShowPropertyPageForDispid(propDesc.Dispid, this.guid);
                }
                catch (Exception ex1) {
                    if (provider != null) {
                          IUIService uiSvc = (IUIService)provider.GetService(typeof(IUIService));
                          if (uiSvc != null){
                            uiSvc.ShowError(ex1, SR.GetString(SR.ErrorTypeConverterFailed));
                          }
                    }
                }
                return value;
            }

            /// <devdoc>
            ///      Retrieves the editing style of the Edit method.  If the method
            ///      is not supported, this will return None.
            /// </devdoc>
            public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
                return UITypeEditorEditStyle.Modal;
            }
        }
        
        // This exists for perf reasons.   We delay doing this until we
        // are actually asked for the array of values. 
        // 
        private class AxPerPropertyBrowsingEnum : Com2Enum {
            private AxPropertyDescriptor target;
            private AxHost               owner;
            private OleStrCAMarshaler    nameMarshaller;
            private Int32CAMarshaler     valueMarshaller;
            private bool                 arraysFetched;
        
            public AxPerPropertyBrowsingEnum(AxPropertyDescriptor targetObject, AxHost owner, OleStrCAMarshaler names, Int32CAMarshaler values, bool allowUnknowns) : base(new string[0], new object[0], allowUnknowns) {
                this.target = targetObject;
                this.nameMarshaller = names;
                this.valueMarshaller = values;
                this.owner = owner;
                this.arraysFetched = false;
            }
        
            /// <include file='doc\AxPerPropertyBrowsingEnum.uex' path='docs/doc[@for="AxHost.AxPerPropertyBrowsingEnum.Values"]/*' />
            /// <devdoc>
            /// Retrieve a copy of the value array
            /// </devdoc>
            public override object[] Values {
                get {
                    EnsureArrays();
                    return base.Values;
                }
            }
        
            /// <devdoc>
            /// Retrieve a copy of the nme array.
            /// </devdoc>
            public override string[] Names {
                get {
                    EnsureArrays();
                    return base.Names;
                }
            }
        
            // ensure that we have processed the caStructs into arrays
            // of values and strings
            //
            private void EnsureArrays() {
                if (this.arraysFetched) {
                    return;
                }
        
                this.arraysFetched = true;
        
                try {
        
                    // marshal the items.
                    object[] nameItems = nameMarshaller.Items;
                    object[] cookieItems=   valueMarshaller.Items;
                    NativeMethods.IPerPropertyBrowsing ppb = (NativeMethods.IPerPropertyBrowsing)owner.GetPerPropertyBrowsing();
                    int itemCount = 0;
        
                    Debug.Assert(cookieItems != null && nameItems != null, "An item array is null");
        
                    if (nameItems.Length > 0) {
                        object[] valueItems = new object[cookieItems.Length];
                        NativeMethods.VARIANT var = new NativeMethods.VARIANT();
                        int cookie;
        
                        Debug.Assert(cookieItems.Length == nameItems.Length, "Got uneven names and cookies");
        
                        // for each name item, we ask the object for it's corresponding value.
                        //
                        for (int i = 0; i < nameItems.Length; i++) {
                            cookie = (int)cookieItems[i];
                            if (nameItems[i] == null || !(nameItems[i] is string)) {
                                Debug.Fail("Bad IPerPropertyBrowsing item [" + i.ToString() + "], name=" + (nameItems == null ? "(unknown)" : nameItems[i].ToString()));
                                continue;
                            }
                            var.vt = (short)NativeMethods.tagVT.VT_EMPTY;
                            int hr = ppb.GetPredefinedValue(target.Dispid, cookie, var);
                            if (hr == NativeMethods.S_OK && var.vt != (short)NativeMethods.tagVT.VT_EMPTY) {
                                valueItems[i] = var.ToObject();
                            }
                            var.Clear();
                            itemCount++;
                        }
        
                        // pass this data down to the base Com2Enum object... 
                        if (itemCount > 0) {
                            string[] strings = new string[itemCount];
                            Array.Copy(nameItems, 0, strings, 0, itemCount);
                            base.PopulateArrays(strings, valueItems);
                        }
                    }
                }
                catch (Exception ex) {
                    Debug.Fail("Failed to build IPerPropertyBrowsing editor. " + ex.GetType().Name + ", " + ex.Message);
                }
        
            }
            
            internal void RefreshArrays( OleStrCAMarshaler names, Int32CAMarshaler values) {
                this.nameMarshaller = names;
                this.valueMarshaller = values;
                this.arraysFetched = false;
            }
        
            private string GetDisplayString(int dispid, ref bool success) {
                NativeMethods.IPerPropertyBrowsing ppb = (NativeMethods.IPerPropertyBrowsing)owner.GetPerPropertyBrowsing();
                string[] strVal = new string[1];
                int hr = ppb.GetDisplayString(dispid, strVal);
                if (hr == NativeMethods.S_OK) {
                    success = (strVal[0] != null);
                    //Debug.Assert(success, "IPerPropertyBrowsing::GetDisplayString returned NULL and S_OK -- this is not a valid state. This component does not property implement IPerPropertyBrowsing. (component class=" + TypeDescriptor.GetClassName(ppb) + ")");
                    return strVal[0];
                }
                else {
                    success = false;
                }   
                return null;
            }
        
            protected override void PopulateArrays(string[] names, object[] values) {
                // we call base.PopulateArrays directly when we actually want to do this.
            }
        
            public override object FromString(string s) {
                EnsureArrays();
                return base.FromString(s);
            }
        
            public override string ToString(object v) {
                EnsureArrays();
                return base.ToString(v);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\buttonbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.Drawing.Imaging;
    using System;
    using System.Security.Permissions;
    using System.Drawing.Drawing2D;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Implements the basic functionality required by a button control.
    ///    </para>
    /// </devdoc>
    public abstract class ButtonBase : Control {
        static readonly ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;
        static readonly ContentAlignment anyLeft   = ContentAlignment.TopLeft | ContentAlignment.MiddleLeft | ContentAlignment.BottomLeft;
        static readonly ContentAlignment anyTop    = ContentAlignment.TopLeft | ContentAlignment.TopCenter | ContentAlignment.TopRight;
        static readonly ContentAlignment anyBottom = ContentAlignment.BottomLeft | ContentAlignment.BottomCenter | ContentAlignment.BottomRight;
        static readonly ContentAlignment anyCenter = ContentAlignment.TopCenter | ContentAlignment.MiddleCenter | ContentAlignment.BottomCenter;
        // WARNING static readonly ContentAlignment anyMiddle = ContentAlignment.MiddleLeft | ContentAlignment.MiddleCenter | ContentAlignment.MiddleRight;
        bool isDefault;
        bool inButtonUp;
        bool mouseOver;
        bool mouseDown;
        bool mousePressed;
        FlatStyle flatStyle = System.Windows.Forms.FlatStyle.Standard;
        ContentAlignment imageAlign = ContentAlignment.MiddleCenter;
        ContentAlignment textAlign = ContentAlignment.MiddleCenter;
        int imageIndex = -1;
        ImageList imageList;
        Image image;
        bool currentlyAnimating;
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ButtonBase"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ButtonBase'/> class.
        ///       
        ///    </para>
        /// </devdoc>
        protected ButtonBase() {
            // If Button doesn't want double-clicks, we should introduce a StandardDoubleClick style.
            // Checkboxes probably one double-click's (#26120), and RadioButtons certainly do
            // (useful e.g. on a Wizard).
            SetStyle( ControlStyles.SupportsTransparentBackColor | 
                      ControlStyles.Opaque | 
                      ControlStyles.ResizeRedraw |
                      ControlStyles.DoubleBuffer |
                      ControlStyles.CacheText | // We gain about 2% in painting by avoiding extra GetWindowText calls
                      ControlStyles.StandardClick,
                      true);

            SetStyle(ControlStyles.UserMouse |
                     ControlStyles.UserPaint, OwnerDraw);
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(75, 23);
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.CreateParams"]/*' />
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                if (!OwnerDraw) {
                    cp.ExStyle &= ~NativeMethods.WS_EX_RIGHT;   // WS_EX_RIGHT overrides the BS_XXXX alignment styles
                    
                    cp.Style |= NativeMethods.BS_MULTILINE;
                    
                    if (IsDefault) {
                        cp.Style |= NativeMethods.BS_DEFPUSHBUTTON;
                    }

                    ContentAlignment align = RtlTranslateContent(TextAlign);                              
                              
                    if ((int)(align & anyLeft) != 0) {
                        cp.Style |= NativeMethods.BS_LEFT;
                    }
                    else if ((int)(align & anyRight) != 0) {
                        cp.Style |= NativeMethods.BS_RIGHT;
                    }
                    else {
                        cp.Style |= NativeMethods.BS_CENTER;
                    
                    }
                    if ((int)(align & anyTop) != 0) {
                        cp.Style |= NativeMethods.BS_TOP;
                    }
                    else if ((int)(align & anyBottom) != 0) {
                        cp.Style |= NativeMethods.BS_BOTTOM;
                    }
                    else {
                        cp.Style |= NativeMethods.BS_VCENTER;
                    }
                }
                return cp;
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.IsDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsDefault {
            get {
                return isDefault;
            }
            set {
                if (isDefault != value) {
                    isDefault = value;
                    if (IsHandleCreated) {
                        if (OwnerDraw) {
                            Invalidate();
                        }
                        else {
                            UpdateStyles();
                        }
                    }
                }
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.FlatStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets
        ///       the flat style appearance of the button control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(FlatStyle.Standard),
        Localizable(true),
        SRDescription(SR.ButtonFlatStyleDescr)
        ]
        public FlatStyle FlatStyle {
            get {
                return flatStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(FlatStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FlatStyle));
                }
                flatStyle = value;
                Invalidate();
                UpdateOwnerDraw();
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.Image"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image
        ///       that is displayed on a button control.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.ButtonImageDescr),
        Localizable(true),
        SRCategory(SR.CatAppearance)
        ]
        public Image Image {
            get {
                if (image == null && imageList != null && ImageIndex >= 0) {
                    return imageList.Images[ImageIndex];
                }
                else {
                    return image;
                }
            }
            set {
                if (Image != value) {
                    StopAnimate();

                    image = value;
                    if (image != null) {
                        ImageIndex = -1;
                        ImageList = null;
                    }

                    Animate();
                    Invalidate();
                }
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ImageAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the alignment of the image on the button control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(ContentAlignment.MiddleCenter),
        Localizable(true),
        SRDescription(SR.ButtonImageAlignDescr),
        SRCategory(SR.CatAppearance)
        ]
        public ContentAlignment ImageAlign {
            get {
                return imageAlign;
            }
            set {

                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }
                imageAlign = value;
                Invalidate();
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ImageIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image list index value of the image
        ///       displayed on the button control.
        ///    </para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        Localizable(true),
        DefaultValue(-1),
        SRDescription(SR.ButtonImageIndexDescr),
        SRCategory(SR.CatAppearance)
        ]
        public int ImageIndex {
            get {
                if (imageIndex != -1 && imageList != null && imageIndex >= imageList.Images.Count) {
                    return imageList.Images.Count - 1;
                }
                return imageIndex;
            }
            set {
                if (value < -1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "-1"));
                }
                if (imageIndex != value) {
                    if (value != -1) {
                        // Image.set calls ImageIndex = -1
                        image = null;
                    }
                    imageIndex = value;
                    Invalidate();
                }
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ImageList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.ImageList'/> that contains the <see cref='System.Drawing.Image'/> displayed on a button control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRDescription(SR.ButtonImageListDescr),
        SRCategory(SR.CatAppearance)
        ]
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (imageList != value) {
                    EventHandler recreateHandler = new EventHandler(ImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    // Detach old event handlers
                    //
                    if (imageList != null) {
                        imageList.RecreateHandle -= recreateHandler;
                        imageList.Disposed -= disposedHandler;                        
                    }

                    // Make sure we don't have an Image as well as an ImageList
                    //
                    if (value != null) {
                        image = null; // Image.set calls ImageList = null
                    }

                    imageList = value;

                    // Wire up new event handlers
                    //
                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;                                               
                    }                    
                    
                    Invalidate();
                }
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <devdoc>
        ///     <para>
        ///         The area of the button encompassing any changes between the button's
        ///     resting appearance and its appearance when the mouse is over it.
        ///     </para>
        ///     <para>
        ///         Consider overriding this property if you override any painting methods,
        ///     or your button may not paint correctly or may have flicker. Returning
        ///     ClientRectangle is safe for correct painting but may still cause flicker.
        ///     </para>
        /// </devdoc>
        internal virtual Rectangle OverChangeRectangle {
            get {
                if (FlatStyle == FlatStyle.Standard) {
                    // this Rectangle will cause no Invalidation
                    // can't use Rectangle.Empty because it will cause Invalidate(ClientRectangle)
                    return new Rectangle(-1, -1, 1, 1);
                }
                else {
                    return ClientRectangle;
                }
            }
        }
        
        internal bool OwnerDraw {
            get {
                return FlatStyle != FlatStyle.System;
            }
        }

        /// <devdoc>
        ///     <para>
        ///         The area of the button encompassing any changes between the button's
        ///     appearance when the mouse is over it but not pressed and when it is pressed.
        ///     </para>
        ///     <para>
        ///         Consider overriding this property if you override any painting methods,
        ///     or your button may not paint correctly or may have flicker. Returning
        ///     ClientRectangle is safe for correct painting but may still cause flicker.
        ///     </para>
        /// </devdoc>
        internal virtual Rectangle DownChangeRectangle {
            get {
                return ClientRectangle;
            }
        }

        internal bool MouseIsPressed {
            get {
                return mousePressed;
            }
        }

        // a "smart" version of mouseDown for Appearance.Button CheckBoxes & RadioButtons
        // for these, instead of being based on the actual mouse state, it's based on the appropriate button state
        internal bool MouseIsDown {
            get {
                return mouseDown;
            }
        }

        // a "smart" version of mouseOver for Appearance.Button CheckBoxes & RadioButtons
        // for these, instead of being based on the actual mouse state, it's based on the appropriate button state
        internal bool MouseIsOver {
            get {
                return mouseOver;
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.TextAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the alignment of the text on the button control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(ContentAlignment.MiddleCenter),
        Localizable(true),
        SRDescription(SR.ButtonTextAlignDescr),
        SRCategory(SR.CatAppearance)
        ]
        public virtual ContentAlignment TextAlign {
            get {
                return textAlign;
            }
            set {
                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }
                textAlign = value;
                if (OwnerDraw) {
                    Invalidate();
                }
                else {
                    UpdateStyles();
                }
            }
        }

        private void Animate() {
            Animate(Visible && Enabled && ParentInternal != null);
        }

        private void StopAnimate() {
            Animate(false);
        }

        private void Animate(bool animate) {
            if (animate != this.currentlyAnimating) {
                if (animate) {
                    if (this.image != null) {
                        ImageAnimator.Animate(this.image, new EventHandler(this.OnFrameChanged));
                        this.currentlyAnimating = animate;
                    }
                }
                else {
                    if (this.image != null) {
                        ImageAnimator.StopAnimate(this.image, new EventHandler(this.OnFrameChanged));
                        this.currentlyAnimating = animate;
                    }
                }
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.CreateAccessibilityInstance"]/*' />
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new ButtonBaseAccessibleObject(this);
        }

        private void DetachImageList(object sender, EventArgs e) {
            ImageList = null;
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                StopAnimate();
                if (imageList != null) {
                    imageList.Disposed -= new EventHandler(this.DetachImageList);
                }
            }
            base.Dispose(disposing);
        }

        private void ImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                Invalidate();
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnGotFocus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnGotFocus'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnGotFocus(EventArgs e) {
            base.OnGotFocus(e);
            if (ShowFocusCues) {
                Invalidate();
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnLostFocus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnLostFocus'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnLostFocus(EventArgs e) {
            base.OnLostFocus(e);

            // Hitting tab while holding down the space key. See ASURT 38669.
            mouseDown = false;
            CaptureInternal = false;

            Invalidate();
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnMouseEnter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseEnter'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseEnter(EventArgs eventargs) {
            Debug.Assert(Enabled, "ButtonBase.OnMouseEnter should not be called if the button is disabled");
            mouseOver = true;
            Invalidate(OverChangeRectangle);
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnMouseEnter(eventargs);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnMouseLeave"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseLeave'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseLeave(EventArgs eventargs) {
            mouseOver = false;
            Invalidate(OverChangeRectangle);
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnMouseLeave(eventargs);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnMouseMove"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseMove'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs mevent) {
            Debug.Assert(Enabled, "ButtonBase.OnMouseMove should not be called if the button is disabled");
            if (mevent.Button != MouseButtons.None && mousePressed) {
                Rectangle r = ClientRectangle;
                if (!r.Contains(mevent.X, mevent.Y)) {
                    if (mouseDown) {
                        mouseDown = false;
                        Invalidate(DownChangeRectangle);
                    }
                }
                else {
                    if (!mouseDown) {
                        mouseDown = true;
                        Invalidate(DownChangeRectangle);
                    }
                }
            }
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnMouseMove(mevent);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnMouseDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.OnMouseDown'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs mevent) {
            Debug.Assert(Enabled, "ButtonBase.OnMouseDown should not be called if the button is disabled");
            if (mevent.Button == MouseButtons.Left) {
                mouseDown = true;
                mousePressed = true;
                Invalidate(DownChangeRectangle);
            }
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnMouseDown(mevent);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnMouseUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnMouseUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs mevent) {
            base.OnMouseUp(mevent);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.ResetFlagsandPaint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Used for quick re-painting of the button after the pressed state.
        ///    </para>
        /// </devdoc>
        protected void ResetFlagsandPaint() {
            mousePressed = false;
            mouseDown = false;
            Invalidate(DownChangeRectangle);
            Update();
        }
            
        /// <devdoc>
        ///     Central paint dispatcher to one of the three styles of painting.
        /// </devdoc>
        private void PaintControl(PaintEventArgs pevent) {
        
            Debug.Assert(GetStyle(ControlStyles.UserPaint), "Shouldn't be in PaintControl when control is not UserPaint style");
        
            switch (FlatStyle) {
                case FlatStyle.Standard:
                    PaintStandard(pevent);
                    break;
                case FlatStyle.Popup:
                    PaintPopup(pevent);
                    break;
                case FlatStyle.Flat:
                    PaintFlat(pevent);
                    break;
            }
        }
        
        internal static Brush CreateDitherBrush(Color color1, Color color2) {
            Brush brush;

            using (Bitmap b = new Bitmap(2, 2)) {
                b.SetPixel(0, 0, color1);
                b.SetPixel(0, 1, color2);
                b.SetPixel(1, 1, color1);
                b.SetPixel(1, 0, color2);

                brush = new TextureBrush(b);
            }
            return brush;
        }

        internal static void DrawDitheredFill(Graphics g, Color color1, Color color2, Rectangle bounds) {
            using (Brush brush = CreateDitherBrush(color1, color2)) {
                g.FillRectangle(brush, bounds);
            }
        }

        void Draw3DBorder(Graphics g, Rectangle bounds, ColorData colors, bool raised) {
            if (BackColor != SystemColors.Control && SystemInformation.HighContrast) {
                if (raised) {
                    Draw3DBorderHighContrastRaised(g, ref bounds, colors);
                }
                else {
                    ControlPaint.DrawBorder(g, bounds, ControlPaint.Dark(BackColor), ButtonBorderStyle.Solid);
                }
            }
            else {
                if (raised) {
                    Draw3DBorderRaised(g, ref bounds, colors);
                }
                else {
                    Draw3DBorderNormal(g, ref bounds, colors);
                }
            }
            bounds.Inflate(-2, -2);
        }
        
        private void Draw3DBorderHighContrastRaised(Graphics g, ref Rectangle bounds, ColorData colors) {
            bool stockColor = colors.buttonFace.ToKnownColor() == SystemColors.Control.ToKnownColor();
            // top + left
            Pen pen = stockColor ? SystemPens.ControlLightLight : new Pen(colors.highlight);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X, bounds.Y + bounds.Height - 1);

            // bottom + right
            if (stockColor) {
                pen = SystemPens.ControlDarkDark;
            }
            else {
                pen.Color = colors.buttonShadowDark;
            }
            g.DrawLine(pen, bounds.X, bounds.Y + bounds.Height - 1, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
            g.DrawLine(pen, bounds.X + bounds.Width - 1, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);

            // top + left inset
            if (stockColor) {
                if (SystemInformation.HighContrast) {
                    pen = SystemPens.ControlLight;
                }
                else {
                    pen = SystemPens.Control;
                }
            }
            else {
                if (SystemInformation.HighContrast) {
                    pen.Color = colors.highlight;
                }
                else {
                    pen.Color = colors.buttonFace;
                }
            }
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + 1);
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + 1, bounds.Y + bounds.Height - 2);

            // Bottom + right inset                        
            if (stockColor) {
                pen = SystemPens.ControlDark;
            }
            else {
                pen.Color = colors.buttonShadow;
            }                        

            g.DrawLine(pen, bounds.X + 1, bounds.Y + bounds.Height - 2,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
            g.DrawLine(pen, bounds.X + bounds.Width - 2, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);

            if (!stockColor) {
                pen.Dispose();
            }

            bounds.X += 1;
            bounds.Y += 1;
            bounds.Width -= 3;
            bounds.Height -= 3;
        }
        
        private void Draw3DBorderNormal(Graphics g, ref Rectangle bounds, ColorData colors) {
            // top + left
            Pen pen = new Pen(colors.buttonShadowDark);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X, bounds.Y + bounds.Height - 1);
    
            // bottom + right
            pen.Color = colors.highlight;
            g.DrawLine(pen, bounds.X, bounds.Y + bounds.Height - 1, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
            g.DrawLine(pen, bounds.X + bounds.Width - 1, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
    
            // Top + left inset
            pen.Color = colors.buttonFace;
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + 1);
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + 1, bounds.Y + bounds.Height - 2);
    
            // bottom + right inset
            if (colors.buttonFace.ToKnownColor() == SystemColors.Control.ToKnownColor()) {
                pen.Color = SystemColors.ControlLight;
            }
            else {
                pen.Color = colors.buttonFace;
            }
            g.DrawLine(pen, bounds.X + 1, bounds.Y + bounds.Height - 2,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
            g.DrawLine(pen, bounds.X + bounds.Width - 2, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
    
            pen.Dispose();
        }
        
        private void Draw3DBorderRaised(Graphics g, ref Rectangle bounds, ColorData colors) {
            bool stockColor = colors.buttonFace.ToKnownColor() == SystemColors.Control.ToKnownColor();
            // top + left
            Pen pen = stockColor ? SystemPens.ControlLightLight : new Pen(colors.highlight);

            //g.DrawRectangle(pen, bounds.X, bounds.Y, bounds.Width - 1, bounds.Height - 1);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y);
            g.DrawLine(pen, bounds.X, bounds.Y, 
                              bounds.X, bounds.Y + bounds.Height - 1);

            // bottom + right
            if (stockColor) {
                pen = SystemPens.ControlDarkDark;
            }
            else {
                pen.Color = colors.buttonShadowDark;
            }
            g.DrawLine(pen, bounds.X, bounds.Y + bounds.Height - 1, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
            g.DrawLine(pen, bounds.X + bounds.Width - 1, bounds.Y, 
                              bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);

            // top + left inset
            if (stockColor) {
                if (SystemInformation.HighContrast) {
                    pen = SystemPens.ControlLight;
                }
                else {
                    pen = SystemPens.Control;
                }
            }
            else {
                pen.Color = colors.buttonFace;
            }
            //g.DrawRectangle(pen, bounds.X + 1, bounds.Y+ 1, bounds.Width - 2, bounds.Height - 2);
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + 1);
            g.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                              bounds.X + 1, bounds.Y + bounds.Height - 2);

            // Bottom + right inset                        
            if (stockColor) {
                pen = SystemPens.ControlDark;
            }
            else {
                pen.Color = colors.buttonShadow;
            }                        

            g.DrawLine(pen, bounds.X + 1, bounds.Y + bounds.Height - 2,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
            g.DrawLine(pen, bounds.X + bounds.Width - 2, bounds.Y + 1,
                              bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);

            if (!stockColor) {
                pen.Dispose();
            }
        }

        /// <devdoc>
        ///     Draws a border for the in the 3D style of the popup button.
        /// </devdoc>
        void Draw3DLiteBorder(Graphics g, Rectangle r, ColorData colors, bool up) {
            using (Pen pen = new Pen(colors.highlight)) {

                // top, left
                if (!up) {
                    pen.Color = colors.buttonShadow;
                }
                g.DrawLine(pen, r.Left, r.Top, r.Left, r.Bottom - 1);
                g.DrawLine(pen, r.Left, r.Top, r.Right - 1, r.Top);

                // bottom, right
                if (up) {
                    pen.Color = colors.buttonShadow;
                }
                else {
                    pen.Color = colors.highlight;
                }
                g.DrawLine(pen, r.Right - 1, r.Top, r.Right - 1, r.Bottom - 1);
                g.DrawLine(pen, r.Left, r.Bottom - 1, r.Right - 1, r.Bottom - 1);
            }
        }
        
        internal static void DrawFlatBorder(Graphics g, Rectangle r, Color c) {
            ControlPaint.DrawBorder(g, r, c, ButtonBorderStyle.Solid);
            r.Inflate(-1, -1);
        }

        void DrawFlatFocus(Graphics g, Rectangle r, Color c) {
            r.Width --;
            r.Height--;

            using (Pen focus = new Pen(c)) {
                g.DrawRectangle(focus, r);
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Draws the focus rectangle if the control has focus.
        ///       
        ///    </para>
        /// </devdoc>
        void DrawFocus(Graphics g, Rectangle r) {
            if (Focused && ShowFocusCues) {
                ControlPaint.DrawFocusRectangle(g, r, ForeColor, BackColor);
            }
        }
        
        /// <devdoc>
        ///     Draws the button's image.
        /// </devdoc>
        void DrawImage(Graphics graphics, Rectangle rectangle, Point imageStart) {
            if (Image != null) {

                //adjust for off-by-one
                rectangle.Width += 1;
                rectangle.Height+= 1;
                imageStart.X += 1;
                imageStart.Y += 1;

                //setup new clip region & draw
                DrawImageCore(graphics, Image, imageStart.X, imageStart.Y);

            }
        }

        // here for DropDownButton
        internal virtual void DrawImageCore(Graphics graphics, Image image, int xLoc, int yLoc) {
            if (!Enabled)
                // need to specify width and height
                ControlPaint.DrawImageDisabled(graphics, image, xLoc, yLoc, BackColor);
            else 
                graphics.DrawImage(image, xLoc, yLoc, image.Width, image.Height);
        }

        void DrawDefaultBorder(Graphics g, Rectangle r, Color c) {
            if (isDefault) {
                r.Inflate(1, 1);
                Pen pen;
                if (c.IsSystemColor) {
                    pen = SystemPens.FromSystemColor(c);
                }
                else {
                    pen = new Pen(c);
                }
                g.DrawRectangle(pen, r.X, r.Y, r.Width - 1, r.Height - 1);
                if (!c.IsSystemColor) {
                    pen.Dispose();
                }
            }
        }

        /// <devdoc>
        ///     Draws the button's text.
        /// </devdoc>
        void DrawText(Graphics g, Rectangle r, Color c, ColorData colors, bool disabledText3D) {
            StringFormat stringFormat = new StringFormat();

            // Adjust string format for Rtl controls
            if (RightToLeft == RightToLeft.Yes) {
                stringFormat.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
            }

            // Calculate formats
            // theoretically, should not need to align here, since we've already got GetTextRect,
            //  but since GDI+ can't give us a tight result for that, we align within GetTextRect as well
            stringFormat.Alignment = ControlPaint.TranslateAlignment(textAlign);
            stringFormat.LineAlignment = ControlPaint.TranslateLineAlignment(textAlign);

            if (ShowKeyboardCues) {
                stringFormat.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Show;
            }
            else {
                stringFormat.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.Hide;
            }

            // Do actual drawing

            // DrawString doesn't seem to draw where it says it does
            if ((textAlign & anyCenter) == 0) {
                r.X -= 1;
            }
            r.Width += 1;

            if (disabledText3D && !Enabled) {
                r.Offset(1, 1);
                using (SolidBrush brush = new SolidBrush(colors.highlight)) {
                    g.DrawString(Text, Font, brush, r, stringFormat);

                    r.Offset(-1, -1);
                    brush.Color = colors.buttonShadow;
                    g.DrawString(Text, Font, brush, r, stringFormat);
                }
            }
            else {
                Brush brush;
                
                if (c.IsSystemColor) {
                    brush = SystemBrushes.FromSystemColor(c);
                }
                else {
                    brush = new SolidBrush(c);
                }
                g.DrawString(Text, Font, brush, r, stringFormat);
                
                if (!c.IsSystemColor) {
                    brush.Dispose();
                }
            }

            stringFormat.Dispose();
        }

        private void OnFrameChanged(object o, EventArgs e) {
            if (IsWindowObscured) {
                StopAnimate();
                return;
            }
            Invalidate();
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);
            Animate();
            if (!Enabled) {
                // disabled button is always "up"
                mouseDown = false;
                mouseOver = false;
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnTextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnTextChanged(EventArgs e) {
            base.OnTextChanged(e);
            Invalidate();
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnKeyDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnKeyDown'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnKeyDown(KeyEventArgs kevent) {
            Debug.Assert(Enabled, "ButtonBase.OnKeyDown should not be called if the button is disabled");
            if (kevent.KeyData == Keys.Space && !mouseDown) {
                mouseDown = true;
                // It looks like none of the "SPACE" key downs generate the BM_SETSTATE.
                // This causes to not draw the focus rectangle inside the button and also
                // not paint the button as "un-depressed".
                //
                if(!OwnerDraw) {
                    SendMessage(NativeMethods.BM_SETSTATE, 1, 0);
                }
                Invalidate(DownChangeRectangle);
                kevent.Handled = true;
            }
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnKeyDown(kevent);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnKeyUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnKeyUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnKeyUp(KeyEventArgs kevent) {
            if (mouseDown && OwnerDraw && !ValidationCancelled) {
                ResetFlagsandPaint();
                OnClick(EventArgs.Empty);
                kevent.Handled = true;
            }
            // call base last, so if it invokes any listeners that disable the button, we
            // don't have to recheck
            base.OnKeyUp(kevent);
            
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnPaint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnPaint'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs pevent) {
        
            if (GetStyle(ControlStyles.UserPaint)) {
                Animate();
                ImageAnimator.UpdateFrames();

                PaintControl(pevent);
            }
            base.OnPaint(pevent);
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnParentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnParentChanged(EventArgs e) {
            base.OnParentChanged(e);
            Animate();
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnVisibleChanged(EventArgs e) {
            base.OnVisibleChanged(e);
            Animate();
        }

        internal virtual void PaintPopupUp(PaintEventArgs e, CheckState state) {
            ColorData colors = PaintPopupRender(e.Graphics).Calculate();
            LayoutData layout = PaintPopupLayout(e, state == CheckState.Unchecked, 1).Layout();

            Graphics g = e.Graphics;

            Rectangle r = ClientRectangle;

            Brush backbrush = null;
            if (state == CheckState.Indeterminate) {
                backbrush = CreateDitherBrush(colors.highlight, colors.buttonFace);
            }

            try {
                PaintButtonBackground(e, r, backbrush);
            }
            finally {
                if (backbrush != null) {
                    backbrush.Dispose();
                    backbrush = null;
                }
            }

            if (IsDefault) {
                r.Inflate(-1, -1);
            }

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, true);

            DrawDefaultBorder(g, r, colors.options.highContrast ? colors.windowText : colors.buttonShadow);

            if (state == CheckState.Unchecked) {
                DrawFlatBorder(g, r, colors.options.highContrast ? colors.windowText : colors.buttonShadow);
            }
            else {
                Draw3DLiteBorder(g, r, colors, false);
            }
        }

        internal virtual void PaintPopupOver(PaintEventArgs e, CheckState state) {
            ColorData colors = PaintPopupRender(e.Graphics).Calculate();
            LayoutData layout = PaintPopupLayout(e, state == CheckState.Unchecked, SystemInformation.HighContrast ? 2 : 1).Layout();

            Graphics g = e.Graphics;
            Region original = g.Clip;

            Rectangle r = ClientRectangle;

            Brush backbrush = null;
            if (state == CheckState.Indeterminate) {
                backbrush = CreateDitherBrush(colors.highlight, colors.buttonFace);
            }

            try {
                PaintButtonBackground(e, r, backbrush);
            }
            finally {
                if (backbrush != null) {
                    backbrush.Dispose();
                    backbrush = null;
                }
            }
            if (IsDefault) {
                r.Inflate(-1, -1);
            }

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, true);

            DrawDefaultBorder(g, r, colors.options.highContrast ? colors.windowText : colors.buttonShadow);

            if (SystemInformation.HighContrast) {
                using (Pen windowFrame = new Pen(colors.windowFrame),
                       highlight = new Pen(colors.highlight),
                       buttonShadow = new Pen(colors.buttonShadow)) {

                    // top, left white
                    g.DrawLine(windowFrame, r.Left + 1, r.Top + 1, r.Right - 2, r.Top + 1);
                    g.DrawLine(windowFrame, r.Left + 1, r.Top + 1, r.Left + 1, r.Bottom - 2);

                    // bottom, right white
                    g.DrawLine(windowFrame, r.Left, r.Bottom - 1, r.Right, r.Bottom - 1);
                    g.DrawLine(windowFrame, r.Right - 1, r.Top, r.Right - 1, r.Bottom);

                    // top, left gray
                    g.DrawLine(highlight, r.Left, r.Top, r.Right, r.Top);
                    g.DrawLine(highlight, r.Left, r.Top, r.Left, r.Bottom);

                    // bottom, right gray
                    g.DrawLine(buttonShadow, r.Left + 1, r.Bottom - 2, r.Right - 2, r.Bottom - 2);
                    g.DrawLine(buttonShadow, r.Right - 2, r.Top + 1, r.Right - 2, r.Bottom - 2);
                }

                r.Inflate(-2, -2);
            }
            else {
                Draw3DLiteBorder(g, r, colors, true);
            }
        }

        internal virtual void PaintPopupDown(PaintEventArgs e, CheckState state) {
            ColorData colors = PaintPopupRender(e.Graphics).Calculate();
            LayoutData layout = PaintPopupLayout(e, false, SystemInformation.HighContrast ? 2 : 1).Layout();

            Graphics g = e.Graphics;
            Region original = g.Clip;

            Rectangle r = ClientRectangle;
            PaintButtonBackground(e, r, null);
            if (IsDefault) {
                r.Inflate(-1, -1);
            }
            r.Inflate(-1, -1);

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, true);
            
            r.Inflate(1, 1);
            DrawDefaultBorder(g, r, colors.options.highContrast ? colors.windowText : colors.windowFrame);
            ControlPaint.DrawBorder(g, r, colors.options.highContrast ? colors.windowText : colors.buttonShadow, ButtonBorderStyle.Solid);
        }

        LayoutOptions CommonLayout() {
            LayoutOptions layout = new LayoutOptions();
            layout.client            = ClientRectangle;
            layout.onePixExtraBorder = IsDefault;
            layout.borderSize        = 2;
            layout.paddingSize       = 0;
            layout.maxFocus          = true;
            layout.focusOddEvenFixup = false;
            layout.font              = Font;
            layout.text              = Text;
            layout.image             = Image;
            layout.checkSize         = 0;
            layout.checkPaddingSize  = 0;
            layout.checkAlign        = ContentAlignment.TopLeft;
            layout.imageAlign        = ImageAlign;
            layout.textAlign         = TextAlign;
            layout.hintTextUp        = false;
            layout.shadowedText      = !Enabled;
            layout.layoutRTL         = RightToLeft.Yes == RightToLeft && RenderRightToLeft;
            return layout;
        }

        LayoutOptions PaintLayout(PaintEventArgs e, bool up) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.textOffset        = !up;

            return layout;
        }

        LayoutOptions PaintPopupLayout(PaintEventArgs e, bool up, int paintedBorder) {
            LayoutOptions layout = CommonLayout();
            layout.borderSize        = paintedBorder;
            layout.paddingSize       = 2 - paintedBorder;//3 - paintedBorder - (IsDefault ? 1 : 0);
            layout.graphics          = e.Graphics;
            layout.hintTextUp        = false;
            layout.textOffset        = !up;
            layout.shadowedText      = SystemInformation.HighContrast;

            return layout;
        }
        
        LayoutOptions PaintFlatLayout(PaintEventArgs e, bool up, bool check) {
            LayoutOptions layout = CommonLayout();
            layout.borderSize        = check ? 2 : 1;
            layout.paddingSize       = check ? 1 : 2;
            layout.graphics          = e.Graphics;
            layout.focusOddEvenFixup = false;
            layout.textOffset        = !up;
            layout.shadowedText      = SystemInformation.HighContrast;

            return layout;
        }

        ColorOptions CommonRender(Graphics g) {
            ColorOptions colors = new ColorOptions(g, ForeColor, BackColor);
            colors.enabled = Enabled;
            return colors;
        }

        internal ColorOptions PaintRender(Graphics g) {
            ColorOptions colors = CommonRender(g);
            return colors;
        }

        internal ColorOptions PaintFlatRender(Graphics g) {
            ColorOptions colors = CommonRender(g);
            colors.disabledTextDim = true;
            return colors;
        }

        internal ColorOptions PaintPopupRender(Graphics g) {
            ColorOptions colors = CommonRender(g);
            colors.disabledTextDim = true;
            return colors;
        }


        void PaintWorker(PaintEventArgs e, bool up, CheckState state) {
            up = up && state == CheckState.Unchecked;


            ColorData colors = PaintRender(e.Graphics).Calculate();
            LayoutData layout = PaintLayout(e, up).Layout();

            Graphics g = e.Graphics;


            Brush backbrush = null;
            if (state == CheckState.Indeterminate) {
                backbrush = CreateDitherBrush(colors.highlight, colors.buttonFace);
            }

            try {
                PaintButtonBackground(e, ClientRectangle, backbrush);
            }
            finally {
                if (backbrush != null) {
                    backbrush.Dispose();
                    backbrush = null;
                }
            }

            Rectangle r = ClientRectangle;
            if (IsDefault) {
                r.Inflate(-1, -1);
            }

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, true);

            DrawDefaultBorder(g, r, colors.windowFrame);

            if (up) {
                Draw3DBorder(g, r, colors, up);
            }
            else {
                // contrary to popular belief, not Draw3DBorder(..., false);
                //
                ControlPaint.DrawBorder(g, r, colors.buttonShadow, ButtonBorderStyle.Solid);
            }
        }

        internal void PaintButtonBackground(PaintEventArgs e, Rectangle bounds, Brush background) {
            if (background == null) {
                PaintBackground(e, bounds);
            }
            else {
                e.Graphics.FillRectangle(background, bounds);
            }
        }

        internal void PaintField(PaintEventArgs e, 
                                 LayoutData layout, 
                                 ColorData colors,
                                 Color foreColor, 
                                 bool drawFocus) {

            Graphics g = e.Graphics;

            Rectangle maxFocus = layout.focus;
            Rectangle text = layout.text;

            DrawText(g, text, foreColor, colors, layout.options.shadowedText);

            if (drawFocus) {
                DrawFocus(g, maxFocus);
            }
        }
        
        internal void PaintImage(PaintEventArgs e, 
                                 LayoutData layout
                                 ) {

            Graphics g = e.Graphics;

            Point imageStart = layout.imageStart;
            Rectangle image = layout.imageBounds;

            DrawImage(g, image, imageStart);
        }

        internal virtual void PaintUp(PaintEventArgs e, CheckState state) {
            PaintWorker(e, true, state);
        }

        internal virtual void PaintDown(PaintEventArgs e, CheckState state) {
            PaintWorker(e, false, state);
        }

        internal virtual void PaintOver(PaintEventArgs e, CheckState state) {
            PaintUp(e, state);
        }

        internal virtual void PaintFlatUp(PaintEventArgs e, CheckState state) {
            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            LayoutData layout = PaintFlatLayout(e, 
                                                SystemInformation.HighContrast ? state != CheckState.Indeterminate : state == CheckState.Unchecked, 
                                                SystemInformation.HighContrast && state == CheckState.Checked).Layout();

            Graphics g = e.Graphics;
            Region original = g.Clip;

            Rectangle r = ClientRectangle;

            Brush backbrush = null;
            switch (state) {
                case CheckState.Unchecked:
                    break;
                case CheckState.Checked:
                    if (SystemInformation.HighContrast) {
                        backbrush = new SolidBrush(colors.buttonShadow);
                    }
                    break;
                case CheckState.Indeterminate:
                    backbrush = CreateDitherBrush(colors.highlight, colors.buttonFace);
                    break;
            }

            try {
                PaintButtonBackground(e, r, backbrush);
            }
            finally {
                if (backbrush != null) {
                    backbrush.Dispose();
                    backbrush = null;
                }
            }

            if (IsDefault) {
                r.Inflate(-1, -1);
            }

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, false);

            if (Focused && ShowFocusCues) {
                DrawFlatFocus(g, layout.focus, colors.options.highContrast ? colors.windowText : colors.constrastButtonShadow);
            }
            
            DrawDefaultBorder(g, r, colors.windowFrame);
            if (state == CheckState.Checked && SystemInformation.HighContrast) {
                DrawFlatBorder(g, r, colors.windowFrame);
                DrawFlatBorder(g, r, colors.buttonShadow);
            }
            else if (state == CheckState.Indeterminate) {
                Draw3DLiteBorder(g, r, colors, false);
            }
            else {
                DrawFlatBorder(g, r, colors.windowFrame);
            }
        }

        internal virtual void PaintFlatDown(PaintEventArgs e, CheckState state) {
            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            LayoutData layout = PaintFlatLayout(e, 
                                                SystemInformation.HighContrast ? state != CheckState.Indeterminate : state == CheckState.Unchecked, 
                                                SystemInformation.HighContrast && state == CheckState.Checked).Layout();

            Graphics g = e.Graphics;
            Region original = g.Clip;

            Rectangle r = ClientRectangle;

            Brush backbrush = null;
            switch (state) {
                case CheckState.Unchecked:
                case CheckState.Checked:
                    backbrush = new SolidBrush(colors.options.highContrast ? colors.buttonShadow : colors.lowHighlight);
                    break;
                case CheckState.Indeterminate:
                    backbrush = CreateDitherBrush(colors.options.highContrast ? colors.buttonShadow : colors.lowHighlight, colors.buttonFace);
                    break;
            }

            try {
                if (BackgroundImage == null) {
                    PaintButtonBackground(e, r, backbrush);
                }
                else {
                    PaintButtonBackground(e, r, null);
                }
            }
            finally {
                if (backbrush != null) {
                    backbrush.Dispose();
                    backbrush = null;
                }
            }
            if (IsDefault) {
                r.Inflate(-1, -1);
            }

            PaintImage(e, layout);
            PaintField(e, layout, colors, colors.windowText, false);

            DrawFlatFocus(g, layout.focus, colors.options.highContrast ? colors.windowText : colors.constrastButtonShadow);
            DrawDefaultBorder(g, r, colors.windowFrame);
            if (state == CheckState.Checked && SystemInformation.HighContrast) {
                DrawFlatBorder(g, r, colors.windowFrame);
                DrawFlatBorder(g, r, colors.buttonShadow);
            }
            else if (state == CheckState.Indeterminate) {
                Draw3DLiteBorder(g, r, colors, false);
            }
            else {
                DrawFlatBorder(g, r, colors.windowFrame);
            }
        }
        
        internal virtual void PaintFlatOver(PaintEventArgs e, CheckState state) {
            if (SystemInformation.HighContrast) {
                PaintFlatUp(e, state);
            }
            else {
                ColorData colors = PaintFlatRender(e.Graphics).Calculate();
                LayoutData layout = PaintFlatLayout(e, state == CheckState.Unchecked, false).Layout();

                Graphics g = e.Graphics;
                Region original = g.Clip;

                Rectangle r = ClientRectangle;

                Brush backbrush = null;
                if (state == CheckState.Indeterminate) {
                    backbrush = CreateDitherBrush(colors.buttonFace, colors.lowButtonFace);
                }
                else {
                    backbrush = new SolidBrush(colors.lowButtonFace);
                }
    
                try {
                    if (BackgroundImage == null) {
                        PaintButtonBackground(e, r, backbrush);
                    }
                    else {
                        PaintButtonBackground(e, r, null);
                    }
                }
                finally {
                    if (backbrush != null) {
                        backbrush.Dispose();
                        backbrush = null;
                    }
                }
                if (IsDefault) {
                    r.Inflate(-1, -1);
                }

                PaintImage(e, layout);
                PaintField(e, layout, colors, colors.windowText, false);

                if (Focused && ShowFocusCues) {
                    DrawFlatFocus(g, layout.focus, colors.constrastButtonShadow);
                }
                DrawDefaultBorder(g, r, colors.windowFrame);
                if (state == CheckState.Unchecked) {
                    DrawFlatBorder(g, r, colors.windowFrame);
                }
                else {
                    Draw3DLiteBorder(g, r, colors, false);
                }
            }
        }

        /// <devdoc>
        ///     Renders the popup style button based upon the current mouse state.
        /// </devdoc>
        private void PaintPopup(PaintEventArgs pevent) {
            if (mouseDown) {
                PaintPopupDown(pevent, CheckState.Unchecked);
            }
            else if (mouseOver) {
                PaintPopupOver(pevent, CheckState.Unchecked);
            }
            else {
                PaintPopupUp(pevent, CheckState.Unchecked);
            }
        }

        /// <devdoc>
        ///     Renders the flat style button based upon the current mouse state.
        /// </devdoc>
        private void PaintFlat(PaintEventArgs pevent) {
            if (mouseDown) {
                PaintFlatDown(pevent, CheckState.Unchecked);
            }
            else if (mouseOver) {
                PaintFlatOver(pevent, CheckState.Unchecked);
            }
            else {
                PaintFlatUp(pevent, CheckState.Unchecked);
            }
        }

        /// <devdoc>
        ///     Renders the standard style button based upon the current mouse state.
        /// </devdoc>
        private void PaintStandard(PaintEventArgs pevent) {
            if (mouseDown) {
                PaintDown(pevent, CheckState.Unchecked);
            }
            else if (mouseOver) {
                PaintOver(pevent, CheckState.Unchecked);
            }
            else {
                PaintUp(pevent, CheckState.Unchecked);  
            }
        }

        private void ResetImage() {
            Image = null;
        }
        
        private bool ShouldSerializeImage() {
            return image != null;
        }
        
        private void UpdateOwnerDraw() {
            if (OwnerDraw != GetStyle(ControlStyles.UserPaint)) {
                SetStyle(ControlStyles.UserPaint, OwnerDraw);
                SetStyle(ControlStyles.UserMouse, OwnerDraw);
                RecreateHandle();
            }
        }

        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBase.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            if (OwnerDraw) {
                switch (m.Msg) {
                    case NativeMethods.BM_SETSTATE:
                        // Ignore BM_SETSTATE -- Windows gets confused and paints
                        // things, even though we are ownerdraw. See ASURT 38669.
                        break;

                    case NativeMethods.WM_KILLFOCUS:
                    case NativeMethods.WM_CANCELMODE:
                    case NativeMethods.WM_CAPTURECHANGED:
                        if (!inButtonUp && mousePressed) {
                            mousePressed = false;

                            if (mouseDown) {
                                mouseDown = false;
                                Invalidate(DownChangeRectangle);
                            }
                        }
                        base.WndProc(ref m);
                        break;

                    case NativeMethods.WM_LBUTTONUP:
                    case NativeMethods.WM_MBUTTONUP:
                    case NativeMethods.WM_RBUTTONUP:
                        try {
                            inButtonUp = true;
                            base.WndProc(ref m);
                        }
                        finally {
                            inButtonUp = false;
                        }
                        break;

                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
            else {
                switch (m.Msg) {
                    case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                        if ((int)m.WParam >> 16 == NativeMethods.BN_CLICKED && !ValidationCancelled) {
                            OnClick(EventArgs.Empty);
                        }
                        break;
                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
        }
        
        /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBaseAccessibleObject"]/*' />
        /// <internalonly/>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class ButtonBaseAccessibleObject : ControlAccessibleObject {
            
            /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBaseAccessibleObject.ButtonBaseAccessibleObject"]/*' />
            public ButtonBaseAccessibleObject(Control owner) : base(owner) {
            }

            /// <include file='doc\ButtonBase.uex' path='docs/doc[@for="ButtonBaseAccessibleObject.DoDefaultAction"]/*' />
            public override void DoDefaultAction() {
                ((ButtonBase)Owner).OnClick(EventArgs.Empty);
            }
        }

        internal class ColorOptions {
            internal Color backColor;
            internal Color foreColor;
            internal bool enabled;
            internal bool disabledTextDim;
            internal bool highContrast;
            internal Graphics graphics;

            internal ColorOptions(Graphics graphics, Color foreColor, Color backColor) {
                this.graphics = graphics;
                this.backColor = backColor;
                this.foreColor = foreColor;
                highContrast = SystemInformation.HighContrast;
            }

            internal int Adjust255(float percentage, int value) {
                int v = (int)(percentage * value);
                if (v > 255) {
                    return 255;
                }
                return v;
            }
            
            internal ColorData Calculate() {
                ColorData colors = new ColorData(this);
                
                colors.buttonFace = backColor;

                if (backColor == SystemColors.Control) {
                    colors.buttonShadow = SystemColors.ControlDark;
                    colors.buttonShadowDark = SystemColors.ControlDarkDark;
                    colors.highlight = SystemColors.ControlLightLight;
                }
                else {
                    if (!highContrast) {
                        colors.buttonShadow = ControlPaint.Dark(backColor);
                        colors.buttonShadowDark = ControlPaint.DarkDark(backColor);
                        colors.highlight = ControlPaint.LightLight(backColor);
                    }
                    else {
                        colors.buttonShadow = ControlPaint.Dark(backColor);
                        colors.buttonShadowDark = ControlPaint.LightLight(backColor);
                        colors.highlight = ControlPaint.LightLight(backColor);
                    }
                }

                const float lowlight = .1f;
                float adjust = 1 - lowlight;

                if (colors.buttonFace.GetBrightness() < .5) {
                    adjust = 1 + lowlight * 2;
                }
                colors.lowButtonFace = Color.FromArgb(Adjust255(adjust, colors.buttonFace.R), 
                                                    Adjust255(adjust, colors.buttonFace.G), 
                                                    Adjust255(adjust, colors.buttonFace.B));

                adjust = 1 - lowlight;
                if (colors.highlight.GetBrightness() < .5) {
                    adjust = 1 + lowlight * 2;
                }
                colors.lowHighlight = Color.FromArgb(Adjust255(adjust, colors.highlight.R), 
                                                   Adjust255(adjust, colors.highlight.G), 
                                                   Adjust255(adjust, colors.highlight.B));
                
                if (highContrast && backColor != SystemColors.Control) {
                    colors.highlight = colors.lowHighlight;
                }

                colors.windowFrame = foreColor;


                /* debug * /
                colors.buttonFace = Color.Yellow;
                colors.buttonShadow = Color.Blue;
                colors.highlight = Color.Brown;
                colors.lowButtonFace = Color.Beige;
                colors.lowHighlight = Color.Cyan;
                colors.windowFrame = Color.Red;
                colors.windowText = Color.Green;
                / * debug */


                if (colors.buttonFace.GetBrightness() < .5) {
                    colors.constrastButtonShadow = colors.lowHighlight;
                }
                else {
                    colors.constrastButtonShadow = colors.buttonShadow;
                }
                
                if (!enabled && disabledTextDim) {
                    colors.windowText = colors.buttonShadow;
                }
                else {
                    colors.windowText = colors.windowFrame;
                }
                
                colors.buttonFace = graphics.GetNearestColor(colors.buttonFace);
                colors.buttonShadow = graphics.GetNearestColor(colors.buttonShadow);
                colors.buttonShadowDark = graphics.GetNearestColor(colors.buttonShadowDark);
                colors.constrastButtonShadow = graphics.GetNearestColor(colors.constrastButtonShadow);
                colors.windowText = graphics.GetNearestColor(colors.windowText);
                colors.highlight = graphics.GetNearestColor(colors.highlight);
                colors.lowHighlight = graphics.GetNearestColor(colors.lowHighlight);
                colors.lowButtonFace = graphics.GetNearestColor(colors.lowButtonFace);
                colors.windowFrame = graphics.GetNearestColor(colors.windowFrame);
                
                return colors;
            }
        }

        internal class ColorData {
            internal Color buttonFace;
            internal Color buttonShadow;
            internal Color buttonShadowDark;
            internal Color constrastButtonShadow;
            internal Color windowText;
            internal Color highlight;
            internal Color lowHighlight;
            internal Color lowButtonFace;
            internal Color windowFrame;

            internal ColorOptions options;

            internal ColorData(ColorOptions options) {
                this.options = options;
            }
        }

        internal class LayoutOptions {
            //use these value to signify ANY of the right, top, left, center, or bottom alignments with the ContentAlignment enum.
            static readonly ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;
            // static readonly ContentAlignment anyLeft   = ContentAlignment.TopLeft | ContentAlignment.MiddleLeft | ContentAlignment.BottomLeft;
            static readonly ContentAlignment anyTop    = ContentAlignment.TopLeft | ContentAlignment.TopCenter | ContentAlignment.TopRight;
            static readonly ContentAlignment anyBottom = ContentAlignment.BottomLeft | ContentAlignment.BottomCenter | ContentAlignment.BottomRight;
            static readonly ContentAlignment anyCenter = ContentAlignment.TopCenter | ContentAlignment.MiddleCenter | ContentAlignment.BottomCenter;
            static readonly ContentAlignment anyMiddle = ContentAlignment.MiddleLeft | ContentAlignment.MiddleCenter | ContentAlignment.MiddleRight;

            internal Rectangle client;
            internal bool onePixExtraBorder;
            internal int borderSize;
            internal int paddingSize;
            internal bool maxFocus;
            internal bool focusOddEvenFixup;
            internal Font font;
            internal Graphics graphics;
            internal string text;
            internal Image image;
            internal int checkSize;
            internal int checkPaddingSize;
            internal ContentAlignment checkAlign;
            internal ContentAlignment imageAlign;
            internal ContentAlignment textAlign;
            internal bool hintTextUp;
            internal bool textOffset;
            internal bool shadowedText;
            internal bool layoutRTL;

            internal LayoutData Layout() {
                LayoutData layout = new LayoutData(this);

                layout.client = this.client;
                layout.face = Rectangle.Inflate(layout.client, -borderSize, -borderSize);
                if (onePixExtraBorder) {
                    layout.face = Rectangle.Inflate(layout.face, -1, -1);
                }
                // checkBounds, checkArea, field
                //
                CalcCheckmarkRectangle(layout);

                // imageBounds, imageStart
                //
                CalcImageRectangle(layout);

                // text
                //
                CalcTextRectangle(layout);

                // focus
                //
                if (maxFocus) {
                    layout.focus = Rectangle.Inflate(layout.field, -1, -1);
                }
                else {
                    Rectangle textAdjusted = new Rectangle(layout.text.X - 1, layout.text.Y - 1,
                                                           layout.text.Width + 2, layout.text.Height + 3);
                    if (image != null) {
                        layout.focus = Rectangle.Union(textAdjusted, layout.imageBounds);
                    }
                    else {
                        layout.focus = textAdjusted;
                    }
                }
                if (focusOddEvenFixup) {
                    if (layout.focus.Height % 2 == 0) {
                        layout.focus.Y++;
                        layout.focus.Height--;
                    }
                    if (layout.focus.Width % 2 == 0) {
                        layout.focus.X++;
                        layout.focus.Width--;
                    }
                }


                return layout;
            }

            ContentAlignment RtlTranslateContent(ContentAlignment align) {
            
                if (layoutRTL) {
                    ContentAlignment[][] mapping = new ContentAlignment[3][];
                    mapping[0] = new ContentAlignment[2] { ContentAlignment.TopLeft, ContentAlignment.TopRight };
                    mapping[1] = new ContentAlignment[2] { ContentAlignment.MiddleLeft, ContentAlignment.MiddleRight };
                    mapping[2] = new ContentAlignment[2] { ContentAlignment.BottomLeft, ContentAlignment.BottomRight };
                         
                    for(int i=0; i < 3; ++i) {
                        if (mapping[i][0] == align) {
                            return mapping[i][1];
                        }
                        else if (mapping[i][1] == align) {
                            return mapping[i][0];
                        }
                    }
                }
                return align;
            }

            void CalcCheckmarkRectangle(LayoutData layout) {
                int checkSizeFull = checkSize + checkPaddingSize;
                layout.checkBounds = new Rectangle(0, 0, checkSizeFull, checkSizeFull);

                // Translate checkAlign for Rtl applications
                ContentAlignment align = RtlTranslateContent(checkAlign);

                Rectangle field = Rectangle.Inflate(layout.face, -paddingSize, -paddingSize);

                layout.field = field;

                if (checkSizeFull > 0) {
                    if ((align & anyRight) != 0) {
                        layout.checkBounds.X = (field.X+field.Width) - layout.checkBounds.Width;
                    }
                    else if ((align & anyCenter) != 0) {
                        layout.checkBounds.X = field.X + (field.Width - layout.checkBounds.Width)/2;
                    }

                    if ((align & anyBottom) != 0) {
                        layout.checkBounds.Y = (field.Y+field.Height)-layout.checkBounds.Height;
                    }
                    else if ((align & anyTop) != 0) {
                        layout.checkBounds.Y = field.Y + 2; // + 2: this needs to be aligned to the Text (bug 87483)
                    }
                    else {
                        layout.checkBounds.Y = field.Y + (field.Height - layout.checkBounds.Height)/2;
                    }

                    switch (align) {
                        case ContentAlignment.TopLeft:
                        case ContentAlignment.MiddleLeft:
                        case ContentAlignment.BottomLeft:
                            layout.checkArea.X = field.X;
                            layout.checkArea.Width = checkSizeFull + 1;

                            layout.checkArea.Y = field.Y;
                            layout.checkArea.Height = field.Height;

                            layout.field.X += checkSizeFull + 1;
                            layout.field.Width -= checkSizeFull + 1;
                            break;
                        case ContentAlignment.TopRight:
                        case ContentAlignment.MiddleRight:
                        case ContentAlignment.BottomRight:
                            layout.checkArea.X = field.X + field.Width - checkSizeFull;
                            layout.checkArea.Width = checkSizeFull + 1;

                            layout.checkArea.Y = field.Y;
                            layout.checkArea.Height = field.Height;

                            layout.field.Width -= checkSizeFull + 1;
                            break;
                        case ContentAlignment.TopCenter:
                            layout.checkArea.X = field.X;
                            layout.checkArea.Width = field.Width;

                            layout.checkArea.Y = field.Y;
                            layout.checkArea.Height = checkSizeFull;

                            layout.field.Y += checkSizeFull;
                            layout.field.Height -= checkSizeFull;
                            break;

                        case ContentAlignment.BottomCenter:
                            layout.checkArea.X = field.X;
                            layout.checkArea.Width = field.Width;

                            layout.checkArea.Y = field.Y + field.Height - checkSizeFull;
                            layout.checkArea.Height = checkSizeFull;

                            layout.field.Height -= checkSizeFull;
                            break;

                        case ContentAlignment.MiddleCenter:
                            layout.checkArea = layout.checkBounds;
                            break;
                    }

                    layout.checkBounds.Width -= checkPaddingSize;
                    layout.checkBounds.Height -= checkPaddingSize;
                }
            }

            void CalcImageRectangle(LayoutData layout) {
                if (image == null) {
                    layout.imageStart = new Point(0, 0);
                    layout.imageBounds = Rectangle.Empty;
                    return;
                }

                // Translate for Rtl applications
                ContentAlignment align = RtlTranslateContent(imageAlign);

                layout.imageBounds = Rectangle.Inflate(layout.field, -2, -2);
                if (onePixExtraBorder) {
                    layout.imageBounds.Inflate(1, 1);
                }
                Size size = new Size(image.Size.Width + 1, image.Size.Height + 1);
                layout.imageBounds = HAlignWithin(size, layout.imageBounds, align);
                layout.imageBounds = VAlignWithin(size, layout.imageBounds, align);

                layout.imageStart = layout.imageBounds.Location;
                layout.imageBounds = Rectangle.Intersect(layout.imageBounds, layout.field);
            }

            void CalcTextRectangle(LayoutData layout) {
                Rectangle bounds = layout.field;
                if (onePixExtraBorder) {
                    bounds.Inflate(1, 1);
                }

                /* These statements compensate for two factors: 3d text when the button is disabled,
                    and moving text on 3d-look buttons. These factors make the text require one
                    more pixel of space; instead we just measure the text as if it had one less
                    pixel available. We do this whether or not the button actually has one of these
                    text styles, because if we do it inconsistently then occasionally the text will
                    wrap in one case and not in another, making a very odd user experience. */
                bounds.Inflate(-2, -2);

                if (graphics != null) {
                    Size textSize;
                    using (StringFormat indicateHotkeyPrefix = new StringFormat()) {
                        // should not matter for size whether we use Show or Hide,
                        // but in case it does use Show and overshoot
                        SizeF s = graphics.MeasureString(text, font, new SizeF((float)bounds.Width, (float)bounds.Height), indicateHotkeyPrefix);
                        textSize = Size.Ceiling(s);
                    }

                    // Translate textAlign for Rtl applications
                    ContentAlignment align = RtlTranslateContent(textAlign);

                    bounds = HAlignWithin(textSize, bounds, align);
                    bounds = VAlignWithin(textSize, bounds, align);
                }

                if (hintTextUp) {
                    bounds.Y--;
                }

                if (textOffset) {
                    bounds.Offset(1, 1);
                }

                // clip
                //
                int bottom = Math.Min(bounds.Bottom, layout.field.Bottom);
                bounds.Y = Math.Max(bounds.Y, layout.field.Y);
                bounds.Height = bottom - bounds.Y;

                layout.text = bounds;
            }

            static Rectangle VAlignWithin (Size alignThis, Rectangle withinThis, ContentAlignment align) {
                if ((align & anyBottom) != 0) {
                    withinThis.Y += withinThis.Height - alignThis.Height;
                }
                else if ((align & anyMiddle) != 0) {
                    withinThis.Y += (withinThis.Height - alignThis.Height) / 2;
                }

                withinThis.Height = alignThis.Height;

                return withinThis;
            }
            static Rectangle HAlignWithin (Size alignThis, Rectangle withinThis, ContentAlignment align) {
                if ((align & anyRight) != 0) {
                    withinThis.X += withinThis.Width - alignThis.Width;
                }
                else if ((align & anyCenter) != 0) {
                    withinThis.X += (withinThis.Width - alignThis.Width) / 2;
                }
                withinThis.Width = alignThis.Width;

                return withinThis;
            }

            public override string ToString() {
                return 
                    "{ client = " + client + "\n" + 
                    "onePixExtraBorder = " + onePixExtraBorder + "\n" + 
                    "borderSize = " + borderSize + "\n" + 
                    "paddingSize = " + paddingSize + "\n" + 
                    "maxFocus = " + maxFocus + "\n" + 
                    "font = " + font + "\n" + 
                    "graphics = " + graphics + "\n" + 
                    "text = " + text + "\n" + 
                    "image = " + image + "\n" + 
                    "checkSize = " + checkSize + "\n" + 
                    "checkPaddingSize = " + checkPaddingSize + "\n" + 
                    "checkAlign = " + checkAlign + "\n" + 
                    "imageAlign = " + imageAlign + "\n" + 
                    "textAlign = " + textAlign + "\n" + 
                    "textOffset = " + textOffset + "\n" + 
                    "shadowedText = " + shadowedText + "\n" + 
                    "layoutRTL = " + layoutRTL + " }";
            }

        }

        internal class LayoutData {
            internal Rectangle client;
            internal Rectangle face;
            internal Rectangle checkArea;
            internal Rectangle checkBounds;
            internal Rectangle text;
            internal Rectangle field;
            internal Rectangle focus;
            internal Rectangle imageBounds;
            internal Point imageStart;
            internal LayoutOptions options;

            public LayoutData(LayoutOptions options) {
                Debug.Assert(options != null, "must have options");
                this.options = options;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\buttonstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the appearance of a button.
    ///       
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum ButtonState {

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The button has a
        ///       checked or latched appearance. Use
        ///       this appearance to show that a toggle button has been pressed.
        ///       
        ///    </para>
        /// </devdoc>
        Checked = NativeMethods.DFCS_CHECKED,

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.Flat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The button has a flat, two-dimensional appearance.
        ///       
        ///    </para>
        /// </devdoc>
        Flat = NativeMethods.DFCS_FLAT,

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.Inactive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The button is inactive (grayed).
        ///       
        ///    </para>
        /// </devdoc>
        Inactive = NativeMethods.DFCS_INACTIVE,

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The button has its normal appearance
        ///       (three-dimensional and not pressed).
        ///       
        ///    </para>
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.Pushed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The button is currently pressed.
        ///       
        ///    </para>
        /// </devdoc>
        Pushed = NativeMethods.DFCS_PUSHED,

        /// <include file='doc\ButtonState.uex' path='docs/doc[@for="ButtonState.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All viable
        ///       flags in the bit mask are used.
        ///       
        ///    </para>
        /// </devdoc>
        All = Flat | Checked | Pushed | Inactive,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\captionbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="CaptionButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type
    ///       of caption button to display.
    ///    </para>
    /// </devdoc>
    public enum CaptionButton {

        /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Close button.
        ///
        ///    </para>
        /// </devdoc>
        Close = NativeMethods.DFCS_CAPTIONCLOSE,

        /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton.Help"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Help button.
        ///    </para>
        /// </devdoc>
        Help = NativeMethods.DFCS_CAPTIONHELP,

        /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton.Maximize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Maximize button.
        ///    </para>
        /// </devdoc>
        Maximize = NativeMethods.DFCS_CAPTIONMAX,

        /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton.Minimize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Minimize button.
        ///    </para>
        /// </devdoc>
        Minimize = NativeMethods.DFCS_CAPTIONMIN,

        /// <include file='doc\CaptionButton.uex' path='docs/doc[@for="CaptionButton.Restore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Restore button.
        ///    </para>
        /// </devdoc>
        Restore = NativeMethods.DFCS_CAPTIONRESTORE,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\charactercasing.cs ===
//------------------------------------------------------------------------------
// <copyright file="CharacterCasing.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\CharacterCasing.uex' path='docs/doc[@for="CharacterCasing"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the case of characters in a Textbox control.
    ///    </para>
    /// </devdoc>
    public enum CharacterCasing {

        /// <include file='doc\CharacterCasing.uex' path='docs/doc[@for="CharacterCasing.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The case of
        ///       characters is left unchanged.
        ///    </para>
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\CharacterCasing.uex' path='docs/doc[@for="CharacterCasing.Upper"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts all characters to uppercase.
        ///    </para>
        /// </devdoc>
        Upper = 1,

        /// <include file='doc\CharacterCasing.uex' path='docs/doc[@for="CharacterCasing.Lower"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts all characters to lowercase.
        ///    </para>
        /// </devdoc>
        Lower = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\checkbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;

    using System.ComponentModel;
    using System.ComponentModel.Design;

    using System.Drawing;
    using System.Drawing.Drawing2D;
    using Microsoft.Win32;

    /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox"]/*' />
    /// <devdoc>
    ///    <para> Represents a Windows
    ///       check box.</para>
    /// </devdoc>
    [
    DefaultProperty("Checked"),
    DefaultEvent("CheckedChanged"),
    ]
    public class CheckBox : ButtonBase {
        private static readonly object EVENT_CHECKEDCHANGED = new object();
        private static readonly object EVENT_CHECKSTATECHANGED = new object();
        private static readonly object EVENT_APPEARANCECHANGED = new object();
        static readonly ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;

        private static Bitmap checkImage = null;
        
        private const int standardCheckSize = 13;
        private const int flatCheckSize = 11;

        private bool autoCheck;
        private bool threeState;

        private ContentAlignment checkAlign = ContentAlignment.MiddleLeft;
        private CheckState checkState;
        private Appearance appearance;

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBox"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.CheckBox'/> class.
        ///    </para>
        /// </devdoc>
        public CheckBox()
        : base() {
        
            // Checkboxes shouldn't respond to right clicks, so we need to do all our own click logic
            SetStyle(ControlStyles.StandardClick |
                     ControlStyles.StandardDoubleClick, false);
        
            autoCheck = true;
            TextAlign = ContentAlignment.MiddleLeft;            
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Appearance"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the value that determines the appearance of a
        ///       check box control.</para>
        /// </devdoc>
        [
        DefaultValue(Appearance.Normal),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.CheckBoxAppearanceDescr)
        ]
        public Appearance Appearance {
            get {
                return appearance;
            }

            set {
                if (!Enum.IsDefined(typeof(Appearance), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(Appearance));
                }

                if (appearance != value) {
                    appearance = value;
                    if (OwnerDraw) {
                        Refresh();
                    }
                    else {
                        UpdateStyles();
                    }
                    OnAppearanceChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.AppearanceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.CheckBoxOnAppearanceChangedDescr)]
        public event EventHandler AppearanceChanged {
            add {
                Events.AddHandler(EVENT_APPEARANCECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_APPEARANCECHANGED, value);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.AutoCheck"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the <see cref='System.Windows.Forms.CheckBox.Checked'/> or <see cref='System.Windows.Forms.CheckBox.CheckState'/>
        /// value and the check box's appearance are automatically
        /// changed when it is clicked.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.CheckBoxAutoCheckDescr)
        ]
        public bool AutoCheck {
            get {
                return autoCheck;
            }

            set {
                autoCheck = value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the horizontal and vertical alignment of a check box on a check box
        ///       control.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(ContentAlignment.MiddleLeft),
        SRDescription(SR.CheckBoxCheckAlignDescr)
        ]
        public ContentAlignment CheckAlign {
            get {
                return checkAlign;
            }
            set {
                if (!Enum.IsDefined(typeof(ContentAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ContentAlignment));
                }

                if (checkAlign != value) {
                    checkAlign = value;
                    if (OwnerDraw) {
                        Invalidate();
                    }
                    else {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating whether the
        ///       check box
        ///       is checked.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.CheckBoxCheckedDescr)
        ]
        public bool Checked {
            get {
                return checkState != CheckState.Unchecked;
            }

            set {
                if (value != Checked) {
                    CheckState = value ? CheckState.Checked : CheckState.Unchecked;
                }
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckState"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets a value indicating whether the check box is checked.</para>
        /// </devdoc>
        [
        Bindable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(CheckState.Unchecked),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.CheckBoxCheckStateDescr)
        ]
        public CheckState CheckState {
            get {
                return checkState;
            }

            set {
                if (!Enum.IsDefined(typeof(CheckState), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(CheckState));
                }

                if (checkState != value) {
                
                    bool oldChecked = Checked;
                
                    checkState = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.BM_SETCHECK, (int)checkState, 0);
                    }
                    
                    if (oldChecked != Checked) {
                        OnCheckedChanged(EventArgs.Empty);
                    }
                    OnCheckStateChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the information used to create the handle for the
        ///    <see cref='System.Windows.Forms.CheckBox'/>
        ///    control.
        /// </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "BUTTON";
                if (OwnerDraw) {
                    cp.Style |= NativeMethods.BS_OWNERDRAW;
                }
                else {
                    cp.Style |= NativeMethods.BS_3STATE;
                    if (Appearance == Appearance.Button) {
                        cp.Style |= NativeMethods.BS_PUSHLIKE;
                    }
                    
                    // Determine the alignment of the check box
                    //
                    ContentAlignment align = RtlTranslateContent(CheckAlign);                              
                    if ((int)(align & anyRight) != 0) {
                        cp.Style |= NativeMethods.BS_RIGHTBUTTON;
                    }

                }

                return cp;
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(104, 24);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OverChangeRectangle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal override Rectangle OverChangeRectangle {
            get {
                if (Appearance == Appearance.Button) {
                    return base.OverChangeRectangle;
                }
                else {
                    if (FlatStyle == FlatStyle.Standard) {
                        // this Rectangle will cause no Invalidation
                        // can't use Rectangle.Empty because it will cause Invalidate(ClientRectangle)
                        return new Rectangle(-1, -1, 1, 1);
                    }
                    else {
                        // Popup mouseover rectangle is actually bigger than GetCheckmarkRectangle
                        return CommonLayout().Layout().checkBounds;
                    }
                }
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.DownChangeRectangle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal override Rectangle DownChangeRectangle {
            get {
                if (Appearance == Appearance.Button) {
                    return base.DownChangeRectangle;
                }
                else {
                    // Popup mouseover rectangle is actually bigger than GetCheckmarkRectangle()
                    return CommonLayout().Layout().checkBounds;
                }
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.TextAlign"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the alignment of the
        ///       text on the checkbox control.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(ContentAlignment.MiddleLeft)
        ]
        public override ContentAlignment TextAlign {
            get {
                return base.TextAlign;
            }
            set {
                base.TextAlign = value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.ThreeState"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating
        ///       whether the check box will allow three check states rather than two.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.CheckBoxThreeStateDescr)
        ]
        public bool ThreeState {
            get {
                return threeState;
            }
            set {
                threeState = value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckedChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the
        ///       value of the <see cref='System.Windows.Forms.CheckBox.Checked'/>
        ///       property changes.</para>
        /// </devdoc>
        [SRDescription(SR.CheckBoxOnCheckedChangedDescr)]
        public event EventHandler CheckedChanged {
            add {
                Events.AddHandler(EVENT_CHECKEDCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CHECKEDCHANGED, value);
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckStateChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the
        ///       value of the <see cref='System.Windows.Forms.CheckBox.CheckState'/>
        ///       property changes.</para>
        /// </devdoc>
        [SRDescription(SR.CheckBoxOnCheckStateChangedDescr)]
        public event EventHandler CheckStateChanged {
            add {
                Events.AddHandler(EVENT_CHECKSTATECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CHECKSTATECHANGED, value);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Constructs the new instance of the accessibility object for this control. Subclasses
        ///       should not call base.CreateAccessibilityObject.
        ///    </para>
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new CheckBoxAccessibleObject(this);
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnAppearanceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAppearanceChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_APPEARANCECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnCheckedChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.CheckBox.CheckedChanged'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnCheckedChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_CHECKEDCHANGED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnCheckStateChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.CheckBox.CheckStateChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnCheckStateChanged(EventArgs e) {
            if (OwnerDraw) {
                Refresh();
            }
            
            EventHandler handler = (EventHandler)Events[EVENT_CHECKSTATECHANGED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnClick"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Fires the event indicating that the control has been clicked.
        ///       Inheriting controls should use this in favour of actually listening to
        ///       the event, but should not forget to call base.onClicked() to
        ///       ensure that the event is still fired for external listeners.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnClick(EventArgs e) {
            if (autoCheck) {
                switch (CheckState) {
                    case CheckState.Unchecked:
                        CheckState = CheckState.Checked;
                        break;
                    case CheckState.Checked:
                        if (threeState) {
                            CheckState = CheckState.Indeterminate;
                        }
                        else {
                            CheckState = CheckState.Unchecked;
                        }
                        break;
                    default:
                        CheckState = CheckState.Unchecked;
                        break;
                }
            }
            base.OnClick(e);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     We override this to ensure that the control's click values are set up
        ///     correctly.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SendMessage(NativeMethods.BM_SETCHECK, (int)checkState, 0);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnMouseUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnMouseUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs mevent) {
            if (mevent.Button == MouseButtons.Left && MouseIsPressed) {
                // It's best not to have the mouse captured while running Click events
                bool captured = Capture;
                if (base.MouseIsDown) {
                    Point pt = PointToScreen(new Point(mevent.X, mevent.Y));
                    if (captured && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                        //Paint in raised state...
                        //
                        ResetFlagsandPaint();
                        if (!ValidationCancelled) {
                            OnClick(EventArgs.Empty);
                        }
                        
                    }
                }
            }
            base.OnMouseUp(mevent);
        }

        void DrawCheckFlat(PaintEventArgs e, LayoutData layout, Color checkColor, Color checkBackground, Color checkBorder, ColorData colors) {
            Region original = e.Graphics.Clip;
            
            Rectangle bounds = layout.checkBounds;
            bounds.Width--;
            bounds.Height--;
            using (Pen pen = new Pen(checkBorder)) {
                e.Graphics.DrawRectangle(pen, bounds);
                bounds.Inflate(-1, -1);
            }
            if (CheckState == CheckState.Indeterminate) {
                bounds.Width++;
                bounds.Height++;
                DrawDitheredFill(e.Graphics, colors.buttonFace, checkBackground, bounds);
            }
            else {
                using (Brush brush = new SolidBrush(checkBackground)) {
                    bounds.Width++;
                    bounds.Height++;
                    e.Graphics.FillRectangle(brush, bounds);
                }
            }
            DrawCheckOnly(e, layout, colors, checkColor, checkBackground, true);
    
        }

        void DrawCheckBackground(PaintEventArgs e, Rectangle bounds, Color checkColor, Color checkBackground, bool disabledColors, ColorData colors) {
            // area behind check
            //
            if (CheckState == CheckState.Indeterminate) {
                DrawDitheredFill(e.Graphics, colors.buttonFace, checkBackground, bounds);
            }
            else {
                Brush brush;

                if (!Enabled && disabledColors) {
                    brush = new SolidBrush(SystemColors.Control);
                }
                else if (CheckState == CheckState.Indeterminate && checkBackground == SystemColors.Window && disabledColors) {
                    Color comboColor = SystemInformation.HighContrast ? SystemColors.ControlDark :
                            SystemColors.Control;
                    byte R = (byte)((comboColor.R + SystemColors.Window.R) / 2);
                    byte G = (byte)((comboColor.G + SystemColors.Window.G) / 2);
                    byte B = (byte)((comboColor.B + SystemColors.Window.B) / 2);
                    brush = new SolidBrush(Color.FromArgb(R, G, B));
                }
                else {
                    brush = new SolidBrush(checkBackground);
                }

                try {
                    e.Graphics.FillRectangle(brush, bounds);
                }
                finally {
                    brush.Dispose();
                }
            }
        }

        void DrawCheckOnly(PaintEventArgs e, LayoutData layout, ColorData colors, Color checkColor, Color checkBackground, bool disabledColors) {

            // check
            //
            if (Checked) {
                if (!Enabled && disabledColors) {
                    checkColor = colors.buttonShadow;
                }
                else if (CheckState == CheckState.Indeterminate && disabledColors) {
                    checkColor = SystemInformation.HighContrast ? colors.highlight :
                       colors.buttonShadow;
                }
                    
                Rectangle fullSize = layout.checkBounds;
                
                if (fullSize.Width == flatCheckSize) {
                    fullSize.Width++;
                    fullSize.Height++;
                }

                fullSize.Width++;
                fullSize.Height++;
                if (checkImage == null || checkImage.Width != fullSize.Width || checkImage.Height != fullSize.Height) {

                    if (checkImage != null) {
                        checkImage.Dispose();
                        checkImage = null;
                    }

                    // We draw the checkmark slightly off center to eliminate 3-D border artifacts,
                    // and compensate below
                    NativeMethods.RECT rcCheck = NativeMethods.RECT.FromXYWH(0, 0, fullSize.Width, fullSize.Height);
                    Bitmap bitmap = new Bitmap(fullSize.Width, fullSize.Height);
                    Graphics offscreen = Graphics.FromImage(bitmap);
                    offscreen.Clear(Color.Transparent);
                    IntPtr dc = offscreen.GetHdc();
                    try {
                        SafeNativeMethods.DrawFrameControl(new HandleRef(offscreen, dc), ref rcCheck,
                                                 NativeMethods.DFC_MENU, NativeMethods.DFCS_MENUCHECK);
                    }
                    finally {
                        offscreen.ReleaseHdcInternal(dc);
                    }
                    offscreen.Dispose();
                    bitmap.MakeTransparent();
                    checkImage = bitmap;
                }
            
                fullSize.Y -= 1;
                Region original = e.Graphics.Clip;
                ControlPaint.DrawImageColorized(e.Graphics, checkImage, fullSize, checkColor);
            }
        }
        
        Rectangle DrawPopupBorder(Graphics g, Rectangle r, ColorData colors) {
            using (Pen high = new Pen(colors.highlight),
                   shadow = new Pen(colors.buttonShadow),
                   face = new Pen(colors.buttonFace)) {
                
                g.DrawLine(high, r.Right-1 , r.Top, r.Right-1, r.Bottom-1);
                g.DrawLine(high, r.Left, r.Bottom-1, r.Right-1 , r.Bottom-1);

                g.DrawLine(shadow, r.Left, r.Top, r.Left , r.Bottom-1);
                g.DrawLine(shadow, r.Left, r.Top, r.Right- 2, r.Top);

                g.DrawLine(face, r.Right - 2, r.Top + 1, r.Right - 2, r.Bottom - 2);
                g.DrawLine(face, r.Left + 1, r.Bottom - 2, r.Right - 2, r.Bottom - 2);
                
            }
            r.Inflate(-1, -1);
            return r;
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.DrawFlatBorder1"]/*' />
        /// <devdoc>
        ///    <para>Draws the border of the check box for buttons with a flat appearance.</para>
        /// </devdoc>
        Rectangle DrawFlatBorder(Graphics g, Rectangle r, Color c, bool disabledColors) {
            if (!Enabled && disabledColors) {
                c = ControlPaint.ContrastControlDark;
            }
            Pen pen = new Pen(c);
            g.DrawRectangle(pen, r.X, r.Y, r.Width - 1, r.Height - 1);
            pen.Dispose();
            
            r.Inflate(-1, -1);
            return r;
        }

        void DrawCheckBox(PaintEventArgs e, LayoutData layout) {
            Graphics g = e.Graphics;
            Region original = g.Clip;

            ButtonState style = (ButtonState)0;

            if (CheckState == CheckState.Unchecked) {
                style |= ButtonState.Normal;
            }
            else {
                style |= ButtonState.Checked;
            }

            if (!Enabled) {
                style |= ButtonState.Inactive;
            }

            if (base.MouseIsDown) {
                style |= ButtonState.Pushed;
            }

            if (CheckState == CheckState.Indeterminate) {
                ControlPaint.DrawMixedCheckBox(g, layout.checkBounds, style);
            }
            else {
                ControlPaint.DrawCheckBox(g, layout.checkBounds, style);
            }
        }
        
        internal override void PaintUp(PaintEventArgs e, CheckState state)
        {
            if (appearance == Appearance.Button) {
                base.PaintUp(e, CheckState);
            }
            else {
                ColorData colors = PaintRender(e.Graphics).Calculate();
                LayoutData layout = PaintLayout(e).Layout();
                PaintButtonBackground(e, ClientRectangle, null);

                PaintImage(e, layout);
                DrawCheckBox(e, layout);
                PaintField(e, layout, colors, colors.windowText, true);
            }
        }
        
        internal override void PaintDown(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintDown(e, CheckState);
            }
            else {
                PaintUp(e, state);
            }
        }
        
        internal override void PaintOver(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintOver(e, CheckState);
            }
            else {
                PaintUp(e, state);
            }
        }
        
        LayoutOptions CommonLayout() {
            LayoutOptions layout = new LayoutOptions();
            layout.client            = ClientRectangle;
            layout.onePixExtraBorder = false;
            layout.borderSize        = 0;
            layout.paddingSize       = 0;
            layout.maxFocus          = false;
            layout.focusOddEvenFixup = true;
            layout.font              = Font;
            layout.text              = Text;
            layout.image             = Image;
            layout.checkSize         = standardCheckSize;
            layout.checkPaddingSize  = 0;
            layout.checkAlign        = CheckAlign;
            layout.imageAlign        = ImageAlign;
            layout.textAlign         = TextAlign;
            layout.hintTextUp        = false;
            layout.textOffset        = false;
            layout.shadowedText      = !Enabled;
            layout.layoutRTL         = RightToLeft.Yes == RightToLeft && RenderRightToLeft;

            return layout;
        }

        LayoutOptions PaintLayout(PaintEventArgs e) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.checkPaddingSize  = 1;

            return layout;
        }

        LayoutOptions PaintPopupLayout(PaintEventArgs e, bool show3D) {
            LayoutOptions layout = CommonLayout();
            layout.graphics          = e.Graphics;
            layout.shadowedText      = false;
            if (show3D) {
                layout.checkSize         = flatCheckSize + 1;
            }
            else {
                layout.checkSize         = flatCheckSize;
                layout.checkPaddingSize  = 1;
            }


            return layout;
        }
        
        LayoutOptions PaintFlatLayout(PaintEventArgs e) {
            LayoutOptions layout = CommonLayout();
            layout.checkSize         = flatCheckSize;
            layout.graphics          = e.Graphics;
            layout.shadowedText      = false;

            return layout;
        }
        
        internal override void PaintFlatDown(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatDown(e, CheckState);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.highlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        } 
        
        internal override void PaintFlatOver(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatOver(e, CheckState);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.lowHighlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        }
        
        internal override void PaintFlatUp(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintFlatUp(e, CheckState);
                return;
            }

            ColorData colors = PaintFlatRender(e.Graphics).Calculate();
            if (Enabled) {
                PaintFlatWorker(e, colors.windowText, colors.highlight, colors.windowFrame, colors);
            }
            else {
                PaintFlatWorker(e, colors.buttonShadow, colors.buttonFace, colors.buttonShadow, colors);
            }
        }
        
        private void PaintFlatWorker(PaintEventArgs e, Color checkColor, Color checkBackground, Color checkBorder, ColorData colors) {
            System.Drawing.Graphics g = e.Graphics;
            LayoutData layout = PaintFlatLayout(e).Layout();
            PaintButtonBackground(e, ClientRectangle, null);

            PaintImage(e, layout);
            DrawCheckFlat(e, layout, checkColor, colors.options.highContrast ? colors.buttonFace : checkBackground, checkBorder, colors);
            PaintField(e, layout, colors, checkColor, true);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the up state.
        /// </devdoc>
        internal override void PaintPopupUp(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintPopupUp(e, CheckState);
            }
            else {
                System.Drawing.Graphics g = e.Graphics;
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintPopupLayout(e, false).Layout();

                Region original = e.Graphics.Clip;
                PaintButtonBackground(e, ClientRectangle, null);

                PaintImage(e, layout);
                
                DrawCheckBackground(e, layout.checkBounds, colors.windowText, colors.options.highContrast ? colors.buttonFace : colors.highlight, true, colors);
                DrawFlatBorder(e.Graphics, layout.checkBounds, colors.buttonShadow);
                DrawCheckOnly(e, layout, colors, colors.windowText, colors.highlight, true);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupOver"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the over state.
        /// </devdoc>
        internal override void PaintPopupOver(PaintEventArgs e, CheckState state) {
            System.Drawing.Graphics g = e.Graphics;
            if (appearance == Appearance.Button) {
                base.PaintPopupOver(e, CheckState);
            }
            else {
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintPopupLayout(e, true).Layout();

                Region original = e.Graphics.Clip;
                PaintButtonBackground(e, ClientRectangle, null);

                PaintImage(e, layout);
                
                DrawCheckBackground(e, layout.checkBounds, colors.windowText, colors.options.highContrast ? colors.buttonFace : colors.highlight, true, colors);
                DrawPopupBorder(g, layout.checkBounds, colors);
                DrawCheckOnly(e, layout, colors, colors.windowText, colors.highlight, true);

                e.Graphics.Clip = original;
                e.Graphics.ExcludeClip(layout.checkArea);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }
        
        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.PaintPopupDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Paints a popup checkbox in the down state.
        /// </devdoc>
        internal override void PaintPopupDown(PaintEventArgs e, CheckState state) {
            if (appearance == Appearance.Button) {
                base.PaintPopupDown(e, CheckState);
            }
            else {
                System.Drawing.Graphics g = e.Graphics;
                ColorData colors = PaintPopupRender(e.Graphics).Calculate();
                LayoutData layout = PaintPopupLayout(e, true).Layout();

                Region original = e.Graphics.Clip;
                PaintButtonBackground(e, ClientRectangle, null);

                PaintImage(e, layout);
                
                DrawCheckBackground(e, layout.checkBounds, colors.windowText, colors.buttonFace, true, colors);
                DrawPopupBorder(g, layout.checkBounds, colors);
                DrawCheckOnly(e, layout, colors, colors.windowText, colors.buttonFace, true);

                PaintField(e, layout, colors, colors.windowText, true);
            }
        }


        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.ProcessMnemonic"]/*' />
        /// <devdoc>
        ///     Overridden to handle mnemonics properly.
        /// </devdoc>
        /// <internalonly/>
        protected override bool ProcessMnemonic(char charCode) {
            if (IsMnemonic(charCode, Text) && CanSelect) {
                if (FocusInternal()) {
                    //Paint in raised state...
                    //
                    ResetFlagsandPaint();
                    if (!ValidationCancelled) {
                        OnClick(EventArgs.Empty);
                    }
                    
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.ToString"]/*' />
        /// <devdoc>
        ///     Provides some interesting information for the CheckBox control in
        ///     String form.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            // C#R cpb: 14744 (sreeramn) We shouldn't need to convert the enum to int -- EE M10 workitem.
            int checkState = (int)CheckState;
            return s + ", CheckState: " + checkState.ToString();
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBoxAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class CheckBoxAccessibleObject : ButtonBaseAccessibleObject {

            /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBoxAccessibleObject.CheckBoxAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public CheckBoxAccessibleObject(Control owner) : base(owner) {
            }

            /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBoxAccessibleObject.DefaultAction"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string DefaultAction {
                get {
                    if (((CheckBox)Owner).Checked) {
                        return SR.GetString(SR.AccessibleActionUncheck);
                    }
                    else {
                        return SR.GetString(SR.AccessibleActionCheck);
                    }
                }
            }
            
            /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBoxAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.CheckButton;
                }
            }
            
            /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBoxAccessibleObject.State"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleStates State {
                get {
                    switch (((CheckBox)Owner).CheckState) {
                        case CheckState.Checked:
                            return AccessibleStates.Checked | base.State;
                        case CheckState.Indeterminate:
                            return AccessibleStates.Indeterminate | base.State;
                    }

                    return base.State;
                }
            }                        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\button.cs ===
//------------------------------------------------------------------------------
// <copyright file="Button.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using System.ComponentModel;

    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\Button.uex' path='docs/doc[@for="Button"]/*' />
    /// <devdoc>
    ///    <para>Represents a
    ///       Windows button.</para>
    /// </devdoc>
    public class Button : ButtonBase, IButtonControl {

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.dialogResult"]/*' />
        /// <devdoc>
        ///     The dialog result that will be sent to the parent dialog form when
        ///     we are clicked.
        /// </devdoc>
        private DialogResult dialogResult;
        
        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.Button"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Button'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public Button() : base() {
            // Buttons shouldn't respond to right clicks, so we need to do all our own click logic
            SetStyle(ControlStyles.StandardClick |
                     ControlStyles.StandardDoubleClick,
                     false);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This is called when creating a window. Inheriting classes can overide
        ///       this to add extra functionality, but should not forget to first call
        ///       base.CreateParams() to make sure the control continues to work
        ///       correctly.
        ///
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "BUTTON";                
                if (GetStyle(ControlStyles.UserPaint)) {
                    cp.Style |= NativeMethods.BS_OWNERDRAW;
                }
                else {
                    cp.Style |= NativeMethods.BS_PUSHBUTTON;
                    if (IsDefault) {
                        cp.Style |= NativeMethods.BS_DEFPUSHBUTTON;
                    }
                }

                return cp;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.DialogResult"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that is returned to the
        ///       parent form when the button
        ///       is clicked.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DialogResult.None),
        SRDescription(SR.ButtonDialogResultDescr)
        ]
        public virtual DialogResult DialogResult {
            get {
                return dialogResult;
            }

            set {
                if (!Enum.IsDefined(typeof(DialogResult), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DialogResult));
                }

                dialogResult = value;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.NotifyDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies the <see cref='System.Windows.Forms.Button'/>
        ///       whether it is the default button so that it can adjust its appearance
        ///       accordingly.
        ///       
        ///    </para>
        /// </devdoc>
        public virtual void NotifyDefault(bool value) {
            if (IsDefault != value) {
                IsDefault = value;                
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.OnClick"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This method actually raises the Click event. Inheriting classes should
        ///       override this if they wish to be notified of a Click event. (This is far
        ///       preferable to actually adding an event handler.) They should not,
        ///       however, forget to call base.onClick(e); before exiting, to ensure that
        ///       other recipients do actually get the event.
        ///
        ///    </para>
        /// </devdoc>
        protected override void OnClick(EventArgs e) {
            Form form = FindFormInternal();
            if (form != null) form.DialogResult = dialogResult;
            base.OnClick(e);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.OnMouseUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ButtonBase.OnMouseUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs mevent) {
            if (GetStyle(ControlStyles.UserPaint) && mevent.Button == MouseButtons.Left && MouseIsPressed) {
                bool isMouseDown = base.MouseIsDown;

                //Paint in raised state...
                //
                ResetFlagsandPaint();
                
                if (isMouseDown) {
                    Point pt = PointToScreen(new Point(mevent.X, mevent.Y));
                    if (UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle && !ValidationCancelled) {
                        OnClick(EventArgs.Empty);
                    }
                }
            }
            base.OnMouseUp(mevent);
        }


        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.PerformClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates a <see cref='System.Windows.Forms.Control.Click'/> event for a
        ///       button.
        ///    </para>
        /// </devdoc>
        public void PerformClick() {
            if (CanSelect) {
                bool fireOnClick = true;
                // Fix 139438
                // Determine the common container between this button and the focused control
                IContainerControl c = GetContainerControlInternal();
                if (c != null) {
                    ContainerControl container = c as ContainerControl;
                    if (container != null) {
                        while (container.ActiveControl == null)
                        {
                            ContainerControl cc;
                            Control parent = container.ParentInternal;
                            if (parent != null)
                            {
                                cc = parent.GetContainerControlInternal() as ContainerControl;
                                if (cc != null)
                                {
                                    container = cc;
                                }
                                else
                                {
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        fireOnClick = container.Validate();
                    }
                }
                if (fireOnClick && !ValidationCancelled) {
                    //Paint in raised state...
                    //
                    ResetFlagsandPaint();
                    OnClick(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.ProcessMnemonic"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Lets a control process mnmemonic characters. Inheriting classes can
        ///       override this to add extra functionality, but should not forget to call
        ///       base.ProcessMnemonic(charCode); to ensure basic functionality
        ///       remains unchanged.
        ///
        ///    </para>
        /// </devdoc>
        protected override bool ProcessMnemonic(char charCode) {
            if (IsMnemonic(charCode, Text)) {
                PerformClick();
                return true;
            }
            return base.ProcessMnemonic(charCode);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information for the Button control in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Text: " + Text;
        }
        
        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.WndProc"]/*' />
        /// <devdoc>
        ///     The button's window procedure.  Inheriting classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the button continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                    if ((int)m.WParam >> 16 == NativeMethods.BN_CLICKED) {
                        Debug.Assert(!GetStyle(ControlStyles.UserPaint), "Shouldn't get BN_CLICKED when UserPaint");
                        if (!ValidationCancelled) {
                            OnClick(EventArgs.Empty);
                        }
                        
                    }
                    break;
                case NativeMethods.WM_ERASEBKGND:
                    DefWndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\buttonborderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonBorderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       the border style for a button control.
    ///    </para>
    /// </devdoc>
    public enum ButtonBorderStyle {
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No border.
        ///    </para>
        /// </devdoc>
        None,
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.Dotted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dotted-line border.
        ///    </para>
        /// </devdoc>
        Dotted,
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.Dashed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dashed border.
        ///    </para>
        /// </devdoc>
        Dashed,
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.Solid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A solid border.
        ///    </para>
        /// </devdoc>
        Solid,
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.Inset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A sunken border.
        ///    </para>
        /// </devdoc>
        Inset,
        /// <include file='doc\ButtonBorderStyle.uex' path='docs/doc[@for="ButtonBorderStyle.Outset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A raised border.
        ///    </para>
        /// </devdoc>
        Outset,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\columnheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Windows.Forms;    
    
    /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays a single column header in a <see cref='System.Windows.Forms.ListView'/>
    ///       control.
    ///
    ///    </para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("Text")
    ]
    public class ColumnHeader : Component, ICloneable {

        internal int index = -1;
        internal string text = null;
        internal int width = 60;
        // Use TextAlign property instead of this member variable, always
        private HorizontalAlignment textAlign = HorizontalAlignment.Left;
        private bool textAlignInitialized = false;

        private ListView listview;
        // We need to send some messages to ListView when it gets initialized.
        internal ListView OwnerListview
        {
            get
            {
                return listview;
            }
            set
            {
                int width = this.Width;

                listview = value;
                
                // The below properties are set into the listview.
                this.Width = width;
            }
        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.ColumnHeader"]/*' />
        /// <devdoc>
        ///     Creates a new ColumnHeader object
        /// </devdoc>
        public ColumnHeader() {
        }

                /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.Index"]/*' />
        /// <devdoc>
        ///     The index of this column.  This index does not necessarily correspond
        ///     to the current visual position of the column in the ListView, because the
        ///     user may orerder columns if the allowColumnReorder property is true.
        /// </devdoc>
        [ Browsable(false)]
        public int Index {
            get {
                if (listview != null)
                    return listview.GetColumnIndex(this);
                return -1;  
            }
        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.ListView"]/*' />
        /// <devdoc>
        ///     Returns the ListView control that this column is displayed in.  May be null
        /// </devdoc>
        [ Browsable(false) ]
        public ListView ListView {
            get {
                return this.listview;
            }
        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.Text"]/*' />
        /// <devdoc>
        ///     The text displayed in the column header
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.ColumnCaption)
        ]
        public string Text {
            get {
                return(text != null ? text : "ColumnHeader");
            }
            set {
                if (value == null) {
                    this.text = "";
                }
                else {
                    this.text = value;
                }
                if (listview != null) {
                    listview.SetColumnInfo(NativeMethods.LVCF_TEXT, this);
                }
            }

        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.TextAlign"]/*' />
        /// <devdoc>
        ///     The horizontal alignment of the text contained in this column
        /// </devdoc>
        [
        SRDescription(SR.ColumnAlignment),
        Localizable(true),
        DefaultValue(HorizontalAlignment.Left)
        ]
        public HorizontalAlignment TextAlign {
            get {
                if (!textAlignInitialized && (listview != null))
                {
                        textAlignInitialized = true;
                        // See below for an explanation of (Index != 0)
                        if ((Index != 0) && (listview.RightToLeft == RightToLeft.Yes))
                        {
                                this.textAlign = HorizontalAlignment.Right;
                        }
                }
                return this.textAlign;
            }
            set {
                this.textAlign = value;
                
                // The first column must be left-aligned
                if (Index == 0 && this.textAlign != HorizontalAlignment.Left) {
                    this.textAlign = HorizontalAlignment.Left;
                }

                if (listview != null) {
                    listview.SetColumnInfo(NativeMethods.LVCF_FMT, this);
                    listview.Invalidate();
                }
            }
        }

        internal int WidthInternal {
            get {
                return width;
            }
        }
        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.Width"]/*' />
        /// <devdoc>
        ///     The width of the column in pixels.
        /// </devdoc>
        [
        SRDescription(SR.ColumnWidth),
        Localizable(true),
        DefaultValue(60)
        ]
        public int Width {
            get {
                // Since we can't keep our private width in sync with the real width because
                // we don't get notified when the user changes it, we need to get this info
                // from the underlying control every time we're asked.
                // The underlying control will only report the correct width if it's in Report view
                if (listview != null && listview.IsHandleCreated && !listview.Disposing && listview.View == View.Details) {
                    
                    // Make sure this column has already been added to the ListView, else just return width
                    //
                    IntPtr hwndHdr = UnsafeNativeMethods.SendMessage(new HandleRef(listview, listview.Handle), NativeMethods.LVM_GETHEADER, 0, 0);
                    if (hwndHdr != IntPtr.Zero) {
                        int nativeColumnCount = (int)UnsafeNativeMethods.SendMessage(new HandleRef(listview, hwndHdr), NativeMethods.HDM_GETITEMCOUNT, 0, 0);
                        if (Index < nativeColumnCount) {
                            width = (int)UnsafeNativeMethods.SendMessage(new HandleRef(listview, listview.Handle), NativeMethods.LVM_GETCOLUMNWIDTH, Index, 0);
                        }
                    }
                }

                return width;
            }
            set {
                this.width = value;
                if (listview != null)
                    listview.SetColumnWidth(Index, value);
                }
        }
        

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.Clone"]/*' />
        /// <devdoc>
        ///     Creates an identical ColumnHeader, unattached to any ListView
        /// </devdoc>
        public object Clone() {
            Type clonedType = this.GetType();
            ColumnHeader columnHeader = null;

            if (clonedType == typeof(ColumnHeader)) 
                columnHeader = new ColumnHeader();
            else
                columnHeader = (ColumnHeader)Activator.CreateInstance(clonedType);
            
            columnHeader.text = text;
            columnHeader.Width = width;
            columnHeader.textAlign = TextAlign;
            return columnHeader;
        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (listview != null) {
                    int index = Index;
                    if (index != -1) {
                        listview.Columns.RemoveAt(index);
                    }
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.ShouldPersistText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal bool ShouldSerializeText() {
            return(text != null);
        }
        
        /// <include file='doc\ColumnHeader.uex' path='docs/doc[@for="ColumnHeader.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation of this column header
        /// </devdoc>
        public override string ToString() {
            return "ColumnHeader: Text: " + Text;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\columnclickeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnClickEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ColumnClickEventHandler.uex' path='docs/doc[@for="ColumnClickEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the
    ///       the <see cref='System.Windows.Forms.ListView.OnColumnClick'/>event of a <see cref='System.Windows.Forms.ListView'/>
    ///       .
    ///       
    ///    </para>
    /// </devdoc>
    public delegate void ColumnClickEventHandler(object sender, ColumnClickEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\columnclickevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnClickEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ColumnClickEvent.uex' path='docs/doc[@for="ColumnClickEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.ListView.OnColumnClick'/>
    ///       event.
    ///
    ///    </para>
    /// </devdoc>
    public class ColumnClickEventArgs : EventArgs {
        readonly int column;

        /// <include file='doc\ColumnClickEvent.uex' path='docs/doc[@for="ColumnClickEventArgs.ColumnClickEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ColumnClickEventArgs(int column) {
            this.column = column;
        }

        /// <include file='doc\ColumnClickEvent.uex' path='docs/doc[@for="ColumnClickEventArgs.Column"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Column {
            get {
                return column;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\checkstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\CheckState.uex' path='docs/doc[@for="CheckState"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the state of a control,
    ///       such as
    ///       a check
    ///       box, that can be checked, unchecked, or
    ///       set to an indeterminate state.
    ///    </para>
    /// </devdoc>
    public enum CheckState {

        /// <include file='doc\CheckState.uex' path='docs/doc[@for="CheckState.Unchecked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is unchecked.
        ///
        ///    </para>
        /// </devdoc>
        Unchecked = 0,

        /// <include file='doc\CheckState.uex' path='docs/doc[@for="CheckState.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is checked.
        ///
        ///    </para>
        /// </devdoc>
        Checked = 1,

        /// <include file='doc\CheckState.uex' path='docs/doc[@for="CheckState.Indeterminate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control
        ///       is indeterminate. An indeterminate control generally has a shaded appearance.
        ///       
        ///    </para>
        /// </devdoc>
        Indeterminate = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\clipboard.cs ===
//------------------------------------------------------------------------------
// <copyright file="Clipboard.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    
    using System.ComponentModel;

    /// <include file='doc\Clipboard.uex' path='docs/doc[@for="Clipboard"]/*' />
    /// <devdoc>
    ///    <para>Provides methods to place data on and retrieve data from the system clipboard. This class cannot be inherited.</para>
    /// </devdoc>
    public sealed class Clipboard {

        // not creatable...
        //
        private Clipboard() {
        }

        /// <include file='doc\Clipboard.uex' path='docs/doc[@for="Clipboard.SetDataObject"]/*' />
        /// <devdoc>
        /// <para>Places nonpersistent data on the system <see cref='System.Windows.Forms.Clipboard'/>.</para>
        /// </devdoc>
        public static void SetDataObject(object data) {
            SetDataObject(data, false);
        }

        /// <include file='doc\Clipboard.uex' path='docs/doc[@for="Clipboard.SetDataObject1"]/*' />
        /// <devdoc>
        /// <para>Places data on the system <see cref='System.Windows.Forms.Clipboard'/> and uses copy to specify whether the data 
        ///    should remain on the <see cref='System.Windows.Forms.Clipboard'/>
        ///    after the application exits.</para>
        /// </devdoc>
        public static void SetDataObject(object data, bool copy) {
            if (Application.OleRequired() != System.Threading.ApartmentState.STA) {
                throw new System.Threading.ThreadStateException(SR.GetString(SR.ThreadMustBeSTA));
            }

            if (data == null) {
                throw new ArgumentNullException("data");
            }

            if (data is UnsafeNativeMethods.IOleDataObject) {
                ThrowIfFailed(UnsafeNativeMethods.OleSetClipboard((UnsafeNativeMethods.IOleDataObject)data));
            }
            else {
                ThrowIfFailed(UnsafeNativeMethods.OleSetClipboard(new DataObject(data)));
            }            
            
            if (copy) {
                ThrowIfFailed(UnsafeNativeMethods.OleFlushClipboard());
            }
        }

        /// <include file='doc\Clipboard.uex' path='docs/doc[@for="Clipboard.GetDataObject"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data that is currently on the system
        ///    <see cref='System.Windows.Forms.Clipboard'/>.</para>
        /// </devdoc>
        public static IDataObject GetDataObject() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ClipboardRead Demanded");
            IntSecurity.ClipboardRead.Demand();

            if (Application.OleRequired() != System.Threading.ApartmentState.STA) {

                // only throw if a message loop was started. This makes the case of trying
                // to query the clipboard from your finalizer or non-ui MTA thread
                // silently fail, instead of making your app die.
                //
                // however, if you are trying to write a normal windows forms app and 
                // forget to set the STAThread attribute, we will correctly report
                // an error to aid in debugging.
                //
                if (Application.MessageLoop) {
                    throw new System.Threading.ThreadStateException(SR.GetString(SR.ThreadMustBeSTA));
                }
                else {
                    return null;
                }
            }
            UnsafeNativeMethods.IOleDataObject dataObject = null;
            ThrowIfFailed(UnsafeNativeMethods.OleGetClipboard(ref dataObject));

            if (dataObject != null) {
                if (dataObject is IDataObject && !Marshal.IsComObject(dataObject)) {
                    return (IDataObject)dataObject;
                }
                else {
                    return new DataObject(dataObject);
                }
            }
            return null;
        }

        private static void ThrowIfFailed(int hr) {
            // CONSIDER : This should use a "FAILED" type function...
            if (hr != 0) {
                ExternalException e = new ExternalException(SR.GetString(SR.ClipboardOperationFailed), hr);
                throw e;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\colordepth.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorDepth.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    // Used with ImageList.
    /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ColorDepth {
        /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth.Depth4Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Depth4Bit         = 4,
        /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth.Depth8Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Depth8Bit         = 8,
        /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth.Depth16Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Depth16Bit        = 16,
        /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth.Depth24Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Depth24Bit        = 24,
        /// <include file='doc\ColorDepth.uex' path='docs/doc[@for="ColorDepth.Depth32Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Depth32Bit        = 32,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\checkedlistbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckedListBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;

    using System.Drawing;
    using System.ComponentModel;
    using System.Runtime.InteropServices;

    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    using System.Drawing.Design;

    /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox"]/*' />
    /// <devdoc>
    ///    <para>
    ///
    ///       Displays a list with a checkbox to the left
    ///
    ///       of each item.
    ///
    ///    </para>
    /// </devdoc>
    public class CheckedListBox : ListBox {

        private const int idealCheckSize = 13;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.killnextselect"]/*' />
        /// <devdoc>
        ///     Decides whether or not to ignore the next LBN_SELCHANGE
        ///     message - used to prevent cursor keys from toggling checkboxes
        /// </devdoc>
        private bool killnextselect = false;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.onItemCheck"]/*' />
        /// <devdoc>
        ///     Current listener of the onItemCheck event.
        /// </devdoc>
        private ItemCheckEventHandler onItemCheck;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.checkOnClick"]/*' />
        /// <devdoc>
        ///     Indicates whether or not we should toggle check state on the first
        ///     click on an item, or whether we should wait for the user to click
        ///     again.
        /// </devdoc>
        private bool checkOnClick = false;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.flat"]/*' />
        /// <devdoc>
        ///     Should we use 3d checkboxes or flat ones?
        /// </devdoc>
        private bool flat = true;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.lastSelected"]/*' />
        /// <devdoc>
        ///     Indicates which item was last selected.  We want to keep track
        ///     of this so we can be a little less aggressive about checking/
        ///     unchecking the items as the user moves around.
        /// </devdoc>
        private int lastSelected = -1;
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.checkedItemCollection"]/*' />
        /// <devdoc>
        ///     The collection of checked items in the CheckedListBox.
        /// </devdoc>                                                                     
        private CheckedItemCollection checkedItemCollection = null;
        private CheckedIndexCollection checkedIndexCollection = null;

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBox"]/*' />
        /// <devdoc>
        ///     Creates a new CheckedListBox for the user.
        /// </devdoc>
        public CheckedListBox() : base() {
            // If we eat WM_ERASEBKGRND messages, the background will be 
            // painted sometimes but not others. See ASURT 28545.
            // SetStyle(ControlStyles.Opaque, true); 

            // If a long item is drawn with ellipsis, we must redraw the ellipsed part
            // as well as the newly uncovered region.
            SetStyle(ControlStyles.ResizeRedraw, true);
            
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckOnClick"]/*' />
        /// <devdoc>
        ///     Indicates whether or not the checkbox should be toggled whenever an
        ///     item is selected.  The default behaviour is to just change the
        ///     selection, and then make the user click again to check it.  However,
        ///     some may prefer checking the item as soon as it is clicked.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.CheckedListBoxCheckOnClickDescr)
        ]
        public bool CheckOnClick {
            get {
                return checkOnClick;
            }

            set {
                checkOnClick = value;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndices"]/*' />
        /// <devdoc>
        ///     Collection of checked indices in this CheckedListBox.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CheckedIndexCollection CheckedIndices {
            get {
                if (checkedIndexCollection == null) {
                    checkedIndexCollection = new CheckedIndexCollection(this);
                }
                return checkedIndexCollection;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItems"]/*' />
        /// <devdoc>
        ///     Collection of checked items in this CheckedListBox.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CheckedItemCollection CheckedItems {
            get {
                if (checkedItemCollection == null) {
                    checkedItemCollection = new CheckedItemCollection(this);
                }
                return checkedItemCollection;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CreateParams"]/*' />
        /// <devdoc>
        ///     This is called when creating a window.  Inheriting classes can ovveride
        ///     this to add extra functionality, but should not forget to first call
        ///     base.CreateParams() to make sure the control continues to work
        ///     correctly.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.LBS_OWNERDRAWFIXED | NativeMethods.LBS_WANTKEYBOARDINPUT;
                return cp;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.DataSource"]/*' />
        /// <devdoc>
        ///     CheckedListBox DataSource.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new object DataSource {
            get {
                return base.DataSource;
            }
            set {
                base.DataSource = value;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.DisplayMember"]/*' />
        /// <devdoc>
        ///     CheckedListBox DisplayMember.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new string DisplayMember {
            get {
                return base.DisplayMember ;
            }
            set {
                base.DisplayMember = value;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.DrawMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override DrawMode DrawMode {
            get {
                return DrawMode.Normal;
            }
            set {
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ItemHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override int ItemHeight {
            get {
                return Font.Height + 2;      // 2 = 2 * border size          
            }
            set {                
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.Items"]/*' />
        /// <devdoc>
        ///     Collection of items in this listbox.
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.ListBoxItemsDescr),
        Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        new public CheckedListBox.ObjectCollection Items {
            get {
                return(CheckedListBox.ObjectCollection)base.Items;
            }
        }

        // Computes the maximum width of all items in the ListBox
        //             
        internal override int MaxItemWidth {
            get {
                // Overridden to include the size of the checkbox
                // Allows for one pixel either side of the checkbox, plus another 1 pixel buffer = 3 pixels
                //
                return base.MaxItemWidth + idealCheckSize + 3;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.SelectionMode"]/*' />
        /// <devdoc>
        ///     For CheckedListBoxes, multi-selection is not supported.  You can set
        ///     selection to be able to select one item or no items.
        /// </devdoc>
        public override SelectionMode SelectionMode {
            get {
                return base.SelectionMode;
            }
            set {
                if ( !Enum.IsDefined(typeof(SelectionMode), value) )
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SelectionMode));
        
                if (value != SelectionMode.One
                    && value != SelectionMode.None) {
                    throw new ArgumentException(SR.GetString(SR.CheckedListBoxInvalidSelectionMode));
                }

                if (value != SelectionMode) {
                    base.SelectionMode = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ThreeDCheckBoxes"]/*' />
        /// <devdoc>
        ///     Indicates if the CheckBoxes should show up as flat or 3D in appearance.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.CheckedListBoxThreeDCheckBoxesDescr)
        ]
        public bool ThreeDCheckBoxes {
            get {
                return !flat;
            }
            set {
                // change the style and repaint.
                //
                if (flat == value) {
                    flat = !value;

                    // see if we have some items, and only invalidate if we do.                    
                    CheckedListBox.ObjectCollection items = (CheckedListBox.ObjectCollection) Items;
                    if ((items != null) && (items.Count > 0)) {
                        this.Invalidate();
                    }
                }
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ValueMember"]/*' />
        /// <devdoc>
        ///     CheckedListBox ValueMember.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new string ValueMember {
            get {
                return base.ValueMember;
            }
            set {
                base.ValueMember = value;
            }
        }


        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="ComboBox.DataSourceChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DataSourceChanged {
            add {
                base.DataSourceChanged += value;
            }
            remove {
                base.DataSourceChanged -= value;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="ComboBox.DisplayMemberChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DisplayMemberChanged {
            add {
                base.DisplayMemberChanged += value;
            }
            remove {
                base.DisplayMemberChanged -= value;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ItemCheck"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.CheckedListBoxItemCheckDescr)]
        public event ItemCheckEventHandler ItemCheck {
            add {
                onItemCheck += value;
            }
            remove {
                onItemCheck -= value;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.DrawItem"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event DrawItemEventHandler DrawItem {
            add {
                base.DrawItem += value;
            }
            remove {
                base.DrawItem -= value;
            }
        }        

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.MeasureItem"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event MeasureItemEventHandler MeasureItem {
            add {
                base.MeasureItem += value;
            }
            remove {
                base.MeasureItem -= value;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="ComboBox.ValueMemberChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ValueMemberChanged {
            add {
                base.ValueMemberChanged += value;
            }
            remove {
                base.ValueMemberChanged -= value;
            }
        }

        internal override int ComputeMaxItemWidth(int oldMax) {
            int maxItemWidth = oldMax;

            using (Graphics g = CreateGraphics()) {
                foreach(object item in Items) {
                    int width = (int)Math.Ceiling(g.MeasureString(item.ToString(), Font).Width);

                    if (width > maxItemWidth) {
                        maxItemWidth = width;
                    }
                }
            }

            return maxItemWidth;
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Constructs the new instance of the accessibility object for this control. Subclasses
        ///    should not call base.CreateAccessibilityObject.
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new CheckedListBoxAccessibleObject(this);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CreateItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ListBox.ObjectCollection CreateItemCollection() {
            return new ObjectCollection(this);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.GetItemCheckState"]/*' />
        /// <devdoc>
        ///     Gets the check value of the current item.  This value will be from the
        ///     System.Windows.Forms.CheckState enumeration.
        /// </devdoc>
        public CheckState GetItemCheckState(int index) {

            if (index < 0 || index >= Items.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));
            return CheckedItems.GetCheckedState(index);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.GetItemChecked"]/*' />
        /// <devdoc>
        ///     Indicates if the given item is, in any way, shape, or form, checked.
        ///     This will return true if the item is fully or indeterminately checked.
        /// </devdoc>
        public bool GetItemChecked(int index) {
            return(GetItemCheckState(index) != CheckState.Unchecked);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.InvalidateItem"]/*' />
        /// <devdoc>
        ///     Invalidates the given item in the listbox
        /// </devdoc>
        /// <internalonly/>
        private void InvalidateItem(int index) {
            if (IsHandleCreated) {
                NativeMethods.RECT rect = new NativeMethods.RECT();
                SendMessage(NativeMethods.LB_GETITEMRECT, index, ref rect);
                SafeNativeMethods.InvalidateRect(new HandleRef(this, Handle), ref rect, false);
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.LbnSelChange"]/*' />
        /// <devdoc>
        ///     A redirected LBN_SELCHANGE message notification.
        /// </devdoc>
        /// <internalonly/>
        private void LbnSelChange() {

            // prepare to change the selection.  we'll fire an event for
            // this.  Note that we'll only change the selection when the
            // user clicks again on a currently selected item, or when the
            // user has CheckOnClick set to true.  Otherwise
            // just using the up and down arrows selects or unselects
            // every item around town ...
            //

            // Get the index of the item to check/uncheck
            int index = SelectedIndex;
            
            // make sure we have a valid index, otherwise we're going to
            // fail ahead...
            if (index < 0 || index >= Items.Count)
                return;
                
            // Send an accessibility notification
            //
            AccessibilityNotifyClients(AccessibleEvents.Focus, index);
            AccessibilityNotifyClients(AccessibleEvents.Selection, index);

                       
            //# VS7 86
            if (!killnextselect && (index == lastSelected || checkOnClick == true)) {
                CheckState currentValue = CheckedItems.GetCheckedState(index);
                CheckState newValue = (currentValue != CheckState.Unchecked)
                                      ? CheckState.Unchecked
                                      : CheckState.Checked;

                ItemCheckEventArgs itemCheckEvent = new ItemCheckEventArgs(index, newValue, currentValue);
                OnItemCheck(itemCheckEvent);

                // take whatever value the user set, and set that as the value.
                //
                CheckedItems.SetCheckedState(index, itemCheckEvent.NewValue);
                
            }

            lastSelected = index;
            InvalidateItem(index);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnClick"]/*' />
        /// <devdoc>
        ///     Ensures that mouse clicks can toggle...
        /// </devdoc>
        /// <internalonly/>
        protected override void OnClick(EventArgs e) {
            killnextselect = false;
            base.OnClick(e);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     When the handle is created we can dump any cached item-check pairs.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SendMessage(NativeMethods.LB_SETITEMHEIGHT, 0, ItemHeight);            
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnDrawItem"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the drawItem event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler yourself for this event].  They should,
        ///     however, remember to call base.OnDrawItem(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected override void OnDrawItem(DrawItemEventArgs e) {
            object item;

            if (e.Index >= 0) {

                if (e.Index < Items.Count) {
                    item = Items[e.Index];
                }
                else {
                    // If the item is not part of our collection, we will just
                    // get the string for it and display it.
                    //
                    int len = (int)SendMessage(NativeMethods.LB_GETTEXTLEN, e.Index, 0);
                    StringBuilder sb = new StringBuilder(len + 1);
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.LB_GETTEXT, e.Index, sb);
                    item = sb.ToString();
                }

                Rectangle bounds = e.Bounds;
                int border = 1;
                int height = Font.Height + 2 * border;

                // Determine bounds for the checkbox
                //
                int centeringFactor = Math.Max((height - idealCheckSize) / 2, 0);

                // Keep the checkbox within the item's upper and lower bounds
                if (centeringFactor + idealCheckSize > bounds.Height) {
                    centeringFactor = bounds.Height - idealCheckSize;
                }

                Rectangle box = new Rectangle(bounds.X + border,
                                              bounds.Y + centeringFactor,
                                              idealCheckSize,
                                              idealCheckSize);
                if (RightToLeft == RightToLeft.Yes) {
                    // For a RightToLeft checked list box, we want the checkbox
                    // to be drawn at the right.
                    // So we override the X position.
                    box.X = bounds.X + bounds.Width - idealCheckSize - border;
                }

                // set up the appearance of the checkbox
                //
                ButtonState state = ButtonState.Normal;
                if (flat) {
                    state |= ButtonState.Flat;
                }
                if (e.Index < Items.Count) {
                    switch (CheckedItems.GetCheckedState(e.Index)) {
                        case CheckState.Checked:
                            state |= ButtonState.Checked;
                            break;
                        case CheckState.Indeterminate:
                            state |= ButtonState.Checked | ButtonState.Inactive;
                            break;
                    }
                }

                // Draw the checkbox.
                //
                ControlPaint.DrawCheckBox(e.Graphics, box, state);
                // Determine bounds for the text portion of the item
                //
                Rectangle textBounds = new Rectangle(
                                                    bounds.X + idealCheckSize + (border * 2),
                                                    bounds.Y,
                                                    bounds.Width - (idealCheckSize + (border * 2)) ,
                                                    bounds.Height);
                if (RightToLeft == RightToLeft.Yes) {
                    // For a RightToLeft checked list box, we want the text
                    // to be drawn at the left.
                    // So we override the X position.
                    textBounds.X = bounds.X;
                }

                // Setup text font, color, and text
                //
                string text = "";
                Color backColor = BackColor;
                Color foreColor = ForeColor;
                if (!Enabled) {
                    foreColor = SystemColors.GrayText;
                }
                Font font = Font;

                object value = FilterItemOnProperty(item);
                
                if (value != null) {
                    text = value.ToString();
                }

                if (SelectionMode != SelectionMode.None && (e.State & DrawItemState.Selected) == DrawItemState.Selected) {
                    backColor = SystemColors.Highlight;
                    foreColor = SystemColors.HighlightText;
                }

                // Draw the text
                //

                // Due to some sort of unpredictable painting optimization in the Windows ListBox control,
                // we need to always paint the background rectangle for the current line.
                using (Brush b = new SolidBrush(backColor)) {
                    e.Graphics.FillRectangle(b, textBounds);
                }

                Rectangle stringBounds = new Rectangle(
                                                      textBounds.X + 1,
                                                      textBounds.Y + border,
                                                      textBounds.Width - 1,
                                                      textBounds.Height - border * 2);

                using (StringFormat format = new StringFormat()) {
                    if (UseTabStops) {
                        //  Set tab stops so it looks similar to a ListBox, at least with the default font size.
                        float tabDistance = 3.6f * Font.Height; // about 7 characters
                        float[] tabStops = new float[15];
                        float tabOffset = -(idealCheckSize + (border * 2));
                        for (int i = 1; i < tabStops.Length; i++)
                            tabStops[i] = tabDistance;

                        //(bug 111825)
                        if (Math.Abs(tabOffset) < tabDistance) {
                            tabStops[0] =  tabDistance +tabOffset;
                        }
                        else {
                            tabStops[0] =  tabDistance;
                        }
                            

                        
                        format.SetTabStops(0, tabStops);
                    }

                    // Adjust string format for Rtl controls
                    if (RightToLeft == RightToLeft.Yes) {
                        format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
                    }

                    // ListBox doesn't word-wrap its items, so neither should CheckedListBox
                    //                                
                    format.FormatFlags |= StringFormatFlags.NoWrap;

                    // Do actual drawing
                    using (SolidBrush brush = new SolidBrush(foreColor)) {
                        e.Graphics.DrawString(text, font, brush, stringBounds, format);
                    }
                }

                // Draw the focus rect if required
                //
                if ((e.State & DrawItemState.Focus) == DrawItemState.Focus && 
                    (e.State & DrawItemState.NoFocusRect) != DrawItemState.NoFocusRect) {
                    ControlPaint.DrawFocusRectangle(e.Graphics, textBounds, foreColor, backColor);
                }
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            base.OnBackColorChanged(e);
            
            if (IsHandleCreated) {
                SafeNativeMethods.InvalidateRect(new HandleRef(this, Handle), null, true);
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
        
            // Update the item height
            //
            if (IsHandleCreated) {
                SendMessage(NativeMethods.LB_SETITEMHEIGHT, 0, ItemHeight);            
            }
            
            // The base OnFontChanged will adjust the height of the CheckedListBox accordingly
            //
            base.OnFontChanged(e);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnKeyPress"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the "keyPress" event.  The Checked
        ///     ListBox overrides this to look for space characters, since we
        ///     want to use those to check or uncheck items periodically.  Don't
        ///     forget to call base.OnKeyPress() to ensure that KeyPrese events
        ///     are correctly fired for all other keys.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyPress(KeyPressEventArgs e) {
            if (e.KeyChar == ' '
                && SelectionMode != SelectionMode.None)
                LbnSelChange();
            else
                base.OnKeyPress(e);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnItemCheck"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the itemCheck event.  Don't
        ///     forget to call base.onItemCheck() to ensure that itemCheck vents
        ///     are correctly fired for all other keys.
        /// </devdoc>
        /// <internalonly/>
        protected virtual void OnItemCheck(ItemCheckEventArgs ice) {
            if (onItemCheck != null) onItemCheck(this, ice);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnMeasureItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnMeasureItem(MeasureItemEventArgs e) {
            base.OnMeasureItem(e);

            // we'll use the ideal checkbox size plus enough for padding on the top
            // and bottom
            //
            if (e.ItemHeight < idealCheckSize + 2) {
                e.ItemHeight = idealCheckSize + 2;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the selectedIndexChanged event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.OnSelectedIndexChanged(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected override void OnSelectedIndexChanged(EventArgs e) {
            
            base.OnSelectedIndexChanged(e);
            lastSelected = SelectedIndex;
            
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.SetItemCheckState"]/*' />
        /// <devdoc>
        ///     Sets the checked value of the given item.  This value should be from
        ///     the System.Windows.Forms.CheckState enumeration.
        /// </devdoc>
        public void SetItemCheckState(int index, CheckState value) {
            if (index < 0 || index >= Items.Count)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          (index).ToString()));
            if ( !Enum.IsDefined(typeof(CheckState), value)) 
                throw new InvalidEnumArgumentException("value", (int)value, typeof(CheckState));
        
            CheckState currentValue = CheckedItems.GetCheckedState(index);
            
            if (value != currentValue) {
                ItemCheckEventArgs itemCheckEvent = new ItemCheckEventArgs(index, value, currentValue);
                OnItemCheck(itemCheckEvent);

                if (itemCheckEvent.NewValue != currentValue) {
                    CheckedItems.SetCheckedState(index, itemCheckEvent.NewValue);
                    InvalidateItem(index);
                }
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.SetItemChecked"]/*' />
        /// <devdoc>
        ///     Sets the checked value of the given item.  This value should be a
        ///     boolean.
        /// </devdoc>
        public void SetItemChecked(int index, bool value) {
            SetItemCheckState(index, value ? CheckState.Checked : CheckState.Unchecked);
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.WmReflectCommand"]/*' />
        /// <devdoc>
        ///     We need to get LBN_SELCHANGE notifications
        /// </devdoc>
        /// <internalonly/>
        [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected override void WmReflectCommand(ref Message m) {
            switch ((int)m.WParam >> 16) {
                case NativeMethods.LBN_SELCHANGE:
                    LbnSelChange();
                    // finally, fire the OnSelectionChange event.
                    base.WmReflectCommand(ref m);
                    break;
                    
                case NativeMethods.LBN_DBLCLK:
                    // We want double-clicks to change the checkstate on each click - just like the CheckBox control
                    //
                    LbnSelChange();
                    base.WmReflectCommand(ref m);
                    break;

                default:
                    base.WmReflectCommand(ref m);
                    break;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.WmReflectVKeyToItem"]/*' />
        /// <devdoc>
        ///     Handle keyboard input to prevent arrow keys from toggling
        ///     checkboxes in CheckOnClick mode.
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectVKeyToItem(ref Message m) {
            int keycode = (int)m.WParam & 0xFFFF;
            switch ((Keys)keycode) {
                case Keys.Up:
                case Keys.Down:
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                case Keys.Left:
                case Keys.Right:
                    killnextselect = true;
                    break;
                default:
                    killnextselect = false;
                    break;
            }
            m.Result = NativeMethods.InvalidIntPtr;
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.WndProc"]/*' />
        /// <devdoc>
        ///     The listbox's window procedure.  Inheriting classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the button continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {

            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_CHARTOITEM:
                    m.Result = NativeMethods.InvalidIntPtr;
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_VKEYTOITEM:
                    WmReflectVKeyToItem(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ObjectCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new public class ObjectCollection : ListBox.ObjectCollection {
            private CheckedListBox owner;

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ObjectCollection.ObjectCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ObjectCollection(CheckedListBox owner)
            : base(owner) {
                this.owner = owner;
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ObjectCollection.Add"]/*' />
            /// <devdoc>
            ///     Lets the user add an item to the listbox with the given initial value
            ///     for the Checked portion of the item.
            /// </devdoc>
            public int Add(object item, bool isChecked) {
                return Add(item, isChecked ? CheckState.Checked : CheckState.Unchecked);
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.ObjectCollection.Add1"]/*' />
            /// <devdoc>
            ///     Lets the user add an item to the listbox with the given initial value
            ///     for the Checked portion of the item.
            /// </devdoc>
            public int Add(object item, CheckState check) {

                //validate the enum that's passed in here
                //
                if (!Enum.IsDefined(typeof(CheckState), check)) {
                    throw new InvalidEnumArgumentException("value", (int)check, typeof(CheckState));
                }
                
                int index = base.Add(item);
                owner.SetItemCheckState(index, check);

                return index;
            }
        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class CheckedIndexCollection : IList {
            private CheckedListBox owner;

            internal CheckedIndexCollection(CheckedListBox owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of current checked items.
            /// </devdoc>
            public int Count {
                get {
                    return owner.CheckedItems.Count;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the specified checked item.
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public int this[int index] {
                get {
                    object identifier = InnerArray.GetEntryObject(index, CheckedItemCollection.AnyMask);
                    return InnerArray.IndexOfIdentifier(identifier, 0);
                }
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(int index) {
                 return (IndexOf(index) != -1);
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object index) {
                if (index is Int32) {
                    return Contains((int)index);
                }
                else {
                    return false;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                int cnt = owner.CheckedItems.Count;
                for (int i = 0; i < cnt; i++) {
                    dest.SetValue(this[i], i + index);
                }
            }
            
            /// <devdoc>
            ///     This is the item array that stores our data.  We share this backing store
            ///     with the main object collection.
            /// </devdoc>
            private ItemArray InnerArray {
                get {
                    return ((ObjectCollection)owner.Items).InnerArray;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                int[] indices = new int[this.Count];
                CopyTo(indices, 0);
                return indices.GetEnumerator();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedIndexCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(int index) {
                if (index >= 0 && index < owner.Items.Count) {
                    object value = InnerArray.GetEntryObject(index, 0);
                    return owner.CheckedItems.IndexOfIdentifier(value);
                }
                return -1;
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedIndexCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object index) {
                if (index is Int32) {
                    return IndexOf((int)index);
                }
                else {
                    return -1;
                }
            }

        }
        
        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class CheckedItemCollection : IList {
        
            internal static int CheckedItemMask = ItemArray.CreateMask();
            internal static int IndeterminateItemMask = ItemArray.CreateMask();
            internal static int AnyMask = CheckedItemMask | IndeterminateItemMask;

            private CheckedListBox owner;

            internal CheckedItemCollection(CheckedListBox owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.Count"]/*' />
            /// <devdoc>
            ///     Number of current checked items.
            /// </devdoc>
            public int Count {
                get {
                    return InnerArray.GetCount(AnyMask);
                }
            }

            /// <devdoc>
            ///     This is the item array that stores our data.  We share this backing store
            ///     with the main object collection.
            /// </devdoc>
            private ItemArray InnerArray {
                get {
                    return ((ListBox.ObjectCollection)owner.Items).InnerArray;
                }
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the specified checked item.
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public object this[int index] {
                get {
                    return InnerArray.GetItem(index, AnyMask);
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return true;
                }
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(object item) {
                return IndexOf(item) != -1;            
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(object item) {
                return InnerArray.IndexOf(item, AnyMask);
            }
            
            internal int IndexOfIdentifier(object item) {
                return InnerArray.IndexOfIdentifier(item, AnyMask);
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                throw new NotSupportedException();
            }                                        
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedItemCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                int cnt = InnerArray.GetCount(AnyMask);
                for (int i = 0; i < cnt; i++) {
                    dest.SetValue(InnerArray.GetItem(i, AnyMask), i + index);
                }
            }
            
            /// <devdoc>
            ///     This method returns if the actual item index is checked.  The index is the index to the MAIN
            ///     collection, not this one.
            /// </devdoc>
            internal CheckState GetCheckedState(int index) {
                bool isChecked = InnerArray.GetState(index, CheckedItemMask);
                bool isIndeterminate = InnerArray.GetState(index, IndeterminateItemMask);
                Debug.Assert(!isChecked || !isIndeterminate, "Can't be both checked and indeterminate.  Somebody screwed up our state.");
                if (isIndeterminate) {
                    return CheckState.Indeterminate;
                }
                else if (isChecked) {
                    return CheckState.Checked;
                }
                
                return CheckState.Unchecked;
            }
            
            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedItemCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return InnerArray.GetEnumerator(AnyMask, true);
            }
        
            /// <devdoc>
            ///     Same thing for GetChecked.
            /// </devdoc>
            internal void SetCheckedState(int index, CheckState value) {
                bool isChecked;
                bool isIndeterminate;
                
                switch(value) {
                    case CheckState.Checked:
                        isChecked = true;
                        isIndeterminate = false;
                        break;
                        
                    case CheckState.Indeterminate:
                        isChecked = false;
                        isIndeterminate = true;
                        break;
                        
                    default:
                        isChecked = false;
                        isIndeterminate = false;
                        break;
                }
                InnerArray.SetState(index, CheckedItemMask, isChecked);
                InnerArray.SetState(index, IndeterminateItemMask, isIndeterminate);
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBoxAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class CheckedListBoxAccessibleObject : ControlAccessibleObject {

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBoxAccessibleObject.CheckedListBoxAccessibleObject"]/*' />
            /// <devdoc>
            /// </devdoc>
            public CheckedListBoxAccessibleObject(CheckedListBox owner) : base(owner) {
            }
            
            private CheckedListBox CheckedListBox {
                get {
                    return (CheckedListBox)Owner;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBoxAccessibleObject.GetChild"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override AccessibleObject GetChild(int index) {
                if (index >= 0 && index < CheckedListBox.Items.Count) {
                    return new CheckedListBoxItemAccessibleObject(CheckedListBox.Items[index].ToString(), index, this);
                }
                else {
                    return null;
                }
            }

            /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBoxAccessibleObject.GetChildCount"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override int GetChildCount() {
                return CheckedListBox.Items.Count;
            }
            
            public override AccessibleObject GetFocused() {
                int index = CheckedListBox.FocusedIndex;
                if (index >= 0) {
                    return GetChild(index);
                }
                
                return null;
            }
            
            public override AccessibleObject GetSelected() {
                int index = CheckedListBox.SelectedIndex;
                if (index >= 0) {
                    return GetChild(index);
                }
                
                return null;
            }
            
            public override AccessibleObject HitTest(int x, int y) {
            
                // Within a child element?
                //
                int count = GetChildCount();
                for(int index=0; index < count; ++index) {
                    AccessibleObject child = GetChild(index);
                    if (child.Bounds.Contains(x, y)) {
                        return child;
                    }
                }
                
                // Within the CheckedListBox bounds?
                //
                if (this.Bounds.Contains(x, y)) {
                    return this;
                }
                
                return null;
            }
            
            public override AccessibleObject Navigate(AccessibleNavigation direction) {
                if (GetChildCount() > 0) {
                    if (direction == AccessibleNavigation.FirstChild) {
                        return GetChild(0);
                    }
                    if (direction == AccessibleNavigation.LastChild) {
                        return GetChild(GetChildCount() - 1);
                    }
                }
                return base.Navigate(direction);
            }
        }

        /// <include file='doc\CheckedListBox.uex' path='docs/doc[@for="CheckedListBox.CheckedListBoxItemAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class CheckedListBoxItemAccessibleObject : AccessibleObject {

            private string name;
            private int index;
            private CheckedListBoxAccessibleObject parent;

            public CheckedListBoxItemAccessibleObject(string name, int index, CheckedListBoxAccessibleObject parent) : base() {
                this.name = name;
                this.parent = parent;
                this.index = index;
            }

            public override Rectangle Bounds {
                get {
                    Rectangle rect = ParentCheckedListBox.GetItemRectangle(index);

                    // Translate rect to screen coordinates
                    //
                    NativeMethods.POINT pt = new NativeMethods.POINT(rect.X, rect.Y);
                    UnsafeNativeMethods.ClientToScreen(new HandleRef(ParentCheckedListBox, ParentCheckedListBox.Handle), pt);

                    return new Rectangle(pt.x, pt.y, rect.Width, rect.Height);
                }
            }

            public override string DefaultAction {
                get {
                    if (ParentCheckedListBox.GetItemChecked(index)) {
                        return SR.GetString(SR.AccessibleActionUncheck);
                    }
                    else {
                        return SR.GetString(SR.AccessibleActionCheck);
                    }
                }
            }

            private CheckedListBox ParentCheckedListBox {
                get {
                    return(CheckedListBox)parent.Owner;
                }
            }

            public override string Name {
                get {
                    return name;
                }
                set {
                    name = value;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return parent;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ListItem;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Selectable | AccessibleStates.Focusable;

                    // Checked state
                    //
                    switch (ParentCheckedListBox.GetItemCheckState(index)) {
                        case CheckState.Checked:
                            state |= AccessibleStates.Checked;
                            break;
                        case CheckState.Indeterminate:
                            state |= AccessibleStates.Indeterminate;
                            break;
                        case CheckState.Unchecked:
                            // No accessible state corresponding to unchecked
                            break;
                    }

                    // Selected state
                    //
                    if (ParentCheckedListBox.SelectedIndex == index) {
                        state |= AccessibleStates.Selected | AccessibleStates.Focused;
                    }

                    return state;

                }
            }

            public override string Value {
                get {
                    return name;
                }
            }

            public override void DoDefaultAction() {
                ParentCheckedListBox.SetItemChecked(index, !ParentCheckedListBox.GetItemChecked(index));
            }
            
            public override AccessibleObject Navigate(AccessibleNavigation direction) {
                // Down/Next
                //
                if (direction == AccessibleNavigation.Down || 
                    direction == AccessibleNavigation.Next) {
                    if (index < parent.GetChildCount() - 1) {
                        return parent.GetChild(index + 1);
                    }
                }
                
                // Up/Previous
                //
                if (direction == AccessibleNavigation.Up ||
                    direction == AccessibleNavigation.Previous) {
                    if (index > 0) {
                        return parent.GetChild(index - 1);
                    }
                }
                
                return base.Navigate(direction);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\colordialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Drawing;

    using System.ComponentModel;
    using System.Windows.Forms;

    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a common dialog box that displays available colors along with
    ///       controls that allow the user to define custom colors.
    ///    </para>
    /// </devdoc>
    [DefaultProperty("Color")]
    // The only event this dialog has is HelpRequest, which isn't very useful
    public class ColorDialog : CommonDialog {

        private int options;
        private int[] customColors;

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.color"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private Color color;

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.ColorDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ColorDialog'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public ColorDialog() {
            customColors = new int[16];
            Reset();
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.AllowFullOpen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the user can use the dialog box
        ///       to define custom colors.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.CDallowFullOpenDescr)
        ]
        public virtual bool AllowFullOpen {
            get {
                return !GetOption(NativeMethods.CC_PREVENTFULLOPEN);
            }

            set {
                SetOption(NativeMethods.CC_PREVENTFULLOPEN, !value);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.AnyColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box displays all available colors in
        ///       the set of basic colors.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.CDanyColorDescr)
        ]
        public virtual bool AnyColor {
            get {
                return GetOption(NativeMethods.CC_ANYCOLOR);
            }

            set {
                SetOption(NativeMethods.CC_ANYCOLOR, value);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.Color"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color selected by the user.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.CDcolorDescr)
        ]
        public Color Color {
            get {
                return color;
            }
            set {
                if (!value.IsEmpty) {
                    color = value;
                }
                else {
                    color = Color.Black;
                }
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.CustomColors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the set of
        ///       custom colors shown in the dialog box.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.CDcustomColorsDescr)
        ]
        public int[] CustomColors {
            get { return(int[]) customColors.Clone();}
            set {
                int length = value == null? 0: Math.Min(value.Length, 16);
                if (length > 0) Array.Copy(value, 0, customColors, 0, length);
                for (int i = length; i < 16; i++) customColors[i] = 0x00FFFFFF;
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.FullOpen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the controls used to create custom
        ///       colors are visible when the dialog box is opened
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.CDfullOpenDescr)
        ]
        public virtual bool FullOpen {
            get {
                return GetOption(NativeMethods.CC_FULLOPEN);
            }

            set {
                SetOption(NativeMethods.CC_FULLOPEN, value);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.Instance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Our HINSTANCE from Windows.
        ///    </para>
        /// </devdoc>
        protected virtual IntPtr Instance {
            [
                SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
                SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
            ]
            get { return UnsafeNativeMethods.GetModuleHandle(null);}
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.Options"]/*' />
        /// <devdoc>
        ///    Returns our CHOOSECOLOR options.
        /// </devdoc>
        /// <internalonly/>
        protected virtual int Options {
            get {
                return options;
            }
        }


        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a Help button appears
        ///       in the color dialog box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.CDshowHelpDescr)
        ]
        public virtual bool ShowHelp {
            get {
                return GetOption(NativeMethods.CC_SHOWHELP);
            }
            set {
                SetOption(NativeMethods.CC_SHOWHELP, value);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.SolidColorOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating
        ///       whether the dialog
        ///       box will restrict users to selecting solid colors only.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.CDsolidColorOnlyDescr)
        ]
        public virtual bool SolidColorOnly {
            get {
                return GetOption(NativeMethods.CC_SOLIDCOLOR);
            }
            set {
                SetOption(NativeMethods.CC_SOLIDCOLOR, value);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.GetOption"]/*' />
        /// <devdoc>
        ///     Lets us control the CHOOSECOLOR options.
        /// </devdoc>
        /// <internalonly/>
        private bool GetOption(int option) {
            return(options & option) != 0;
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets
        ///       all options to their
        ///       default values, the last selected color to black, and the custom
        ///       colors to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            options = 0;
            color = Color.Black;
            CustomColors = null;
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.RunDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override bool RunDialog(IntPtr hwndOwner) {

            NativeMethods.WndProc hookProcPtr = new NativeMethods.WndProc(this.HookProc);
            NativeMethods.CHOOSECOLOR cc = new NativeMethods.CHOOSECOLOR();
            IntPtr custColorPtr = Marshal.AllocCoTaskMem(64);
            try {
                Marshal.Copy(customColors, 0, custColorPtr, 16);
                cc.hwndOwner = hwndOwner;
                cc.hInstance = Instance;
                cc.rgbResult = ColorTranslator.ToWin32(color);
                cc.lpCustColors = custColorPtr;

                int flags = Options | (NativeMethods.CC_RGBINIT | NativeMethods.CC_ENABLEHOOK);
                // Our docs say AllowFullOpen takes precedence over FullOpen; ChooseColor implements the opposite
                if (!AllowFullOpen)
                    flags &= ~NativeMethods.CC_FULLOPEN;
                cc.Flags = flags;

                cc.lpfnHook = hookProcPtr;
                if (!SafeNativeMethods.ChooseColor(cc)) return false;
                if (cc.rgbResult != ColorTranslator.ToWin32(color)) color = ColorTranslator.FromOle(cc.rgbResult);
                Marshal.Copy(custColorPtr, customColors, 0, 16);
                return true;
            }
            finally {
                Marshal.FreeCoTaskMem(custColorPtr);
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.SetOption"]/*' />
        /// <devdoc>
        ///     Allows us to manipulate the CHOOSECOLOR options
        /// </devdoc>
        /// <internalonly/>
        private void SetOption(int option, bool value) {
            if (value) {
                options |= option;
            }
            else {
                options &= ~option;
            }
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.ShouldSerializeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.ColorDialog.Color'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeColor() {
            return !Color.Equals(Color.Black);
        }

        /// <include file='doc\ColorDialog.uex' path='docs/doc[@for="ColorDialog.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides a string version of this object.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            string s = base.ToString();
            return s + ",  Color: " + Color.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\columnheaderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnHeaderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\ColumnHeaderStyle.uex' path='docs/doc[@for="ColumnHeaderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how <see cref='System.Windows.Forms.ListView'/> column headers behave.
    ///    </para>
    /// </devdoc>
    public enum ColumnHeaderStyle {

        /// <include file='doc\ColumnHeaderStyle.uex' path='docs/doc[@for="ColumnHeaderStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No visible column header.
        ///    </para>
        /// </devdoc>
        None         = 0,
        /// <include file='doc\ColumnHeaderStyle.uex' path='docs/doc[@for="ColumnHeaderStyle.Nonclickable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Visible column header that does not respond to clicking.
        ///    </para>
        /// </devdoc>
        Nonclickable = 1,
        /// <include file='doc\ColumnHeaderStyle.uex' path='docs/doc[@for="ColumnHeaderStyle.Clickable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Visible column header that responds to clicking.
        ///    </para>
        /// </devdoc>
        Clickable    = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\commondialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommonDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Drawing;   
    using System.Windows.Forms;    
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the base class used for displaying
    ///       dialog boxes on the screen.
    ///    </para>
    /// </devdoc>
    [
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public abstract class CommonDialog : Component {
        private static readonly object EventHelpRequest = new object();
        private const int CDM_SETDEFAULTFOCUS = NativeMethods.WM_USER + 0x51;
        private static int helpMsg;

        internal IntPtr defOwnerWndProc;

        private IntPtr  defaultControlHwnd;

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.CommonDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.CommonDialog'/> class.
        ///    </para>
        /// </devdoc>
        public CommonDialog() {
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.HelpRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the user clicks the Help button on a common
        ///       dialog box.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.CommonDialogHelpRequested)]
        public event EventHandler HelpRequest {
            add {
                Events.AddHandler(EventHelpRequest, value);
            }
            remove {
                Events.RemoveHandler(EventHelpRequest, value);
            }
        }

        // Generate meaningful result from Windows.CommDlgExtendedError()
        internal static string CommonDialogErrorToString(int error) {
            switch (error) {
                case NativeMethods.CDERR_DIALOGFAILURE: return "dialogfailure";
                case NativeMethods.CDERR_FINDRESFAILURE: return "findresfailure";
                case NativeMethods.CDERR_INITIALIZATION: return "initialization";
                case NativeMethods.CDERR_LOADRESFAILURE: return "loadresfailure";
                case NativeMethods.CDERR_LOADSTRFAILURE: return "loadstrfailure";
                case NativeMethods.CDERR_LOCKRESFAILURE: return "lockresfailure";
                case NativeMethods.CDERR_MEMALLOCFAILURE: return "memallocfailure";
                case NativeMethods.CDERR_MEMLOCKFAILURE: return "memlockfailure";
                case NativeMethods.CDERR_NOHINSTANCE: return "nohinstance";
                case NativeMethods.CDERR_NOHOOK: return "nohook";
                case NativeMethods.CDERR_NOTEMPLATE: return "notemplate";
                case NativeMethods.CDERR_REGISTERMSGFAIL: return "registermsgfail";
                case NativeMethods.CDERR_STRUCTSIZE: return "structsize";
                case NativeMethods.PDERR_CREATEICFAILURE: return "createicfailure";
                case NativeMethods.PDERR_DEFAULTDIFFERENT: return "defaultdifferent";
                case NativeMethods.PDERR_DNDMMISMATCH: return "dndmmismatch";
                case NativeMethods.PDERR_GETDEVMODEFAIL: return "getdevmodefail";
                case NativeMethods.PDERR_INITFAILURE: return "initfailure";
                case NativeMethods.PDERR_LOADDRVFAILURE: return "loaddrvfailure";
                case NativeMethods.PDERR_NODEFAULTPRN: return "nodefaultprn";
                case NativeMethods.PDERR_NODEVICES: return "nodevices";
                case NativeMethods.PDERR_PARSEFAILURE: return "parsefailure";
                case NativeMethods.PDERR_PRINTERNOTFOUND: return "printernotfound";
                case NativeMethods.PDERR_RETDEFFAILURE: return "retdeffailure";
                case NativeMethods.PDERR_SETUPFAILURE: return "setupfailure";
                case NativeMethods.CFERR_MAXLESSTHANMIN: return "maxlessthanmin";
                case NativeMethods.CFERR_NOFONTS: return "nofonts";
                case NativeMethods.FNERR_BUFFERTOOSMALL: return "buffertoosmall";
                case NativeMethods.FNERR_INVALIDFILENAME: return "invalidfilename";
                case NativeMethods.FNERR_SUBCLASSFAILURE: return "subclassfailure";
                case NativeMethods.FRERR_BUFFERLENGTHZERO : return "bufferlengthzero";
                default: return "unknown error";
            }
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.HookProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines the common dialog box hook
        ///       procedure that is overridden to add specific functionality to a common dialog
        ///       box.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
        SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected virtual IntPtr HookProc(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
            if (msg == NativeMethods.WM_INITDIALOG) {
                MoveToScreenCenter(hWnd);

                // Under some circumstances, the dialog
                // does not initially focus on any control. We fix that by explicitly
                // setting focus ourselves. See ASURT 39435.
                //
                this.defaultControlHwnd = wparam;
                UnsafeNativeMethods.SetFocus(new HandleRef(null, wparam));
            }
            else if (msg == NativeMethods.WM_SETFOCUS) {
                UnsafeNativeMethods.PostMessage(new HandleRef(null, hWnd), CDM_SETDEFAULTFOCUS, 0, 0);
            }
            else if (msg == CDM_SETDEFAULTFOCUS) {
                // If the dialog box gets focus, bounce it to the default control.
                // so we post a message back to ourselves to wait for the focus change then push it to the default
                // control. See ASURT 84016.
                //
                UnsafeNativeMethods.SetFocus(new HandleRef(this, defaultControlHwnd));
            }
            return IntPtr.Zero;
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.MoveToScreenCenter"]/*' />
        /// <devdoc>
        ///     Centers the given window on the screen. This method is used by the default
        ///     common dialog hook procedure to center the dialog on the screen before it
        ///     is shown.
        /// </devdoc>
        internal static void MoveToScreenCenter(IntPtr hWnd) {
            NativeMethods.RECT r = new NativeMethods.RECT();
            UnsafeNativeMethods.GetWindowRect(new HandleRef(null, hWnd), ref r);
            Rectangle screen = Screen.GetWorkingArea(Control.MousePosition);
            int x = screen.X + (screen.Width - r.right + r.left) / 2;
            int y = screen.Y + (screen.Height - r.bottom + r.top) / 3;
            SafeNativeMethods.SetWindowPos(new HandleRef(null, hWnd), NativeMethods.NullHandleRef, x, y, 0, 0, NativeMethods.SWP_NOSIZE |
                                 NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.OnHelpRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.CommonDialog.HelpRequest'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnHelpRequest(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventHelpRequest];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.OwnerWndProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines the owner window procedure that is
        ///       overridden to add specific functionality to a common dialog box.
        ///    </para>
        /// </devdoc>
        [
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual IntPtr OwnerWndProc(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
            if (msg == helpMsg) {
                try {
                    OnHelpRequest(EventArgs.Empty);
                }
                catch (Exception e) {
                    Application.OnThreadException(e);
                }
                return IntPtr.Zero;
            }
            return UnsafeNativeMethods.CallWindowProc(defOwnerWndProc, hWnd, msg, wparam, lparam);
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       resets the properties of a common dialog to their default
        ///       values.
        ///    </para>
        /// </devdoc>
        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
        public abstract void Reset();

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.RunDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       specifies a common dialog box.
        ///    </para>
        /// </devdoc>
        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
        protected abstract bool RunDialog(IntPtr hwndOwner);

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.ShowDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Runs a common dialog box.
        ///    </para>
        /// </devdoc>
        public DialogResult ShowDialog() {

            IntSecurity.SafeSubWindows.Demand();

            if (!SystemInformation.UserInteractive) {
                throw new InvalidOperationException(SR.GetString(SR.CantShowModalOnNonInteractive));
            }

            if (helpMsg == 0) {
                helpMsg = SafeNativeMethods.RegisterWindowMessage("commdlg_help");
            }
            IntPtr hwndOwner = UnsafeNativeMethods.GetActiveWindow();
            if (hwndOwner == IntPtr.Zero) hwndOwner = Application.GetParkingWindow(null).Handle;
            defOwnerWndProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(null, hwndOwner), NativeMethods.GWL_WNDPROC);

            // define ownerproc out here so it won't be garbage collected before the finally
            // clause runs
            NativeMethods.WndProc ownerProc = new NativeMethods.WndProc(this.OwnerWndProc);
            DialogResult result = DialogResult.Cancel;

            try {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(null, hwndOwner), NativeMethods.GWL_WNDPROC, ownerProc);
                
                Application.BeginModalMessageLoop();
                try {
                    result = RunDialog(hwndOwner) ? DialogResult.OK : DialogResult.Cancel;
                    GC.KeepAlive(ownerProc);
                }
                finally {
                    Application.EndModalMessageLoop();
                }
            }
            finally {
                if (UnsafeNativeMethods.IsWindow(new HandleRef(null, hwndOwner))) {
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(null, hwndOwner), NativeMethods.GWL_WNDPROC, new HandleRef(null, defOwnerWndProc));
                }
            }

            return result;
        }

        /// <include file='doc\CommonDialog.uex' path='docs/doc[@for="CommonDialog.ShowDialog1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Runs a common dialog box, parented to the given IWin32Window.
        ///    </para>
        /// </devdoc>
        public DialogResult ShowDialog( IWin32Window owner ) {

            IntSecurity.SafeSubWindows.Demand();

            if (owner == null || owner.Handle == IntPtr.Zero) {
                return ShowDialog();
            }

            if (!SystemInformation.UserInteractive) {
                throw new InvalidOperationException(SR.GetString(SR.CantShowModalOnNonInteractive));
            }
            
            if (helpMsg == 0) {
                helpMsg = SafeNativeMethods.RegisterWindowMessage("commdlg_help");
            }
            
            IntPtr hwndOwner = owner.Handle;
            defOwnerWndProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(owner, hwndOwner), NativeMethods.GWL_WNDPROC);

            // define ownerproc out here so it won't be garbage collected before the finally
            // clause runs
            NativeMethods.WndProc ownerProc = new NativeMethods.WndProc(this.OwnerWndProc);
            DialogResult result = DialogResult.Cancel;

            try {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(owner, hwndOwner), NativeMethods.GWL_WNDPROC, ownerProc);
                
                Application.BeginModalMessageLoop();
                try {
                    result = RunDialog(hwndOwner) ? DialogResult.OK : DialogResult.Cancel;
                    GC.KeepAlive(ownerProc);
                }
                finally {
                    Application.EndModalMessageLoop();
                }
            }
            finally {
                if (UnsafeNativeMethods.IsWindow(new HandleRef(owner, hwndOwner))) {
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(owner, hwndOwner), NativeMethods.GWL_WNDPROC, new HandleRef(null, defOwnerWndProc));
                }
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\command.cs ===
//------------------------------------------------------------------------------
// <copyright file="Command.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using Microsoft.Win32;

    /// <include file='doc\Command.uex' path='docs/doc[@for="Command"]/*' />
    /// <internalonly/>
    internal class Command : WeakReference {

        private static Command[] cmds;
        private static int icmdTry;
        private const int idMin = 0x00100;
        private const int idLim = 0x10000;

        internal int id;

        public Command(ICommandExecutor target)
            : base(target, false) {
            AssignID(this);
        }

        public virtual int ID {
            get {
                return id;
            }
        }

        protected static void AssignID(Command cmd) {
            lock(typeof(Command)) {
                int icmd;

                if (null == cmds) {
                    cmds = new Command[20];
                    icmd = 0;
                }
                else {
                    Debug.Assert(cmds.Length > 0, "why is cmds.Length zero?");
                    Debug.Assert(icmdTry >= 0, "why is icmdTry negative?");

                    int icmdLim = cmds.Length;

                    if (icmdTry >= icmdLim)
                        icmdTry = 0;

                    // First look for an empty slot (starting at icmdTry).
                    for (icmd = icmdTry; icmd < icmdLim; icmd++)
                        if (null == cmds[icmd]) goto FindSlotComplete;
                    for (icmd = 0; icmd < icmdTry; icmd++)
                        if (null == cmds[icmd]) goto FindSlotComplete;

                    // All slots have Command objects in them. Look for a command
                    // with a null referent.
                    for (icmd = 0; icmd < icmdLim; icmd++)
                        if (null == cmds[icmd].Target) goto FindSlotComplete;

                    // Grow the array.
                    icmd = cmds.Length;
                    icmdLim = Math.Min(idLim - idMin, 2 * icmd);

                    if (icmdLim <= icmd) {
                        // Already at maximal size. Do a garbage collect and look again.
                        GC.Collect();
                        for (icmd = 0; icmd < icmdLim; icmd++) {
                            if (null == cmds[icmd] || null == cmds[icmd].Target)
                                goto FindSlotComplete;
                        }
                        throw new ArgumentException(SR.GetString(SR.CommandIdNotAllocated));
                    }
                    else {
                        Command[] newCmds = new Command[icmdLim];
                        Array.Copy(cmds, 0, newCmds, 0, icmd);
                        cmds = newCmds;
                    }
                }

FindSlotComplete:

                cmd.id = icmd + idMin;
                Debug.Assert(cmd.id >= idMin && cmd.id < idLim, "generated command id out of range");

                cmds[icmd] = cmd;
                icmdTry = icmd + 1;
            }
        }

        public static bool DispatchID(int id) {
            Command cmd = GetCommandFromID(id);
            if (null == cmd)
                return false;
            return cmd.Invoke();
        }

        protected static void Dispose(Command cmd) {
            lock(typeof(Command)) {
                if (cmd.id >= idMin) {
                    cmd.Target = null;
                    if (cmds[cmd.id - idMin] == cmd)
                        cmds[cmd.id - idMin] = null;
                    cmd.id = 0;
                }
            }
        }

        public virtual void Dispose() {
            if (id >= idMin)
                Dispose(this);
        }

        public static Command GetCommandFromID(int id) {
            lock(typeof(Command)) {
                if (null == cmds)
                    return null;
                int i = id - idMin;
                if (i < 0 || i >= cmds.Length)
                    return null;
                return cmds[i];
            }
        }

        public virtual bool Invoke() {
            object target = Target;
            if (!(target is ICommandExecutor))
                return false;
            ((ICommandExecutor)target).Execute();
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\comboboxstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComboBoxStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ComboBoxStyle.uex' path='docs/doc[@for="ComboBoxStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the <see cref='System.Windows.Forms.ComboBox'/>
    ///       style.
    ///
    ///    </para>
    /// </devdoc>
    public enum ComboBoxStyle {

        /// <include file='doc\ComboBoxStyle.uex' path='docs/doc[@for="ComboBoxStyle.Simple"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The text portion is editable. The list portion is
        ///       always visible.
        ///
        ///    </para>
        /// </devdoc>
        Simple       = 0,

        /// <include file='doc\ComboBoxStyle.uex' path='docs/doc[@for="ComboBoxStyle.DropDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///
        ///       The text portion is editable. The user must click the arrow button to display
        ///       the list portion.
        ///
        ///    </para>
        /// </devdoc>
        DropDown     = 1,

        /// <include file='doc\ComboBoxStyle.uex' path='docs/doc[@for="ComboBoxStyle.DropDownList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       user cannot directly edit the text portion. The user must click the arrow button to
        ///       display the list portion.
        ///
        ///    </para>
        /// </devdoc>
        DropDownList = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\controlbindingscollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlBindingsCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents the collection of data bindings for a control.</para>
    /// </devdoc>
    [DefaultEvent("CollectionChanged"),
     Editor("System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing, typeof(System.Drawing.Design.UITypeEditor)),
     TypeConverterAttribute("System.Windows.Forms.Design.ControlBindingsConverter, " + AssemblyRef.SystemDesign),
     ]
    public class ControlBindingsCollection : BindingsCollection {

        internal Control control;

        // internalonly
        internal ControlBindingsCollection(Control control) : base() {
            Debug.Assert(control != null, "How could a controlbindingscollection not have a control associated with it!");
            this.control = control;
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Control"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Control Control {
            get {
                return control;
            }
        }
                
        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding this[string propertyName] {
            get {
                foreach (Binding binding in this) {
                    if (String.Compare(binding.PropertyName, propertyName, true, CultureInfo.InvariantCulture) == 0) {
                        return binding;
                    }
                }
                return null;
            }
        }
                
        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Add"]/*' />
        /// <devdoc>
        /// Adds the binding to the collection.  An ArgumentNullException is thrown if this binding
        /// is null.  An exception is thrown if a binding to the same target and Property as an existing binding or
        /// if the binding's column isn't a valid column given this DataSource.Table's schema.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        public new void Add(Binding binding) {
            AddCore(binding);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, binding));
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Add1"]/*' />
        /// <devdoc>
        /// Creates the binding and adds it to the collection.  An InvalidBindingException is thrown
        /// if this binding can't be constructed.  An exception is thrown if a binding to the same target and Property as an existing binding or
        /// if the binding's column isn't a valid column given this DataSource.Table's schema.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        public Binding Add(string propertyName, object dataSource, string dataMember) {
            if (dataSource == null)
                throw new ArgumentNullException("dataSource");
            Binding binding = new Binding(propertyName, dataSource, dataMember);
            Add(binding);
            return binding;
        }

/*
        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Add2"]/*' />
        public Binding Add(string propertyName, object dataSource, int columnIndex) {
            Binding binding = new Binding(propertyName, dataSource, columnIndex);
            Add(binding);
            return binding;
        }
*/

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.AddCore"]/*' />
        /// <devdoc>
        /// Creates the binding and adds it to the collection.  An InvalidBindingException is thrown
        /// if this binding can't be constructed.  An exception is thrown if a binding to the same target and Property as an existing binding or
        /// if the binding's column isn't a valid column given this DataSource.Table's schema.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        protected override void AddCore(Binding dataBinding) {
            if (dataBinding == null)
                throw new ArgumentNullException("dataBinding");
            if (dataBinding.Control == control)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionAdd1));
            if (dataBinding.Control != null)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionAdd2));

            // important to set prop first for error checking.
            dataBinding.SetControl(control);

            base.AddCore(dataBinding);
        }

        // internalonly
        internal void CheckDuplicates(Binding binding) {
            if (binding.PropertyName.Length == 0) {
                return;
            }
            for (int i = 0; i < Count; i++) {
                if (binding != this[i] && this[i].PropertyName.Length > 0 &&
                    (String.Compare(binding.PropertyName, this[i].PropertyName, false, CultureInfo.InvariantCulture) == 0)) {
                    throw new ArgumentException(SR.GetString(SR.BindingsCollectionDup), "binding");
                }
            }
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Clear"]/*' />
        /// <devdoc>
        /// Clears the collection of any bindings.
        /// Fires the CollectionChangedEvent.
        /// </devdoc>
        public new void Clear() {
            base.Clear();
        }

        // internalonly
        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.ClearCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void ClearCore() {
            int numLinks = Count;
            for (int i = 0; i < numLinks; i++) {
                Binding dataBinding = this[i];
                dataBinding.SetControl(null);
            }
            base.ClearCore();
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.Remove"]/*' />
        /// <devdoc>
        /// Removes the given binding from the collection.
        /// An ArgumentNullException is thrown if this binding is null.  An ArgumentException is thrown
        /// if this binding doesn't belong to this collection.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public new void Remove(Binding binding) {
            base.Remove(binding);
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// Removes the given binding from the collection.
        /// It throws an IndexOutOfRangeException if this doesn't have
        /// a valid binding.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public new void RemoveAt(int index) {
            base.RemoveAt(index);
        }

        /// <include file='doc\ControlBindingsCollection.uex' path='docs/doc[@for="ControlBindingsCollection.RemoveCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void RemoveCore(Binding dataBinding) {
            if (dataBinding.Control != control)
                throw new ArgumentException(SR.GetString(SR.BindingsCollectionForeign));
            dataBinding.SetControl(null);
            base.RemoveCore(dataBinding);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\contextmenu.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContextMenu.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu"]/*' />
    /// <devdoc>
    ///     This class is used to put context menus on your form and show them for
    ///     controls at runtime.  It basically acts like a regular Menu control,
    ///     but can be set for the ContextMenu property that most controls have.
    /// </devdoc>
    [
    DefaultEvent("Popup"),
    ]
    public class ContextMenu : Menu {

        private EventHandler onPopup;
        private Control sourceControl;
        
        private RightToLeft rightToLeft = System.Windows.Forms.RightToLeft.Inherit;

        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.ContextMenu"]/*' />
        /// <devdoc>
        ///     Creates a new ContextMenu object with no items in it by default.
        /// </devdoc>
        public ContextMenu()
            : base(null) {
        }

        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.ContextMenu1"]/*' />
        /// <devdoc>
        ///     Creates a ContextMenu object with the given MenuItems.
        /// </devdoc>
        public ContextMenu(MenuItem[] menuItems)
            : base(menuItems) {
        }

        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.SourceControl"]/*' />
        /// <devdoc>
        ///     The last control that was acted upon that resulted in this context
        ///     menu being displayed.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ContextMenuSourceControlDescr)
        ]
        public Control SourceControl {
            get {
                return sourceControl;
            }
        }



        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.Popup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRDescription(SR.MenuItemOnInitDescr)]
        public event EventHandler Popup {
            add {
                onPopup += value;
            }
            remove {
                onPopup -= value;
            }
        }      
        
        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.RightToLeft"]/*' />
        /// <devdoc>
        ///     This is used for international applications where the language
        ///     is written from RightToLeft. When this property is true,
        ///     text alignment and reading order will be from right to left.
        /// </devdoc>
        [
        Localizable(true),
        SRDescription(SR.MenuRightToLeftDescr)
        ]
        public virtual RightToLeft RightToLeft {
            get {
                if (System.Windows.Forms.RightToLeft.Inherit == rightToLeft) {
                    if (sourceControl != null) {
                        return ((Control)sourceControl).RightToLeft;
                    }
                    else {
                        return RightToLeft.No;
                    }
                }
                else {
                    return rightToLeft;
                }
            }
            set {
            
                if (!Enum.IsDefined(typeof(System.Windows.Forms.RightToLeft), value)) {
                    throw new InvalidEnumArgumentException("RightToLeft", (int)value, typeof(RightToLeft));
                }
                if (rightToLeft != value) {
                    rightToLeft = value;
                }

            }
        }  

        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.OnPopup"]/*' />
        /// <devdoc>
        ///     Fires the popup event
        /// </devdoc>
        protected internal virtual void OnPopup(EventArgs e) {
            if (onPopup != null) {
                onPopup.Invoke(this, e);
            }
        }
        
        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.ShouldSerializeRightToLeft"]/*' />
        /// <devdoc>
        ///     Returns true if the RightToLeft should be persisted in code gen.
        /// </devdoc>
        internal virtual bool ShouldSerializeRightToLeft() {
            if (System.Windows.Forms.RightToLeft.Inherit == rightToLeft) {
                return false;
            }
            return true;
        }

        /// <include file='doc\ContextMenu.uex' path='docs/doc[@for="ContextMenu.Show"]/*' />
        /// <devdoc>
        ///     Displays the context menu at the specified position.  This method
        ///     doesn't return until the menu is dismissed.
        /// </devdoc>
        public void Show(Control control, Point pos) {
            if (control == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                                    "control",
                                                                    "null"));

            if (!control.IsHandleCreated || !control.Visible)
                throw new ArgumentException(SR.GetString(SR.ContextMenuInvalidParent), "control");

            sourceControl = control;

            OnPopup(EventArgs.Empty);
            pos = control.PointToScreen(pos);
            SafeNativeMethods.TrackPopupMenuEx(new HandleRef(this, Handle),
                NativeMethods.TPM_VERTICAL,
                pos.X,
                pos.Y,
                new HandleRef(control, control.Handle),
                null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\containercontrol.cs ===
//----------------------------------------------------------------------------
// <copyright file="ContainerControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl"]/*' />
    /// <devdoc>
    ///    <para>Defines a
    ///       base class for
    ///       controls that can parent other controls.</para>
    /// </devdoc>
    public class ContainerControl : ScrollableControl, IContainerControl {
        /// <devdoc>
        ///     Current active control.
        /// </devdoc>
        private Control activeControl;
        /// <devdoc>
        ///     Current focused control. Do not directly edit this value.
        /// </devdoc>
        private Control focusedControl;

        /// <devdoc>
        ///     The last control that requires validation.  Do not directly edit this value.
        /// </devdoc>
        private Control unvalidatedControl;

        /// <devdoc>
        ///     Indicates whether we're currently validating.
        /// </devdoc>
        private bool validating = false;

        private static readonly int PropAxContainer            = PropertyStore.CreateKey();

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ContainerControl"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.ContainerControl'/>
        /// class.</para>
        /// </devdoc>
        public ContainerControl() : base() {
            SetStyle(ControlStyles.AllPaintingInWmPaint, false);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.BindingContext"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       The binding manager for the container control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        SRDescription(SR.ContainerControlBindingContextDescr)
        ]
        public override BindingContext BindingContext {
            get {
                BindingContext bm = base.BindingContext;
                if (bm == null) {
                    bm = new BindingContext();
                    BindingContext = bm;
                }
                return bm;
            }
            set {
                base.BindingContext = value;
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ActiveControl"]/*' />
        /// <devdoc>
        ///    <para>Indicates the current active control on the container control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ContainerControlActiveControlDescr)
        ]
        public Control ActiveControl {
            get {
                return activeControl;
            }

            set {
                SetActiveControl(value);
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.CreateParams"]/*' />
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= NativeMethods.WS_EX_CONTROLPARENT;
                return cp;
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ParentForm"]/*' />
        /// <devdoc>
        ///    <para>Indicates the form that the scrollable control is assigned to. This property is read-only.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ContainerControlParentFormDescr)
        ]
        public Form ParentForm {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();
                return ParentFormInternal;
            }
        }

        internal Form ParentFormInternal {
            get {
                if (ParentInternal != null) {
                    return ParentInternal.FindFormInternal();
                }
                else {
                    if (this is Form) {
                        return null;
                    }

                    return FindFormInternal();
                }
            }
        }

        // Package scope for Control
        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.IContainerControl.ActivateControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Activates the specified control.</para>
        /// </devdoc>
        bool IContainerControl.ActivateControl(Control control) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyFocus Demanded");
            IntSecurity.ModifyFocus.Demand();

            return ActivateControlInternal(control, true);
        }

        internal bool ActivateControlInternal(Control control) {
            return ActivateControlInternal(control, true);
        }

        internal bool ActivateControlInternal(Control control, bool originator) {
            // Recursive function that makes sure that the chain of active controls
            // is coherent.
            bool ret = true;
            bool updateContainerActiveControl = false;
            ContainerControl cc = null;
            Control parent = this.ParentInternal;
            if (parent != null)
            {
                cc = (parent.GetContainerControlInternal()) as ContainerControl;
                if (cc != null)
                {
                    updateContainerActiveControl = (cc.ActiveControl != this);
                }
            }
            if (control != activeControl || updateContainerActiveControl)
            {
                if (updateContainerActiveControl)
                {
                    if (!cc.ActivateControlInternal(this, false))
                    {
                        return false;
                    }
                }
                ret = AssignActiveControlInternal((control == this) ? null : control);
            }

            if (originator) {
                ScrollActiveControlIntoView();
            }
            return ret;
        }

        /// <internalonly/>
        /// <devdoc>
        ///     Used for UserControls - checks if the control
        ///     has a focusable control inside or not
        /// </devdoc>
        internal bool HasFocusableChild()
        {
            Control ctl = null;
            do {
                ctl = GetNextControl(ctl, true);
                if (ctl != null &&
                    ctl.CanSelect &&
                    ctl.TabStop)
                {
                    break;
                }
            } while (ctl != null);
            return ctl != null;
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.AdjustFormScrollbars"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void AdjustFormScrollbars(bool displayScrollbars) {
            base.AdjustFormScrollbars(displayScrollbars);

            if (!GetScrollState(ScrollStateUserHasScrolled)) {
                ScrollActiveControlIntoView();
            }
        }

        /// <devdoc>
        ///     Cleans up form state after a control has been removed.
        ///     Package scope for Control
        /// </devdoc>
        /// <internalonly/>
        internal virtual void AfterControlRemoved(Control control) {
            
            if (control == activeControl || control.Contains(activeControl)) {
                // REGISB: this branch never seems to be reached.
                //         leaving it intact to be on the safe side
                bool selected = SelectNextControl(control, true, true, true, true);
                if (selected) {
                    FocusActiveControlInternal();
                }
            }
            else if (activeControl == null && ParentInternal != null)
            {
                // The last control of an active container was removed. Focus needs to be given to the next
                // control in the Form.
                ContainerControl cc = ParentInternal.GetContainerControlInternal() as ContainerControl;
                if (cc != null && cc.ActiveControl == this)
                {
                    Form f = FindFormInternal();
                    if (f != null)
                    {
                        f.SelectNextControl(this, true, true, true, true);
                    }
                }
            }
            
            if (control == unvalidatedControl || control.Contains(unvalidatedControl)) {
                unvalidatedControl = null;
            }
        }

        private bool AssignActiveControlInternal(Control value) {
            Debug.Assert(value == null || (value.ParentInternal != null &&
                                           this == value.ParentInternal.GetContainerControlInternal()));
            if (activeControl != value) {
            // cpb: #7318
#if FALSE   
                if (activeControl != null) {
                    AxHost.Container cont = FindAxContainer();
                    if (cont != null) {
                        cont.OnOldActiveControl(activeControl, value);
                    }
                }
    #endif
                activeControl = value;
                UpdateFocusedControl();
                if (activeControl == value) {
                    // cpb: #7318
    #if FALSE
                    AxHost.Container cont = FindAxContainer();
                    if (cont != null) {
                        cont.OnNewActiveControl(value);
                    }
    #endif
                    Form form = FindFormInternal();
                    if (form != null)
                    {
                        form.UpdateDefaultButton();
                    }
                }
            }
            return(activeControl == value);
        }

        /// <devdoc>
        ///     Used to notify the AxContainer that the form
        ///     has been created.  This should only be called if
        ///     there is an AX container.
        /// </devdoc>
        private void AxContainerFormCreated() {
            ((AxHost.AxContainer)Properties.GetObject(PropAxContainer)).FormCreated();
        }

        private AxHost.AxContainer FindAxContainer() {
            object aXContainer = Properties.GetObject(PropAxContainer);
            if (aXContainer != null) return(AxHost.AxContainer)aXContainer;
            Control p = ParentInternal;

            if (p != null) {
                Form f = p.FindFormInternal();
                if (f != null) return f.FindAxContainer();
            }
            return null;
        }

        internal AxHost.AxContainer CreateAxContainer() {
            object aXContainer = Properties.GetObject(PropAxContainer);
            if (aXContainer == null) {
                aXContainer = new AxHost.AxContainer(this);
                Properties.SetObject(PropAxContainer, aXContainer);
            }
            return(AxHost.AxContainer)aXContainer;
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by 
        ///       the <see cref='System.Windows.Forms.ContainerControl'/>
        ///       .</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                activeControl = null;
            }
            base.Dispose(disposing);
        }

        /// <devdoc>
        ///     Assigns focus to the activeControl. If there is no activeControl then
        ///     focus is given to the form.
        ///     package scope for Form
        /// </devdoc>
        internal void FocusActiveControlInternal() {
#if DEBUG
            // Things really get ugly if you try to pop up an assert dialog here
            if (activeControl != null && !this.Contains(activeControl))
                Debug.WriteLine("ActiveControl is not a child of this ContainerControl");
#endif

            if (activeControl != null && activeControl.Visible) {
            
                // Avoid focus loops, especially with ComboBoxes, on Win98/ME.
                //
                IntPtr focusHandle = UnsafeNativeMethods.GetFocus();
                if (focusHandle == IntPtr.Zero || Control.FromChildHandleInternal(focusHandle) != activeControl) {
                    UnsafeNativeMethods.SetFocus(new HandleRef(activeControl, activeControl.Handle));
                }
            }
            else {
                // Determine and focus closest visible parent
                ContainerControl cc = this;
                while (cc != null && !cc.Visible)
                {
                    Control parent = cc.ParentInternal;
                    if (parent != null)
                    {
                        cc = parent.GetContainerControlInternal() as ContainerControl;
                    }
                    else {
                        break;
                    }
                }
                if (cc != null && cc.Visible)
                {
                    UnsafeNativeMethods.SetFocus(new HandleRef(cc, cc.Handle));
                }
            }
        }

        // internal for AxHost
        internal AxHost.AxContainer GetAxContainer() {
            return(AxHost.AxContainer)Properties.GetObject(PropAxContainer);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.OnCreateControl"]/*' />
        /// <devdoc>
        ///    <para> Raises the CreateControl event.</para>
        /// </devdoc>
        protected override void OnCreateControl() {
            base.OnCreateControl();
            
            if (Properties.GetObject(PropAxContainer) != null) {
                AxContainerFormCreated();
            }
            OnBindingContextChanged(EventArgs.Empty);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.OnControlRemoved"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Called when a child control is removed from this control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnControlRemoved(ControlEventArgs e) {
            Control c = e.Control;
            
            if (c == activeControl || c.Contains(activeControl))
                SetActiveControlInternal(null);
            if (c == unvalidatedControl || c.Contains(unvalidatedControl))
                unvalidatedControl = null;

            base.OnControlRemoved(e);
        }

        /// <devdoc>
        ///     Process an arrowKey press by selecting the next control in the group
        ///     that the activeControl belongs to.
        /// </devdoc>
        /// <internalonly/>
        private bool ProcessArrowKey(bool forward) {
            Control group = this;
            if (activeControl != null) {
                group = activeControl.ParentInternal;
            }
            return group.SelectNextControl(activeControl, forward, false, false, true);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ProcessDialogChar"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Processes a dialog character. Overrides Control.processDialogChar().
        ///    This method calls the processMnemonic() method to check if the character
        ///    is a mnemonic for one of the controls on the form. If processMnemonic()
        ///    does not consume the character, then base.processDialogChar() is
        ///    called.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override bool ProcessDialogChar(char charCode) {
#if DEBUG        
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "ContainerControl.ProcessDialogChar [" + charCode.ToString() + "]");
#endif          
            // If we're the top-level form or control, we need to do the mnemonic handling
            //
            if (GetTopLevel() && charCode != ' ' && ProcessMnemonic(charCode)) return true;
            return base.ProcessDialogChar(charCode);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ProcessDialogKey"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Processes a dialog key. Overrides Control.processDialogKey(). This
        ///    method implements handling of the TAB, LEFT, RIGHT, UP, and DOWN
        ///    keys in dialogs.
        ///    The method performs no processing on keys that include the ALT or
        ///    CONTROL modifiers. For the TAB key, the method selects the next control
        ///    on the form. For the arrow keys,
        ///    !!!
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
#if DEBUG        
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "ContainerControl.ProcessDialogKey [" + keyData.ToString() + "]");
#endif            
            if ((keyData & (Keys.Alt | Keys.Control)) == Keys.None) {
                Keys keyCode = (Keys)keyData & Keys.KeyCode;
                switch (keyCode) {
                    case Keys.Tab:
                        if (ProcessTabKey((keyData & Keys.Shift) == Keys.None)) return true;
                        break;
                    case Keys.Left:
                    case Keys.Right:
                    case Keys.Up:
                    case Keys.Down:
                        if (ProcessArrowKey(keyCode == Keys.Right ||
                                            keyCode == Keys.Down)) return true;
                        break;
                }
            }
            return base.ProcessDialogKey(keyData);
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ProcessMnemonic"]/*' />
        /// <internalonly/>
 
        protected override bool ProcessMnemonic(char charCode) {
#if DEBUG           
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "ContainerControl.ProcessMnemonic [" + charCode.ToString() + "]");
            Debug.Indent();
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "this == " + ToString());
#endif

            if (Controls.Count == 0) {
                Debug.Unindent();
                return false;
            }
            
            // Start with the control just past the currently focused one
            //
            Control start = ActiveControl;
            while(start is ContainerControl && ((ContainerControl)start).ActiveControl != null) {
                start = ((ContainerControl)start).ActiveControl;
            }
            
#if DEBUG
            int count = 0;
#endif //DEBUG

            bool wrapped = false;            
            
            Control ctl = start;
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Check starting at '" + ((start != null) ? start.ToString() : "<null>") + "'");
            
            do {
                // Loop through the controls starting at the current Active control 
                // till we find someone willing to process this mnemonic.
                //
                
#if DEBUG
                count++;
                if (count > 9999) {
                    Debug.Fail("Infinite loop trying to find controls which can ProcessMnemonic()!!!");
                }
#endif //DEBUG

                ctl = GetNextControl(ctl, true);

                if (ctl != null) {
#if DEBUG            
                    Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "  ...checking for mnemonics on " + ctl.ToString());
                    bool canProcess = ctl.CanProcessMnemonic(); // Processing the mnemonic can change the value of CanProcessMnemonic. See ASURT 39583.
#endif
                
                    if (ctl._ProcessMnemonic(charCode)) {
#if DEBUG                
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "  ...mnemonics found");
                        Debug.Assert(canProcess, "ProcessMnemonic returned true, even though CanProcessMnemonic() is false.  Someone probably overrode ProcessMnemonic and forgot to test CanSelect or CanProcessMnemonic().");
                        Debug.Unindent();
#endif                    
                        return true;
                    }
                }
                else { // ctl is null
                    if (wrapped) {
                        break;      // This avoids infinite loops
                    }
                    wrapped = true;                                         
                }
            } while (ctl != start);

            Debug.Unindent();
            return false;
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.ProcessTabKey"]/*' />
        /// <devdoc>
        ///    <para>Selects the next available control and makes it the active control.</para>
        /// </devdoc>
        protected virtual bool ProcessTabKey(bool forward) {
            if (SelectNextControl(activeControl, forward, true, true, false)) return true;
            return false;
        }

        private ScrollableControl FindScrollableParent(Control ctl) {
            Control current = ctl.ParentInternal;
            while (current != null && !(current is ScrollableControl)) {
                current = current.ParentInternal;
            }
            if (current != null) {
                return(ScrollableControl)current;
            }
            return null;
        }

        private void ScrollActiveControlIntoView() {
            Control last = activeControl;
            if (last != null) {
                ScrollableControl scrollParent = FindScrollableParent(last);

                while (scrollParent != null) {
                    scrollParent.ScrollControlIntoView(activeControl);
                    last = scrollParent;
                    scrollParent = FindScrollableParent(scrollParent);
                }
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.Select"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Select(bool directed, bool forward) {
            bool correctParentActiveControl = true;
            if (ParentInternal != null) 
            {
                IContainerControl c = ParentInternal.GetContainerControlInternal();
                if (c != null) 
                {
                    c.ActiveControl = this;
                    correctParentActiveControl = (c.ActiveControl == this);
                }
            }
            if (directed && correctParentActiveControl)
            {
                SelectNextControl(null, forward, true, true, false);
            }
        }

        private void SetActiveControl(Control ctl) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyFocus Demanded");
            IntSecurity.ModifyFocus.Demand();

            SetActiveControlInternal(ctl);
        }

        internal void SetActiveControlInternal(Control value) {
            if (activeControl != value || (value != null && !value.Focused)) {
                if (value != null && !Contains(value)) {
                    throw new ArgumentException(SR.GetString(SR.CannotActivateControl));
                }

                bool ret;
                ContainerControl cc = this;

                if (value != null && value.ParentInternal != null)
                {
                    cc = (value.ParentInternal.GetContainerControlInternal()) as ContainerControl;
                }
                if (cc != null)
                {
                    // Call to the recursive function that corrects the chain
                    // of active controls
                    ret = cc.ActivateControlInternal(value, false);
                }
                else
                {
                    ret = AssignActiveControlInternal(value);
                }

                if (cc != null && ret)
                {
                    ContainerControl ccAncestor = this;
                    while (ccAncestor.ParentInternal != null && 
                           ccAncestor.ParentInternal.GetContainerControlInternal() is ContainerControl)
                    {
                        ccAncestor = ccAncestor.ParentInternal.GetContainerControlInternal() as ContainerControl;
                        Debug.Assert(ccAncestor != null);
                    }

                    if (ccAncestor.ContainsFocus && 
                        (value == null || 
                         !(value is UserControl) ||
                         (value is UserControl && !((UserControl)value).HasFocusableChild())))
                    {
                        cc.FocusActiveControlInternal();
                    }
                }
            }
        }

        internal ContainerControl InnerMostActiveContainerControl
        {
            get
            {
                ContainerControl ret = this;
                while (ret.ActiveControl is ContainerControl)
                {
                    ret = (ContainerControl) ret.ActiveControl;
                }
                return ret;
            }
        }

        internal ContainerControl InnerMostFocusedContainerControl
        {
            get
            {
                ContainerControl ret = this;
                while (ret.focusedControl is ContainerControl)
                {
                    ret = (ContainerControl) ret.focusedControl;
                }
                return ret;
            }
        }


        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.UpdateDefaultButton"]/*' />
        /// <devdoc>
        ///     Updates the default button based on current selection, and the
        ///     acceptButton property.
        /// </devdoc>
        /// <internalonly/>
        protected virtual void UpdateDefaultButton() {
            // hook for form
        }
        
        /// <devdoc>
        ///     Updates the focusedControl variable by walking towards the
        ///     activeControl variable, firing enter and leave events and validation
        ///     as necessary.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateFocusedControl() {
            // Capture the current focusedControl as the unvalidatedControl if we don't have one/are not validating.
            if (!validating && unvalidatedControl == null) {
                unvalidatedControl = focusedControl;
                while (unvalidatedControl is ContainerControl && 
                       ((ContainerControl) unvalidatedControl).activeControl != null)
                {
                    unvalidatedControl = ((ContainerControl) unvalidatedControl).activeControl;
                }
            }

            Control pathControl = focusedControl;
            
            while (activeControl != pathControl) {
                if (pathControl == null || pathControl.IsDescendant(activeControl)) {
                    // heading down. find next control on path.
                    Control nextControlDown = activeControl;
                    while (true) {
                        Control parent = nextControlDown.ParentInternal;
                        if (parent == this || parent == pathControl)
                            break;
                        nextControlDown = nextControlDown.ParentInternal;
                    }

                    Control priorFocusedControl = focusedControl = pathControl;
                    EnterValidation(nextControlDown);
                    // If validation changed position, then jump back to the loop.
                    if (focusedControl != priorFocusedControl) {
                        pathControl = focusedControl;
                        continue;
                    }

                    pathControl = nextControlDown;
                    try {
                        pathControl.NotifyEnter();
                    }
                    catch (Exception e) {
                        Application.OnThreadException(e);
                    }
                }
                else {
                    // heading up.
                    ContainerControl innerMostFCC = InnerMostFocusedContainerControl;
                    Control stopControl = null;
                    
                    if (innerMostFCC.focusedControl != null)
                    {
                        pathControl = innerMostFCC.focusedControl;
                        stopControl = innerMostFCC;

                        if (innerMostFCC != this)
                        {
                            innerMostFCC.focusedControl = null;
                            if (!(innerMostFCC.ParentInternal != null && innerMostFCC.ParentInternal is MdiClient))
                            {
                                // Don't reset the active control of a MDIChild that loses the focus
                                innerMostFCC.activeControl = null;
                            }
                        }
                    }
                    else
                    {
                        pathControl = innerMostFCC;
                        // innerMostFCC.ParentInternal can be null when the ActiveControl is deleted.
                        if (innerMostFCC.ParentInternal != null)
                        {
                            ContainerControl cc = (innerMostFCC.ParentInternal.GetContainerControlInternal()) as ContainerControl;
                            stopControl = cc;
                            if (cc != null && cc != this)
                            {
                                cc.focusedControl = null;
                                cc.activeControl = null;
                            }
                        }
                    }

                    do
                    {
                        Control leaveControl = pathControl;
                    
                        if (pathControl != null)
                        {
                            pathControl = pathControl.ParentInternal;
                        }

                        if (pathControl == this)
                        {
                            pathControl = null;
                        }

                        try {
                            if (leaveControl != null)
                            {
                                leaveControl.NotifyLeave();
                            }
                        }
                        catch (Exception e) {
                            Application.OnThreadException(e);
                        }
                    }
                    while (pathControl != null &&
                           pathControl != stopControl &&
                           !pathControl.IsDescendant(activeControl));
                }
            }
            
            Debug.Assert(activeControl == null || activeControl.ParentInternal.GetContainerControlInternal() == this);
            focusedControl = activeControl;
            if (activeControl != null) {
                EnterValidation(activeControl);
            }
        }

        /// <devdoc>
        ///     Validates the last unvalidated control and its ancestors (up through the ancestor in common
        ///     with enterControl) if enterControl causes validation.
        /// </devdoc>
        /// <internalonly/>
        private void EnterValidation(Control enterControl) {
            if (unvalidatedControl != null && enterControl.CausesValidation) {
                while (enterControl != null && !enterControl.IsDescendant(unvalidatedControl)) {
                    enterControl = enterControl.ParentInternal;
                }
                ValidateThroughAncestor(enterControl);
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.Validate"]/*' />
        /// <devdoc>
        ///    <para>Validates the last unvalidated control and its ancestors up through, but not including the current control.</para>
        /// </devdoc>
        public bool Validate() {
            if (unvalidatedControl == null) {
                if (focusedControl is ContainerControl && focusedControl.CausesValidation) {
                    ContainerControl c = (ContainerControl)focusedControl;
                    c.Validate();
                }
                else
                     unvalidatedControl = focusedControl;
            }
            return ValidateThroughAncestor(null);
        }

        /// <devdoc>
        ///     Validates the last unvalidated control and its ancestors up through (but not including) ancestorControl.
        /// </devdoc>
        /// <internalonly/>
        private bool ValidateThroughAncestor(Control ancestorControl) {
            if (ancestorControl == null)
                ancestorControl = this;
            if (validating)
                return false;
            if (unvalidatedControl == null)
                unvalidatedControl = focusedControl;
            //return true for a Container Control with no controls to validate....
            //
            if (unvalidatedControl == null)
                return true;
            if (!ancestorControl.IsDescendant(unvalidatedControl))
                return false;

            this.validating = true;
            bool cancel = false;
            
            Control currentActiveControl = activeControl;
            Control currentValidatingControl = unvalidatedControl;
            if (currentActiveControl != null) {
                currentActiveControl.ValidationCancelled = false;
            }
            try {
                while (currentValidatingControl != ancestorControl) {
                    if (currentValidatingControl.CausesValidation) {
                        bool validationCancelled = false;

                        try {
                            validationCancelled = currentValidatingControl.NotifyValidating();
                        }
                        catch (Exception) {
                            // if the handler threw, we have to cancel
                            cancel = true;
                            throw;
                        }

                        // check whether the handler said cancel
                        if (validationCancelled) {
                            cancel = true;
                            break;
                        }
                        else {
                            try {
                                currentValidatingControl.NotifyValidated();
                            }
                            catch (Exception e) {
                                Application.OnThreadException(e);
                            }
                        }
                    }

                    currentValidatingControl = currentValidatingControl.ParentInternal;
                }

                if (cancel) {
                    if (currentActiveControl == activeControl) {
                        if (currentActiveControl != null) {
                            CancelEventArgs ev = new CancelEventArgs();
                            ev.Cancel = true;
                            currentActiveControl.NotifyValidationResult(currentValidatingControl, ev);
                            if (currentActiveControl is ContainerControl) {
                                ContainerControl currentActiveContainerControl = currentActiveControl as ContainerControl;
                                if (currentActiveContainerControl.focusedControl != null) {
                                    currentActiveContainerControl.focusedControl.ValidationCancelled = true;
                                }
                                currentActiveContainerControl.ResetActiveAndFocusedControlsRecursive();
                            }
                        }
                    }
                    SetActiveControlInternal(unvalidatedControl);
                }
            }
            finally {
                unvalidatedControl = null;
                validating = false;
            }
            
            return !cancel;
        }
        
        internal void ResetActiveAndFocusedControlsRecursive()
        {
            if (activeControl is ContainerControl)
            {
                ((ContainerControl) activeControl).ResetActiveAndFocusedControlsRecursive();
            }
            activeControl = null;
            focusedControl = null;
        }

        /// <devdoc>
        ///     WM_SETFOCUS handler
        /// </devdoc>
        /// <internalonly/>
        private void WmSetFocus(ref Message m) {
            
            if (!HostedInWin32DialogManager) {
                if (ActiveControl != null) {
                    ImeSetFocus();
                    // REGISB: Do not raise GotFocus event since the focus 
                    //         is given to the visible ActiveControl
                    if (!ActiveControl.Visible) {
                        OnGotFocus(EventArgs.Empty);
                    }
                    FocusActiveControlInternal();
                }
                else {
                    if (ParentInternal != null) {
                        IContainerControl c = ParentInternal.GetContainerControlInternal();
                        if (c != null) {
                            bool succeeded = false;
                            
                            ContainerControl knowncontainer = c as ContainerControl;
                            if (knowncontainer != null) {
                                succeeded = knowncontainer.ActivateControlInternal(this);
                            }
                            else {
        
                                // SECREVIEW : Taking focus and activating a control is response
                                //           : to a user gesture (WM_SETFOCUS) is OK.
                                //
                                IntSecurity.ModifyFocus.Assert();
                                try {
                                    succeeded = c.ActivateControl(this);
                                }
                                finally {
                                    CodeAccessPermission.RevertAssert();
                                }
                            }
                            if (!succeeded) {
                                return;
                            }
                        }
                    }                
                    base.WndProc(ref m);
                }
            }
            else {
                base.WndProc(ref m);
            }
        }

        /// <include file='doc\ContainerControl.uex' path='docs/doc[@for="ContainerControl.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_SETFOCUS:
                    WmSetFocus(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\controleventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ControlEventHandler.uex' path='docs/doc[@for="ControlEventHandler"]/*' />
    /// <devdoc>
    ///      Describes a delegate for an event that has a ControlEventArgs as
    ///      a parameter.
    /// </devdoc>
    public delegate void ControlEventHandler(object sender, ControlEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\controlevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;


    /// <include file='doc\ControlEvent.uex' path='docs/doc[@for="ControlEventArgs"]/*' />
    /// <devdoc>
    ///      A ControlEventArgs is an event that has a control
    ///      as a property.
    /// </devdoc>
    public class ControlEventArgs : EventArgs {
        private Control control;

        /// <include file='doc\ControlEvent.uex' path='docs/doc[@for="ControlEventArgs.Control"]/*' />
        /// <devdoc>
        ///      Retrieves the control object stored in this event.
        /// </devdoc>
        public Control Control {
            get {
                return control;
            }
        }

        /// <include file='doc\ControlEvent.uex' path='docs/doc[@for="ControlEventArgs.ControlEventArgs"]/*' />
        /// <devdoc>
        ///      Creates a new ControlEventArgs.
        /// </devdoc>
        public ControlEventArgs(Control control) {
            this.control = control;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\controlpaint.cs ===
#define GRAYSCALE_DISABLED
//------------------------------------------------------------------------------
// <copyright file="ControlPaint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Drawing.Text;
    using System.Drawing.Imaging;
    using System.Drawing.Drawing2D;
    using System.Runtime.InteropServices;


    /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint"]/*' />
    /// <devdoc>
    ///      The ControlPaint class provides a series of methods that can be used to
    ///      paint common Windows UI pieces.  Many windows forms controls use this class to paint
    ///      their UI elements.
    /// </devdoc>
    public sealed class ControlPaint {
        private static Bitmap       checkImage;         // image used to render checkmarks
        private static Pen          focusPen;           // pen used to draw a focus rectangle
        private static Pen          focusPenInvert;     // pen used to draw a focus rectangle
        private static Color        focusPenColor;      // the last background color the focus pen was created with
        private static Pen          grabPenPrimary;     // pen used for primary grab handles
        private static Pen          grabPenSecondary;   // pen used for secondary grab handles
        private static Brush        grabBrushPrimary;   // brush used for primary grab handles
        private static Brush        grabBrushSecondary; // brush used for secondary grab handles
        private static Brush        frameBrushActive;   // brush used for the active selection frame
        private static Color        frameColorActive;   // color of active frame brush
        private static Brush        frameBrushSelected; // brush used for the inactive selection frame
        private static Color        frameColorSelected; // color of selected frame brush
        private static Brush        gridBrush;          // brush used to draw a grid
        private static Size         gridSize;           // the dimensions of the grid dots
        private static bool         gridInvert;         // true if the grid color is inverted
        private static ImageAttributes disabledImageAttr; // ImageAttributes used to render disabled images

        //use these value to signify ANY of the right, top, left, center, or bottom alignments with the ContentAlignment enum.
        private static readonly ContentAlignment anyRight  = ContentAlignment.TopRight | ContentAlignment.MiddleRight | ContentAlignment.BottomRight;
        private static readonly ContentAlignment anyBottom = ContentAlignment.BottomLeft | ContentAlignment.BottomCenter | ContentAlignment.BottomRight;
        private static readonly ContentAlignment anyCenter = ContentAlignment.TopCenter | ContentAlignment.MiddleCenter | ContentAlignment.BottomCenter;
        private static readonly ContentAlignment anyMiddle = ContentAlignment.MiddleLeft | ContentAlignment.MiddleCenter | ContentAlignment.MiddleRight;


        // not creatable...
        //
        private ControlPaint() {
        }

        // a color appropriate for certain elements that are ControlDark in normal color schemes,
        // but for which ControlDark does not work in high contrast color schemes
        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.ContrastControlDark"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color ContrastControlDark {
            get {
                return SystemInformation.HighContrast ? SystemColors.WindowFrame : SystemColors.ControlDark;
            }
        }

        // Returns address of a BITMAPINFO for use by CreateHBITMAP16Bit
        private static IntPtr CreateBitmapInfo(Bitmap bitmap, IntPtr hdcS) {
            NativeMethods.BITMAPINFOHEADER header = new NativeMethods.BITMAPINFOHEADER();
            header.biSize = Marshal.SizeOf(header);
            header.biWidth = bitmap.Width;
            header.biHeight = bitmap.Height;
            header.biPlanes = 1;
            header.biBitCount = 16;
            header.biCompression = NativeMethods.BI_RGB;
            // leave everything else 0

            // Set up color table --
            int entryCount = 0;
            IntPtr palette = SafeNativeMethods.CreateHalftonePalette(new HandleRef(null, hdcS));
            UnsafeNativeMethods.GetObject(new HandleRef(null, palette), 2, ref entryCount);
            int[] entries = new int[entryCount];
            SafeNativeMethods.GetPaletteEntries(new HandleRef(null, palette), 0, entryCount, entries);
            int[] colors = new int[entryCount];
            for (int i = 0; i < entryCount; i++) {
                int entry = entries[i];
                colors[i]
                = (entry & unchecked((int)0xff000000)) >> 6 // red
                  + (entry & 0x00ff0000) >> 4 // blue
                  + (entry & 0x0000ff00) >> 2; // green
            }
            SafeNativeMethods.DeleteObject(new HandleRef(null, palette));

            IntPtr address = Marshal.AllocCoTaskMem(Marshal.SizeOf(header) + entryCount*4);
            Marshal.StructureToPtr(header, address, false);
            Marshal.Copy(colors, 0, (IntPtr)((long)address + Marshal.SizeOf(header)), entryCount);
            return address;
        }

        // Creates a 16-bit color bitmap.
        // Sadly, this must be public for the designer to get at it.
        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.CreateHBitmap16Bit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr CreateHBitmap16Bit(Bitmap bitmap, Color background) {
            Size size = bitmap.Size;

            IntPtr hdcS = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            byte[] enoughBits = new byte[bitmap.Width * bitmap.Height];
            IntPtr bitmapInfo = CreateBitmapInfo(bitmap, hdcS);
            IntPtr hBitmap = SafeNativeMethods.CreateDIBSection(new HandleRef(null, hdcS), new HandleRef(null, bitmapInfo), NativeMethods.DIB_RGB_COLORS,
                                                         enoughBits, IntPtr.Zero, 0);
            NativeMethods.BITMAP bm = new NativeMethods.BITMAP();
            UnsafeNativeMethods.GetObject(new HandleRef(null, hBitmap), Marshal.SizeOf(bm), bm);
            Marshal.FreeCoTaskMem(bitmapInfo);
            bitmapInfo = IntPtr.Zero;

            if (hBitmap == IntPtr.Zero) throw new Win32Exception();
            IntPtr dc = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hdcS));
            try {
                if (dc == IntPtr.Zero) throw new Win32Exception();
                IntPtr previousBitmap = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, hBitmap));
                try {
                    if (previousBitmap == IntPtr.Zero) throw new Win32Exception();
                    UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hdcS));

                    Brush brush = new SolidBrush(background);
                    Graphics graphics = Graphics.FromHdcInternal(dc);
                    try {
                        graphics.FillRectangle(brush, 0, 0, size.Width, size.Height);
                        brush.Dispose();

                        graphics.DrawImage(bitmap, 0, 0, size.Width, size.Height);
                    }
                    finally {
                        graphics.Dispose();
                    }
                }
                finally {
                    SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, previousBitmap));
                }
            }
            finally {
                UnsafeNativeMethods.DeleteDC(new HandleRef(null, dc));
            }


            return hBitmap;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.CreateHBitmapTransparencyMask"]/*' />
        /// <devdoc>
        ///     Creates a Win32 HBITMAP out of the image.  You are responsible for
        ///     de-allocating the HBITMAP with Windows.DeleteObject(handle).
        ///     If the image uses transparency, the background will be filled with the specified color.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr CreateHBitmapTransparencyMask(Bitmap bitmap) {
            Size size = bitmap.Size;
            int width = bitmap.Width;
            int height = bitmap.Height;

            int monochromeStride = width / 8;
            if ((width % 8) != 0) // wanted division to round up, not down
                monochromeStride++;
            // must be multiple of two -- i.e., bitmap 
            // scanlines must fall on double-byte boundaries
            if ((monochromeStride % 2) != 0)
                monochromeStride++;

            byte[] bits = new byte[monochromeStride * height];
            BitmapData data = bitmap.LockBits(new Rectangle(0,0, width, height),
                                              ImageLockMode.ReadOnly,
                                              PixelFormat.Format32bppArgb);

            Debug.Assert(data.Scan0 != IntPtr.Zero, "BitmapData.Scan0 is null; check marshalling");

            for (int y = 0; y < height; y++) {
                IntPtr scan = (IntPtr)((long)data.Scan0 + y * data.Stride);
                for (int x = 0; x < width; x++) {
                    int color = Marshal.ReadInt32(scan, x*4);
                    if (color >> 24 == 0) {
                        // pixel is transparent; set bit to 1
                        int index = monochromeStride * y + x / 8;
                        bits[index] |= (byte) (0x80 >> (x % 8));
                    }
                }
            }

            bitmap.UnlockBits(data);

            IntPtr mask = SafeNativeMethods.CreateBitmap(size.Width, size.Height, 1, /* 1bpp */ 1, bits);

            return mask;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.CreateHBitmapColorMask"]/*' />
        /// <devdoc>
        ///     Creates a Win32 HBITMAP out of the image.  You are responsible for
        ///     de-allocating the HBITMAP with Windows.DeleteObject(handle).
        ///     If the image uses transparency, the background will be filled with the specified color.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static IntPtr CreateHBitmapColorMask(Bitmap bitmap, IntPtr monochromeMask) {
            Size size = bitmap.Size;

            IntPtr colorMask = bitmap.GetHbitmap();
            IntPtr hdcS = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            IntPtr source = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hdcS));
            IntPtr target = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hdcS));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hdcS));
            IntPtr previousSourceBitmap = SafeNativeMethods.SelectObject(new HandleRef(null, source), new HandleRef(null, monochromeMask));
            IntPtr previousTargetBitmap = SafeNativeMethods.SelectObject(new HandleRef(null, target), new HandleRef(null, colorMask));

            // Now the trick is to make colorBitmap black wherever the transparent
            // color is located, but keep the original color everywhere else.
            // We've already got the original bitmap, so all we need to do is
            // to and with the inverse of the mask (ROP DSna).  When going from
            // monochrome to color, Windows sets all 1 bits to the background
            // color, and all 0 bits to the foreground color.
            //
            SafeNativeMethods.SetBkColor(new HandleRef(null, target), 0x00ffffff); // white
            SafeNativeMethods.SetTextColor(new HandleRef(null, target), 0); // black
            SafeNativeMethods.BitBlt(new HandleRef(null, target), 0, 0, size.Width, size.Height, new HandleRef(null, source),
                                     0, 0, 0x220326); // RasterOp.SOURCE.Invert().AndWith(RasterOp.TARGET).GetRop());

            SafeNativeMethods.SelectObject(new HandleRef(null, source), new HandleRef(null, previousSourceBitmap));
            SafeNativeMethods.SelectObject(new HandleRef(null, target), new HandleRef(null, previousTargetBitmap));
            UnsafeNativeMethods.DeleteDC(new HandleRef(null, source));
            UnsafeNativeMethods.DeleteDC(new HandleRef(null, target));

            return colorMask;
        }

        internal static IntPtr CreateHalftoneHBRUSH() {
            short[] grayPattern = new short[8];
            for (int i = 0; i < 8; i++)
                grayPattern[i] = (short)(0x5555 << (i & 1));
            IntPtr hBitmap = SafeNativeMethods.CreateBitmap(8, 8, 1, 1, grayPattern);

            NativeMethods.LOGBRUSH lb = new NativeMethods.LOGBRUSH();
            lb.lbColor = ColorTranslator.ToWin32(Color.Black);
            lb.lbStyle = NativeMethods.BS_PATTERN;
            lb.lbHatch = hBitmap;
            IntPtr brush = SafeNativeMethods.CreateBrushIndirect(lb);

            SafeNativeMethods.DeleteObject(new HandleRef(null, hBitmap));
            return brush;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.BorderStyleToDashStyle"]/*' />
        /// <devdoc>
        ///      Draws a border of the specified style and color to the given graphics.
        /// </devdoc>
        private static DashStyle BorderStyleToDashStyle(ButtonBorderStyle borderStyle) {
            switch (borderStyle) {
                case ButtonBorderStyle.Dotted: return DashStyle.Dot;
                case ButtonBorderStyle.Dashed: return DashStyle.Dash;
                case ButtonBorderStyle.Solid: return DashStyle.Solid;
                default:
                    Debug.Fail("border style has no corresponding dash style");
                    return DashStyle.Solid;
            }
        }        

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.Dark"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color Dark(Color baseColor, float percOfDarkDark) {
            return new HLSColor(baseColor).Darker(percOfDarkDark);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.Dark1"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color Dark(Color baseColor) {
            return new HLSColor(baseColor).Darker(0.5f);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DarkDark"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color DarkDark(Color baseColor) {
            return new HLSColor(baseColor).Darker(1.0f);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void DrawBorder(Graphics graphics, Rectangle bounds, Color color, ButtonBorderStyle style) {
            // Optimized version
            switch (style) {
                case ButtonBorderStyle.None:
                    // nothing
                    break;
                    
                case ButtonBorderStyle.Dotted:
                case ButtonBorderStyle.Dashed:
                case ButtonBorderStyle.Solid:
                    DrawBorderSimple(graphics, bounds, color, style);
                    break;

                case ButtonBorderStyle.Inset:
                case ButtonBorderStyle.Outset:
                    DrawBorderComplex(graphics, bounds, color, style);
                    break;

                default:
                    Debug.Fail("Unknown border style");
                    break;
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder1"]/*' />
        /// <devdoc>
        ///      Draws a border of the specified style and color to the given graphics.
        /// </devdoc>
        public static void DrawBorder(Graphics graphics, Rectangle bounds,
                                      Color leftColor, int leftWidth, ButtonBorderStyle leftStyle,
                                      Color topColor, int topWidth, ButtonBorderStyle topStyle,
                                      Color rightColor, int rightWidth, ButtonBorderStyle rightStyle,
                                      Color bottomColor, int bottomWidth, ButtonBorderStyle bottomStyle) {
            // Very general, and very slow

            int[] topLineLefts = new int[topWidth];
            int[] topLineRights = new int[topWidth];
            int[] leftLineTops = new int[leftWidth];
            int[] leftLineBottoms = new int[leftWidth];
            int[] bottomLineLefts = new int[bottomWidth];
            int[] bottomLineRights = new int[bottomWidth];
            int[] rightLineTops = new int[rightWidth];
            int[] rightLineBottoms = new int[rightWidth];

            float topToLeft = 0.0f;
            float bottomToLeft = 0.0f;
            if (leftWidth > 0) {
                topToLeft = ((float)topWidth)/((float)leftWidth);
                bottomToLeft = ((float)bottomWidth)/((float)leftWidth);
            }
            float topToRight = 0.0f;
            float bottomToRight = 0.0f;
            if (rightWidth > 0) {
                topToRight = ((float)topWidth)/((float)rightWidth);
                bottomToRight = ((float)bottomWidth)/((float)rightWidth);
            }

            HLSColor topHLSColor = new HLSColor(topColor);
            HLSColor leftHLSColor = new HLSColor(leftColor);
            HLSColor bottomHLSColor = new HLSColor(bottomColor);
            HLSColor rightHLSColor = new HLSColor(rightColor);

            if (topWidth > 0) {
                int i=0;
                for (; i<topWidth; i++) {
                    int leftOffset = 0;
                    if (topToLeft > 0) {
                        leftOffset = (int)(((float)i) / topToLeft);
                    }
                    int rightOffset = 0;
                    if (topToRight > 0) {
                        rightOffset = (int)(((float)i) / topToRight);
                    }
                    topLineLefts[i] = bounds.X + leftOffset;
                    topLineRights[i] = bounds.X + bounds.Width - rightOffset;
                    if (leftWidth > 0) {
                        leftLineTops[leftOffset] = bounds.Y + i + 1;
                    }
                    if (rightWidth > 0) {
                        rightLineTops[rightOffset] = bounds.Y + i;
                    }
                }
                for (int j=i; j<leftWidth; j++) {
                    leftLineTops[j] = bounds.Y + i + 1;
                }
                for (int j=i; j<rightWidth; j++) {
                    rightLineTops[j] = bounds.Y + i;
                }
            }
            else {
                for (int i=0; i<leftWidth; i++) {
                    leftLineTops[i] = bounds.Y;
                }
                for (int i=0; i<rightWidth; i++) {
                    rightLineTops[i] = bounds.Y;
                }
            }

            if (bottomWidth > 0) {
                int i=0;
                for (; i<bottomWidth; i++) {
                    int leftOffset = 0;
                    if (bottomToLeft > 0) {
                        leftOffset = (int)(((float)i) / bottomToLeft);
                    }
                    int rightOffset = 0;
                    if (bottomToRight > 0) {
                        rightOffset = (int)(((float)i) / bottomToRight);
                    }
                    bottomLineLefts[i] = bounds.X + leftOffset;
                    bottomLineRights[i] = bounds.X + bounds.Width - rightOffset;
                    if (leftWidth > 0) {
                        leftLineBottoms[leftOffset] = bounds.Y + bounds.Height - i - 1;
                    }
                    if (rightWidth > 0) {
                        rightLineBottoms[rightOffset] = bounds.Y + bounds.Height - i - 1;
                    }
                }
                for (int j=i; j<leftWidth; j++) {
                    leftLineBottoms[j] = bounds.Y + bounds.Height - i - 1;
                }
                for (int j=i; j<rightWidth; j++) {
                    rightLineBottoms[j] = bounds.Y + bounds.Height - i - 1;
                }
            }
            else {
                for (int i=0; i<leftWidth; i++) {
                    leftLineBottoms[i] = bounds.Y + bounds.Height - 1;
                }
                for (int i=0; i<rightWidth; i++) {
                    rightLineBottoms[i] = bounds.Y + bounds.Height - 1;
                }
            }

            Pen pen;

            // draw top line
            switch (topStyle) {
                case ButtonBorderStyle.None:
                    // nothing
                    break;
                case ButtonBorderStyle.Dotted:
                    pen = new Pen(topColor);
                    pen.DashStyle = DashStyle.Dot;
                    for (int i=0; i<topWidth; i++) {
                        graphics.DrawLine(pen, topLineLefts[i], bounds.Y + i, topLineRights[i], bounds.Y + i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Dashed:
                    pen = new Pen(topColor);
                    pen.DashStyle = DashStyle.Dash;
                    for (int i=0; i<topWidth; i++) {
                        graphics.DrawLine(pen, topLineLefts[i], bounds.Y + i, topLineRights[i], bounds.Y + i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Solid:
                    pen = new Pen(topColor);
                    pen.DashStyle = DashStyle.Solid;
                    for (int i=0; i<topWidth; i++) {
                        graphics.DrawLine(pen, topLineLefts[i], bounds.Y + i, topLineRights[i], bounds.Y + i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Inset: {
                        float inc = InfinityToOne(1.0f/(float)(topWidth-1));
                        for (int i=0; i<topWidth; i++) {
                            pen = new Pen(topHLSColor.Darker(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, topLineLefts[i], bounds.Y + i, topLineRights[i], bounds.Y + i);
                            pen.Dispose();
                        }
                        break;
                    }
                case ButtonBorderStyle.Outset: {
                        float inc = InfinityToOne(1.0f/(float)(topWidth-1));

                        for (int i=0; i<topWidth; i++) {
                            pen = new Pen(topHLSColor.Lighter(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, topLineLefts[i], bounds.Y + i, topLineRights[i], bounds.Y + i);
                            pen.Dispose();
                        }
                        break;
                    }
            }

            // Assertion: pen has been disposed
            pen = null;

            // draw left line
            switch (leftStyle) {
                case ButtonBorderStyle.None:
                    // nothing
                    break;
                case ButtonBorderStyle.Dotted:
                    pen = new Pen(leftColor);
                    pen.DashStyle = DashStyle.Dot;
                    for (int i=0; i<leftWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + i, leftLineTops[i], bounds.X + i, leftLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Dashed:
                    pen = new Pen(leftColor);
                    pen.DashStyle = DashStyle.Dash;
                    for (int i=0; i<leftWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + i, leftLineTops[i], bounds.X + i, leftLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Solid:
                    pen = new Pen(leftColor);
                    pen.DashStyle = DashStyle.Solid;
                    for (int i=0; i<leftWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + i, leftLineTops[i], bounds.X + i, leftLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Inset: {
                        float inc = InfinityToOne(1.0f/(float)(leftWidth-1));
                        for (int i=0; i<leftWidth; i++) {
                            pen = new Pen(leftHLSColor.Darker(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bounds.X + i, leftLineTops[i], bounds.X + i, leftLineBottoms[i]);
                            pen.Dispose();
                        }
                        break;
                    }
                case ButtonBorderStyle.Outset: {
                        float inc = InfinityToOne(1.0f/(float)(leftWidth-1));
                        for (int i=0; i<leftWidth; i++) {
                            pen = new Pen(leftHLSColor.Lighter(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bounds.X + i, leftLineTops[i], bounds.X + i, leftLineBottoms[i]);
                            pen.Dispose();
                        }
                        break;
                    }
            }

            // Assertion: pen has been disposed
            pen = null;

            // draw bottom line
            switch (bottomStyle) {
                case ButtonBorderStyle.None:
                    // nothing
                    break;
                case ButtonBorderStyle.Dotted:
                    pen = new Pen(bottomColor);
                    pen.DashStyle = DashStyle.Dot;
                    for (int i=0; i<bottomWidth; i++) {
                        graphics.DrawLine(pen, bottomLineLefts[i], bounds.Y + bounds.Height - 1 - i, bottomLineRights[i], bounds.Y + bounds.Height - 1 - i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Dashed:
                    pen = new Pen(bottomColor);
                    pen.DashStyle = DashStyle.Dash;
                    for (int i=0; i<bottomWidth; i++) {
                        graphics.DrawLine(pen, bottomLineLefts[i], bounds.Y + bounds.Height - 1 - i, bottomLineRights[i], bounds.Y + bounds.Height - 1 - i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Solid:
                    pen = new Pen(bottomColor);
                    pen.DashStyle = DashStyle.Solid;
                    for (int i=0; i<bottomWidth; i++) {
                        graphics.DrawLine(pen, bottomLineLefts[i], bounds.Y + bounds.Height - 1 - i, bottomLineRights[i], bounds.Y + bounds.Height - 1 - i);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Inset: {
                        float inc = InfinityToOne(1.0f/(float)(bottomWidth-1));
                        for (int i=0; i<bottomWidth; i++) {
                            pen = new Pen(bottomHLSColor.Lighter(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bottomLineLefts[i], bounds.Y + bounds.Height - 1 - i, bottomLineRights[i], bounds.Y + bounds.Height - 1 - i);
                            pen.Dispose();
                        }
                        break;
                    }
                case ButtonBorderStyle.Outset: {
                        float inc = InfinityToOne(1.0f/(float)(bottomWidth-1));

                        for (int i=0; i<bottomWidth; i++) {
                            pen = new Pen(bottomHLSColor.Darker(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bottomLineLefts[i], bounds.Y + bounds.Height - 1 - i, bottomLineRights[i], bounds.Y + bounds.Height - 1 - i);
                            pen.Dispose();
                        }
                        break;
                    }
            }

            // Assertion: pen has been disposed
            pen = null;

            // draw right line
            switch (rightStyle) {
                case ButtonBorderStyle.None:
                    // nothing
                    break;
                case ButtonBorderStyle.Dotted:
                    pen = new Pen(rightColor);
                    pen.DashStyle = DashStyle.Dot;
                    for (int i=0; i<rightWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + bounds.Width - 1 - i, rightLineTops[i], bounds.X + bounds.Width - 1 - i, rightLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Dashed:
                    pen = new Pen(rightColor);
                    pen.DashStyle = DashStyle.Dash;
                    for (int i=0; i<rightWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + bounds.Width - 1 - i, rightLineTops[i], bounds.X + bounds.Width - 1 - i, rightLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Solid:
                    pen = new Pen(rightColor);
                    pen.DashStyle = DashStyle.Solid;
                    for (int i=0; i<rightWidth; i++) {
                        graphics.DrawLine(pen, bounds.X + bounds.Width - 1 - i, rightLineTops[i], bounds.X + bounds.Width - 1 - i, rightLineBottoms[i]);
                    }
                    pen.Dispose();
                    break;
                case ButtonBorderStyle.Inset: {
                        float inc = InfinityToOne(1.0f/(float)(rightWidth-1));
                        for (int i=0; i<rightWidth; i++) {
                            pen = new Pen(rightHLSColor.Lighter(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bounds.X + bounds.Width - 1 - i, rightLineTops[i], bounds.X + bounds.Width - 1 - i, rightLineBottoms[i]);
                            pen.Dispose();
                        }
                        break;
                    }
                case ButtonBorderStyle.Outset: {
                        float inc = InfinityToOne(1.0f/(float)(rightWidth-1));

                        for (int i=0; i<rightWidth; i++) {
                            pen = new Pen(rightHLSColor.Darker(1.0f - ((float)i)*inc));
                            pen.DashStyle = DashStyle.Solid;
                            graphics.DrawLine(pen, bounds.X + bounds.Width - 1 - i, rightLineTops[i], bounds.X + bounds.Width - 1 - i, rightLineBottoms[i]);
                            pen.Dispose();
                        }

                        break;
                    }
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  The default 3D style of
        ///     Etched is used.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, Rectangle rectangle) {
            DrawBorder3D(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, Border3DStyle.Etched,
                         Border3DSide.Left | Border3DSide.Top | Border3DSide.Right | Border3DSide.Bottom);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D1"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  You may specify the style
        ///     of the 3D appearance.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, Rectangle rectangle, Border3DStyle style) {
            DrawBorder3D(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, style,
                         Border3DSide.Left | Border3DSide.Top | Border3DSide.Right | Border3DSide.Bottom);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D2"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  You may specify the style
        ///     of the 3D appearance, and which sides of the 3D rectangle you wish to
        ///     draw.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, Rectangle rectangle, Border3DStyle style, Border3DSide sides) {
            DrawBorder3D(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, style, sides);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D3"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  The default 3D style of
        ///     ETCHED is used.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, int x, int y, int width, int height) {
            DrawBorder3D(graphics, x, y, width, height, Border3DStyle.Etched,
                         Border3DSide.Left | Border3DSide.Top | Border3DSide.Right | Border3DSide.Bottom);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D4"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  You may specify the style
        ///     of the 3D appearance.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, int x, int y, int width, int height, Border3DStyle style) {
            DrawBorder3D(graphics, x, y, width, height, style,
                         Border3DSide.Left | Border3DSide.Top | Border3DSide.Right | Border3DSide.Bottom);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawBorder3D5"]/*' />
        /// <devdoc>
        ///     Draws a 3D style border at the given rectangle.  You may specify the style
        ///     of the 3D appearance, and which sides of the 3D rectangle you wish to
        ///     draw.
        /// </devdoc>
        public static void DrawBorder3D(Graphics graphics, int x, int y, int width, int height, Border3DStyle style, Border3DSide sides) {

            int edge = ((int)style) & 0x0F;
            int flags = ((int)sides) | (((int)style) & ~0x0F);

            NativeMethods.RECT rc = NativeMethods.RECT.FromXYWH(x, y, width, height);

            // Windows just draws the border to size, and then
            // shrinks the rectangle so the user can paint the
            // client area.  We can't really do that, so we do
            // the opposite:  We precalculate the size of the border
            // and enlarge the rectangle so the client size is
            // preserved.
            //
            if ((flags & (int)Border3DStyle.Adjust) == (int)Border3DStyle.Adjust) {
                Size sz = SystemInformation.Border3DSize;
                rc.left -= sz.Width;
                rc.right += sz.Width;
                rc.top -= sz.Height;
                rc.bottom += sz.Height;
                flags &= ~((int)Border3DStyle.Adjust);
            }

            IntPtr dc = graphics.GetHdc();
            SafeNativeMethods.DrawEdge(new HandleRef(null, dc), ref rc, edge, flags);
            graphics.ReleaseHdcInternal(dc);
        }
        
        /// <devdoc>
        ///     Helper function that draws a more complex border.  This is used by DrawBorder for less common
        ///     rendering cases.  We split DrawBorder into DrawBorderSimple and DrawBorderComplex so we maximize
        ///     the % of the function call.  It is less performant to have large functions that do many things.
        /// </devdoc>
        private static void DrawBorderComplex(Graphics graphics, Rectangle bounds, Color color, ButtonBorderStyle style) {
            if (style == ButtonBorderStyle.Inset) { // button being pushed
                HLSColor hls = new HLSColor(color);

                // top + left
                Pen pen = new Pen(hls.Darker(1.0f));
                graphics.DrawLine(pen, bounds.X, bounds.Y, 
                                  bounds.X + bounds.Width - 1, bounds.Y);
                graphics.DrawLine(pen, bounds.X, bounds.Y, 
                                  bounds.X, bounds.Y + bounds.Height - 1);

                // bottom + right
                pen.Color = hls.Lighter(1.0f);
                graphics.DrawLine(pen, bounds.X, bounds.Y + bounds.Height - 1, 
                                  bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
                graphics.DrawLine(pen, bounds.X + bounds.Width - 1, bounds.Y, 
                                  bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);

                // Top + left inset
                pen.Color = hls.Lighter(0.5f);
                graphics.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                                  bounds.X + bounds.Width - 2, bounds.Y + 1);
                graphics.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                                  bounds.X + 1, bounds.Y + bounds.Height - 2);

                // bottom + right inset
                if (color.ToKnownColor() == SystemColors.Control.ToKnownColor()) {
                    pen.Color = SystemColors.ControlLight;
                    graphics.DrawLine(pen, bounds.X + 1, bounds.Y + bounds.Height - 2,
                                      bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
                    graphics.DrawLine(pen, bounds.X + bounds.Width - 2, bounds.Y + 1,
                                      bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
                }

                pen.Dispose();
            }
            else { // Standard button
                Debug.Assert(style == ButtonBorderStyle.Outset, "Caller should have known how to use us.");
                
                bool stockColor = color.ToKnownColor() == SystemColors.Control.ToKnownColor();
                HLSColor hls = new HLSColor(color);

                // top + left
                Pen pen = stockColor ? SystemPens.ControlLightLight : new Pen(hls.Lighter(1.0f));
                graphics.DrawLine(pen, bounds.X, bounds.Y, 
                                  bounds.X + bounds.Width - 1, bounds.Y);
                graphics.DrawLine(pen, bounds.X, bounds.Y, 
                                  bounds.X, bounds.Y + bounds.Height - 1);

                // bottom + right
                if (stockColor) {
                    pen = SystemPens.ControlDarkDark;
                }
                else {
                    pen.Color = hls.Darker(1.0f);
                }
                graphics.DrawLine(pen, bounds.X, bounds.Y + bounds.Height - 1, 
                                  bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);
                graphics.DrawLine(pen, bounds.X + bounds.Width - 1, bounds.Y, 
                                  bounds.X + bounds.Width - 1, bounds.Y + bounds.Height - 1);

                // top + left inset
                if (stockColor) {
                    if (SystemInformation.HighContrast) {
                        pen = SystemPens.ControlLight;
                    }
                    else {
                        pen = SystemPens.Control;
                    }
                }
                else {
                    pen.Color = color;
                }
                graphics.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                                  bounds.X + bounds.Width - 2, bounds.Y + 1);
                graphics.DrawLine(pen, bounds.X + 1, bounds.Y + 1,
                                  bounds.X + 1, bounds.Y + bounds.Height - 2);

                // Bottom + right inset                        
                if (stockColor) {
                    pen = SystemPens.ControlDark;
                }
                else {
                    pen.Color = hls.Darker(0.5f);
                }                        
                
                graphics.DrawLine(pen, bounds.X + 1, bounds.Y + bounds.Height - 2,
                                  bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
                graphics.DrawLine(pen, bounds.X + bounds.Width - 2, bounds.Y + 1,
                                  bounds.X + bounds.Width - 2, bounds.Y + bounds.Height - 2);
                                  
                if (!stockColor) {
                    pen.Dispose();
                }
            }
        }
        
        /// <devdoc>
        ///     Helper function that draws a simple border.  This is used by DrawBorder for the most common rendering cases.
        /// </devdoc>
        private static void DrawBorderSimple(Graphics graphics, Rectangle bounds, Color color, ButtonBorderStyle style) {
            // Common case: system color with solid pen
            bool stockBorder = (style == ButtonBorderStyle.Solid && color.IsSystemColor);
            Pen pen;
            if (stockBorder) {
                pen = SystemPens.FromSystemColor(color);
            }
            else  {
                pen = new Pen(color);
                if (style != ButtonBorderStyle.Solid) {
                    pen.DashStyle = BorderStyleToDashStyle(style);
                }
            }
            graphics.DrawRectangle(pen, bounds.X, bounds.Y, bounds.Width - 1, bounds.Height - 1);
            
            if (!stockBorder) {
                pen.Dispose();
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawButton"]/*' />
        /// <devdoc>
        ///     Draws a Win32 button control in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawButton(Graphics graphics, Rectangle rectangle, ButtonState state) {
            DrawButton(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawButton1"]/*' />
        /// <devdoc>
        ///     Draws a Win32 button control in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawButton(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_BUTTON,
                             NativeMethods.DFCS_BUTTONPUSH | (int) state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawCaptionButton"]/*' />
        /// <devdoc>
        ///     Draws a Win32 window caption button in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawCaptionButton(Graphics graphics, Rectangle rectangle, CaptionButton button, ButtonState state) {
            DrawCaptionButton(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, button, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawCaptionButton1"]/*' />
        /// <devdoc>
        ///     Draws a Win32 window caption button in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawCaptionButton(Graphics graphics, int x, int y, int width, int height, CaptionButton button, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_CAPTION,
                             (int) button | (int) state);
        }


        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawCheckBox"]/*' />
        /// <devdoc>
        ///     Draws a Win32 checkbox control in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawCheckBox(Graphics graphics, Rectangle rectangle, ButtonState state) {
            DrawCheckBox(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawCheckBox1"]/*' />
        /// <devdoc>
        ///     Draws a Win32 checkbox control in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawCheckBox(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
            // Windows flat check box is too ugly for words.  We draw our own here
            if ((state & ButtonState.Flat) == ButtonState.Flat) {
                DrawFlatCheckBox(graphics, new Rectangle(x, y, width, height), state);
            }
            else {
                DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_BUTTON,
                                 NativeMethods.DFCS_BUTTONCHECK | (int) state);
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawComboButton"]/*' />
        /// <devdoc>
        ///     Draws the drop down button of a Win32 combo box in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawComboButton(Graphics graphics, Rectangle rectangle, ButtonState state) {
            DrawComboButton(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawComboButton1"]/*' />
        /// <devdoc>
        ///     Draws the drop down button of a Win32 combo box in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawComboButton(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_SCROLL,
                             NativeMethods.DFCS_SCROLLCOMBOBOX | (int) state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawContainerGrabHandle"]/*' />
        /// <devdoc>
        ///     Draws a container control grab handle glyph inside the given rectangle.
        /// </devdoc>
        public static void DrawContainerGrabHandle(Graphics graphics, Rectangle bounds) {

            Brush brush = Brushes.White;
            Pen pen = Pens.Black;

            graphics.FillRectangle(brush, bounds);
            graphics.DrawRectangle(pen, bounds.X, bounds.Y, bounds.Width - 1, bounds.Height - 1);

            int midx = bounds.X + bounds.Width/2;
            int midy = bounds.Y + bounds.Height/2;

            // vert line
            graphics.DrawLine(pen, midx, bounds.Y+2, midx, bounds.Y + bounds.Height-3);

            // horiz line
            graphics.DrawLine(pen, bounds.X+2, midy, bounds.X + bounds.Width-3, midy);

            // top hash
            graphics.DrawLine(pen, midx - 1, bounds.Y+3, midx+1, bounds.Y+3);

            // left hash
            graphics.DrawLine(pen, bounds.X+3, midy - 1, bounds.X + 3, midy + 1);

            // right hash
            graphics.DrawLine(pen, bounds.X + bounds.Width-4, midy - 1, bounds.X + bounds.Width-4, midy + 1);

            // bottom hash
            graphics.DrawLine(pen, midx - 1, bounds.Y + bounds.Height-4, midx+1, bounds.Y + bounds.Height-4);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawFlatCheckBox"]/*' />
        /// <devdoc>
        ///     Draws a flat checkbox.
        /// </devdoc>
        private static void DrawFlatCheckBox(Graphics graphics, Rectangle rectangle, ButtonState state) {
            // Background color of checkbox
            //
            Brush background = ((state & ButtonState.Inactive) == ButtonState.Inactive) ?
                               SystemBrushes.Control :
                               SystemBrushes.Window;
            Color foreground = ((state & ButtonState.Inactive) == ButtonState.Inactive) ?
                               SystemColors.ControlDark :
                               SystemColors.ControlText;
            DrawFlatCheckBox(graphics, rectangle, foreground, background, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawFlatCheckBox1"]/*' />
        /// <devdoc>
        ///     Draws a Win32 checkbox control in the given rectangle with the given state.  This
        ///     draws a flat looking check box that is suitable for use in list boxes, etc. We
        ///     custom draw this because the windows version is soooo ugly.
        /// </devdoc>
        /// <internalonly/>
        private static void DrawFlatCheckBox(Graphics graphics, Rectangle rectangle, Color foreground, Brush background, ButtonState state) {
            Rectangle offsetRectangle = new Rectangle(rectangle.X + 1, rectangle.Y + 1,
                                                      rectangle.Width - 2, rectangle.Height - 2);
            graphics.FillRectangle(background, offsetRectangle);

            // Checkmark
            //
            if ((state & ButtonState.Checked) == ButtonState.Checked) {
                if (checkImage == null || checkImage.Width != rectangle.Width || checkImage.Height != rectangle.Height) {

                    if (checkImage != null) {
                        checkImage.Dispose();
                        checkImage = null;
                    }

                    // We draw the checkmark slightly off center to eliminate 3-D border artifacts,
                    // and compensate below
                    NativeMethods.RECT rcCheck = NativeMethods.RECT.FromXYWH(0, 0, rectangle.Width, rectangle.Height);
                    Bitmap bitmap = new Bitmap(rectangle.Width, rectangle.Height);
                    using (Graphics g2 = Graphics.FromImage(bitmap)) {
                        g2.Clear(Color.Transparent);
                        IntPtr dc = g2.GetHdc();
                        try {
                            SafeNativeMethods.DrawFrameControl(new HandleRef(null, dc), ref rcCheck,
                                                               NativeMethods.DFC_MENU, NativeMethods.DFCS_MENUCHECK);
                        }
                        finally {
                            g2.ReleaseHdcInternal(dc);
                        }
                    }
                    bitmap.MakeTransparent();
                    checkImage = bitmap;
                }

                rectangle.X += 1;
                DrawImageColorized(graphics, checkImage, rectangle, foreground);
                rectangle.X -= 1;
            }

            // Surrounding border.  We inset this by one pixel so we match how
            // the 3D checkbox is drawn.
            //
            Pen pen = SystemPens.ControlDark;
            graphics.DrawRectangle(pen, offsetRectangle.X, offsetRectangle.Y, offsetRectangle.Width - 1, offsetRectangle.Height - 1);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawFocusRectangle"]/*' />
        /// <devdoc>
        ///      Draws a focus rectangle.  A focus rectangle is a dotted rectangle that Windows
        ///      uses to indicate what control has the current keyboard focus.
        /// </devdoc>
        public static void DrawFocusRectangle(Graphics graphics, Rectangle rectangle) {
            DrawFocusRectangle(graphics, rectangle, SystemColors.ControlText, SystemColors.Control);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawFocusRectangle1"]/*' />
        /// <devdoc>
        ///      Draws a focus rectangle.  A focus rectangle is a dotted rectangle that Windows
        ///      uses to indicate what control has the current keyboard focus.
        /// </devdoc>
        public static void DrawFocusRectangle(Graphics graphics, Rectangle rectangle, Color foreColor, Color backColor) {
            rectangle.Width --;
            rectangle.Height--;
            graphics.DrawRectangle(GetFocusPen(backColor,
                                               // we want the corner to be penned
                                               // see GetFocusPen for more explanation
                                               (rectangle.X + rectangle.Y) % 2 == 1),
                                   rectangle);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawFrameControl"]/*' />
        /// <devdoc>
        ///     Draws a win32 frame control.
        /// </devdoc>
        private static void DrawFrameControl(Graphics graphics, int x, int y, int width, int height, int kind, int state) {
            NativeMethods.RECT rcFrame = NativeMethods.RECT.FromXYWH(0, 0, width, height);

            Bitmap bitmap = new Bitmap(width, height);
            Graphics g2 = Graphics.FromImage(bitmap);
            g2.Clear(Color.Transparent);
            IntPtr dc = g2.GetHdc();
            SafeNativeMethods.DrawFrameControl(new HandleRef(null, dc), ref rcFrame, kind, (int) state);
            // SECREVIEW : GetHdc allocs the handle, so we must release it.
            //
            IntSecurity.Win32HandleManipulation.Assert();
            try {
                g2.ReleaseHdc(dc);
            }
            finally {
                CodeAccessPermission.RevertAssert();
                g2.Dispose();
            }

            graphics.DrawImage(bitmap, x, y);
            bitmap.Dispose();
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawGrabHandle"]/*' />
        /// <devdoc>
        ///      Draws a standard selection grab handle with the given dimensions.  Grab
        ///      handles are used by components to indicate to the user that they can
        ///      be directly maniupulated.
        /// </devdoc>
        public static void DrawGrabHandle(Graphics graphics, Rectangle rectangle, bool primary, bool enabled) {
            Pen pen;
            Brush brush;

            if (primary) {
                if (null == grabPenPrimary) {
                    grabPenPrimary = Pens.Black;
                }
                pen = grabPenPrimary;


                if (enabled) {
                    if (null == grabBrushPrimary) {
                        grabBrushPrimary = Brushes.White;
                    }
                    brush = grabBrushPrimary;
                }
                else {
                    brush = SystemBrushes.Control;
                }
            }
            else {
                if (null == grabPenSecondary) {
                    grabPenSecondary = Pens.White;
                }
                pen = grabPenSecondary;

                if (enabled) {
                    if (null == grabBrushSecondary) {
                        grabBrushSecondary = Brushes.Black;
                    }
                    brush = grabBrushSecondary;
                }
                else {
                    brush = SystemBrushes.Control;
                }
            }

            Rectangle fillRect = new Rectangle(rectangle.X + 1, rectangle.Y + 1, rectangle.Width - 1, rectangle.Height - 1);
            graphics.FillRectangle(brush, fillRect);
            rectangle.Width --;
            rectangle.Height--;
            graphics.DrawRectangle(pen, rectangle);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawGrid"]/*' />
        /// <devdoc>
        ///      Draws a grid of one pixel dots in the given rectangle.
        /// </devdoc>
        public static void DrawGrid(Graphics graphics, Rectangle area, Size pixelsBetweenDots, Color backColor) {

            float intensity = backColor.GetBrightness();
            bool invert = (intensity < .5);
            
            lock(typeof(ControlPaint)) {
                if (gridBrush == null || gridSize.Width != pixelsBetweenDots.Width 
                    || gridSize.Height != pixelsBetweenDots.Height || invert != gridInvert) {
    
                    if (gridBrush != null) {
                        gridBrush.Dispose();
                        gridBrush = null;
                    }
    
                    gridSize = pixelsBetweenDots;
                    int idealSize = 16;
                    gridInvert = invert;
                    Color foreColor = (gridInvert) ? Color.White : Color.Black;
    
                    // Round size to a multiple of pixelsBetweenDots
                    int width = ((idealSize / pixelsBetweenDots.Width) + 1) * pixelsBetweenDots.Width;
                    int height = ((idealSize / pixelsBetweenDots.Height) + 1) * pixelsBetweenDots.Height;
    
                    Bitmap bitmap = new Bitmap(width, height);
    
                    // draw the dots
                    for (int x = 0; x < width; x += pixelsBetweenDots.Width)
                        for (int y = 0; y < height; y += pixelsBetweenDots.Height)
                            bitmap.SetPixel(x, y, foreColor);
    
                    gridBrush = new TextureBrush(bitmap);
                    bitmap.Dispose();
                }
            }
            
            graphics.FillRectangle(gridBrush, area);
        }

        // Takes a black and white image, and paints it in color
        internal static void DrawImageColorized(Graphics graphics, Image image, Rectangle destination, 
                                                Color replaceBlack, Color replaceWhite) {
            DrawImageColorized(graphics, image, destination, 
                               RemapBlackAndWhiteAndTransparentMatrix(replaceBlack, replaceWhite));
        }

        // Takes a black and transparent image, turns black pixels into some other color, and leaves transparent pixels alone
        internal static void DrawImageColorized(Graphics graphics, Image image, Rectangle destination, 
                                                Color replaceBlack) {
            DrawImageColorized(graphics, image, destination, 
                               RemapBlackAndWhitePreserveTransparentMatrix(replaceBlack, Color.White));
        }

        // takes an image and replaces all the pixels of oldColor with newColor, drawing the new image into the rectangle on
        // the supplied Graphics object.
        internal static void DrawImageReplaceColor(Graphics g, Image image, Rectangle dest, Color oldColor, Color newColor) {
            ImageAttributes attrs = new ImageAttributes();

            ColorMap cm = new ColorMap();
            cm.OldColor = oldColor;
            cm.NewColor = newColor;

            attrs.SetRemapTable(new ColorMap[]{cm}, ColorAdjustType.Bitmap);

            g.DrawImage(image, dest, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, attrs, null, IntPtr.Zero);
            attrs.Dispose();
        }


        // Takes a black and white image, and paints it in color
        private static void DrawImageColorized(Graphics graphics, Image image, Rectangle destination, 
                                               ColorMatrix matrix) {
            ImageAttributes attributes = new ImageAttributes();
            attributes.SetColorMatrix(matrix);
            graphics.DrawImage(image, destination, 0,0, image.Width, image.Height,
                               GraphicsUnit.Pixel, attributes, null, IntPtr.Zero);
            attributes.Dispose();
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawImageDisabled"]/*' />
        /// <devdoc>
        ///     Draws an image and makes it look disabled.
        /// </devdoc>
        public static void DrawImageDisabled(Graphics graphics, Image image, int x, int y, Color background) {
#if GRAYSCALE_DISABLED
            Size imageSize = image.Size;

            if (disabledImageAttr == null) {
                // This is how I came up with this somewhat random ColorMatrix.
                // Its set to resemble Office10 commandbars, but still be able to
                // deal with hi-color (256+) icons and images.
                //
                // The idea is to scale everything down (more than just a grayscale does,
                // therefore the small numbers in the scaling part of matrix)
                // White -> some shade of gray &
                // Black -> Black
                //
                // Second part of the matrix is to translate everything, so all colors are
                // a bit brigher.
                // Grays become lighter and washed out looking
                // Black becomes a shade of gray as well.
                //
                // btw, if you do come up with something better let me know - nikhilko
                
                float[][] array = new float[5][];
                    array[0] = new float[5] {0.2125f, 0.2125f, 0.2125f, 0, 0};
                array[1] = new float[5] {0.2577f, 0.2577f, 0.2577f, 0, 0};
                array[2] = new float[5] {0.0361f, 0.0361f, 0.0361f, 0, 0};
                array[3] = new float[5] {0,       0,       0,       1, 0};
                array[4] = new float[5] {0.38f,   0.38f,   0.38f,   0, 1};

                ColorMatrix grayMatrix = new ColorMatrix(array);

                disabledImageAttr = new ImageAttributes();
                disabledImageAttr.ClearColorKey();
                disabledImageAttr.SetColorMatrix(grayMatrix);
            }

            graphics.DrawImage(image, 
                               new Rectangle(x, y, imageSize.Width, imageSize.Height), 
                               0, 0, imageSize.Width, imageSize.Height,
                               GraphicsUnit.Pixel, 
                               disabledImageAttr);
#else


            // This is remarkably simple -- make a monochrome version of the image, draw once
            // with the button highlight color, then a second time offset by one pixel
            // and in the button shadow color.
            // Technique borrowed from comctl Toolbar.

            Bitmap bitmap;
            bool disposeBitmap = false;
            if (image is Bitmap)
                bitmap = (Bitmap) image;
            else {
                // #37659 -- metafiles can have extremely high resolutions,
                // so if we naively turn them into bitmaps, the performance will be very poor.
                // bitmap = new Bitmap(image);

                GraphicsUnit units = GraphicsUnit.Display;
                RectangleF bounds = image.GetBounds(ref units);
                bitmap = new Bitmap((int) (bounds.Width * graphics.DpiX / image.HorizontalResolution),
                                    (int) (bounds.Height * graphics.DpiY / image.VerticalResolution));

                Graphics bitmapGraphics = Graphics.FromImage(bitmap);
                bitmapGraphics.Clear(Color.Transparent);
                bitmapGraphics.DrawImage(image, 0, 0, image.Size.Width, image.Size.Height);
                bitmapGraphics.Dispose();

                disposeBitmap = true;
            }
            
            Color highlight = ControlPaint.LightLight(background);
            Bitmap monochrome = MakeMonochrome(bitmap, highlight);
            graphics.DrawImage(monochrome, new Rectangle(x + 1, y + 1, bitmap.Width, bitmap.Height));
            monochrome.Dispose();

            Color shadow = ControlPaint.Dark(background);
            monochrome = MakeMonochrome(bitmap, shadow);
            graphics.DrawImage(monochrome, new Rectangle(x, y, bitmap.Width, bitmap.Height));
            monochrome.Dispose();

            if (disposeBitmap)
                bitmap.Dispose();
#endif
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawLockedFrame"]/*' />
        /// <devdoc>
        ///     Draws a locked selection frame around the given rectangle.
        /// </devdoc>
        public static void DrawLockedFrame(Graphics graphics, Rectangle rectangle, bool primary) {
            Pen pen;

            if (primary) {
                pen = Pens.White;
            }
            else {
                pen = Pens.Black;
            }

            graphics.DrawRectangle(pen, rectangle.X, rectangle.Y, rectangle.Width - 1, rectangle.Height - 1);
            rectangle.Inflate(-1, -1);
            graphics.DrawRectangle(pen, rectangle.X, rectangle.Y, rectangle.Width - 1, rectangle.Height - 1);

            if (primary) {
                pen = Pens.Black;
            }
            else {
                pen = Pens.White;
            }
            rectangle.Inflate(-1, -1);
            graphics.DrawRectangle(pen, rectangle.X, rectangle.Y, rectangle.Width - 1, rectangle.Height - 1);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawMenuGlyph"]/*' />
        /// <devdoc>
        ///     Draws a menu glyph for a Win32 menu in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawMenuGlyph(Graphics graphics, Rectangle rectangle, MenuGlyph glyph) {
            DrawMenuGlyph(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, glyph);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawMenuGlyph1"]/*' />
        /// <devdoc>
        ///     Draws a menu glyph for a Win32 menu in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawMenuGlyph(Graphics graphics, int x, int y, int width, int height, MenuGlyph glyph) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_MENU,
                             (int) glyph);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawMixedCheckBox"]/*' />
        /// <devdoc>
        ///     Draws a Win32 3-state checkbox control in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawMixedCheckBox(Graphics graphics, Rectangle rectangle, ButtonState state) {
            DrawMixedCheckBox(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawMixedCheckBox1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void DrawMixedCheckBox(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_BUTTON,
                             NativeMethods.DFCS_BUTTON3STATE | (int) state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawRadioButton"]/*' />
        /// <devdoc>
        ///     Draws a Win32 radio button in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawRadioButton(Graphics graphics, Rectangle rectangle, ButtonState state) {
            DrawRadioButton(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawRadioButton1"]/*' />
        /// <devdoc>
        ///     Draws a Win32 radio button in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawRadioButton(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_BUTTON,
                             NativeMethods.DFCS_BUTTONRADIO | ((int)state));
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawReversibleFrame"]/*' />
        /// <devdoc>
        ///      Draws a rectangular frame on the given graphics.  The operation of this can be
        ///      "reversed" by drawing the same rectangle again.  This is similar to
        ///      inverting a region of the screen except that it behaves better for
        ///      a wider variety of colors.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        public static void DrawReversibleFrame(Rectangle rectangle, Color backColor, FrameStyle style) {
            int rop2;
            Color graphicsColor;

            if (backColor.GetBrightness() < .5) {
                rop2 = 0xA; // RasterOp.PEN.Invert().XorWith(RasterOp.TARGET);
                graphicsColor = Color.White;
            }
            else {
                rop2 = 0x7; // RasterOp.PEN.XorWith(RasterOp.TARGET);
                graphicsColor = Color.Black;
            }

            IntPtr dc = UnsafeNativeMethods.GetDCEx(new HandleRef(null, UnsafeNativeMethods.GetDesktopWindow()), NativeMethods.NullHandleRef, NativeMethods.DCX_WINDOW | NativeMethods.DCX_LOCKWINDOWUPDATE | NativeMethods.DCX_CACHE);
            IntPtr pen;

            switch (style) {
                case FrameStyle.Dashed:
                    pen = SafeNativeMethods.CreatePen(NativeMethods.PS_DOT, 1, ColorTranslator.ToWin32(backColor));
                    break;

                case FrameStyle.Thick:
                default:
                    pen = SafeNativeMethods.CreatePen(NativeMethods.PS_SOLID, 2, ColorTranslator.ToWin32(backColor));
                    break;
            }

            int prevRop2 = SafeNativeMethods.SetROP2(new HandleRef(null, dc), rop2);
            IntPtr oldBrush = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, UnsafeNativeMethods.GetStockObject(NativeMethods.HOLLOW_BRUSH)));
            IntPtr oldPen = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, pen));
            SafeNativeMethods.SetBkColor(new HandleRef(null, dc), ColorTranslator.ToWin32(graphicsColor));
            SafeNativeMethods.Rectangle(new HandleRef(null, dc), rectangle.X, rectangle.Y, rectangle.Right, rectangle.Bottom);

            SafeNativeMethods.SetROP2(new HandleRef(null, dc), prevRop2);
            SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, oldBrush));
            SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, oldPen));
            SafeNativeMethods.DeleteObject(new HandleRef(null, pen));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawReversibleLine"]/*' />
        /// <devdoc>
        ///      Draws a reversible line on the given graphics.  A reversible line can
        ///      be erased by just drawing over it again.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        public static void DrawReversibleLine(Point start, Point end, Color backColor) {
            int rop2 = GetColorRop(backColor, 
                                   0xA, // RasterOp.PEN.Invert().XorWith(RasterOp.TARGET), 
                                   0x7); //RasterOp.PEN.XorWith(RasterOp.TARGET));

            IntPtr dc = UnsafeNativeMethods.GetDCEx(new HandleRef(null, UnsafeNativeMethods.GetDesktopWindow()), NativeMethods.NullHandleRef, NativeMethods.DCX_WINDOW | NativeMethods.DCX_LOCKWINDOWUPDATE | NativeMethods.DCX_CACHE);
            IntPtr pen = SafeNativeMethods.CreatePen(NativeMethods.PS_SOLID, 1, ColorTranslator.ToWin32(backColor));

            int prevRop2 = SafeNativeMethods.SetROP2(new HandleRef(null, dc), rop2);
            IntPtr oldBrush = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, UnsafeNativeMethods.GetStockObject(NativeMethods.HOLLOW_BRUSH)));
            IntPtr oldPen = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, pen));


            SafeNativeMethods.MoveToEx(new HandleRef(null, dc), start.X, start.Y, null);
            SafeNativeMethods.LineTo(new HandleRef(null, dc), end.X, end.Y);

            SafeNativeMethods.SetROP2(new HandleRef(null, dc), prevRop2);
            SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, oldBrush));
            SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, oldPen));
            SafeNativeMethods.DeleteObject(new HandleRef(null, pen));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawScrollButton"]/*' />
        /// <devdoc>
        ///     Draws a button for a Win32 scroll bar in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawScrollButton(Graphics graphics, Rectangle rectangle, ScrollButton button, ButtonState state) {
            DrawScrollButton(graphics, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, button, state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawScrollButton1"]/*' />
        /// <devdoc>
        ///     Draws a button for a Win32 scroll bar in the given rectangle with the given state.
        /// </devdoc>
        public static void DrawScrollButton(Graphics graphics, int x, int y, int width, int height, ScrollButton button, ButtonState state) {
            DrawFrameControl(graphics, x, y, width, height, NativeMethods.DFC_SCROLL,
                             (int)button | (int)state);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawSelectionFrame"]/*' />
        /// <devdoc>
        ///      Draws a standard selection frame.  A selection frame is a frame that is
        ///      drawn around a selected component at design time.
        /// </devdoc>
        public static void DrawSelectionFrame(Graphics graphics, bool active, Rectangle outsideRect, Rectangle insideRect, Color backColor) {
            Brush frameBrush;

            if (active) {
                frameBrush = GetActiveBrush(backColor);
            }
            else {
                frameBrush = GetSelectedBrush(backColor);
            }

            Region clip = graphics.Clip;
            graphics.ExcludeClip(insideRect);
            graphics.FillRectangle(frameBrush, outsideRect);
            graphics.Clip = clip;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawSizeGrip"]/*' />
        /// <devdoc>
        ///      Draws a size grip at the given location.  The color of the size grip is based
        ///      on the given background color.
        /// </devdoc>
        public static void DrawSizeGrip(Graphics graphics, Color backColor, Rectangle bounds) {
            DrawSizeGrip(graphics, backColor, bounds.X, bounds.Y, bounds.Width, bounds.Height);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawSizeGrip1"]/*' />
        /// <devdoc>
        ///      Draws a size grip at the given location.  The color of the size grip is based
        ///      on the given background color.
        /// </devdoc>
        public static void DrawSizeGrip(Graphics graphics, Color backColor, int x, int y, int width, int height) {

            // Note: We don't paint any background to facilitate transparency, background images, etc...
            //

            Pen bright = new Pen(LightLight(backColor));
            Pen dark = new Pen(Dark(backColor));

            int minDim = Math.Min(width, height);
            int right = x+width-1;
            int bottom = y+height-2;

            for (int i=0; i<minDim - 4; i+= 4) {
                graphics.DrawLine(dark, right - (i + 1) - 2, bottom, right, bottom - (i + 1) - 2);
                graphics.DrawLine(dark, right - (i + 2) - 2, bottom, right, bottom - (i + 2) - 2);
                graphics.DrawLine(bright, right - (i + 3) - 2, bottom, right, bottom - (i + 3) - 2);
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.DrawStringDisabled"]/*' />
        /// <devdoc>
        ///     Draws a string in the style appropriate for disabled items.
        /// </devdoc>
        public static void DrawStringDisabled(Graphics graphics, string s, Font font, 
                                              Color color, RectangleF layoutRectangle,
                                              StringFormat format) {
            layoutRectangle.Offset(1, 1);
            SolidBrush brush = new SolidBrush(LightLight(color));
            try {
                graphics.DrawString(s, font, brush, layoutRectangle, format);

                layoutRectangle.Offset(-1, -1);
                color = Dark(color);
                brush.Color = color;
                graphics.DrawString(s, font, brush, layoutRectangle, format);
            }
            finally {
                brush.Dispose();
            }
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.FillReversibleRectangle"]/*' />
        /// <devdoc>
        ///      Draws a filled rectangle on the screen.  The operation of this can be
        ///      "reversed" by drawing the same rectangle again.  This is similar to
        ///      inverting a region of the screen except that it behaves better for
        ///      a wider variety of colors.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        public static void FillReversibleRectangle(Rectangle rectangle, Color backColor) {
            int rop3 = GetColorRop(backColor, 
                                   0xa50065, // RasterOp.BRUSH.Invert().XorWith(RasterOp.TARGET), 
                                   0x5a0049); // RasterOp.BRUSH.XorWith(RasterOp.TARGET));
            int rop2 = GetColorRop(backColor, 
                                   0x6, // RasterOp.BRUSH.Invert().XorWith(RasterOp.TARGET), 
                                   0x6); // RasterOp.BRUSH.XorWith(RasterOp.TARGET));

            IntPtr dc = UnsafeNativeMethods.GetDCEx(new HandleRef(null, UnsafeNativeMethods.GetDesktopWindow()), NativeMethods.NullHandleRef, NativeMethods.DCX_WINDOW | NativeMethods.DCX_LOCKWINDOWUPDATE | NativeMethods.DCX_CACHE);
            IntPtr brush = SafeNativeMethods.CreateSolidBrush(ColorTranslator.ToWin32(backColor));

            int prevRop2 = SafeNativeMethods.SetROP2(new HandleRef(null, dc), rop2);
            IntPtr oldBrush = SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, brush));

            // PatBlt must be the only Win32 function that wants height in width rather than x2,y2.
            SafeNativeMethods.PatBlt(new HandleRef(null, dc), rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height, rop3);

            SafeNativeMethods.SetROP2(new HandleRef(null, dc), prevRop2);
            SafeNativeMethods.SelectObject(new HandleRef(null, dc), new HandleRef(null, oldBrush));
            SafeNativeMethods.DeleteObject(new HandleRef(null, brush));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));
        }

        // Converts the font into one where Font.Unit = Point.
        // If the original font is in device-dependent units (and it usually is),
        // we interpret the size relative to the screen.
        //
        // This is not really a general-purpose function -- when used on something
        // not obtained from ChooseFont, it may round away some precision.
        internal static Font FontInPoints(Font font) {
            return new Font(font.FontFamily, font.SizeInPoints, font.Style, GraphicsUnit.Point, font.GdiCharSet, font.GdiVerticalFont);
        }

        // Returns whether or not target was changed
        internal static bool FontToIFont(Font source, SafeNativeMethods.IFont target) {
            bool changed = false; 

            // we need to go through all the pain of the diff here because
            // it looks like setting them all has different results based on the
            // order and each individual IFont implementor...
            //
            string fontName = target.GetName();
            if (!source.Name.Equals(fontName)) {
                target.SetName(source.Name);
                changed = true;
            }

            // SBURKE, Review: this always seems to come back as
            // the point size * 10000 (HIMETRIC?), regardless
            // or ratio or mapping mode, and despite what
            // the documentation says...
            //
            // Either figure out what's going on here or
            // do the process that the windows forms FONT object does here
            // or, worse case, just create another Font object
            // from the handle, but that's pretty heavy...
            //
            float fontSize = (float)target.GetSize() / 10000;

            // size must be in points
            float winformsSize = source.SizeInPoints;
            if (winformsSize != fontSize) {
                target.SetSize((long)(winformsSize * 10000));
                changed = true;
            }

            NativeMethods.LOGFONT logfont = new NativeMethods.LOGFONT();

            IntSecurity.ObjectFromWin32Handle.Assert();
            try {
                source.ToLogFont(logfont);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            short fontWeight = target.GetWeight();
            if (fontWeight != logfont.lfWeight) {
                target.SetWeight((short)logfont.lfWeight);
                changed = true;
            }

            bool fontBold = target.GetBold();
            if (fontBold != (logfont.lfWeight >= 700)) {
                target.SetBold(logfont.lfWeight >= 700);
                changed = true;
            }

            bool fontItalic = target.GetItalic();
            if (fontItalic != (0 != logfont.lfItalic)) {
                target.SetItalic(0 != logfont.lfItalic);
                changed = true;
            }

            bool fontUnderline = target.GetUnderline();
            if (fontUnderline != (0 != logfont.lfUnderline)) {
                target.SetUnderline(0 != logfont.lfUnderline);
                changed = true;
            }

            bool fontStrike = target.GetStrikethrough();
            if (fontStrike != (0 != logfont.lfStrikeOut)) {
                target.SetStrikethrough(0 != logfont.lfStrikeOut);
                changed = true;
            }

            short fontCharset = target.GetCharset();
            if (fontCharset != logfont.lfCharSet) {
                target.SetCharset(logfont.lfCharSet);
                changed = true;
            }

            return changed;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.GetColorRop"]/*' />
        /// <devdoc>
        ///     This makes a choice from a set of raster op codes, based on the color given.  If the
        ///     color is considered to be "dark", the raster op provided by dark will be returned.
        /// </devdoc>
        private static int GetColorRop(Color color, int darkROP, int lightROP) {
            if (color.GetBrightness() < .5) {
                return darkROP;
            }
            return lightROP;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.GetActiveBrush"]/*' />
        /// <devdoc>
        ///      Retrieves the brush used to draw active objects.
        /// </devdoc>
        private static Brush GetActiveBrush(Color backColor) {
            Color brushColor;

            if (backColor.GetBrightness() <= .5) {
                brushColor = SystemColors.ControlLight;
            }
            else {
                brushColor = SystemColors.ControlDark;
            }

            if (frameBrushActive == null ||
                !frameColorActive.Equals(brushColor)) {

                if (frameBrushActive != null) {
                    frameBrushActive.Dispose();
                    frameBrushActive = null;
                }

                frameColorActive = brushColor;

                int patternSize = 8;

                Bitmap bitmap = new Bitmap(patternSize, patternSize);

                // gpr : bitmap does not initialize itself to be zero?
                //
                for (int x = 0; x < patternSize; x++) {
                    for (int y = 0; y < patternSize; y++) {
                        bitmap.SetPixel(x, y, Color.Transparent);
                    }
                }

                for (int y = 0; y < patternSize; y++) {
                    for (int x = -y; x < patternSize; x += 4) {
                        if (x >= 0) {
                            bitmap.SetPixel(x, y, brushColor);
                        }
                    }
                }

                frameBrushActive = new TextureBrush(bitmap);
                bitmap.Dispose();
            }

            return frameBrushActive;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.GetFocusPen"]/*' />
        /// <devdoc>
        ///      Retrieves the pen used to draw a focus rectangle around a control.  The focus
        ///      rectangle is typically drawn when the control has keyboard focus.
        /// </devdoc>
        private static Pen GetFocusPen(Color backColor, bool odds) {
            if (focusPen == null ||
                (focusPenColor.GetBrightness() <= .5 && backColor.GetBrightness() <= .5) ||
                !focusPenColor.Equals(backColor)) {

                if (focusPen != null) {
                    focusPen.Dispose();
                    focusPen = null;
                    focusPenInvert.Dispose();
                    focusPenInvert = null;
                }

                focusPenColor = backColor;

                Bitmap b = new Bitmap(2,2);
                Color color1 = Color.Transparent;
                Color color2 = Color.Black;

                if (backColor.GetBrightness() <= .5) {
                    color1 = color2;
                    color2 = InvertColor(backColor);
                }

                b.SetPixel(1, 0, color2);
                b.SetPixel(0, 1, color2);
                b.SetPixel(0, 0, color1);
                b.SetPixel(1, 1, color1);

                Brush brush = new TextureBrush(b);
                focusPen = new Pen(brush, 1);
                brush.Dispose(); // The Pen constructor copies what it needs from the brush

                b.SetPixel(1, 0, color1);
                b.SetPixel(0, 1, color1);
                b.SetPixel(0, 0, color2);
                b.SetPixel(1, 1, color2);

                brush = new TextureBrush(b);
                focusPenInvert = new Pen(brush, 1);
                brush.Dispose();

                b.Dispose();
            }

            return odds ? focusPen : focusPenInvert;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.GetSelectedBrush"]/*' />
        /// <devdoc>
        ///      Retrieves the brush used to draw selected objects.
        /// </devdoc>
        private static Brush GetSelectedBrush(Color backColor) {
            Color brushColor;

            if (backColor.GetBrightness() <= .5) {
                brushColor = SystemColors.ControlLight;
            }
            else {
                brushColor = SystemColors.ControlDark;
            }

            if (frameBrushSelected == null ||
                !frameColorSelected.Equals(brushColor)) {

                if (frameBrushSelected != null) {
                    frameBrushSelected.Dispose();
                    frameBrushSelected = null;
                }

                frameColorSelected = brushColor;

                int patternSize = 8;

                Bitmap bitmap = new Bitmap(patternSize, patternSize);

                // gpr : bitmap does not initialize itself to be zero?
                //
                for (int x = 0; x < patternSize; x++) {
                    for (int y = 0; y < patternSize; y++) {
                        bitmap.SetPixel(x, y, Color.Transparent);
                    }
                }

                int start = 0;

                for (int x = 0; x < patternSize; x += 2) {
                    for (int y = start; y < patternSize; y += 2) {
                        bitmap.SetPixel(x, y, brushColor);
                    }

                    start ^= 1;
                }

                frameBrushSelected = new TextureBrush(bitmap);
                bitmap.Dispose();
            }

            return frameBrushSelected;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.InfinityToOne"]/*' />
        /// <devdoc>
        ///      Converts an infinite value to "1".
        /// </devdoc>
        private static float InfinityToOne(float value) {
            if (value == Single.NegativeInfinity || value == Single.PositiveInfinity) {
                return 1.0f;
            }
            return value;
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.InvertColor"]/*' />
        /// <devdoc>
        ///      Inverts the given color.
        /// </devdoc>
        private static Color InvertColor(Color color) {
            return Color.FromArgb(color.A, (byte)~color.R, (byte)~color.G, (byte)~color.B);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.Light"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color Light(Color baseColor, float percOfLightLight) {
            return new HLSColor(baseColor).Lighter(percOfLightLight);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.Light1"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color Light(Color baseColor) {
            return new HLSColor(baseColor).Lighter(0.5f);
        }

        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.LightLight"]/*' />
        /// <devdoc>
        ///      Creates a new color that is a object of the given color.
        /// </devdoc>
        public static Color LightLight(Color baseColor) {
            return new HLSColor(baseColor).Lighter(1.0f);
        }

        // Returns a monochrome bitmap based on the input.
        private static Bitmap MakeMonochrome(Bitmap input, Color color) {
            Bitmap output = new Bitmap(input.Width, input.Height);
            output.SetResolution(input.HorizontalResolution, input.VerticalResolution);        
            Size size = input.Size;
            int width = input.Width;
            int height = input.Height;

            BitmapData inputData = input.LockBits(new Rectangle(0,0, width, height),
                                                  ImageLockMode.ReadOnly,
                                                  PixelFormat.Format32bppArgb);
            BitmapData outputData = output.LockBits(new Rectangle(0,0, width, height),
                                                    ImageLockMode.WriteOnly,
                                                    PixelFormat.Format32bppArgb);

            Debug.Assert(inputData.Scan0 != IntPtr.Zero && outputData.Scan0 != IntPtr.Zero, "BitmapData.Scan0 is null; check marshalling");

            int colorARGB = color.ToArgb();
            for (int y = 0; y < height; y++) {
                IntPtr inputScan = (IntPtr)((long)inputData.Scan0 + y * inputData.Stride);
                IntPtr outputScan = (IntPtr)((long)outputData.Scan0 + y * outputData.Stride);
                for (int x = 0; x < width; x++) {
                    int pixel = Marshal.ReadInt32(inputScan,x*4);
                    if (pixel >> 24 == 0)
                        Marshal.WriteInt32(outputScan, x*4, 0); // transparent
                    else
                        Marshal.WriteInt32(outputScan, x*4, colorARGB);
                }
            }
            input.UnlockBits(inputData);
            output.UnlockBits(outputData);

            return output;
        }

        // Takes a black and white image, and replaces those colors with the colors of your choice.
        // The Alpha channel of the source bitmap will be ignored, meaning pixels with Color.Transparent
        // (really transparent black) will be mapped to the replaceBlack color.
        private static ColorMatrix RemapBlackAndWhiteAndTransparentMatrix(Color replaceBlack, Color replaceWhite) {
            // Normalize the colors to 1.0.

            float normBlackRed   = ((float)replaceBlack.R)/(float)255.0;
            float normBlackGreen = ((float)replaceBlack.G)/(float)255.0;
            float normBlackBlue  = ((float)replaceBlack.B)/(float)255.0;
            float normBlackAlpha = ((float)replaceBlack.A)/(float)255.0;

            float normWhiteRed   = ((float)replaceWhite.R)/(float)255.0;
            float normWhiteGreen = ((float)replaceWhite.G)/(float)255.0;
            float normWhiteBlue  = ((float)replaceWhite.B)/(float)255.0;
            float normWhiteAlpha = ((float)replaceWhite.A)/(float)255.0;

            // Set up a matrix that will map white to replaceWhite and 
            // black and transparent black to replaceBlack.
            //
            //                | -B  -B  -B  -B   0 |
            //                |   r   g   b   a    |
            //                |                    |
            //                |  W   W   W   W   0 |
            //                |   r   g   b   a    |
            //                |                    |
            //  [ R G B A ] * |  0   0   0   0   0 | = [ R' G' B' A' ]
            //                |                    |
            //                |                    |
            //                |  0   0   0   0   0 |
            //                |                    |
            //                |                    |
            //                |  B   B   B   B   1 |
            //                |   r   g   b   a    |

            ColorMatrix matrix = new ColorMatrix();

            matrix.Matrix00 = -normBlackRed;
            matrix.Matrix01 = -normBlackGreen;
            matrix.Matrix02 = -normBlackBlue;
            matrix.Matrix03 = -normBlackAlpha;

            matrix.Matrix10 =  normWhiteRed;
            matrix.Matrix11 =  normWhiteGreen;
            matrix.Matrix12 =  normWhiteBlue;
            matrix.Matrix13 =  normWhiteAlpha;

            matrix.Matrix40 =  normBlackRed;
            matrix.Matrix41 =  normBlackGreen;
            matrix.Matrix42 =  normBlackBlue;
            matrix.Matrix43 =  normBlackAlpha;
            matrix.Matrix44 =  1.0f;

            return matrix;
        }

        // Takes a black and white image, and replaces those colors with the colors of your choice.
        // The replaceBlack and replaceWhite colors must have alpha = 255, because the alpha value
        // of the bitmap is preserved.
        private static ColorMatrix RemapBlackAndWhitePreserveTransparentMatrix(Color replaceBlack, Color replaceWhite) {
            Debug.Assert(replaceBlack.A == 255, "replaceBlack.Alpha is ignored, so please set it to 255 so I know you know what you're doing");
            Debug.Assert(replaceWhite.A == 255, "replaceWhite.Alpha is ignored, so please set it to 255 so I know you know what you're doing");

            // Normalize the colors to 1.0.

            float normBlackRed   = ((float)replaceBlack.R)/(float)255.0;
            float normBlackGreen = ((float)replaceBlack.G)/(float)255.0;
            float normBlackBlue  = ((float)replaceBlack.B)/(float)255.0;
            float normBlackAlpha = ((float)replaceBlack.A)/(float)255.0;

            float normWhiteRed   = ((float)replaceWhite.R)/(float)255.0;
            float normWhiteGreen = ((float)replaceWhite.G)/(float)255.0;
            float normWhiteBlue  = ((float)replaceWhite.B)/(float)255.0;
            float normWhiteAlpha = ((float)replaceWhite.A)/(float)255.0;

            // Set up a matrix that will map white to replaceWhite and 
            // black to replaceBlack, using the source bitmap's alpha value for the output
            //
            //                | -B  -B  -B   0   0 |
            //                |   r   g   b        |
            //                |                    |
            //                |  W   W   W   0   0 |
            //                |   r   g   b        |
            //                |                    |
            //  [ R G B A ] * |  0   0   0   0   0 | = [ R' G' B' A ]
            //                |                    |
            //                |                    |
            //                |  0   0   0   1   0 |
            //                |                    |
            //                |                    |
            //                |  B   B   B   0   1 |
            //                |   r   g   b        |

            ColorMatrix matrix = new ColorMatrix();

            matrix.Matrix00 = -normBlackRed;
            matrix.Matrix01 = -normBlackGreen;
            matrix.Matrix02 = -normBlackBlue;

            matrix.Matrix10 =  normWhiteRed;
            matrix.Matrix11 =  normWhiteGreen;
            matrix.Matrix12 =  normWhiteBlue;

            matrix.Matrix33 =  1.0f;

            matrix.Matrix40 =  normBlackRed;
            matrix.Matrix41 =  normBlackGreen;
            matrix.Matrix42 =  normBlackBlue;
            matrix.Matrix44 =  1.0f;

            return matrix;
        }
        
        // Uses OLE to save bitmap
        private static void SaveHBitmap(Stream stream, IntPtr hBitmap, IntPtr hPalette) {
            NativeMethods.PICTDESC pictdesc = NativeMethods.PICTDESC.CreateBitmapPICTDESC(hBitmap, hPalette);
            Guid g = typeof(SafeNativeMethods.IPicture).GUID;
            SafeNativeMethods.IPicture localPicture = SafeNativeMethods.OleCreatePictureIndirect(pictdesc, ref g, false);

            Debug.Assert(localPicture != null, "NO local picture to save");
            int temp;
            localPicture.SaveAsFile(new UnsafeNativeMethods.ComStreamFromDataStream(stream), -1, out temp); // assume dirty, whatever that means
            // CONSIDER:            ComLib.Release(localPicture);
        }

        internal static StringAlignment TranslateAlignment(HorizontalAlignment align) {
            StringAlignment result;
            switch (align) {
                case HorizontalAlignment.Right:
                    result = StringAlignment.Far;
                    break;
                case HorizontalAlignment.Center:
                    result = StringAlignment.Center;
                    break;
                case HorizontalAlignment.Left:
                default:
                    result = StringAlignment.Near;
                    break;
            }

            return result;
        }

        internal static StringAlignment TranslateAlignment(ContentAlignment align) {
            StringAlignment result;
            if ((align & anyRight) != 0)
                result = StringAlignment.Far;
            else if ((align & anyCenter) != 0)
                result = StringAlignment.Center;
            else
                result = StringAlignment.Near;
            return result;
        }

        internal static StringAlignment TranslateLineAlignment(ContentAlignment align) {
            StringAlignment result;
            if ((align & anyBottom) != 0) {
                result = StringAlignment.Far;
            }
            else if ((align & anyMiddle) != 0) {
                result = StringAlignment.Center;
            }
            else {
                result = StringAlignment.Near;
            }
            return result;
        }

        internal static StringFormat StringFormatForAlignment(ContentAlignment align) {
            StringFormat output = new StringFormat();
            output.Alignment = TranslateAlignment(align);
            output.LineAlignment = TranslateLineAlignment(align);
            return output;
        }

        internal static StringFormat StringFormatForAlignment(HorizontalAlignment align) {
            StringFormat output = new StringFormat();
            output.Alignment = TranslateAlignment(align);
            return output;
        }


        /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor"]/*' />
        /// <devdoc>
        ///     Logic copied from Win2K sources to copy the lightening and
        ///     darkening of colors.
        /// </devdoc>
        private struct HLSColor {
            private const int ShadowAdj         = -333;
            private const int HilightAdj        = 500;
            private const int WatermarkAdj      = -50;

            private const int Range = 240;
            private const int HLSMax = Range;
            private const int RGBMax = 255;
            private const int Undefined = HLSMax*2/3;

            private int hue;
            private int saturation;
            private int luminosity;

            private bool isSystemColors_Control;

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.HLSColor"]/*' />
            /// <devdoc>
            /// </devdoc>
            public HLSColor(Color color) {
                isSystemColors_Control = (color.ToKnownColor() == SystemColors.Control.ToKnownColor());
                int r = color.R;
                int g = color.G;
                int b = color.B;
                int max, min;        /* max and min RGB values */
                int sum, dif;
                int  Rdelta,Gdelta,Bdelta;  /* intermediate value: % of spread from max */

                /* calculate lightness */
                max = Math.Max( Math.Max(r,g), b);
                min = Math.Min( Math.Min(r,g), b);
                sum = max + min;

                luminosity = (((sum * HLSMax) + RGBMax)/(2*RGBMax));

                dif = max - min;
                if (dif == 0) {       /* r=g=b --> achromatic case */
                    saturation = 0;                         /* saturation */
                    hue = Undefined;                 /* hue */
                }
                else {                           /* chromatic case */
                    /* saturation */
                    if (luminosity <= (HLSMax/2))
                        saturation = (int) (((dif * (int) HLSMax) + (sum / 2) ) / sum);
                    else
                        saturation = (int) ((int) ((dif * (int) HLSMax) + (int)((2*RGBMax-sum)/2) )
                                            / (2*RGBMax-sum));
                    /* hue */
                    Rdelta = (int) (( ((max-r)*(int)(HLSMax/6)) + (dif / 2) ) / dif);
                    Gdelta = (int) (( ((max-g)*(int)(HLSMax/6)) + (dif / 2) ) / dif);
                    Bdelta = (int) (( ((max-b)*(int)(HLSMax/6)) + (dif / 2) ) / dif);

                    if ((int) r == max)
                        hue = Bdelta - Gdelta;
                    else if ((int)g == max)
                        hue = (HLSMax/3) + Rdelta - Bdelta;
                    else /* B == cMax */
                        hue = ((2*HLSMax)/3) + Gdelta - Rdelta;

                    if (hue < 0)
                        hue += HLSMax;
                    if (hue > HLSMax)
                        hue -= HLSMax;
                }
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.Hue"]/*' />
            /// <devdoc>
            /// </devdoc>
            public int Hue {
                get {
                    return hue;
                }
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.Luminosity"]/*' />
            /// <devdoc>
            /// </devdoc>
            public int Luminosity {
                get {
                    return luminosity;
                }
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.Saturation"]/*' />
            /// <devdoc>
            /// </devdoc>
            public int Saturation {
                get {
                    return saturation;
                }
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.Darker"]/*' />
            /// <devdoc>
            /// </devdoc>
            public Color Darker(float percDarker) {
                if (isSystemColors_Control) {
                    // With the usual color scheme, ControlDark/DarkDark is not exactly
                    // what we would otherwise calculate
                    if (percDarker == 0.0f) {
                        return SystemColors.ControlDark;
                    }
                    else if (percDarker == 1.0f) {
                        return SystemColors.ControlDarkDark;
                    }
                    else {
                        Color dark = SystemColors.ControlDark;
                        Color darkDark = SystemColors.ControlDarkDark;

                        int dr = dark.R - darkDark.R;
                        int dg = dark.G - darkDark.G;
                        int db = dark.B - darkDark.B;

                        return Color.FromArgb((byte)(dark.R - (byte)(dr * percDarker)),
                                              (byte)(dark.G - (byte)(dg * percDarker)),
                                              (byte)(dark.B - (byte)(db * percDarker)));
                    }
                }
                else {
                    int oneLum = 0;
                    int zeroLum = NewLuma(ShadowAdj, true);

                    /*                                        
                    if (luminosity < 40) {
                        zeroLum = NewLuma(120, ShadowAdj, true);
                    }
                    else {
                        zeroLum = NewLuma(ShadowAdj, true);
                    }
                    */

                    return ColorFromHLS(hue, zeroLum - (int)((zeroLum - oneLum) * percDarker), saturation);
                }
            }
            
            public override bool Equals(object o) {
                if (!(o is HLSColor)) {
                    return false;
                }
                
                HLSColor c = (HLSColor)o;
                return hue == c.hue && 
                       saturation == c.saturation && 
                       luminosity == c.luminosity && 
                       isSystemColors_Control == c.isSystemColors_Control;
            }

            public override int GetHashCode() {
                return hue << 6 | saturation << 2 | luminosity;
            }
    
            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.Lighter"]/*' />
            /// <devdoc>
            /// </devdoc>
            public Color Lighter(float percLighter) {
                if (isSystemColors_Control) {
                    // With the usual color scheme, ControlLight/LightLight is not exactly
                    // what we would otherwise calculate
                    if (percLighter == 0.0f) {
                        return SystemColors.ControlLight;
                    }
                    else if (percLighter == 1.0f) {
                        return SystemColors.ControlLightLight;
                    }
                    else {
                        Color light = SystemColors.ControlLight;
                        Color lightLight = SystemColors.ControlLightLight;

                        int dr = light.R - lightLight.R;
                        int dg = light.G - lightLight.G;
                        int db = light.B - lightLight.B;

                        return Color.FromArgb((byte)(light.R - (byte)(dr * percLighter)),
                                              (byte)(light.G - (byte)(dg * percLighter)),
                                              (byte)(light.B - (byte)(db * percLighter)));
                    }
                }
                else {
                    int zeroLum = luminosity;
                    int oneLum = NewLuma(HilightAdj, true);

                    /*
                    if (luminosity < 40) {
                        zeroLum = 120;
                        oneLum = NewLuma(120, HilightAdj, true);
                    }
                    else {
                        zeroLum = luminosity;
                        oneLum = NewLuma(HilightAdj, true);
                    }
                    */
                    
                    return ColorFromHLS(hue, zeroLum + (int)((oneLum - zeroLum) * percLighter), saturation);
                }
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.NewLuma"]/*' />
            /// <devdoc>
            /// </devdoc>
            private int NewLuma(int n, bool scale) {
                return NewLuma(luminosity, n, scale);
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.NewLuma1"]/*' />
            /// <devdoc>
            /// </devdoc>
            private int NewLuma(int luminosity, int n, bool scale) {
                if (n == 0)
                    return luminosity;

                if (scale) {
                    if (n > 0) {
                        return(int)(((int)luminosity * (1000 - n) + (Range + 1L) * n) / 1000);
                    }
                    else {
                        return(int)(((int)luminosity * (n + 1000)) / 1000);
                    }
                }

                int newLum = luminosity;
                newLum += (int)((long)n * Range / 1000);

                if (newLum < 0)
                    newLum = 0;
                if (newLum > HLSMax)
                    newLum = HLSMax;

                return newLum;
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.ColorFromHLS"]/*' />
            /// <devdoc>
            /// </devdoc>
            private Color ColorFromHLS(int hue, int luminosity, int saturation) {
                byte r,g,b;                      /* RGB component values */
                int  magic1,magic2;       /* calculated magic numbers (really!) */

                if (saturation == 0) {                /* achromatic case */
                    r = g = b = (byte)((luminosity * RGBMax) / HLSMax);
                    if (hue != Undefined) {
                        /* ERROR */
                    }
                }
                else {                         /* chromatic case */
                    /* set up magic numbers */
                    if (luminosity <= (HLSMax/2))
                        magic2 = (int)((luminosity * ((int)HLSMax + saturation) + (HLSMax/2))/HLSMax);
                    else
                        magic2 = luminosity + saturation - (int)(((luminosity*saturation) + (int)(HLSMax/2))/HLSMax);
                    magic1 = 2*luminosity-magic2;

                    /* get RGB, change units from HLSMax to RGBMax */
                    r = (byte)(((HueToRGB(magic1,magic2,(int)(hue+(int)(HLSMax/3)))*(int)RGBMax + (HLSMax/2))) / (int)HLSMax);
                    g = (byte)(((HueToRGB(magic1,magic2,hue)*(int)RGBMax + (HLSMax/2))) / HLSMax);
                    b = (byte)(((HueToRGB(magic1,magic2,(int)(hue-(int)(HLSMax/3)))*(int)RGBMax + (HLSMax/2))) / (int)HLSMax);
                }
                return Color.FromArgb(r,g,b);
            }

            /// <include file='doc\ControlPaint.uex' path='docs/doc[@for="ControlPaint.HLSColor.HueToRGB"]/*' />
            /// <devdoc>
            /// </devdoc>
            private int HueToRGB(int n1, int n2, int hue) {
                /* range check: note values passed add/subtract thirds of range */

                /* The following is redundant for WORD (unsigned int) */
                if (hue < 0)
                    hue += HLSMax;

                if (hue > HLSMax)
                    hue -= HLSMax;

                /* return r,g, or b value from this tridrant */
                if (hue < (HLSMax/6))
                    return( n1 + (((n2-n1)*hue+(HLSMax/12))/(HLSMax/6)) );
                if (hue < (HLSMax/2))
                    return( n2 );
                if (hue < ((HLSMax*2)/3))
                    return( n1 + (((n2-n1)*(((HLSMax*2)/3)-hue)+(HLSMax/12)) / (HLSMax/6)) );
                else
                    return( n1 );

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\combobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using Accessibility;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    
    using System.Globalization;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays an editing field and a list, allowing the user to select from the
    ///       list or to enter new text. Displays only the editing field until the user
    ///       explicitly displays the list.
    ///
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("SelectedIndexChanged"),
    DefaultProperty("Items"),
    Designer("System.Windows.Forms.Design.ComboBoxDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class ComboBox : ListControl {

        // TODO: Eliminate duplicate focus messages

        private static readonly object EVENT_DROPDOWN                   = new object();
        private static readonly object EVENT_DRAWITEM                   = new object();
        private static readonly object EVENT_MEASUREITEM                = new object();
        private static readonly object EVENT_SELECTEDINDEXCHANGED       = new object();
        private static readonly object EVENT_SELECTIONCHANECOMMITTED    = new object();
        private static readonly object EVENT_SELECTEDITEMCHANGED        = new object();
        private static readonly object EVENT_DROPDOWNSTYLE              = new object();

        private static readonly int PropMaxLength     = PropertyStore.CreateKey();
        private static readonly int PropItemHeight    = PropertyStore.CreateKey();
        private static readonly int PropDropDownWidth = PropertyStore.CreateKey();
        private static readonly int PropStyle         = PropertyStore.CreateKey();
        private static readonly int PropDrawMode      = PropertyStore.CreateKey();
                    
        private const int DefaultSimpleStyleHeight = 150;

        private int selectedIndex = -1;  // used when we don't have a handle.
        // When the style is "simple", the requested height is used
        // for the actual height of the control.
        // When the style is non-simple, the height of the control
        // is determined by the OS.
        // This fixes bug #20966
        private int requestedHeight;
        private GCHandle childWindowRoot;
        
        private IntPtr editHandle;
        private IntPtr editWndProc;
        private ChildAccessibleObject editAccessibleObject;
        
        private IntPtr listHandle;
        private IntPtr listWndProc;
        private ChildAccessibleObject listAccessibleObject;
        
        private IntPtr dropDownHandle;
        private ObjectCollection itemsCollection;
        private short prefHeightCache=-1;
        private short maxDropDownItems = 8;
        private bool integralHeight = true;
        private bool mousePressed;
        private bool mouseEvents;
        private bool mouseInEdit;

        private bool sorted;
        private bool fireSetFocus = true;
        private bool fireLostFocus = true;

        private bool selectedValueChangedFired = false;

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ComboBox"]/*' />
        /// <devdoc>
        ///     Creates a new ComboBox control.  The default style for the combo is
        ///     a regular DropDown Combo.
        /// </devdoc>
        public ComboBox() {
            SetStyle(ControlStyles.UserPaint |
                     ControlStyles.StandardClick, false);
                     
            requestedHeight = DefaultSimpleStyleHeight;
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.BackColor"]/*' />
        /// <devdoc>
        ///     The background color of this control. This is an ambient property and
        ///     will always return a non-null value.
        /// </devdoc>
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to call base.CreateParams() first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "COMBOBOX";
                cp.Style |= NativeMethods.WS_VSCROLL | NativeMethods.CBS_HASSTRINGS | NativeMethods.CBS_AUTOHSCROLL;
                cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                if (!integralHeight) cp.Style |= NativeMethods.CBS_NOINTEGRALHEIGHT;

                switch (DropDownStyle) {
                    case ComboBoxStyle.Simple:
                        cp.Style |= NativeMethods.CBS_SIMPLE;
                        break;
                    case ComboBoxStyle.DropDown:
                        cp.Style |= NativeMethods.CBS_DROPDOWN;
                        // Make sure we put the height back or we won't be able to size the dropdown!
                        cp.Height = PreferredHeight;
                        break;
                    case ComboBoxStyle.DropDownList:
                        cp.Style |= NativeMethods.CBS_DROPDOWNLIST;
                        // Comment above...
                        cp.Height = PreferredHeight;
                        break;
                }
                switch (DrawMode) {
                    
                    case DrawMode.OwnerDrawFixed:
                        cp.Style |= NativeMethods.CBS_OWNERDRAWFIXED;
                        break;
                    case DrawMode.OwnerDrawVariable:
                        cp.Style |= NativeMethods.CBS_OWNERDRAWVARIABLE;
                        break;
                }
                return cp;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(121, PreferredHeight);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DrawMode"]/*' />
        /// <devdoc>
        ///     Retrieves the value of the DrawMode property.  The DrawMode property
        ///     controls whether the control is drawn by Windows or by the user.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DrawMode.Normal),
        SRDescription(SR.ComboBoxDrawModeDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public DrawMode DrawMode {
            get {
                bool found;
                int drawMode = Properties.GetInteger(PropDrawMode, out found);
                if (found) {
                    return (DrawMode)drawMode;
                }
                
                return DrawMode.Normal;
            }
            set {
                if (DrawMode != value) {
                    //verify that 'value' is a valid enum type...

                    if ( !Enum.IsDefined(typeof(DrawMode), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(DrawMode));
                    }

                    Properties.SetInteger(PropDrawMode, (int)value);
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DropDownWidth"]/*' />
        /// <devdoc>
        ///     Returns the width of the drop down box in a combo box.        
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.ComboBoxDropDownWidthDescr)
        ]
        public int DropDownWidth {
            get {
                bool found;
                int dropDownWidth = Properties.GetInteger(PropDropDownWidth, out found);
                
                if (found) {
                    return dropDownWidth;
                }
                else {
                    return Width;
                }
            }

            set {
                if (value < 1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "value", (value).ToString()));
                }
                if (Properties.GetInteger(PropDropDownWidth) != value) {
                    Properties.SetInteger(PropDropDownWidth, value);
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.CB_SETDROPPEDWIDTH, value, 0);
                    }                  
                }
            }
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DroppedDown"]/*' />
        /// <devdoc>
        ///     Indicates whether the DropDown of the combo is  currently dropped down.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxDroppedDownDescr)
        ]
        public bool DroppedDown {
            get {
                if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.CB_GETDROPPEDSTATE, 0, 0) != 0;
                }
                else {
                    return false;
                }
            }

            set {
                SendMessage(NativeMethods.CB_SHOWDROPDOWN, value? -1: 0, 0);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Focused"]/*' />
        /// <devdoc>
        ///     Returns true if this control has focus.
        /// </devdoc>
        public override bool Focused {
            get {
                if (base.Focused) return true;
                IntPtr focus = UnsafeNativeMethods.GetFocus();
                return focus != IntPtr.Zero && (focus == editHandle || focus == listHandle);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of the control.
        ///    </para>
        /// </devdoc>
        public override Color ForeColor {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.IntegralHeight"]/*' />
        /// <devdoc>
        ///     Indicates if the combo should avoid showing partial Items.  If so,
        ///     then only full items will be displayed, and the list portion will be resized
        ///     to prevent partial items from being shown.  Otherwise, they will be
        ///     shown
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ComboBoxIntegralHeightDescr)
        ]
        public bool IntegralHeight {
            get {
                return integralHeight;
            }

            set {
                if (integralHeight != value) {
                    integralHeight = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ItemHeight"]/*' />
        /// <devdoc>
        ///     Returns the height of an item in the combo box. When drawMode is Normal
        ///     or OwnerDrawFixed, all items have the same height. When drawMode is
        ///     OwnerDrawVariable, this method returns the height that will be given
        ///     to new items added to the combo box. To determine the actual height of
        ///     an item, use the GetItemHeight() method with an integer parameter.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.ComboBoxItemHeightDescr)
        ]
        public int ItemHeight {
            get {

                DrawMode drawMode = DrawMode;
                if (drawMode == DrawMode.OwnerDrawFixed ||
                    drawMode == DrawMode.OwnerDrawVariable ||
                    !IsHandleCreated) {
                    
                    bool found;
                    int itemHeight = Properties.GetInteger(PropItemHeight, out found);
                    if (found) {
                        return itemHeight;
                    }
                    else {
                        return FontHeight + 2;   // bug (90774)+2 for the 1 pixel gap on each side (up and Bottom) of the Text.
                    }
                }

                // Note that the above if clause deals with the case when the handle has not yet been created
                Debug.Assert(IsHandleCreated, "Handle should be created at this point");
                
                int h = (int)SendMessage(NativeMethods.CB_GETITEMHEIGHT, 0, 0);
                if (h == -1) {
                    throw new Win32Exception();
                }
                return h;
            }

            set {
                if (value < 1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "value", (value).ToString()));
                }
                
                if (Properties.GetInteger(PropItemHeight) != value) {
                    Properties.SetInteger(PropItemHeight, value);
                    if (DrawMode != DrawMode.Normal) {
                        UpdateItemHeight();
                    }
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Items"]/*' />
        /// <devdoc>
        ///     Collection of the items contained in this ComboBox.
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.ComboBoxItemsDescr),
        Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public ObjectCollection Items {
            get {
                if (itemsCollection == null) {
                    itemsCollection = new ObjectCollection(this);
                }
                return itemsCollection;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.MaxDropDownItems"]/*' />
        /// <devdoc>
        ///     The maximum number of items to be shown in the dropdown portion
        ///     of the ComboBox.  This number can be between 1 and 100.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(8),
        Localizable(true),
        SRDescription(SR.ComboBoxMaxDropDownItemsDescr)
        ]
        public int MaxDropDownItems {
            get {
                return maxDropDownItems;
            }
            set {
                if (value < 1 || value > 100) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidBoundArgument,
                                                              "value", (value).ToString(), "1", "100"));
                }
                maxDropDownItems = (short)value;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.MaxLength"]/*' />
        /// <devdoc>
        ///     The maximum length of the text the user may type into the edit control
        ///     of a combo box.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Localizable(true),
        SRDescription(SR.ComboBoxMaxLengthDescr)
        ]
        public int MaxLength {
            get {
                return Properties.GetInteger(PropMaxLength);
            }
            set {
                if (value < 0) value = 0;
                if (MaxLength != value) {
                    Properties.SetInteger(PropMaxLength, value);
                    if (IsHandleCreated) SendMessage(NativeMethods.CB_LIMITTEXT, value, 0);
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.PreferredHeight"]/*' />
        /// <devdoc>
        ///     The preferred height of the combobox control.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxPreferredHeightDescr)
        ]
        public int PreferredHeight {
            get {
                if (prefHeightCache > -1) {
                    return(int)prefHeightCache;
                }

                // Base the preferred height on the current font
                int height = FontHeight;

                // Adjust for the border
                height += SystemInformation.BorderSize.Height * 4 + 3;
                prefHeightCache = (short)height;

                return height;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectedIndex"]/*' />
        /// <devdoc>
        ///     The [zero based] index of the currently selected item in the combos list.
        ///     Note If the value of index is -1, then the ComboBox is
        ///     set to have no selection.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxSelectedIndexDescr)
        ]
        public override int SelectedIndex {
            get {
                if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.CB_GETCURSEL, 0, 0);
                }
                else {
                    return selectedIndex;
                }
            }
            set {
                if (SelectedIndex != value) {
                    int itemCount = 0;
                    if (itemsCollection != null) {
                        itemCount = itemsCollection.Count;
                    }
                    
                    if (value < -1 || value >= itemCount) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (value).ToString()));
                    }

                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.CB_SETCURSEL, value, 0);
                        
                    }
                    else {
                        selectedIndex = value;
                    }
                    UpdateText();
                    
                    if (IsHandleCreated) {
                        OnTextChanged(EventArgs.Empty);
                    }
                    OnSelectedItemChanged(EventArgs.Empty);
                    OnSelectedIndexChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectedItem"]/*' />
        /// <devdoc>
        ///     The handle to the object that is currently selected in the
        ///     combos list.
        /// </devdoc>
        [
        Browsable(false),
        Bindable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxSelectedItemDescr)
        ]
        public object SelectedItem {
            get {
                int index = SelectedIndex;
                return(index == -1) ? null : Items[index];
            }
            set {
                int x = -1;
                
                if (itemsCollection != null) {
                    //bug (82115)
                    if (value != null)
                        x = itemsCollection.IndexOf(value);
                    else
                        SelectedIndex = -1;
                }

                if (x != -1) {
                    SelectedIndex = x;
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectedText"]/*' />
        /// <devdoc>
        ///     The selected text in the edit component of the ComboBox. If the
        ///     ComboBox has ComboBoxStyle.DROPDOWNLIST, the return is an empty
        ///     string ("").
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxSelectedTextDescr)
        ]
        public string SelectedText {
            get {
                if (DropDownStyle == ComboBoxStyle.DropDownList) return "";
                return Text.Substring(SelectionStart, SelectionLength);
            }
            set {
                if (DropDownStyle != ComboBoxStyle.DropDownList) {
                    CreateControl();
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, editHandle), NativeMethods.EM_REPLACESEL, NativeMethods.InvalidIntPtr, value);
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectionLength"]/*' />
        /// <devdoc>
        ///     The length, in characters, of the selection in the editbox.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxSelectionLengthDescr)
        ]
        public int SelectionLength {
            get {
                int[] end = new int[] {0};
                int[] start = new int[] {0};
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.CB_GETEDITSEL, start, end);
                return end[0] - start[0];
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "value", value.ToString()));
                }
                Select(SelectionStart, value);
            }
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectionStart"]/*' />
        /// <devdoc>
        ///     The [zero-based] index of the first character in the current text selection.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ComboBoxSelectionStartDescr)
        ]
        public int SelectionStart {
            get {
                int[] value = new int[] {0};
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.CB_GETEDITSEL, value, (int[])null);
                return value[0];
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "value", value.ToString()));
                }
                Select(value, SelectionLength);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Sorted"]/*' />
        /// <devdoc>
        ///     Indicates if the Combos list is sorted or not.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ComboBoxSortedDescr)
        ]
        public bool Sorted {
            get {
                return sorted;
            }
            set {
                if (sorted != value) {
                    if (this.DataSource != null && value) {
                        throw new ArgumentException(SR.GetString("ComboBoxSortWithDataSource"));
                    }

                    sorted = value;
                    RefreshItems();
                    SelectedIndex = -1;
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DropDownStyle"]/*' />
        /// <devdoc>
        ///     The type of combo that we are right now.  The value would come
        ///     from the System.Windows.Forms.ComboBoxStyle enumeration.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(ComboBoxStyle.DropDown),
        SRDescription(SR.ComboBoxStyleDescr),
        RefreshPropertiesAttribute(RefreshProperties.Repaint)
        ]
        public ComboBoxStyle DropDownStyle {
            get {
                bool found;
                int style = Properties.GetInteger(PropStyle, out found);
                if (found) {
                    return (ComboBoxStyle)style;
                }
                
                return ComboBoxStyle.DropDown;
            }
            set {
                if (DropDownStyle != value) {

                    // verify that 'value' is a valid enum type...
                    if (!Enum.IsDefined(typeof(ComboBoxStyle), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(ComboBoxStyle));
                    }

                    Properties.SetInteger(PropStyle, (int)value);

                    if (IsHandleCreated) {
                        RecreateHandle();
                    }

                    OnDropDownStyleChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true),
        Bindable(true)
        ]
        public override string Text {
            get {
                if (SelectedItem != null && !BindingFieldEmpty) {
                    // bug 54966: if the comboBox is bound, then use
                    // the binding to get the text
                    return FilterItemOnProperty(SelectedItem).ToString();
                }
                else {
                    return base.Text;
                }
            }
            set {
                base.Text = value;
                if (!DesignMode) {
                    //bug <70650> Subhag removed 'value.Length == 0' check to handle String.Empty.
                    //
                    if (value == null) { 
                        SelectedIndex = -1;
                    }
                    else if (value != null && (SelectedItem == null || (String.Compare(value, FilterItemOnProperty(SelectedItem).ToString(), false, CultureInfo.CurrentCulture) != 0))) {
                        // Scan through the list items looking for the supplied text string
                        //
                        for (int index=0; index < Items.Count; ++index) {
                            if (String.Compare(value, FilterItemOnProperty(Items[index]).ToString(), false, CultureInfo.CurrentCulture) == 0) {
                                SelectedIndex = index;
                                return;
                            }
                        }
                        for (int index=0; index < Items.Count; ++index) {
                            if (String.Compare(value, FilterItemOnProperty(Items[index]).ToString(), true, CultureInfo.CurrentCulture) == 0) {
                                SelectedIndex = index;
                                return;
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DrawItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.drawItemEventDescr)]
        public event DrawItemEventHandler DrawItem {
            add {
                Events.AddHandler(EVENT_DRAWITEM, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DRAWITEM, value);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DropDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ComboBoxOnDropDownDescr)]
        public event EventHandler DropDown {
            add {
                Events.AddHandler(EVENT_DROPDOWN, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DROPDOWN, value);
            }
        }


        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.MeasureItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.measureItemEventDescr)]
        public event MeasureItemEventHandler MeasureItem {
            add {
                Events.AddHandler(EVENT_MEASUREITEM, value);
                UpdateItemHeight();
            }
            remove {
                Events.RemoveHandler(EVENT_MEASUREITEM, value);
                UpdateItemHeight();
            }
        }


        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.selectedIndexChangedEventDescr)]
        public event EventHandler SelectedIndexChanged {
            add {
                Events.AddHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELECTEDINDEXCHANGED, value);
            }
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectionChangeCommitted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.selectionChangeCommittedEventDescr)]
        public event EventHandler SelectionChangeCommitted {
            add {
                Events.AddHandler(EVENT_SELECTIONCHANECOMMITTED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELECTIONCHANECOMMITTED, value);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.DropDownStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ComboBoxOnDropDownDescr)]
        public event EventHandler DropDownStyleChanged {
            add {
                Events.AddHandler(EVENT_DROPDOWNSTYLE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DROPDOWNSTYLE, value);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnPaint"]/*' />
        /// <devdoc>
        ///     ComboBox Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.AddItemsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of adding the specified items to the combobox
        /// </devdoc>
        protected virtual void AddItemsCore(object[] value) {
            int count = value == null? 0: value.Length;
            if (count == 0) {
                return;
            }

            BeginUpdate();
            try {
                Items.AddRangeInternal(value);
            }
            finally {
                EndUpdate();
            }
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.BeginUpdate"]/*' />
        /// <devdoc>
        ///     Disables redrawing of the combo box. A call to beginUpdate() must be
        ///     balanced by a following call to endUpdate(). Following a call to
        ///     beginUpdate(), any redrawing caused by operations performed on the
        ///     combo box is deferred until the call to endUpdate().
        /// </devdoc>
        public void BeginUpdate() {
            BeginUpdateInternal();
        }

        private void CheckNoDataSource() {
            if (DataSource != null) {
                throw new ArgumentException(SR.GetString(SR.DataSourceLocksItems));
            }
        }
        
        private void ChildWmGetObject(ref Message m) {

            // See "How to Handle WM_GETOBJECT" in MSDN
            if ( (m.HWnd == editHandle || m.HWnd == listHandle) && NativeMethods.OBJID_CLIENT == (int)m.LParam) {
                
                // Get the IAccessible GUID
                //
                Guid IID_IAccessible = new Guid(NativeMethods.uuid_IAccessible);

                // Get an Lresult for the accessibility Object for this control
                //
                IntPtr punkAcc;
                try {
                    IAccessible iacc = null;
                    if (m.HWnd == editHandle) {
                        if (editAccessibleObject == null) {
                            editAccessibleObject = new ChildAccessibleObject(this, editHandle);
                        }
                        iacc = (IAccessible)editAccessibleObject;                    
                    }
                    else {
                        if (listAccessibleObject == null) {
                            listAccessibleObject = new ChildAccessibleObject(this, listHandle);
                        }
                        iacc = (IAccessible)listAccessibleObject;                    
                    }
                    
                    // Obtain the Lresult
                    //
                    punkAcc = Marshal.GetIUnknownForObject(iacc);
                    
                    try {
                        m.Result = UnsafeNativeMethods.LresultFromObject(ref IID_IAccessible, m.WParam, new HandleRef(this, punkAcc));
                    }
                    finally {
                        Marshal.Release(punkAcc);
                    }                    
                }
                catch (Exception e) {
                    throw new InvalidOperationException(SR.GetString(SR.RichControlLresult), e);
                }
            }
            else {  // m.lparam != OBJID_CLIENT, so do default message processing
                DefChildWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     This procedure takes in the message, converts the Edit handle coordinates into Combo Box Coordinates
        /// </devdoc>
        /// <internalonly/>
        internal Point EditToComboboxMapping(Message m) {
            // Get the Combox Rect ...
            //
            NativeMethods.RECT comboRectMid = new NativeMethods.RECT();
            UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref comboRectMid);
            //
            //Get the Edit Rectangle...
            //
            NativeMethods.RECT editRectMid = new NativeMethods.RECT();
            UnsafeNativeMethods.GetWindowRect(new HandleRef(this, editHandle), ref editRectMid);
            
            //get the delta
            int comboXMid = (int)(short)m.LParam + (editRectMid.left - comboRectMid.left);
            int comboYMid = ((int)m.LParam >> 16)  + (editRectMid.top - comboRectMid.top);

            return (new Point(comboXMid,comboYMid));

        }


        /// <devdoc>
        ///     Subclassed window procedure for the edit and list child controls of the
        ///     combo box.
        /// </devdoc>
        /// <internalonly/>
        private void ChildWndProc(ref Message m) {

            switch (m.Msg) {
                case NativeMethods.WM_CHAR:
                case NativeMethods.WM_SYSCHAR:
                    if (!PreProcessMessage(ref m)) {
                        if(ProcessKeyEventArgs(ref m)) return;
                        DefChildWndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_KEYDOWN:
                case NativeMethods.WM_SYSKEYDOWN:
                    if (!PreProcessMessage(ref m)) {
                        if(ProcessKeyEventArgs(ref m)) return;		
                        DefChildWndProc(ref m);                   
                    }
		   
                    Keys keyData = (Keys)(int)m.WParam | ModifierKeys;
                    if (keyData == Keys.Enter) {
                        SelectAll();
                    }

                    break;
                case NativeMethods.WM_KEYUP:
                case NativeMethods.WM_SYSKEYUP:
                    if (!PreProcessMessage(ref m)) {		       
                        if(ProcessKeyEventArgs(ref m)) return;
                        DefChildWndProc(ref m);
                    }
                      
                    break;
                case NativeMethods.WM_KILLFOCUS:
                    if (!DesignMode) {
                        UpdateCachedImeMode(m.HWnd);
                    }
                    DefChildWndProc(ref m);
                    // We don't want to fire the focus events twice -
                    // once in the combobox and once here.
                    if (fireLostFocus) {
                        OnLostFocus(EventArgs.Empty);
                    }
                    break;
                case NativeMethods.WM_SETFOCUS:
                    
                    if (!DesignMode) {
                        SetImeModeToIMEContext(CachedImeMode, m.HWnd);
                    }
                
                    if (!HostedInWin32DialogManager) {
                        IContainerControl c = GetContainerControlInternal();
                        if (c != null) {
                            ContainerControl container = c as ContainerControl;
                            if (container != null) {
                                if (!container.ActivateControlInternal(this, false)) 
                                {
                                    return;
                                }
                            }
                        }
                    }

                    DefChildWndProc(ref m);
                    // We don't want to fire the focus events twice -
                    // once in the combobox and once here.
                    if (fireSetFocus) {
                        OnGotFocus(EventArgs.Empty);
                    }
                    break;
                
                case NativeMethods.WM_SETFONT:
                    DefChildWndProc(ref m);
                    if (m.HWnd == editHandle) {
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, editHandle), NativeMethods.EM_SETMARGINS,
                                                  NativeMethods.EC_LEFTMARGIN | NativeMethods.EC_RIGHTMARGIN, 0);
                    }
                    break;
                case NativeMethods.WM_LBUTTONDBLCLK:
                    //the Listbox gets  WM_LBUTTONDOWN - WM_LBUTTONUP -WM_LBUTTONDBLCLK - WM_LBUTTONUP...
                    //sequence for doubleclick...
                    //Set MouseEvents...
                    mousePressed = true;
                    mouseEvents = true;
                    CaptureInternal = true;
                    //Call the DefWndProc() so that mousemove messages get to the windows edit(112079)
                    //
                    DefChildWndProc(ref m);
                    OnMouseDown(new MouseEventArgs(MouseButtons.Left, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;

                case NativeMethods.WM_MBUTTONDBLCLK:
                    //the Listbox gets  WM_LBUTTONDOWN - WM_LBUTTONUP -WM_LBUTTONDBLCLK - WM_LBUTTONUP...
                    //sequence for doubleclick...
                    //Set MouseEvents...
                    mousePressed = true;
                    mouseEvents = true;
                    CaptureInternal = true;
                    //Call the DefWndProc() so that mousemove messages get to the windows edit(112079)
                    //
                    DefChildWndProc(ref m);
                    OnMouseDown(new MouseEventArgs(MouseButtons.Middle, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;

                case NativeMethods.WM_RBUTTONDBLCLK:
                    //the Listbox gets  WM_LBUTTONDOWN - WM_LBUTTONUP -WM_LBUTTONDBLCLK - WM_LBUTTONUP...
                    //sequence for doubleclick...
                    //Set MouseEvents...
                    mousePressed = true;
                    mouseEvents = true;
                    CaptureInternal = true;
                    //Call the DefWndProc() so that mousemove messages get to the windows edit(112079)
                    //
                    DefChildWndProc(ref m);
                    OnMouseDown(new MouseEventArgs(MouseButtons.Right, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;

                case NativeMethods.WM_LBUTTONDOWN:
                    mousePressed = true;
                    mouseEvents = true;
                    //set the mouse capture .. this is the Child Wndproc..
                    //
                    CaptureInternal = true;
                    DefChildWndProc(ref m);
                    OnMouseDown(new MouseEventArgs(MouseButtons.Left, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;
                case NativeMethods.WM_LBUTTONUP:
                    // Get the mouse location
                    //
                    NativeMethods.RECT r = new NativeMethods.RECT();
                    UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref r);
                    Rectangle ClientRect = new Rectangle(r.left, r.top, r.right - r.left, r.bottom - r.top);
                    // Get the mouse location
                    //
                    int x = (int)(short)m.LParam;
                    int y = (int)m.LParam >> 16;
                    Point pt = new Point(x,y);
                    pt = PointToScreen(pt);
                    // combo box gets a WM_LBUTTONUP for focus change ...
                    // So check MouseEvents....
                    if (mouseEvents && !ValidationCancelled) {
                        mouseEvents = false;
                        if (mousePressed) {
                            if (ClientRect.Contains(pt)) {
                                mousePressed = false;
                                OnClick(EventArgs.Empty);
                            }
                            else
                            {
                                mousePressed = false;
                                mouseInEdit = false;
                                OnMouseLeave(EventArgs.Empty);
                            }
                        }
                    }
                    DefChildWndProc(ref m);
                    CaptureInternal = false;
                    OnMouseUp(new MouseEventArgs(MouseButtons.Left, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;
                case NativeMethods.WM_MBUTTONDOWN:
                    mousePressed = true;
                    mouseEvents = true;
                    //set the mouse capture .. this is the Child Wndproc..
                    //
                    CaptureInternal = true;
                    DefChildWndProc(ref m);
                    //the up gets fired from "Combo-box's WndPrc --- So Convert these Coordinates to Combobox coordianate...
                    //
                    Point P = EditToComboboxMapping(m);
                    
                    OnMouseDown(new MouseEventArgs(MouseButtons.Middle, 1, P.X, P.Y, 0));
                    break;
                case NativeMethods.WM_RBUTTONDOWN:
                    mousePressed = true;
                    mouseEvents = true;

                    //set the mouse capture .. this is the Child Wndproc..
                    // Bug# 112108: If I set the capture=true here, the
                    // DefWndProc() never fires the WM_CONTEXTMENU that would show
                    // the default context menu.
                    //
                    if (this.ContextMenu != null)
                        CaptureInternal = true;
                    DefChildWndProc(ref m);
                    //the up gets fired from "Combo-box's WndPrc --- So Convert these Coordinates to Combobox coordianate...
                    //
                    Point Pt = EditToComboboxMapping(m);
                    
                    OnMouseDown(new MouseEventArgs(MouseButtons.Right, 1, Pt.X, Pt.Y, 0));
                    break;
                case NativeMethods.WM_MBUTTONUP:
                    mousePressed = false;
                    mouseEvents = false;
                    //set the mouse capture .. this is the Child Wndproc..
                    //
                    CaptureInternal = false;
                    DefChildWndProc(ref m);
                    OnMouseUp(new MouseEventArgs(MouseButtons.Middle, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;
                case NativeMethods.WM_RBUTTONUP:
                    mousePressed = false;
                    mouseEvents = false;
                    //set the mouse capture .. this is the Child Wndproc..
                    //
                    if (this.ContextMenu != null)
                        CaptureInternal = false;
                    DefChildWndProc(ref m);
                    OnMouseUp(new MouseEventArgs(MouseButtons.Right, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    break;

                case NativeMethods.WM_CONTEXTMENU:
                    // Forward context menu messages to the parent control
                    if (this.ContextMenu != null) {
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.WM_CONTEXTMENU, m.WParam, m.LParam);
                    }
                    else {
                        DefChildWndProc(ref m);
                    }
                    break;
                    
                case NativeMethods.WM_MOUSEMOVE:
                    Point point = EditToComboboxMapping(m);
                    //Call the DefWndProc() so that mousemove messages get to the windows edit(112079)
                    //
                    DefChildWndProc(ref m);
                    OnMouseMove(new MouseEventArgs(MouseButtons, 0, point.X, point.Y, 0));
                    break;
               
                case NativeMethods.WM_GETOBJECT:
                    ChildWmGetObject(ref m);
                    break;

                default:
                    DefChildWndProc(ref m);
                    break;
            }
        }
        
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void DefChildWndProc(ref Message m) {
            IntPtr defWndProc = m.HWnd == editHandle? editWndProc: listWndProc;
            m.Result = UnsafeNativeMethods.CallWindowProc(defWndProc, m.HWnd, m.Msg, m.WParam, m.LParam);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            ReleaseChildWindow();
            base.Dispose(disposing);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.EndUpdate"]/*' />
        /// <devdoc>
        ///     Reenables redrawing of the combo box. A call to beginUpdate() must be
        ///     balanced by a following call to endUpdate(). Following a call to
        ///     beginUpdate(), any redrawing caused by operations performed on the
        ///     combo box is deferred until the call to endUpdate().
        /// </devdoc>
        public void EndUpdate() {
            if (EndUpdateInternal()) {
                if (editHandle != IntPtr.Zero) {
                    SafeNativeMethods.InvalidateRect(new HandleRef(this, editHandle), null, false);
                }
                if (listHandle != IntPtr.Zero) {
                    SafeNativeMethods.InvalidateRect(new HandleRef(this, listHandle), null, false);
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.FindString"]/*' />
        /// <devdoc>
        ///     Finds the first item in the combo box that starts with the given string.
        ///     The search is not case sensitive.
        /// </devdoc>
        public int FindString(string s) {
            return FindString(s, -1);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.FindString1"]/*' />
        /// <devdoc>
        ///     Finds the first item after the given index which starts with the given
        ///     string. The search is not case sensitive.
        /// </devdoc>
        public int FindString(string s, int startIndex) {
            if (s == null) {
                return -1;
            }
            
            if (itemsCollection == null || itemsCollection.Count == 0) {
                return -1;
            }
            
            if (startIndex < -1 || startIndex >= itemsCollection.Count - 1) {
                throw new ArgumentOutOfRangeException("startIndex");
            }

            // Always use the managed FindStringInternal instead of CB_FINDSTRING.
            // The managed version correctly handles Turkish I.                
            //
            return FindStringInternal(s, Items, startIndex, false);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.FindStringExact"]/*' />
        /// <devdoc>
        ///     Finds the first item in the combo box that matches the given string.
        ///     The strings must match exactly, except for differences in casing.
        /// </devdoc>
        public int FindStringExact(string s) {
            return FindStringExact(s, -1);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.FindStringExact1"]/*' />
        /// <devdoc>
        ///     Finds the first item after the given index that matches the given
        ///     string. The strings must match exactly, except for differences in
        ///     casing.
        /// </devdoc>
        public int FindStringExact(string s, int startIndex) {
            if (s == null) return -1;
            
            if (itemsCollection == null || itemsCollection.Count == 0) {
                return -1;
            }
            
            if (startIndex < -1 || startIndex >= itemsCollection.Count - 1) {
                throw new ArgumentOutOfRangeException("startIndex");
            }
            
            // Always use the managed FindStringInternal instead of CB_FINDSTRINGEXACT.
            // The managed version correctly handles Turkish I.                
            //
            return FindStringInternal(s, Items, startIndex, true);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.GetItemHeight"]/*' />
        /// <devdoc>
        ///     Returns the height of the given item in an OwnerDrawVariable style
        ///     combo box. This method should not be used for Normal or OwnerDrawFixed
        ///     style combo boxes.
        /// </devdoc>
        public int GetItemHeight(int index) {

            // This function is only relevant for OwnerDrawVariable
            if (DrawMode != DrawMode.OwnerDrawVariable) {
                return ItemHeight;
            }

            if (index < 0 || itemsCollection == null || index >= itemsCollection.Count) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index", (index).ToString()));
            }

            if (IsHandleCreated) {
            
                int h = (int)SendMessage(NativeMethods.CB_GETITEMHEIGHT, index, 0);
                if (h == -1) {
                    throw new Win32Exception();
                }
                return h;
            }
            
            return ItemHeight;
        }

        internal override IntPtr InitializeDCForWmCtlColor(IntPtr dc, int msg) {

            if ((msg == NativeMethods.WM_CTLCOLORSTATIC) && !ShouldSerializeBackColor()) {
                // Let the Win32 Edit control handle background colors itself.
                // This is necessary because a disabled edit control will display a different
                // BackColor than when enabled.
                return IntPtr.Zero;
            }
            else {
                return base.InitializeDCForWmCtlColor(dc, msg);
            }
        }

        // Invalidate the entire control, including child HWNDs and non-client areas
        private void InvalidateEverything() {
            SafeNativeMethods.RedrawWindow(new HandleRef(this, Handle),
                                           null, NativeMethods.NullHandleRef,
                                           NativeMethods.RDW_INVALIDATE |
                                           NativeMethods.RDW_FRAME |  // Control.Invalidate(true) doesn't invalidate the non-client region
                                           NativeMethods.RDW_ERASE |
                                           NativeMethods.RDW_ALLCHILDREN);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.IsInputKey"]/*' />
        /// <devdoc>
        ///     Determines if keyData is in input key that the control wants.
        ///     Overridden to return true for RETURN and ESCAPE when the combo box is
        ///     dropped down.
        /// </devdoc>
        /// <internalonly/>
        protected override bool IsInputKey(Keys keyData) {

            Keys keyCode = keyData & (Keys.KeyCode | Keys.Alt);
            if ((keyCode == Keys.Return || keyCode == Keys.Escape) && DroppedDown) return true;
            return base.IsInputKey(keyData);            
        }

        /// <devdoc>
        ///     Adds the given item to the native combo box.  This asserts if the handle hasn't been
        ///     created.
        /// </devdoc>
        private int NativeAdd(object item) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            int insertIndex = (int)SendMessage(NativeMethods.CB_ADDSTRING, 0, GetItemText(item));
            if (insertIndex < 0) {
                throw new OutOfMemoryException(SR.GetString(SR.ComboBoxItemOverflow));
            }
            return insertIndex;
        }
        
        /// <devdoc>
        ///     Clears the contents of the combo box.
        /// </devdoc>
        private void NativeClear() {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            string saved = null;
            if (DropDownStyle != ComboBoxStyle.DropDownList) {
                saved = WindowText;
            }
            SendMessage(NativeMethods.CB_RESETCONTENT, 0, 0);
            if (saved != null) {
                WindowText = saved;
            }
        }

        /// <devdoc>
        ///     Inserts the given item to the native combo box at the index.  This asserts if the handle hasn't been
        ///     created or if the resulting insert index doesn't match the passed in index.
        /// </devdoc>
        private int NativeInsert(int index, object item) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            int insertIndex = (int)SendMessage(NativeMethods.CB_INSERTSTRING, index, GetItemText(item));
            if (insertIndex < 0) {
                throw new OutOfMemoryException(SR.GetString(SR.ComboBoxItemOverflow));
            }
            Debug.Assert(insertIndex == index, "NativeComboBox inserted at " + insertIndex + " not the requested index of " + index);
            return insertIndex;
        }
        
        /// <devdoc>
        ///     Removes the native item from the given index.
        /// </devdoc>
        private void NativeRemoveAt(int index) {
            Debug.Assert(IsHandleCreated, "Shouldn't be calling Native methods before the handle is created.");
            
            // Windows combo does not invalidate the selected region if you remove the
            // currently selected item.  Test for this and invalidate.  Note that because
            // invalidate will lazy-paint we can actually invalidate before we send the
            // delete message.
            //
            if (DropDownStyle == ComboBoxStyle.DropDownList && SelectedIndex == index) {
                Invalidate();
            }
            
            SendMessage(NativeMethods.CB_DELETESTRING, index, 0);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Overridden to make sure all the items and styles get set up correctly.
        ///     Inheriting classes should not forget to call
        ///     base.OnHandleCreated()
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            
            base.OnHandleCreated(e);
            
            if (MaxLength > 0) {
                SendMessage(NativeMethods.CB_LIMITTEXT, MaxLength, 0);
            }
            
            // Get the handles and wndprocs of the ComboBox's child windows
            //
            Debug.Assert(!childWindowRoot.IsAllocated, "Child window root already allocated");
            Debug.Assert(listHandle == IntPtr.Zero, "List handle already set");
            Debug.Assert(listWndProc == IntPtr.Zero, "List wndproc already set");
            Debug.Assert(editHandle == IntPtr.Zero, "Edit handle already set");
            Debug.Assert(editWndProc == IntPtr.Zero, "Edit wndproc already set");
            
            bool ok = !childWindowRoot.IsAllocated && 
                        listHandle == IntPtr.Zero && 
                        listWndProc == IntPtr.Zero && 
                        editHandle == IntPtr.Zero &&
                        editWndProc == IntPtr.Zero;
            
            if (ok && DropDownStyle != ComboBoxStyle.DropDownList) {
                IntPtr hwnd = UnsafeNativeMethods.GetWindow(new HandleRef(this, Handle), NativeMethods.GW_CHILD);
                if (hwnd != IntPtr.Zero) {
                    NativeMethods.WndProc wndProc = new NativeMethods.WndProc(new ChildWindow(this).Callback);
                    
                    childWindowRoot = GCHandle.Alloc(wndProc);
                    if (DropDownStyle == ComboBoxStyle.Simple) {
                        listHandle = hwnd;
                        listWndProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, hwnd), NativeMethods.GWL_WNDPROC);
                        UnsafeNativeMethods.SetWindowLong(new HandleRef(this, hwnd), NativeMethods.GWL_WNDPROC, wndProc);
                        hwnd = UnsafeNativeMethods.GetWindow(new HandleRef(this, hwnd), NativeMethods.GW_HWNDNEXT);
                    }
                    editHandle = hwnd;
                    editWndProc = UnsafeNativeMethods.GetWindowLong(new HandleRef(this, hwnd), NativeMethods.GWL_WNDPROC);
                    UnsafeNativeMethods.SetWindowLong(new HandleRef(this, hwnd), NativeMethods.GWL_WNDPROC, wndProc);
                }
            }
            
            //
            
            bool found;
            int dropDownWidth = Properties.GetInteger(PropDropDownWidth, out found);
            if (found) {
                SendMessage(NativeMethods.CB_SETDROPPEDWIDTH, dropDownWidth, 0);
            }

            // Resize a simple style combobox on handle creation                                         
            // to respect the requested height.
            //
            if (DropDownStyle == ComboBoxStyle.Simple) {
                Height = requestedHeight;
            }
            
            if (itemsCollection != null) {
                foreach(object item in itemsCollection) {
                    NativeAdd(item);
                }
                
                // Now udpate the current selection.
                //
                if (selectedIndex >= 0) {
                    SendMessage(NativeMethods.CB_SETCURSEL, selectedIndex, 0);
                    UpdateText();
                    selectedIndex = -1;
                }
            }
            
            // NOTE: Setting SelectedIndex must be the last thing we do. See ASURT 73949.
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///     We need to un-subclasses everything here.  Inheriting classes should
        ///     not forget to call base.OnHandleDestroyed()
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleDestroyed(EventArgs e) {
            ReleaseChildWindow();
            dropDownHandle = IntPtr.Zero;
            if (Disposing) {
                itemsCollection = null;
                selectedIndex = -1;
            }
            else {
                selectedIndex = SelectedIndex;
            }
            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnDrawItem"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the drawItem event.  Don't
        ///     forget to call base.onDrawItem() to ensure that drawItem events
        ///     are correctly fired at all other times.
        /// </devdoc>
        protected virtual void OnDrawItem(DrawItemEventArgs e) {
            DrawItemEventHandler handler = (DrawItemEventHandler)Events[EVENT_DRAWITEM];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnDropDown"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the dropDown event.  Don't
        ///     forget to call base.onDropDown() to ensure that dropDown events
        ///     are correctly fired at all other times.
        /// </devdoc>
        protected virtual void OnDropDown(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_DROPDOWN];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnKeyPress"]/*' />
        /// <devdoc>
        ///     Key press event handler. Overridden to close up the combo box when the
        ///     user presses RETURN or ESCAPE.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyPress(KeyPressEventArgs e) {
            base.OnKeyPress(e);
            if (!e.Handled && (e.KeyChar == (char)(int)Keys.Return || e.KeyChar == (char)(int)Keys.Escape)
                && DroppedDown) {
                DroppedDown = false;
                e.Handled = true;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnMeasureItem"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the measuereItem event.  Don't
        ///     forget to call base.onMeasureItem() to ensure that measureItem
        ///     events are correctly fired at all other times.
        /// </devdoc>
        protected virtual void OnMeasureItem(MeasureItemEventArgs e) {
            MeasureItemEventHandler handler = (MeasureItemEventHandler)Events[EVENT_MEASUREITEM];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnSelectionChangeCommitted"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the SelectionChangeCommitted event.
        ///     Don't forget to call base.OnSelectionChangeCommitted() to ensure
        ///     that SelectionChangeCommitted events are correctly fired at all other times.
        /// </devdoc>
        protected virtual void OnSelectionChangeCommitted(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_SELECTIONCHANECOMMITTED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the selectedIndexChanged event.
        ///     Don't forget to call base.onSelectedIndexChanged() to ensure
        ///     that selectedIndexChanged events are correctly fired at all other times.
        /// </devdoc>
        protected override void OnSelectedIndexChanged(EventArgs e) {
            base.OnSelectedIndexChanged(e);
            EventHandler handler = (EventHandler)Events[EVENT_SELECTEDINDEXCHANGED];
            if (handler != null) handler(this,e);

            // set the position in the dataSource, if there is any
            // we will only set the position in the currencyManager if it is different
            // from the SelectedIndex. Setting CurrencyManager::Position (even w/o changing it)
            // calls CurrencyManager::EndCurrentEdit, and that will pull the dataFrom the controls
            // into the backEnd. We do not need to do that.
            //
            if (this.DataManager != null && DataManager.Position != SelectedIndex) {
                this.DataManager.Position = this.SelectedIndex;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnSelectedValueChanged"]/*' />
        protected override void OnSelectedValueChanged(EventArgs e) {
            base.OnSelectedValueChanged(e);
            selectedValueChangedFired = true;
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnSelectedItemChanged"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the selectedItemChanged event.
        ///     Don't forget to call base.onSelectedItemChanged() to ensure
        ///     that selectedItemChanged events are correctly fired at all other times.
        /// </devdoc>
        protected virtual void OnSelectedItemChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_SELECTEDITEMCHANGED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnDropDownStyleChanged"]/*' />
        /// <devdoc>
        ///     This is the code that actually fires the DropDownStyleChanged event.
        /// </devdoc>
        protected virtual void OnDropDownStyleChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_DROPDOWNSTYLE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnParentBackColorChanged"]/*' />
        /// <devdoc>
        ///     This method is called by the parent control when any property
        ///     changes on the parent. This can be overriden by inheriting
        ///     classes, however they must call base.OnParentPropertyChanged.
        /// </devdoc>
        protected override void OnParentBackColorChanged(EventArgs e) {
            base.OnParentBackColorChanged(e);
            if (DropDownStyle == ComboBoxStyle.Simple) Invalidate();
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnFontChanged"]/*' />
        /// <devdoc>
        ///     Indicates that a critical property, such as color or font has
        ///     changed.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            UpdateControl(true);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///     Indicates that a critical property, such as color or font has
        ///     changed.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnBackColorChanged(EventArgs e) {
            base.OnBackColorChanged(e);
            UpdateControl(false);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnForeColorChanged"]/*' />
        /// <devdoc>
        ///     Indicates that a critical property, such as color or font has
        ///     changed.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnForeColorChanged(EventArgs e) {
            base.OnForeColorChanged(e);
            UpdateControl(false);
        }

        private void UpdateControl(bool recreate) {
            //clear the pref height cache
            prefHeightCache = -1;

            if (IsHandleCreated) {
                if (DropDownStyle == ComboBoxStyle.Simple && recreate) {
                    // Control forgets to add a scrollbar. See ASURT 19113.
                    RecreateHandle();
                }
                else {
                    UpdateItemHeight();
                    // Force everything to repaint. See ASURT 19113.
                    InvalidateEverything();
                }
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnResize"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Resize'/> event.</para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            if (DropDownStyle == ComboBoxStyle.Simple) {
                // simple style combo boxes have more painting problems than you can shake a stick at (#19113)
                InvalidateEverything();
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnDataSourceChanged"]/*' />                      
        protected override void OnDataSourceChanged(EventArgs e) {
            if (Sorted) {
                if (DataSource != null && Created) {
                    // we will only throw the exception when the control is already on the form.
                    Debug.Assert(DisplayMember.Equals(String.Empty), "if this list is sorted it means that dataSource was null when Sorted first became true. at that point DisplayMember had to be String.Empty");
                    DataSource = null;
                    throw new Exception(SR.GetString("ComboBoxDataSourceWithSort"));
                }
            }
            if (DataSource == null)
            {
                BeginUpdate();
                SelectedIndex = -1;
                Items.ClearInternal();
                EndUpdate();
            }
            if (!Sorted && Created)
                base.OnDataSourceChanged(e);
            RefreshItems();
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.OnDisplayMemberChanged"]/*' />
        protected override void OnDisplayMemberChanged(EventArgs e) {
            base.OnDisplayMemberChanged(e);
            
            // bug 63005: when we change the displayMember, we need to refresh the
            // items collection
            //
            RefreshItems();
        }

        /// <devdoc>
        /// Reparses the objects, getting new text strings for them.
        /// </devdoc>
        /// <internalonly/>
        private void RefreshItems() {
        
            // Save off the selection and the current collection.
            //
            int selectedIndex = SelectedIndex;
            ObjectCollection savedItems = itemsCollection;
            
            // Clear the items.
            //
            itemsCollection = null;
            
            if (IsHandleCreated) {
                NativeClear();
            }
            
            object[] newItems = null;
            
            // if we have a dataSource and a DisplayMember, then use it
            // to populate the Items collection
            //
            if (this.DataManager != null && this.DataManager.Count != -1) {
                newItems = new object[this.DataManager.Count];
                for(int i = 0; i < newItems.Length; i++) {
                    newItems[i] = this.DataManager[i];
                }
            }
            else if (savedItems != null) {
                newItems = new object[savedItems.Count];
                savedItems.CopyTo(newItems, 0);
            }

            // Store the current list of items
            //
            if (newItems != null) {
                Items.AddRangeInternal(newItems);
            }
            
            if (this.DataManager != null) {
                // put the selectedIndex in sync w/ the position in the dataManager
                this.SelectedIndex = this.DataManager.Position;
            }
            else {
                SelectedIndex = selectedIndex;
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.RefreshItem"]/*' />
        /// <devdoc>
        /// Reparses the object at the given index, getting new text string for it.
        /// </devdoc>
        /// <internalonly/>
        protected override void RefreshItem(int index) {
            Items.SetItemInternal(index, Items[index]);
        }


        /// <devdoc>
        ///     Release the ChildWindow object by un-subclassing the child edit and
        ///     list controls and freeing the root of the ChildWindow object.
        /// </devdoc>
        private void ReleaseChildWindow() {
            if (editHandle != IntPtr.Zero) {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, editHandle), NativeMethods.GWL_WNDPROC, new HandleRef(this, editWndProc));
                editHandle = IntPtr.Zero;
                editWndProc = IntPtr.Zero;
            }
            if (listHandle != IntPtr.Zero) {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, listHandle), NativeMethods.GWL_WNDPROC, new HandleRef(this, listWndProc));
                listHandle = IntPtr.Zero;
                listWndProc = IntPtr.Zero;
            }
            if (childWindowRoot.IsAllocated) {
                childWindowRoot.Free();                
            }

        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.Select"]/*' />
        /// <devdoc>
        ///     Selects the text in the editable portion of the ComboBox at the
        ///     from the given start index to the given end index.
        /// </devdoc>
        public void Select(int start, int length) {
            if (start < 0) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "start", start.ToString()));
            }
            if (length < 0) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "length", length.ToString()));
            }

            int end = start + length;
            SendMessage(NativeMethods.CB_SETEDITSEL, 0, NativeMethods.Util.MAKELPARAM(start, end));
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SelectAll"]/*' />
        /// <devdoc>
        ///     Selects all the text in the editable portion of the ComboBox.
        /// </devdoc>
        public void SelectAll() {
            Select(0, Int32.MaxValue);
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the bounds of this control. Inheriting
        ///     classes can overide this function to add size restrictions. Inheriting
        ///     classes must call base.setBoundsCore to actually cause the bounds
        ///     of the control to change.
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {

            // If we are changing height, store the requested height.
            // Requested height is used if the style is changed to simple.
            // (Bug fix #20966)
            if ((specified & BoundsSpecified.Height) != BoundsSpecified.None) {
                requestedHeight = height;
            }
            
            if (DropDownStyle == ComboBoxStyle.DropDown
                || DropDownStyle == ComboBoxStyle.DropDownList) {

                // Height is not user-changable for these styles
                if (ParentInternal != null) {
                    height = PreferredHeight;
                }
            }

            base.SetBoundsCore(x, y, width, height, specified);
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SetItemsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the specified items to the combobox
        /// </devdoc>
        protected override void SetItemsCore(IList value) {
            BeginUpdate();
            Items.ClearInternal();
            Items.AddRangeInternal(value);

            // if the list changed, we w