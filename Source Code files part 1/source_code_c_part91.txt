        NonPagedPool,
        sizeof(PIO_RESOURCE_LIST) * listSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (resourceArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( resourceArray, sizeof(PIO_RESOURCE_LIST) * listSize );

    //
    // Get the first list to work on
    //
    curList = &( (*IoResReqList)->List[0]);
    buffer = (PUCHAR) curList;
    newSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) - sizeof(IO_RESOURCE_LIST);

    //
    // Sort the IoResList
    //
    status = ACPIRangeSortIoList( curList );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "ACPIRangeSubtract: AcpiRangeSortIoList 0x%08lx Failed 0x%08lx\n",
            *curList,
            status
            ) );
        return status;

    }


    //
    // Process all the elements in the list
    //
    for (listIndex = 0; listIndex < listSize; listIndex++) {

        //
        // Process that list
        //
        status = ACPIRangeSubtractIoList(
            curList,
            CmResList,
            &(resourceArray[listIndex])
            );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIRangeSubtract: Failed - 0x%08lx\n",
                status
                ) );
            while (listIndex) {

                ExFreePool( resourceArray[listIndex] );
                listIndex--;

            }
            ExFreePool( resourceArray );
            return status;

        }

        //
        // Help calculate the size of the new res req descriptor
        //
        newSize += sizeof(IO_RESOURCE_LIST) +
            ( ( (resourceArray[listIndex])->Count - 1) *
            sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Find the next list
        //
        size = sizeof(IO_RESOURCE_LIST) + (curList->Count - 1) *
            sizeof(IO_RESOURCE_DESCRIPTOR);
        buffer += size;
        curList = (PIO_RESOURCE_LIST) buffer;

    }

    //
    // Allocate the new list
    //
    newList = ExAllocatePoolWithTag(
        NonPagedPool,
        newSize,
        ACPI_RESOURCE_POOLTAG
        );
    if (newList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeSubtract: Failed to allocate 0x%08lx bytes\n",
            size
            ) );
        do {

            listSize--;
            ExFreePool( resourceArray[listSize] );

        } while (listSize);
        ExFreePool( resourceArray );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Copy the head of the res req list
    //
    RtlZeroMemory( newList, newSize );
    RtlCopyMemory(
        newList,
        *IoResReqList,
        sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
        sizeof(IO_RESOURCE_LIST)
        );
    newList->ListSize = newSize;
    curList = &(newList->List[0]);
    buffer = (PUCHAR) curList;

    for (listIndex = 0; listIndex < listSize; listIndex++) {

        //
        // Determine the size to copy
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( ( ( (resourceArray[listIndex])->Count) - 1) *
              sizeof(IO_RESOURCE_DESCRIPTOR) );

        //
        // Copy the new resource to the correct place
        //
        RtlCopyMemory(
            curList,
            resourceArray[ listIndex ],
            size
            );

        //
        // Find the next list
        //
        buffer += size;
        curList = (PIO_RESOURCE_LIST) buffer;

        //
        // Done with this list
        //
        ExFreePool( resourceArray[listIndex] );

    }

    //
    // Done with this area of memory
    //
    ExFreePool( resourceArray );

    //
    // Free Old list
    //
    ExFreePool( *IoResReqList );

    //
    // Return the new list
    //
    *IoResReqList = newList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRangeSubtractIoList(
    IN  PIO_RESOURCE_LIST   IoResList,
    IN  PCM_RESOURCE_LIST   CmResList,
    OUT PIO_RESOURCE_LIST   *Result
    )
/*++

Routine Description:

    This routine is responsible for subtracting the elements of the
    CmResList from the IoResList

Arguments:

    IoResList   - The list to subtract from
    CmResList   - The list to subtract
    Result      - The answer

Return Value:

    NTSTATUS

--*/
{
    //
    // The current CM descriptor
    //
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    //
    // The current CM resource list that we are processing
    //
    PCM_PARTIAL_RESOURCE_LIST       cmList;
    //
    // The current IO descriptor
    //
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    //
    // The working copy of the result list
    //
    PIO_RESOURCE_LIST               workList;
    //
    // The current index into the cm res list
    //
    ULONG                           cmIndex;
    //
    // The number of elements there are in the cm res list
    //
    ULONG                           cmSize;
    //
    // The current index into the io res list
    //
    ULONG                           ioIndex;
    //
    // The number of elements there are in the io res list
    //
    ULONG                           ioSize;
    //
    // The current index into the result. This is where the 'next' resource
    // descriptor goes into.
    //
    ULONG                           resultIndex = 0;
    //
    // How many elements there are in the result
    //
    ULONG                           resultSize;
    //
    // These are the max and min of the cm desc
    //
    ULONGLONG                       cmMax, cmMin;
    //
    // These are the max and min of the io desc
    //
    ULONGLONG                       ioMax, ioMin;
    //
    // The length of the resource
    //
    ULONGLONG                       length;

    //
    // Step one: Obtain the pointers we need to the start of the cm list
    // and the size of the supplied lists
    //
    cmList = &(CmResList->List[0].PartialResourceList);
    cmSize = cmList->Count;
    ioSize = IoResList->Count;

    //
    // Step two: Calculate the number of Io descriptors needed in the
    // worst case. That is 2x the number of cm descriptors plut the number
    // of original io descriptors.
    //
    resultSize = cmSize * 2 + ioSize * 2;

    //
    // Step three: Allocate enough memory for those descriptors
    //
    workList = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultSize - 1) ),
        ACPI_RESOURCE_POOLTAG
        );
    if (workList == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( workList, sizeof(IO_RESOURCE_LIST) +
        (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultSize - 1) ) );
    RtlCopyMemory(
        workList,
        IoResList,
        sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR)
        );

    //
    // Step four: walk through the entire io res list
    //
    for (ioIndex = 0; ioIndex < ioSize; ioIndex++) {

        //
        // Step five: copy the current descriptor to the result, and
        // keep a pointer to it. Remember where to store the next io
        // descriptor.
        //
        RtlCopyMemory(
            &(workList->Descriptors[resultIndex]),
            &(IoResList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "Copied Desc %d (0x%08lx) to Index %d (0x%08lx)\n",
            ioIndex,
            &(IoResList->Descriptors[ioIndex]),
            resultIndex,
            &(workList->Descriptors[resultIndex])
            ) );
        ioDesc = &(workList->Descriptors[resultIndex]);
        resultIndex += 1;

        //
        // Step six: Walk the Cm Res list, looking for resources to
        // subtract from this descriptor
        //
        for (cmIndex = 0; cmIndex < cmSize; cmIndex++) {

            //
            // If we don't have a resource descriptor any more, then
            // we stop looping
            //
            if (ioDesc == NULL) {

                break;

            }

            //
            // Step seven: determine the current cm descriptor
            //
            cmDesc = &(cmList->PartialDescriptors[cmIndex]);

            //
            // Step eight: is the current cm descriptor of the same type
            // as the io descriptor?
            //
            if (cmDesc->Type != ioDesc->Type) {

                //
                // No
                //
                continue;

            }

            //
            // Step nine: we must handle each resource type indepently.
            //
            switch (ioDesc->Type) {
            case CmResourceTypeMemory:
            case CmResourceTypePort:

                ioMin = ioDesc->u.Port.MinimumAddress.QuadPart;
                ioMax = ioDesc->u.Port.MaximumAddress.QuadPart;
                cmMin = cmDesc->u.Port.Start.QuadPart;
                cmMax = cmDesc->u.Port.Start.QuadPart +
                    cmDesc->u.Port.Length - 1;

                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "ACPIRangeSubtractIoRange: ioMin 0x%lx ioMax 0x%lx "
                    "cmMin 0x%lx cmMax 0x%lx resultIndex 0x%lx\n",
                    (ULONG) ioMin,
                    (ULONG) ioMax,
                    (ULONG) cmMin,
                    (ULONG) cmMax,
                    resultIndex
                    ) );

                //
                // Does the descriptors overlap?
                //
                if (ioMin > cmMax || ioMax < cmMin) {

                    break;

                }

                //
                // Do we need to remove the descriptor from the list?
                //
                if (ioMin >= cmMin && ioMax <= cmMax) {

                    resultIndex -= 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we need to truncate the lowpart of the io desc?
                //
                if (ioMin >= cmMin && ioMax > cmMax) {

                    ioDesc->u.Port.MinimumAddress.QuadPart = (cmMax + 1);
                    length = ioMax - cmMax;

                }

                //
                // Do we need to truncate the highpart of the io desc?
                //
                if (ioMin < cmMin && ioMax <= cmMax) {

                    ioDesc->u.Port.MaximumAddress.QuadPart = (cmMin - 1);
                    length = cmMin - ioMin;

                }

                //
                // Do we need to split the descriptor into two parts
                //
                if (ioMin < cmMin && ioMax > cmMax) {

                    //
                    // Create a new descriptors
                    //
                    RtlCopyMemory(
                        &(workList->Descriptors[resultIndex]),
                        ioDesc,
                        sizeof(IO_RESOURCE_DESCRIPTOR)
                        );
                    ACPIPrint( (
                        ACPI_PRINT_RESOURCES_2,
                        "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                        &(IoResList->Descriptors[ioIndex]),
                        resultIndex,
                        &(workList->Descriptors[resultIndex])
                        ) );
                    ioDesc->u.Port.MaximumAddress.QuadPart = (cmMin - 1);
                    ioDesc->u.Port.Alignment = 1;
                    length = cmMin - ioMin;
                    if ( (ULONG) length < ioDesc->u.Port.Length) {

                        ioDesc->u.Port.Length = (ULONG) length;

                    }

                    //
                    // Next descriptor
                    //
                    ioDesc = &(workList->Descriptors[resultIndex]);
                    ioDesc->u.Port.MinimumAddress.QuadPart = (cmMax + 1);
                    ioDesc->u.Port.Alignment = 1;
                    length = ioMax - cmMax;
                    resultIndex += 1;

                }

                //
                // Do we need to update the length?
                //
                if ( (ULONG) length < ioDesc->u.Port.Length) {

                    ioDesc->u.Port.Length = (ULONG) length;

                }
                break;

            case CmResourceTypeInterrupt:

                //
                // Do the descriptors overlap?
                //
                if (ioDesc->u.Interrupt.MinimumVector >
                    cmDesc->u.Interrupt.Vector ||
                    ioDesc->u.Interrupt.MaximumVector <
                    cmDesc->u.Interrupt.Vector) {

                    break;

                }

                //
                // Do we have to remove the descriptor
                //
                if (ioDesc->u.Interrupt.MinimumVector ==
                    cmDesc->u.Interrupt.Vector &&
                    ioDesc->u.Interrupt.MaximumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    resultIndex =- 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we clip the low part?
                //
                if (ioDesc->u.Interrupt.MinimumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    ioDesc->u.Interrupt.MinimumVector++;
                    break;

                }

                //
                // Do we clip the high part
                //
                if (ioDesc->u.Interrupt.MaximumVector ==
                    cmDesc->u.Interrupt.Vector) {

                    ioDesc->u.Interrupt.MaximumVector--;
                    break;

                }

                //
                // Split the record
                //
                RtlCopyMemory(
                    &(workList->Descriptors[resultIndex]),
                    ioDesc,
                    sizeof(IO_RESOURCE_DESCRIPTOR)
                    );
                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                    &(IoResList->Descriptors[ioIndex]),
                    resultIndex,
                    &(workList->Descriptors[resultIndex])
                    ) );
                ioDesc->u.Interrupt.MaximumVector =
                    cmDesc->u.Interrupt.Vector - 1;
                ioDesc = &(workList->Descriptors[resultIndex]);
                ioDesc->u.Interrupt.MinimumVector =
                    cmDesc->u.Interrupt.Vector + 1;
                resultIndex += 1;
                break;

            case CmResourceTypeDma:

                //
                // Do the descriptors overlap?
                //
                if (ioDesc->u.Dma.MinimumChannel >
                    cmDesc->u.Dma.Channel ||
                    ioDesc->u.Dma.MaximumChannel <
                    cmDesc->u.Dma.Channel) {

                    break;

                }

                //
                // Do we have to remove the descriptor
                //
                if (ioDesc->u.Dma.MinimumChannel ==
                    cmDesc->u.Dma.Channel &&
                    ioDesc->u.Dma.MaximumChannel ==
                    cmDesc->u.Dma.Channel) {

                    resultIndex -= 1;
                    ioDesc = NULL;
                    break;

                }

                //
                // Do we clip the low part?
                //
                if (ioDesc->u.Dma.MinimumChannel ==
                    cmDesc->u.Dma.Channel) {

                    ioDesc->u.Dma.MinimumChannel++;
                    break;

                }

                //
                // Do we clip the high part
                //
                if (ioDesc->u.Dma.MaximumChannel ==
                    cmDesc->u.Dma.Channel) {

                    ioDesc->u.Dma.MaximumChannel--;
                    break;

                }

                //
                // Split the record
                //
                RtlCopyMemory(
                    &(workList->Descriptors[resultIndex]),
                    ioDesc,
                    sizeof(IO_RESOURCE_DESCRIPTOR)
                    );
                ACPIPrint( (
                    ACPI_PRINT_RESOURCES_2,
                    "Copied Desc (0x%08lx) to Index %d (0x%08lx)\n",
                    &(IoResList->Descriptors[ioIndex]),
                    resultIndex,
                    &(workList->Descriptors[resultIndex])
                    ) );
                ioDesc->u.Dma.MaximumChannel =
                    cmDesc->u.Dma.Channel - 1;
                ioDesc = &(workList->Descriptors[resultIndex]);
                ioDesc->u.Dma.MinimumChannel =
                    cmDesc->u.Dma.Channel + 1;
                resultIndex += 1;
                break;
            } // switch

        } // for

        //
        // Step ten, make a backup copy of the original descriptor, and
        // mark it as a DeviceSpecific resource
        //
        RtlCopyMemory(
            &(workList->Descriptors[resultIndex]),
            &(IoResList->Descriptors[ioIndex]),
            sizeof(IO_RESOURCE_DESCRIPTOR)
            );
        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "Copied Desc %d (0x%08lx) to Index %d (0x%08lx) for backup\n",
            ioIndex,
            &(IoResList->Descriptors[ioIndex]),
            resultIndex,
            &(workList->Descriptors[resultIndex])
            ) );

        ioDesc = &(workList->Descriptors[resultIndex]);
        ioDesc->Type = CmResourceTypeDevicePrivate;
        resultIndex += 1;

    } // for

    //
    // Step 11: Calculate the number of resources in the new list
    //
    workList->Count = resultIndex;

    //
    // Step 12: Allocate the block for the return value. Don't waste
    // any memory here
    //
    *Result = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultIndex - 1) ),
        ACPI_RESOURCE_POOLTAG
        );
    if (*Result == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Step 13: Copy the result over and free the work buffer
    //
    RtlCopyMemory(
        *Result,
        workList,
        sizeof(IO_RESOURCE_LIST) +
            (sizeof(IO_RESOURCE_DESCRIPTOR) * (resultIndex - 1) )
        );

    //
    // Step 14: Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIRangeValidatePciMemoryResource(
    IN  PIO_RESOURCE_LIST       IoList,
    IN  ULONG                   Index,
    IN  PACPI_BIOS_MULTI_NODE   E820Info,
    OUT ULONG                   *BugCheck
    )
/*++

Routine Description:

    This routine checks the specified descriptor in the resource list does
    not in any way overlap or conflict with any of the descriptors in the
    E820 information structure

Arguments:

    IoResList   - The IoResourceList to check
    Index       - The descript we are currently looking at
    E820Info    - The BIOS's memory description table (Chapter 14 of ACPI Spec)
    BugCheck    - The number of bugcheckable offences commited


Return Value:

    None

--*/
{
    ULONG       i;
    ULONGLONG   absMin;
    ULONGLONG   absMax;

    ASSERT( IoList != NULL );

    //
    // Make sure that there is an E820 table before we look at it
    //
    if (E820Info == NULL) {

        return;
    }

    //
    // Calculate the absolute maximum and minimum size of the memory window
    //
    absMin = IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart;
    absMax = IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart;

    //
    // Look at all the entries in the E820Info and see if there is an
    // overlap
    //
    for (i = 0; i < E820Info->Count; i++) {

        //
        // Hackhack --- if this is a "Reserved" address, then don't consider
        // those a bugcheck
        //
        if (E820Info->E820Entry[i].Type == AcpiAddressRangeReserved) {

            continue;

        }

        //
        // Do some fixups firsts
        //
        if (E820Info->E820Entry[i].Type == AcpiAddressRangeNVS ||
            E820Info->E820Entry[i].Type == AcpiAddressRangeACPI) {

            ASSERT( E820Info->E820Entry[i].Length.HighPart == 0);
            if (E820Info->E820Entry[i].Length.HighPart != 0) {

                ACPIPrint( (
                    ACPI_PRINT_WARNING,
                    "ACPI: E820 Entry #%d (type %d) Length = %016I64x > 32bit\n",
                    i,
                    E820Info->E820Entry[i].Type,
                    E820Info->E820Entry[i].Length.QuadPart
                    ) );
                E820Info->E820Entry[i].Length.HighPart = 0;

            }

        }

        //
        // Is the descriptor beyond what we are looking for?
        //
        if (absMax < (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart) {

            continue;
        }

        //
        // Is it before what we are looking for?
        //
        if (absMin >= (ULONGLONG) (E820Info->E820Entry[i].Base.QuadPart + E820Info->E820Entry[i].Length.QuadPart) ) {

            continue;

        }

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPI: E820 Entry %d (type %I64d) (%I64x-%I64x) overlaps\n"
            "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
            i, E820Info->E820Entry[i].Type,
            E820Info->E820Entry[i].Base.QuadPart,
            (E820Info->E820Entry[i].Base.QuadPart + E820Info->E820Entry[i].Length.QuadPart),
            Index,
            IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart,
            IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart,
            IoList->Descriptors[Index].u.Memory.Length,
            IoList->Descriptors[Index].u.Memory.Alignment
            ) );

        //
        // Is this an NVS area? Are we doing an override of this?
        //
        if ( (AcpiOverrideAttributes & ACPI_OVERRIDE_NVS_CHECK) &&
             (E820Info->E820Entry[i].Type == AcpiAddressRangeNVS) ) {

            if (absMax >= (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart &&
                absMin < (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart) {

                //
                // We can attempt to do a helpfull fixup here
                //
                IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart =
                    (ULONGLONG) E820Info->E820Entry[i].Base.QuadPart - 1;
                IoList->Descriptors[Index].u.Memory.Length = (ULONG)
                    (IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart -
                    IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart + 1);

                ACPIPrint( (
                    ACPI_PRINT_CRITICAL,
                    "ACPI: PCI  Entry %d Changed to\n"
                    "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                    Index,
                    Index,
                    IoList->Descriptors[Index].u.Memory.MinimumAddress.QuadPart,
                    IoList->Descriptors[Index].u.Memory.MaximumAddress.QuadPart,
                    IoList->Descriptors[Index].u.Memory.Length,
                    IoList->Descriptors[Index].u.Memory.Alignment
                    ) );

            }

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPI: E820 Entry %d Overrides PCI Entry\n",
                i
                ) );

            continue;

        }

        //
        // If we got here, then there is an overlap, and we need to bugcheck
        //
        (*BugCheck)++;

    }
}

VOID
ACPIRangeValidatePciResources(
    IN  PDEVICE_EXTENSION               DeviceExtension,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
    )
/*++

Routine Description:

    This routine is called to make sure that the resource that we will
    hand of to PCI have a chance of making the system boot.

    This is what the list will allow
        MEM -   A0000 - DFFFF,
                <Physical Base> - 4GB
        IO  -   Any
        BUS -   Any

    The code checks to make sure that the Length = Max - Min + 1, and that
    the Alignment value is correct

Arguments:

    IoResList -    The list to check

Return Value:

    Nothing

--*/
{
    NTSTATUS                        status;
    PACPI_BIOS_MULTI_NODE           e820Info;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PIO_RESOURCE_LIST               ioList;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    ULONG                           bugCheck = 0;
    ULONG                           i;
    ULONG                           j;
    ULONGLONG                       length;
    ULONG                           size;

    if (IoResList == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeValidPciResources: No IoResList\n"
            ) );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) DeviceExtension,
            2,
            0
            );

    }

    //
    // Read the key for the AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRangeValidatePciResources: Cannot get Information %08lx\n",
            status
            ) );
        return;

    }

    //
    // Crack the structure to get the E820Table entry
    //
    cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
    cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
    e820Info = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc +
        sizeof(CM_PARTIAL_RESOURCE_LIST) );

    //
    // Walk the resource requirements list
    //
    ioList = &(IoResList->List[0]);
    for (i = 0; i < IoResList->AlternativeLists; i++) {

        //
        // Walk the IO list
        //
        for (j = 0; j < ioList->Count; j++) {

            if (ioList->Descriptors[j].Type == CmResourceTypePort ||
                ioList->Descriptors[j].Type == CmResourceTypeMemory) {

                length = ioList->Descriptors[j].u.Port.MaximumAddress.QuadPart -
                    ioList->Descriptors[j].u.Port.MinimumAddress.QuadPart + 1;


                if (length > MAXULONG) {
                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Length > MAXULONG)\n"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        j,
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;                    
                }
                //
                // Does the length match?
                //
                if (length != ioList->Descriptors[j].u.Port.Length) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Length - ( (Max - Min + 1) != Length)\n"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        j,
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;                    

                }

                //
                // Is the alignment non-zero?
                //
                if (ioList->Descriptors[j].u.Port.Alignment == 0) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Alignment"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        j,
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;

                }

                //
                // The alignment cannot intersect with the min value
                //
                if (ioList->Descriptors[j].u.Port.MinimumAddress.LowPart &
                    (ioList->Descriptors[j].u.Port.Alignment - 1) ) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid IO/Mem Alignment - (Min & (Align - 1) )\n"
                        "ACPI: PCI  Entry %d Min:%I64x Max:%I64x Length:%lx Align:%lx\n",
                        j,
                        ioList->Descriptors[j].u.Memory.MinimumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.MaximumAddress.QuadPart,
                        ioList->Descriptors[j].u.Memory.Length,
                        ioList->Descriptors[j].u.Memory.Alignment
                        ) );
                    bugCheck++;

                }

            }

            if (ioList->Descriptors[j].Type == CmResourceTypeBusNumber) {

                length = ioList->Descriptors[j].u.BusNumber.MaxBusNumber -
                    ioList->Descriptors[j].u.BusNumber.MinBusNumber + 1;

                //
                // Does the length match?
                //
                if (length != ioList->Descriptors[j].u.BusNumber.Length) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPI: Invalid BusNumber Length - ( (Max - Min + 1) != Length)\n"
                        "ACPI: PCI  Entry %d Min:%x Max:%x Length:%lx\n",
                        j,
                        ioList->Descriptors[j].u.BusNumber.MinBusNumber,
                        ioList->Descriptors[j].u.BusNumber.MaxBusNumber,
                        ioList->Descriptors[j].u.BusNumber.Length
                        ) );
                    bugCheck++;

                }

            }

            if (ioList->Descriptors[j].Type == CmResourceTypeMemory) {

                ACPIRangeValidatePciMemoryResource(
                    ioList,
                    j,
                    e820Info,
                    &bugCheck
                    );

            }

        }

        //
        // Next list
        //
        size = sizeof(IO_RESOURCE_LIST) +
            ( (ioList->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
        ioList = (PIO_RESOURCE_LIST) ( ( (PUCHAR) ioList ) + size );

    }

    //
    // Do we errors?
    //
    if (bugCheck) {

         ACPIPrint( (
             ACPI_PRINT_CRITICAL,
             "ACPI:\n"
             "ACPI: FATAL BIOS ERROR - Need new BIOS to fix PCI problems\n"
             "ACPI:\n"
             "ACPI: This machine will not boot after 8/26/98!!!!\n"
             ) );

        //
        // No, well, bugcheck
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_PCI_RESOURCE_FAILURE,
            (ULONG_PTR) DeviceExtension,
            (ULONG_PTR) IoResList,
            (ULONG_PTR) e820Info
            );

    }

    //
    // Free the E820 info
    //
    ExFreePool( keyInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\rangesup.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rangesup.h

Abstract:

    This handles the subtraction of a set of CmResList from an IoResList
    IoResList

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    Aug-05-97   - Initial Revision

--*/

#ifndef _RANGESUP_H_
#define _RANGESUP_H_

    NTSTATUS
    ACPIRangeAdd(
        IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *GlobalList,
        IN      PIO_RESOURCE_REQUIREMENTS_LIST  AddList
        );

    NTSTATUS
    ACPIRangeAddCmList(
        IN  OUT PCM_RESOURCE_LIST   *GlobalList,
        IN      PCM_RESOURCE_LIST   AddList
        );

    NTSTATUS
    ACPIRangeFilterPICInterrupt(
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
        );

    NTSTATUS
    ACPIRangeSortCmList(
        IN  PCM_RESOURCE_LIST   CmResList
        );

    NTSTATUS
    ACPIRangeSortIoList(
        IN  PIO_RESOURCE_LIST   IoResList
        );

    NTSTATUS
    ACPIRangeSubtract(
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  *IoResReqList,
        IN  PCM_RESOURCE_LIST               CmResList
        );

    NTSTATUS
    ACPIRangeSubtractIoList(
        IN  PIO_RESOURCE_LIST   IoResList,
        IN  PCM_RESOURCE_LIST   CmResList,
        OUT PIO_RESOURCE_LIST   *Result
        );

    VOID
    ACPIRangeValidatePciMemoryResource(
        IN  PIO_RESOURCE_LIST       IoList,
        IN  ULONG                   Index,
        IN  PACPI_BIOS_MULTI_NODE   E820Info,
        OUT ULONG                   *BugCheck
        );

    VOID
    ACPIRangeValidatePciResources(
        IN  PDEVICE_EXTENSION               DeviceExtension,
        IN  PIO_RESOURCE_REQUIREMENTS_LIST  IoResList
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\reg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    regcd.c

Abstract:

    This contains all of the registry munging code of the NT-specific
    side of the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    31-Mar-96 Initial Revision

--*/

#include "pch.h"

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,OSCloseHandle)
#pragma alloc_text(PAGE,OSCreateHandle)
#pragma alloc_text(PAGE,OSGetRegistryValue)
#pragma alloc_text(PAGE,OSOpenHandle)
#pragma alloc_text(PAGE,OSOpenUnicodeHandle)
#pragma alloc_text(PAGE,OSOpenLargestSubkey)
#pragma alloc_text(PAGE,OSReadAcpiConfigurationData)
#pragma alloc_text(PAGE,OSReadRegValue)
#pragma alloc_text(PAGE,OSWriteRegValue)
#endif

WCHAR   rgzAcpiBiosIdentifier[]                 = L"ACPI BIOS";
WCHAR   rgzAcpiConfigurationDataIdentifier[]    = L"Configuration Data";
WCHAR   rgzAcpiMultiFunctionAdapterIdentifier[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultiFunctionAdapter";
WCHAR   rgzAcpiRegistryIdentifier[]             = L"Identifier";


NTSTATUS
OSCloseHandle(
    HANDLE  Key
    )
{

    //
    // Call the function that will close the handle now...
    //
    PAGED_CODE();
    return ZwClose( Key );

}

NTSTATUS
OSCreateHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    )
/*++

Routine Description:

    Creates a registry key for writting

Arguments:

    KeyName        - Name of the key to create
    ParentHandle    - Handle of parent key
    ChildHandle     - Pointer to where the handle is returned

Return Value:

    Status of create/open

--*/
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSCreateHandle");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, KeyName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSCreateHandle: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;
    }

    //
    // Initialize the OBJECT Attributes to a known value
    //
    RtlZeroMemory( &objectAttributes, sizeof(OBJECT_ATTRIBUTES) );
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeKey,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Create the key here
    //
    *ChildHandle = 0;
    status = ZwCreateKey(
        ChildHandle,
        KEY_WRITE,
        &objectAttributes,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        NULL
        );

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSCreateHandle: ZwCreateKey = %#08lx\n",
            status
            ) );
    }

    return status;

    ACPIDebugExit("OSCreateHandle");
}

NTSTATUS
OSGetRegistryValue(
    IN  HANDLE                          ParentHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *Information
    )
{
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  infoBuffer;
    ULONG                           keyValueLength;
    UNICODE_STRING                  unicodeString;

    PAGED_CODE();
    ACPIDebugEnter("OSGetRegistryValue");

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that we can allocate the
    // proper sized buffer
    //
    status = ZwQueryValueKey(
        ParentHandle,
        &unicodeString,
        KeyValuePartialInformationAlign64,
        (PVOID) NULL,
        0,
        &keyValueLength
        );
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {

        return status;

    }

    //
    // Allocate a buffer large enough to contain the entire key data value
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        ACPI_STRING_POOLTAG
        );
    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Now query the data again and this time it will work
    //
    status = ZwQueryValueKey(
        ParentHandle,
        &unicodeString,
        KeyValuePartialInformationAlign64,
        (PVOID) infoBuffer,
        keyValueLength,
        &keyValueLength
        );
    if (!NT_SUCCESS(status)) {

        ExFreePool( infoBuffer );
        return status;

    }

    //
    // Everything worked - so simply return the address of the allocated
    // structure buffer to the caller, who is now responsible for freeing it
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;

    ACPIDebugExit("OSGetRegistryValue");
}

NTSTATUS
OSOpenHandle(
    PSZ     KeyName,
    HANDLE  ParentHandle,
    PHANDLE ChildHandle
    )
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSOpenHandle");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, KeyName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSOpenHandle: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;

    }

    status = OSOpenUnicodeHandle( &unicodeKey, ParentHandle, ChildHandle );

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );

    return status;

    ACPIDebugExit("OSOpenHandle");
}

NTSTATUS
OSOpenUnicodeHandle(
    PUNICODE_STRING UnicodeKey,
    HANDLE          ParentHandle,
    PHANDLE         ChildHandle
    )
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;

    PAGED_CODE();

    //
    // Initialize the OBJECT Attributes to a known value
    //
    RtlZeroMemory( &objectAttributes, sizeof(OBJECT_ATTRIBUTES) );
    InitializeObjectAttributes(
        &objectAttributes,
        UnicodeKey,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Open the key here
    //
    status = ZwOpenKey(
        ChildHandle,
        KEY_READ,
        &objectAttributes
        );

    if (!NT_SUCCESS(status)) {
        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSOpenUnicodeHandle: ZwOpenKey = %#08lx\n",
            status
            ) );

    }

    return status;
}

NTSTATUS
OSOpenLargestSubkey(
    HANDLE                  ParentHandle,
    PHANDLE                 ChildHandle,
    ULONG                   RomVersion
    )
/*++

Routine Description:

    Open the largest (numerically) subkey under the given parent key.

Arguments:

    ParentHandle    - Handle to the parent key
    ChildHandle     - Pointer to where the handle is returned
    RomVersion      - Minimum version number that is acceptable

Return Value:

    Status of open

--*/
{
    NTSTATUS                status;
    UNICODE_STRING          unicodeName;
    PKEY_BASIC_INFORMATION  keyInformation;
    ULONG                   resultLength;
    ULONG                   i;
    HANDLE                  workingDir = NULL;
    HANDLE                  largestDir = NULL;
    ULONG                   largestRev = 0;
    ULONG                   thisRev = 0;


    PAGED_CODE();
    ACPIDebugEnter( "OSOpenLargestSubkey" );

    keyInformation = ExAllocatePoolWithTag(
        PagedPool,
        512,
        ACPI_MISC_POOLTAG
        );
    if (keyInformation == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Traverse all subkeys
    //
    for (i = 0; ; i++) {

        //
        // Get a subkey
        //
        status = ZwEnumerateKey(
                ParentHandle,
                i,
                KeyBasicInformation,
                keyInformation,
                512,
                &resultLength
                );
        if (!NT_SUCCESS(status)) {          // Fail when no more subkeys
            break;
        }

        //
        // Create a UNICODE_STRING using the counted string passed back to
        // us in the information structure, and convert to an integer.
        //
        unicodeName.Length          = (USHORT) keyInformation->NameLength;
        unicodeName.MaximumLength   = (USHORT) keyInformation->NameLength;
        unicodeName.Buffer          = keyInformation->Name;
        RtlUnicodeStringToInteger(&unicodeName, 16, &thisRev);

        //
        // Save this one if it is the largest
        //
        if ( (workingDir == NULL) || thisRev > largestRev) {

            //
            // We'll just open the target rather than save
            // away the name to open later
            //
            status = OSOpenUnicodeHandle(
                &unicodeName,
                ParentHandle,
                &workingDir
                );
            if ( NT_SUCCESS(status) ) {

                if (largestDir) {

                    OSCloseHandle (largestDir);       // Close previous

                }
                largestDir = workingDir;        // Save handle
                largestRev = thisRev;           // Save version number

           }

        }

    }

    //
    // Done with KeyInformation
    //
    ExFreePool( keyInformation );

    //
    // No subkey found/opened, this is a problem
    //
    if (largestDir == NULL) {

        return ( NT_SUCCESS(status) ? STATUS_UNSUCCESSFUL : status );

    }

    //
    // Use the subkey only if it the revision is equal or greater than the
    // ROM version
    //
    if (largestRev < RomVersion) {

        OSCloseHandle (largestDir);
        return STATUS_REVISION_MISMATCH;

    }

    *ChildHandle = largestDir;       // Return handle to subkey
    return STATUS_SUCCESS;

    ACPIDebugExit( "OSOpenLargestSubkey" );
}

NTSTATUS
OSReadAcpiConfigurationData(
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  *KeyInfo
    )
/*++

Routine Description:

    This very specialized routine looks in the Registry and tries to find
    the information that was written there by ntdetect. It returns a pointer
    to the keyvalue that will then be processed by the caller to find the
    pointer to the RSDT and the E820 memory table

Arguments:

    KeyInfo - Where to store the pointer to the information from the registry

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN         sameId;
    HANDLE          functionHandle;
    HANDLE          multiHandle;
    NTSTATUS        status;
    ULONG           i;
    ULONG           length;
    UNICODE_STRING  biosId;
    UNICODE_STRING  functionId;
    UNICODE_STRING  registryId;
    WCHAR           wbuffer[4];

    ASSERT( KeyInfo != NULL );
    if (KeyInfo == NULL) {

        return STATUS_INVALID_PARAMETER;

    }
    *KeyInfo = NULL;

    //
    // Open the handle for the MultiFunctionAdapter
    //
    RtlInitUnicodeString( &functionId, rgzAcpiMultiFunctionAdapterIdentifier );
    status = OSOpenUnicodeHandle(
        &functionId,
        NULL,
        &multiHandle
        );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSReadAcpiConfigurationData: Cannot open MFA Handle = %08lx\n",
            status
            ) );
        ACPIBreakPoint();
        return status;

    }

    //
    // Initialize the unicode strings we will need shortly
    //
    RtlInitUnicodeString( &biosId, rgzAcpiBiosIdentifier );
    functionId.Buffer = wbuffer;
    functionId.MaximumLength = sizeof(wbuffer);

    //
    // Loop until we run out of children in the MFA node
    //
    for (i = 0; i < 999; i++) {

        //
        // Open the subkey
        //
        RtlIntegerToUnicodeString(i, 10, &functionId );
        status = OSOpenUnicodeHandle(
            &functionId,
            multiHandle,
            &functionHandle
            );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadAcpiConfigurationData: Cannot open MFA %ws = %08lx\n",
                functionId.Buffer,
                status
                ) );
            ACPIBreakPoint();
            OSCloseHandle( multiHandle );
            return status;

        }

        //
        // Check the identifier to see if this is an ACPI BIOS entry
        //
        status = OSGetRegistryValue(
            functionHandle,
            rgzAcpiRegistryIdentifier,
            KeyInfo
            );
        if (!NT_SUCCESS(status)) {

            OSCloseHandle( functionHandle );
            continue;

        }

        //
        // Convert the key information into a unicode string
        //
        registryId.Buffer = (PWSTR) ( (PUCHAR) (*KeyInfo)->Data);
        registryId.MaximumLength = (USHORT) ( (*KeyInfo)->DataLength );
        length = ( (*KeyInfo)->DataLength ) / sizeof(WCHAR);

        //
        // Determine the real length of the ID string
        //
        while (length) {

            if (registryId.Buffer[length-1] == UNICODE_NULL) {

                length--;
                continue;

            }
            break;

        }
        registryId.Length = (USHORT) ( length * sizeof(WCHAR) );

        //
        // Compare the bios string and the registry string
        //
        sameId = RtlEqualUnicodeString( &biosId, &registryId, TRUE );

        //
        // We are done with this information at this point
        //
        ExFreePool( *KeyInfo );

        //
        // Did the two strings match
        //
        if (sameId == FALSE) {

            OSCloseHandle( functionHandle );
            continue;

        }

        //
        // Read the configuration data from the entry
        //
        status = OSGetRegistryValue(
            functionHandle,
            rgzAcpiConfigurationDataIdentifier,
            KeyInfo
            );

        //
        // We are done with the function handle, no matter what
        //
        OSCloseHandle( functionHandle );

        //
        // Did we read what we wanted to?
        //
        if (!NT_SUCCESS(status)) {

            continue;

        }

        //
        // At this point, we don't need the bus handle
        //
        OSCloseHandle( multiHandle );
        return STATUS_SUCCESS;

    }

    //
    // If we got here, then there is nothing to return
    //
    ACPIPrint( (
        ACPI_PRINT_CRITICAL,
        "OSReadAcpiConfigurationData - Could not find entry\n"
        ) );
    ACPIBreakPoint();
    return STATUS_OBJECT_NAME_NOT_FOUND;
}

NTSTATUS
OSReadRegValue(
    PSZ     ValueName,
    HANDLE  ParentHandle,
    PUCHAR  Buffer,
    PULONG  BufferSize
    )
/*++

Routine Description:

    This function is responsible for returning the data in the specified value
    over to the calling function.

Arguments:

    ValueName       - What we are looking for
    ParentHandle    - Our Parent Handle
    Buffer          - Where to store the data
    BufferSize      - Length of the buffer and where to store the # read

Return Value:

    NTSTATUS

--*/
{
    ANSI_STRING                     ansiValue;
    HANDLE                          localHandle = NULL;
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  data = NULL;
    ULONG                           currentLength = 0;
    ULONG                           desiredLength = 0;
    UNICODE_STRING                  unicodeValue;

    PAGED_CODE();
    ACPIDebugEnter( "OSReadRegValue" );

    //
    // First, try to open a handle to the key
    //
    if (ParentHandle == NULL) {

        status= OSOpenHandle(
            ACPI_PARAMETERS_REGISTRY_KEY,
            0,
            &localHandle
            );
        if (!NT_SUCCESS(status) || localHandle == NULL) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSReadRegValue: OSOpenHandle = %#08lx\n",
                status
                ) );
            return (ULONG) status;

        }

    } else {

        localHandle = ParentHandle;

    }

    //
    // Now that we have an open handle, we can convert the value to a
    // unicode string and query it
    //
    RtlInitAnsiString( &ansiValue, ValueName );
    status = RtlAnsiStringToUnicodeString( &unicodeValue, &ansiValue, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSReadRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        if (ParentHandle == NULL) {

            OSCloseHandle( localHandle );

        }
        return status;

    }

    //
    // Next, we need to figure out how much memore we need to hold the
    // entire key
    //
    status = ZwQueryValueKey(
        localHandle,
        &unicodeValue,
        KeyValuePartialInformationAlign64,
        data,
        currentLength,
        &desiredLength
        );

    //
    // We expect this to fail with STATUS_BUFFER_OVERFLOW, so lets make
    // sure that this is what happened
    //
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "OSReadRegValue: ZwQueryValueKey = %#08lx\n",
            status
            ) );

        //
        // Free resources
        //
        RtlFreeUnicodeString( &unicodeValue );
        if (ParentHandle == NULL) {

            OSCloseHandle( localHandle );

        }
        return (NT_SUCCESS(status) ? STATUS_UNSUCCESSFUL : status);

    }

    while (status == STATUS_BUFFER_OVERFLOW ||
           status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Set the new currentLength
        //
        currentLength = desiredLength;

        //
        // Allocate a correctly sized buffer
        //
        data = ExAllocatePoolWithTag(
            PagedPool,
            currentLength,
            ACPI_MISC_POOLTAG
            );
        if (data == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadRegValue: ExAllocatePool(NonPagedPool,%#08lx) failed\n",
                desiredLength
                ) );

            RtlFreeUnicodeString( &unicodeValue );
            if (ParentHandle == NULL) {

                OSCloseHandle( localHandle );

            }
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Actually try to read the entire key now
        //
        status = ZwQueryValueKey(
            localHandle,
            &unicodeValue,
            KeyValuePartialInformationAlign64,
            data,
            currentLength,
            &desiredLength
            );

        //
        // If we don't have enough resources, lets just loop again
        //
        if (status == STATUS_BUFFER_OVERFLOW ||
            status == STATUS_BUFFER_TOO_SMALL) {

            //
            // Make sure to free the old buffer -- otherwise, we could
            // have a major memory leak
            //
            ExFreePool( data );
            continue;

        }

        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "OSReadRegValue: ZwQueryValueKey = %#08lx\n",
                status
                ) );
            RtlFreeUnicodeString( &unicodeValue );
            if (ParentHandle == NULL) {

                OSCloseHandle( localHandle );

            }
            ExFreePool( data );
            return status;

        }

        //
        // Done
        //
        break;

    } // while (status == ...

    //
    // Free Resources
    //
    RtlFreeUnicodeString( &unicodeValue );
    if (ParentHandle == NULL) {

        OSCloseHandle( localHandle );

    }

    //
    // The value read from the registry is a UNICODE Value, however
    // we are asked for an ANSI string. So we just work the conversion
    // backwards
    //
    if ( data->Type == REG_SZ ||
         data->Type == REG_MULTI_SZ) {

        RtlInitUnicodeString( &unicodeValue, (PWSTR) data->Data );
        status = RtlUnicodeStringToAnsiString( &ansiValue, &unicodeValue, TRUE);
        ExFreePool( data );
        if (!NT_SUCCESS(status)) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "OSReadRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
                status
                ) );
            return (ULONG) status;

        }

        //
        // Is our buffer big enough?
        //
        if ( *BufferSize < ansiValue.MaximumLength) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "OSReadRegValue: %#08lx < %#08lx\n",
                *BufferSize,
                ansiValue.MaximumLength
                ) );

            RtlFreeAnsiString( &ansiValue );
            return (ULONG) STATUS_BUFFER_OVERFLOW;

        } else {

            //
            // Set the returned size
            //
            *BufferSize = ansiValue.MaximumLength;

        }

        //
        // Copy the required information
        //
        RtlCopyMemory( Buffer, ansiValue.Buffer, *BufferSize);
        RtlFreeAnsiString( &ansiValue );

    } else if ( *BufferSize >= data->DataLength) {

        //
        // Copy the memory
        //
        RtlCopyMemory( Buffer, data->Data, data->DataLength );
        *BufferSize = data->DataLength;
        ExFreePool( data );

    } else {

        ExFreePool( data );
        return STATUS_BUFFER_OVERFLOW;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;

    ACPIDebugExit( "OSReadRegValue" );

}

NTSTATUS
OSWriteRegValue(
    PSZ     ValueName,
    HANDLE  Handle,
    PVOID   Data,
    ULONG   DataSize
    )
/*++

Routine Description:

    Creates a value item in a registry key, and writes data to it

Arguments:

    ValueName       - Name of the value item to create
    Handle          - Handle of the parent key
    Data            - Raw data to be written to the value
    DataSize        - Size of the data to write

Return Value:

    Status of create/write

--*/
{
    ANSI_STRING         ansiKey;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeKey;

    PAGED_CODE();
    ACPIDebugEnter("OSWriteRegValue");

    //
    // We need to convert the given narrow character string into unicode
    //
    RtlInitAnsiString( &ansiKey, ValueName );
    status = RtlAnsiStringToUnicodeString( &unicodeKey, &ansiKey, TRUE );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "OSWriteRegValue: RtlAnsiStringToUnicodeString = %#08lx\n",
            status
            ) );
        return status;

    }

    //
    // Create the value
    //
    status = ZwSetValueKey(
        Handle,
        &unicodeKey,
        0,
        REG_BINARY,
        Data,
        DataSize
        );

    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_REGISTRY,
            "OSRegWriteValue: ZwSetValueKey = %#08lx\n",
            status
            ) );

    }

    //
    // We no longer care about the Key after this point...
    //
    RtlFreeUnicodeString( &unicodeKey );
    return status;

    ACPIDebugExit("OSRegWriteValue");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\res_bios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_bios

Abstract:

    PnP BIOS/ISA configuration data definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995
    Stephane Plante (splante) Feb 13, 1997

Revision History:

    Feb 13 1997
        Changed and fully adapted to ACPI driver

--*/

#ifndef _RES_BIOS_H_
#define _RES_BIOS_H_

    //
    // Constants
    //
    #define SMALL_RESOURCE_TAG          (UCHAR)(0x00)
    #define LARGE_RESOURCE_TAG          (UCHAR)(0x80)
    #define SMALL_TAG_MASK              0xf8
    #define SMALL_TAG_SIZE_MASK         7

    //
    // Small Resource Tags with length bits stripped off
    //
    #define TAG_IRQ                     0x20
    #define TAG_DMA                     0x28
    #define TAG_START_DEPEND            0x30
    #define TAG_END_DEPEND              0x38
    #define TAG_IO                      0x40
    #define TAG_IO_FIXED                0x48
    #define TAG_VENDOR                  0x70
    #define TAG_END                     0x78

    //
    // Large Resource Tags
    //
    #define TAG_MEMORY                  0x81
    #define TAG_VENDOR_LONG             0x84
    #define TAG_MEMORY32                0x85
    #define TAG_MEMORY32_FIXED          0x86
    #define TAG_DOUBLE_ADDRESS          0x87
    #define TAG_WORD_ADDRESS            0x88
    #define TAG_EXTENDED_IRQ            0x89
    #define TAG_QUAD_ADDRESS            0x8a

    #include "pshpack1.h"

    //
    // PNP ISA Port descriptor definition
    //
    typedef struct _PNP_PORT_DESCRIPTOR_ {
        UCHAR   Tag;                    // 01000111B, small item name = 08, length = 7
        UCHAR   Information;            // bit [0] = 1 device decodes full 16 bit addr
                                        //         = 0 device decodes ISA addr bits[9-0]
        USHORT  MinimumAddress;
        USHORT  MaximumAddress;
        UCHAR   Alignment;              // Increment in 1 byte blocks
        UCHAR   Length;                 // # contiguous Port requested
    } PNP_PORT_DESCRIPTOR, *PPNP_PORT_DESCRIPTOR;

    #define PNP_PORT_DECODE_MASK        0x1
    #define PNP_PORT_10_BIT_DECODE      0x0
    #define PNP_PORT_16_BIT_DECODE      0x1

    //
    // PNP ISA fixed Port descriptor definition
    //
    typedef struct _PNP_FIXED_PORT_DESCRIPTOR_ {
        UCHAR   Tag;                    // 01001011B, small item name = 09, length = 3
        USHORT  MinimumAddress;
        UCHAR   Length;                 // # contiguous Port requested
    } PNP_FIXED_PORT_DESCRIPTOR, *PPNP_FIXED_PORT_DESCRIPTOR;

    //
    // PNP ISA IRQ descriptor definition
    //
    typedef struct _PNP_IRQ_DESCRIPTOR_ {
        UCHAR   Tag;                    // 0010001XB small item name = 4 length = 2/3
        USHORT  IrqMask;                // bit 0 is irq 0
        UCHAR   Information;            // Optional
    } PNP_IRQ_DESCRIPTOR, *PPNP_IRQ_DESCRIPTOR;

    #define PNP_IRQ_LEVEL               0x08
    #define PNP_IRQ_LATCHED             0x01
    #define PNP_IRQ_SHARED              0x10

    //
    // PNP ISA DMA descriptor definition
    //
    typedef struct _PNP_DMA_DESCRIPTOR_ {
        UCHAR   Tag;                    // 00101010B, small item name = 05, length = 2
        UCHAR   ChannelMask;            // bit 0 is channel 0
        UCHAR   Flags;                  // see spec
    } PNP_DMA_DESCRIPTOR, *PPNP_DMA_DESCRIPTOR;

    //
    // Defination and mask for the various flags
    //
    #define PNP_DMA_SIZE_MASK           0x03
    #define PNP_DMA_SIZE_8              0x00
    #define PNP_DMA_SIZE_8_AND_16       0x01
    #define PNP_DMA_SIZE_16             0x02
    #define PNP_DMA_SIZE_RESERVED       0x03

    #define PNP_DMA_BUS_MASTER          0x04

    #define PNP_DMA_TYPE_MASK           0x60
    #define PNP_DMA_TYPE_COMPATIBLE     0x00
    #define PNP_DMA_TYPE_A              0x20
    #define PNP_DMA_TYPE_B              0x40
    #define PNP_DMA_TYPE_F              0x60

    //
    // PNP ISA MEMORY descriptor
    //
    typedef struct _PNP_MEMORY_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000001B, Large item name = 1
        USHORT  Length;                 // Length of the descriptor = 9
        UCHAR   Information;            // See def below
        USHORT  MinimumAddress;         // address bit [8-23]
        USHORT  MaximumAddress;         // address bit [8-23]
        USHORT  Alignment;              // 0x0000 = 64KB
        USHORT  MemorySize;             // In 256 byte blocks
    } PNP_MEMORY_DESCRIPTOR, *PPNP_MEMORY_DESCRIPTOR;

    //
    // PNP ISA MEMORY32 descriptor
    //
    typedef struct _PNP_MEMORY32_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000101B, Large item name = 5
        USHORT  Length;                 // Length of the descriptor = 17
        UCHAR   Information;            // See def below
        ULONG   MinimumAddress;         // 32 bit addr
        ULONG   MaximumAddress;         // 32 bit addr
        ULONG   Alignment;              // 32 bit alignment
        ULONG   MemorySize;             // 32 bit length
    } PNP_MEMORY32_DESCRIPTOR, *PPNP_MEMORY32_DESCRIPTOR;

    //
    // PNP ISA FIXED MEMORY32 descriptor
    //
    typedef struct _PNP_FIXED_MEMORY32_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000110B, Large item name = 6
        USHORT  Length;                 // Length of the descriptor = 9
        UCHAR   Information;            // See def below
        ULONG   BaseAddress;            // 32 bit addr
        ULONG   MemorySize;             // 32 bit length
    } PNP_FIXED_MEMORY32_DESCRIPTOR, *PPNP_FIXED_MEMORY32_DESCRIPTOR;

    #define PNP_MEMORY_READ_ONLY                    0x00
    #define PNP_MEMORY_READ_WRITE                   0x01

    //
    // PNP ISA Resource Source descriptor definition
    //
    typedef struct _PNP_RESOURCE_SOURCE_DESCRIPTOR_ {
        UCHAR   Index;                  // Varies with type of Source
        UCHAR   String[1];              // Start of a variable string
    } PNP_RESOURCE_SOURCE_DESCRIPTOR, *PPNP_RESOURCE_SOURCE_DESCRIPTOR;

    //
    // PNP DWORD Address descriptor definition
    //
    typedef struct _PNP_DWORD_ADDRESS_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10000111B, Large item name= 7
        USHORT  Length;                 // Length of the descriptor = 23 (min)
        UCHAR   RFlag;                  // Resource Flags
        UCHAR   GFlag;                  // General Flags
        UCHAR   TFlag;                  // Type specific flags
        ULONG   Granularity;            // Memory Decode Bits
        ULONG   MinimumAddress;         // Minium Address in range
        ULONG   MaximumAddress;         // Maximum Address in range
        ULONG   TranslationAddress;     // How to translate the address
        ULONG   AddressLength;          // Number of bytes requested
    } PNP_DWORD_ADDRESS_DESCRIPTOR, *PPNP_DWORD_ADDRESS_DESCRIPTOR;

    typedef struct _PNP_QWORD_ADDRESS_DESCRIPTOR_ {
        UCHAR       Tag;                    // 10001010B, Large item name= 10
        USHORT      Length;                 // Length of the descriptor = 23 (min)
        UCHAR       RFlag;                  // Resource Flags
        UCHAR       GFlag;                  // General Flags
        UCHAR       TFlag;                  // Type specific flags
        ULONGLONG   Granularity;            // Memory Decode Bits
        ULONGLONG   MinimumAddress;         // Minium Address in range
        ULONGLONG   MaximumAddress;         // Maximum Address in range
        ULONGLONG   TranslationAddress;     // How to translate the address
        ULONGLONG   AddressLength;          // Number of bytes requested
    } PNP_QWORD_ADDRESS_DESCRIPTOR, *PPNP_QWORD_ADDRESS_DESCRIPTOR;

    typedef struct _PNP_WORD_ADDRESS_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10001000B, Large item name= 8
        USHORT  Length;                 // Length of the descriptor = 13 (min)
        UCHAR   RFlag;                  // Resource Flags
        UCHAR   GFlag;                  // General Flags
        UCHAR   TFlag;                  // Type specific flags
        USHORT  Granularity;            // Memory Decode Bits
        USHORT  MinimumAddress;         // Minium Address in range
        USHORT  MaximumAddress;         // Maximum Address in range
        USHORT  TranslationAddress;     // How to translate the address
        USHORT  AddressLength;          // Number of Bytes requested
    } PNP_WORD_ADDRESS_DESCRIPTOR, *PPNP_WORD_ADDRESS_DESCRIPTOR;

    //
    // These are the valid minimum lengths. We bugcheck if the descriptors
    // are less then these
    //
    #define PNP_ADDRESS_WORD_MINIMUM_LENGTH         0x0D
    #define PNP_ADDRESS_DWORD_MINIMUM_LENGTH        0x17
    #define PNP_ADDRESS_QWORD_MINIMUM_LENGTH        0x2B

    //
    // These are the possible values for RFlag Means
    //
    #define PNP_ADDRESS_MEMORY_TYPE                 0x0
    #define PNP_ADDRESS_IO_TYPE                     0x1
    #define PNP_ADDRESS_BUS_NUMBER_TYPE             0x2

    //
    // The Global flags
    //
    #define PNP_ADDRESS_FLAG_CONSUMED_ONLY          0x1
    #define PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE     0x2
    #define PNP_ADDRESS_FLAG_MINIMUM_FIXED          0x4
    #define PNP_ADDRESS_FLAG_MAXIMUM_FIXED          0x8

    //
    // This mask is used when the RFLags indicates that this is
    // memory address descriptor. The mask is used with the TFlags
    // and the result is compared to the next 4 defines to determine
    // the memory type
    //
    #define PNP_ADDRESS_TYPE_MEMORY_MASK            0x1E
    #define PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE    0x00
    #define PNP_ADDRESS_TYPE_MEMORY_CACHEABLE       0x02
    #define PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE   0x04
    #define PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE    0x06

    //
    // If this bit is set, then this memory is read-write
    //
    #define PNP_ADDRESS_TYPE_MEMORY_READ_WRITE      0x01
    #define PNP_ADDRESS_TYPE_MEMORY_READ_ONLY       0x00

    //
    // These are used when the RFlags indicates that this is an IO descriptor
    //
    #define PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE       0x01
    #define PNP_ADDRESS_TYPE_IO_ISA_RANGE           0x02
    #define PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION  0x20
    #define PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM 0x10

    //
    // PNP ISA Extended IRQ descriptor definition [fixed block]
    //
    typedef struct _PNP_EXTENDED_IRQ_DESCRIPTOR_ {
        UCHAR   Tag;                    // 10001001B, Large item name = 9
        USHORT  Length;                 // Length of the descriptor = 12 (min)
        UCHAR   Flags;                  // Vector Flags
        UCHAR   TableSize;              // How many items in the table
        ULONG   Table[1];               // Table of interrupts
    } PNP_EXTENDED_IRQ_DESCRIPTOR, *PPNP_EXTENDED_IRQ_DESCRIPTOR;

    #define PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY 0x01
    #define PNP_EXTENDED_IRQ_MODE                   0x02
    #define PNP_EXTENDED_IRQ_POLARITY               0x04
    #define PNP_EXTENDED_IRQ_SHARED                 0x08

    #define PNP_VENDOR_SPECIFIC_MASK                0x07

    //
    // These are the flags that can be passed into the Bios to Io engine
    //
    #define PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES    0x01

    #include "poppack.h"

    VOID
    PnpiBiosAddressHandleBusFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandleGlobalFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandleMemoryFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    VOID
    PnpiBiosAddressHandlePortFlags(
        IN  PVOID                   Buffer,
        IN  PIO_RESOURCE_DESCRIPTOR Descriptor
        );

    NTSTATUS
    PnpiBiosAddressToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosAddressDoubleToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosAddressQuadToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosDmaToIoDescriptor(
        IN  PUCHAR              Data,
        IN  UCHAR               Channel,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  USHORT              Count,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosExtendedIrqToIoDescriptor(
        IN  PUCHAR              Data,
        IN  UCHAR               DataIndex,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosIrqToIoDescriptor(
        IN  PUCHAR              Data,
        IN  USHORT              Interrupt,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  USHORT              Count,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosMemoryToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    NTSTATUS
    PnpiBiosPortToIoDescriptor (
        IN  PUCHAR                  Data,
        IN  PIO_RESOURCE_LIST       Array[],
        IN  ULONG                   ArrayIndex,
        IN  ULONG                   Flags
        );


    NTSTATUS
    PnpiBiosPortFixedToIoDescriptor(
        IN  PUCHAR              Data,
        IN  PIO_RESOURCE_LIST   Array[],
        IN  ULONG               ArrayIndex,
        IN  ULONG               Flags
        );

    VOID
    PnpiClearAllocatedMemory(
        IN      PIO_RESOURCE_LIST       ResourceArray[],
        IN      ULONG                   ResourceArraySize
        );

    NTSTATUS
    PnpiGrowResourceDescriptor(
        IN  OUT PIO_RESOURCE_LIST       *ResourceList
        );

    NTSTATUS
    PnpiGrowResourceList(
        IN  OUT PIO_RESOURCE_LIST       *ResourceListArray[],
        IN  OUT ULONG                   *ResourceListArraySize
        );

    NTSTATUS
    PnpiUpdateResourceList(
        IN  OUT PIO_RESOURCE_LIST       *ResourceList,
            OUT PIO_RESOURCE_DESCRIPTOR *ResourceDesc
        );

    NTSTATUS
    PnpBiosResourcesToNtResources (
        IN      PUCHAR                          BiosData,
        IN      ULONG                           Flags,
           OUT PIO_RESOURCE_REQUIREMENTS_LIST  *List
         );

    NTSTATUS
    PnpCmResourceListToIoResourceList(
        IN      PCM_RESOURCE_LIST               CmList,
        IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *IoList
        );

    NTSTATUS
    PnpIoResourceListToCmResourceList(
        IN      PIO_RESOURCE_REQUIREMENTS_LIST  IoList,
        IN  OUT PCM_RESOURCE_LIST               *CmList
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\res_bios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_bios.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995
    Stephane Plante (splante) 20-Nov-1996

Environment:

    Kernel mode only.

Revision History:

    20-Nov-1996:
        Changed to conform with ACPI environment
    22-Jan-1997:
        Changed to remove all traces of original Shie Lin code

--*/

#include "pch.h"

#define RESOURCE_LIST_GROWTH_SIZE   8

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PnpiBiosAddressHandleBusFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandleGlobalFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandleMemoryFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressHandlePortFlags)
#pragma alloc_text(PAGE,PnpiBiosAddressToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosAddressDoubleToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosAddressQuadToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosDmaToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosExtendedIrqToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosIrqToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosMemoryToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosPortFixedToIoDescriptor)
#pragma alloc_text(PAGE,PnpiBiosPortToIoDescriptor)
#pragma alloc_text(PAGE,PnpiClearAllocatedMemory)
#pragma alloc_text(PAGE,PnpiGrowResourceDescriptor)
#pragma alloc_text(PAGE,PnpiGrowResourceList)
#pragma alloc_text(PAGE,PnpiUpdateResourceList)
#pragma alloc_text(PAGE,PnpBiosResourcesToNtResources)
#pragma alloc_text(PAGE,PnpIoResourceListToCmResourceList)
#endif


VOID
PnpiBiosAddressHandleBusFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Bus

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT(Descriptor->u.BusNumber.Length > 0);
}

VOID
PnpiBiosAddressHandleGlobalFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Descriptoin:

    This routine handles all the Global 'generic' flags in an Address Descriptor

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;
    ULONG                           newValue;
    ULONG                           oldValue;
    ULONG                           bound;
    PAGED_CODE();

    //
    // If the resource is marked as being consumed only, then it is
    // exclusive, otherwise, it is shared
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

        Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

    } else {

        Descriptor->ShareDisposition = CmResourceShareShared;

    }

    //
    // Handle the hints that are given to us
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED &&
        buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            oldValue = Descriptor->u.BusNumber.Length;
            newValue = Descriptor->u.BusNumber.Length =
                Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.MinBusNumber + 1;

        } else {

            oldValue = Descriptor->u.Memory.Length;
            newValue = Descriptor->u.Memory.Length =
                Descriptor->u.Memory.MaximumAddress.LowPart -
                Descriptor->u.Memory.MinimumAddress.LowPart + 1;

        }

    } else if (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            bound = Descriptor->u.BusNumber.MaxBusNumber;
            oldValue = Descriptor->u.BusNumber.MinBusNumber;
            newValue = Descriptor->u.BusNumber.MinBusNumber = 1 +
                Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.Length;

        } else {

            bound = Descriptor->u.Memory.MaximumAddress.LowPart;
            oldValue = Descriptor->u.Memory.MinimumAddress.LowPart;
            newValue = Descriptor->u.Memory.MinimumAddress.LowPart = 1 +
                Descriptor->u.Memory.MaximumAddress.LowPart -
                Descriptor->u.Memory.Length;

        }

    } else if (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

        if (Descriptor->Type == CmResourceTypeBusNumber) {

            bound = Descriptor->u.BusNumber.MinBusNumber;
            oldValue = Descriptor->u.BusNumber.MaxBusNumber;
            newValue = Descriptor->u.BusNumber.MaxBusNumber =
                Descriptor->u.BusNumber.MinBusNumber +
                Descriptor->u.BusNumber.Length - 1;

        } else {

            bound = Descriptor->u.Memory.MinimumAddress.LowPart;
            oldValue = Descriptor->u.Memory.MaximumAddress.LowPart;
            newValue = Descriptor->u.Memory.MaximumAddress.LowPart =
                Descriptor->u.Memory.MinimumAddress.LowPart -
                Descriptor->u.Memory.Length - 1;

        }

    }

}

VOID
PnpiBiosAddressHandleMemoryFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Memory

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;

    PAGED_CODE();

    //
    // Set the proper memory type flags
    //
    switch( buffer->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
        case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_CACHEABLE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_COMBINEDWRITE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
            Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
            break;
        case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
            break;
        default:
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "PnpiBiosAddressHandleMemoryFlags: Unknown Memory TFlag "
                "0x%02x\n",
                buffer->TFlag
                ) );
            break;
    }

    //
    // This bit is used to turn on/off write access to memory
    //
    if (buffer->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

        Descriptor->Flags |= CM_RESOURCE_MEMORY_READ_WRITE;

    } else {

        Descriptor->Flags |= CM_RESOURCE_MEMORY_READ_ONLY;
    }

}

VOID
PnpiBiosAddressHandlePortFlags(
    IN  PVOID                   Buffer,
    IN  PIO_RESOURCE_DESCRIPTOR Descriptor
    )
/*++

Routine Description:

    This routine handles the Type specific flags in an Address Descriptor of
    type Port

Arguments:

    Buffer      - The pnp descriptor. Can be a WORD, DWORD, or QWORD descriptor,
                  because the initial memory placement is identical
    Descriptor  - Where to set the flags

Return Value:

    None

--*/
{
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;
    ULONG                           granularity = Descriptor->u.Port.Alignment;

    PAGED_CODE();

    //
    // We can determine if the device uses a positive decode or not
    //
    if ( !(buffer->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE)) {

        Descriptor->Flags |= CM_RESOURCE_PORT_POSITIVE_DECODE;

    }
}

NTSTATUS
PnpiBiosAddressToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer;
    ULONG                           alignment;
    ULONG                           length;
    UCHAR                           decodeLength;
    USHORT                          parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //

    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;

        //
        // Fill in the top 32 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[2] = 0;
    }

    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_WORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length
            ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );

    }

    //
    // Length is the stored within the descriptor record
    //
    length = (ULONG)(buffer->AddressLength);
    alignment = (ULONG) (buffer->Granularity) + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONG   length2;
        ULONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & (ULONG) buffer->Granularity ) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
               ACPI_PRINT_WARNING,
               "ACPI: Granularity does not match fixed attributes\n"
               ) );
            alignment = 1;

        }

    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //
        rangeDescriptor->u.Memory.Alignment = alignment;
        rangeDescriptor->u.Memory.Length = length;
        rangeDescriptor->u.Memory.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Memory.MinimumAddress.HighPart =
            rangeDescriptor->u.Memory.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //


        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Memory.Alignment = 1;
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = alignment;
        rangeDescriptor->u.Port.Length = length;
        rangeDescriptor->u.Port.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Port.MinimumAddress.HighPart =
            rangeDescriptor->u.Port.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypePort;

        
        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }
        

        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        } else {

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.MinBusNumber = (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (buffer->MaximumAddress);
        rangeDescriptor->u.BusNumber.Length = length;

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;
    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosAddressDoubleToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_DWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           decodeLength;
    ULONG                           alignment;
    ULONG                           length;
    ULONG                           parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }
    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //
    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;

        //
        // Fill in the top 32 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[2] = 0;
    }

    //
    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_DWORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressDoubleToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );
    }

    //
    // Length is the stored within the descriptor record
    //
    // Note. AddressLength field and Granularity field are both ULONG
    // values and don't require casting.  beware if you cut and paste
    // this code as other descriptor types don't necessarily match that.
    //
    length =  buffer->AddressLength;
    alignment = buffer->Granularity + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONG   length2;
        ULONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & buffer->Granularity) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Granularity does not match fixed attributes\n"
                ) );
            alignment = 1;

        }

    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //

        rangeDescriptor->u.Memory.Alignment = alignment;
        rangeDescriptor->u.Memory.Length = length;
        rangeDescriptor->u.Memory.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Memory.MinimumAddress.HighPart =
            rangeDescriptor->u.Memory.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //

        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Memory.Alignment = 1;
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = alignment;
        rangeDescriptor->u.Port.Length = length;
        rangeDescriptor->u.Port.MinimumAddress.LowPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.LowPart = childMax;
        rangeDescriptor->u.Port.MinimumAddress.HighPart =
            rangeDescriptor->u.Port.MaximumAddress.HighPart = 0;
        rangeDescriptor->Type = CmResourceTypePort;


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypeMemory;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
                CmResourceTypePort;

        }

        //
        // Fill in the bottom 32 bits of the parent's start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = parentMin;

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.Length = length;
        rangeDescriptor->u.BusNumber.MinBusNumber = (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (buffer->MaximumAddress);

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressDoubleToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;

    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosAddressQuadToIoDescriptor(
    IN  PUCHAR              Data,
    IN  PIO_RESOURCE_LIST   Array[],
    IN  ULONG               ArrayIndex,
    IN  ULONG               Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status;
    PIO_RESOURCE_DESCRIPTOR         rangeDescriptor, privateDescriptor;
    PPNP_QWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           decodeLength;
    ULONGLONG                       alignment;
    ULONGLONG                       length;
    ULONGLONG                       parentMin, childMin, childMax;

    PAGED_CODE();
    ASSERT( Array != NULL );

    buffer = (PPNP_QWORD_ADDRESS_DESCRIPTOR) Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (buffer->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY &&
        buffer->RFlag == PNP_ADDRESS_IO_TYPE &&
        Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the address range is zero, ignore this descriptor.
    // This makes it easier for BIOS writers to set up a template and then
    // whack its length to zero if it doesn't apply.
    //
    if (buffer->AddressLength == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &rangeDescriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is I/O or Memory, then we will need to make enough space for
    // a device private resource too.
    //
    if ((buffer->RFlag == PNP_ADDRESS_MEMORY_TYPE) ||
        (buffer->RFlag == PNP_ADDRESS_IO_TYPE)) {

        status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &privateDescriptor );

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Calling PnpiUpdateResourceList may have invalidated
        // rangeDescriptor.  So make sure it's OK now.
        //

        ASSERT(Array[ArrayIndex]->Count >= 2);
        rangeDescriptor = privateDescriptor - 1;

        privateDescriptor->Type = CmResourceTypeDevicePrivate;

        //
        // Mark this descriptor as containing the start
        // address of the translated resource.
        //
        privateDescriptor->Flags = TRANSLATION_DATA_PARENT_ADDRESS;
    }

    //
    //
    // Do we met the minimum length requirements ?
    //
    if ( buffer->Length < PNP_ADDRESS_QWORD_MINIMUM_LENGTH) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpiBiosAddressQuadToIoDescriptor: Descriptor too small 0x%08lx\n",
            buffer->Length ) );

        //
        // We can go no further
        //
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_PNP_RESOURCE_LIST_BUFFER_TOO_SMALL,
            (ULONG_PTR) buffer,
            buffer->Tag,
            buffer->Length
            );
    }

    //
    // Length is the stored within the descriptor record
    //
    length = (ULONGLONG) (buffer->AddressLength);
    alignment = (ULONGLONG) (buffer->Granularity) + 1;

    //
    // Calculate the bounds of both the parent and child sides of
    // the bridge.
    //
    // The translation field applies to the parent address i.e.
    // the child address is the address in the buffer and the
    // parent address is the addition of the child address and
    // the translation field.
    //

    parentMin = buffer->MinimumAddress + buffer->TranslationAddress;
    childMin = buffer->MinimumAddress;
    childMax = buffer->MaximumAddress;

    //
    // Patch the length based on wether or not the min/max flags are set
    //
    if ( (buffer->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) &&
         (buffer->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) ) {

        ULONGLONG   length2;
        ULONGLONG   alignment2;

        //
        // Calculate the length based on the fact that the min and
        // max addresses are locked down.
        //
        length2 = childMax - childMin + 1;

        //
        // Test #1 --- The length had better be correct
        //
        if (length2 != length) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Length does not match fixed attributes\n"
                ) );
            length = length2;

        }

        //
        // Test #2 --- The granularity had also better be correct
        //
        if ( (childMin & (ULONGLONG) buffer->Granularity) ) {

            //
            // Bummer. Let the world know
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPI: Granularity does not match fixed attributes\n"
                ) );
            alignment = 1;

        }
    }


    if (length > MAXULONG) {
    
        ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPI: descriptor length %I64x exceeds MAXULONG\n",
                length
                ) );            

        if ((!(AcpiOverrideAttributes & ACPI_OVERRIDE_DELL_MAXULONG_BUGCHECK)) || (childMin < MAXULONG)) {
            //
            // We can go no further
            //
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_PNP_RESOURCE_LIST_LENGTH_TOO_LARGE,
                (ULONG_PTR) buffer,
                buffer->Tag,
                (ULONG_PTR)&length
                );
        }
    }

    //
    // Handle the Resource type seperately
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:

        //
        // Set the proper ranges
        //
        rangeDescriptor->u.Memory.Alignment = (ULONG)alignment ;
        rangeDescriptor->u.Memory.Length = (ULONG)length;
        rangeDescriptor->u.Memory.MinimumAddress.QuadPart = childMin;
        rangeDescriptor->u.Memory.MaximumAddress.QuadPart = childMax;
        rangeDescriptor->Type = CmResourceTypeMemory;

        //
        // The child address is the address in the PnP address
        // space descriptor and the child descriptor will inherit
        // the descriptor type from the PnP address space
        // descriptor.
        //


        if (buffer->TFlag & TRANSLATION_MEM_TO_IO) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // changed from Memory to IO.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
               CmResourceTypePort;

        } else {

            //
            // The parent descriptor type will not change.
            //

            privateDescriptor->u.DevicePrivate.Data[0] =
               CmResourceTypeMemory;

        }

        //
        // Fill in all 64 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = (ULONG)(parentMin & 0xffffffff);
        privateDescriptor->u.DevicePrivate.Data[2] = (ULONG)(parentMin >> 32);

        //
        // Handle memory flags
        //
        PnpiBiosAddressHandleMemoryFlags( buffer, rangeDescriptor );
        break;

    case PNP_ADDRESS_IO_TYPE:

        //
        // Any flags that are set here must be handled
        // through the use of device privates
        //
        rangeDescriptor->u.Port.Alignment = (ULONG) alignment;
        rangeDescriptor->u.Port.Length = (ULONG) length;
        rangeDescriptor->u.Port.MinimumAddress.QuadPart = childMin;
        rangeDescriptor->u.Port.MaximumAddress.QuadPart = childMax;
        rangeDescriptor->Type = CmResourceTypePort;


        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_SPARSE_TRANSLATION) {
            privateDescriptor->Flags |= TRANSLATION_RANGE_SPARSE;
        }
        

        if (buffer->TFlag & PNP_ADDRESS_TYPE_IO_TRANSLATE_IO_TO_MEM) {

            //
            // The device private describes the parent. With this
            // flag set, the descriptor type of the parent will
            // change from IO to Memory.
            //

            privateDescriptor->u.DevicePrivate.Data[0] = CmResourceTypeMemory;

        } else {

            //
            // Bridges that implement I/O on the parent side never
            // implement memory on the child side.
            //
            privateDescriptor->u.DevicePrivate.Data[0] = CmResourceTypePort;
        }

        //
        // Fill in all 64 bits of the start address.
        //
        privateDescriptor->u.DevicePrivate.Data[1] = (ULONG)(parentMin & 0xffffffff);
        privateDescriptor->u.DevicePrivate.Data[2] = (ULONG)(parentMin >> 32);

        //
        // Handle port flags
        //
        PnpiBiosAddressHandlePortFlags( buffer, rangeDescriptor );

        //
        // Reset the alignment
        //
        rangeDescriptor->u.Port.Alignment = 1;
        break;

    case PNP_ADDRESS_BUS_NUMBER_TYPE:

        rangeDescriptor->Type = CmResourceTypeBusNumber;
        rangeDescriptor->u.BusNumber.Length = (ULONG) length;
        rangeDescriptor->u.BusNumber.MinBusNumber = (ULONG) (buffer->MinimumAddress);
        rangeDescriptor->u.BusNumber.MaxBusNumber = (ULONG) (buffer->MaximumAddress);

        //
        // Handle busnumber flags
        //
        PnpiBiosAddressHandleBusFlags( buffer, rangeDescriptor );
        break;

    default:

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "PnpiBiosAddressQuadToIoDescriptor: Unknown Type 0x%2x\n",
            buffer->RFlag ) );
        break;

    }

    //
    // Handle global flags
    //
    PnpiBiosAddressHandleGlobalFlags( buffer, rangeDescriptor );
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosDmaToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  UCHAR                   Channel,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  USHORT                  Count,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPNP_DMA_DESCRIPTOR     buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_DMA_DESCRIPTOR)Data;

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Option = (Count ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeDma;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Dma.MinimumChannel = Channel;
    descriptor->u.Dma.MaximumChannel = Channel;

    //
    // Set some information about the type of DMA channel
    //
    switch ( (buffer->Flags & PNP_DMA_SIZE_MASK) ) {
    case PNP_DMA_SIZE_8:
        descriptor->Flags |= CM_RESOURCE_DMA_8;
        break;
    case PNP_DMA_SIZE_8_AND_16:
        descriptor->Flags |= CM_RESOURCE_DMA_8_AND_16;
        break;
    case PNP_DMA_SIZE_16:
        descriptor->Flags |= CM_RESOURCE_DMA_16;
        break;
    case PNP_DMA_SIZE_RESERVED:
    default:
        ASSERT( (buffer->Flags & 0x3) == 0x3);
        descriptor->Flags |= CM_RESOURCE_DMA_32;
        break;

    }
    if ( (buffer->Flags & PNP_DMA_BUS_MASTER) ) {

        descriptor->Flags |= CM_RESOURCE_DMA_BUS_MASTER;

    }
    switch ( (buffer->Flags & PNP_DMA_TYPE_MASK) ) {
    default:
    case PNP_DMA_TYPE_COMPATIBLE:
        break;
    case PNP_DMA_TYPE_A:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_A;
        break;
    case PNP_DMA_TYPE_B:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_B;
        break;
    case PNP_DMA_TYPE_F:
        descriptor->Flags |= CM_RESOURCE_DMA_TYPE_F;
        break;
    }

    return status;
}

NTSTATUS
PnpiBiosExtendedIrqToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  UCHAR                   DataIndex,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR         descriptor;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    buffer;
    PULONG                          polarity;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_EXTENDED_IRQ_DESCRIPTOR)Data;

    //
    // Are we within bounds?
    //
    if (DataIndex >= buffer->TableSize) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Is the vector null? If so, then this is a 'skip' condition
    //
    if (buffer->Table[DataIndex] == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );

    if (!NT_SUCCESS(status)) {
        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Option = (DataIndex ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeInterrupt;
    descriptor->u.Interrupt.MinimumVector =
        descriptor->u.Interrupt.MaximumVector = buffer->Table[DataIndex];

    //
    // Crack the rest of the flags
    //
    descriptor->Flags = 0;
    if ((buffer->Flags & PNP_EXTENDED_IRQ_MODE) == $LVL) {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        //
        // Crack the share flags
        //
        if (buffer->Flags & PNP_EXTENDED_IRQ_SHARED) {

            descriptor->ShareDisposition = CmResourceShareShared;

        } else {

            descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

        }
    }
    if ((buffer->Flags & PNP_EXTENDED_IRQ_MODE) == $EDG) {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;

        //
        // Crack the share flags
        //
        if (buffer->Flags & PNP_EXTENDED_IRQ_SHARED) {

            descriptor->ShareDisposition = CmResourceShareDriverExclusive;

        } else {

            descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

        }
    }

    //
    // Warning!  Awful HACK coming.
    //
    //  The original designer of the flags for CmResourceTypeInterrupt
    //  was bad.  Instead of a bit field, it's an enum.  Which means
    //  that we can't add any flags now.  So I'm stuffing the interrupt
    //  polarity information into an unused DWORD of the IO_RES_LIST.
    //
    polarity = (PULONG)(&descriptor->u.Interrupt.MaximumVector) + 1;

    if ((buffer->Flags & PNP_EXTENDED_IRQ_POLARITY) == $LOW) {

        *polarity = VECTOR_ACTIVE_LOW;

    } else {

        *polarity = VECTOR_ACTIVE_HIGH;

    }

    //
    // To show anything else, we will need to use device private
    // resources
    //
    return status;
}

NTSTATUS
PnpiBiosIrqToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  USHORT                  Interrupt,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  USHORT                  Count,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPNP_IRQ_DESCRIPTOR     buffer;
    PULONG                  polarity;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_IRQ_DESCRIPTOR)Data;

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the resource descriptor
    //
    descriptor->Option = (Count ? IO_RESOURCE_ALTERNATIVE : 0);
    descriptor->Type = CmResourceTypeInterrupt;
    descriptor->u.Interrupt.MinimumVector = Interrupt;
    descriptor->u.Interrupt.MaximumVector = Interrupt;

    //
    // Warning!  Awful HACK coming.
    //
    //  The original designer of the flags for CmResourceTypeInterrupt
    //  was bad.  Instead of a bit field, it's an enum.  Which means
    //  that we can't add any flags now.  So I'm stuffing the interrupt
    //  polarity information into an unused DWORD of the IO_RES_LIST.
    //

    polarity = (PULONG)(&descriptor->u.Interrupt.MaximumVector) + 1;

    if ( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3) {

        //
        // Set the type flags
        //
        descriptor->Flags = 0;
        if (buffer->Information & PNP_IRQ_LATCHED) {

            descriptor->Flags |= CM_RESOURCE_INTERRUPT_LATCHED;
            *polarity = VECTOR_ACTIVE_HIGH;

            //
            // Set the share flags
            //
            if (buffer->Information & PNP_IRQ_SHARED) {

                descriptor->ShareDisposition = CmResourceShareDriverExclusive;

            } else {

                descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            }
        }

        if (buffer->Information & PNP_IRQ_LEVEL) {

            descriptor->Flags |= CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            *polarity = VECTOR_ACTIVE_LOW;

            //
            // Set the share flags
            //
            if (buffer->Information & PNP_IRQ_SHARED) {

                descriptor->ShareDisposition = CmResourceShareShared;

            } else {

                descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            }
        }

    } else {

        descriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    }

    return status;
}

NTSTATUS
PnpiBiosMemoryToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PHYSICAL_ADDRESS        minAddr;
    PHYSICAL_ADDRESS        maxAddr;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    UCHAR                   tag;
    ULONG                   alignment;
    ULONG                   length = 0;
    USHORT                  flags;

    PAGED_CODE();
    ASSERT (Array != NULL);

    //
    // Grab the memory range limits
    //
    tag = ((PPNP_MEMORY_DESCRIPTOR)Data)->Tag;
    minAddr.HighPart = 0;
    maxAddr.HighPart = 0;
    flags = 0;

    //
    // Setup the flags
    //
    if ( ((PPNP_MEMORY_DESCRIPTOR)Data)->Information & PNP_MEMORY_READ_WRITE) {

        flags |= CM_RESOURCE_MEMORY_READ_WRITE;

    } else {

        flags |= CM_RESOURCE_MEMORY_READ_ONLY;

    }

    //
    // Grab the other values from the descriptor
    //
    switch (tag) {
    case TAG_MEMORY: {

        PPNP_MEMORY_DESCRIPTOR  buffer;

        //
        // 24 Bit Memory
        //
        flags |= CM_RESOURCE_MEMORY_24;

        buffer = (PPNP_MEMORY_DESCRIPTOR) Data;
        length = ( (ULONG)(buffer->MemorySize) ) << 8;
        minAddr.LowPart =( (ULONG)(buffer->MinimumAddress) ) << 8;
        maxAddr.LowPart =( ( (ULONG)(buffer->MaximumAddress) ) << 8) + length - 1;
        if ( (alignment = buffer->Alignment) == 0) {

             alignment = 0x10000;

        }
        break;

    }
    case TAG_MEMORY32: {

        PPNP_MEMORY32_DESCRIPTOR    buffer;

        buffer = (PPNP_MEMORY32_DESCRIPTOR) Data;
        length = buffer->MemorySize;
        minAddr.LowPart = buffer->MinimumAddress;
        maxAddr.LowPart = buffer->MaximumAddress +length - 1;
        alignment = buffer->Alignment;
        break;

    }
    case TAG_MEMORY32_FIXED: {

        PPNP_FIXED_MEMORY32_DESCRIPTOR  buffer;

        buffer = (PPNP_FIXED_MEMORY32_DESCRIPTOR) Data;
        length = buffer->MemorySize;
        minAddr.LowPart = buffer->BaseAddress;
        maxAddr.LowPart = minAddr.LowPart + length - 1;
        alignment = 1;
        break;

    }
    default:

         ASSERT( (tag != TAG_MEMORY) && (tag != TAG_MEMORY32) &&
             (tag != TAG_MEMORY32_FIXED) );

    }

    //
    // If the length that we calculated is 0, then we don't have a real
    // descriptor that we should report
    //
    if (length == 0) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in common memory buffers
    //
    descriptor->Type = CmResourceTypeMemory;
    descriptor->Flags = (CM_RESOURCE_PORT_MEMORY | flags);
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

    //
    // Fill in Memory Descriptor
    //
    descriptor->u.Memory.MinimumAddress = minAddr;
    descriptor->u.Memory.MaximumAddress = maxAddr;
    descriptor->u.Memory.Alignment = alignment;
    descriptor->u.Memory.Length = length;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosPortFixedToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR     descriptor;
    PPNP_FIXED_PORT_DESCRIPTOR  buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_FIXED_PORT_DESCRIPTOR)Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the descriptor is 0, then we don't have a descriptor
    // that we can report to the OS
    //
    if (buffer->Length == 0 ) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Type = CmResourceTypePort;
    descriptor->Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Port.Length = (ULONG)buffer->Length;
    descriptor->u.Port.MinimumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff);
    descriptor->u.Port.MaximumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff) +
        (ULONG)buffer->Length - 1;
    descriptor->u.Port.Alignment = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpiBiosPortToIoDescriptor (
    IN  PUCHAR                  Data,
    IN  PIO_RESOURCE_LIST       Array[],
    IN  ULONG                   ArrayIndex,
    IN  ULONG                   Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_RESOURCE_DESCRIPTOR     descriptor;
    PPNP_PORT_DESCRIPTOR        buffer;

    PAGED_CODE();
    ASSERT (Array != NULL);

    buffer = (PPNP_PORT_DESCRIPTOR)Data;

    //
    // Check to see if we are are allowed to use this resource
    //
    if (Flags & PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES) {

        return STATUS_SUCCESS;

    }

    //
    // If the length of the descriptor is 0, then we don't have a descriptor
    // that we can report to the OS
    //
    if (buffer->Length == 0 ) {

        return STATUS_SUCCESS;

    }

    //
    // Ensure that there is enough space within the chosen list to add the
    // resource
    //
    status = PnpiUpdateResourceList( & (Array[ArrayIndex]), &descriptor );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Fill in Io resource descriptor
    //
    descriptor->Type = CmResourceTypePort;
    descriptor->Flags = CM_RESOURCE_PORT_IO;
    descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    descriptor->u.Port.Length = (ULONG)buffer->Length;
    descriptor->u.Port.MinimumAddress.LowPart = (ULONG)buffer->MinimumAddress;
    descriptor->u.Port.MaximumAddress.LowPart = (ULONG)buffer->MaximumAddress +
        buffer->Length - 1;
    descriptor->u.Port.Alignment = (ULONG)buffer->Alignment;

    //
    // Set the flags
    //
    switch (buffer->Information & PNP_PORT_DECODE_MASK) {
    case PNP_PORT_10_BIT_DECODE:
        descriptor->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
        break;
    default:
    case PNP_PORT_16_BIT_DECODE:
        descriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
        break;
    }

    return STATUS_SUCCESS;
}

VOID
PnpiClearAllocatedMemory(
    IN      PIO_RESOURCE_LIST       ResourceArray[],
    IN      ULONG                   ResourceArraySize
    )
/*++

Routine Description:

    This routine frees all the memory that was allocated in building the resource
    lists in the system

Arguments:

    ResourceArray       - Table of PIO_RESOURCE_LIST
    ResourceArraySize   - How large the table is

Return Value:

    VOID

--*/
{
    ULONG   i;

    PAGED_CODE();

    if (ResourceArray == NULL) {

        return;
    }

    for (i = 0; i < ResourceArraySize; i++) {

        if (ResourceArray[i] != NULL) {

            ExFreePool( ResourceArray[i] );
        }
    }

    ExFreePool( ResourceArray );
}

NTSTATUS
PnpiGrowResourceDescriptor(
    IN  OUT PIO_RESOURCE_LIST       *ResourceList
    )
/*++

Routine Description:

    This routine takes a pointer to a Resource list and returns a pointer to resource list
    that contained all the old information, but is now larger


Arguments:

    ResourceList    - ResourceList pointer to change

Return Value:

    NTSTATUS (in case the memory allocation fails)

--*/
{
    NTSTATUS    status;
    ULONG       count = 0;
    ULONG       size = 0;
    ULONG       size2 = 0;

    PAGED_CODE();
    ASSERT( ResourceList != NULL );

    //
    // Are we looking at a null resource list???
    //
    if (*ResourceList == NULL) {

        //
        // Determine how much space is required
        //
        count = 0;
        size = sizeof(IO_RESOURCE_LIST) + ( (count + 7) * sizeof(IO_RESOURCE_DESCRIPTOR) );

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpiGrowResourceDescriptor: Count: %d -> %d, Size: %#08lx\n",
            count, count + RESOURCE_LIST_GROWTH_SIZE, size
            ) );

        //
        // Allocate the ResourceList
        //
        *ResourceList = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );

        //
        // Failed?
        //
        if (*ResourceList == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Init resource list
        //
        RtlZeroMemory( *ResourceList, size );
        (*ResourceList)->Version = 0x01;
        (*ResourceList)->Revision = 0x01;
        (*ResourceList)->Count = 0x00;

        return STATUS_SUCCESS;

    }

    //
    // We already have a resource list, so what we should do is add 8 to the number of
    // existing blocks that we have now, and copy over the old memory
    //
    count = (*ResourceList)->Count ;
    size = sizeof(IO_RESOURCE_LIST) + ( (count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );
    size2 = size + (8 * sizeof(IO_RESOURCE_DESCRIPTOR) );

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpiGrowResourceDescriptor: Count: %d -> %d, Size: %#08lx\n",
        count, count + RESOURCE_LIST_GROWTH_SIZE, size2
        ) );

    //
    // Grow the List
    //
    status = ACPIInternalGrowBuffer( ResourceList, size, size2 );

    return status;
}

NTSTATUS
PnpiGrowResourceList(
    IN  OUT PIO_RESOURCE_LIST       *ResourceListArray[],
    IN  OUT ULONG                   *ResourceListArraySize
    )
/*++

Routine Description:

    This function is responsible for growing the array of resource lists

Arguments:

    ResourceListArray - An array of pointers to IO_RESOURCE_LISTs
    ResourceListSize  - The current size of the array

Return Value:

    NTSTATUS (in case memory allocation fails)

--*/
{
    NTSTATUS    status;
    ULONG       count;
    ULONG       size;
    ULONG       size2;

    PAGED_CODE();
    ASSERT( ResourceListArray != NULL);

    //
    // Its always a special case if the table is null
    //
    if ( *ResourceListArray == NULL || *ResourceListArraySize == 0) {

        count = 0;
        size = (count + RESOURCE_LIST_GROWTH_SIZE ) * sizeof(PIO_RESOURCE_LIST);

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpiGrowResourceList: Count: %d -> %d, Size: %#08lx\n",
            count, count + RESOURCE_LIST_GROWTH_SIZE, size
            ) );

        //
        // Allocate the ResourceListArray
        //
        *ResourceListArray = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );

        //
        // Failed?
        //
        if (*ResourceListArray == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Increment the size
        //
        *ResourceListArraySize = count + RESOURCE_LIST_GROWTH_SIZE;
        RtlZeroMemory( *ResourceListArray, size );

        return STATUS_SUCCESS;
    }

    count = *ResourceListArraySize;
    size  = count * sizeof(PIO_RESOURCE_LIST);
    size2 = size + (RESOURCE_LIST_GROWTH_SIZE * sizeof(PIO_RESOURCE_LIST));

    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpiGrowResourceList: Count: %d -> %d, Size: %#08lx\n",
        count, count + RESOURCE_LIST_GROWTH_SIZE, size2
        ) );

    status = ACPIInternalGrowBuffer( (PVOID *) ResourceListArray, size, size2 );
    if (!NT_SUCCESS(status)) {

        *ResourceListArraySize = 0;

    } else {

        *ResourceListArraySize = (count + RESOURCE_LIST_GROWTH_SIZE);
    }

    return status;
}

NTSTATUS
PnpiUpdateResourceList(
    IN  OUT PIO_RESOURCE_LIST       *ResourceList,
        OUT PIO_RESOURCE_DESCRIPTOR *ResourceDesc
    )
/*++

Routine Description:

    This function is called when a new resource is about to be added. This routine
    ensures that enough space is present within the list, and gives a pointer to the
    location of the Resource Descriptor where the list should be added...

Arguments:

    ResourceList    - Pointer to list to check
    ResourceDesc    - Location to store pointer to descriptor

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT( ResourceList != NULL);

    if ( *ResourceList == NULL ||
         (*ResourceList)->Count % RESOURCE_LIST_GROWTH_SIZE == 0) {

        //
        // Oops, not enough space for the next descriptor
        //
        status = PnpiGrowResourceDescriptor( ResourceList );

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Find the next descriptor to use
    //
    *ResourceDesc = & ( (*ResourceList)->Descriptors[ (*ResourceList)->Count ] );

    //
    // Update the count of in-use descriptors
    //
    (*ResourceList)->Count += 1;

    return status;
}

NTSTATUS
PnpBiosResourcesToNtResources(
    IN      PUCHAR                          Data,
    IN      ULONG                           Flags,
        OUT PIO_RESOURCE_REQUIREMENTS_LIST  *List
    )
/*++

Routine Description:

    This routine parses the Bios resource list and generates an NT resource list.
    The returned NT resource list must be freed by the caller

Arguments:

    Data    - Pointer to PNP ISA Configuration Information
    Flags   - Options to use when parsing the data
    List    - Pointer to NT Configuration Information

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS            status;
    PIO_RESOURCE_LIST   *Array = NULL;
    PUCHAR              buffer;
    UCHAR               tagName;
    USHORT              increment;
    ULONG               ArraySize = 0;
    ULONG               ArrayIndex = 0;
    ULONG               ArrayAlternateIndex = 0;
    ULONG               size;
    ULONG               size2;
    ULONG               ResourceCount = 0;
    ULONG               VendorTagCount = 0;
    
    PAGED_CODE();
    ASSERT( Data != NULL );

    //
    // First we need to build the pointer list
    //
    status = PnpiGrowResourceList( &Array, &ArraySize );

    if (!NT_SUCCESS(status)) {
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: PnpiGrowResourceList = 0x%8lx\n",
            status ) );

        return status;
    }

    //
    // Setup initial variables
    //
    buffer = Data;
    tagName = *buffer;

    //
    // Look through all the descriptors.
    //
    while (TRUE) {

        //
        // Determine the size of the PNP resource descriptor
        //
        if ( !(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // Small Tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: small = %#02lx incr = 0x%2lx\n",
                tagName, increment ) );

        } else {

            //
            // Large Tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: large = %#02lx incr = 0x%2lx\n",
                tagName, increment
                ) );
        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_END\n"
                ) );
            break;
        }

        ResourceCount++;

        switch(tagName) {
        case TAG_IRQ: {

            USHORT  mask = ( (PPNP_IRQ_DESCRIPTOR)buffer)->IrqMask;
            USHORT  interrupt = 0;
            USHORT  count = 0;

            //
            // Find all of interrupts to set
            //
            for ( ;mask && NT_SUCCESS(status); interrupt++, mask >>= 1) {

                if (mask & 1) {

                    status = PnpiBiosIrqToIoDescriptor(
                        buffer,
                        interrupt,
                        Array,
                        ArrayIndex,
                        count,
                        Flags
                        );

                    count++;
                }
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IRQ(count: 0x%2lx) "
                "= 0x%8lx\n",
                count, status
                ) );

            break;
            }

        case TAG_EXTENDED_IRQ: {

            UCHAR   tableSize =
                ( (PPNP_EXTENDED_IRQ_DESCRIPTOR)buffer)->TableSize;
            UCHAR   irqCount = 0;

            //
            // For each of the interrupts to set, do
            //
            for ( ;irqCount < tableSize && NT_SUCCESS(status); irqCount++) {

                status = PnpiBiosExtendedIrqToIoDescriptor(
                    buffer,
                    irqCount,
                    Array,
                    ArrayIndex,
                    Flags
                    );
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_EXTENDED_IRQ(count: "
                "0x%2lx) = 0x%8lx\n",
                irqCount, status
                ) );

            break;
            }

        case TAG_DMA: {

            UCHAR   mask = ( (PPNP_DMA_DESCRIPTOR)buffer)->ChannelMask;
            UCHAR   channel = 0;
            USHORT  count = 0;

            //
            // Find all the dma's to set
            //
            for ( ;mask && NT_SUCCESS(status); channel++, mask >>= 1 ) {

                if (mask & 1) {

                    status = PnpiBiosDmaToIoDescriptor(
                        buffer,
                        channel,
                        Array,
                        ArrayIndex,
                        count,
                        Flags
                        );

                    count++;
                }
            }

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_DMA(count: 0x%2lx) "
                "= 0x%8lx\n",
                count, status
                ) );

            break;
            }

        case TAG_START_DEPEND: {

            //
            // Increment the alternate list index
            //
            ArrayAlternateIndex++;

            //
            // This is now our current index
            //
            ArrayIndex = ArrayAlternateIndex;

            //
            // We need to use DevicePrivate data to give the
            // arbiter a helping hand
            //

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_START_DEPEND(Index: "
                "0x%2lx)\n",
                ArrayIndex
                ) );

            //
            // Make sure that there is a pointer allocated for this index
            //
            if (ArrayIndex == ArraySize) {

                //
                // Not enough space
                //
                status = PnpiGrowResourceList( &Array, &ArraySize );
            }

            break;
            }

        case TAG_END_DEPEND: {

            //
            // Debug Info
            //
            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_END_DEPEND(Index: "
                "0x%2lx)\n",
                ArrayIndex
                ) );

            //
            // All we have to do is go back to our original index
            //
            ArrayIndex = 0;
            break;
            }

        case TAG_IO: {

            status = PnpiBiosPortToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IO = 0x%8lx\n",
                status
                ) );

            break;
            }

        case TAG_IO_FIXED: {

            status = PnpiBiosPortFixedToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_IO_FIXED = 0x%8lx\n",
                status
                ) );

            break;
            }

        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED: {

            status = PnpiBiosMemoryToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_MEMORY = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_WORD_ADDRESS: {

            status = PnpiBiosAddressToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_WORD_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_DOUBLE_ADDRESS: {

            status = PnpiBiosAddressDoubleToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_DOUBLE_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_QUAD_ADDRESS: {

            status = PnpiBiosAddressQuadToIoDescriptor(
                buffer,
                Array,
                ArrayIndex,
                Flags
                );

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpBiosResourcesToNtResources: TAG_QUAD_ADDRESS = 0x%8lx\n",
                status
                ) );
            break;
            }

        case TAG_VENDOR:
        case TAG_VENDOR_LONG:{
            //
            // Ignore this tag.  Skip over it.
            //
            VendorTagCount++;
            status = STATUS_SUCCESS;
            break;
            }
        
        default: {

            //
            // Unknown tag. Skip it
            //
            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "PnpBiosResourceToNtResources: TAG_UNKNOWN(tagName:"
                " 0x%2lx)\n",
                tagName ) );
            break;
            }
        } // switch

        //
        // Did we fail?
        //
        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // Move to the next descriptor
        //
        buffer += increment;
        tagName = *buffer;

    }


    //
    // This is a special case check for cases where a vendor has just a 
    // Vendor short or vendor long defined in the _CRS. In this case we 
    // dont need to allocate any resources and bail ... 
    //
    if (NT_SUCCESS(status) && (ResourceCount) && (VendorTagCount == ResourceCount)) {

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpBiosResourcesToNtResources: This _CRS contains vendor defined tags only. No resources will be allocated.\n"
            ) );

        //
        // Clean up any allocated memory and return
        //
        PnpiClearAllocatedMemory( Array, ArraySize );
        *List = NULL;
        
        return status;
    }

    //
    // At this point, if everything is okay, we should be looking at the end tag
    // If not, we will have a failed status value to account for it...
    //
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: Failed on Tag - %d Status %#08lx\n",
            tagName, status
            ) );

        //
        // Clean up any allocated memory and return
        //
        PnpiClearAllocatedMemory( Array, ArraySize );

        return status;
    }

    //
    // Now, we must figure out how many bytes to allocate for the lists...
    // We can start out by determining the size of just the REQUIREMENT_LIST
    //
    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) - sizeof(IO_RESOURCE_LIST);

    //
    // How much many common resources are there?
    //
    if (Array[0] != NULL) {

        size2 = Array[0]->Count;

    } else {

        size2 = 0;
    }

    //
    // This is tricky. The first array is the list of resources that are
    // common to *all* lists, so we don't begin by counting it. Rather, we
    // figure out how much the other lists will take up
    //
    for (ArrayIndex = 1; ArrayIndex <= ArrayAlternateIndex; ArrayIndex++) {

         if (Array[ArrayIndex] == NULL) {

             ACPIPrint( (
                 ACPI_PRINT_CRITICAL,
                 "PnpBiosResourcesToNtResources: Bad List at Array[%d]\n",
                 ArrayIndex
                 ) );
             PnpiClearAllocatedMemory( Array, ArraySize );
             *List = NULL;
             return STATUS_UNSUCCESSFUL;

         }

        //
        // Just to make sure that we don't get tricked into adding an alternate list
        // if we do not need to...
        //
        if ( (Array[ArrayIndex])->Count == 0) {

            continue;
        }

        //
        // How much space does the current Resource List take?
        //
        size += sizeof(IO_RESOURCE_LIST) +
            ( (Array[ArrayIndex])->Count - 1 + size2) * sizeof(IO_RESOURCE_DESCRIPTOR);

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpBiosResourcesToNtResources: Index %d Size %#08lx\n",
            ArrayIndex, size
            ) );

    } // for

    //
    // This is to account for the case where there are no dependent resources...
    //
    if (ArrayAlternateIndex == 0) {

         if (Array[0] == NULL || Array[0]->Count == 0) {

             ACPIPrint( (
                 ACPI_PRINT_WARNING,
                 "PnpBiosResourcesToNtResources: No Resources to Report\n"
                 ) );

             PnpiClearAllocatedMemory( Array, ArraySize );
             *List = NULL;

             return STATUS_UNSUCCESSFUL;
         }

        size += ( (Array[0])->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) +
            sizeof(IO_RESOURCE_LIST);
    }

    //
    // This is a redundant check. If we don't have at least enough information
    // to create a single list, then we should not be returning anything. Period.
    //
    if (size < sizeof(IO_RESOURCE_REQUIREMENTS_LIST) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourcesToNtResources: Resources smaller than a List\n"
            ) );

        PnpiClearAllocatedMemory( Array, ArraySize );
        *List = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate the required amount of space
    //
    (*List) = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "PnpBiosResourceToNtResources: ResourceRequirementsList = %#08lx (%#08lx)\n",
        (*List), size ) );

    if (*List == NULL) {

        //
        // Oops...
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "PnpBiosResourceToNtResources: Could not allocate memory for "
            "ResourceRequirementList\n" ) );


        //
        // Clean up any allocated memory and return
        //
        PnpiClearAllocatedMemory( Array, ArraySize );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( (*List), size );

    //
    // Find the first place to store the information
    //
    (*List)->InterfaceType = PNPBus;
    (*List)->BusNumber = 0;
    (*List)->ListSize = size;
    buffer = (PUCHAR) &( (*List)->List[0]);
    for (ArrayIndex = 1; ArrayIndex <= ArrayAlternateIndex; ArrayIndex++) {

        //
        // Just to make sure that we don't get tricked into adding an alternate list
        // if we do not need to...
        //
        if ( (Array[ArrayIndex])->Count == 0) {

            continue;
        }

        //
        // How much space does the current Resource List take?
        //
        size = ( ( (Array[ArrayIndex])->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) +
            sizeof(IO_RESOURCE_LIST) );

        //
        // This is tricky. Using the sideeffect of if I upgrade the count field
        // in the dependent resource descriptor, then when I copy it over, it will
        // be correct, I avoid issues with trying to message with pointers at a
        // later point in time.
        //
        (Array[ArrayIndex])->Count += size2;

        ACPIPrint( (
            ACPI_PRINT_RESOURCES_2,
            "PnpBiosResourcesToNtResources:  %d@%#08lx Size %#04lx Items %#04x\n",
            ArrayIndex, buffer, size, (Array[ArrayIndex])->Count
            ) );

        //
        // Copy the resources
        //
        RtlCopyMemory(buffer, Array[ArrayIndex], size );
        buffer += size;

        //
        // Now we account for the common resources
        //
        if (size2) {

            RtlCopyMemory(
                buffer,
                &( (Array[0])->Descriptors[0]),
                size2 * sizeof(IO_RESOURCE_DESCRIPTOR)
                );
            buffer += (size2 * sizeof(IO_RESOURCE_DESCRIPTOR));
        }

        //
        // Update the number of alternate lists in the ResourceRequirement List
        //
        (*List)->AlternativeLists += 1;
    }

    //
    // This check is required because we might just have a common list, with
    // no dependent resources...
    //
    if (ArrayAlternateIndex == 0) {

        ASSERT( size2 != 0 );

        size = (size2 - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) + sizeof(IO_RESOURCE_LIST);
        RtlCopyMemory(buffer,Array[0],size);
        (*List)->AlternativeLists += 1;
    }

    //
    // Clean up the copies
    //
    PnpiClearAllocatedMemory( Array, ArraySize );

    return STATUS_SUCCESS;
}

NTSTATUS
PnpIoResourceListToCmResourceList(
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  IoList,
    IN  OUT PCM_RESOURCE_LIST               *CmList
    )
/*++

Routine Description:

    This routine takes an IO_RESOURCE_REQUIREMENTS_LIST and generates a
    CM_RESOURCE_LIST

Arguments:

    IoList  - The list to convert
    CmList  - Points to pointer of where to store the new list. The caller is
            responsible for freeing this

Return Value:

    NTSTATUS

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PCM_RESOURCE_LIST               cmList;
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    PIO_RESOURCE_LIST               ioResList;
    ULONG                           size;
    ULONG                           count;

    PAGED_CODE();

    *CmList = NULL;

    //
    // As a trivial check, if there are no lists, than we can simply return
    //
    if (IoList == NULL || IoList->List == NULL || IoList->List[0].Count == 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // The first step is to allocate the correct number of bytes for the CmList. The
    // first simplifying assumptions that can be me is that the IoList will not have
    // more than one alternative.
    //
    size = (IoList->List[0].Count - 1) * sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) +
        sizeof( CM_RESOURCE_LIST );

    //
    // Now, allocate this block of memory
    //
    cmList = ExAllocatePoolWithTag( PagedPool, size, ACPI_RESOURCE_POOLTAG );
    if (cmList == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( cmList, size );

    //
    // Setup the initial values for the CmList
    //
    ioResList = &(IoList->List[0]);
    cmList->Count = 1;
    cmList->List[0].InterfaceType = IoList->InterfaceType;
    cmList->List[0].BusNumber = IoList->BusNumber;
    cmPartialList = &(cmList->List[0].PartialResourceList);
    cmPartialList->Version = 1;
    cmPartialList->Revision = 1;
    cmPartialList->Count = ioResList->Count;

    for (count = 0; count < ioResList->Count; count++) {

        //
        // Grab the current CmDescriptor and IoDescriptor
        //
        cmDesc = &(cmPartialList->PartialDescriptors[count]);
        ioDesc = &(ioResList->Descriptors[count]);

        //
        // Now, copy the information from one descriptor to another
        //
        cmDesc->Type = ioDesc->Type;
        cmDesc->ShareDisposition = ioDesc->ShareDisposition;
        cmDesc->Flags = ioDesc->Flags;
        switch (cmDesc->Type) {
        case CmResourceTypeBusNumber:
            cmDesc->u.BusNumber.Start = ioDesc->u.BusNumber.MinBusNumber;
            cmDesc->u.BusNumber.Length = ioDesc->u.BusNumber.Length;
            break;
        case CmResourceTypePort:
            cmDesc->u.Port.Length = ioDesc->u.Port.Length;
            cmDesc->u.Port.Start = ioDesc->u.Port.MinimumAddress;
            break;
        case CmResourceTypeInterrupt:
            cmDesc->u.Interrupt.Level =
            cmDesc->u.Interrupt.Vector = ioDesc->u.Interrupt.MinimumVector;
            cmDesc->u.Interrupt.Affinity = (ULONG)-1;
            break;
        case CmResourceTypeMemory:
            cmDesc->u.Memory.Length = ioDesc->u.Memory.Length;
            cmDesc->u.Memory.Start = ioDesc->u.Memory.MinimumAddress;
            break;
        case CmResourceTypeDma:
            cmDesc->u.Dma.Channel = ioDesc->u.Dma.MinimumChannel;
            cmDesc->u.Dma.Port = 0;
            break;
        default:
        case CmResourceTypeDevicePrivate:
            cmDesc->u.DevicePrivate.Data[0] = ioDesc->u.DevicePrivate.Data[0];
            cmDesc->u.DevicePrivate.Data[1] = ioDesc->u.DevicePrivate.Data[1];
            cmDesc->u.DevicePrivate.Data[2] = ioDesc->u.DevicePrivate.Data[2];
            break;
        }
    }

    //
    // Let the caller know he has a good list
    //
    *CmList = cmList;

    return STATUS_SUCCESS;
}

NTSTATUS
PnpCmResourceListToIoResourceList(
    IN      PCM_RESOURCE_LIST               CmList,
    IN  OUT PIO_RESOURCE_REQUIREMENTS_LIST  *IoList
    )
/*++

Routine Description:

    This routine generates an IO_RESOURCE_REQUIREMENTS_LIST and from a
    CM_RESOURCE_LIST

Arguments:

    CmList  - The list to convert
    IoList  - Points to pointer of where to store the new list. The caller is
            responsible for freeing this

Return Value:

    NTSTATUS

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PIO_RESOURCE_DESCRIPTOR         ioDesc;
    PIO_RESOURCE_LIST               ioResList;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList;
    ULONG                           size;
    ULONG                           count;

    PAGED_CODE();

    *IoList = NULL;

    //
    // As a trivial check, if there are no lists, than we can simply return
    //
    if (CmList == NULL || CmList->List == NULL ||
        CmList->List[0].PartialResourceList.Count == 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Grab the partial list to make walking it easier
    //
    cmPartialList = &(CmList->List[0].PartialResourceList);


    //
    // How much space do we need for the IO list?
    //
    size = (cmPartialList->Count - 1) * sizeof( IO_RESOURCE_DESCRIPTOR ) +
        sizeof( IO_RESOURCE_REQUIREMENTS_LIST );

    //
    // Now, allocate this block of memory
    //
    ioList = ExAllocatePoolWithTag( NonPagedPool, size, ACPI_RESOURCE_POOLTAG );

    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ioList, size );

    //
    // Setup the initial values for the IoList
    //
    ioList->ListSize = size;
    ioList->AlternativeLists = 1;
    ioList->InterfaceType = CmList->List[0].InterfaceType;
    ioList->BusNumber = CmList->List[0].BusNumber;

    //
    // Setup the initialize value for the ioResList
    //
    ioResList = &(ioList->List[0]);
    ioResList->Count = cmPartialList->Count;
    ioResList->Version = cmPartialList->Version;
    ioResList->Revision = cmPartialList->Revision;

    //
    // Loop for all the elements in the partial list
    //
    for (count = 0; count < ioResList->Count; count++) {

        //
        // Grab the current CmDescriptor and IoDescriptor
        //
        cmDesc = &(cmPartialList->PartialDescriptors[count]);
        ioDesc = &(ioResList->Descriptors[count]);

        //
        // Now, copy the information from one descriptor to another
        //
        ioDesc->Type                = cmDesc->Type;
        ioDesc->ShareDisposition    = cmDesc->ShareDisposition;
        ioDesc->Flags               = cmDesc->Flags;
        switch (cmDesc->Type) {
        case CmResourceTypeMemory:
        case CmResourceTypePort:
            ioDesc->u.Port.Length           = cmDesc->u.Port.Length;
            ioDesc->u.Port.MinimumAddress   = cmDesc->u.Port.Start;
            ioDesc->u.Port.MaximumAddress   = cmDesc->u.Port.Start;
            ioDesc->u.Port.MaximumAddress.LowPart += cmDesc->u.Port.Length - 1;
            ioDesc->u.Port.Alignment        = 1;
            break;
        case CmResourceTypeInterrupt:
            ioDesc->u.Interrupt.MinimumVector = cmDesc->u.Interrupt.Vector;
            ioDesc->u.Interrupt.MaximumVector = cmDesc->u.Interrupt.Vector;
            break;
        case CmResourceTypeDma:
            ioDesc->u.Dma.MinimumChannel = cmDesc->u.Dma.Channel;
            ioDesc->u.Dma.MaximumChannel = cmDesc->u.Dma.Channel;
            break;
        case CmResourceTypeBusNumber:
            ioDesc->u.BusNumber.MinBusNumber = cmDesc->u.BusNumber.Start;
            ioDesc->u.BusNumber.MaxBusNumber = cmDesc->u.BusNumber.Length +
                cmDesc->u.BusNumber.Start;
            ioDesc->u.BusNumber.Length = cmDesc->u.BusNumber.Length;
            break;
        default:
        case CmResourceTypeDevicePrivate:
            ioDesc->u.DevicePrivate.Data[0] = cmDesc->u.DevicePrivate.Data[0];
            ioDesc->u.DevicePrivate.Data[1] = cmDesc->u.DevicePrivate.Data[1];
            ioDesc->u.DevicePrivate.Data[2] = cmDesc->u.DevicePrivate.Data[2];
            break;
        }
    }

    *IoList = ioList;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\res_cm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    res_cm.h

Abstract:

    Converts from NT to Pnp resources

Author:

    Stephane Plante (splante) Feb 13, 1997

Revision History:

--*/

#ifndef _RES_CM_H_
#define _RES_CM_H_

    NTSTATUS
    PnpiCmResourceToBiosAddress(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosAddressDouble(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosDma(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosExtendedIrq(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIoFixedPort(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIoPort(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosIrq(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory32(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpiCmResourceToBiosMemory32Fixed(
        IN  PUCHAR              Buffer,
        IN  PCM_RESOURCE_LIST   List
        );

    BOOLEAN
    PnpiCmResourceValidEmptyList(
        IN  PCM_RESOURCE_LIST   List
        );

    NTSTATUS
    PnpCmResourcesToBiosResources(
        IN  PCM_RESOURCE_LIST   List,
        IN  PUCHAR              Data
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\root.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    root.c

Abstract:

    This module contains the root FDO handler for the NT Driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July-09-97  Added support to Unify QueryDeviceRelations from filter.c

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIRootIrpCancelRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpQueryBusRelations)
#pragma alloc_text(PAGE, ACPIRootIrpQueryCapabilities)
#pragma alloc_text(PAGE, ACPIRootIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, ACPIRootIrpQueryRemoveOrStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpStartDevice)
#pragma alloc_text(PAGE, ACPIRootIrpStopDevice)
#pragma alloc_text(PAGE, ACPIRootIrpQueryInterface)
#endif


NTSTATUS
ACPIRootIrpCancelRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions the device from the inactive to the
    started state

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Where we allowed to stop the device? If so, then undo whatever it
    // was we did, otherwise let the world know about the cancel
    //

    if (!(deviceExtension->Flags & DEV_CAP_NO_STOP) ) {

        //
        // Check to see if we have placed this device in the inactive state
        //
        if (deviceExtension->DeviceState == Inactive) {

            //
            // Mark the device state to its previous state
            //
            deviceExtension->DeviceState = deviceExtension->PreviousState;

        }


    }

    //
    // We are successfull
    //
    Irp->IoStatus.Status = status;

    //
    // Pass the Irp Along
    //
    Irp->IoStatus.Status = STATUS_SUCCESS ;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpCompleteRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This is the routine that is called when one of the IRPS that was
    noticed by ACPIRootIrp* and was judged to be an IRP that we need
    to examine later on...

Arguments:

    DeviceObject    - A pointer to the Filter Object
    Irp             - A pointer to the completed request
    Context         - Whatever Irp-dependent information we need to know

Return Value:

    NTSTATUS
--*/
{
    PKEVENT             event           = (PKEVENT) Context;
#if DBG
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    if (deviceExtension != NULL) {

        //
        // Let the world know what we just got...
        //
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(%#08lx): %s = %#08lx (Complete)\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
            Irp->IoStatus.Status
            ) );

    }
#endif

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ACPIRootIrpQueryBusRelations(
    IN  PDEVICE_OBJECT    DeviceObject,
    IN  PIRP              Irp,
    OUT PDEVICE_RELATIONS *PdeviceRelations
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Root or Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            detectStatus;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PNSOBJ              acpiObject      = NULL;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // lets look at the ACPIObject that we have and we can see
    // if it is valid
    //
    acpiObject = deviceExtension->AcpiObject;
    ASSERT( acpiObject != NULL );
    if (acpiObject == NULL) {

       ACPIDevPrint( (
           ACPI_PRINT_WARNING,
           deviceExtension,
           "(%#08lx): %s - Invalid ACPI Object %#08lx\n",
           Irp,
           ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
           acpiObject
           ) );

       //
       // Fail the IRP.
       //
       return STATUS_INVALID_PARAMETER;
    }

    //
    // Detect which PDOs are missing
    //
    detectStatus = ACPIDetectPdoDevices(
        DeviceObject,
        PdeviceRelations
        );

    //
    // If something went well along the way, yell a bit
    //
    if ( !NT_SUCCESS(detectStatus) ) {

        ACPIDevPrint( (
            ACPI_PRINT_WARNING,
            deviceExtension,
            "(%#08lx): %s - Enum Failed %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Detect which profile providers are missing
    //
    if ( NT_SUCCESS(detectStatus)) {

        detectStatus = ACPIDetectDockDevices(
            deviceExtension,
            PdeviceRelations
            );

        //
        // If something went well along the way, yell a bit
        //
        if ( !NT_SUCCESS(detectStatus) ) {

            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                deviceExtension,
                "(%#08lx): %s - Dock Enum Failed "
                "%#08lx\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                detectStatus
                ) );

        }

    }

    //
    // Done
    //
    return detectStatus;
}

NTSTATUS
ACPIRootIrpQueryCapabilities(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine fills in the capabilities for the root device

Arguments:

    DeviceObject    - The object whose capabilities to get
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    KEVENT                  event;
    NTSTATUS                status          = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES    capabilities;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack;
    UCHAR                   minorFunction;

    PAGED_CODE();

    //
    // Setup the Event so that we are notified of when this done
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // We want our completion routine to fire...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );
    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Look at the current stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );
    minorFunction = irpStack->MinorFunction;

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Failure
        //
        goto ACPIRootIrpQueryCapabilitiesExit;

    }

    //
    // Grab a pointer to the capabilitites
    //
    capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
#ifndef HANDLE_BOGUS_CAPS
    if (capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        goto ACPIRootIrpQueryCapabilitiesExit;

    }
#endif

    //
    // Set the capabilities that we know about
    //
    capabilities->LockSupported = FALSE;
    capabilities->EjectSupported = FALSE;
    capabilities->Removable = FALSE;
    capabilities->UINumber = (ULONG) -1;
    capabilities->UniqueID = TRUE;
    capabilities->RawDeviceOK = FALSE;
    capabilities->SurpriseRemovalOK = FALSE;
    capabilities->Address = (ULONG) -1;
    capabilities->DeviceWake = PowerDeviceUnspecified;
    capabilities->SystemWake = PowerDeviceUnspecified;

    //
    // build the power table properly yet?
    //
    status = ACPISystemPowerInitializeRootMapping(
        deviceExtension,
        capabilities
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): %s - InitializeRootMapping = %08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            status
            ) );
        goto ACPIRootIrpQueryCapabilitiesExit;

    }

ACPIRootIrpQueryCapabilitiesExit:

    //
    // Have happily finished with this irp
    //
    Irp->IoStatus.Status = status;

    //
    // Complete the Irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}


NTSTATUS
ACPIRootIrpQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_QUERY_DEVICE_RELATIONS
    requests sent to the Root or Filter Device Objects

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             checkForFilters = FALSE;
    KEVENT              queryEvent;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_RELATIONS   deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;
    NTSTATUS            detectStatus;

    PAGED_CODE();

    switch(irpStack->Parameters.QueryDeviceRelations.Type) {

        case BusRelations:

            //
            // Remember to check for filters later on...
            //
            checkForFilters = TRUE;

            //
            // Get the real bus relations
            //
            status = ACPIRootIrpQueryBusRelations(
                DeviceObject,
                Irp,
                &deviceRelations
                );
            break ;

        default:
            status = STATUS_NOT_SUPPORTED ;
            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                deviceExtension,
                "(%#08lx): %s - Unhandled Type %d\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
                irpStack->Parameters.QueryDeviceRelations.Type
                ) );
            break ;
    }

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s (d) = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    if (NT_SUCCESS(status)) {

        //
        // Pass the IRP status along
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    } else if ((status != STATUS_NOT_SUPPORTED) && (deviceRelations == NULL)) {

        //
        // If we haven't succeed the irp, then we can also fail it
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) NULL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    } else {

        //
        // Either someone above us added an entry or we did not have anything
        // to add. Therefore, we do not touch this IRP, but simply pass it down.
        //
    }

    //
    // Initialize an event so that we can block
    //
    KeInitializeEvent( &queryEvent, SynchronizationEvent, FALSE );

    //
    // If we succeeded, then we must set a completion routine so that we
    // can do some post-processing
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &queryEvent,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &queryEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Read back the device relations (they may have changed)
    //
    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    //
    // If we succeeded, then we should try to load the filters
    //
    if ( (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED) ) &&
         checkForFilters == TRUE) {

        //
        // Grab the device relations
        //
        detectStatus = ACPIDetectFilterDevices(
            DeviceObject,
            deviceRelations
            );
        ACPIDevPrint( (
            ACPI_PRINT_IRP,
            deviceExtension,
            "(0x%08lx): %s (u) = %#08lx\n",
            Irp,
            ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
            detectStatus
            ) );

    }

    //
    // Done with the IRP
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPIRootIrpQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_INTERFACE requests for the ACPI FDO.
    It will eject an arbiter interface for interrupts.

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    ARBITER_INTERFACE   ArbiterTable;
    CM_RESOURCE_TYPE    resource;
    NTSTATUS            status;
    GUID                *interfaceType;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    ULONG               count;
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Obtain the info we will need from the irp
    //
    resource = (CM_RESOURCE_TYPE)
        PtrToUlong(irpStack->Parameters.QueryInterface.InterfaceSpecificData);
    interfaceType = (LPGUID) irpStack->Parameters.QueryInterface.InterfaceType;

#if DBG
    {
        NTSTATUS        status2;
        UNICODE_STRING  guidString;

        status2 = RtlStringFromGUID( interfaceType, &guidString );
        if (NT_SUCCESS(status2)) {

            ACPIDevPrint( (
                ACPI_PRINT_IRP,
                deviceExtension,
                "(0x%08lx): %s - Res %x Type = %wZ\n",
                Irp,
                ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction),
                resource,
                &guidString
                ) );

            RtlFreeUnicodeString( &guidString );

        }
    }
#endif

    //
    // *Only* Handle the Guids that we know about. Do Not Ever touch
    // any other GUID
    //
    if ((CompareGuid(interfaceType, (PVOID) &GUID_ARBITER_INTERFACE_STANDARD)) &&
               (resource == CmResourceTypeInterrupt)){

        //
        // Only copy up to current size of the ARBITER_INTERFACE structure
        //
        if (irpStack->Parameters.QueryInterface.Size >
            sizeof (ARBITER_INTERFACE) ) {

            count = sizeof (ARBITER_INTERFACE);

        } else {

            count = irpStack->Parameters.QueryInterface.Size;
        }

        ArbiterTable.Size = sizeof(ARBITER_INTERFACE);
        ArbiterTable.Version = 1;
        ArbiterTable.InterfaceReference = AcpiNullReference;
        ArbiterTable.InterfaceDereference = AcpiNullReference;
        ArbiterTable.ArbiterHandler = &ArbArbiterHandler;
        ArbiterTable.Context = &AcpiArbiter.ArbiterState;
        ArbiterTable.Flags = 0; // Do not set ARBITER_PARTIAL here

        //
        // Copy the arbiter table.
        //
        RtlCopyMemory(irpStack->Parameters.QueryInterface.Interface,
                      &ArbiterTable,
                      count);

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        Irp->IoStatus.Status
        ) );

    return ACPIDispatchForwardIrp( DeviceObject, Irp );
}

NTSTATUS
ACPIRootIrpQueryPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles the QUERY_POWER sent to the root FDO. It succeeds
    the query if ACPI supports the listed system state

Arguments:

    DeviceObject    - The Target
    Irp             - The Request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             passDown = TRUE;
    NTSTATUS            status = Irp->IoStatus.Status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpSp;
    PNSOBJ              object;
    SYSTEM_POWER_STATE  systemState;
    ULONG               objectName;

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        goto ACPIRootIrpQueryPowerExit;

    }
    if (irpSp->Parameters.Power.ShutdownType == PowerActionWarmEject) {

        //
        // We definately don't allow the ejection of this node
        //
        passDown = FALSE;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto ACPIRootIrpQueryPowerExit;

    }

    //
    // What system state are we looking at?
    //
    systemState = irpSp->Parameters.Power.State.SystemState;
    switch (systemState) {
        case PowerSystemWorking:   objectName = PACKED_S0; break;
        case PowerSystemSleeping1: objectName = PACKED_S1; break;
        case PowerSystemSleeping2: objectName = PACKED_S2; break;
        case PowerSystemSleeping3: objectName = PACKED_S3; break;
        case PowerSystemHibernate:
        case PowerSystemShutdown:

            status = STATUS_SUCCESS;
            goto ACPIRootIrpQueryPowerExit;

        default:

            //
            // We don't handle this IRP
            //
            passDown = FALSE;
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto ACPIRootIrpQueryPowerExit;
    }

    //
    // Does the object exist?
    //
    object = ACPIAmliGetNamedChild(
        deviceExtension->AcpiObject->pnsParent,
        objectName
        );
    if (object != NULL) {

        status = STATUS_SUCCESS;

    } else {

        passDown = FALSE;
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

ACPIRootIrpQueryPowerExit:

    //
    // Let the system know what we support and what we don't
    //
    Irp->IoStatus.Status = status;
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpQueryPower = %08lx\n",
        Irp,
        status
        ) );

    //
    // Should we pass the irp down or fail it?
    //
    if (passDown) {

        //
        // If we support the request then pass it down and give someone else a
        // chance to veto it
        //
        return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );

    } else {

        //
        // If we failed the irp for whatever reason, the we should just complete
        // the request now and continue along
        //
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }
}

NTSTATUS
ACPIRootIrpQueryRemoveOrStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine transitions the device to the inactive state

Arguments:

    DeviceObject    - The target
    Irp             - The Request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Are we allowed to stop the device?
    //
    if (deviceExtension->Flags & DEV_CAP_NO_STOP) {

        //
        // No, then fail the irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

        //
        // Mark the device state as inactive...
        //
        deviceExtension->PreviousState = deviceExtension->DeviceState;
        deviceExtension->DeviceState = Inactive;

        //
        // Pass the Irp Along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );


    }

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called when a filter object must remove itself...

Arguments:

    DeviceObject    - The DeviceObject that must be removed
    Irp             - The request to remove ourselves

Return Value:

--*/
{
    LONG                oldReferenceCount;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // Set the device state as 'removed' ...
    //
    deviceExtension->DeviceState = Removed;

    //
    // Send on the remove IRP
    //
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );

    //
    // Attempt to stop the device (if possible)
    //
    ACPIInitStopACPI( DeviceObject );


    //
    // Unregister WMI
    //
#ifdef WMI_TRACING
    ACPIWmiUnRegisterLog(DeviceObject);
#endif // WMI_TRACING    

    //
    // Delete the useless set of resources
    //
    if (deviceExtension->ResourceList != NULL) {

        ExFreePool( deviceExtension->ResourceList );

    }

    //
    // Update the device extension ---
    // we need to hold the lock for this
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Step one is to zero out the things that we no longer care
    // about
    //
    DeviceObject->DeviceExtension = NULL;
    targetObject = deviceExtension->TargetDeviceObject;
    deviceExtension->TargetDeviceObject = NULL;
    deviceExtension->PhysicalDeviceObject = NULL;
    deviceExtension->DeviceObject = NULL;

    //
    // Mark the node as being fresh and untouched
    //
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_MASK_TYPE, TRUE );
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_NOT_FOUND, FALSE );
    ACPIInternalUpdateFlags( &(deviceExtension->Flags), DEV_TYPE_REMOVED, FALSE );

    //
    // The reference count should have value >= 1
    //
    oldReferenceCount = InterlockedDecrement(
        &(deviceExtension->ReferenceCount)
        );

    ASSERT( oldReferenceCount >= 0 );

    //
    // Do we have to delete the node?
    //
    if (oldReferenceCount == 0) {

        //
        // Delete the extension
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // Detach the device and delete the object
    //
    ASSERT( targetObject );
    IoDetachDevice( targetObject );
    IoDeleteDevice( DeviceObject );

    //
    // done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIRootIrpSetPower (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to tell the Root device that the system is
    going to sleep

Arguments:

    DeviceObject    - Device which represents the root of the ACPI tree
    Irp             - The request in question

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp;

    //
    // See if we need to bugcheck
    //
    if (AcpiSystemInitialized == FALSE) {

        ACPIInternalError( ACPI_ROOT );

    }

    //
    // Get the Current stack location to determine if we are a system
    // irp or a device irp. We ignore device irps here.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->Parameters.Power.Type != SystemPowerState) {

        //
        // We don't handle this irp
        //
        return ACPIDispatchForwardPowerIrp( DeviceObject, Irp );

    }

    //
    // We are going to work on the Irp, so mark it as being SUCCESS
    // for now
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpSetPower - S%d\n",
        Irp,
        irpSp->Parameters.Power.State.SystemState - PowerSystemWorking
        ) );

    //
    // Mark the irp as pending, and increment the irp count because a
    // completion is going to be set
    //
    IoMarkIrpPending( Irp );
    InterlockedIncrement( &(deviceExtension->OutstandingIrpCount) );

    //
    // Queue the request
    //
    status = ACPIDeviceIrpSystemRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpForwardRequest
        );

    //
    // Did we return STATUS_MORE_PROCESSING_REQUIRED (which we used if
    // we overloaded STATUS_PENDING)
    //
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    }

    //
    // Done. Note: the callback function always gets called, so we don't
    // have to worry about doing clean-up work here.
    //
    return status;
}

NTSTATUS
ACPIRootIrpStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the IRP_MN_START_DEVICE requests sent
    to the Root (or FDO, take your pick, they are the same thing) device object

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    KEVENT              event;
    NTSTATUS            status          = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack;
    UCHAR               minorFunction;

    PAGED_CODE();

    //
    // Request to start the device. The rule is that we must pass
    // this down to the PDO before we can start the device ourselves
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): ACPIRootIrpStartDevice\n",
        Irp
        ) );

    //
    // Setup the Event so that we are notified of when this done
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Copy the stack location
    //
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // We want our completion routine to fire...
    //
    IoSetCompletionRoutine(
        Irp,
        ACPIRootIrpCompleteRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Let the IRP execute
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    if (status == STATUS_PENDING) {

        //
        // Wait for it
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab the 'real' status
        //
        status = Irp->IoStatus.Status;

    }

    //
    // Get the current irp stack location
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );
    minorFunction = irpStack->MinorFunction;

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        //
        // Failure
        //
        goto ACPIRootIrpStartDeviceExit;

    }

    //
    // Grab the translatted resource allocated for this device
    //
    deviceExtension->ResourceList =
        (irpStack->Parameters.StartDevice.AllocatedResourcesTranslated ==
         NULL) ? NULL:
        RtlDuplicateCmResourceList(
            NonPagedPool,
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
            ACPI_RESOURCE_POOLTAG
            );
    if (deviceExtension->ResourceList == NULL) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - Did not find a resource list!\n"
            ) );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_ROOT_RESOURCES_FAILURE,
            (ULONG_PTR) deviceExtension,
            0,
            0
            );

    }

    //
    // Start ACPI
    //
    status = ACPIInitStartACPI( DeviceObject );

    //
    // Update the status of the device
    //
    if (NT_SUCCESS(status)) {

        deviceExtension->DeviceState = Started;

    }

#if 0
    status = ACPIRootUpdateRootResourcesWithHalResources();
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            "(0x%08lx): ACPIRootUpdateRootResourcesWithHalResources = %08lx\n",
            Irp,
            status
            ) );

    }
#endif

ACPIRootIrpStartDeviceExit:

    //
    // Store and return the result
    //
    Irp->IoStatus.Status = status;

    //
    // Complete the Irp
    //
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpStopDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This handles a request to stop the device

Arguments:

    DeviceObject    - The device to stop
    Irp             - The request to tell us how to do it...

Return Value:

    NTSTATUS

--*/
{

    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    PAGED_CODE();

    //
    // Note: we can only stop a device from within the Inactive state...
    //
    if (deviceExtension->DeviceState != Inactive) {

        ASSERT( deviceExtension->DeviceState == Inactive );
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        goto ACPIRootIrpStopDeviceExit;

    }

    //
    // Set the device as 'Stopped'
    deviceExtension->DeviceState = Stopped;

    //
    // Send on the Stop IRP
    //
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Attempt to stop the device (if possible)
    //
#if 1
    ACPIInitStopACPI( DeviceObject );
#endif

ACPIRootIrpStopDeviceExit:

    //
    // done
    //
    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(%#08lx): %s = %#08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        status
        ) );
    return status;
}

NTSTATUS
ACPIRootIrpUnhandled(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch point for the unhandled requests sent to a filter

Arguments:

    DeviceObject    - Pointer to the device object we received the request for
    Irp             - Pointer to the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    //
    // Let the debugger know
    //
    ACPIDevPrint( (
        ACPI_PRINT_WARNING,
        deviceExtension,
        "(%#08lx): %s - Unhandled\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, irpStack->MinorFunction)
        ) );

    //
    // Skip current stack location
    //
    IoSkipCurrentIrpStackLocation( Irp );

    //
    // Call the driver below us
    //
    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // Done
    //
    return status;
}

//
// Some data structures used by the AML interpreter. We need to be able
// to read/write these globals to keep track of the number of contexts
// allocated by the interpreter...
//
extern  ULONG       gdwcCTObjsMax;
extern  ULONG       AMLIMaxCTObjs;
extern  KSPIN_LOCK  gdwGContextSpinLock;

VOID
ACPIRootPowerCallBack(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    )
/*++

Routine Description:

    This routine is called when the system changes power states

Arguments:

    CallBackContext - The device extension for the root device
    Argument1

--*/
{
    HANDLE      pKey;
    HANDLE      wKey;
    KIRQL       oldIrql;
    NTSTATUS    status;
    ULONG       action = PtrToUlong( Argument1 );
    ULONG       value  = PtrToUlong( Argument2 );
    ULONG       num;

    //
    // We are looking for a PO_CB_SYSTEM_STATE_LOCK
    //
    if (action != PO_CB_SYSTEM_STATE_LOCK) {

        return;

    }

    //
    // We need to remember if we are going to S0 or we are leaving S0
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );
    AcpiPowerLeavingS0 = (value != 1);
    KeReleaseSpinLock( &GpeTableLock, oldIrql );

    //
    // We have to update the GPE masks now. Before we can do that, we need
    // to hold the cancel spinlock and the power lock to make sure that
    // everything is synchronized okay
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );

    //
    // Update the GPE masks
    //
    ACPIWakeRemoveDevicesAndUpdate( NULL, NULL );

    //
    // Done with the locks
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    if (value == 0) {

        //
        // We need to reset the max number of context objects allocated
        //
        KeAcquireSpinLock( &gdwGContextSpinLock, &oldIrql );
        gdwcCTObjsMax = 0;
        KeReleaseSpinLock( &gdwGContextSpinLock, oldIrql );

        //
        // Return now otherwise we will execute that we normally
        // would execute on wake-up
        //
        return;

    }

    //
    // Open the correct handle to the registry
    //
    status = OSCreateHandle(ACPI_PARAMETERS_REGISTRY_KEY, NULL, &pKey);
    if (!NT_SUCCESS(status)) {

        return;

    }

    //
    // Grab the max number of contexts allocated and write it to
    // the registry, but only if it exceeds the last value store
    // in the registry
    //
    KeAcquireSpinLock( &gdwGContextSpinLock, &oldIrql );
    if (gdwcCTObjsMax > AMLIMaxCTObjs) {

        AMLIMaxCTObjs = gdwcCTObjsMax;

    }
    num = AMLIMaxCTObjs;
    KeReleaseSpinLock( &gdwGContextSpinLock, oldIrql );
    OSWriteRegValue(
        "AMLIMaxCTObjs",
        pKey,
        &num,
        sizeof(num)
        );

    //
    // If we are leaving the sleep state, and re-entering the running
    // state, then we had better write to the registery that we think
    // woke up the computer
    //
    status = OSCreateHandle("WakeUp",pKey,&wKey);
    OSCloseHandle(pKey);
    if (!NT_SUCCESS(status)) {

        OSCloseHandle(pKey);
        return;

    }


    //
    // Store the PM1 Fixed Register Mask
    //
    OSWriteRegValue(
        "FixedEventMask",
        wKey,
        &(AcpiInformation->pm1_wake_mask),
        sizeof(AcpiInformation->pm1_wake_mask)
        );

    //
    // Store the PM1 Fixed Register Status
    //
    OSWriteRegValue(
        "FixedEventStatus",
        wKey,
        &(AcpiInformation->pm1_wake_status),
        sizeof(AcpiInformation->pm1_wake_status)
        );

    //
    // Store the GPE Mask
    //
    OSWriteRegValue(
        "GenericEventMask",
        wKey,
        GpeSavedWakeMask,
        AcpiInformation->GpeSize
        );

    //
    // Store the GPE Status
    //
    OSWriteRegValue(
        "GenericEventStatus",
        wKey,
        GpeSavedWakeStatus,
        AcpiInformation->GpeSize
        );

    //
    // Done with the key
    //
    OSCloseHandle( wKey );
}

NTSTATUS
ACPIRootUpdateRootResourcesWithBusResources(
    VOID
    )
/*++

Routine Description:

    This routine is called when ACPI is started. Its purpose is to change
    the resources reported to ACPI for its own use to include those resources
    used by direct childs which are not buses. In other words, it updates
    its resource list so that buses do not prevent direct children from
    starting.

    This is black magic

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    KIRQL                           oldIrql;
    LONG                            oldReferenceCount;
    NTSTATUS                        status;
    PCM_RESOURCE_LIST               cmList;
    PDEVICE_EXTENSION               deviceExtension;
    PDEVICE_EXTENSION               oldExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  currentList         = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST  globalList          = NULL;
    PUCHAR                          crsBuf;

    //
    // First take the ACPI CM Res List and turn *that* into an Io ResList. This
    // is the list that we will add things to
    //
    status = PnpCmResourceListToIoResourceList(
        RootDeviceExtension->ResourceList,
        &globalList
        );
    if (!NT_SUCCESS(status)) {

        //
        // Oops
        //
        return status;

    }

    //
    // We must walk the tree at Dispatch level <sigh>
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Is the list empty?
    //
    if (IsListEmpty( &(RootDeviceExtension->ChildDeviceList) ) ) {

        //
        // We have nothing to do here
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        ExFreePool( globalList );
        return STATUS_SUCCESS;

    }

    //
    // Get the first child
    //
    deviceExtension = CONTAINING_RECORD(
        RootDeviceExtension->ChildDeviceList.Flink,
        DEVICE_EXTENSION,
        SiblingDeviceList
        );

    //
    // Always update the reference count to make sure that one will ever
    // delete the node without our knowing about it
    //
    InterlockedIncrement( &(deviceExtension->ReferenceCount) );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // loop until we get to the parent
    //
    while (deviceExtension != NULL ) {

        //
        // Check to see if we are a bus, and if we are, we will skip this
        // node
        //
        if (!(deviceExtension->Flags & DEV_MASK_BUS) &&
            !(deviceExtension->Flags & DEV_PROP_NO_OBJECT) ) {

            //
            // At this point, see if there is a _CRS
            //
            ACPIGetBufferSync(
                deviceExtension,
                PACKED_CRS,
                &crsBuf,
                NULL
                );
            if (crsBuf != NULL) {

                //
                // Try to turn the crs into an IO_RESOURCE_REQUIREMENTS_LIST
                //
                status = PnpBiosResourcesToNtResources(
                    crsBuf,
                    0,
                    &currentList
                    );

                //
                // If we didn't succeed, then we skip the list
                //
                if (NT_SUCCESS(status) && currentList) {

                    //
                    // Add this list to the global list
                    //
                    status = ACPIRangeAdd(
                        &globalList,
                        currentList
                        );

                    //
                    // We are done with the local IO res list
                    //
                    ExFreePool( currentList );

                }

                ACPIDevPrint( (
                    ACPI_PRINT_RESOURCES_1,
                    deviceExtension,
                    "ACPIRootUpdateResources = %08lx\n",
                    status
                    ) );

                //
                // Done with local crs
                //
                ExFreePool( crsBuf );

            }

        }

        //
        // We need the lock to walk the next resource in the tree
        //
        KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

        //
        // Remember the old extension
        //
        oldExtension = deviceExtension;

        //
        // Get the next device extension
        //
        if (deviceExtension->SiblingDeviceList.Flink !=
            &(RootDeviceExtension->ChildDeviceList) ) {

            //
            // Next Element
            //
            deviceExtension = CONTAINING_RECORD(
                deviceExtension->SiblingDeviceList.Flink,
                DEVICE_EXTENSION,
                SiblingDeviceList
                );

            //
            // Reference count the device
            //
            InterlockedIncrement( &(deviceExtension->ReferenceCount) );

        } else {

            deviceExtension = NULL;

        }

        //
        // Decrement the reference count on this node
        //
        oldReferenceCount = InterlockedDecrement(
            &(oldExtension->ReferenceCount)
            );

        //
        // Is this the last reference?
        //
        if (oldReferenceCount == 0) {

            //
            // Free the memory allocated by the extension
            //
            ACPIInitDeleteDeviceExtension( oldExtension );
        }

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    }

    //
    // Do we have any resources that we care to update?
    //
    if (globalList == NULL) {

        //
        // No, then we are done
        //
        return STATUS_SUCCESS;

    }

    //
    // Turn the global list into a CM_RES_LIST
    //
    status = PnpIoResourceListToCmResourceList( globalList, &cmList );

    //
    // No matter what, we are done with the global list
    //
    ExFreePool( globalList );

    //
    // Check to see if we succeeded
    //
    if (!NT_SUCCESS(status)) {

        //
        // Oops
        //
        return status;

    }

    //
    // Now, set this as the resources consumed by ACPI. The previous list
    // was created by the system manager, so freeing it is bad.
    //
    RootDeviceExtension->ResourceList = cmList;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIRootUpdateRootResourcesWithHalResources(
    VOID
    )
/*++

Routine Description:

    This routine will read from the registry the resources that cannot
    be allocated by ACPI and store them in the resourceList for PnP0C08

    This is black magic

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    HANDLE                          classKeyHandle;
    HANDLE                          driverKeyHandle;
    HANDLE                          resourceMap;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               resourceObject;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResList;
    PCM_RESOURCE_LIST               globalResList;
    PCM_RESOURCE_LIST               cmResList;
    PUCHAR                          lastAddr;
    ULONG                           bufferSize;
    ULONG                           busTranslatedLength;
    ULONG                           classKeyIndex;
    ULONG                           driverKeyIndex;
    ULONG                           driverValueIndex;
    ULONG                           i;
    ULONG                           j;
    ULONG                           length;
    ULONG                           temp;
    ULONG                           translatedLength;
    union {
        PVOID                       buffer;
        PKEY_BASIC_INFORMATION      keyBasicInf;
        PKEY_FULL_INFORMATION       keyFullInf;
        PKEY_VALUE_FULL_INFORMATION valueKeyFullInf;
    } u;
    UNICODE_STRING                  keyName;
    WCHAR                           rgzTranslated[] = L".Translated";
    WCHAR                           rgzBusTranslated[] = L".Bus.Translated";
    WCHAR                           rgzResourceMap[] =
        L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP";

#define INVALID_HANDLE  (HANDLE) -1

    //
    // Start out with one page of buffer
    //
    bufferSize = PAGE_SIZE;

    //
    // Allocate this buffer
    //
    u.buffer = ExAllocatePoolWithTag(
         PagedPool,
         bufferSize,
         ACPI_MISC_POOLTAG
         );
    if (u.buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Add the current global res list to the working list
    //
    globalResList = NULL;
    status = ACPIRangeAddCmList(
        &globalResList,
        RootDeviceExtension->ResourceList
        );
    if (!NT_SUCCESS(status)) {

        ExFreePool( u.buffer );
        return status;

    }
    ExFreePool( RootDeviceExtension->ResourceList );
    RootDeviceExtension->ResourceList = NULL;

    //
    // count the constant string lengths
    //
    for (translatedLength = 0;
         rgzTranslated[translatedLength];
         translatedLength++);
    for (busTranslatedLength = 0;
         rgzBusTranslated[busTranslatedLength];
         busTranslatedLength++);
    translatedLength *= sizeof(WCHAR);
    busTranslatedLength *= sizeof(WCHAR);

    //
    // Initialize the registry path information
    //
    RtlInitUnicodeString( &keyName, rgzResourceMap );

    //
    // Open the registry key for this information
    //
    InitializeObjectAttributes(
        &resourceObject,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwOpenKey(
        &resourceMap,
        KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
        &resourceObject
        );
    if (!NT_SUCCESS(status)) {

        //
        // Failed:
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIRootUpdateRootResourcesWithHalResources: ZwOpenKey = 0x%08lx\n",
            status
            ) );
        ExFreePool( u.buffer );
        return status;

    }

    //
    // Walk resource map and collect any in-use resources
    //
    classKeyIndex = 0;
    classKeyHandle = INVALID_HANDLE;
    driverKeyHandle = INVALID_HANDLE;
    status = STATUS_SUCCESS;

    //
    // loop until failure
    //
    while (NT_SUCCESS(status)) {

        //
        // Get the class information
        //
        status = ZwEnumerateKey(
            resourceMap,
            classKeyIndex++,
            KeyBasicInformation,
            u.keyBasicInf,
            bufferSize,
            &temp
            );
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Create a unicode string using the counted string passed back to
        // us in the information structure, and open the class key
        //
        keyName.Buffer = (PWSTR) u.keyBasicInf->Name;
        keyName.Length = (USHORT) u.keyBasicInf->NameLength;
        keyName.MaximumLength = (USHORT) u.keyBasicInf->NameLength;
        InitializeObjectAttributes(
            &resourceObject,
            &keyName,
            OBJ_CASE_INSENSITIVE,
            resourceMap,
            NULL
            );
        status = ZwOpenKey(
            &classKeyHandle,
            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
            &resourceObject
            );
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Loop until failure
        //
        driverKeyIndex = 0;
        while (NT_SUCCESS(status)) {

            //
            // Get the class information
            //
            status = ZwEnumerateKey(
                classKeyHandle,
                driverKeyIndex++,
                KeyBasicInformation,
                u.keyBasicInf,
                bufferSize,
                &temp
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Create a unicode string using the counted string passed back
            // to us in the information structure, and open the class key
            //
            keyName.Buffer = (PWSTR) u.keyBasicInf->Name;
            keyName.Length = (USHORT) u.keyBasicInf->NameLength;
            keyName.MaximumLength = (USHORT) u.keyBasicInf->NameLength;
            InitializeObjectAttributes(
                &resourceObject,
                &keyName,
                OBJ_CASE_INSENSITIVE,
                classKeyHandle,
                NULL
                );
            status = ZwOpenKey(
                &driverKeyHandle,
                KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                &resourceObject
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // Get full information for that key so we can get the information
            // about the data stored in the key
            //
            status = ZwQueryKey(
                driverKeyHandle,
                KeyFullInformation,
                u.keyFullInf,
                bufferSize,
                &temp
                );
            if (!NT_SUCCESS(status)) {

                break;

            }

            //
            // How long is the key?
            //
            length = sizeof( KEY_VALUE_FULL_INFORMATION) +
                u.keyFullInf->MaxValueNameLen +
                u.keyFullInf->MaxValueDataLen +
                sizeof(UNICODE_NULL);
            if (length > bufferSize) {

                PVOID   tempBuffer;

                //
                // Grow the buffer
                //
                tempBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    length,
                    ACPI_MISC_POOLTAG
                    );
                if (tempBuffer == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }
                ExFreePool( u.buffer );
                u.buffer = tempBuffer;
                bufferSize = length;

            }

            //
            // Look at all the values
            //
            driverValueIndex = 0;
            for(;;) {

                PCM_RESOURCE_LIST   tempCmList;

                status = ZwEnumerateValueKey(
                    driverKeyHandle,
                    driverValueIndex++,
                    KeyValueFullInformation,
                    u.valueKeyFullInf,
                    bufferSize,
                    &temp
                    );
                if (!NT_SUCCESS(status)) {

                    break;

                }

                //
                // If this is not a translated resource list, skip it
                //
                i = u.valueKeyFullInf->NameLength;
                if (i < translatedLength ||
                    RtlCompareMemory(
                        ((PUCHAR) u.valueKeyFullInf->Name) + i - translatedLength,
                        rgzTranslated,
                        translatedLength) != translatedLength
                    ) {

                    //
                    // Does not end in rgzTranslated
                    //
                    continue;

                }

                //
                // Is this a bus translated resource list???
                //
                if (i >= busTranslatedLength &&
                    RtlCompareMemory(
                        ((PUCHAR) u.valueKeyFullInf->Name) + i - busTranslatedLength,
                        rgzBusTranslated,
                        busTranslatedLength) != busTranslatedLength
                    ) {

                    //
                    // Ends in rgzBusTranslated
                    //
                    continue;

                }

                //
                // we now have a pointer to the cm resource list
                //
                cmResList = (PCM_RESOURCE_LIST) ( (PUCHAR) u.valueKeyFullInf +
                    u.valueKeyFullInf->DataOffset);
                lastAddr = (PUCHAR) cmResList + u.valueKeyFullInf->DataLength;

                //
                // We must flatten this list down to one level, so lets
                // figure out how many descriptors we need
                //
                cmFullResList = cmResList->List;
                for (temp = i = 0; i < cmResList->Count; i++) {

                    if ( (PUCHAR) cmFullResList > lastAddr) {

                        break;

                    }

                    temp += cmFullResList->PartialResourceList.Count;

                    //
                    // next CM_FULL_RESOURCE_DESCRIPTOR
                    //
                    cmFullResList =
                        (PCM_FULL_RESOURCE_DESCRIPTOR) ( (PUCHAR) cmFullResList
                        + sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                        (cmFullResList->PartialResourceList.Count - 1) *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

                }

                //
                // Now that we have the number of descriptors, allocate this
                // much space
                //
                tempCmList = ExAllocatePool(
                    PagedPool,
                    sizeof(CM_RESOURCE_LIST) + (temp - 1) *
                    sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );
                if (tempCmList == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

                //
                // Now, fill up the flatened list
                //
                RtlCopyMemory(
                    tempCmList,
                    cmResList,
                    sizeof(CM_RESOURCE_LIST) -
                    sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );
                tempCmList->Count = 1;
                tempCmList->List->PartialResourceList.Count = temp;

                //
                // This is a brute force approach
                //
                cmFullResList = cmResList->List;
                for (temp = i = 0; i < cmResList->Count; i++) {

                    if ( (PUCHAR) cmFullResList > lastAddr) {

                        break;

                    }

                    //
                    // Copy the current descriptors over
                    //
                    RtlCopyMemory(
                        &(tempCmList->List->PartialResourceList.PartialDescriptors[temp]),
                        cmFullResList->PartialResourceList.PartialDescriptors,
                        cmFullResList->PartialResourceList.Count *
                            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                        );


                    temp += cmFullResList->PartialResourceList.Count;

                    //
                    // next CM_FULL_RESOURCE_DESCRIPTOR
                    //
                    cmFullResList =
                        (PCM_FULL_RESOURCE_DESCRIPTOR) ( (PUCHAR) cmFullResList
                        + sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                        (cmFullResList->PartialResourceList.Count - 1) *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

                }

                //
                // Add it to the global list
                //
                status = ACPIRangeAddCmList(
                    &globalResList,
                    tempCmList
                    );
                if (!NT_SUCCESS(status)) {

                    ACPIPrint( (
                        ACPI_PRINT_CRITICAL,
                        "ACPIRootUpdateRootResourcesWithHalResources: "
                        "ACPIRangeAddCmList = 0x%08lx\n",
                        status
                        ) );
                    ExFreePool( tempCmList );
                    break;

                }
                ExFreePool( tempCmList );

            } // for -- Next driverValueIndex

            if (driverKeyHandle != INVALID_HANDLE) {

                ZwClose( driverKeyHandle);
                driverKeyHandle = INVALID_HANDLE;

            }

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;

            }

        } // while -- Next driverKeyIndex

        if (classKeyHandle != INVALID_HANDLE) {

            ZwClose( classKeyHandle );
            classKeyHandle = INVALID_HANDLE;

        }

        if (status == STATUS_NO_MORE_ENTRIES) {

            status = STATUS_SUCCESS;

        }

    } // while -- next classKeyIndex

    if (status == STATUS_NO_MORE_ENTRIES) {

        status = STATUS_SUCCESS;

    }

    ZwClose( resourceMap );
    ExFreePool( u.buffer );

    //
    // Remember the new global list
    //
    RootDeviceExtension->ResourceList = globalResList;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\res_cm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmres.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Stephane Plante (splante) 20-Nov-1996

Environment:

    Kernel mode only.

Revision History:

    13-Feb-1997:
        Initial Revision

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PnpiCmResourceToBiosAddress)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosAddressDouble)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosDma)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosExtendedIrq)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIoFixedPort)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIoPort)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosIrq)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory32)
#pragma alloc_text(PAGE,PnpiCmResourceToBiosMemory32Fixed)
#pragma alloc_text(PAGE,PnpiCmResourceValidEmptyList)
#pragma alloc_text(PAGE,PnpCmResourcesToBiosResources)
#endif


NTSTATUS
PnpiCmResourceToBiosAddress(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine converts the proper Cm resource descriptor back into a
    word address descriptor

Arguments:

    Buffer  - Pointer to the Bios Resource list
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_WORD_ADDRESS_DESCRIPTOR    buffer;
    UCHAR                           type;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_WORD_ADDRESS_DESCRIPTOR) Buffer;

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1 );
    ASSERT( aList->PartialResourceList.Count );

    //
    // Determine which type of descriptor we are looking for
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:
        type = CmResourceTypeMemory;
        break;
    case PNP_ADDRESS_IO_TYPE:
        type = CmResourceTypePort;
        break;
    case PNP_ADDRESS_BUS_NUMBER_TYPE:
        type = CmResourceTypeBusNumber;
        break;
    default:
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != type) {

            //
            // No
            //
            continue;

        }

        switch (desc->Type) {
        case PNP_ADDRESS_MEMORY_TYPE:

            //
            // Set the flags
            //
            buffer->TFlag = 0;
            if (desc->Flags & CM_RESOURCE_MEMORY_READ_WRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_WRITE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_ONLY;

            }
            if (desc->Flags & CM_RESOURCE_MEMORY_CACHEABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_CACHEABLE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE;

            }

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (USHORT)
                (desc->u.Memory.Start.LowPart & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.Memory.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.Memory.Length;
            break;

        case PNP_ADDRESS_IO_TYPE:

            //
            // We must extract the flags here from the
            // devicePrivate resource
            //

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (USHORT)
                (desc->u.Port.Start.LowPart & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.Port.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.Port.Length;
            break;

        case PNP_ADDRESS_BUS_NUMBER_TYPE:

            buffer->MinimumAddress = (USHORT)
                (desc->u.BusNumber.Start & 0xFFFF);
            buffer->MaximumAddress = buffer->MinimumAddress +
                (USHORT) (desc->u.BusNumber.Length - 1);
            buffer->AddressLength = (USHORT) desc->u.BusNumber.Length;
            break;

        } // switch

        //
        // Handling for the GFlags goes here, if we ever decide to
        // support it
        //

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    } // for

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosAddressDouble(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine converts the proper Cm resource descriptor back into a
    word address descriptor

Arguments:

    Buffer  - Pointer to the Bios Resource list
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_DWORD_ADDRESS_DESCRIPTOR   buffer;
    UCHAR                           type;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_DWORD_ADDRESS_DESCRIPTOR) Buffer;

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1 );
    ASSERT( aList->PartialResourceList.Count );

    //
    // Determine which type of descriptor we are looking for
    //
    switch (buffer->RFlag) {
    case PNP_ADDRESS_MEMORY_TYPE:
        type = CmResourceTypeMemory;
        break;
    case PNP_ADDRESS_IO_TYPE:
        type = CmResourceTypePort;
        break;
    case PNP_ADDRESS_BUS_NUMBER_TYPE:
        type = CmResourceTypeBusNumber;
        break;
    default:
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != type) {

            //
            // No
            //
            continue;

        }

        switch (desc->Type) {
        case PNP_ADDRESS_MEMORY_TYPE:

            //
            // Set the flags
            //
            buffer->TFlag = 0;
            if (desc->Flags & CM_RESOURCE_MEMORY_READ_WRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_WRITE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_READ_ONLY;

            }
            if (desc->Flags & CM_RESOURCE_MEMORY_CACHEABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_CACHEABLE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE;

            } else if (desc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE;

            } else {

                buffer->TFlag |= PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE;

            }

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (ULONG) desc->u.Memory.Start.LowPart;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.Memory.Length - 1);
            buffer->AddressLength = desc->u.Memory.Length;
            break;

        case PNP_ADDRESS_IO_TYPE:

            //
            // We must extract the flags here from the
            // devicePrivate resource
            //

            //
            // Set the rest of the information
            //
            buffer->MinimumAddress = (ULONG) desc->u.Port.Start.LowPart;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.Port.Length - 1);
            buffer->AddressLength = desc->u.Port.Length;
            break;

        case PNP_ADDRESS_BUS_NUMBER_TYPE:

            buffer->MinimumAddress = (ULONG) desc->u.BusNumber.Start;
            buffer->MaximumAddress = buffer->MinimumAddress +
                (ULONG) (desc->u.BusNumber.Length - 1);
            buffer->AddressLength = desc->u.BusNumber.Length;
            break;

        } // switch

        //
        // Handling for the GFlags goes here if we ever decide to support it
        //

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    } // for

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosDma(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the DMAs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_DMA_DESCRIPTOR             buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_DMA_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 2);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can have a descriptor with no DMA channels
    //
    buffer->ChannelMask = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeDma) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->ChannelMask = (1 << desc->u.Dma.Channel);

        //
        // Set the correct flags
        //
        buffer->Flags = 0;
        if (desc->Flags & CM_RESOURCE_DMA_8) {

            buffer->Flags |= PNP_DMA_SIZE_8;

        } else if (desc->Flags & CM_RESOURCE_DMA_8_AND_16) {

            buffer->Flags |= PNP_DMA_SIZE_8_AND_16;

        } else if (desc->Flags & CM_RESOURCE_DMA_16) {

            buffer->Flags |= PNP_DMA_SIZE_16;

        } else if (desc->Flags & CM_RESOURCE_DMA_32) {

            buffer->Flags |= PNP_DMA_SIZE_RESERVED;

        }
        if (desc->Flags & CM_RESOURCE_DMA_BUS_MASTER) {

            buffer->Flags |= PNP_DMA_BUS_MASTER;

        }
        if (desc->Flags & CM_RESOURCE_DMA_TYPE_A) {

            buffer->Flags |= PNP_DMA_TYPE_A;

        } else if (desc->Flags & CM_RESOURCE_DMA_TYPE_B) {

            buffer->Flags |= PNP_DMA_TYPE_B;

        } else if (desc->Flags & CM_RESOURCE_DMA_TYPE_F) {

            buffer->Flags |= PNP_DMA_TYPE_F;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosExtendedIrq(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Irqs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return Value:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_EXTENDED_IRQ_DESCRIPTOR    buffer;
    ULONG                           i;
    ULONG                           matches = 0;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_EXTENDED_IRQ_DESCRIPTOR) Buffer;
    ASSERT( buffer->TableSize == 1);
    ASSERT( buffer->Length >= 6);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeInterrupt) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->Table[0] = (ULONG) desc->u.Interrupt.Level;

        //
        // Set the Flags
        //
        buffer->Flags = 0;
        if ( (desc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ) {

            buffer->Flags |= $EDG | $HGH;

        } else {

            buffer->Flags |= $LVL | $LOW;

        }
        if (desc->ShareDisposition == CmResourceShareShared) {

            buffer->Flags |= PNP_EXTENDED_IRQ_SHARED;

        }

        //
        // We need to use DevicePrivate information to store this
        // bit. For now, assume that it is set to true
        //
        buffer->Flags |= PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY;

        //
        // Done with the record
        //
        desc->Type = CmResourceTypeNull;
        matches++;
        break;

    }

    //
    // Done with matches
    //
    return (matches == 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS );
}

NTSTATUS
PnpiCmResourceToBiosIoFixedPort(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the IoPort in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_FIXED_PORT_DESCRIPTOR      buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_FIXED_PORT_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Our fixed port can be nothing
    //
    buffer->MinimumAddress = buffer->Length = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypePort) {

            //
            // No
            //
            continue;

        }

        //
        // This port type is always set to a 10 bit decode
        //
        if ( !(desc->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) ) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = (USHORT) desc->u.Port.Start.LowPart;
        buffer->Length = (UCHAR) desc->u.Port.Length;

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosIoPort(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the IoPort in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_PORT_DESCRIPTOR            buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_PORT_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 7);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no ports
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->Length = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypePort) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = (USHORT) desc->u.Port.Start.LowPart;
        buffer->MaximumAddress = buffer->MinimumAddress;
        buffer->Alignment = 1;
        buffer->Length = (UCHAR) desc->u.Port.Length;

        //
        // Set the flags
        //
        buffer->Information = 0;
        if (desc->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {

            buffer->Information |= PNP_PORT_10_BIT_DECODE;

        }
        if (desc->Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {

            buffer->Information |= PNP_PORT_16_BIT_DECODE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done with matches
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosIrq(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Irqs in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return Value:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_IRQ_DESCRIPTOR             buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_IRQ_DESCRIPTOR) Buffer;
    ASSERT( (buffer->Tag & SMALL_TAG_SIZE_MASK) >= 2);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no interrupts
    //
    buffer->IrqMask = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeInterrupt) {

            //
            // No
            //
            continue;

        }

        //
        // Okay, we have a possible match...
        //
        if (desc->u.Interrupt.Level >= sizeof(USHORT) * 8) {

            //
            // Interrupts > 15 are Extended Irqs
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->IrqMask = ( 1 << desc->u.Interrupt.Level );
        if ( (buffer->Tag & SMALL_TAG_SIZE_MASK) == 3) {

            //
            // Wipe out the previous flags
            //
            buffer->Information = 0;
            if ( (desc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ) {

                buffer->Information |= PNP_IRQ_LATCHED;

            } else {

                buffer->Information |= PNP_IRQ_LEVEL;

            }
            if (desc->ShareDisposition == CmResourceShareShared) {

                buffer->Information |= PNP_IRQ_SHARED;

            }

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_MEMORY_DESCRIPTOR          buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_MEMORY_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 9);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Is this a 24 bit memory descriptor?
        //
        if ( !(desc->Flags & CM_RESOURCE_MEMORY_24)) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MinimumAddress = buffer->MaximumAddress =
            (USHORT) (desc->u.Memory.Start.LowPart >> 8);
        buffer->MemorySize = (USHORT) (desc->u.Memory.Length >> 8);
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory32(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_MEMORY32_DESCRIPTOR        buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_MEMORY32_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 17);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->MinimumAddress = 0;
    buffer->MaximumAddress = 0;
    buffer->Alignment = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->MemorySize = desc->u.Memory.Length;
        buffer->MinimumAddress = buffer->MaximumAddress = desc->u.Memory.Start.LowPart;
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done with matches
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PnpiCmResourceToBiosMemory32Fixed(
    IN  PUCHAR              Buffer,
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine stores all of the Memory elements in the resource list into the Bios resource
    list

Arguments:

    Buffer  - Pointer to the Bios resource List
    List    - Pointer to the CM resource List

Return:

    NTSTATUS

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PPNP_FIXED_MEMORY32_DESCRIPTOR  buffer;
    ULONG                           i;

    PAGED_CODE();

    //
    // Setup the initial buffer
    //
    buffer = (PPNP_FIXED_MEMORY32_DESCRIPTOR) Buffer;
    ASSERT( buffer->Length == 9);

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // We can use no memory
    //
    buffer->Information = 0;
    buffer->BaseAddress = 0;
    buffer->MemorySize = 0;

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeMemory) {

            //
            // No
            //
            continue;

        }

        //
        // Here we *have* a match...
        //
        buffer->BaseAddress = desc->u.Memory.Start.LowPart;
        buffer->MemorySize =  desc->u.Memory.Length >> 8;
        if (desc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            buffer->Information |= PNP_MEMORY_READ_ONLY;

        } else {

            buffer->Information |= PNP_MEMORY_READ_WRITE;

        }

        //
        // Done with descriptor and match
        //
        desc->Type = CmResourceTypeNull;
        break;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

BOOLEAN
PnpiCmResourceValidEmptyList(
    IN  PCM_RESOURCE_LIST   List
    )
/*++

Routine Description:

    This routine takes a CM_RESOURCE_LIST and makes sure that no unallocated elements
    remain...

Arguments:

    List    - List to check

Return Value:

    TRUE    - Empty
    FALSE   - Nonempty

--*/
{

    PCM_FULL_RESOURCE_DESCRIPTOR    aList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG                           i;

    PAGED_CODE();

    //
    // We can only have one list...
    //
    aList = &(List->List[0]);
    ASSERT( List->Count == 1);
    ASSERT( aList->PartialResourceList.Count );

    //
    // Loop for each of the partial resource descriptors
    //
    for (i = 0; i < aList->PartialResourceList.Count; i++) {

        //
        // Current descriptor
        //
        desc = &(aList->PartialResourceList.PartialDescriptors[i]);

        //
        // Is this an interesting descriptor?
        //
        if (desc->Type != CmResourceTypeNull) {

            //
            // No
            //
            continue;

        }

        //
        // This element wasn't consumed...<sigh>
        //
        break;

    }

    //
    // Done
    //
    return ( i == aList->PartialResourceList.Count ? TRUE : FALSE );
}

NTSTATUS
PnpCmResourcesToBiosResources(
    IN  PCM_RESOURCE_LIST   List,
    IN  PUCHAR              Data
    )
/*++

Routine Description:

    This routine takes a CM_RESOURCE_LIST and a _CRS buffer. The routine sets the
    resources in the _CRS buffer to equal to those reported in the CM_RESOURCE_LIST.
    That is: the buffer is used as a template for the new resources that are in
    the system.

Arguments:

    List    - Pointer to the CM_RESOURCE_LIST that we wish to assign
    Data    - Where we wish to store the data, and the template for it

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    PUCHAR                          buffer;
    UCHAR                           tagName;
    USHORT                          increment;

    PAGED_CODE();

    ASSERT( Data != NULL );

    //
    // Setup initial variables.
    //
    buffer = Data;
    tagName = *buffer;

    //
    // The algorithm we use is that we examine each tag in the buffer, and try to
    // match it with an entry in the resource list. So we take the convertion routine
    // for the previous problem and turn it upside down.
    //
    while (1) {

        //
        // Determine the size of the PNP resource descriptor
        //
        if ( !(tagName & LARGE_RESOURCE_TAG) ) {

            //
            // Small Tag
            //
            increment = (USHORT) (tagName & SMALL_TAG_SIZE_MASK) + 1;
            tagName &= SMALL_TAG_MASK;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: small tag = %#02lx increment = %#02lx\n",
                tagName, increment
                ) );

        } else {

            //
            // Large Tag
            //
            increment = ( *(USHORT UNALIGNED *)(buffer+1) ) + 3;

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: large tag = %#02lx increment = %#02lx\n",
                tagName, increment
                ) );

        }

        //
        // We are done if the current tag is the end tag
        //
        if (tagName == TAG_END) {

            ACPIPrint( (
                ACPI_PRINT_RESOURCES_2,
                "PnpCmResourcesToBiosResources: TAG_END\n"
                ) );

            break;

        }


        switch(tagName) {
            case TAG_IRQ:

                status = PnpiCmResourceToBiosIrq( buffer, List );
                break;

            case TAG_EXTENDED_IRQ:

                status = PnpiCmResourceToBiosExtendedIrq( buffer, List );
                break;

            case TAG_DMA:

                status = PnpiCmResourceToBiosDma( buffer, List );
                break;

            case TAG_START_DEPEND:

                ASSERT( tagName != TAG_START_DEPEND );
                break;

            case TAG_END_DEPEND:

                ASSERT( tagName != TAG_END_DEPEND );
                break;

            case TAG_IO:

                status = PnpiCmResourceToBiosIoPort( buffer, List );
                break;

            case TAG_IO_FIXED:

                status = PnpiCmResourceToBiosIoFixedPort( buffer, List );
                break;

            case TAG_MEMORY:

                status = PnpiCmResourceToBiosMemory( buffer, List );
                break;

            case TAG_MEMORY32:

                status = PnpiCmResourceToBiosMemory32( buffer, List );
                break;

            case TAG_MEMORY32_FIXED:

                status = PnpiCmResourceToBiosMemory32Fixed( buffer, List );
                break;

            case TAG_WORD_ADDRESS:

                status = PnpiCmResourceToBiosAddress( buffer, List );
                break;

           case TAG_DOUBLE_ADDRESS:

                status = PnpiCmResourceToBiosAddressDouble( buffer, List );
                break;

            case TAG_VENDOR:

                //
                // Ignore this tag
                //
                break;

            default: {

                //
                // Unknown tag. Skip it
                //
                ACPIPrint( (
                    ACPI_PRINT_WARNING,
                    "PnpBiosResourceToNtResources: TAG_UNKNOWN [tagName = %#02lx]\n",
                    tagName
                    ) );

                break;
            }

        } // switch
        //
        // Did we fail?
        //
        if (!NT_SUCCESS(status)) {

            break;

        }

        //
        // Move to the next descriptor
        //
        buffer += increment;
        tagName = *buffer;

    }

    if (!( NT_SUCCESS(status) )) {

        return status;

    }

    //
    // Check to see if we have consumed all of the appropriate resources...
    //
    if (PnpiCmResourceValidEmptyList( List ) ) {

        //
        // We failed to empty the list... <sigh>
        //
        return STATUS_UNSUCCESSFUL;

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\sleep.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sleep.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _SLEEP_H_
#define _SLEEP_H_

    NTSTATUS
    ACPIHandleSetPower (
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\root.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    root.h

Abstract:

    This module contains the root FDO handler for the NT Driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ROOT_H_
#define _ROOT_H_

    NTSTATUS
    ACPIRootIrpCancelRemoveOrStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpCompleteRoutine(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           Context
        );

    NTSTATUS
    ACPIRootIrpQueryCapabilities(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryDeviceRelations(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryBusRelations(
        IN  PDEVICE_OBJECT    DeviceObject,
        IN  PIRP              Irp,
        OUT PDEVICE_RELATIONS *PdeviceRelation
        );

    NTSTATUS
    ACPIRootIrpQueryInterface(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpQueryRemoveOrStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpRemoveDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpSetPower(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpStopDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    NTSTATUS
    ACPIRootIrpUnhandled(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIRootPowerCallBack(
        IN  PVOID   CallBackContext,
        IN  PVOID   Argument1,
        IN  PVOID   Argument2
        );

    NTSTATUS
    ACPIRootUpdateRootResourcesWithBusResources(
        VOID
        );

    NTSTATUS
    ACPIRootUpdateRootResourcesWithHalResources(
        VOID
        );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\rtl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rtl.h

Abstract:

    Some handy-dany RTL functions. These really should be part of the kernel

Author:

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#ifndef _RTL_H_
#define _RTL_H_

    PCM_RESOURCE_LIST
    RtlDuplicateCmResourceList(
        IN  POOL_TYPE           PoolType,
        IN  PCM_RESOURCE_LIST   ResourceList,
        IN  ULONG               Tag
        );

    ULONG
    RtlSizeOfCmResourceList(
        IN  PCM_RESOURCE_LIST   ResourceList
        );

    PCM_PARTIAL_RESOURCE_DESCRIPTOR
    RtlUnpackPartialDesc(
        IN  UCHAR               Type,
        IN  PCM_RESOURCE_LIST   ResList,
        IN  OUT PULONG          Count
        );

#endif // _RTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\syspower.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    syspower.c

Abstract:

    Contains all the code that deals with the system having to determine
    System Power State to Device Power State mappings

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    October 29th, 1998

--*/

#include "pch.h"

//
// Quick Lookup table to map S-States to SxD methods
//
ULONG   AcpiSxDMethodTable[] = {
    PACKED_SWD,
    PACKED_S0D,
    PACKED_S1D,
    PACKED_S2D,
    PACKED_S3D,
    PACKED_S4D,
    PACKED_S5D
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPISystemPowerGetSxD)
#pragma alloc_text(PAGE,ACPISystemPowerProcessRootMapping)
#pragma alloc_text(PAGE,ACPISystemPowerProcessSxD)
#pragma alloc_text(PAGE,ACPISystemPowerQueryDeviceCapabilities)
#pragma alloc_text(PAGE,ACPISystemPowerUpdateWakeCapabilities)
#endif

NTSTATUS
ACPISystemPowerDetermineSupportedDeviceStates(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  SYSTEM_POWER_STATE  SystemState,
    OUT ULONG               *SupportedDeviceStates
    )
/*++

Routine Description:

    This recursive routine looks at all the children of the current
    device extension and determines what device states might be supported
    at the specified system state. This is accomplished by looking at the
    _SxD methods and looking at the power plane information

Arguments:

    DeviceExtension         - The device whose children we want to know
                              information about
    SystemState             - The system state we want to know about
    SupportedDeviceStates   - Set bits represent supported D-states

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE      deviceState;
    EXTENSIONLIST_ENUMDATA  eled;
    KIRQL                   oldIrql;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       childExtension;
    SYSTEM_POWER_STATE      prSystemState;

    ASSERT(
        SystemState >= PowerSystemWorking &&
        SystemState <= PowerSystemShutdown
        );
    ASSERT( SupportedDeviceStates != NULL );

    //
    // Setup the data structure that we will use to walk the device extension
    // tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        &AcpiDeviceTreeLock,
        SiblingDeviceList,
        WALKSCHEME_REFERENCE_ENTRIES
        );

    //
    // Look at all children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled );
         ACPIExtListTestElement( &eled, (BOOLEAN) NT_SUCCESS(status) );
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Recurse first
        //
        status = ACPISystemPowerDetermineSupportedDeviceStates(
            childExtension,
            SystemState,
            SupportedDeviceStates
            );
        if (!NT_SUCCESS(status)) {

            continue;

        }

        //
        // Get the _SxD mapping for the device
        //
        status = ACPISystemPowerGetSxD(
            childExtension,
            SystemState,
            &deviceState
            );
        if (NT_SUCCESS( status ) ) {

            //
            // We support this D-state
            //
            *SupportedDeviceStates |= (1 << deviceState );

            ACPIDevPrint( (
                ACPI_PRINT_SXD,
                childExtension,
                " S%x->D%x\n",
                (SystemState - 1),
                (deviceState - 1)
                ) );

            //
            // Don't bother looking at the _PRx methods
            //
            continue;

        } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // If we hit another error, then we should continue now
            // Note that continuing will cause us to terminate the loop
            //
            ACPIDevPrint( (
                ACPI_PRINT_FAILURE,
                childExtension,
                " - ACPISystemPowerdetermineSupportedDeviceStates = %08lx\n",
                status
                ) );
            continue;

        } else {

            //
            // If we got here, then that means that the childExtension doesn't
            // have a _SxD method, which is okay. We reset the status so that
            // the loop test will succeed, or at least won't fail because there
            // wasn't an _SxD method.
            //
            status = STATUS_SUCCESS;

        }

        //
        // We are going to play with the power nodes, so we must be holding
        // the power lock
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Look at all the device states that might be supported via
        // the _PR methods
        //
        for (deviceState = PowerDeviceD0;
             deviceState <= PowerDeviceD2;
             deviceState++) {

            prSystemState = ACPISystemPowerDetermineSupportedSystemState(
                 childExtension,
                 deviceState
                 );
            if (prSystemState >= SystemState) {

                //
                // This d-state maps to a deeper S-state than what we
                // are looking for, so we should be implicitly supporting
                // this d-state for the current S-state
                //
                *SupportedDeviceStates |= (1 << deviceState);

                ACPIDevPrint( (
                    ACPI_PRINT_SXD,
                    childExtension,
                    " PR%x maps to S%x, so S%x->D%x\n",
                    (deviceState - 1),
                    (prSystemState - 1),
                    (SystemState - 1),
                    (deviceState - 1)
                    ) );

            }

        }

        //
        // Done with the lock
        //
        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

DEVICE_POWER_STATE
ACPISystemPowerDetermineSupportedDeviceWakeState(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at the PowerInformation structure and determines
    the D-State that is supported by the wake state

    As a rule of thumb, if the S-State is not supported, then we
    return PowerDeviceUnspecified

    Note: The parent is holding the AcpiPowerLock

Arguments:

    DeviceExtension     - The extension that we wish to check

Return Value:

    DEVICE_POWER_STATE

--*/
{
    DEVICE_POWER_STATE      deviceState = PowerDeviceMaximum;
    PACPI_DEVICE_POWER_NODE deviceNode;

    deviceNode = DeviceExtension->PowerInfo.PowerNode[PowerDeviceUnspecified];
    while (deviceNode != NULL) {

        //
        // Does the current device node support a lower device then the
        // current maximum device state?
        //
        if (deviceNode->AssociatedDeviceState < deviceState) {

            //
            // Yes, so this is the new maximum system state
            //
            deviceState = deviceNode->AssociatedDeviceState;

        }
        deviceNode = deviceNode->Next;

    }

    //
    // PowerSystemMaximum is not a valid entry. So if that is what we would
    // return, then change that to return PowerSystemUnspecified
    //
    if (deviceState == PowerDeviceMaximum) {

        deviceState = PowerDeviceUnspecified;

    }
    return deviceState;
}

SYSTEM_POWER_STATE
ACPISystemPowerDetermineSupportedSystemState(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  DeviceState
    )
/*++

Routine Description:

    This routine looks at the PowerInformation structure and determines
    the S-State that is supported by the D-state

    As a rule of thumb, if the D-State is not supported, then we
    return PowerSystemUnspecified

    Note: The parent is holding the AcpiPowerLock

Arguments:

    DeviceExtension     - The extension that we wish to check
    DeviceState         - The state that we wish to sanity check

Return Value:

    SYSTEM_POWER_STATE

--*/
{
    PACPI_DEVICE_POWER_NODE deviceNode;
    SYSTEM_POWER_STATE      systemState = PowerSystemMaximum;

    if (DeviceState == PowerDeviceD3) {

        goto ACPISystemPowerDetermineSupportedSystemStateExit;

    }

    deviceNode = DeviceExtension->PowerInfo.PowerNode[DeviceState];
    while (deviceNode != NULL) {

        //
        // Does the current device node support a lower system then the
        // current maximum system state?
        //
        if (deviceNode->SystemState < systemState) {

            //
            // Yes, so this is the new maximum system state
            //
            systemState = deviceNode->SystemState;

        }
        deviceNode = deviceNode->Next;

    }

ACPISystemPowerDetermineSupportedSystemStateExit:
    //
    // PowerSystemMaximum is not a valid entry. So if that is what we would
    // return, then change that to return PowerSystemUnspecified
    //
    if (systemState == PowerSystemMaximum) {

        systemState = PowerSystemUnspecified;

    }
    return systemState;
}

NTSTATUS
ACPISystemPowerGetSxD(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  SYSTEM_POWER_STATE  SystemState,
    OUT DEVICE_POWER_STATE  *DeviceState
    )
/*++

Routine Description:

    This is the worker function that is called when we want to run an
    SxD method. We give the function an S-State, and we get back a
    D-State.

Arguments:

    DeviceExtension - The device to run the SxD on
    SystemState     - The S-state to determine the D-State for
    DeviceState     - Where we store the answer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       value;

    PAGED_CODE();

    //
    // Assume that we don't find an answer
    //
    *DeviceState = PowerDeviceUnspecified;

    //
    // We want this code to run even though there is no namespace object
    // for the device. Since we don't want to add a check to GetNamedChild
    // that checks for null, we need to handle this special case here
    //
    if ( (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) ||
         (DeviceExtension->Flags & DEV_PROP_FAILED_INIT) ) {

        return STATUS_OBJECT_NAME_NOT_FOUND;

    }

    //
    // Evaluate the control method
    //
    status = ACPIGetIntegerSync(
        DeviceExtension,
        AcpiSxDMethodTable[SystemState],
        &value,
        NULL
        );
    if (NT_SUCCESS(status)) {

        //
        // Convert this number to a D-State
        //
        *DeviceState = ACPIDeviceMapPowerState( value );

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // HACKHACK --- Program Management wants us to force the PCI Root Bus
        // mappings for S1 to be D1. So look for a device node that has
        // both the PCI flag and the HID flag set, and if so, return that
        // we support D1
        //
        if (SystemState == PowerSystemSleeping1 &&
            (DeviceExtension->Flags & DEV_MASK_HID) &&
            (DeviceExtension->Flags & DEV_CAP_PCI) ) {

            *DeviceState = PowerDeviceD1;
            status = STATUS_SUCCESS;

        }

#if DBG
    } else {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerGetSxD: Cannot run _S%cD - 0x%08lx\n",
            (SystemState == 0 ? 'w' : '0' + (UCHAR) (SystemState - 1) ),
            status
            ) );
#endif

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
ACPISystemPowerInitializeRootMapping(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine is responsible for initializing the S->D mapping for the
    root device extension

Arguments:

    DeviceExtension     - Pointer to the root device extension
    DeviceCapabilitites - DeviceCapabilitites

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             sxdFound;
    DEVICE_POWER_STATE  deviceMap[PowerSystemMaximum];
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  sysIndex;

    //
    // Can we actually do any real work here?
    //
    if ( (DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) ||
         (DeviceExtension->DeviceState != Started) ) {

        goto ACPISystemPowerInitializeRootMappingExit;

    }

    //
    // Initialize the root mapping
    //
    RtlZeroMemory( deviceMap, sizeof(DEVICE_POWER_STATE) * PowerSystemMaximum );

    //
    // Copy the mapping from the device extension. See the comment at the
    // end as to why we don't grab a spinlock
    //
    IoCopyDeviceCapabilitiesMapping(
       DeviceExtension->PowerInfo.DevicePowerMatrix,
       deviceMap
       );

    //
    // Make sure that S0->D0
    //
    deviceMap[PowerSystemWorking]  = PowerDeviceD0;

    //
    // Special case the fact that someone one might want to have the
    // HAL return a different template. If the capabilities that we got
    // handed have some values in them, have them override our defaults
    //
    for (sysIndex = PowerSystemSleeping1;
         sysIndex <= PowerSystemShutdown;
         sysIndex++) {

        if (DeviceCapabilities->DeviceState[sysIndex] != PowerDeviceUnspecified) {

            deviceMap[sysIndex] = DeviceCapabilities->DeviceState[sysIndex];

        }

    }

    //
    // Porcess the SxD methods if there are any
    //
    status = ACPISystemPowerProcessSxD(
        DeviceExtension,
        deviceMap,
        &sxdFound
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "- ACPISystemPowerProcessSxD = %08lx\n",
            status
            ) );
        return status;

    }

    //
    // Make sure that the Shutdown case doesn't map to PowerDeviceUnspecified
    // If it does, then it should really map to PowerDeviceD3
    //
    if (deviceMap[PowerSystemShutdown] == PowerDeviceUnspecified) {

        deviceMap[PowerSystemShutdown] = PowerDeviceD3;

    }

    //
    // Look at all the children capabilities to help us decide the root
    // mapping
    //
    status = ACPISystemPowerProcessRootMapping(
        DeviceExtension,
        deviceMap
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            " - ACPISystemPowerProcessRootMapping = %08lx\n",
            status
            ) );
        goto ACPISystemPowerInitializeRootMappingExit;

    }

    //
    // If we have reached this point, then we have build the SxD table
    // and never need to do so again
    //
    ACPIInternalUpdateFlags(
        &(DeviceExtension->Flags),
        DEV_PROP_BUILT_POWER_TABLE,
        FALSE
        );

#if DBG
    //
    // We haven't updated the device extension yet, so we can still do this
    // at this point in the game
    //
    ACPIDebugDeviceCapabilities(
        DeviceExtension,
        DeviceCapabilities,
        "Initial"
        );
    ACPIDebugPowerCapabilities( DeviceExtension, "Before Update" );
#endif

    //
    // Copy the mapping to the device extension
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    IoCopyDeviceCapabilitiesMapping(
       deviceMap,
       DeviceExtension->PowerInfo.DevicePowerMatrix
       );
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

#if DBG
    ACPIDebugPowerCapabilities( DeviceExtension, "After Update" );
#endif

ACPISystemPowerInitializeRootMappingExit:
    //
    // Hmm.. I'm tempted to grab a spinlock here, but since we cannot
    // updating the capabilities for this device, I think it is safe
    // to not do so. We need to grab the spinlock when setting these
    // values so that we can sync with the power code
    //

    //
    // Copy the power capabilities to their final location
    //
    IoCopyDeviceCapabilitiesMapping(
        DeviceExtension->PowerInfo.DevicePowerMatrix,
        DeviceCapabilities->DeviceState
        );
#if DBG
    ACPIDebugDeviceCapabilities(DeviceExtension, DeviceCapabilities, "Done" );
#endif

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerProcessRootMapping(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  DeviceMap[PowerSystemMaximum]
    )
/*++

Routine Description:

    This routine is called by the FDO to figure out what the minimal set
    of capabilities for each s state are. These then become the root
    capabilitites

Arguments:

    DeviceExtension - The root device extension
    DeviceMap       - The current mapping

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  deviceState;
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  systemState;
    ULONG               supportedDeviceStates;

    PAGED_CODE();

    //
    // Loop on all the system supported states
    //
    for (systemState = PowerSystemSleeping1;
         systemState <= PowerSystemShutdown;
         systemState++) {

        //
        // Do we support this state?
        //
        if (!(AcpiSupportedSystemStates & (1 << systemState) ) ) {

            continue;

        }

        //
        // We always support the D3 state
        //
        supportedDeviceStates = (1 << PowerDeviceD3);

        //
        // Determine the supported Device states for this System state
        //
        status = ACPISystemPowerDetermineSupportedDeviceStates(
            DeviceExtension,
            systemState,
            &supportedDeviceStates
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_WARNING,
                DeviceExtension,
                "Cannot determine D state for S%x - %08lx\n",
                (systemState - 1),
                status
                ) );
            DeviceMap[systemState] = PowerDeviceD3;
            continue;

        }

        //
        // Starting from the device states that we currently are set to
        // (which we would have gotten by running the _SxD method on the
        // \_SB), look to see if we can use a lower D-state instead.
        //
        // Note: It is *VERY* important to remember that *ALL* devices can
        // support D3, so the following loop will *always* terminate in the
        // D3 case.
        //
        for (deviceState = DeviceMap[systemState];
             deviceState <= PowerDeviceD3;
             deviceState++) {

            //
            // Is this a supported device state?
            //
            if (!(supportedDeviceStates & (1 << deviceState) ) ) {

                //
                // no? then look at the next one
                //
                continue;

            }

            //
            // This is the D-state that we need to use
            //
            DeviceMap[systemState] = deviceState;
            break;

        }

    }

    //
    // Always return success
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerProcessSxD(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  DEVICE_POWER_STATE  CurrentMapping[PowerSystemMaximum],
    IN  PBOOLEAN            MatchFound
    )
/*++

Routine Description:

    This routine updates the current S-to-D mapping with the information
    in the ACPI namespace. If it finds any _SxD routines, then it tells the
    caller

Arguments:

    DeviceExtension - Device to check
    CurrentMapping  - The current mapping to modify
    MatchFound      - Where to indicate if we have found a match or not

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  dState;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  sState;

    PAGED_CODE();
    ASSERT( MatchFound != NULL );

    //
    // Assume no match
    //
    *MatchFound = FALSE;

    //
    // Loop for all the S-States that we care about
    //
    for (sState = PowerSystemWorking; sState < PowerSystemMaximum; sState++) {

        //
        // Does the system support this S-State?
        //
        if (!(AcpiSupportedSystemStates & (1 << sState)) ) {

            //
            // This S-state is not supported by the system. Mark it as such
            //
            CurrentMapping[sState] = PowerDeviceUnspecified;
            continue;

        }

        //
        // Evaluate the control method
        //
        status = ACPISystemPowerGetSxD( DeviceExtension, sState, &dState );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // Not a critical error
            //
            continue;

        }
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPISystemPowerProcessSxD: Cannot Evaluate _SxD - 0x%08lx\n",
                status
                ) );
            continue;

        }

        //
        // Match found
        //
        *MatchFound = TRUE;

        //
        // Is this value greater then the number within the table?
        //
        if (dState > CurrentMapping[sState]) {

            //
            // Yes, so we have a new mapping
            //
            CurrentMapping[sState] = dState;

        }

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerQueryDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    Any routine that needs to know the device capabilities will call this
    function for the power capabilities

Arguments:

    DeviceExtension     - The extension whose capabilities we want
    DeviceCapabilities  - Where to store the capabilities

Return Value:

    NTSTATUS

--*/
{
#if DBG
    BOOLEAN                 dumpAtEnd = FALSE;
#endif
    DEVICE_CAPABILITIES     parentCapabilities;
    NTSTATUS                status;
    PDEVICE_CAPABILITIES    baseCapabilities;

    PAGED_CODE();

    //
    // We only need to do this once
    //
    if (!(DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) ) {

#if DBG
        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            DeviceCapabilities,
            "From PDO"
            );
#endif

        //
        // Our next action depends on wether or not we are a filter (only)
        // or a PDO
        //
        if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
            !(DeviceExtension->Flags & DEV_TYPE_PDO) ) {

            //
            // In this case, our base capabilities are the ones that have
            // already been passed to us
            //
            baseCapabilities = DeviceCapabilities;

        } else {

            //
            // We must get the capabilities of the parent device
            //
            status = ACPIInternalGetDeviceCapabilities(
                DeviceExtension->ParentExtension->DeviceObject,
                &parentCapabilities
                );
            if (!NT_SUCCESS(status)) {

                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    " - Could not get parent caps - %08lx\n",
                    status
                    ) );
                return status;

            }

            //
            // our base capabilities are the one that we just fetched
            //
            baseCapabilities = &parentCapabilities;

#if DBG
            ACPIDebugDeviceCapabilities(
                DeviceExtension,
                baseCapabilities,
                "From Parent"
                );
#endif

        }

#if DBG
        ACPIDebugPowerCapabilities( DeviceExtension, "Before Update" );
#endif

        //
        // Update our capabilities with those of our parent
        //
        status = ACPISystemPowerUpdateDeviceCapabilities(
            DeviceExtension,
            baseCapabilities,
            DeviceCapabilities
            );
        if (!NT_SUCCESS(status)) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                " - Could not update caps - %08lx\n",
                status
                ) );

            //
            // If this is a pdo, then this is a fatal error
            //
            if ( (DeviceExtension->Flags & DEV_TYPE_PDO) ) {

                ACPIInternalError( ACPI_SYSPOWER );

            }
            return status;

        }
#if DBG
        ACPIDebugPowerCapabilities( DeviceExtension, "After Update" );
        dumpAtEnd = TRUE;
#endif

        //
        // Never do this again
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_BUILT_POWER_TABLE,
            FALSE
            );

    }

    //
    // Hmm.. I'm tempted to grab a spinlock here, but since we cannot
    // updating the capabilities for this device, I think it is safe
    // to not do so. We need to grab the spinlock when setting these
    // values so that we can sync with the power code
    //

    //
    // Okay, at this point, we think the device extension's capabilities
    // are appropriate for the stack at hand. Let's copy them over
    //
    IoCopyDeviceCapabilitiesMapping(
        DeviceExtension->PowerInfo.DevicePowerMatrix,
        DeviceCapabilities->DeviceState
        );

    //
    // then set those capabilities as well.
    //
    DeviceCapabilities->SystemWake = DeviceExtension->PowerInfo.SystemWakeLevel;
    DeviceCapabilities->DeviceWake = DeviceExtension->PowerInfo.DeviceWakeLevel;

    //
    // Set the other capabilities
    //
    DeviceCapabilities->DeviceD1 = DeviceExtension->PowerInfo.SupportDeviceD1;
    DeviceCapabilities->DeviceD2 = DeviceExtension->PowerInfo.SupportDeviceD2;
    DeviceCapabilities->WakeFromD0 = DeviceExtension->PowerInfo.SupportWakeFromD0;
    DeviceCapabilities->WakeFromD1 = DeviceExtension->PowerInfo.SupportWakeFromD1;
    DeviceCapabilities->WakeFromD2 = DeviceExtension->PowerInfo.SupportWakeFromD2;
    DeviceCapabilities->WakeFromD3 = DeviceExtension->PowerInfo.SupportWakeFromD3;

#if DBG
    if (dumpAtEnd) {

        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            DeviceCapabilities,
            "Done"
            );

    }
#endif

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateDeviceCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine updates the DevicePowerMatrix of the device extension with
    the current S to D mapping for the device.

    The BaseCapabilities are used as the template. That is, they provide
    values that we then modify.

    The DeviceCapabilities are the actual capabilities that are returned
    to the OS. Note that it is possible for the BaseCapabilities to the be
    same pointer as the DeviceCapabilities (if its a Filter).

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The device capabilities

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             matchFound;
    DEVICE_POWER_STATE  currentDState;
    DEVICE_POWER_STATE  currentMapping[PowerSystemMaximum];
    DEVICE_POWER_STATE  devIndex;
    DEVICE_POWER_STATE  deviceWakeLevel = PowerDeviceUnspecified;
    DEVICE_POWER_STATE  filterWakeLevel = PowerDeviceUnspecified;
    KIRQL               oldIrql;
    NTSTATUS            status          = STATUS_SUCCESS;
    SYSTEM_POWER_STATE  sysIndex;
    SYSTEM_POWER_STATE  supportedState;
    SYSTEM_POWER_STATE  systemWakeLevel = PowerSystemUnspecified;
    ULONG               interestingBits;
    ULONG               mask;
    ULONG               supported       = 0;
    ULONG               supportedPr     = 0;
    ULONG               supportedPs     = 0;
    ULONG               supportedWake   = 0;

    //
    // We should remember what the capabilities of the device. We need
    // to remember because we will be modifying these capabilities in
    // the next call (if required)
    //
    IoCopyDeviceCapabilitiesMapping(
        BaseCapabilities->DeviceState,
        currentMapping
        );

    //
    // Sanity checks
    //
    if (currentMapping[PowerSystemWorking] != PowerDeviceD0) {

#if DBG
        ACPIDebugDeviceCapabilities(
            DeviceExtension,
            BaseCapabilities,
            "PowerSystemWorking != PowerDeviceD0"
            );
#endif
//        ASSERT( currentMapping[PowerSystemWorking] == PowerDeviceD0 );
        currentMapping[PowerSystemWorking] = PowerDeviceD0;

    }

    //
    // Get the D-States that are supported by this extension
    //
    status = ACPIDevicePowerDetermineSupportedDeviceStates(
        DeviceExtension,
        &supportedPr,
        &supportedPs
        );
    if (!NT_SUCCESS(status)) {

        //
        // Hmm...
        //
        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPIDevicePowerDetermineSupportedDeviceStates = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // The supported index is the union of which _PR and which _PS are
    // present
    supported = (supportedPr | supportedPs);

    //
    // At this point, if there are no supported bits, then we should check
    // the device capabilities and what our parent supports
    //
    if (!supported) {

        //
        // Do some special checkin if we are a filter. We can only do the
        // following if the caps indicate that there is a D0 or D3 support
        //
        if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
            !(DeviceExtension->Flags & DEV_TYPE_PDO)    &&
            !(DeviceCapabilities->DeviceD1)             &&
            !(DeviceCapabilities->DeviceD2) ) {

            //
            // This is a filter, and we don't know any of its power caps, so
            // the thing to do (because of Video) is to decide to not touch
            // the mapping
            //
            goto ACPISystemPowerUpdateDeviceCapabilitiesExit;

        }

        //
        // Assume that we support D0 and D3
        //
        supported = (1 << PowerDeviceD0) | (1 << PowerDeviceD3);

        //
        // Do we support D1?
        //
        if (DeviceCapabilities->DeviceD1) {

            supported |= (1 << PowerDeviceD1);

        }

        //
        // Do we support D2?
        //
        if (DeviceCapabilities->DeviceD2) {

            supported |= (1 << PowerDeviceD2);

        }

    }

    //
    // We also need to update the Wake Capabilities. We do this so
    // that we get the correct SystemWakeLevel based on the information
    // present
    //
    status = ACPISystemPowerUpdateWakeCapabilities(
        DeviceExtension,
        BaseCapabilities,
        DeviceCapabilities,
        currentMapping,
        &supportedWake,
        &systemWakeLevel,
        &deviceWakeLevel,
        &filterWakeLevel
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerUpdateWakeCapabilities = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // Now, we must look at the base capabilities and determine
    // if we need to modify them
    //
    for (sysIndex = PowerSystemSleeping1; sysIndex <= PowerSystemShutdown; sysIndex++) {

        //
        // Does the system support this S-State?
        //
        if (!(AcpiSupportedSystemStates & (1 << sysIndex) ) ) {

            continue;

        }

        //
        // See if there is an _SxD for this state
        //
        status = ACPISystemPowerGetSxD( DeviceExtension, sysIndex, &devIndex );
        if (NT_SUCCESS(status)) {

            //
            // We have found a match. Is it better then the current mapping?
            //
            if (devIndex > currentMapping[sysIndex]) {

                //
                // Yes, so we have a new mapping
                //
                currentMapping[sysIndex] = devIndex;

            }
            continue;

        } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "ACPISystemPowerUpdateDeviceCapabilities: Cannot Evalutate "
                "_SxD - 0x%08lx\n",
                status
                ) );

        }

        //
        // What is the base d-state for the current mapping
        //
        currentDState = currentMapping[sysIndex];

        //
        // Remember that we didn't find a match
        //
        matchFound = FALSE;

        //
        // Calculate the interesting pr bits. Do this by ignoring any bit
        // less then the one indicated by the current mapping
        //
        mask = (1 << currentDState) - 1;
        interestingBits = supported & ~mask;

        //
        // While there are interesting bits, look to see if they are
        // available for the current state
        //
       while (interestingBits) {

            //
            // Determine what the highest possible D state that we can
            // have on this device. Clear what we are looking at from
            // the interesting bits
            //
            devIndex = (DEVICE_POWER_STATE) RtlFindLeastSignificantBit(
                (ULONGLONG) interestingBits
                );
            mask = (1 << devIndex);
            interestingBits &= ~mask;

            //
            // If this S-state is less than the wake level of the device
            // then we should try to find a D-state that we can wake from
            //
            if (sysIndex <= systemWakeLevel) {

                //
                // If we can wake from a deeper state, then lets consider
                // those bits
                //
                if ( (supportedWake & interestingBits) ) {

                    continue;

                }

                //
                // Don't consider anything deeper than the deviceWake,
                // although this should be taken care in the supportedWake
                // test
                //
                if (devIndex == filterWakeLevel) {

                    matchFound = TRUE;
                    currentMapping[sysIndex] = devIndex;

                }

            }

            //
            // If our only choice is D3, than we automatically match that
            // since all S states can map to D3.
            //
            if (devIndex == PowerDeviceD3) {

                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

            //
            // If we are looking at a _PR entry, then we need to determine
            // if the power plane actually supports this S state
            //
            if (supportedPr == 0) {

                //
                // We are looking at a _PS entry, and automatically match
                // those
                //
                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

            //
            // We must holding a spinlock for the following
            //
            KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

            //
            // What system state does this pr state support. If the
            // If the function does not support the D state, then Power
            // SystemUnspecified is returned. The only time that we
            // expect this value is when devIndex == PowerDeviceD3
            //
            supportedState = ACPISystemPowerDetermineSupportedSystemState(
                DeviceExtension,
                devIndex
                );
            if (supportedState == PowerSystemUnspecified) {

                //
                // Paranoia
                //
                ACPIDevPrint( (
                    ACPI_PRINT_CRITICAL,
                    DeviceExtension,
                    "D%x returned PowerSystemUnspecified!\n",
                    (devIndex - 1)
                    ) );
                KeBugCheckEx(
                    ACPI_BIOS_ERROR,
                    ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                    (ULONG_PTR) DeviceExtension,
                    0,
                    devIndex
                    );

            }

            //
            // Done with the power lock
            //
            KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

            //
            // The only way to match is if the return value from
            // ACPISystemPowerDetermineSupportedSystemState returns an S
            // state greater than or equal to the one that we are currently
            // processing.
            //
            if (supportedState >= sysIndex) {

                matchFound = TRUE;
                currentMapping[sysIndex] = devIndex;
                break;

            }

        } // while

        //
        // If we didn't find a match at this point, that should be fatal
        //
        if (!matchFound) {

            ACPIDevPrint( (
                ACPI_PRINT_CRITICAL,
                DeviceExtension,
                "No match found for S%x\n",
                (sysIndex - 1)
                ) );
            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                (ULONG_PTR) DeviceExtension,
                1,
                sysIndex
                );

        }

    } // for

ACPISystemPowerUpdateDeviceCapabilitiesExit:

    //
    // Now, we re-run the wake capabilities to make sure that we get the correct
    // device wake level
    //
    status = ACPISystemPowerUpdateWakeCapabilities(
        DeviceExtension,
        BaseCapabilities,
        DeviceCapabilities,
        currentMapping,
        &supportedWake,
        &systemWakeLevel,
        &deviceWakeLevel,
        &filterWakeLevel
        );
    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPISystemPowerUpdateWakeCapabilities = 0x%08lx\n",
            status
            ) );
        return status;

    }

    //
    // We must holding a spinlock for the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Copy the mapping back onto the device
    //
    IoCopyDeviceCapabilitiesMapping(
        currentMapping,
        DeviceExtension->PowerInfo.DevicePowerMatrix
        );

    //
    // Remember the system wake level, device wake level, and what
    // the various support Wake and Power states are
    //
    DeviceExtension->PowerInfo.DeviceWakeLevel = deviceWakeLevel;
    DeviceExtension->PowerInfo.SystemWakeLevel = systemWakeLevel;
    DeviceExtension->PowerInfo.SupportDeviceD1 = ( ( supported & ( 1 << PowerDeviceD1 ) ) != 0);
    DeviceExtension->PowerInfo.SupportDeviceD2 = ( ( supported & ( 1 << PowerDeviceD2 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD0 = ( ( supportedWake & ( 1 << PowerDeviceD0 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD1 = ( ( supportedWake & ( 1 << PowerDeviceD1 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD2 = ( ( supportedWake & ( 1 << PowerDeviceD2 ) ) != 0);
    DeviceExtension->PowerInfo.SupportWakeFromD3 = ( ( supportedWake & ( 1 << PowerDeviceD3 ) ) != 0);

    //
    // Done with the power lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Again, because we allowed device extension with no name space objects
    // to use this function, we must make sure not to set the ACPI_POWER
    // property unless they have a name space object
    //
    if (!(DeviceExtension->Flags & DEV_PROP_NO_OBJECT)) {

        //
        // Set the ACPI Power Management bits
        //
        ACPIInternalUpdateFlags(
            &(DeviceExtension->Flags),
            DEV_PROP_ACPI_POWER,
            FALSE
            );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilities(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    ParentCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping
    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{

    PAGED_CODE();

    if ( (DeviceExtension->Flags & DEV_TYPE_FILTER) &&
        !(DeviceExtension->Flags & DEV_TYPE_PDO) ) {

        return ACPISystemPowerUpdateWakeCapabilitiesForFilters(
            DeviceExtension,
            BaseCapabilities,
            DeviceCapabilities,
            CurrentMapping,
            SupportedWake,
            SystemWakeLevel,
            DeviceWakeLevel,
            FilterWakeLevel
            );

    } else {

        if (FilterWakeLevel != NULL) {

            *FilterWakeLevel = PowerDeviceUnspecified;

        }

        return ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
            DeviceExtension,
            BaseCapabilities,
            DeviceCapabilities,
            CurrentMapping,
            SupportedWake,
            SystemWakeLevel,
            DeviceWakeLevel,
            FilterWakeLevel
            );
    }

}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilitiesForFilters(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities. This version of the function uses the
    devices states that the device can wake from to determine what the
    appropriate system level is.

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping

    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             noPdoWakeSupport = FALSE;
    BOOLEAN             foundDState = FALSE;
    DEVICE_POWER_STATE  deviceWake;
    DEVICE_POWER_STATE  deviceTempWake;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PACPI_POWER_INFO    powerInfo;
    SYSTEM_POWER_STATE  systemWake;
    SYSTEM_POWER_STATE  tempWake;

    UNREFERENCED_PARAMETER( BaseCapabilities );

    //
    // Use the capabilities from the Device
    //
    deviceWake = DeviceCapabilities->DeviceWake;
    systemWake = DeviceCapabilities->SystemWake;

    //
    // Does the device support wake from D0? D1? D2? D3?
    //
    if (DeviceCapabilities->WakeFromD0) {

        *SupportedWake |= (1 << PowerDeviceD0 );

    }
    if (DeviceCapabilities->WakeFromD1) {

        *SupportedWake |= (1 << PowerDeviceD1 );

    }
    if (DeviceCapabilities->WakeFromD2) {

        *SupportedWake |= (1 << PowerDeviceD2 );

    }
    if (DeviceCapabilities->WakeFromD3) {

        *SupportedWake |= (1 << PowerDeviceD3 );

    }

    //
    // If we don't support any wake states in the PDO (ie: DeviceWake or
    // SystemWake is 0) then we should remember that for future considerations
    //
    if (deviceWake == PowerDeviceUnspecified ||
        systemWake == PowerSystemUnspecified) {

        noPdoWakeSupport = TRUE;
        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;

    }

    //
    // If we support the device wake (ie: there is a _PRW), then we
    // should take the minimum of the systemWake we got from the parent
    // and the value that is stored in the _PRW
    //
    if ( (DeviceExtension->Flags & DEV_CAP_WAKE) ) {

        //
        // Need power lock for the following.
        //
        KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

        //
        // Remember the current system wake level
        //
        tempWake = DeviceExtension->PowerInfo.SystemWakeLevel;

        //
        // See what D-state (if any) that the power plane information
        // maps to
        //
        deviceTempWake = ACPISystemPowerDetermineSupportedDeviceWakeState(
            DeviceExtension
            );

        KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

        //
        // Take the minimum
        //
        if (tempWake < systemWake || noPdoWakeSupport) {

            systemWake = tempWake;

        }

        //
        // Did the PRW have useful information for us?
        //
        if (deviceTempWake != PowerDeviceUnspecified) {

            //
            // Note that in this case, they are basically overriding all
            // other supported wake up states, so the thing to do is only
            // remember this wake level
            //
            foundDState = TRUE;
            deviceWake = deviceTempWake;

        }

        //
        // See if there is a device wake specified for this S-state?
        //
        status = ACPISystemPowerGetSxD(
            DeviceExtension,
            tempWake,
            &deviceTempWake
            );
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            status = ACPISystemPowerGetSxD(
                DeviceExtension,
                systemWake,
                &deviceTempWake
                );

        }
        if (NT_SUCCESS(status)) {

            //
            // Note that in this case, they are basically overriding all other
            // supported Wake up states, so the thing to do is only remember
            // this wake level
            //
            foundDState = TRUE;
            deviceWake = deviceTempWake;

        }

        if (!foundDState) {

            //
            // Crossreference the system wake level with the matrix
            // Need spinlock to do this
            //
            deviceWake = CurrentMapping[systemWake];

            //
            // If this value isn't known, then we guess that it can
            // from D3. In other words, unless they have made some
            // explicity mechanism to tell which D-state to wake from,
            // assume that we can do it from D3
            //
            if (deviceWake == PowerDeviceUnspecified) {

                deviceWake = PowerDeviceD3;

            }

        }

        //
        // We should only check to see if the D-state is a wakeable state
        // in the parent only if the parent claims to support wake
        //
        if (!noPdoWakeSupport) {

            //
            // The logic behind the following is that if we are a filter, even
            // if we support device wake (that is the _PRW is in the PCI device
            // itself, not for the root PCI bus), than we still need to make sure
            // that the D-State that we mapped to is one that is supported by
            // the hardware.
            //
            for (;deviceWake < PowerDeviceMaximum; deviceWake++) {

                //
                // If we we support this wake state, then we can stop
                //
                if (*SupportedWake & (1 << deviceWake) ) {

                    break;

                }

            }

        }

        //
        // If we got here, and the D-state is PowerDeviceMaximum, then we
        // don't really support wake on the device
        //
        if (deviceWake == PowerDeviceMaximum ||
            deviceWake == PowerDeviceUnspecified) {

            deviceWake = PowerDeviceUnspecified;
            systemWake = PowerSystemUnspecified;
            *SupportedWake = 0;

        } else {

            //
            // In this situation, we will end up only supporting this wake state
            //
            *SupportedWake = (1 << deviceWake );

        }

    } else {

        //
        // See if there is a device wake specified for this S-state
        //
        status = ACPISystemPowerGetSxD(
            DeviceExtension,
            systemWake,
            &deviceTempWake
            );
        if (NT_SUCCESS(status)) {

            //
            // Find the best supported wake level
            //
            for (;deviceTempWake > PowerDeviceUnspecified; deviceTempWake--) {

                if ( (*SupportedWake & (1 << deviceTempWake) ) ) {

                    deviceWake = deviceTempWake;
                    break;

                }

            }

        }

        //
        // Make sure that the system wake level is a valid one
        //
        for (; systemWake > PowerSystemUnspecified; systemWake--) {

            //
            // Since S-States that we don't support map to
            // PowerDeviceUnspecified, we cannot consider any of those S
            // states in this test. We also cannot consider them for other
            // obvious reasons as well
            //*
            if (!(AcpiSupportedSystemStates & (1 << systemWake) ) ||
                 (CurrentMapping[systemWake] == PowerDeviceUnspecified) ) {

                continue;

            }

            //
            // Does this S-state support the given S-State?
            //
            if (CurrentMapping[systemWake] <= deviceWake) {

                break;

            }

            //
            // Does the device state for the current system wake mapping
            // allow wake-from sleep?
            //
            if (*SupportedWake & (1 << CurrentMapping[systemWake]) ) {

                //
                // Yes? then we had better update our idea of what the
                // device wake state should be...
                //
                deviceWake = CurrentMapping[systemWake];
                break;

            }

        }

        //
        // If we got into a situation were we cannot find a single S-state
        // that we can wake from, then we must make sure that the device
        // wake is null
        //
        if (systemWake == PowerSystemUnspecified) {

            //
            // Remember that the device wake and supported wake states
            // are null
            //
            deviceWake = PowerDeviceUnspecified;
            *SupportedWake = 0;

        }

    }

    //
    // Return the proper device wake and system wake values
    //
    if (SystemWakeLevel != NULL) {

        *SystemWakeLevel = systemWake;

    }
    if (DeviceWakeLevel != NULL) {

        *DeviceWakeLevel = deviceWake;

    }
    if (FilterWakeLevel != NULL) {

        *FilterWakeLevel = deviceWake;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
    IN  PDEVICE_EXTENSION       DeviceExtension,
    IN  PDEVICE_CAPABILITIES    BaseCapabilities,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
    IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
    IN  ULONG                   *SupportedWake,
    IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
    IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
    IN  DEVICE_POWER_STATE      *FilterWakeLevel
    )
/*++

Routine Description:

    This routine calculates the Wake Capabilities of the device based on
    the present capabilities. This version of the function uses the
    system state that the device can wake from to determine what the
    appropriate device level is.

Arguments:

    DeviceExtension     - The device whose capabilities we want
    BaseCapabilities    - The base values
    DeviceCapabilities  - The capabilities for the device
    CurrentMapping      - The current S->D mapping
    SupportedWake       - BitMap of the supported Wake states
    SystemWakeLevel     - The S-State that we can wake up from
    DeviceWakeLevel     - The D-State that we can wake up from

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             foundDState = FALSE;
    DEVICE_POWER_STATE  deviceWake;
    DEVICE_POWER_STATE  deviceTempWake;
    DEVICE_POWER_STATE  filterWake = PowerDeviceUnspecified;
    KIRQL               oldIrql;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  systemWake;

    UNREFERENCED_PARAMETER( DeviceCapabilities );
    UNREFERENCED_PARAMETER( BaseCapabilities );

    //
    // Use the capabilities of the device
    //
    if (!(DeviceExtension->Flags & DEV_CAP_WAKE) ) {

        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;
        goto ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit;

    }

    //
    // Hold the lock for the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Use the wake level that we know about. If this wakelevel
    // isn't supported, than there is a bios error
    //
    systemWake = DeviceExtension->PowerInfo.SystemWakeLevel;
    deviceTempWake = ACPISystemPowerDetermineSupportedDeviceWakeState(
        DeviceExtension
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Sanity check
    //
    if (!(AcpiSupportedSystemStates & (1 << systemWake) ) ) {

#if 0
        if (!(AcpiOverrideAttributes & ACPI_OVERRIDE_MP_SLEEP) ) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_CANNOT_MAP_SYSTEM_TO_DEVICE_STATES,
                (ULONG_PTR) DeviceExtension,
                2,
                systemWake
                );

        }
#endif

        deviceWake = PowerDeviceUnspecified;
        systemWake = PowerSystemUnspecified;
        goto ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit;

    }

    if (deviceTempWake != PowerDeviceUnspecified) {

        //
        // Note that in this case, they are basically overriding all
        // other supported wake up states, so the thing to do is only
        // remember this wake level
        //
        foundDState = TRUE;
        deviceWake = deviceTempWake;
        filterWake = deviceTempWake;
        *SupportedWake = (1 << deviceWake );

    }

    //
    // See if there is an SxD method that will give us a hint
    //
    status = ACPISystemPowerGetSxD(
        DeviceExtension,
        systemWake,
        &deviceTempWake
        );
    if (NT_SUCCESS(status)) {

        //
        // Note that in this case, they are basically overriding all other
        // supported Wake up states, so the thing to do is only remember
        // this wake level
        deviceWake = deviceTempWake;
        filterWake = deviceTempWake;
        foundDState = TRUE;

    }

    if (!foundDState) {

        //
        // Crossreference the system wake level with the matrix
        // Need spinlock to do this
        //
        deviceWake = CurrentMapping[systemWake];

        //
        // If this value isn't known, then we guess that it can
        // from D3. In other words, unless they have made some
        // explicity mechanism to tell which D-state to wake from,
        // assume that we can do it from D3
        //
        if (deviceWake == PowerDeviceUnspecified) {

            deviceWake = PowerDeviceD3;

        }

    }

ACPISystemPowerUpdateWakeCapabilitiesForPDOsExit:

    //
    // Set the return values
    //
    if (deviceWake != PowerDeviceUnspecified) {

        *SupportedWake = (1 << deviceWake );

    } else {

        *SupportedWake = 0;
    }

    if (SystemWakeLevel != NULL) {

        *SystemWakeLevel = systemWake;

    }
    if (DeviceWakeLevel != NULL) {

        *DeviceWakeLevel = deviceWake;

    }
    if (FilterWakeLevel != NULL) {

        *FilterWakeLevel = filterWake;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\syspower.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    syspower.h

Abstract:

    Contains all the code that deals with the system having to determine
    System Power State to Device Power State mappings

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    October 29th, 1998

--*/

#ifndef _SYSPOWER_H_
#define _SYSPOWER_H_

    #define IoCopyDeviceCapabilitiesMapping( Source, Dest )           \
        RtlCopyMemory( (PUCHAR) Dest, (PUCHAR) Source,                \
            (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE) )

    NTSTATUS
    ACPISystemPowerDetermineSupportedDeviceStates(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  SYSTEM_POWER_STATE  SystemState,
        OUT ULONG               *SupportedDeviceStates
        );

    DEVICE_POWER_STATE
    ACPISystemPowerDetermineSupportedDeviceWakeState(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    SYSTEM_POWER_STATE
    ACPISystemPowerDetermineSupportedSystemState(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  DeviceState
        );

    NTSTATUS
    ACPISystemPowerGetSxD(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  SYSTEM_POWER_STATE  SystemState,
        OUT DEVICE_POWER_STATE  *DeviceState
        );

    NTSTATUS
    ACPISystemPowerInitializeRootMapping(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerProcessRootMapping(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  DeviceMapping[PowerSystemMaximum]
        );

    NTSTATUS
    ACPISystemPowerProcessSxD(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  DEVICE_POWER_STATE  CurrentMapping[PowerSystemMaximum],
        IN  PBOOLEAN            MatchFound
        );

    NTSTATUS
    ACPISystemPowerQueryDeviceCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerUpdateDeviceCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilities(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilitiesForFilters(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

    NTSTATUS
    ACPISystemPowerUpdateWakeCapabilitiesForPDOs(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PDEVICE_CAPABILITIES    BaseCapabilities,
        IN  PDEVICE_CAPABILITIES    DeviceCapabilities,
        IN  DEVICE_POWER_STATE      CurrentMapping[PowerSystemMaximum],
        IN  ULONG                   *SupportedWake,
        IN  SYSTEM_POWER_STATE      *SystemWakeLevel,
        IN  DEVICE_POWER_STATE      *DeviceWakeLevel,
        IN  DEVICE_POWER_STATE      *FilterWakeLevel
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\rtl.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rtl.c

Abstract:

    Some handy-dany RTL functions. These really should be part of the kernel


Author:

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"


PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN  POOL_TYPE           PoolType,
    IN  PCM_RESOURCE_LIST   ResourceList,
    IN  ULONG               Tag
    )
/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/
{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    //
    // How much memory do we need for this resource list?
    //
    size = RtlSizeOfCmResourceList(ResourceList);

    //
    // Allocate the memory and copy the list
    //
    buffer = ExAllocatePoolWithTag(PoolType, size, Tag);
    if(buffer != NULL) {

        RtlCopyMemory(
            buffer,
            ResourceList,
            size
            );

    }

    return buffer;
}

ULONG
RtlSizeOfCmResourceList(
    IN  PCM_RESOURCE_LIST   ResourceList
    )
/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //
        if(i != 0) {

            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //
            if(j != 0) {

                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            }

        }

    }
    return size;
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN  UCHAR               Type,
    IN  PCM_RESOURCE_LIST   ResList,
    IN  OUT PULONG          Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...
    ResList - The list to search
    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the partial descriptor if found, otherwise NULL

--*/
{
    ULONG hit = 0;
    ULONG i;
    ULONG j;

    for (i = 0; i < ResList->Count; i++) {

        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {

            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {

                if (hit == *Count) {

                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];

                } else {

                    hit++;

                }

            }

        }

    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\table.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    table.h

Abstract:

    All the function related to actually loading an ACPI table
    are included herein.

    This, however, is mostly bookkeeping since the actual mechanics
    of creating device extensions, and the name space tree are
    handled elsewhere

Author:

    Stephane Plante (splante)

Environment:

    Kernel Mode Only

Revision History:

    03/22/00 - Created (from code in callback.c)

--*/

#ifndef _TABLE_H_
#define _TABLE_H_

    NTSTATUS
    ACPITableLoad(
        VOID
        );

    VOID
    ACPITableLoadCallBack(
        IN  PVOID       BuildContext,
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    NTSTATUS
    EXPORT
    ACPITableNotifyFreeObject(
        IN  ULONG       Event,
        IN  PVOID       Object,
        IN  ULONG       ObjectType
        );

    NTSTATUS
    ACPITableUnload(
        VOID
        );

    NTSTATUS
    ACPITableUnloadInvalidateRelations(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\thermal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    thermal.h

Abstract:

    This module implements all the callbacks that are NT specific from
    the AML Interperter

Environment

    Kernel mode only

Revision History:

    04-Jun-97 Initial Revision

--*/

#ifndef _THERMAL_H_
#define _THERMAL_H_

    //
    // Structures
    //
    typedef struct {
        THERMAL_INFORMATION     Info;
        ULONG                   CoolingLevel;
        ULONG                   Mode;
        PVOID                   ActiveList[10];
        PNSOBJ                  TempMethod;
        OBJDATA                 Temp;
    } THRM_INFO, *PTHRM_INFO;

    extern  WMIGUIDREGINFO  ACPIThermalGuidList;
    extern  KSPIN_LOCK      AcpiThermalLock;
    extern  LIST_ENTRY      AcpiThermalList;

    #define ACPIThermalGuidCount (sizeof(ACPIThermalGuidList) / sizeof(WMIGUIDREGINFO))

    //
    // Defines
    //
    #define THRM_COOLING_LEVEL          0x00000001
    #define THRM_TEMP                   0x00000002
    #define THRM_TRIP_POINTS            0x00000004
    #define THRM_MODE                   0x00000008
    #define THRM_INITIALIZE             0x00000010

    #define THRM_WAIT_FOR_NOTIFY        0x20000000
    #define THRM_BUSY                   0x40000000
    #define THRM_IN_SERVICE_LOOP        0x80000000

    //
    // Prototypes
    //
    VOID
    ACPIThermalCalculateProcessorMask(
        IN PNSOBJ           ProcessorObject,
        IN PTHRM_INFO       Thrm
        );

    VOID
    ACPIThermalCancelRequest (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

    VOID
    EXPORT
    ACPIThermalComplete(
        IN PNSOBJ               AcpiObject,
        IN NTSTATUS             Status,
        IN POBJDATA             Result  OPTIONAL,
        IN PVOID                DevExt
        );

    BOOLEAN
    ACPIThermalCompletePendingIrps(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  PTHRM_INFO          Thermal
        );

    NTSTATUS
    ACPIThermalDeviceControl(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIThermalEvent(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  ULONG           EventData
        );

    NTSTATUS
    ACPIThermalFanStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    ACPIThermalLoop(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  ULONG               Clear
        );

    VOID
    ACPIThermalPowerCallback(
        IN PDEVICE_EXTENSION    DeviceExtenion,
        IN PVOID                Context,
        IN NTSTATUS             Status
        );

    NTSTATUS
    ACPIThermalQueryWmiDataBlock(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  ULONG           GuidIndex,
        IN  ULONG           InstanceIndex,
        IN  ULONG           InstanceCount,
        IN  OUT PULONG      InstanceLengthArray,
        IN  ULONG           BufferAvail,
        OUT PUCHAR          Buffer
        );

    NTSTATUS
    ACPIThermalQueryWmiRegInfo(
        IN  PDEVICE_OBJECT  DeviceObject,
        OUT ULONG           *RegFlags,
        OUT PUNICODE_STRING InstanceName,
        OUT PUNICODE_STRING *RegistryPath,
        OUT PUNICODE_STRING MofResourceName,
        OUT PDEVICE_OBJECT  *Pdo
        );

    NTSTATUS
    ACPIThermalStartDevice(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp
        );

    VOID
    EXPORT
    ACPIThermalTempatureRead (
        IN  PNSOBJ      AcpiObject,
        IN  NTSTATUS    Status,
        IN  POBJDATA    Result  OPTIONAL,
        IN  PVOID       DevExt
        );

    VOID
    ACPIThermalWorker (
        IN  PDEVICE_EXTENSION   DevExt,
        IN  ULONG               Events
        );

    NTSTATUS
    ACPIThermalWmi(
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\thermal.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    thermal.c

Abstract:

    Thermal Zone support

    A small discourse on the use and function of the THRM_WAIT_FOR_NOTIFY
    flag. This flag was added to ensure that at least one Notify() operation
    occured between each query of the temperature. In other words, we didn't
    want to loop forever asking and receiving the same temperature information.

    One of the side effects of this flag is that if we get a QUERY, then
    a SET (instead of another QUERY), then the set must clear the flag.
    Failure to do so will prevent the ThermalLoop() code from ever completing
    the IRP. And that means that the temperature mechanisms will stop working.

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

Revision History:

    July 7, 1997    - Complete Rewrite
--*/

#include "pch.h"

WMIGUIDREGINFO ACPIThermalGuidList =
{
    &THERMAL_ZONE_GUID,
    1,
    0
};

//
// Spinlock to protect the thermal list
//
KSPIN_LOCK  AcpiThermalLock;

//
// List entry to store the thermal requests on
//
LIST_ENTRY  AcpiThermalList;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ACPIThermalStartDevice)
#pragma alloc_text(PAGE, ACPIThermalWorker)
#pragma alloc_text(PAGE, ACPIThermalQueryWmiRegInfo)
#pragma alloc_text(PAGE, ACPIThermalQueryWmiDataBlock)
#pragma alloc_text(PAGE, ACPIThermalWmi)
#endif

VOID
ACPIThermalCalculateProcessorMask(
    IN PNSOBJ           ProcessorObject,
    IN PTHRM_INFO       Thrm
    )
/*++

Routine Description:

    This routine, which is only called from ACPIThermalWorker, has been
    created so that we don't have to worry about locking down the
    ACPIThermalWorker, takes a processor object from the namespace and
    sets the proper affinity bit in the thermal info

Arguments:

    ProcessorObject - Pointer to Namespace Processor Object
    Thrm            - Thermal Information Structure

Return Value:

    None

--*/
{
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   ProcessorExtension;

    //
    // Sanity check
    //
    if (ProcessorObject == NULL) {

        return;

    }

    //
    // We need the spinlock to deref the processor extension
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &OldIrql );

    //
    // The context pointer is the device extension
    //
    ProcessorExtension = (PDEVICE_EXTENSION) ProcessorObject->Context;
    if (ProcessorExtension) {

        //
        // We know what index it is within the processor list.
        // This should be a good enough guess for now
        //
        Thrm->Info.Processors |= ( (ULONG_PTR) 1 << ProcessorExtension->Processor.ProcessorIndex);

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, OldIrql );

}

VOID
ACPIThermalCancelRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine cancels an outstanding thermal request

Arguments

    DeviceObject    - The device which has a request being cancelled
    Irp             - The cancelling irp

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

#if DBG
    ULONGLONG           currentTime = KeQueryInterruptTime();

    ACPIThermalPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        currentTime,
        "ACPIThermalCancelRequest: Irp %08lx\n",
        Irp
        ) );
#endif

    //
    // We no longer need the cancel lock
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // We do however need the thermal queue lock
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // Remove the irp from the list that it is on
    //
    RemoveEntryList( &(Irp->Tail.Overlay.ListEntry) );

    //
    // Done with the thermal lock now
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Complete the irp now
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

VOID
EXPORT
ACPIThermalComplete (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                DeviceExtension
    )
/*++

Routine Description:

    This routine is called when the interpreter has completed a request

Arguments:

    AcpiObject  - The request that was completed
    Status      - The status of the request
    Result      - What the result of the request was
    DevExt      - The context of the request

Return Value:

    NONE

--*/
{
    ACPIThermalLoop (DeviceExtension, THRM_BUSY);
}

BOOLEAN
ACPIThermalCompletePendingIrps(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PTHRM_INFO          Thermal
    )
/*++

Routine Description:

    This routine is called, with no spinlock being held. This routine
    completes any IOCTLs associated with the device object

    This routine will return TRUE if it completed any requests, false
    otherwise

Arguments:

    DeviceExtension - The device extension whose requests we want to complete
    Thermal         - Pointer to the thermal information for the extension

Return Value:

    BOOLEAN
--*/
{
    BOOLEAN                 handledRequest  = FALSE;
    KIRQL                   oldIrql;
    LIST_ENTRY              doneList;
    PDEVICE_EXTENSION       irpExtension;
    PDEVICE_OBJECT          deviceObject;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    irp;
    PLIST_ENTRY             listEntry;
    PTHERMAL_INFORMATION    thermalInfo;

    //
    // Initialize the list that will hold the requets that we need to complete
    //
    InitializeListHead( &doneList );
    //
    // Acquire the thermal lock so that we can pend these requests
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // Walk the list of pending irps to see which ones match this extensions
    //
    listEntry = AcpiThermalList.Flink;
    while (listEntry != &AcpiThermalList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;

        //
        // We need the current irp stack location
        //
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // Grab the device object from the irp stack and turn that into a
        // device extension
        //
        irpExtension = ACPIInternalGetDeviceExtension( irpSp->DeviceObject );

        //
        // Is this an irp that we care about? IE: does the target match the
        // one specified in this function
        //
        if (irpExtension != DeviceExtension) {

            continue;

        }

        //
        // If this is a query information irp then, we must be able to set the
        // cancel routine to NULL to make sure that it cannot be cancelled on
        // us
        //
        if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_THERMAL_QUERY_INFORMATION) {

            if (IoSetCancelRoutine(irp, NULL) == NULL) {

                //
                // Cancel routine is active, stop processing this irp and move on
                //
                continue;

            }

            //
            // Copy the data that we got back to the irp
            //
            DeviceExtension->Thermal.Flags |= THRM_WAIT_FOR_NOTIFY;
            thermalInfo = (PTHERMAL_INFORMATION) irp->AssociatedIrp.SystemBuffer;
            memcpy (thermalInfo, Thermal, sizeof (THERMAL_INFORMATION));

            //
            // Set the parameters that we will return
            //
            irp->IoStatus.Information   = sizeof(THERMAL_INFORMATION);

        } else {

            //
            // Set the parameters that we will return
            //
            irp->IoStatus.Information = 0;

        }

        //
        // Always succeed these irps
        //
        irp->IoStatus.Status        = STATUS_SUCCESS;

        //
        // Remove the entry from the list
        //
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        //
        // Insert the list into the next queue so that we know to complete it
        // later on
        //
        InsertTailList( &doneList, &(irp->Tail.Overlay.ListEntry) );

    }

    //
    // At this point, drop our thermal lock
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Walk the list of irpts to be completed
    //
    listEntry = doneList.Flink;
    while (listEntry != &doneList) {

        //
        // Grab the irp from the list entry and update the next list entry
        // that we will look at
        //
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        listEntry = listEntry->Flink;
        RemoveEntryList( &(irp->Tail.Overlay.ListEntry) );

        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            KeQueryInterruptTime(),
            "Completing Irp 0x%x\n",
            irp
            ) );

        //
        // Now complete the irp
        //
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        //
        // Remember that we handled a request
        //
        handledRequest = TRUE;

    }

    //
    // Return wether or not we handled a request
    return handledRequest;
}

NTSTATUS
ACPIThermalDeviceControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Fixed button device IOCTL handler

Arguments:

    DeviceObject    - fixed feature button device object
    Irp             - the ioctl request

Return Value:

    NTSTATUS

--*/
{
    KIRQL                       oldIrql;
    PIO_STACK_LOCATION          IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION           deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PTHERMAL_INFORMATION        thermalInfo;
    PULONG                      Mode;
    PTHRM_INFO                  Thrm            = deviceExtension->Thermal.Info;
    NTSTATUS                    Status          = STATUS_PENDING;
    ULONG                       ThermalWork     = 0;
    ULONGLONG                   currentTime;

    //
    // Do not allow user mode IRPs in this routine
    //
    if (Irp->RequestorMode != KernelMode) {

        return ACPIDispatchIrpInvalid( DeviceObject, Irp );

    }

#if DBG
    currentTime = KeQueryInterruptTime();
#endif

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_THERMAL_QUERY_INFORMATION:

        //
        // If this irp's stamp does not match the known last stamp, then we
        // need a new temp now
        //
        thermalInfo = (PTHERMAL_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
        if (thermalInfo->ThermalStamp != Thrm->Info.ThermalStamp) {

            ThermalWork = THRM_TEMP | THRM_WAIT_FOR_NOTIFY;

        }
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - THERMAL_QUERY_INFORMATION: %x - %x\n",
            Irp,
            thermalInfo->ThermalStamp,
            Thrm->Info.ThermalStamp
            ) );
#endif

        break;

    case IOCTL_THERMAL_SET_COOLING_POLICY:

        //
        // Set the thermal zone's policy mode
        //
        Thrm->Mode = *((PUCHAR) Irp->AssociatedIrp.SystemBuffer);
        ThermalWork = THRM_MODE | THRM_TRIP_POINTS | THRM_WAIT_FOR_NOTIFY;

#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - SET_COOLING_POLICY: %x\n",
            Irp,
            Thrm->Mode
            ) );
#endif

        break;

    case IOCTL_RUN_ACTIVE_COOLING_METHOD:

        Thrm->CoolingLevel = *((PUCHAR) Irp->AssociatedIrp.SystemBuffer);
        ThermalWork = THRM_COOLING_LEVEL | THRM_WAIT_FOR_NOTIFY;

#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            currentTime,
            "%08x - ACTIVE_COOLING_LEVEL: %x\n",
            Irp,
            Thrm->CoolingLevel
            ) );
#endif

        break;

    default:

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_NOT_SUPPORTED;

    }

    //
    // Grab the thermal lock, queue the request to the proper place, and make
    // sure to set a cancel routine --- no that we will only allow a cancel
    // routine if this is a query irp
    //
    KeAcquireSpinLock( &AcpiThermalLock, &oldIrql );

    //
    // There is one fly in the ointment: What to do if the device is no longer
    // there. The only way to really handle that is to just fail the request.
    // Its important to note that this check is done while the ThermalLock
    // is being held because the code that builds a SurpriseRemoved extension
    // will attempt to call AcpiThermalCompletePendingIrps which also
    // acquires this lock.
    //
    if (deviceExtension->Flags & DEV_TYPE_SURPRISE_REMOVED) {

        KeReleaseSpinLock( &AcpiThermalLock, oldIrql );
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;

    }

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_THERMAL_QUERY_INFORMATION) {

        IoSetCancelRoutine (Irp, ACPIThermalCancelRequest);
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) ) {

            //
            // If we got here, that means that the irp has been cancelled and we
            // beat the IO manager to the ThermalLock. So release the irp, and
            // mark the irp as being cancelled
            //
            KeReleaseSpinLock( &AcpiThermalLock, oldIrql );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return STATUS_CANCELLED;

        }
    }

    //
    // If we got to this point, we are going to queue the request and do some
    // work on it. The ACPIThermalLoop routine may process this request right 
    // away or do it later depending on wether it is busy doing some work when
    // it is called. Therefore we should mark this IRP pending. There is no harm
    // in marking it pending and returning STATUS_PENDING even if the work
    // gets completed by ACPIThermalLoop syncronously.
    //
    IoMarkIrpPending( Irp );
    
    //
    // If we got here, we know we can queue the irp in the outstanding
    // work list entry
    //
    InsertTailList( &AcpiThermalList, &(Irp->Tail.Overlay.ListEntry) );

    //
    // Done with the lock at this point
    //
    KeReleaseSpinLock( &AcpiThermalLock, oldIrql );

    //
    // Fire off the workter thread
    //
    ACPIThermalLoop (deviceExtension, ThermalWork);
    return Status;
}

VOID
ACPIThermalEvent (
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            EventData
    )
/*++

Routine Description:

    This routine handles thermal events

Arguments:

    DeviceObject    - The device that received the event
    EventData       - The event that just happened

Return Value:

    NONE

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    ULONG               clear;

    ACPIThermalPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        KeQueryInterruptTime(),
        "ACPIThermalEvent - Notify(%x)\n",
        EventData
        ) );

    //
    // Handle event type
    //
    clear = 0;
    switch (EventData) {
    case 0x80:

        //
        // Tempature changed notification
        //
        clear = THRM_WAIT_FOR_NOTIFY | THRM_TEMP;
        break;

    case 0x81:

        //
        // Trips points changed notification
        //
        clear = THRM_WAIT_FOR_NOTIFY | THRM_TEMP | THRM_TRIP_POINTS;
        break;

    default:
        break;
    }

    ACPIThermalLoop (deviceExtension, clear);
}

NTSTATUS
ACPIThermalFanStartDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the routine that processes the start device for the fans

Arguments:

    DeviceObject    - The fan device
    Irp             - The start request

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    UCHAR               minorFunction   = irpStack->MinorFunction;

    //
    // There is nothing to do when starting a fan --- it is really being
    // controlled by the thermal zones
    //
    deviceExtension->DeviceState = Started;

    //
    // Complete the request
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR) NULL;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Let the world know
    //
    ACPIDevPrint( (
        ACPI_PRINT_THERMAL,
        deviceExtension,
        "(0x%08lx): %s = 0x%08lx\n",
        Irp,
        ACPIDebugGetIrpText(IRP_MJ_PNP, minorFunction),
        STATUS_SUCCESS
        ) );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPIThermalLoop (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Clear
    )
/*++

Routine Description:

    This is the routine that processes all thermal events

Arguments:

    DevExt  - The device extension of the thermal zone
    Clear   - Bits to clear

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     doneRequests;
    BOOLEAN     lockHeld;
    KIRQL       oldIrql;
    PTHRM_INFO  thermal;
    NTSTATUS    status;

    thermal = DeviceExtension->Thermal.Info;

    KeAcquireSpinLock (&DeviceExtension->Thermal.SpinLock, &oldIrql);
    lockHeld = TRUE;

    DeviceExtension->Thermal.Flags &= ~Clear;

    //
    // If we're not in the service loop, enter it now
    //
    if (!(DeviceExtension->Thermal.Flags & THRM_IN_SERVICE_LOOP)) {
        DeviceExtension->Thermal.Flags |= THRM_IN_SERVICE_LOOP;

        //
        // Loop while there's work to be done
        //
        for (; ;) {

            //
            // Synchronize the thermal zone
            //
            if (!lockHeld) {

                KeAcquireSpinLock(&DeviceExtension->Thermal.SpinLock, &oldIrql);
                lockHeld = TRUE;

            }

            //
            // If some work is pending, wait for it to complete
            //
            if (DeviceExtension->Thermal.Flags & THRM_BUSY) {

                break;

            }

            //
            // Make sure that the thermal zone is initialized. This must
            // be the first thing that we do in the loop!!!
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_INITIALIZE) ) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_INITIALIZE;
                ACPISetDeviceWorker(
                    DeviceExtension,
                    THRM_COOLING_LEVEL | THRM_INITIALIZE
                    );
                continue;

            }

            //
            // If the thermal zone mode needs updated, do it now
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_MODE)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_MODE;
                KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
                lockHeld = FALSE;

                status = ACPIGetNothingEvalIntegerAsync(
                    DeviceExtension,
                    PACKED_SCP,
                    thermal->Mode,
                    ACPIThermalComplete,
                    DeviceExtension
                    );
                if (status != STATUS_PENDING) {

                    ACPIThermalComplete(
                        NULL,
                        status,
                        NULL,
                        DeviceExtension
                        );

                }
                continue;

            }

            //
            // If the trip point infomation needs updated, get it. Note that
            // updating the trip points means that we also need to redo the
            // cooling level
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_TRIP_POINTS)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_TRIP_POINTS;
                ACPISetDeviceWorker( DeviceExtension, THRM_TRIP_POINTS );
                continue;

            }

            //
            // If the cooling level has changed,
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_COOLING_LEVEL)) {

                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_COOLING_LEVEL;
                ACPISetDeviceWorker (DeviceExtension, THRM_COOLING_LEVEL);
                continue;

            }

            //
            // Prevent the recursion that occurs when we complete an irp and
            // the completion routine is able to queue the IRP before we resume
            // the loop
            //
            if ( (DeviceExtension->Thermal.Flags & THRM_WAIT_FOR_NOTIFY) &&
                 (DeviceExtension->Thermal.Flags & THRM_TEMP) ) {

                break;

            }

            //
            // If we don't have a temp, get it
            //
            if (!(DeviceExtension->Thermal.Flags & THRM_TEMP)) {

                //
                // Is the temp object not present?
                //
#if DBG
                if (thermal->TempMethod == NULL) {

                    ACPIInternalError( ACPI_THERMAL );

                }
#endif

                thermal->Info.ThermalStamp += 1;
                DeviceExtension->Thermal.Flags |= THRM_BUSY | THRM_TEMP;
                KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
                lockHeld = FALSE;

                RtlZeroMemory (&thermal->Temp, sizeof(OBJDATA));

                thermal->Temp.dwDataType = OBJTYPE_UNKNOWN;
                status = AMLIAsyncEvalObject(
                    thermal->TempMethod,
                    &thermal->Temp,
                    0,
                    NULL,
                    ACPIThermalTempatureRead,
                    DeviceExtension
                    );

                if (status != STATUS_PENDING) {

                    ACPIThermalTempatureRead(
                        thermal->TempMethod,
                        status,
                        &thermal->Temp,
                        DeviceExtension
                        );

                }
                continue;

            }

            //
            // Everything is up to date.  Check for a pending irp to see if
            // we can complete it.
            //

            //
            // Call into a child function to determine if we have completed
            // any requests
            //
            doneRequests = ACPIThermalCompletePendingIrps(
                DeviceExtension,
                thermal
                );
            if (doneRequests) {

                continue;

            }
            break;

        }

        //
        // No longer in the serivce loop
        //
        DeviceExtension->Thermal.Flags &= ~THRM_IN_SERVICE_LOOP;

    }

    KeReleaseSpinLock (&DeviceExtension->Thermal.SpinLock, oldIrql);
    return ;
}

VOID
ACPIThermalPowerCallback (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PVOID                Context,
    IN NTSTATUS             Status
    )
/*++

Routine Description:

    This is the routine that is called after we have sent an internal
    power request to the device

Arguments:

    DeviceExtension - the device that was set
    Context         - Not used
    Status          - Result

Return Value:

    None

--*/
{
    if (!NT_SUCCESS(Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            DeviceExtension,
            "ACPIThermalPowerCallBack: failed power setting %x\n",
            Status
            ) );

    }
}

NTSTATUS
ACPIThermalQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension;
    ULONG                   sizeNeeded;
    PTHRM_INFO              info;
    PTHERMAL_INFORMATION    thermalInfo;
    PTHERMAL_INFORMATION    wmiThermalInfo;

    PAGED_CODE();

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    if (GuidIndex == 0) {

        //
        // ThermalZone temperature query
        //
        info = (PTHRM_INFO) deviceExtension->Thermal.Info;
        thermalInfo = &info->Info;

        wmiThermalInfo = (PTHERMAL_INFORMATION)Buffer;
        sizeNeeded = sizeof(THERMAL_INFORMATION);

        if (BufferAvail >= sizeNeeded) {

            // NOTE - Synchronize with thread getting this data
            *InstanceLengthArray = sizeNeeded;
            RtlCopyMemory(wmiThermalInfo, thermalInfo, sizeNeeded);
            status = STATUS_SUCCESS;

        } else {

            status = STATUS_BUFFER_TOO_SMALL;

        }

    } else {

        status = STATUS_WMI_GUID_NOT_FOUND;
        sizeNeeded = 0;

    }

    status = WmiCompleteRequest(
        DeviceObject,
        Irp,
        status,
        sizeNeeded,
        IO_NO_INCREMENT
        );
    return status;
}

NTSTATUS
ACPIThermalQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PAGED_CODE();

    if (AcpiRegistryPath.Buffer != NULL) {

        *RegistryPath = &AcpiRegistryPath;

    } else {

        *RegistryPath = NULL;

    }

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *Pdo = DeviceObject;
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIThermalStartDevice (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is called to start the thermal zone

Arguments:

    DeviceObject    - The device that is starting up
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PWMILIB_CONTEXT     wmilibContext;

    deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ACPIDevPrint( (
        ACPI_PRINT_IRP,
        deviceExtension,
        "(0x%08lx): IRP_MN_START_DEVICE\n",
        Irp
        ) );

    status = ACPIInternalSetDeviceInterface (
        DeviceObject,
        (LPGUID) &GUID_DEVICE_THERMAL_ZONE
        );

    if (!NT_SUCCESS(status)) {

        ACPIDevPrint( (
            ACPI_PRINT_FAILURE,
            deviceExtension,
            "ACPIThermalStartDevice -> SetDeviceInterface = 0x%08lx\n",
            status
            ) );
        goto ACPIThermalStartDeviceExit;

    }

    ACPIRegisterForDeviceNotifications(
        DeviceObject,
        (PDEVICE_NOTIFY_CALLBACK) ACPIThermalEvent,
        (PVOID) DeviceObject
        );

    //
    // Initialize device object for WMILIB
    //
    wmilibContext = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(WMILIB_CONTEXT),
        ACPI_THERMAL_POOLTAG
        );
    if (wmilibContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIThermalStartDeviceExit;

    }

    RtlZeroMemory(wmilibContext, sizeof(WMILIB_CONTEXT));
    wmilibContext->GuidCount = ACPIThermalGuidCount;
    wmilibContext->GuidList = &ACPIThermalGuidList;
    wmilibContext->QueryWmiRegInfo = ACPIThermalQueryWmiRegInfo;
    wmilibContext->QueryWmiDataBlock = ACPIThermalQueryWmiDataBlock;
    deviceExtension->Thermal.WmilibContext = wmilibContext;

    //
    // Register for WMI events
    //
    status = IoWMIRegistrationControl(
        DeviceObject,
        WMIREG_ACTION_REGISTER
        );
    if (!NT_SUCCESS(status)) {

        deviceExtension->Thermal.WmilibContext = NULL;
        ExFreePool(wmilibContext);
        goto ACPIThermalStartDeviceExit;

    }

    //
    // Mark the device as started
    //
    deviceExtension->DeviceState = Started;

    //
    // Request that the device go to the D0 state
    //  Note: that we don't block on this call, since we assume that
    //        we can process thermal events asynchronously from being in
    //        the D0 state. However, there may be a future occasion where
    //        this is not true, so this makes the code more ready to handle
    //        that case
    //
    status = ACPIDeviceInternalDeviceRequest(
        deviceExtension,
        PowerDeviceD0,
        NULL,
        NULL,
        0
        );
    if (status == STATUS_PENDING) {

        status = STATUS_SUCCESS;

    }

    //
    // Start the thermal engine
    //
    ACPIThermalLoop( deviceExtension, THRM_TRIP_POINTS | THRM_MODE);

ACPIThermalStartDeviceExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

VOID
EXPORT
ACPIThermalTempatureRead (
    IN PNSOBJ               AcpiObject,
    IN NTSTATUS             Status,
    IN POBJDATA             Result  OPTIONAL,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine is called to read the temperature. It is used a callback to
    an interpreter call

Arguments:

    AcpiObject  - The object that was executed
    Status      - The status of the execution
    Result      - The result of the execution
    Context     - The device extension

Return Value:

    NTSTATUS

--*/
{
    PTHRM_INFO          Thrm;
    PDEVICE_EXTENSION   deviceExtension;

    deviceExtension = Context;

    if (NT_SUCCESS(Status)) {

        ASSERT (Result->dwDataType == OBJTYPE_INTDATA);
        Thrm = deviceExtension->Thermal.Info;
        Thrm->Info.CurrentTemperature = (ULONG)Result->uipDataValue;
        AMLIFreeDataBuffs (Result, 1);

        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            deviceExtension,
            KeQueryInterruptTime(),
            "Current Temperature is %d.%dK\n",
            (Thrm->Info.CurrentTemperature / 10 ),
            (Thrm->Info.CurrentTemperature % 10 )
            ) );

    }
    ACPIThermalLoop (deviceExtension, THRM_BUSY);
}

VOID
ACPIThermalWorker (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Events
    )
/*++

Routine Description:

    Worker thread for thermal regions

Arguments:

    DeviceExtension - The device extension that we are manipulating
    Events          - What just happened

Return Value:

    None

--*/
{
    BOOLEAN             TurnOn;
    PTHRM_INFO          Thrm;
    NTSTATUS            Status;
    PNSOBJ              ThrmObj;
    PNSOBJ              ALobj;
    OBJDATA             ALPackage;
    OBJDATA             ALElement;
    PNSOBJ              ACDevObj;
    ULONG               Index;
    ULONG               Level;
    ULONG               PackageSize;
    ULONGLONG           currentTime;

    PAGED_CODE();

#if DBG
    currentTime = KeQueryInterruptTime();
#endif

    Thrm = DeviceExtension->Thermal.Info;
    ThrmObj = DeviceExtension->AcpiObject;

    //
    // Initialization code
    //
    if (Events & THRM_INITIALIZE) {

        ULONG   names[10] = {
                    PACKED_AL0,
                    PACKED_AL1,
                    PACKED_AL2,
                    PACKED_AL3,
                    PACKED_AL4,
                    PACKED_AL5,
                    PACKED_AL6,
                    PACKED_AL7,
                    PACKED_AL8,
                    PACKED_AL9,
                    };

        //
        // Start the system in PASSIVE mode
        //
        Thrm->Mode = 1;

        //
        // Fetch all of the objects associated with each cooling level
        //
        for (Level = 0; Level < 10; Level++) {

            //
            // Find this level's active list
            //
            ALobj = ACPIAmliGetNamedChild(
                ThrmObj,
                names[Level]
                );
            if (ALobj == NULL) {

                break;

            }

            //
            // Remember that we have this object
            //
            Thrm->ActiveList[Level] = ALobj;

        }

    }

    //
    // Do this before we update the trips points
    //
    if ( (Events & THRM_COOLING_LEVEL) ) {

        RtlZeroMemory (&ALPackage, sizeof(OBJDATA));
        RtlZeroMemory (&ALElement, sizeof(OBJDATA));

        for (Level=0; Level < 10; Level++) {

            //
            // Is there a cooling object?
            //
            ALobj = Thrm->ActiveList[Level];
            if (ALobj == NULL) {

                break;
            }

            //
            // Evalute the list to its package
            //
            Status = AMLIEvalNameSpaceObject(
                ALobj,
                &ALPackage,
                0,
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                break;

            }

            //
            // Remember how large the package is
            //
            PackageSize = ((PPACKAGEOBJ) ALPackage.pbDataBuff)->dwcElements;

            //
            // Walk the names in the package
            //
            for (Index = 0; Index < PackageSize; Index += 1) {

                //
                // Grab the object name
                Status = AMLIEvalPkgDataElement(
                    &ALPackage,
                    Index,
                    &ALElement
                    );
                if (!NT_SUCCESS(Status)) {

                    break;

                }

                //
                // Determine if we are going to the device on or off
                //
                TurnOn = (Level >= Thrm->CoolingLevel);

                //
                // Tell the world
                //
#if DBG
                ACPIThermalPrint( (
                    ACPI_PRINT_THERMAL,
                    DeviceExtension,
                    currentTime,
                    "ACPIThermalWorker: Turn %s %s\n",
                    TurnOn ? "on " : "off",
                    ALElement.pbDataBuff
                    ) );
#endif

                //
                // Find this device of this name
                //
                Status = AMLIGetNameSpaceObject(
                    ALElement.pbDataBuff,
                    ThrmObj,
                    &ACDevObj,
                    0
                    );
                AMLIFreeDataBuffs (&ALElement, 1);
                if (!NT_SUCCESS(Status) ||  !ACDevObj->Context) {

                    break;

                }

                //
                // Turn it on/off
                //
                ACPIDeviceInternalDeviceRequest (
                    (PDEVICE_EXTENSION) ACDevObj->Context,
                    TurnOn ? PowerDeviceD0 : PowerDeviceD3,
                    ACPIThermalPowerCallback,
                    NULL,
                    0
                    );

            }
            AMLIFreeDataBuffs (&ALPackage, 1);

        }

    }

    //
    // If the trip points need to be re-freshed, go read them
    //
    if (Events & THRM_TRIP_POINTS) {

        ULONG   names[10] = {
                    PACKED_AC0,
                    PACKED_AC1,
                    PACKED_AC2,
                    PACKED_AC3,
                    PACKED_AC4,
                    PACKED_AC5,
                    PACKED_AC6,
                    PACKED_AC7,
                    PACKED_AC8,
                    PACKED_AC9,
                    };

        //
        // Get the thermal constants, passive & critical values
        //
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TC1,
            &Thrm->Info.ThermalConstant1,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - ThermalConstant1 = %x\n",
            Thrm->Info.ThermalConstant1
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TC2,
            &Thrm->Info.ThermalConstant2,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - ThermalConstant2 = %x\n",
            Thrm->Info.ThermalConstant2
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_PSV,
            &Thrm->Info.PassiveTripPoint,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - PassiveTripPoint = %d.%dK\n",
            (Thrm->Info.PassiveTripPoint / 10),
            (Thrm->Info.PassiveTripPoint % 10)
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_CRT,
            &Thrm->Info.CriticalTripPoint,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - CriticalTripPoint = %d.%dK\n",
            (Thrm->Info.CriticalTripPoint / 10),
            (Thrm->Info.CriticalTripPoint % 10)
            ) );
#endif
        ACPIGetIntegerSync(
            DeviceExtension,
            PACKED_TSP,
            &Thrm->Info.SamplingPeriod,
            NULL
            );
#if DBG
        ACPIThermalPrint( (
            ACPI_PRINT_THERMAL,
            DeviceExtension,
            currentTime,
            "ACPIThermalWorker - SamplingPeriod = %x\n",
            Thrm->Info.SamplingPeriod
            ) );
#endif

        //
        // Get the active cooling limits
        //
        for (Level=0; Level < 10; Level++) {

            Status = ACPIGetIntegerSync(
                DeviceExtension,
                names[Level],
                &Thrm->Info.ActiveTripPoint[Level],
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                break;

            }
#if DBG
            ACPIThermalPrint( (
                ACPI_PRINT_THERMAL,
                DeviceExtension,
                currentTime,
                "ACPIThermalWorker - Active Cooling Level %x = %d.%dK\n",
                Level,
                (Thrm->Info.ActiveTripPoint[Level] / 10),
                (Thrm->Info.ActiveTripPoint[Level] % 10)
                ) );
#endif

        }
        Thrm->Info.ActiveTripPointCount = (UCHAR) Level;

        //
        // Clean these variables for reuse
        //
        RtlZeroMemory (&ALPackage, sizeof(OBJDATA));
        RtlZeroMemory (&ALElement, sizeof(OBJDATA));

        //
        // Assume an affinity of 0
        //
        Thrm->Info.Processors = 0;

        //
        // Get the passive cooling affinity object
        //
        ALobj = ACPIAmliGetNamedChild(
            ThrmObj,
            PACKED_PSL
            );
        if (ALobj != NULL) {

            //
            // Evaluate the processor affinity object
            //
            Status = AMLIEvalNameSpaceObject(
                ALobj,
                &ALPackage,
                0,
                NULL
                );
            if (!NT_SUCCESS(Status)) {

                goto ACPIThermalWorkerExit;

            }

            //
            // Remember how large the package is
            //
            PackageSize = ((PPACKAGEOBJ) ALPackage.pbDataBuff)->dwcElements;

            //
            // Walk the elements in the package
            //
            for (Index = 0; Index < PackageSize ;Index++) {

                Status = AMLIEvalPkgDataElement(
                    &ALPackage,
                    Index,
                    &ALElement
                    );
                if (!NT_SUCCESS(Status)) {

                    break;

                }

                //
                // Find this device of this name
                //
                Status = AMLIGetNameSpaceObject(
                    ALElement.pbDataBuff,
                    NULL,
                    &ACDevObj,
                    0
                    );

                //
                // No longer need this information
                //
                AMLIFreeDataBuffs (&ALElement, 1);

                //
                // Did we find what we wanted?
                //
                if (!NT_SUCCESS(Status) ) {

                    break;

                }

                //
                // Get the correct affinity mask. We call another
                // function since that one requires a spinlock which
                // don't want to take in this worker function
                //
                ACPIThermalCalculateProcessorMask( ACDevObj, Thrm );

            }

            //
            // We are done with the package
            //
            AMLIFreeDataBuffs (&ALPackage, 1);

        }

    }

ACPIThermalWorkerExit:

    //
    // done, check for next work
    //
    ACPIThermalLoop (DeviceExtension, THRM_TEMP | THRM_BUSY);
}


NTSTATUS
ACPIThermalWmi(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpSp;
    PWMILIB_CONTEXT         wmilibContext;
    SYSCTL_IRP_DISPOSITION  disposition;

    wmilibContext = deviceExtension->Thermal.WmilibContext;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    status = WmiSystemControl(
        wmilibContext,
        DeviceObject,
        Irp,
        &disposition
        );

    switch (disposition) {

        case IrpProcessed:
            break;
        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        case IrpNotWmi:
        case IrpForward:
        default:
            status = ACPIDispatchForwardIrp(DeviceObject, Irp);
            break;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\table.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    table.c

Abstract:

    All the function related to actually loading an ACPI table
    are included herein.

    This, however, is mostly bookkeeping since the actual mechanics
    of creating device extensions, and the name space tree are
    handled elsewhere

Author:

    Stephane Plante (splante)

Environment:

    Kernel Mode Only

Revision History:

    03/22/00 - Created (from code in callback.c)

--*/

#include "pch.h"

NTSTATUS
ACPITableLoad(
    VOID
    )
/*++

Routine Description:

    This routine is called when the AML interpreter has finished loading
    a Differentiated Data Block

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             runRootIni = FALSE;
    KIRQL               oldIrql;
    NTSTATUS            status;
    PDEVICE_EXTENSION   fixedButtonExtension = NULL;
    PNSOBJ              iniObject;
    PNSOBJ              nsObject;

    //
    // At this point, we should do everything that we need to do once the
    // name space has been loaded. Note that we need to make sure that we
    // only do those things once...
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // We need the ACPI object for the _SB tree
    //
    status = AMLIGetNameSpaceObject( "\\_SB", NULL, &nsObject, 0 );
    if (!NT_SUCCESS(status)) {

        //
        // Ooops. Failure
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPICallBackLoadUnloadDDB: No SB Object!\n"
            ) );
        ACPIInternalError( ACPI_CALLBACK );
        return STATUS_SUCCESS;

    }

    //
    // Make sure that the root device extension's object points to the correct
    // thing. We only want to run through this code path once...
    //
    if (RootDeviceExtension->AcpiObject == NULL) {

        runRootIni = TRUE;
        InterlockedIncrement( &(RootDeviceExtension->ReferenceCount) );
        RootDeviceExtension->AcpiObject = nsObject;
        nsObject->Context = RootDeviceExtension;

        //
        // Now, enumerate the fixed button
        //
        status = ACPIBuildFixedButtonExtension(
            RootDeviceExtension,
            &fixedButtonExtension
            );
        if (NT_SUCCESS(status) &&
            fixedButtonExtension != NULL) {

            //
            // Incremement the reference count on the node. We do this because
            // we are going to be doing work (which will take a long time
            // to complete, anyways), and we don't want to hold the lock for that
            // entire time. If we incr the reference count, then we guarantee that
            // no one can come along and kick the feet out from underneath us
            //
            InterlockedIncrement( &(fixedButtonExtension->ReferenceCount) );

        }

    }

    //
    // We now want to run the _INI through the entire tree, starting at
    // the _SB
    //
    status = ACPIBuildRunMethodRequest(
        RootDeviceExtension,
        NULL,
        NULL,
        PACKED_INI,
        (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE | RUN_REQUEST_MARK_INI),
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIInternalError( ACPI_CALLBACK );

    }

    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // We also need to run the _INI method off of the root name space entry
    //
    if (runRootIni) {

        iniObject = ACPIAmliGetNamedChild( nsObject->pnsParent, PACKED_INI );
        if (iniObject) {

            AMLIAsyncEvalObject(
                iniObject,
                NULL,
                0,
                NULL,
                NULL,
                NULL
                );

        }

    }

    //
    // We need a synchronization point after we finish running the
    // DPC engine. We want to be able to move anything in the Delayed
    // Power Queue over to the Power DPC engine
    //
    status = ACPIBuildSynchronizationRequest(
        RootDeviceExtension,
        ACPITableLoadCallBack,
        NULL,
        &AcpiBuildDeviceList,
        FALSE
        );
    if (!NT_SUCCESS(status)) {

        ACPIInternalError( ACPI_CALLBACK );

    }

    //
    // We need to hold this spinlock
    //
    KeAcquireSpinLock( &AcpiBuildQueueLock, &oldIrql );

    //
    // Do we need to run the DPC?
    //
    if (!AcpiBuildDpcRunning) {

        KeInsertQueueDpc( &AcpiBuildDpc, 0, 0);

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiBuildQueueLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
ACPITableLoadCallBack(
    IN  PVOID       BuildContext,
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )
/*++

Routine Description:

    This routine is called when we have emptied all of the elements
    within the AcpiBuildDeviceList. This is a good time to move items
    from the AcpiPowerDelayedQueueList to the AcpiPowerQueueList.

Arguments:

    BuildContext    - Not used (it is the RootDeviceExtension)
    Context         - NULL
    Status          - Status of the operation

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( BuildContext );
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Status );

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // We want to rebuilt the device based GPE mask here, so
    // we need the following locks
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // Now, we need to walk the device namespace and find which events
    // are special, which are wake events, and which are run-time events
    // As a matter of practical theory, its not possible for there to
    // be a _PRW on the root device extension, so we should be safely
    // able to walk only the Root's children and thereon
    //
    ACPIGpeBuildWakeMasks(RootDeviceExtension);

    //
    // We don't need these particular spin locks anymore
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    //
    // We need the power lock to touch these Power Queues
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerQueueLock );

    //
    // If we there are items on the delayed list, we need to put them
    // on the main list
    //
    if (!IsListEmpty( &AcpiPowerDelayedQueueList ) ) {

        //
        // Move the list
        //
        ACPIInternalMoveList(
            &AcpiPowerDelayedQueueList,
            &AcpiPowerQueueList
            );

        //
        // Schedule the DPC, if necessary
        ///
        if (!AcpiPowerDpcRunning) {

            KeInsertQueueDpc( &AcpiPowerDpc, 0, 0 );

        }
    }

    //
    // Done with the lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerQueueLock );

}

NTSTATUS
EXPORT
ACPITableNotifyFreeObject(
    ULONG   Event,
    PVOID   Context,
    ULONG   ObjectType
    )
/*++

Routine Description:

    This routine is called when interpreter tells us that an
    object has been freed

Arguments:

    Event       - the step in unload
    Object      - the object being unloaded
    ObjectType  - the type of the object

--*/
{
    LONG                oldReferenceCount;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   parentExtension;
    PKIRQL              oldIrql;
    PNSOBJ              object;

    //
    // Start case
    //
    if (Event == DESTROYOBJ_START) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "Unloading: Start\n"
            ) );

        oldIrql = (PKIRQL) Context;
        KeAcquireSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return STATUS_SUCCESS;

    }
    if (Event == DESTROYOBJ_END) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "Unloading: End\n"
            ) );

        oldIrql = (PKIRQL) Context;
        KeReleaseSpinLock( &AcpiDeviceTreeLock, *oldIrql );
        return STATUS_SUCCESS;
    }

    //
    // At this point, we have a either a valid unload request or
    // a bugcheck request
    //
    object = (PNSOBJ) Context;

    //
    // Let the world Know...
    //
    ACPIPrint( (
        ACPI_PRINT_CRITICAL,
        "%x: Unloading: %x %x %x\n",
        (object ? object->Context : 0),
        object,
        ObjectType,
        Event
        ) );

    //
    // Handle the bugcheck cases
    //
    if (Event == DESTROYOBJ_CHILD_NOT_FREED) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_TABLE_UNLOAD,
            (ULONG_PTR) object,
            0,
            0
            );

    }
    if (Event == DESTROYOBJ_BOGUS_PARENT) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_TABLE_UNLOAD,
            (ULONG_PTR) object,
            1,
            0
            );

    }

    //
    // We only understand processors, thermal zones, and devices for right
    // now, we will have to add power resources at a later point
    //
    if (ObjectType == OBJTYPE_POWERRES) {

        return STATUS_SUCCESS;

    }

    //
    // Grab the device extension, and make sure that one exists
    //
    deviceExtension = object->Context;
    if (deviceExtension == NULL) {

        //
        // No device extension, so we can free this thing *now*
        //
        AMLIDestroyFreedObjs( object );
        return STATUS_SUCCESS;

    }

    //
    // Mark the extension as no longer existing
    //
    ACPIInternalUpdateFlags(
        &(deviceExtension->Flags),
        DEV_PROP_UNLOADING,
        FALSE
        );

    //
    // Does this device have a parent extension? It might not
    // have an extension if the parent has been marked for removal
    //
    parentExtension = deviceExtension->ParentExtension;
    if (parentExtension != NULL) {

        //
        // Mark the parent's relations as invalid
        //
        ACPIInternalUpdateFlags(
            &(parentExtension->Flags),
            DEV_PROP_INVALID_RELATIONS,
            FALSE
            );

    }

    //
    // Finally, decrement the reference count on the device...
    //
    oldReferenceCount = InterlockedDecrement(
        &(deviceExtension->ReferenceCount)
        );
    if (oldReferenceCount == 0) {

        //
        // Free this extension
        //
        ACPIInitDeleteDeviceExtension( deviceExtension );

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPITableUnload(
    VOID
    )
/*++

Routine Description:

    This routine is called after a table has been unloaded.

    The purpose of this routine is to go out and issue the invalidate
    device relations on all elements of the table whose children are
    going away...

Arguments:

    None

Return value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension;

    //
    // We will need to hold the device tree lock for the following
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if we have to invalid the root's device extension?
    //
    deviceExtension = RootDeviceExtension;
    if (deviceExtension && !(deviceExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

        if (deviceExtension->Flags & DEV_PROP_INVALID_RELATIONS) {

            ACPIInternalUpdateFlags(
                &(deviceExtension->Flags),
                DEV_PROP_INVALID_RELATIONS,
                TRUE
                );
            IoInvalidateDeviceRelations(
                deviceExtension->PhysicalDeviceObject,
                BusRelations
                );

        } else {

            //
            // Walk the namespace looking for bogus relations
            //
            ACPITableUnloadInvalidateRelations( deviceExtension );

        }

    }

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );

    //
    // And with the function
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPITableUnloadInvalidateRelations(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This recursive routine is called to walke the namespace and issue
    the appropriate invalidates.

    The device tree lock is owned during this call...

Arguments:

    DeviceExtension - The device whose child extension we have to check

Return Value:

    NTSTATUS

--*/
{
    EXTENSIONLIST_ENUMDATA  eled;
    PDEVICE_EXTENSION       childExtension;

    //
    // Setup the data structures that we will use to walk the
    // device extension tree
    //
    ACPIExtListSetupEnum(
        &eled,
        &(DeviceExtension->ChildDeviceList),
        NULL,
        SiblingDeviceList,
        WALKSCHEME_NO_PROTECTION
        );

    //
    // Look at all the children of the current device extension
    //
    for (childExtension = ACPIExtListStartEnum( &eled) ;
         ACPIExtListTestElement( &eled, TRUE);
         childExtension = ACPIExtListEnumNext( &eled) ) {

        //
        // Does this object have any device objects?
        //
        if (!(childExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

            continue;

        }

        //
        // Do we have to invalidate this object's relations?
        //
        if (childExtension->Flags & DEV_PROP_INVALID_RELATIONS) {

            ACPIInternalUpdateFlags(
                &(childExtension->Flags),
                DEV_PROP_INVALID_RELATIONS,
                TRUE
                );
            IoInvalidateDeviceRelations(
                childExtension->PhysicalDeviceObject,
                BusRelations
                );
            continue;
        }

        //
        // Recurse
        //
        ACPITableUnloadInvalidateRelations( childExtension );

    } // for ( ... )

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\translate.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    translate.c

Abstract:

    This file implements translator interfaces for busses
    enumerated by ACPI.

    The actual translation information about this bus is
    gotten from the _CRS associated with the bus.  We put
    the data into an IO_RESOURCE_REQUIREMENTS_LIST as
    device private data of the following form:

        DevicePrivate.Data[0]:  child's CM_RESOURCE_TYPE
        DevicePrivate.Data[1]:  child's start address [31:0]
        DevicePrivate.Data[2]:  child's start address [63:32]

    The descriptor that describes child-side translation
    immediately follows the one that describes the
    parent-side resources.

    The Flags field of the IO_RESOURCE_REQUIREMENTS_LIST may have the
    TRANSLATION_RANGE_SPARSE bit set.

Author:

    Jake Oshins     7-Nov-97

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"

NTSTATUS
FindTranslationRange(
    IN  PHYSICAL_ADDRESS    Start,
    IN  LONGLONG            Length,
    IN  PBRIDGE_TRANSLATOR  Translator,
    IN  RESOURCE_TRANSLATION_DIRECTION  Direction,
    IN  UCHAR               ResType,
    OUT PBRIDGE_WINDOW      *Window
    );

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
BuildTranslatorRanges(
    IN  PBRIDGE_TRANSLATOR Translator,
    OUT ULONG *BridgeWindowCount,
    OUT PBRIDGE_WINDOW *Window
    );

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

HAL_PORT_RANGE_INTERFACE HalPortRangeInterface;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateEjectInterface)
#pragma alloc_text(PAGE, TranslateBridgeResources)
#pragma alloc_text(PAGE, TranslateBridgeRequirements)
#pragma alloc_text(PAGE, FindTranslationRange)
#pragma alloc_text(PAGE, AcpiNullReference)
#pragma alloc_text(PAGE, BuildTranslatorRanges)
#endif

NTSTATUS
TranslateEjectInterface(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioList = NULL;
    PIO_RESOURCE_DESCRIPTOR         transDesc;
    PIO_RESOURCE_DESCRIPTOR         parentDesc;
    PTRANSLATOR_INTERFACE           transInterface;
    PBRIDGE_TRANSLATOR              bridgeTrans = NULL;
    PIO_STACK_LOCATION              irpSp;
    PDEVICE_EXTENSION               devExtension;
    BOOLEAN                         foundTranslations = FALSE;
    NTSTATUS                        status;
    PUCHAR                          crsBuf = NULL;
    ULONG                           descCount;
    ULONG                           parentResType;
    ULONG                           childResType;
    ULONG                           crsBufSize;
    PHYSICAL_ADDRESS                parentStart;
    PHYSICAL_ADDRESS                childStart;

    PAGED_CODE();

    devExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    ASSERT(devExtension);
    ASSERT(devExtension->AcpiObject);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->Parameters.QueryInterface.Size >= sizeof(TRANSLATOR_INTERFACE));

    transInterface = (PTRANSLATOR_INTERFACE)irpSp->Parameters.QueryInterface.Interface;
    ASSERT(transInterface);

    //
    // Get the resources for this bus.
    //
    status = ACPIGetBufferSync(
        devExtension,
        PACKED_CRS,
        &crsBuf,
        &crsBufSize
        );
    if (!NT_SUCCESS(status)) {

        //
        // This bus has no _CRS.  So it doesn't need a translator.
        //
        status = Irp->IoStatus.Status;
        goto TranslateEjectInterfaceExit;

    }

    //
    // Turn it into something meaningful.
    //
    status = PnpBiosResourcesToNtResources(
        crsBuf,
        PNP_BIOS_TO_IO_NO_CONSUMED_RESOURCES,
        &ioList
        );
    if (!NT_SUCCESS(status)) {
        goto TranslateEjectInterfaceExit;
    }

    //
    // This was a leagal _CRS but it contained no resources that are useful to the OS.
    //
    if (!ioList) {
        status = Irp->IoStatus.Status;
        goto TranslateEjectInterfaceExit;
    }

    //
    // Cycle through the descriptors looking for device private data
    // that contains translation information.
    //

    for (descCount = 0; descCount < ioList->List[0].Count; descCount++) {

        transDesc = &ioList->List[0].Descriptors[descCount];

        if (transDesc->Type == CmResourceTypeDevicePrivate) {

            //
            // Translation information is contained in
            // a device private resource that has
            // TRANSLATION_DATA_PARENT_ADDRESS in the
            // flags field.
            //
            if (transDesc->Flags & TRANSLATION_DATA_PARENT_ADDRESS) {

                // The first descriptor cannot be a translation descriptor
                ASSERT(descCount != 0);

                //
                // The translation descriptor should follow the descriptor
                // that it is trying to modify.  The first, normal,
                // descriptor is for the child-relative resources.  The
                // second, device private, descriptor is modifies the
                // child-relative resources to generate the parent-relative
                // resources.
                //

                parentResType        = transDesc->u.DevicePrivate.Data[0];
                parentStart.LowPart  = transDesc->u.DevicePrivate.Data[1];
                parentStart.HighPart = transDesc->u.DevicePrivate.Data[2];

                childResType = ioList->List[0].Descriptors[descCount - 1].Type;
                childStart.QuadPart = (transDesc - 1)->u.Generic.MinimumAddress.QuadPart;
                
                if ((parentResType != childResType) ||
                    (parentStart.QuadPart != childStart.QuadPart)) {

                    foundTranslations = TRUE;
                    break;
                }
            }
        }
    }

    if (!foundTranslations) {

        //
        // Didn't find any translation information for this bus.
        //
        status = Irp->IoStatus.Status;
        goto TranslateEjectInterfaceExit;
    }

    //
    // Build a translator interface.
    //
    bridgeTrans = ExAllocatePoolWithTag(
        PagedPool,
        sizeof (BRIDGE_TRANSLATOR),
        ACPI_TRANSLATE_POOLTAG
        );
    if (!bridgeTrans) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto TranslateEjectInterfaceExit;

    }

    bridgeTrans->AcpiObject = devExtension->AcpiObject;
    bridgeTrans->IoList = ioList;

    //
    // Build the array of bridge windows.
    //
    status = BuildTranslatorRanges(
        bridgeTrans,
        &bridgeTrans->RangeCount,
        &bridgeTrans->Ranges
        );
    if (!NT_SUCCESS(status)) {

        goto TranslateEjectInterfaceExit;

    }
    transInterface->Size = sizeof(TRANSLATOR_INTERFACE);
    transInterface->Version = 1;
    transInterface->Context = (PVOID)bridgeTrans;
    transInterface->InterfaceReference = AcpiNullReference;
    transInterface->InterfaceDereference = AcpiNullReference;
    transInterface->TranslateResources = TranslateBridgeResources;
    transInterface->TranslateResourceRequirements = TranslateBridgeRequirements;

    status = STATUS_SUCCESS;

TranslateEjectInterfaceExit:
    if (!NT_SUCCESS(status) && bridgeTrans){

        ExFreePool(bridgeTrans);
    }

    if(crsBuf){

        ExFreePool(crsBuf);
    }

    if(ioList){

        ExFreePool(ioList);
    }
    return status;
}




NTSTATUS
FindTranslationRange(
    IN  PHYSICAL_ADDRESS    Start,
    IN  LONGLONG            Length,
    IN  PBRIDGE_TRANSLATOR  Translator,
    IN  RESOURCE_TRANSLATION_DIRECTION  Direction,
    IN  UCHAR               ResType,
    OUT PBRIDGE_WINDOW      *Window
    )
{
    LONGLONG    beginning, end;
    ULONG       i;
    UCHAR       rangeType;

    PAGED_CODE();

    for (i = 0; i < Translator->RangeCount; i++) {

        if (Direction == TranslateParentToChild) {

            beginning = Translator->Ranges[i].ParentAddress.QuadPart;
            rangeType = Translator->Ranges[i].ParentType;

        } else {

            beginning = Translator->Ranges[i].ChildAddress.QuadPart;
            rangeType = Translator->Ranges[i].ChildType;
        }

        end = beginning + Translator->Ranges[i].Length;

        if ((rangeType == ResType) &&
            (!((Start.QuadPart < beginning) ||
               (Start.QuadPart + Length > end)))) {

            //
            // The range lies within this bridge window
            // and the resource types match.
            //

            *Window = &Translator->Ranges[i];

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
TranslateBridgeResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a set of resources that are
    passed through a bridge and does any translation
    that is necessary when changing from a parent-
    relative viewpoint to a child-relative one or
    back again.

    In this function, we have the notion of a "window,"
    which is an aperature within the bridge.  Bridges
    often have multiple windows, each with distinct
    translations.

    This function should never fail, as any resource
    range that will fail translation should have already
    been stripped out by TranslateBridgeRequirements.

Arguments:

    Context - pointer to the translation data

    Source  - resource list to be translated

    Direction - TranslateChildToParent or
                    TranslateParentToChild

    AlternativesCount - not used

    Alternatives - not used

    PhysicalDeviceObject - not used

    Target  - translated resource list

Return Value:

    Status

--*/
{
    PBRIDGE_TRANSLATOR  translator;
    PBRIDGE_WINDOW      window;
    NTSTATUS            status;

    PAGED_CODE();
    ASSERT(Context);
    ASSERT((Source->Type == CmResourceTypePort) ||
           (Source->Type == CmResourceTypeMemory));

    translator = (PBRIDGE_TRANSLATOR)Context;

    ASSERT(translator->RangeCount > 0);

    //
    // Find the window that this translation occurs
    // within.
    //
    status = FindTranslationRange(Source->u.Generic.Start,
                                  Source->u.Generic.Length,
                                  translator,
                                  Direction,
                                  Source->Type,
                                  &window);

    if (!NT_SUCCESS(status)) {

        //
        // We should never get here.  This fucntion
        // should only be called for ranges that
        // are valid.  TranslateBridgeRequirements should
        // weed out all the invalid ranges.

        return status;
    }

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Target inherits the parent's resource type.
        //
        Target->Type = window->ParentType;

        //
        // Calculate the target's parent-relative start
        // address.
        //
        Target->u.Generic.Start.QuadPart =
            Source->u.Generic.Start.QuadPart +
                window->ParentAddress.QuadPart -
                window->ChildAddress.QuadPart;

        //
        // Make sure the length is still in bounds.
        //
        ASSERT(Target->u.Generic.Length <= (ULONG)(window->Length -
               (Target->u.Generic.Start.QuadPart -
                    window->ParentAddress.QuadPart)));

        status = STATUS_TRANSLATION_COMPLETE;

        break;

    case TranslateParentToChild:

        //
        // Target inherits the child's resource type.
        //
        Target->Type = window->ChildType;

        //
        // Calculate the target's child-relative start
        // address.
        //
        Target->u.Generic.Start.QuadPart =
            Source->u.Generic.Start.QuadPart +
                window->ChildAddress.QuadPart -
                window->ParentAddress.QuadPart;

        //
        // Make sure the length is still in bounds.
        //
        ASSERT(Target->u.Generic.Length <= (ULONG)(window->Length -
               (Target->u.Generic.Start.QuadPart -
                    window->ChildAddress.QuadPart)));

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

#if 0
    if (Target->Type == CmResourceTypePort) {
        DbgPrint("XXX:  %s[%d]=0x%I64x -> %s[%d]=0x%I64x\n",
                 (Direction == TranslateChildToParent) ? "child" : "parent",
                 Source->Type,
                 Source->u.Generic.Start.QuadPart,
                 (Direction == TranslateChildToParent) ? "parent" : "child",
                 Target->Type,
                 Target->u.Generic.Start.QuadPart);
    }
#endif
    
    return status;
}

NTSTATUS
TranslateBridgeRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes a resource requirements list for
    resources on the child side of the bridge and
    translates them into resource requirements on the
    parent side of the bridge.  This may involve clipping
    and there may be multiple target ranges.

Arguments:

    Context - pointer to the translation data

    Source  - resource list to be translated

    PhysicalDeviceObject - not used

    TargetCount - number of resources in the target list

    Target  - translated resource requirements list

Return Value:

    Status

--*/
{
    PBRIDGE_TRANSLATOR  translator;
    PBRIDGE_WINDOW      window;
    NTSTATUS            status;
    LONGLONG            rangeStart, rangeEnd, windowStart, windowEnd;
    ULONG               i;

    PAGED_CODE();
    ASSERT(Context);
    ASSERT((Source->Type == CmResourceTypePort) ||
           (Source->Type == CmResourceTypeMemory));

    translator = (PBRIDGE_TRANSLATOR)Context;

    //
    // Allocate memory for the target range.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    ACPI_RESOURCE_POOLTAG);

    if (!*Target) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Look at all the aperatures in the bridge to see which
    // ones of them could possibly provide translations for
    // this resource.
    //

    rangeStart = Source->u.Generic.MinimumAddress.QuadPart;
    rangeEnd   = Source->u.Generic.MaximumAddress.QuadPart;

    for (i = 0; i < translator->RangeCount; i++) {

        window = &translator->Ranges[i];

        if (window->ChildType != Source->Type) {

            //
            // This window describes the wrong
            // type of resource.
            //
            continue;
        }

        if (Source->u.Generic.Length > window->Length) {

            //
            // This resource won't fit in this aperature.
            //
            continue;
        }

        windowStart = window->ChildAddress.QuadPart;
        windowEnd = window->ChildAddress.QuadPart + (LONGLONG)window->Length;

        if (!(((rangeStart < windowStart) && (rangeEnd < windowStart)) ||
              ((rangeStart > windowEnd) && (rangeEnd > windowEnd)))) {

            //
            // The range and the window do intersect.  So create
            // a resource that clips the range to the window.
            //

            **Target = *Source;
            *TargetCount = 1;

            (*Target)->Type = window->ParentType;

            (*Target)->u.Generic.MinimumAddress.QuadPart =
                rangeStart + (window->ParentAddress.QuadPart - windowStart);

            (*Target)->u.Generic.MaximumAddress.QuadPart =
                rangeEnd + (window->ParentAddress.QuadPart - windowStart);

            break;
        }
    }

    if (i < translator->RangeCount) {

        return STATUS_TRANSLATION_COMPLETE;

    } else {

        *TargetCount = 0;
        status = STATUS_PNP_TRANSLATION_FAILED;
    }

cleanup:

    if (*Target) {
        ExFreePool(*Target);
    }

    return status;
}

NTSTATUS
BuildTranslatorRanges(
    IN  PBRIDGE_TRANSLATOR Translator,
    OUT ULONG *BridgeWindowCount,
    OUT PBRIDGE_WINDOW *Window
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioList;
    PIO_RESOURCE_DESCRIPTOR transDesc, resDesc;
    ULONG   descCount, windowCount, maxWindows;

    PAGED_CODE();

    ioList = Translator->IoList;

    //
    // Make an array of windows for holding the translation information.
    //

    maxWindows = ioList->List[0].Count / 2;

    *Window = ExAllocatePoolWithTag(PagedPool,
                                    maxWindows *  sizeof(BRIDGE_WINDOW),
                                    ACPI_TRANSLATE_POOLTAG);

    if (!*Window) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the array with translations.
    //

    windowCount = 0;

    for (descCount = 0; descCount < ioList->List[0].Count; descCount++) {

        transDesc = &ioList->List[0].Descriptors[descCount];

        if (transDesc->Type == CmResourceTypeDevicePrivate) {

            //
            // Translation information is contained in
            // a device private resource that has
            // TRANSLATION_DATA_PARENT_ADDRESS in the
            // flags field.
            //
            if (transDesc->Flags & TRANSLATION_DATA_PARENT_ADDRESS) {

                ASSERT(windowCount <= maxWindows);

                         

                //
                // The translation descriptor is supposed to follow
                // the resource that it is providing information about.
                //

                resDesc = &ioList->List[0].Descriptors[descCount - 1];



                (*Window)[windowCount].ParentType =
                    (UCHAR)transDesc->u.DevicePrivate.Data[0];

                (*Window)[windowCount].ChildType = resDesc->Type;

                (*Window)[windowCount].ParentAddress.LowPart =
                    transDesc->u.DevicePrivate.Data[1];

                (*Window)[windowCount].ParentAddress.HighPart =
                    transDesc->u.DevicePrivate.Data[2];

                (*Window)[windowCount].ChildAddress.QuadPart =
                    resDesc->u.Generic.MinimumAddress.QuadPart;

                (*Window)[windowCount].Length =
                    resDesc->u.Generic.Length;

                //
                // If the HAL has provided underlying sparse port translation
                // services, allow for that.
                //

                if ((HalPortRangeInterface.QueryAllocateRange != NULL) &&
                    (resDesc->Type == CmResourceTypePort)) {
                    
                    USHORT rangeId;
                    UCHAR parentType = (UCHAR)transDesc->u.DevicePrivate.Data[0];
                    
                    BOOLEAN isSparse = transDesc->Flags & TRANSLATION_RANGE_SPARSE;
                    ULONG parentLength = resDesc->u.Generic.Length;
                    PHYSICAL_ADDRESS parentAddress;
                    NTSTATUS status;

                    PHYSICAL_ADDRESS rangeZeroBase;

                    parentAddress.LowPart  = transDesc->u.DevicePrivate.Data[1];
                    parentAddress.HighPart = transDesc->u.DevicePrivate.Data[2];

                    rangeZeroBase.QuadPart = parentAddress.QuadPart - resDesc->u.Generic.MinimumAddress.QuadPart;                    

                    if (isSparse) {
                        parentLength = (parentLength + resDesc->u.Generic.MinimumAddress.LowPart) << 10;
                    }

                    status = HalPortRangeInterface.QueryAllocateRange(
                        isSparse,
                        parentType == CmResourceTypeMemory,
                        NULL,
                        rangeZeroBase,
                        parentLength,
                        &rangeId
                        );

                    if (NT_SUCCESS(status)) {
                        (*Window)[windowCount].ParentType = CmResourceTypePort;
                        
                        (*Window)[windowCount].ParentAddress.QuadPart =
                            ((ULONGLONG)rangeId << 16) |
                            ((*Window)[windowCount].ChildAddress.QuadPart & 0xffff);
                    }
                }

                windowCount++;
            }
        }
    }

    *BridgeWindowCount = windowCount;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\vector.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vector.h

Abstract:

    contains all structures protyptes for connecting external
    vectors to the Gpe Engine

Environment

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _VECTOR_H_
#define _VECTOR_H_

    //
    // Object returned by GpeConnectVector
    //
    typedef struct _GPE_VECTOR_OBJECT {
        ULONG                   Vector;
        PGPE_SERVICE_ROUTINE    Handler;
        PVOID                   Context;
        BOOLEAN                 Sharable;
        BOOLEAN                 HasControlMethod;
        KINTERRUPT_MODE         Mode;
    } GPE_VECTOR_OBJECT, *PGPE_VECTOR_OBJECT;

    //
    // Structure of each entry in the global GPE vector table
    //
    typedef struct {
        UCHAR                   Next;
        PGPE_VECTOR_OBJECT      GpeVectorObject;
    } GPE_VECTOR_ENTRY, *PGPE_VECTOR_ENTRY;

    extern PGPE_VECTOR_ENTRY    GpeVectorTable;
    extern UCHAR                GpeVectorFree;
    extern ULONG                GpeVectorTableSize;

    //
    // Action parameter to ACPIGpeInstallRemoveIndex
    //
    #define ACPI_GPE_EDGE_INSTALL       0
    #define ACPI_GPE_LEVEL_INSTALL      1
    #define ACPI_GPE_REMOVE             2

    //
    // Type parameter to ACPIGpeInstallRemoveIndex
    //
    #define ACPI_GPE_HANDLER            0
    #define ACPI_GPE_CONTROL_METHOD     1

    VOID
    ACPIVectorBuildVectorMasks(
        VOID
        );

    NTSTATUS
    ACPIVectorClear(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    NTSTATUS
    ACPIVectorConnect(
        PDEVICE_OBJECT          AcpiDeviceObject,
        ULONG                   GpeVector,
        KINTERRUPT_MODE         GpeMode,
        BOOLEAN                 Sharable,
        PGPE_SERVICE_ROUTINE    ServiceRoutine,
        PVOID                   ServiceContext,
        PVOID                   *GpeVectorObject
        );

    NTSTATUS
    ACPIVectorDisable(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    NTSTATUS
    ACPIVectorDisconnect(
        PVOID                   GpeVectorObject
        );

    NTSTATUS
    ACPIVectorEnable(
        PDEVICE_OBJECT      AcpiDeviceObject,
        PVOID               GpeVectorObject
        );

    VOID
    ACPIVectorFreeEntry (
        ULONG       TableIndex
        );

    BOOLEAN
    ACPIVectorGetEntry (
        PULONG              TableIndex
        );

    BOOLEAN
    ACPIVectorInstall(
        ULONG               GpeIndex,
        PGPE_VECTOR_OBJECT  GpeVectorObject
        );

    BOOLEAN
    ACPIVectorRemove(
        ULONG       GpeIndex
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\vector.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vector.c

Abstract:

    This module is how external drivers add / remove hooks to deal with
    ACPI Gpe Events

Author:

    Stephane Plante

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

//
// Table for installed GPE handlers
//
PGPE_VECTOR_ENTRY   GpeVectorTable      = NULL;
UCHAR               GpeVectorFree       = 0;
ULONG               GpeVectorTableSize  = 0;


VOID
ACPIVectorBuildVectorMasks(
    VOID
    )
/*++

Routine Description:

    This routine is called to walk the GPE Vector Table and properly
    enable all the events that we think should be enabled.

    This routine is typically called after we have loaded a new set
    of tables or we have unloaded an existing set of tables.

    We have to call this routine because at the start of the operation,
    we clear out all the knowledge of these additional vectors.

    This routine is called with GPEs disabled and the GPE Table locked
    acquired.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN installed;
    ULONG   i;
    ULONG   mode;

    //
    // Walk all the elements in the table
    //
    for (i = 0; i < GpeVectorTableSize; i++) {

        //
        // Does this entry point to a vector object?
        //
        if (GpeVectorTable[i].GpeVectorObject == NULL) {

            continue;

        }

        if (GpeVectorTable[i].GpeVectorObject->Mode == LevelSensitive) {

            mode = ACPI_GPE_LEVEL_INSTALL;

        } else {

            mode = ACPI_GPE_EDGE_INSTALL;

        }

        //
        // Install the GPE into bit-maps.  This validates the GPE number.
        //
        installed = ACPIGpeInstallRemoveIndex(
            GpeVectorTable[i].GpeVectorObject->Vector,
            mode,
            ACPI_GPE_HANDLER,
            &(GpeVectorTable[i].GpeVectorObject->HasControlMethod)
            );
        if (!installed) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPIVectorBuildVectorMasks: Could not reenable Vector Object %d\n",
                i
                ) );

        }

    }

}

NTSTATUS
ACPIVectorClear(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Clear the GPE_STS (status) bit associated with a vector object

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by
                          ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    ULONG               gpeIndex;
    ULONG               bitOffset;
    ULONG               i;

    ASSERT( localVectorObject );

    //
    // What is the GPE index for this vector?
    //
    gpeIndex = localVectorObject->Vector;

    //
    // Calculate the proper mask to use
    //
    bitOffset = gpeIndex % 8;

    //
    // Calculate the offset for the register
    //
    i = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Clear the register
    //
    ACPIWriteGpeStatusRegister (i, (UCHAR) (1 << bitOffset));
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIVectorConnect(
    PDEVICE_OBJECT          AcpiDeviceObject,
    ULONG                   GpeVector,
    KINTERRUPT_MODE         GpeMode,
    BOOLEAN                 Sharable,
    PGPE_SERVICE_ROUTINE    ServiceRoutine,
    PVOID                   ServiceContext,
    PVOID                   *GpeVectorObject
    )
/*++

Routine Description:

    Connects a handler to a general-purpose event.

Arguments:

    AcpiDeviceObject    - The ACPI object
    GpeVector           - The event number to connect to
    GpeMode             - Level or edge interrupt
    Sharable            - Can this level be shared?
    ServiceRoutine      - Address of the handler
    ServiceContext      - Context object to be passed to the handler
    *GpeVectorObject    - Pointer to where the vector object is returned

Return Value

    Returns status

--*/
{
    BOOLEAN                 installed;
    KIRQL                   oldIrql;
    NTSTATUS                status;
    PGPE_VECTOR_OBJECT      localVectorObject;
    ULONG                   mode;

    ASSERT( GpeVectorObject );

    ACPIPrint( (
        ACPI_PRINT_INFO,
        "ACPIVectorConnect: Attach GPE handler\n"
        ) );

    status = STATUS_SUCCESS;
    *GpeVectorObject = NULL;

    //
    // Do GPEs exist on this machine?
    //
    if (AcpiInformation->GpeSize == 0) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Validate the vector number (GPE number)
    //
    if ( !ACPIGpeValidIndex(GpeVector) ) {

        return STATUS_INVALID_PARAMETER_2;

    }

    //
    // Create and initialize a vector object
    //
    localVectorObject = ExAllocatePoolWithTag (
        NonPagedPool,
        sizeof(GPE_VECTOR_OBJECT),
        ACPI_SHARED_GPE_POOLTAG
        );
    if (localVectorObject == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( localVectorObject, sizeof(GPE_VECTOR_OBJECT) );
    localVectorObject->Vector   = GpeVector;
    localVectorObject->Handler  = ServiceRoutine;
    localVectorObject->Context  = ServiceContext;
    localVectorObject->Mode     = GpeMode;

    //
    // We don't implement anything other than sharable...
    //
    localVectorObject->Sharable = Sharable;

    //
    // Level/Edge mode for ACPIGpeInstallRemoveIndex()
    //
    if (GpeMode == LevelSensitive) {

        mode = ACPI_GPE_LEVEL_INSTALL;

    } else {

        mode = ACPI_GPE_EDGE_INSTALL;

    }

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are installing the handler
    //
    ACPIGpeEnableDisableEvents(FALSE);

    //
    // Install the GPE into bit-maps.  This validates the GPE number.
    //
    installed = ACPIGpeInstallRemoveIndex(
        GpeVector,
        mode,
        ACPI_GPE_HANDLER,
        &(localVectorObject->HasControlMethod)
        );
    if (!installed) {

        status = STATUS_UNSUCCESSFUL;

    } else {

        //
        // Install GPE handler into vector table.
        //
        installed = ACPIVectorInstall(
            GpeVector,
            localVectorObject
            );
        if (!installed) {

            ACPIGpeInstallRemoveIndex(
                GpeVector,
                ACPI_GPE_REMOVE,
                0,
                &localVectorObject->HasControlMethod
                );
            status = STATUS_UNSUCCESSFUL;

        }

    }

    if (!NT_SUCCESS(status)) {

        ExFreePool (localVectorObject);

    } else {

        *GpeVectorObject = localVectorObject;

    }

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    return status;
}

NTSTATUS
ACPIVectorDisable(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Temporarily disable a GPE that is already attached to a handler.

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    KIRQL               oldIrql;
    ULONG               gpeIndex;
    ULONG               bit;
    ULONG               i;

    //
    // The GPE index was validated when the handler was attached
    //
    gpeIndex = localVectorObject->Vector;

    //
    // Calculate the mask and index
    //
    bit = (1 << (gpeIndex % 8));
    i = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are fussing with the enable bits
    //
    ACPIGpeEnableDisableEvents(FALSE);

    //
    // Remove the GPE from the enable bit-maps.  This event will be completely disabled,
    // but the handler has not been removed.
    //
    GpeEnable [i]      &= ~bit;
    GpeCurEnable [i]   &= ~bit;
    ASSERT(!(GpeWakeEnable[i] & bit));

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "ACPIVectorDisable: GPE %x disabled\n",
        gpeIndex
        ) );
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIVectorDisconnect(
    PVOID                   GpeVectorObject
    )
/*++

Routine Description:

    Disconnects a handler from a general-purpose event.

Arguments:

    GpeVectorObject - Pointer to the vector object returned by
                      ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    BOOLEAN                 removed;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    PGPE_VECTOR_OBJECT      gpeVectorObj    = GpeVectorObject;

    ACPIPrint( (
        ACPI_PRINT_INFO,
        "ACPIVectorDisconnect: Detach GPE handler\n"
        ) );

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are removing the handler
    //
    ACPIGpeEnableDisableEvents (FALSE);

    //
    // Remove GPE handler From vector table.
    //
    ACPIVectorRemove(gpeVectorObj->Vector);

    //
    // Remove the GPE from the bit-maps.  Fall back to using control method
    // if available.
    //
    removed = ACPIGpeInstallRemoveIndex(
        gpeVectorObj->Vector,
        ACPI_GPE_REMOVE,
        0,
        &(gpeVectorObj->HasControlMethod)
        );
    if (!removed) {

        status = STATUS_UNSUCCESSFUL;

    }

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents(TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);

    //
    // Free the vector object, it's purpose is done.
    //
    if (status == STATUS_SUCCESS) {

        ExFreePool (GpeVectorObject);

    }
    return status;
}

NTSTATUS
ACPIVectorEnable(
    PDEVICE_OBJECT      AcpiDeviceObject,
    PVOID               GpeVectorObject
    )
/*++

Routine Description:

    Enable (a previously disabled) GPE that is already attached to a handler.

Arguments:

    AcpiDeviceObject    - The ACPI device object
    GpeVectorObject     - Pointer to the vector object returned by ACPIGpeConnectVector

Return Value

    Returns status

--*/
{
    KIRQL               oldIrql;
    PGPE_VECTOR_OBJECT  localVectorObject = GpeVectorObject;
    ULONG               bit;
    ULONG               gpeIndex;
    ULONG               gpeRegister;

    //
    // The GPE index was validated when the handler was attached
    //
    gpeIndex = localVectorObject->Vector;
    bit = (1 << (gpeIndex % 8));
    gpeRegister = ACPIGpeIndexToGpeRegister (gpeIndex);

    //
    // Lock the global tables
    //
    KeAcquireSpinLock (&GpeTableLock, &oldIrql);

    //
    // Disable GPEs while we are fussing with the enable bits
    //
    ACPIGpeEnableDisableEvents (FALSE);

    //
    // Enable the GPE in the bit maps.
    //
    GpeEnable [gpeRegister]      |= bit;
    GpeCurEnable [gpeRegister]   |= bit;

    //
    // Update hardware to match us
    //
    ACPIGpeEnableDisableEvents (TRUE);

    //
    // Unlock tables and return status
    //
    KeReleaseSpinLock (&GpeTableLock, oldIrql);
    ACPIPrint( (
        ACPI_PRINT_RESOURCES_2,
        "ACPIVectorEnable: GPE %x enabled\n",
        gpeIndex
        ) );
    return STATUS_SUCCESS;
}

VOID
ACPIVectorFreeEntry (
    ULONG       TableIndex
    )
/*++

Routine Description:

    Free a GPE vector table entry.
    NOTE: Should be called with the global GpeVectorTable locked.

Arguments:

    TableIndex  - Index into GPE vector table of entry to be freed

Return Value:

    NONE

--*/
{
    //
    // Put onto free list
    //
    GpeVectorTable[TableIndex].Next = GpeVectorFree;
    GpeVectorFree = (UCHAR) TableIndex;
}

BOOLEAN
ACPIVectorGetEntry (
    PULONG              TableIndex
    )
/*++

Routine Description:

    Get a new vector entry from the GPE vector table.
    NOTE: Should be called with the global GpeVectorTable locked.

Arguments:

    TableIndex      - Pointer to where the vector table index of the entry is returned

Return Value:

    TRUE - Success
    FALSE - Failure

--*/
{
    PGPE_VECTOR_ENTRY   Vector;
    ULONG               i, j;

#define NEW_TABLE_ENTRIES       4

    if (!GpeVectorFree) {

        //
        // No free entries on vector table, make some
        //
        i = GpeVectorTableSize;
        Vector = ExAllocatePoolWithTag (
            NonPagedPool,
            sizeof (GPE_VECTOR_ENTRY) * (i + NEW_TABLE_ENTRIES),
            ACPI_SHARED_GPE_POOLTAG
            );
        if (Vector == NULL) {

            return FALSE;

        }

        //
        // Make sure that its in a known state
        //
        RtlZeroMemory(
            Vector,
            (sizeof(GPE_VECTOR_ENTRY) * (i + NEW_TABLE_ENTRIES) )
            );

        //
        // Copy old table to new
        //
        if (GpeVectorTable) {

            RtlCopyMemory(
                Vector,
                GpeVectorTable,
                sizeof (GPE_VECTOR_ENTRY) * i
                );
            ExFreePool (GpeVectorTable);

        }

        GpeVectorTableSize += NEW_TABLE_ENTRIES;
        GpeVectorTable = Vector;

        //
        // Link new entries
        //
        for (j=0; j < NEW_TABLE_ENTRIES; j++) {

            GpeVectorTable[i+j].Next = (UCHAR) (i+j+1);

        }

        //
        // The last entry in the list gets pointed to 0, because we then
        // want to grow this list again
        //
        GpeVectorTable[i+j-1].Next = 0;

        //
        // The next free vector the head of the list that we just allocated
        //
        GpeVectorFree = (UCHAR) i;

    }

    *TableIndex = GpeVectorFree;
    Vector = &GpeVectorTable[GpeVectorFree];
    GpeVectorFree = Vector->Next;
    return TRUE;
}

BOOLEAN
ACPIVectorInstall(
    ULONG               GpeIndex,
    PGPE_VECTOR_OBJECT  GpeVectorObject
    )
/*++

Routine Description:

    Install a GPE handler into the Map and Vector tables
    NOTE: Should be called with the global GpeVectorTable locked, and GPEs disabled

Arguments:


Return Value:

    TRUE    - Success
    FALSE   - Failure

--*/
{
    ULONG               byteIndex;
    ULONG               tableIndex;

    //
    // Get an entry in the global vector table
    //
    if (ACPIVectorGetEntry (&tableIndex)) {

        //
        // Install the entry into the map table
        //
        byteIndex = ACPIGpeIndexToByteIndex (GpeIndex);
        GpeMap [byteIndex] = (UCHAR) tableIndex;

        //
        // Install the vector object in the vector table entry
        //
        GpeVectorTable [tableIndex].GpeVectorObject = GpeVectorObject;
        return TRUE;

    }

    return FALSE;
}

BOOLEAN
ACPIVectorRemove(
    ULONG       GpeIndex
    )
/*++

Routine Description:

    Remove a GPE handler from the Map and Vector tables
    NOTE: Should be called with the global GpeVectorTable locked,
    and GPEs disabled

Arguments:


Return Value:

    TRUE    - Success
    FALSE   - Failure

--*/
{
    ULONG               byteIndex;
    ULONG               tableIndex;

    //
    // Get the table index from the map table
    //
    byteIndex = ACPIGpeIndexToByteIndex (GpeIndex);
    tableIndex = GpeMap [byteIndex];

    //
    // Bounds check
    //
    if (tableIndex >= GpeVectorTableSize) {

        return FALSE;

    }

    //
    // Remember that we don't have this GpeVectorObject anymore
    //
    GpeVectorTable[tableIndex].GpeVectorObject = NULL;

    //
    // Free the slot in the master vector table
    //
    ACPIVectorFreeEntry (tableIndex);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\wmilog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Wmilog.h

Abstract:

    This module contains Wmi loging support

Author:

    Hanumant Yadav (hanumany)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _WMILOG_H_
#define _WMILOG_H_

#ifdef WMI_TRACING
    #define ACPIWMILOGEVENT(a1) {ACPIWmiLogEvent a1;}
#else
    #define ACPIWMILOGEVENT(a1)
#endif

#ifdef WMI_TRACING

//
// Defines
//

#define AMLI_LOG_GUID 0x0

#define ACPI_TRACE_MOF_FILE     L"ACPIMOFResource"

//
// Globals
//
extern GUID        GUID_List[];



extern ULONG       ACPIWmiTraceEnable;
extern ULONG       ACPIWmiTraceGlobalEnable;
extern TRACEHANDLE ACPIWmiLoggerHandle;
// End Globals

//
// Structures
//
typedef struct 
{
    EVENT_TRACE_HEADER  Header;
    MOF_FIELD           Data;
} WMI_LOG_DATA, *PWMI_LOG_DATA;




//
// Function Prototypes
//

VOID 
ACPIWmiInitLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    );

VOID 
ACPIWmiUnRegisterLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    );

NTSTATUS
ACPIWmiRegisterGuids(
    IN  PWMIREGINFO     WmiRegInfo,
    IN  ULONG           wmiRegInfoSize,
    IN  PULONG          pReturnSize
    );


VOID
ACPIGetWmiLogGlobalHandle(
    VOID
    );

NTSTATUS
ACPIWmiEnableLog(
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize
    );


NTSTATUS
ACPIWmiDisableLog(
    VOID
    );

NTSTATUS
ACPIWmiLogEvent(
    IN UCHAR    LogLevel,
    IN UCHAR    LogType,
    IN GUID     LogGUID,
    IN PUCHAR   Format, 
    IN ...
    );

NTSTATUS
ACPIDispatchWmiLog(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

#endif //WMI_TRACING

#endif // _WMILOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\wake.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    wake.h

Abstract:

    Handles wake code for the entire ACPI subsystem

Author:

    splante (splante)

Environment:

    Kernel mode only.

Revision History:

    06-18-97:   Initial Revision
    11-24-97:   Rewrite

--*/

#ifndef _WAKE_H_
#define _WAKE_H_

    //
    // This structure is used only within this module to ensure that we run
    // the _PSW methods in a synchronized and well behabed manner
    //
    typedef struct _ACPI_WAKE_PSW_CONTEXT {
        LIST_ENTRY          ListEntry;
        PDEVICE_EXTENSION   DeviceExtension;
        BOOLEAN             Enable;
        ULONG               Count;
        PFNACB              CallBack;
        PVOID               Context;
    } ACPI_WAKE_PSW_CONTEXT, *PACPI_WAKE_PSW_CONTEXT;

    //
    // This structure is used when we wake up from hibernate and we need to
    // re-enable all of the outstanding _PSWs
    //
    typedef struct _ACPI_WAKE_RESTORE_PSW_CONTEXT {

        PACPI_POWER_CALLBACK    CallBack;
        PVOID                   CallBackContext;

    } ACPI_WAKE_RESTORE_PSW_CONTEXT, *PACPI_WAKE_RESTORE_PSW_CONTEXT;

    extern  NPAGED_LOOKASIDE_LIST   PswContextLookAsideList;
    extern  BOOLEAN                 PciPmeInterfaceInstantiated;

    VOID
    ACPIWakeCompleteRequestQueue(
        IN  PLIST_ENTRY         RequestList,
        IN  NTSTATUS            Status
        );

    NTSTATUS
    ACPIWakeDisableAsync(
        IN  PDEVICE_EXTENSION   DeviceExtenion,
        IN  PLIST_ENTRY         RequestList,
        IN  PFNACB              CallBack,
        IN  PVOID               Context
        );

    NTSTATUS
    ACPIWakeEmptyRequestQueue(
        IN  PDEVICE_EXTENSION   DeviceExtension
        );

    NTSTATUS
    ACPIWakeEnableDisableAsync(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable,
        IN  PFNACB              CallBack,
        IN  PVOID               Context
        );

    VOID
    EXPORT
    ACPIWakeEnableDisableAsyncCallBack(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            ObjData,
        IN  PVOID               Context
        );

    VOID
    ACPIWakeEnableDisablePciDevice(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable
        );

    NTSTATUS
    ACPIWakeEnableDisableSync(
        IN  PDEVICE_EXTENSION   DeviceExtension,
        IN  BOOLEAN             Enable
        );

    VOID
    EXPORT
    ACPIWakeEnableDisableSyncCallBack(
        IN  PNSOBJ              AcpiObject,
        IN  NTSTATUS            Status,
        IN  POBJDATA            ObjData,
        IN  PVOID               Context
        );

    VOID
    ACPIWakeEnableWakeEvents(
        VOID
        );

    NTSTATUS
    ACPIWakeInitializePciDevice(
        IN  PDEVICE_OBJECT      DeviceObject
        );

    NTSTATUS
    ACPIWakeInitializePmeRouting(
        IN  PDEVICE_OBJECT      DeviceObject
        );

    VOID
    ACPIWakeRemoveDevicesAndUpdate(
        IN  PDEVICE_EXTENSION   TargetExtension,
        IN  PLIST_ENTRY         ListHead
        );

    NTSTATUS
    ACPIWakeRestoreEnables(
        IN  PACPI_BUILD_CALLBACK    CallBack,
        IN  PVOID                   CallBackContext
        );

    VOID
    ACPIWakeRestoreEnablesCompletion(
        IN  PDEVICE_EXTENSION       DeviceExtension,
        IN  PVOID                   Context,
        IN  NTSTATUS                Status
        );

    NTSTATUS
    ACPIWakeWaitIrp(
        IN  PDEVICE_OBJECT      DeviceObject,
        IN  PIRP                Irp
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\wake.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    wake.c

Abstract:

    Handles wake code for the entire ACPI subsystem

Author:

    splante (splante)

Environment:

    Kernel mode only.

Revision History:

    06-18-97:   Initial Revision
    11-24-97:   Rewrite

--*/

#include "pch.h"
#pragma hdrstop
#define INITGUID
#include <initguid.h>
#include <pciintrf.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIWakeEnableDisableSync)
#endif

//
// This request is used by the synchronous mechanism when it calls the
// asynchronous one
//
typedef struct _ACPI_WAKE_PSW_SYNC_CONTEXT {
    KEVENT      Event;
    NTSTATUS    Status;
} ACPI_WAKE_PSW_SYNC_CONTEXT, *PACPI_WAKE_PSW_SYNC_CONTEXT;

//
// This is a lookaside list of contexts
//
NPAGED_LOOKASIDE_LIST   PswContextLookAsideList;

//
// Pointer to the PCI PME interface, which we will need (maybe)
//
PPCI_PME_INTERFACE      PciPmeInterface;

//
// Have we loaded the PCI PME Interface?
//
BOOLEAN                 PciPmeInterfaceInstantiated;

//
// We need to access this piece of data here
//
extern PACPIInformation AcpiInformation;

VOID
ACPIWakeCompleteRequestQueue(
    IN  PLIST_ENTRY         RequestList,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine takes a LIST_ENTRY of requests to be completed and completes
    all of them. This is to minimize code duplication.

Arguments:

    RequestList - List Entry to process
    Status      - Status to complete the requests with

Return Value:

    None

--*/
{
    PLIST_ENTRY         listEntry;
    PACPI_POWER_REQUEST powerRequest;

    //
    // walk the list
    //
    listEntry = RequestList->Flink;
    while (listEntry != RequestList) {

        //
        // Crack the request
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );
        listEntry = listEntry->Flink;

        //
        // Complete this power request
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            powerRequest->DeviceExtension,
            "ACPIWakeCompleteRequestQueue - Completing 0x%08lx - %08lx\n",
            powerRequest,
            Status
            ) );
        powerRequest->Status = Status;
        ACPIDeviceIrpWaitWakeRequestComplete( powerRequest );

    }

}

NTSTATUS
ACPIWakeDisableAsync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PLIST_ENTRY         RequestList,
    IN  PFNACB              CallBack,
    IN  PVOID               Context
    )
/*++

Routine Description:

    This routine decrements the number of outstanding wake events on the
    supplied DeviceExtension by the number of items in the request list.
    If the reference goes to 0, then we run _PSW(Off) to disable wake support
    on the device

Arguments:

    DeviceExtension - Device for which we to deference the wake count
    RequestList     - The list of requests, for which the ref count will
                      be decreased
    CallBack        - Function to call when we are done
    Context         - Argument to the function

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN                 runPsw          = FALSE;
    KIRQL                   oldIrql;
    NTSTATUS                status          = STATUS_SUCCESS;
    OBJDATA                 pswData;
    PACPI_WAKE_PSW_CONTEXT  pswContext;
    PLIST_ENTRY             listEntry       = RequestList->Flink;
    PNSOBJ                  pswObject       = NULL;
    ULONG                   count           = 0;

    //
    // Walk the list, counting the number of items within it
    //
    while (listEntry != RequestList) {

        count++;
        listEntry = listEntry->Flink;

    }

    //
    // Grab the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Let the world know what happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeDisableAsync - ReferenceCount: %lx - %lx = %lx\n",
        DeviceExtension->PowerInfo.WakeSupportCount,
        count,
        (DeviceExtension->PowerInfo.WakeSupportCount - count)
        ) );

    //
    // Update the number of references on the device
    //
    ASSERT( DeviceExtension->PowerInfo.WakeSupportCount <= count );
    DeviceExtension->PowerInfo.WakeSupportCount -= count;

    //
    // Grab the pswObject
    //
    pswObject = DeviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified];
    if (pswObject == NULL) {

        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Are there no references left on the device?
    //
    if (DeviceExtension->PowerInfo.WakeSupportCount != 0) {

        //
        // If we own the PME pin for this device, then make sure that
        // we clear the status pin and keep the PME signal enabled
        //
        if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                TRUE
                );

        }
        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Allocate the _PSW context that we need to signify that there is
    // a pending _PSW on this device
    //
    pswContext = ExAllocateFromNPagedLookasideList(
        &PswContextLookAsideList
        );
    if (pswContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIWakeDisableAsyncExit;

    }

    //
    // Initialize the context
    //
    pswContext->Enable = FALSE;
    pswContext->CallBack = CallBack;
    pswContext->Context = Context;
    pswContext->DeviceExtension = DeviceExtension;
    pswContext->Count = count;

    //
    // Check to see if we are simply going to queue the context up, or
    // call the interpreter
    //
    if (IsListEmpty( &(DeviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;

    }

    //
    // List is non-empty, so we just queue up the context
    //
    InsertTailList(
        &(DeviceExtension->PowerInfo.WakeSupportList),
        &(pswContext->ListEntry)
        );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Should we run the method?
    //
    if (runPsw) {

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (DeviceExtension->Flags & DEV_PROP_HAS_PME)) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                FALSE
                );

        }

        //
        // Initialize the arguments
        //
        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = 0;

        //
        // Run the control method
        //
        status = AMLIAsyncEvalObject(
            pswObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            pswContext
            );

        //
        // What Happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeDisableAsync = 0x%08lx (P)\n",
            status
            ) );


        if (status != STATUS_PENDING) {

            ACPIWakeEnableDisableAsyncCallBack(
                pswObject,
                status,
                NULL,
                pswContext
                );

        }
        return STATUS_PENDING;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (Q)\n",
            STATUS_PENDING
            ) );

        //
        // we queued the request up, so we must return pending
        //
        return STATUS_PENDING;

    }

ACPIWakeDisableAsyncExit:

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeDisableAsync = 0x%08lx\n",
        status
        ) );

    //
    // Call the specified callback ourselves
    //
    (*CallBack)(
        pswObject,
        status,
        NULL,
        Context
        );
    return STATUS_PENDING;


}

NTSTATUS
ACPIWakeEmptyRequestQueue(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine looks at the current list of Wake Request irps and
    completes the ones that are waiting on the specified device

    Note: this code assumes that if we clear the irps out but we don't
    run _PSW(O), that nothing bad will happen if that GPE fires

Arguments:

    DeviceExtension - Device for which we want no wake requests

Return Value:

    None

--*/
{
    KIRQL               oldIrql;
    LIST_ENTRY          powerList;

    //
    // We will store the list of matching requests onto this list, so we
    // must initialize it
    //
    InitializeListHead( &powerList );

    //
    // We need to hold both the Cancel and the Power lock while we remove
    // things from the PowerQueue list
    //
    IoAcquireCancelSpinLock( &oldIrql );
    KeAcquireSpinLockAtDpcLevel( &AcpiPowerLock );
    ACPIWakeRemoveDevicesAndUpdate( DeviceExtension, &powerList );
    KeReleaseSpinLockFromDpcLevel( &AcpiPowerLock );
    IoReleaseCancelSpinLock( oldIrql );

    //
    // Complete the requests
    //
    ACPIWakeCompleteRequestQueue( &powerList, STATUS_NO_SUCH_DEVICE );

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPIWakeEnableDisableAsync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable,
    IN  PFNACB              CallBack,
    IN  PVOID               Context
    )
/*++

Routine Description:

    Given a Device Extension, updates the count of outstanding PSW on the
    device. If there is a 0-1 transition, then we must run _PSW(1). If there
    is a 1-0 transition, then we must run _PSW(0)

    NB: The CallBack will always be invoked

Arguments:


    DeviceExtension - Object to look at
    Enable          - Increment or Decrement
    CallBack        - Function to run after running _PSW()
    Context         - Argument to pass to _PSW

Return Value:

    Status

--*/
{
    BOOLEAN                 runPsw      = FALSE;
    KIRQL                   oldIrql;
    OBJDATA                 pswData;
    NTSTATUS                status      = STATUS_SUCCESS;
    PACPI_WAKE_PSW_CONTEXT  pswContext;
    PNSOBJ                  pswObject   = NULL;

    
    //
    // Update the number of references on the device
    //
    if (Enable) {

        DeviceExtension->PowerInfo.WakeSupportCount++;

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync - Count: %d (+)\n",
            DeviceExtension->PowerInfo.WakeSupportCount
            ) );

        //
        // Did we transition to one wake?
        //
        if (DeviceExtension->PowerInfo.WakeSupportCount != 1) {

            //
            // If we own the PME pin for this device, then make sure that
            // we clear the status pin and keep the PME signal enabled
            //
            if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

                ACPIWakeEnableDisablePciDevice(
                    DeviceExtension,
                    TRUE
                    );

            }
            goto ACPIWakeEnableDisableAsyncExit;

        }

    } else {

        ASSERT( DeviceExtension->PowerInfo.WakeSupportCount );
        DeviceExtension->PowerInfo.WakeSupportCount--;

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync - Count: %d (-)\n",
            DeviceExtension->PowerInfo.WakeSupportCount
            ) );

        //
        // Did we transition to zero wake?
        //
        if (DeviceExtension->PowerInfo.WakeSupportCount != 0) {

            //
            // If we own the PME pin for this device, then make sure that
            // we clear the status pin and keep the PME signal enabled
            //
            if (DeviceExtension->Flags & DEV_PROP_HAS_PME ) {

                ACPIWakeEnableDisablePciDevice(
                    DeviceExtension,
                    TRUE
                    );

            }
            goto ACPIWakeEnableDisableAsyncExit;

        }

    }

    //
    // Grab the pswObject
    //
    pswObject = DeviceExtension->PowerInfo.PowerObject[PowerDeviceUnspecified];
    if (pswObject == NULL) {

        //
        // If we got here, that means that there isn't a _PSW to be run and
        // that we should make sure that if we own the PME pin, that we should
        // set it.
        //
        if (DeviceExtension->Flags & DEV_PROP_HAS_PME) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                TRUE
                );

        }
        goto ACPIWakeEnableDisableAsyncExit;

    }

    //
    // Allocate the _PSW context that we need to signify that there is
    // a pending _PSW on this device
    //
    pswContext = ExAllocateFromNPagedLookasideList(
        &PswContextLookAsideList
        );
    if (pswContext == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIWakeEnableDisableAsyncExit;

    }

    //
    // Initialize the context
    //
    pswContext->Enable = Enable;
    pswContext->CallBack = CallBack;
    pswContext->Context = Context;
    pswContext->DeviceExtension = DeviceExtension;
    pswContext->Count = 1;

    
    //
    // Acquire the Spinlock so we can safely look at
    // the WakeSupportList without worry of someone else
    // messing with it underneath us.
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Check to see if we are simply going to queue the context up, or
    // call the interpreter
    //
    if (IsListEmpty( &(DeviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;

    }

    //
    // List is non-empty, so we just queue up the context
    //
    InsertTailList(
        &(DeviceExtension->PowerInfo.WakeSupportList),
        &(pswContext->ListEntry)
        );

    //
    // Release the lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Should we run the method?
    //
    if (runPsw) {

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (DeviceExtension->Flags & DEV_PROP_HAS_PME) &&
             pswContext->Enable == FALSE) {

            ACPIWakeEnableDisablePciDevice(
                DeviceExtension,
                FALSE
                );

        }

        //
        // Initialize the arguments
        //
        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = (Enable ? 1 : 0);

        //
        // Run the control method
        //
        status = AMLIAsyncEvalObject(
            pswObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            pswContext
            );

        //
        // What Happened
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (P)\n",
            status
            ) );

        if (status != STATUS_PENDING) {

            ACPIWakeEnableDisableAsyncCallBack(
                pswObject,
                status,
                NULL,
                pswContext
                );

        }
        return STATUS_PENDING;

    } else {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            DeviceExtension,
            "ACPIWakeEnableDisableAsync = 0x%08lx (Q)\n",
            STATUS_PENDING
            ) );

        //
        // we queued the request up, so we must return pending
        //
        return STATUS_PENDING;

    }

ACPIWakeEnableDisableAsyncExit:

    //
    // What happened
    //
    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        DeviceExtension,
        "ACPIWakeEnableDisableAsync = 0x%08lx\n",
        status
        ) );

    //
    // Call the specified callback ourselves
    //
    (*CallBack)(
        pswObject,
        status,
        NULL,
        Context
        );
    return STATUS_PENDING;

}

VOID
EXPORT
ACPIWakeEnableDisableAsyncCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    This routine is called after a _PSW method has been run on a device.

    This routine is responsible for seeing if there are any more delayed
    _PSW requests on the same device, and if so, run them.

Arguments:

    AcpiObject  - The method object that was run
    Status      - The result of the eval
    ObjData     - Not used
    Context     - PACPI_WAKE_PSW_CONTEXT

Return value:

    VOID

--*/
{
    BOOLEAN                 runPsw          = FALSE;
    KIRQL                   oldIrql;
    PACPI_WAKE_PSW_CONTEXT  pswContext      = (PACPI_WAKE_PSW_CONTEXT) Context;
    PACPI_WAKE_PSW_CONTEXT  nextContext;
    PDEVICE_EXTENSION       deviceExtension = pswContext->DeviceExtension;

    ACPIDevPrint( (
        ACPI_PRINT_WAKE,
        deviceExtension,
        "ACPIWakeEnableDisableAsyncCallBack = %08lx (C)\n",
        Status
        ) );

    //
    // Acquire the spinlock
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Remove the specified entry from the list
    //
    RemoveEntryList( &(pswContext->ListEntry) );

    //
    // If we failed the request, then we don't really know the status of the
    // _PSW on the device. Lets assume that it doesn't change and undo
    // whatever change we did to get here
    //
    if (!NT_SUCCESS(Status)) {

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "ACPIWakeEnableDisableAsyncCallBack - RefCount: %lx %s %lx = %lx\n",
            deviceExtension->PowerInfo.WakeSupportCount,
            (pswContext->Enable ? "-" : "+"),
            pswContext->Count,
            (pswContext->Enable ? deviceExtension->PowerInfo.WakeSupportCount -
             pswContext->Count : deviceExtension->PowerInfo.WakeSupportCount +
             pswContext->Count)
            ) );


        if (pswContext->Enable) {

            deviceExtension->PowerInfo.WakeSupportCount -= pswContext->Count;

        } else {

            deviceExtension->PowerInfo.WakeSupportCount += pswContext->Count;

        }

    }

    //
    // If we own the PCI PME pin for this device, the make sure to clear the
    // status and either enable it --- we enable the PME pin after we have
    // turned on the _PSW, and we disable the PME pin before we turn off
    // the _PSW
    //
    if ( (deviceExtension->Flags & DEV_PROP_HAS_PME) &&
         pswContext->Enable == TRUE) {

        ACPIWakeEnableDisablePciDevice(
            deviceExtension,
            pswContext->Enable
            );

    }

    //
    // Are the any items on the list?
    //
    if (!IsListEmpty( &(deviceExtension->PowerInfo.WakeSupportList) ) ) {

        runPsw = TRUE;
        nextContext = CONTAINING_RECORD(
            deviceExtension->PowerInfo.WakeSupportList.Flink,
            ACPI_WAKE_PSW_CONTEXT,
            ListEntry
            );

    }

    //
    // We can release the lock now
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Call the callback on the completed item
    //
    (*pswContext->CallBack)(
        AcpiObject,
        Status,
        ObjData,
        (pswContext->Context)
        );

    //
    // Free the completed context
    //
    ExFreeToNPagedLookasideList(
        &PswContextLookAsideList,
        pswContext
        );

    //
    // Do we have to run a method?
    //
    if (runPsw) {

        NTSTATUS    status;
        OBJDATA     pswData;

        RtlZeroMemory( &pswData, sizeof(OBJDATA) );
        pswData.dwDataType = OBJTYPE_INTDATA;
        pswData.uipDataValue = (nextContext->Enable ? 1 : 0);

        //
        // If we own the PCI PME pin for this device, the make sure to clear the
        // status and disable it --- we enable the PME pin after we have
        // turned on the _PSW, and we disable the PME pin before we turn off
        // the _PSW
        //
        if ( (deviceExtension->Flags & DEV_PROP_HAS_PME) &&
             nextContext->Enable == FALSE) {

            ACPIWakeEnableDisablePciDevice(
                deviceExtension,
                FALSE
                );

        }

        //
        // Call the interpreter
        //
        status = AMLIAsyncEvalObject(
            AcpiObject,
            NULL,
            1,
            &pswData,
            ACPIWakeEnableDisableAsyncCallBack,
            nextContext
            );

        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            nextContext->DeviceExtension,
            "ACPIWakeEnableDisableAsyncCallBack = 0x%08lx (M)\n",
            status
            ) );

        if (status != STATUS_PENDING) {

            //
            // Ugh - Recursive
            //
            ACPIWakeEnableDisableAsyncCallBack(
                AcpiObject,
                status,
                NULL,
                nextContext
                );

        }

    }

}

VOID
ACPIWakeEnableDisablePciDevice(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable
    )
/*++

Routine Description:

    This routine is what is actually called to enable or disable the
    PCI PME pin for a device

    N.B. The AcpiPowerLock must be owned

Arguments:

    DeviceExtension - The device extension that is a filter on top of the
                      pdo from the PCI device
    Enable          - True to enable PME, false otherwise

Return Value:

    None

--*/
{
    KIRQL   oldIrql;


    //
    // Is there an interface present?
    //
    if (!PciPmeInterfaceInstantiated) {

        return;

    }

    //
    // Prevent the device from going away while we make this call
    //
    KeAcquireSpinLock( &AcpiDeviceTreeLock, &oldIrql );

    //
    // Check to see if there is a device object...
    //
    if (!DeviceExtension->PhysicalDeviceObject) {

        KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
        return;

    }

    PciPmeInterface->UpdateEnable(
        DeviceExtension->PhysicalDeviceObject,
        Enable
        );

    //
    // Done with the lock
    //
    KeReleaseSpinLock( &AcpiDeviceTreeLock, oldIrql );
}

NTSTATUS
ACPIWakeEnableDisableSync(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  BOOLEAN             Enable
    )
/*++

Routine Description:

    Given a DeviceExtension, enables or disables the device wake support
    from the device

    NB: This routine can only be called at passive level

Arguments:

    DeviceExtension - The device we care about
    Enable          - True if we are to enable, false otherwise

Return Value:

    NTSTATUS

--*/
{
    ACPI_WAKE_PSW_SYNC_CONTEXT  syncContext;
    NTSTATUS                    status;

    PAGED_CODE();

    ASSERT( DeviceExtension != NULL &&
            DeviceExtension->Signature == ACPI_SIGNATURE );

    //
    // Initialize the event
    //
    KeInitializeEvent( &syncContext.Event, NotificationEvent, FALSE );

    //
    // Call the async procedure
    //
    status = ACPIWakeEnableDisableAsync(
        DeviceExtension,
        Enable,
        ACPIWakeEnableDisableSyncCallBack,
        &syncContext
        );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &syncContext.Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = syncContext.Status;

    }

    //
    // Done
    //
    return status;
}

VOID
EXPORT
ACPIWakeEnableDisableSyncCallBack(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjData,
    IN  PVOID       Context
    )
/*++

Routine Description:

    The Async part of the EnableDisable request has been completed

Arguments:

    AcpiObject  - The object that was executed
    Status      - The result of the operation
    ObjData     - Not used
    Context     - ACPI_WAKE_PSW_SYNC_CONTEXT

Return Value:

    VOID

--*/
{
    PACPI_WAKE_PSW_SYNC_CONTEXT pswContext = (PACPI_WAKE_PSW_SYNC_CONTEXT) Context;

    UNREFERENCED_PARAMETER(AcpiObject);
    UNREFERENCED_PARAMETER(ObjData);

    //
    // Set the real status
    //
    pswContext->Status = Status;

    //
    // Set the event
    //
    KeSetEvent( &(pswContext->Event), IO_NO_INCREMENT, FALSE );
}

VOID
ACPIWakeEnableWakeEvents(
    VOID
    )
/*++

Routine Description:

    This routine is called just before the system is put to sleep.

    The purpose of this routine is re-allow all wake and run-time events
    in the GpeCurEnable to be correctly set. After the machine wakes up,
    the machine will check that register to see if any events triggered the
    wakeup

    NB: This routine is called with interrupts off.

Arguments:

    None

Return Value:

    None

--*/
{
    KIRQL   oldIrql;
    ULONG   gpeRegister = 0;

    //
    // This function is called when interrupts are disabled, so in theory,
    // all the following should be safe. However, better safe than sorry.
    //
    KeAcquireSpinLock( &GpeTableLock, &oldIrql );

    //
    // Remember that on the way back up, we will entering the S0 state
    //
    AcpiPowerLeavingS0 = FALSE;

    //
    // Update all the registers
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        //
        // In any case, make sure that our current enable mask includes all
        // the wake registers, but doesn't include any of the pending
        // events
        //
        GpeCurEnable[gpeRegister] |= (GpeWakeEnable[gpeRegister] &
            ~GpePending[gpeRegister]);

    }

    //
    // Set the wake events only
    //
    ACPIGpeEnableWakeEvents();

    //
    // Done with the table lock
    //
    KeReleaseSpinLock( &GpeTableLock, oldIrql );
}

NTSTATUS
ACPIWakeInitializePciDevice(
    IN  PDEVICE_OBJECT      DeviceObject
    )
/*++

Routine Description:

    This routine is called when a filter is started to determine if the PCI
    device is capable of generating a PME

Arguments:

    DeviceObject    - The device object to initialize

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN             pmeSupported;
    BOOLEAN             pmeStatus;
    BOOLEAN             pmeEnable;
    KIRQL               oldIrql;
    PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);

    //
    // We don't have to worry if the device doesn't support wake methods
    // directly
    //
    if (!(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        return STATUS_SUCCESS;

    }

    //
    // Need to grab the power lock to do the following
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );

    //
    // Do we have an interface to call?
    //
    if (PciPmeInterfaceInstantiated == FALSE) {

        goto ACPIWakeInitializePciDeviceExit;

    }

    //
    // Get the status of PME for this device
    //
    PciPmeInterface->GetPmeInformation(
        deviceExtension->PhysicalDeviceObject,
        &pmeSupported,
        &pmeStatus,
        &pmeEnable
        );

    //
    // if the device supports pme, then we own it...
    //
    if (pmeSupported == TRUE) {

        //
        // We own the PME pin for this device
        //
        ACPIInternalUpdateFlags(
            &(deviceExtension->Flags),
            (DEV_PROP_HAS_PME),
            FALSE
            );

        //
        // Check to see if we should disable PME or disable the PME status
        //
        if (pmeEnable) {

            //
            // Calling this also clears the PME status pin
            //
            PciPmeInterface->UpdateEnable(
                deviceExtension->PhysicalDeviceObject,
                FALSE
                );

        } else if (pmeStatus) {

            //
            // Clear the PME status
            //
            PciPmeInterface->ClearPmeStatus(
                deviceExtension->PhysicalDeviceObject
                );

        }

    }

ACPIWakeInitializePciDeviceExit:
    //
    // Done with lock
    //
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIWakeInitializePmeRouting(
    IN  PDEVICE_OBJECT      DeviceObject
    )
/*++

Routine Description:

    This routine will ask the PCI driver for its PME interface

Arguments:

    DeviceObject    - The ACPI PDO for a PCI root bus

Return Value:

    NTSTATUS

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            status;
    IO_STACK_LOCATION   irpSp;
    PPCI_PME_INTERFACE  interface;
    PULONG              dummy;

    //
    // Allocate some memory for the interface
    //
    interface = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PCI_PME_INTERFACE),
        ACPI_ARBITER_POOLTAG
        );
    if (interface == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the stack location
    //
    RtlZeroMemory( &irpSp, sizeof(IO_STACK_LOCATION) );
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCI_PME_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = PCI_PME_INTRF_STANDARD_VER;
    irpSp.Parameters.QueryInterface.Size = sizeof (PCI_PME_INTERFACE);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Send the request along
    //
    status = ACPIInternalSendSynchronousIrp(
        DeviceObject,
        &irpSp,
        &dummy
        );
    if (!NT_SUCCESS(status)) {

        PDEVICE_EXTENSION   deviceExtension = ACPIInternalGetDeviceExtension( DeviceObject );

        ACPIDevPrint( (
            ACPI_PRINT_CRITICAL,
            deviceExtension,
            " - ACPIWakeInitializePmeRouting = %08lx\n",
            status
            ) );

        //
        // Free the memory and return
        //
        ExFreePool( interface );
        return status;

    }

    //
    // Do this under spinlock protection
    //
    KeAcquireSpinLock( &AcpiPowerLock, &oldIrql );
    if (PciPmeInterfaceInstantiated == FALSE) {

        //
        // Keep a global pointer to the interface
        //
        PciPmeInterfaceInstantiated = TRUE;
        PciPmeInterface = interface;

    } else {

        //
        // Someone else got here before us, so we need to make sure
        // that we free the extra memory
        //
        ExFreePool (interface );

    }
    KeReleaseSpinLock( &AcpiPowerLock, oldIrql );

    //
    // Done
    //
    return status;
}

VOID
ACPIWakeRemoveDevicesAndUpdate(
    IN  PDEVICE_EXTENSION   TargetExtension,
    OUT PLIST_ENTRY         ListHead
    )
/*++

Routine Description:

    This routine finds the all of the WaitWake requests associated with
    TargetDevice and return them on ListHead. This is done in a 'safe' way

    NB: Caller must hold the AcpiPowerLock and Cancel Lock!

Arguments:

    TargetExtension - The target extension that we are looking for
    ListHead        - Where to store the list of matched devices

Return Value:

    NONE

--*/
{
    PACPI_POWER_REQUEST powerRequest;
    PDEVICE_EXTENSION   deviceExtension;
    PLIST_ENTRY         listEntry;
    SYSTEM_POWER_STATE  sleepState;
    ULONG               gpeRegister;
    ULONG               gpeMask;
    ULONG               byteIndex;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // We need to synchronize with the ProcessGPE code because we are going
    // to touch one of the GPE Masks
    //
    KeAcquireSpinLockAtDpcLevel( &GpeTableLock );

    //
    // The first step is to disable all the wake vectors
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        //
        // Remove the wake vectors from the real-time vectors.
        // Note that since we are going to be writting the GPE Enable vector
        // later on in the process, it seems pointless to actually write them
        // now as well
        //
        GpeCurEnable[gpeRegister] &= (GpeSpecialHandler[gpeRegister] |
            ~(GpeWakeEnable[gpeRegister] | GpeWakeHandler[gpeRegister]));

    }

    //
    // Next step is to reset the wake mask
    //
    RtlZeroMemory( GpeWakeEnable, AcpiInformation->GpeSize * sizeof(UCHAR) );


    //
    // Look at the first element in the wake list
    //
    listEntry = AcpiPowerWaitWakeList.Flink;

    //
    // Loop for all elements in the list
    //
    while (listEntry != &AcpiPowerWaitWakeList) {

        //
        // Grab the irp from the listEntry
        //
        powerRequest = CONTAINING_RECORD(
            listEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Point to the next request
        //
        listEntry = listEntry->Flink;

        //
        // Obtain the device extension for the request
        //
        deviceExtension = powerRequest->DeviceExtension;

        //
        // If this device is to be removed, then remove it
        //
        if (deviceExtension == TargetExtension) {

            //
            // Remove the request from the list and move it to the next
            // list. Mark the irp as no longer cancelable.
            //
            IoSetCancelRoutine( (PIRP) powerRequest->Context, NULL );
            RemoveEntryList( &powerRequest->ListEntry );
            InsertTailList( ListHead, &powerRequest->ListEntry );

        } else {

            //
            // If the wake level of the bit indicates that it isn't supported
            // in the current sleep state, then don't enable it... Note that
            // this doesn't solve the problem where two devices share the
            // same vector, one can wake the computer from S2, one from S3 and
            // we are going to S3. In this case, we don't have the smarts to
            // un-run the _PSW from the S2 device
            //
            sleepState = powerRequest->u.WaitWakeRequest.SystemPowerState;
            if (sleepState < AcpiMostRecentSleepState) {

                continue;

            }

            //
            // Get the byteIndex for this GPE
            //
            byteIndex = ACPIGpeIndexToByteIndex(
                deviceExtension->PowerInfo.WakeBit
                );

            //
            // Drivers cannot register on wake vectors
            //
            if (GpeMap[byteIndex]) {

                ACPIDevPrint( (
                    ACPI_PRINT_WAKE,
                    deviceExtension,
                    "ACPIWakeRemoveDeviceAndUpdate - %x cannot be used as a"
                    "wake pin.\n",
                    deviceExtension->PowerInfo.WakeBit
                    ) );
                continue;

            }

            //
            // Calculate the entry and offset. Assume that the Parameter is
            // at most a UCHAR
            //
            gpeRegister = ACPIGpeIndexToGpeRegister(
                deviceExtension->PowerInfo.WakeBit
                );
            gpeMask  = 1 << ( (UCHAR) deviceExtension->PowerInfo.WakeBit % 8);

            //
            // This GPE is being used as a wake event
            //
            if (!(GpeWakeEnable[gpeRegister] & gpeMask)) {

                //
                // This is a wake pin
                //
                GpeWakeEnable[gpeRegister] |= gpeMask;

                //
                // Prevent machine stupity and try to clear the Status bit
                //
                ACPIWriteGpeStatusRegister( gpeRegister, (UCHAR) gpeMask );

                //
                // Do we have a control method associated with this GPE?
                //
                if (!(GpeEnable[gpeRegister] & gpeMask)) {

                    //
                    // Is this GPE already enabled?
                    //
                    if (GpeCurEnable[gpeRegister] & gpeMask) {

                        continue;

                    }

                    //
                    // Not enabled -- then there is no control method for this
                    // GPE, consider this to be a level vector.
                    //
                    GpeIsLevel[gpeRegister] |= gpeMask;
                    GpeCurEnable[gpeRegister] |= gpeMask;

                } else if (!(GpeSpecialHandler[gpeRegister] & gpeMask) ) {

                    //
                    // In this case, the GPE *does* have a control method
                    // associated with it. Remember that.
                    //
                    GpeWakeHandler[gpeRegister] |= gpeMask;

                }

            }

        }

    }

    //
    // Update all the registers
    //
    for (gpeRegister = 0; gpeRegister < AcpiInformation->GpeSize; gpeRegister++) {

        if (AcpiPowerLeavingS0) {

            //
            // If we are leaving S0, then make sure to remove *all* the
            // wake events that we know about from the current enable mask.
            // If any wake events are currently pending, that will cause us
            // to continue processing them, but hopefully will not lead us
            // to renable them
            //
            GpeCurEnable[gpeRegister] &= ~GpeWakeEnable[gpeRegister];

        } else {

            //
            // If we are re-entering S0, then we need to renable all the wake
            // events, except the ones that we are already processing
            //
            GpeCurEnable[gpeRegister] |= (GpeWakeEnable[gpeRegister] &
                ~GpePending[gpeRegister]);

        }

        //
        // Now that we have calculate what the proper register should be,
        // write it back to the hardware
        //
        ACPIWriteGpeEnableRegister( gpeRegister, GpeCurEnable[gpeRegister] );

    }

    //
    // Done with the spinlock
    //
    KeReleaseSpinLockFromDpcLevel( &GpeTableLock );

    //
    // Done
    //
    return;
}

NTSTATUS
ACPIWakeRestoreEnables(
    IN  PACPI_BUILD_CALLBACK    CallBack,
    IN  PVOID                   CallBackContext
    )
/*++

Routine Description:

    This routine re-runs through the list of WAIT-WAKE irps and runs the _PSW
    method for each of those irps again. The reason that this is done is to
    restore the state of the hardware to what the OS thinks the state is.

Arguments:

    CallBack        - The function to call when done
    CallBackContext - The context to pass to that function

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        status;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // We need to hold the device tree lock
    //
    KeAcquireSpinLockAtDpcLevel( &AcpiDeviceTreeLock );

    //
    // Call the build routines that we have already tested and running to
    // cause them to walk the device extension tree and run the appropriate
    // control methods
    //
    status = ACPIBuildRunMethodRequest(
        RootDeviceExtension,
        CallBack,
        CallBackContext,
        PACKED_PSW,
        (RUN_REQUEST_CHECK_STATUS | RUN_REQUEST_RECURSIVE |
         RUN_REQUEST_CHECK_WAKE_COUNT),
        TRUE
        );

    //
    // Done with the device tree lock
    //
    KeReleaseSpinLockFromDpcLevel( &AcpiDeviceTreeLock );

    //
    // Done
    //
    return status;
}

VOID
ACPIWakeRestoreEnablesCompletion(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PVOID               Context,
    IN  NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called after we have finished running all the _PSWs in the
    system

Arguments:

    DeviceExtension - The device that just completed the enables
    Context         - PACPI_POWER_REQUEST
    Status          - What the status of the operation was

--*/
{
    UNREFERENCED_PARAMETER( DeviceExtension);

    //
    // Restart the device power management engine
    //
    ACPIDeviceCompleteGenericPhase(
        NULL,
        Status,
        NULL,
        Context
        );
}

NTSTATUS
ACPIWakeWaitIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the routine that is called when the system wants to be notified
    of this device waking the system.

Arguments:

    DeviceObject    - The device object which is supposed to wake the system
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = ACPIInternalGetDeviceExtension(DeviceObject);
    PIO_STACK_LOCATION      irpStack;

    //
    // The first step is to decide if this object can actually support
    // a wake.
    //
    if ( !(deviceExtension->Flags & DEV_CAP_WAKE) ) {

        //
        // We do not support wake
        //
        return ACPIDispatchForwardOrFailPowerIrp( DeviceObject, Irp );

    }

    //
    // Get the stack parameters
    //
    irpStack = IoGetCurrentIrpStackLocation( Irp );

    //
    // We must make sure that we are at the correct system level
    // to support this functionality
    //
    if (deviceExtension->PowerInfo.SystemWakeLevel <
        irpStack->Parameters.WaitWake.PowerState) {

        //
        // The system level is not the one we are currently at
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "(0x%08lx): ACPIWakeWaitIrp ->S%d < Irp->S%d\n",
            Irp,
            deviceExtension->PowerInfo.SystemWakeLevel - 1,
            irpStack->Parameters.WaitWake.PowerState - 1
            ) );

        //
        // Fail the Irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_STATE;
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    //
    // We must make sure that the device is in the proper device level
    // to support this functionality
    //
    if (deviceExtension->PowerInfo.DeviceWakeLevel <
        deviceExtension->PowerInfo.PowerState) {

        //
        // We are too much powered off to wake the computer
        //
        ACPIDevPrint( (
            ACPI_PRINT_WAKE,
            deviceExtension,
            "(0x%08lx): ACPIWakeWaitIrp  Device->D%d Max->D%d\n",
            Irp,
            deviceExtension->PowerInfo.DeviceWakeLevel - 1,
            deviceExtension->PowerInfo.PowerState - 1
            ) );

        //
        // Fail the irp
        //
        Irp->IoStatus.Status = status = STATUS_INVALID_DEVICE_STATE;
        PoStartNextPowerIrp( Irp );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;

    }

    //
    // At this point, we are definately going to run the completion routine
    // so, we mark the irp as pending and increment the reference count
    //
    IoMarkIrpPending( Irp );
    InterlockedIncrement( &deviceExtension->OutstandingIrpCount );

    //
    // Feed the request to the device power management subsystem. Note that
    // this function is supposed to invoke the completion request no matter
    // what happens.
    //
    status = ACPIDeviceIrpWaitWakeRequest(
        DeviceObject,
        Irp,
        ACPIDeviceIrpCompleteRequest
        );
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = STATUS_PENDING;

    } else {

        //
        // Remove our reference
        //
        ACPIInternalDecrementIrpReferenceCount( deviceExtension );

    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\worker.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    butt.h

Abstract:

    This module contains the enumerated for the ACPI driver, NT version

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Model Driver only

--*/


#ifndef _WORKER_H_
#define _WORKER_H_

VOID
ACPIInitializeWorker (
    VOID
    );

VOID
ACPISetDeviceWorker (
    IN PDEVICE_EXTENSION    DevExt,
    IN ULONG                Events
    );

#endif _WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\wmilog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    WmiLog.c

Abstract:

    This module contains Wmi loging support.

Author:

    Hanumant Yadav (hanumany) 18-Dec-2000

Revision History:

--*/



#include "pch.h"
#include <evntrace.h>



#ifdef WMI_TRACING
//
//Globals
//
GUID        GUID_List[] =
{
    {0xF2E0E060L, 0xBF32, 0x4B88, 0xB8, 0xE4, 0x5C, 0xAD, 0x15, 0xAF, 0x6A, 0xE9} /* AMLI log GUID */
    /* Add new logging GUIDS here */
};



ULONG       ACPIWmiTraceEnable = 0;
ULONG       ACPIWmiTraceGlobalEnable = 0;
TRACEHANDLE ACPIWmiLoggerHandle = 0;

// End Globals



VOID
ACPIWmiInitLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    )
/*++

Routine Description:

    This is a initialization function in which we call IoWMIRegistrationControl
    to register for WMI loging.

Arguments:
    ACPIDeviceObject.

Return Value:
    None.

--*/
{
    NTSTATUS status;
    //
    // Register with WMI.
    //
    status = IoWMIRegistrationControl(ACPIDeviceObject,
                                      WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status))
    {
        ACPIPrint( (
                    DPFLTR_ERROR_LEVEL,
                    "ACPIWmiInitLog: Failed to register for WMI support\n"
                 ) );
    }
    return;
}

VOID
ACPIWmiUnRegisterLog(
    IN  PDEVICE_OBJECT ACPIDeviceObject
    )
/*++

Routine Description:

    This is a unregistration function in which we call IoWMIRegistrationControl
    to unregister for WMI loging.

Arguments:
    ACPIDeviceObject.

Return Value:
    None.

--*/
{
    NTSTATUS status;
    //
    // Register with WMI.
    //
    status = IoWMIRegistrationControl(ACPIDeviceObject,
                                      WMIREG_ACTION_DEREGISTER);
    if (!NT_SUCCESS(status))
    {
        ACPIPrint( (
                    DPFLTR_ERROR_LEVEL,
                    "ACPIWmiInitLog: Failed to unregister for WMI support\n"
                 ) );
    }
    return;
}

NTSTATUS
ACPIWmiRegisterGuids(
    IN  PWMIREGINFO             WmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
/*++

Routine Description:

    This function handles WMI GUID registration goo.

Arguments:
    WmiRegInfo,
    wmiRegInfoSize,
    pReturnSize

Return Value:
    STATUS_SUCCESS on success.

--*/
{
    //
    // Register a Control Guid as a Trace Guid.
    //

    ULONG           SizeNeeded;
    PWMIREGGUIDW    WmiRegGuidPtr;
    ULONG           Status;
    ULONG           GuidCount;
    LPGUID          ControlGuid;
    ULONG           RegistryPathSize;
    ULONG           MofResourceSize;
    PUCHAR          ptmp;
    GUID            ACPITraceGuid  = {0xDAB01D4DL, 0x2D48, 0x477D, 0xB1, 0xC3, 0xDA, 0xAD, 0x0C, 0xE6, 0xF0, 0x6B};

    
    *pReturnSize = 0;
    GuidCount = 1;
    ControlGuid = &ACPITraceGuid;

    //
    // Allocate WMIREGINFO for controlGuid + GuidCount.
    //
    RegistryPathSize = sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR) + sizeof(USHORT);
    MofResourceSize =  sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR) + sizeof(USHORT);
    SizeNeeded = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW) +
                 RegistryPathSize +
                 MofResourceSize;


    if (SizeNeeded  > wmiRegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_SUCCESS;
    }


    RtlZeroMemory(WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;
    WmiRegInfo->RegistryPath = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW);
    WmiRegInfo->MofResourceName = WmiRegInfo->RegistryPath + RegistryPathSize; //ACPI_TRACE_MOF_FILE;

    WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[0];
    WmiRegGuidPtr->Guid = *ControlGuid;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    WmiRegGuidPtr->InstanceCount = 0;
    WmiRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&WmiRegInfo->WmiRegGuid[1];
    *((PUSHORT)ptmp) = sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, ACPI_REGISTRY_KEY, sizeof(ACPI_REGISTRY_KEY) - sizeof(WCHAR));

    ptmp = (PUCHAR)WmiRegInfo + WmiRegInfo->MofResourceName;
    *((PUSHORT)ptmp) = sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, ACPI_TRACE_MOF_FILE, sizeof(ACPI_TRACE_MOF_FILE) - sizeof(WCHAR));

    *pReturnSize =  SizeNeeded;
    return(STATUS_SUCCESS);

}


VOID
ACPIGetWmiLogGlobalHandle(
    VOID
    )
/*++

Routine Description:

    This function gets the global wmi logging handle. We need this to log
    at boot time, before we start getting wmi messages.

Arguments:
    None.

Return Value:
    None.

--*/
{
    WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &ACPIWmiLoggerHandle);
    if(ACPIWmiLoggerHandle)
    {
       ACPIPrint( (
                    DPFLTR_INFO_LEVEL,
                    "ACPIGetWmiLogGlobalHandle: Global handle aquired. Handle = %I64u\n",
                    ACPIWmiLoggerHandle
                ) );

        ACPIWmiTraceGlobalEnable = 1;
    }
    return;
}


NTSTATUS
ACPIWmiEnableLog(
    IN  PVOID Buffer,
    IN  ULONG BufferSize
    )
/*++

Routine Description:

    This function is the handler for IRP_MN_ENABLE_EVENTS.

Arguments:
    Buffer,
    BufferSize

Return Value:
    NTSTATUS

--*/
{
    PWNODE_HEADER Wnode=NULL;

    InterlockedExchange(&ACPIWmiTraceEnable, 1);

    Wnode = (PWNODE_HEADER)Buffer;
    if (BufferSize >= sizeof(WNODE_HEADER)) {
        ACPIWmiLoggerHandle = Wnode->HistoricalContext;
        //
        // reset the global logger if it is active.
        //
        if(ACPIWmiTraceGlobalEnable)
            ACPIWmiTraceGlobalEnable = 0;

       ACPIPrint( (
                    DPFLTR_INFO_LEVEL,
                    "ACPIWmiEnableLog: LoggerHandle = %I64u. BufferSize = %d. Flags = %x. Version = %x\n",
                    ACPIWmiLoggerHandle,
                    Wnode->BufferSize,
                    Wnode->Flags,
                    Wnode->Version
                ) );

    }

    return(STATUS_SUCCESS);

}

NTSTATUS
ACPIWmiDisableLog(
    VOID
    )
/*++

Routine Description:

    This function is the handler for IRP_MN_DISABLE_EVENTS.

Arguments:
    None.

Return Value:
    NTSTATUS

--*/
{
    InterlockedExchange(&ACPIWmiTraceEnable, 0);
    ACPIWmiLoggerHandle = 0;

    return(STATUS_SUCCESS);
}

NTSTATUS
ACPIWmiLogEvent(
    IN UCHAR    LogLevel,
    IN UCHAR    LogType,
    IN GUID     LogGUID,
    IN PUCHAR   Format,
    IN ...
    )
/*++

Routine Description:

    This is the main wmi logging funcion. This function should be used
    throughtout the ACPI driver where WMI logging is required.

Arguments:
    LogLevel,
    LogType,
    LogGUID,
    Format,
    ...

Return Value:
    NTSTATUS

--*/
{
    static char         Buffer[1024];
    va_list             marker;
    WMI_LOG_DATA        Wmi_log_data ={0,0};
    EVENT_TRACE_HEADER  *Wnode;
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    va_start(marker, Format);
    vsprintf(Buffer, Format, marker);
    va_end(marker);

    if(ACPIWmiTraceEnable || ACPIWmiTraceGlobalEnable)
    {
        if(ACPIWmiLoggerHandle)
        {
            Wmi_log_data.Data.DataPtr = (ULONG64)&Buffer;
            Wmi_log_data.Data.Length = strlen(Buffer) + 1;
            Wmi_log_data.Header.Size = sizeof(WMI_LOG_DATA);
            Wmi_log_data.Header.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
            Wmi_log_data.Header.Class.Type = LogType;
            Wmi_log_data.Header.Class.Level = LogLevel;
            Wmi_log_data.Header.Guid = LogGUID;
            Wnode = &Wmi_log_data.Header;
            ((PWNODE_HEADER)Wnode)->HistoricalContext = ACPIWmiLoggerHandle;

            //
            // Call TraceLogger to  write this event
            //

            status = IoWMIWriteEvent((PVOID)&(Wmi_log_data.Header));

            //
            // if IoWMIWriteEvent fails and we are using the global logger handle,
            // we need to stop loging.
            //
            if(status != STATUS_SUCCESS)
            {
                if(ACPIWmiTraceGlobalEnable)
                {
                    ACPIWmiLoggerHandle = 0;
                    ACPIWmiTraceGlobalEnable = 0;
                    ACPIPrint( (
                            ACPI_PRINT_INFO,
                            "ACPIWmiLogEvent: Disabling WMI loging using global handle. status = %x\n",
                            status
                         ) );
                }
                else
                {
                    ACPIPrint( (
                                DPFLTR_ERROR_LEVEL,
                                "ACPIWmiLogEvent: Failed to log. status = %x\n",
                                status
                             ) );
                }

            }
        }
    }

    return status;
}


NTSTATUS
ACPIDispatchWmiLog(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    UCHAR                   minorFunction;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the dispatch table that we will be using and the minor code as well,
    // so that we can look it when required
    //
    ASSERT(RootDeviceExtension->DeviceObject == DeviceObject);

    if (DeviceObject != (PDEVICE_OBJECT) irpSp->Parameters.WMI.ProviderId) {

        return ACPIDispatchForwardIrp(DeviceObject, Irp);
    }

    minorFunction = irpSp->MinorFunction;

    switch(minorFunction){

        case IRP_MN_REGINFO:{
            
            ULONG ReturnSize = 0;
            ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
            PVOID Buffer = irpSp->Parameters.WMI.Buffer;

            status=ACPIWmiRegisterGuids(
                                         Buffer,
                                         BufferSize,
                                         &ReturnSize
                                        );

            Irp->IoStatus.Information = ReturnSize;
            Irp->IoStatus.Status = status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_ENABLE_EVENTS:{
            
            status=ACPIWmiEnableLog(
                                    irpSp->Parameters.WMI.Buffer,
                                    irpSp->Parameters.WMI.BufferSize
                                   );
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        case IRP_MN_DISABLE_EVENTS:{
            
            status=ACPIWmiDisableLog();
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return status;
        }
        default:{
            
            status = ACPIDispatchForwardIrp(DeviceObject, Irp);
            return status;
        }
    }
    return status;
}

#endif //WMI_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpictl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpictl.c

Abstract:

    This module handles all of the INTERNAL_DEVICE_CONTROLS requested to
    the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

Revision History:

    01-05-98 - SGP - Complete Rewrite
    01-13-98 - SGP - Cleaned up the Eval Post-Processing

--*/

#include "pch.h"

NTSTATUS
ACPIIoctlAcquireGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine acquires the global lock for another device driver

Arguments:

    DeviceObject    - The device object stack that wants the lock
    Irp             - The irp with the request in it
    Irpstack        - The current stack within the irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                            status;
    PACPI_GLOBAL_LOCK                   newLock;
    PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER outputBuffer;
    ULONG                               outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Remember that we don't be returning any data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (outputLength < sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlAcquireGlobalLockExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    outputBuffer = (PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;
    if (outputBuffer->Signature != ACPI_ACQUIRE_GLOBAL_LOCK_SIGNATURE) {

        status = STATUS_INVALID_PARAMETER_1;
        goto ACPIIoctlAcquireGlobalLockExit;

    }

    //
    // Allocate storage for the lock
    //
    newLock = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPI_GLOBAL_LOCK),
        'LcpA'
        );
    if (newLock == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ACPIIoctlAcquireGlobalLockExit;

    }
    RtlZeroMemory( newLock, sizeof(ACPI_GLOBAL_LOCK) );

    //
    // Initialize the new lock and the request
    //
    outputBuffer->LockObject = newLock;
    Irp->IoStatus.Information = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    newLock->LockContext = Irp;
    newLock->Type = ACPI_GL_QTYPE_IRP;

    //
    // Mark the irp as pending, since we can block while acquire the lock
    //
    IoMarkIrpPending( Irp );

    //
    // Request the lock now
    //
    status = ACPIAsyncAcquireGlobalLock( newLock );
    if (status == STATUS_PENDING) {

        return status;

    }
ACPIIoctlAcquireGlobalLockExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

}

NTSTATUS
ACPIIoctlAsyncEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to handle a control method request asynchronously

Arguments:

    DeviceObject    - The device object to run the method on
    Irp             - The irp with the request in it
    IrpStack        - THe current stack within the Irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      methodObject;
    POBJDATA    argumentData = NULL;
    POBJDATA    resultData = NULL;
    ULONG       argumentCount = 0;

    //
    // Do the pre processing on the irp
    //
    status = ACPIIoctlEvalPreProcessing(
        DeviceObject,
        Irp,
        IrpStack,
        NonPagedPool,
        &methodObject,
        &resultData,
        &argumentData,
        &argumentCount
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIIoctlAsyncEvalControlMethodExit;

    }

    //
    // At this point, we can run the async method
    //
    status = AMLIAsyncEvalObject(
        methodObject,
        resultData,
        argumentCount,
        argumentData,
        ACPIIoctlAsyncEvalControlMethodCompletion,
        Irp
        );

    //
    // We no longer need the arguments now. Note, that we should clean up
    // the argument list because it contains pointer to another block of
    // allocated data. Freeing something in the middle of the block would be
    // very bad.
    //
    if (argumentData != NULL) {

        ExFreePool( argumentData );
        argumentData = NULL;

    }

    //
    // Check the return data now
    //
    if (status == STATUS_PENDING) {

        return status;

    } else if (NT_SUCCESS(status)) {

        //
        // Do the post processing ourselves
        //
        status = ACPIIoctlEvalPostProcessing(
            Irp,
            resultData
            );
        AMLIFreeDataBuffs( resultData, 1 );

    }

ACPIIoctlAsyncEvalControlMethodExit:

    //
    // No longer need this data
    //
    if (resultData != NULL) {

        ExFreePool( resultData );

    }

    //
    // If we got here, then we must complete the irp and return
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

VOID EXPORT
ACPIIoctlAsyncEvalControlMethodCompletion(
    IN  PNSOBJ          AcpiObject,
    IN  NTSTATUS        Status,
    IN  POBJDATA        ObjectData,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine is called after the interpreter has had a chance to run
    the method

Arguments:

    AcpiObject  - The object that the method was run on
    Status      - The status of the eval
    ObjectData  - The result of the eval
    Context     - Specific to the caller

Return Value:

    NTSTATUS

--*/
{
    PIRP        irp = (PIRP) Context;

    //
    // Did we succeed the request?
    //
    if (NT_SUCCESS(Status)) {

        //
        // Do the work now
        //
        Status = ACPIIoctlEvalPostProcessing(
            irp,
            ObjectData
            );
        AMLIFreeDataBuffs( ObjectData, 1 );

    }

    //
    // No longer need this data
    //
    ExFreePool( ObjectData );

    //
    // If our completion routine got called, then AMLIAsyncEvalObject returned
    // STATUS_PENDING. Be sure to mark the IRP pending before we complete it.
    //
    IoMarkIrpPending(irp);

    //
    // Complete the request
    //
    irp->IoStatus.Status = Status;
    IoCompleteRequest( irp, IO_NO_INCREMENT );

}

NTSTATUS
ACPIIoctlCalculateOutputBuffer(
    IN  POBJDATA                ObjectData,
    IN  PACPI_METHOD_ARGUMENT   Argument,
    IN  BOOLEAN                 TopLevel
    )
/*++

Routine Description:

    This function is called to fill the contents of Argument with the
    information provided by the ObjectData. This function is recursive.

    It assumes that the correct amount of storage was allocated for Argument.

    Note:  To add the ability to return nested packages without breaking W2K
           behavior, the outermost package is not part of the output buffer.
           I.e. anything that was a package will have its outermost
           ACPI_EVAL_OUTPUT_BUFFER.Count be more than 1.

Arguments:

    ObjectData  - The information that we need to propogate
    Argument    - The location to propogate that information
    TopLevel    - Indicates whether we are at the top level of recursion

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    POBJDATA    objData;
    PPACKAGEOBJ package;
    ULONG       count;
    ULONG       packageCount;
    ULONG       packageSize;
    PACPI_METHOD_ARGUMENT packageArgument;

    ASSERT( Argument );

    //
    // Fill in the output buffer arguments
    //
    if (ObjectData->dwDataType == OBJTYPE_INTDATA) {

        Argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        Argument->DataLength = sizeof(ULONG);
        Argument->Argument = (ULONG) ObjectData->uipDataValue;

    } else if (ObjectData->dwDataType == OBJTYPE_STRDATA ||
        ObjectData->dwDataType == OBJTYPE_BUFFDATA) {

        Argument->Type = (ObjectData->dwDataType == OBJTYPE_STRDATA ?
            ACPI_METHOD_ARGUMENT_STRING : ACPI_METHOD_ARGUMENT_BUFFER);
        Argument->DataLength = (USHORT)ObjectData->dwDataLen;
        RtlCopyMemory(
            Argument->Data,
            ObjectData->pbDataBuff,
            ObjectData->dwDataLen
            );

    } else if (ObjectData->dwDataType == OBJTYPE_PKGDATA) {

        package = (PPACKAGEOBJ) ObjectData->pbDataBuff;

        //
        // Get the size of the space necessary to store a package's
        // data.  We are really only interested in the amount of
        // data the package will consume *without* its header
        // information.  Passing TRUE as the last parameter will
        // give us that.
        //

        packageSize = 0;
        packageCount = 0;
        status = ACPIIoctlCalculateOutputBufferSize(ObjectData,
                                                    &packageSize,
                                                    &packageCount,
                                                    TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(packageCount == package->dwcElements);

        if (!TopLevel) {
            //
            // Create a package argument.
            //

            Argument->Type = ACPI_METHOD_ARGUMENT_PACKAGE;
            Argument->DataLength = (USHORT)packageSize;

            packageArgument = (PACPI_METHOD_ARGUMENT)
                ((PUCHAR)Argument + FIELD_OFFSET(ACPI_METHOD_ARGUMENT, Data));

        } else {

            packageArgument = Argument;
        }

        for (count = 0; count < package->dwcElements; count++) {

            objData = &(package->adata[count]);
            status = ACPIIoctlCalculateOutputBuffer(
                objData,
                packageArgument,
                FALSE
                );
            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Point to the next argument
            //

            packageArgument = ACPI_METHOD_NEXT_ARGUMENT(packageArgument);
        }

    } else {

        //
        // We don't understand this data type, we won't return anything
        //
        return STATUS_ACPI_INVALID_DATA;

    }

    //
    // Success
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlCalculateOutputBufferSize(
    IN  POBJDATA            ObjectData,
    IN  PULONG              BufferSize,
    IN  PULONG              BufferCount,
    IN  BOOLEAN             TopLevel
    )
/*++

Routine Description:

    This routine (recursively) calculates the amount of buffer space required
    to hold the flattened contents of ObjectData. This information is returned
    in BufferSize data location...

    If the ObjectData structure contains information that cannot be expressed
    to the user, then this routine will return a failure code.

Arguments:

    ObjectData  - The object whose size we have to calculate
    BufferSize  - Where to put that size
    BufferCount - The number of elements that we are allocating for

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    POBJDATA    objData;
    PPACKAGEOBJ package;
    ULONG       bufferLength;
    ULONG       count;
    ULONG       packageCount;
    ULONG       dummyCount;

    //
    // Determine how much buffer space is required to hold the
    // flattened data structure
    //
    if (ObjectData->dwDataType == OBJTYPE_INTDATA) {

        bufferLength = ACPI_METHOD_ARGUMENT_LENGTH( sizeof(ULONG) );
        *BufferCount = 1;

    } else if (ObjectData->dwDataType == OBJTYPE_STRDATA ||
        ObjectData->dwDataType == OBJTYPE_BUFFDATA) {

        bufferLength = ACPI_METHOD_ARGUMENT_LENGTH( ObjectData->dwDataLen );
        *BufferCount = 1;

    } else if (ObjectData->dwDataType == OBJTYPE_PKGDATA) {

        //
        // Remember that walking the package means that we have accounted for
        // the length of the package and the number of elements within the
        // package
        //
        packageCount = 0;

        //
        // Walk the package
        //
        package = (PPACKAGEOBJ) ObjectData->pbDataBuff;

        if (!TopLevel) {

            //
            // Packages are contained in an ACPI_METHOD_ARGUMENT structure.
            // So add enough for the overhead of one of these before looking
            // at the children.
            //
            bufferLength = FIELD_OFFSET(ACPI_METHOD_ARGUMENT, Data);
            *BufferCount = 1;

        } else {

            bufferLength = 0;
            *BufferCount = package->dwcElements;
        }

        for (count = 0; count < package->dwcElements; count++) {

            objData = &(package->adata[count]);
            status = ACPIIoctlCalculateOutputBufferSize(
                objData,
                BufferSize,
                &dummyCount,
                FALSE
                );

            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

    } else if (ObjectData->dwDataType == OBJTYPE_UNKNOWN) {

        *BufferCount = 1;
        bufferLength = 0;

    } else {

        //
        // We don't understand this data type, so we won't return anything
        //
        ASSERT(FALSE);
        return STATUS_ACPI_INVALID_DATA;
    }

    //
    // Update the package lengths
    //
    ASSERT( BufferSize && BufferCount );
    *BufferSize += bufferLength;

    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to handle a control method request synchronously

Arguments:

    DeviceObject    - The device object to run the method on
    Irp             - The irp with the request in it
    IrpStack        - THe current stack within the Irp

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PNSOBJ      methodObject;
    POBJDATA    argumentData = NULL;
    POBJDATA    resultData = NULL;
    ULONG       argumentCount = 0;

    //
    // Do the pre processing on the irp
    //
    status = ACPIIoctlEvalPreProcessing(
        DeviceObject,
        Irp,
        IrpStack,
        PagedPool,
        &methodObject,
        &resultData,
        &argumentData,
        &argumentCount
        );
    if (!NT_SUCCESS(status)) {

        goto ACPIIoctlEvalControlMethodExit;

    }

    //
    // At this point, we can run the async method
    //
    status = AMLIEvalNameSpaceObject(
        methodObject,
        resultData,
        argumentCount,
        argumentData
        );

    //
    // We no longer need the arguments now
    //
    if (argumentData != NULL) {

        ExFreePool( argumentData );
        argumentData = NULL;

    }

    //
    // Check the return data now and fake a call to the completion routine
    //
    if (NT_SUCCESS(status)) {

        //
        // Do the post processing now
        //
        status = ACPIIoctlEvalPostProcessing(
            Irp,
            resultData
            );
        AMLIFreeDataBuffs( resultData, 1 );

    }

ACPIIoctlEvalControlMethodExit:

    //
    // No longer need this data
    //
    if (resultData != NULL) {

        ExFreePool( resultData );

    }

    //
    // If we got here, then we must complete the irp and return
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
ACPIIoctlEvalPostProcessing(
    IN  PIRP        Irp,
    IN  POBJDATA    ObjectData
    )
/*++

Routine Description:

    This routine handles convering the ObjectData into information
    that can be passed back into the irp.

    N.B. This routine does *not* complete the irp. The caller must
    do that. This routine is also *not* pageable

Arguments:

    Irp         - The irp that will hold the results
    ObjectData  - The result to convert

Return Value:

    NTSTATUS    - Same as in Irp->IoStatus.Status

--*/
{
    NTSTATUS                    status;
    PACPI_EVAL_OUTPUT_BUFFER    outputBuffer;
    PACPI_METHOD_ARGUMENT       arg;
    PIO_STACK_LOCATION          irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG                       bufferLength = 0;
    ULONG                       outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG                       packageCount = 0;

    //
    // If we don't have an output buffer, then we can complete the request
    //
    if (outputLength == 0) {

        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Count the amount of space taken up by the flattened data and how many
    // elements of data are contained therein
    //
    bufferLength = 0;
    packageCount = 0;
    status = ACPIIoctlCalculateOutputBufferSize(
        ObjectData,
        &bufferLength,
        &packageCount,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        //
        // We don't understand a data type in the handling of the data, so
        // we won't return anything
        //
        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Add in the fudge factor that we need to account for the Output buffer
    //
    bufferLength += (sizeof(ACPI_EVAL_OUTPUT_BUFFER) -
        sizeof(ACPI_METHOD_ARGUMENT) );

    if (bufferLength < sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {
        bufferLength = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
    }

    //
    // Setup the Output buffer
    //
    if (outputLength >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {

        outputBuffer = (PACPI_EVAL_OUTPUT_BUFFER) Irp->AssociatedIrp.SystemBuffer;
        outputBuffer->Signature = ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE;
        outputBuffer->Length = bufferLength;
        outputBuffer->Count = packageCount;
        arg = outputBuffer->Argument;

    }

    //
    // Make sure that we have enough output buffer space
    //
    if (bufferLength > outputLength) {

        Irp->IoStatus.Information = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
        return STATUS_BUFFER_OVERFLOW;


    } else {

        Irp->IoStatus.Information = bufferLength;

    }

    status = ACPIIoctlCalculateOutputBuffer(
        ObjectData,
        arg,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        //
        // We don't understand a data type in the handling of the data, so we
        // won't return anything
        //
        Irp->IoStatus.Information = 0;
        return STATUS_SUCCESS;

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlEvalPreProcessing(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack,
    IN  POOL_TYPE           PoolType,
    OUT PNSOBJ              *MethodObject,
    OUT POBJDATA            *ResultData,
    OUT POBJDATA            *ArgumentData,
    OUT ULONG               *ArgumentCount
    )
/*++

Routine Description:

    This routine converts the request in an Irp into the structures
    required by the AML Interpreter

    N.B. This routine does *not* complete the irp. The caller must
    do that. This routine is also *not* pageable

Arguments:

    Irp             - The request
    IrpStack        - The current stack location in the request
    PoolType        - Which type of memory to allocate
    MethodObject    - Pointer to which object to run
    ResultData      - Pointer to where to store the result
    ArgumentData    - Pointer to the arguments
    ArgumentCount   - Potiner to the number of arguments

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_EVAL_INPUT_BUFFER inputBuffer;
    PNSOBJ                  acpiObject;
    PNSOBJ                  methodObject;
    POBJDATA                argumentData = NULL;
    POBJDATA                resultData = NULL;
    UCHAR                   methodName[5];
    ULONG                   argumentCount = 0;
    ULONG                   inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                   outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Do this step before we do anything else --- this way we won't
    // overwrite anything is someone tries to return some data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_EVAL_INPUT_BUFFER) ) {

        return STATUS_INFO_LENGTH_MISMATCH;

    }

    //
    // Do we have a non-null output length? if so, then it must meet the
    // minimum size
    //
    if (outputLength != 0 && outputLength < sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_EVAL_INPUT_BUFFER) Irp->AssociatedIrp.SystemBuffer;

    //
    // Convert the name to a null terminated string
    //
    RtlZeroMemory( methodName, 5 * sizeof(UCHAR) );
    RtlCopyMemory( methodName, inputBuffer->MethodName, sizeof(NAMESEG) );

    //
    // Search for the name space object that corresponds to the one that we
    // being asked about
    //
    acpiObject = OSConvertDeviceHandleToPNSOBJ( DeviceObject );
    if (acpiObject == NULL) {

        return STATUS_NO_SUCH_DEVICE;

    }
    status = AMLIGetNameSpaceObject(
        methodName,
        acpiObject,
        &methodObject,
        NSF_LOCAL_SCOPE
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Allocate memory for return data
    //
    resultData = ExAllocatePoolWithTag( PoolType, sizeof(OBJDATA), 'RcpA' );
    if (resultData == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // What we do is really based on what the signature in this buffer is
    //
    switch (inputBuffer->Signature) {
        case ACPI_EVAL_INPUT_BUFFER_SIGNATURE:

            //
            // Nothing to do here
            //
            break;

        case ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE:
        case ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_SIGNATURE:

            //
            // We need to create a single argument to pass to the function
            //
            argumentCount = 1;
            argumentData = ExAllocatePoolWithTag(
                PoolType,
                sizeof(OBJDATA),
                'AcpA'
                );
            if (argumentData == NULL) {

                ExFreePool( resultData );
                return STATUS_INSUFFICIENT_RESOURCES;

            }

            //
            // Initialize the argument to the proper value
            //
            RtlZeroMemory( argumentData, sizeof(OBJDATA) );
            if (inputBuffer->Signature == ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE) {

                PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER integerBuffer;

                integerBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER) inputBuffer;

                argumentData->dwDataType = OBJTYPE_INTDATA;
                argumentData->uipDataValue = integerBuffer->IntegerArgument;

            } else {

                PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING stringBuffer;

                stringBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING) inputBuffer;

                argumentData->dwDataType = OBJTYPE_STRDATA;
                argumentData->dwDataLen = stringBuffer->StringLength;
                argumentData->pbDataBuff = stringBuffer->String;

            }
            break;

        case ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE: {

            PACPI_EVAL_INPUT_BUFFER_COMPLEX complexBuffer;
            PACPI_METHOD_ARGUMENT           methodArgument;
            ULONG                           i;

            complexBuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) inputBuffer;

            //
            // Do we need to create any arguments?
            //
            if (complexBuffer->ArgumentCount == 0) {

                break;
            }

            //
            // Create the object data structures to hold these arguments
            //
            argumentCount = complexBuffer->ArgumentCount;
            methodArgument = complexBuffer->Argument;
            argumentData = ExAllocatePoolWithTag(
                PoolType,
                sizeof(OBJDATA) * argumentCount,
                'AcpA'
                );
            if (argumentData == NULL) {

                ExFreePool( resultData );
                return STATUS_INSUFFICIENT_RESOURCES;

            }

            RtlZeroMemory( argumentData, argumentCount * sizeof(OBJDATA) );
            for (i = 0; i < argumentCount; i++) {

                if (methodArgument->Type == ACPI_METHOD_ARGUMENT_INTEGER) {

                    (argumentData[i]).dwDataType = OBJTYPE_INTDATA;
                    (argumentData[i]).uipDataValue = methodArgument->Argument;

                } else {

                    (argumentData[i]).dwDataLen = methodArgument->DataLength;
                    (argumentData[i]).pbDataBuff = methodArgument->Data;
                    if (methodArgument->Type == ACPI_METHOD_ARGUMENT_STRING) {

                        (argumentData[i]).dwDataType = OBJTYPE_STRDATA;

                    } else {

                        (argumentData[i]).dwDataType = OBJTYPE_BUFFDATA;

                    }

                }

                //
                // Look at the next method
                //
                methodArgument = ACPI_METHOD_NEXT_ARGUMENT( methodArgument );

            }

            break;

        }
        default:

            return STATUS_INVALID_PARAMETER_1;

    }

    //
    // Set the proper pointers
    //
    *MethodObject = methodObject;
    *ResultData = resultData;
    *ArgumentData = argumentData;
    *ArgumentCount = argumentCount;

    //
    // Done pre-processing
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIIoctlRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handle the registration of the an Operation Region

Arguments:

    DeviceObject    - The DeviceObject that the region is getting
                      registered on
    Irp             - The request
    IrpStack        - Our part of the request

Return Value

    Status

--*/
{
    NTSTATUS                                    status;
    PACPI_REGISTER_OPREGION_HANDLER_BUFFER      inputBuffer;
    PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER    outputBuffer;
    PNSOBJ                                      regionObject;
    PVOID                                       opregionObject;
    ULONG                                       accessType;
    ULONG                                       inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                                       outputLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG                                       regionSpace;

    //
    // Grab the acpi object that corresponds to the current one
    //
    regionObject  = OSConvertDeviceHandleToPNSOBJ( DeviceObject );

    //
    // Preload this value. This is so that we don't have to remember how
    // many bytes we will return
    //
    Irp->IoStatus.Information = sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER);

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Do we have a non-null output length? if so, then it must meet the
    // minimum size
    //
    if (outputLength < sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_REGISTER_OPREGION_HANDLER_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;

    //
    // Is this an input buffer?
    //
    if (inputBuffer->Signature != ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE) {

        status = STATUS_ACPI_INVALID_DATA;
        goto ACPIIoctlRegisterOpRegionHandlerExit;

    }

    //
    // Set the correct access type
    //
    switch (inputBuffer->AccessType) {
        case ACPI_OPREGION_ACCESS_AS_RAW:

            accessType = EVTYPE_RS_RAWACCESS;
            break;

        case ACPI_OPREGION_ACCESS_AS_COOKED:

            accessType = EVTYPE_RS_COOKACCESS;
            break;

        default:

            status = STATUS_ACPI_INVALID_DATA;
            goto ACPIIoctlRegisterOpRegionHandlerExit;
    }

    //
    // Set the correct region space
    //
    switch (inputBuffer->RegionSpace) {
        case ACPI_OPREGION_REGION_SPACE_MEMORY:

            regionSpace = REGSPACE_MEM;
            break;

        case ACPI_OPREGION_REGION_SPACE_IO:

            regionSpace = REGSPACE_IO;
            break;

        case ACPI_OPREGION_REGION_SPACE_PCI_CONFIG:

            regionSpace = REGSPACE_PCICFG;
            break;

        case ACPI_OPREGION_REGION_SPACE_EC:

            regionSpace = REGSPACE_EC;
            break;

        case ACPI_OPREGION_REGION_SPACE_SMB:

            regionSpace = REGSPACE_SMB;
            break;

        case ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG:

            regionSpace = REGSPACE_CMOSCFG;
            break;

        case ACPI_OPREGION_REGION_SPACE_PCIBARTARGET:

            regionSpace = REGSPACE_PCIBARTARGET;
            break;

        default:

            if (inputBuffer->RegionSpace >= 0x80 &&
                inputBuffer->RegionSpace <= 0xff ) {

                //
                // This one is vendor-defined.  Just use
                // the value that the vendor passed in.
                //

                regionSpace = inputBuffer->RegionSpace;
                break;
            }

            status = STATUS_ACPI_INVALID_DATA;
            goto ACPIIoctlRegisterOpRegionHandlerExit;
    }

    //
    // Evaluate the registration
    //
    status = RegisterOperationRegionHandler(
        regionObject,
        accessType,
        regionSpace,
        (PFNHND) inputBuffer->Handler,
        (ULONG_PTR)inputBuffer->Context,
        &opregionObject
        );

    //
    // If we succeeded, then setup the output buffer
    //
    if (NT_SUCCESS(status)) {

        outputBuffer = (PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER)
            Irp->AssociatedIrp.SystemBuffer;
        outputBuffer->Signature = ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
        outputBuffer->OperationRegionObject = opregionObject;
        Irp->IoStatus.Information =
            sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER);

    }

ACPIIoctlRegisterOpRegionHandlerExit:

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // return with the status code
    //
    return status;
}

NTSTATUS
ACPIIoctlReleaseGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine is called to release the global lock

Arguments:

    DeviceObject    - The Device object that is releasing the lock
    Irp             - The request
    IrpStack        - Our part of the request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                            status;
    PACPI_GLOBAL_LOCK                   acpiLock;
    PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER inputBuffer;
    ULONG                               inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Remember that we don't be returning any data
    //
    Irp->IoStatus.Information = 0;

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlReleaseGlobalLockExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;
    if (inputBuffer->Signature != ACPI_RELEASE_GLOBAL_LOCK_SIGNATURE) {

        status = STATUS_INVALID_PARAMETER_1;
        goto ACPIIoctlReleaseGlobalLockExit;

    }
    acpiLock = inputBuffer->LockObject;

    //
    // Release the lock now
    //
    status = ACPIReleaseGlobalLock( acpiLock );

    //
    // Free the memory for the lock
    //
    ExFreePool( acpiLock );

ACPIIoctlReleaseGlobalLockExit:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // Done
    //
    return status;

}

NTSTATUS
ACPIIoctlUnRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    )
/*++

Routine Description:

    This routine handle the unregistration of the an Operation Region

Arguments:

    DeviceObject    - The DeviceObject that the region is getting
                      registered on
    Irp             - The request
    IrpStack        - Our part of the request

NTSTATUS

    Status

--*/
{
    NTSTATUS                                    status;
    PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER    inputBuffer;
    PNSOBJ                                      regionObject;
    ULONG                                       inputLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Grab the region object that corresponds to the requested on
    //
    regionObject = OSConvertDeviceHandleToPNSOBJ( DeviceObject );

    //
    // Is the irp have a minimum size buffer?
    //
    if (inputLength < sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER) ) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        goto ACPIIoctlUnRegisterOpRegionHandlerExit;

    }

    //
    // Grab a pointer at the input buffer
    //
    inputBuffer = (PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER)
        Irp->AssociatedIrp.SystemBuffer;

    //
    // Evaluate the registration
    //
    status = UnRegisterOperationRegionHandler(
        regionObject,
        inputBuffer->OperationRegionObject
        );

ACPIIoctlUnRegisterOpRegionHandlerExit:

    //
    // Done with the request
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    //
    // return with the status code
    //
    return status;
}

NTSTATUS
ACPIIrpDispatchDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine handles the INTERNAL_DEVICE_CONTROLs that are sent to
    an ACPI Device Object

Arguments:

    DeviceObject    - The device object that received the request
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG               ioctlCode;

    //
    // Make sure that this is an internally generated irp
    //
    if (Irp->RequestorMode != KernelMode) {

        status = ACPIDispatchForwardIrp( DeviceObject, Irp );
        return status;

    }

    //
    // Grab what we need out of the current irp stack
    //
    ioctlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // What is the IOCTL that we need to handle?
    //
    switch (ioctlCode ) {
        case IOCTL_ACPI_ASYNC_EVAL_METHOD:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlAsyncEvalControlMethod(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_EVAL_METHOD:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlEvalControlMethod(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_REGISTER_OPREGION_HANDLER:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlRegisterOpRegionHandler(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlUnRegisterOpRegionHandler(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_ACQUIRE_GLOBAL_LOCK:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlAcquireGlobalLock(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        case IOCTL_ACPI_RELEASE_GLOBAL_LOCK:

            //
            // Handle this elsewhere
            //
            status = ACPIIoctlReleaseGlobalLock(
                DeviceObject,
                Irp,
                irpStack
                );
            break;

        default:

            //
            // Handle this with the default mechanism
            //
            status = ACPIDispatchForwardIrp( DeviceObject, Irp );

    }

    //
    // Done
    //
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\nt\worker.c ===
/*
 *  Worker thread functions
 *
 *
 */

#include "pch.h"

KSPIN_LOCK      ACPIWorkerSpinLock;
WORK_QUEUE_ITEM ACPIWorkItem;
LIST_ENTRY      ACPIDeviceWorkQueue;
BOOLEAN         ACPIWorkerBusy;

KEVENT          ACPIWorkToDoEvent;
KEVENT          ACPITerminateEvent;
LIST_ENTRY      ACPIWorkQueue;
HANDLE          ACPIThread;

VOID
ACPIWorkerThread (
    IN PVOID    Context
    );

VOID
ACPIWorker(
    IN PVOID StartContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ACPIInitializeWorker)
#endif

VOID
ACPIInitializeWorker (
    VOID
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ThreadHandle;
    PETHREAD *Thread;

    KeInitializeSpinLock (&ACPIWorkerSpinLock);
    ExInitializeWorkItem (&ACPIWorkItem, ACPIWorkerThread, NULL);
    InitializeListHead (&ACPIDeviceWorkQueue);

    //
    // Initialize the ACPI worker thread. This thread is for use by the AML
    // interpreter and must not page-fault or have its stack swapped.
    //
    KeInitializeEvent(&ACPIWorkToDoEvent, NotificationEvent, FALSE);
    KeInitializeEvent(&ACPITerminateEvent, NotificationEvent, FALSE);
    InitializeListHead(&ACPIWorkQueue);

    //
    // Create the worker thread
    //
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    Status = PsCreateSystemThread(&ThreadHandle,
                                  THREAD_ALL_ACCESS,
                                  &ObjectAttributes,
                                  0,
                                  NULL,
                                  ACPIWorker,
                                  NULL);
    if (Status != STATUS_SUCCESS) {

        ACPIInternalError( ACPI_WORKER );

    }

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_ALL_ACCESS,
                                        NULL,
                                        KernelMode,
                                        (PVOID *)&Thread,
                                        NULL);

    if (Status != STATUS_SUCCESS) {

        ACPIInternalError( ACPI_WORKER );

    }
}


VOID
ACPISetDeviceWorker (
    IN PDEVICE_EXTENSION    DevExt,
    IN ULONG                Events
    )
{
    BOOLEAN         QueueWorker;
    KIRQL           OldIrql;

    //
    // Synchronize with worker thread
    //

    KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    QueueWorker = FALSE;

    //
    // Set the devices pending events
    //

    DevExt->WorkQueue.PendingEvents |= Events;

    //
    // If this device is not being processed, start now
    //

    if (!DevExt->WorkQueue.Link.Flink) {
        //
        // Queue to worker thread
        //

        InsertTailList (&ACPIDeviceWorkQueue, &DevExt->WorkQueue.Link);
        QueueWorker = !ACPIWorkerBusy;
        ACPIWorkerBusy = TRUE;
    }

    //
    // Drop lock, and if needed get a worker thread
    //

    KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
    if (QueueWorker) {
        ExQueueWorkItem (&ACPIWorkItem, DelayedWorkQueue);
    }
}

VOID
ACPIWorkerThread (
    IN PVOID    Context
    )
{
    KIRQL               OldIrql;
    PDEVICE_EXTENSION   DevExt;
    ULONG               Events;
    PLIST_ENTRY         Link;

    KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    ACPIWorkerBusy = TRUE;

    //
    // Loop and handle each queue device
    //

    while (!IsListEmpty(&ACPIDeviceWorkQueue)) {
        Link = ACPIDeviceWorkQueue.Flink;
        RemoveEntryList (Link);
        Link->Flink = NULL;

        DevExt = CONTAINING_RECORD (Link, DEVICE_EXTENSION, WorkQueue.Link);

        //
        // Dispatch the pending events
        //

        Events = DevExt->WorkQueue.PendingEvents;
        DevExt->WorkQueue.PendingEvents = 0;

        KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
        DevExt->DispatchTable->Worker (DevExt, Events);
        KeAcquireSpinLock (&ACPIWorkerSpinLock, &OldIrql);
    }

    ACPIWorkerBusy = FALSE;
    KeReleaseSpinLock (&ACPIWorkerSpinLock, OldIrql);
}

#if DBG

EXCEPTION_DISPOSITION
ACPIWorkerThreadFilter(
    IN PWORKER_THREAD_ROUTINE WorkerRoutine,
    IN PVOID Parameter,
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
{
    KdPrint(("ACPIWORKER: exception in worker routine %lx(%lx)\n", WorkerRoutine, Parameter));
    KdPrint(("  exception record at %lx\n", ExceptionInfo->ExceptionRecord));
    KdPrint(("  context record at %lx\n",ExceptionInfo->ContextRecord));

    try {
        DbgBreakPoint();

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // No kernel debugger attached, so let the system thread
        // exception handler call KeBugCheckEx.
        //
        return(EXCEPTION_CONTINUE_SEARCH);
    }

    return(EXCEPTION_EXECUTE_HANDLER);
}
#endif

typedef enum _ACPI_WORKER_OBJECT {
    ACPIWorkToDo,
    ACPITerminate,
    ACPIMaximumObject
} ACPI_WORKER_OBJECT;

VOID
ACPIWorker(
    IN PVOID StartContext
    )
{
    PLIST_ENTRY Entry;
    WORK_QUEUE_TYPE QueueType;
    PWORK_QUEUE_ITEM WorkItem;
    KIRQL OldIrql;
    NTSTATUS Status;
    static KWAIT_BLOCK WaitBlockArray[ACPIMaximumObject];
    PVOID WaitObjects[ACPIMaximumObject];

    ACPIThread = PsGetCurrentThread ();

    //
    // Wait for the modified page writer event AND the PFN mutex.
    //

    WaitObjects[ACPIWorkToDo] = (PVOID)&ACPIWorkToDoEvent;
    WaitObjects[ACPITerminate] = (PVOID)&ACPITerminateEvent;

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue.
        //
        // By specifying a wait mode of KernelMode, the thread's kernel stack is
        // not swappable
        //


        Status = KeWaitForMultipleObjects(ACPIMaximumObject,
                                          &WaitObjects[0],
                                          WaitAny,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL,
                                          &WaitBlockArray[0]);

        //
        // Switch on the wait status.
        //

        switch (Status) {

        case ACPIWorkToDo:
                break;

        case ACPITerminate:
                // Stephane - you need to clear out any pending requests,
                // wake people up, etc.  here.
                //
                // Also make sure you free up any allocated pool, etc.

                PsTerminateSystemThread (STATUS_SUCCESS);
                break;

        default:
                break;
        }

        KeAcquireSpinLock(&ACPIWorkerSpinLock, &OldIrql);
        ASSERT(!IsListEmpty(&ACPIWorkQueue));
        Entry = RemoveHeadList(&ACPIWorkQueue);

        if (IsListEmpty(&ACPIWorkQueue)) {
            KeClearEvent(&ACPIWorkToDoEvent);
        }
        KeReleaseSpinLock(&ACPIWorkerSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Execute the specified routine.
        //

#if DBG

        try {

            PVOID WorkerRoutine;
            PVOID Parameter;

            WorkerRoutine = WorkItem->WorkerRoutine;
            Parameter = WorkItem->Parameter;
            (WorkItem->WorkerRoutine)(WorkItem->Parameter);
            if (KeGetCurrentIrql() != 0) {

                ACPIPrint( (
                    ACPI_PRINT_CRITICAL,
                    "ACPIWORKER: worker exit at IRQL %d, worker routine %x, "
                    "parameter %x, item %x\n",
                    KeGetCurrentIrql(),
                    WorkerRoutine,
                    Parameter,
                    WorkItem
                    ) );
                DbgBreakPoint();

            }

        } except( ACPIWorkerThreadFilter(WorkItem->WorkerRoutine,
                                         WorkItem->Parameter,
                                         GetExceptionInformation() )) {
        }

#else

        (WorkItem->WorkerRoutine)(WorkItem->Parameter);
        if (KeGetCurrentIrql() != 0) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem
                );
            }
#endif

    } while(TRUE);
}

VOID
OSQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by the ACPI worker thread

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must be located in NonPagedPool. The work item
        structure contains a doubly linked list entry, the address of a
        routine to call and a parameter to pass to that routine.

Return Value:

    None

--*/

{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Insert the work item
    //
    KeAcquireSpinLock(&ACPIWorkerSpinLock, &OldIrql);
    if (IsListEmpty(&ACPIWorkQueue)) {
        KeSetEvent(&ACPIWorkToDoEvent, 0, FALSE);
    }
    InsertTailList(&ACPIWorkQueue, &WorkItem->List);
    KeReleaseSpinLock(&ACPIWorkerSpinLock, OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpienbl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpienbl.c

Abstract:

    This module contains functions to put an ACPI machine in ACPI mode.

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIENBL_H_
#define _ACPIENBL_H_

    VOID
    ACPIEnableEnterACPIMode(
        IN BOOLEAN ReEnable
        );

    VOID
    ACPIEnableInitializeACPI(
        IN  BOOLEAN ReEnable
        );

    VOID
    ACPIEnablePMInterruptOnly(
        VOID
        );

    ULONG
    ACPIEnableQueryFixedEnables(
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpigpio.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    acpigpio.h

Abstract:

    contains all the structures related to reading/writting to directly
    to the GP IO registers

Environment:

    Kernel mode only

Revision History:

    03/22/00 - Initial Revision

--*/

#ifndef _ACPIGPIO_H_
#define _ACPIGPIO_H_

    UCHAR
    ACPIReadGpeStatusRegister (
        ULONG                   Register
        );

    VOID
    ACPIWriteGpeStatusRegister (
        ULONG                   Register,
        UCHAR                   Value
        );

    VOID
    ACPIWriteGpeEnableRegister (
        ULONG                   Register,
        UCHAR                   Value
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpictl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpictl.c

Abstract:

    This module handles all of the INTERNAL_DEVICE_CONTROLS requested to
    the ACPI driver

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver only

--*/

#ifndef _ACPICTL_H_
#define _ACPICTL_H_

NTSTATUS
ACPIIoctlAcquireGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlAsyncEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

VOID EXPORT
ACPIIoctlAsyncEvalControlMethodCompletion(
    IN  PNSOBJ      AcpiObject,
    IN  NTSTATUS    Status,
    IN  POBJDATA    ObjectData,
    IN  PVOID       Context
    );

NTSTATUS
ACPIIoctlCalculateOutputBuffer(
    IN  POBJDATA                ObjectData,
    IN  PACPI_METHOD_ARGUMENT   Argument,
    IN  BOOLEAN                 TopLevel
    );

NTSTATUS
ACPIIoctlCalculateOutputBufferSize(
    IN  POBJDATA                ObjectData,
    IN  PULONG                  BufferSize,
    IN  PULONG                  BufferCount,
    IN  BOOLEAN                 TopLevel
    );

NTSTATUS
ACPIIoctlEvalControlMethod(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlEvalPostProcessing(
    IN  PIRP        Irp,
    IN  POBJDATA    ObjectData
    );

NTSTATUS
ACPIIoctlEvalPreProcessing(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack,
    IN  POOL_TYPE           PoolType,
    OUT PNSOBJ              *MethodObject,
    OUT POBJDATA            *ResultData,
    OUT POBJDATA            *ArgumentData,
    OUT ULONG               *ArgumentCount
    );

NTSTATUS
ACPIIoctlRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlReleaseGlobalLock(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIoctlUnRegisterOpRegionHandler(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpStack
    );

NTSTATUS
ACPIIrpDispatchDeviceControl(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiinit.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiinit.h

Abstract:

    ACPI OS Independent initialization routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#ifndef _ACPIINIT_H_
#define _ACPIINIT_H_

    extern PACPIInformation AcpiInformation;
    extern PRSDTINFORMATION RsdtInformation;
    extern PNSOBJ           ProcessorList[];

    BOOLEAN
    ACPIInitialize(
        IN  PVOID   Context
        );

    NTSTATUS
    ACPIInitializeAMLI(
        VOID
        );

    NTSTATUS
    ACPIInitializeDDB(
        IN  ULONG   Index
        );

    NTSTATUS
    ACPIInitializeDDBs(
        VOID
        );

    ULONG
    GetPBlkAddress(
        IN  UCHAR   Processor
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiinit.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiinit.c

Abstract:

    ACPI OS Independent initialization routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPIInitialize)
#pragma alloc_text(PAGE,ACPIInitializeAMLI)
#pragma alloc_text(PAGE,ACPIInitializeDDB)
#pragma alloc_text(PAGE,ACPIInitializeDDBs)
#pragma alloc_text(PAGE,GetPBlkAddress)
#endif

#ifdef DBG
#define VERIFY_IO_WRITES
#endif

//
// Pointer to global ACPIInformation structure.
//
PACPIInformation        AcpiInformation = NULL;

//
// Global structure for Pnp/QUERY_INTERFACE
//
ACPI_INTERFACE_STANDARD ACPIInterfaceTable;
PNSOBJ                  ProcessorList[ACPI_SUPPORTED_PROCESSORS];
PRSDTINFORMATION        RsdtInformation;

//
// Remember how many contexts we have reserved for the interpreter
//
ULONG                   AMLIMaxCTObjs;


BOOLEAN
ACPIInitialize(
    PVOID Context
    )
/*++

Routine Description:

    This routine is called by the OS to detect ACPI, store interesting
    information in the global data structure, enables ACPI on the machine,
    and finally load the DSDT

Arguments:

    Context - The context to back to the OS upon a callback. Typically a
              deviceObject

Return Value:

    BOOLEAN
        - TRUE if ACPI was found
        - FALSE, otherwise

--*/
{
    BOOLEAN     bool;
    NTSTATUS    status;
    PRSDT       rootSystemDescTable;

    PAGED_CODE();

    //
    // Initialize the interpreter
    //
    status = ACPIInitializeAMLI();
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: AMLI failed initialization 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: AMLI failed initialization\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            0,
            0,
            0
            );

    }

    //
    // Get the linear address of the RSDT of NULL if ACPI is not present on
    // the System
    //
    rootSystemDescTable = ACPILoadFindRSDT();
    if ( rootSystemDescTable == NULL ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPI RSDT Not Found\n"
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPI RSDT Not Found\n",
            rootSystemDescTable
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            1,
            0,
            0
            );

    }

    //
    // ACPI is alive and well on this machine.
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPIInitalize: ACPI RSDT found at %p \n",
        rootSystemDescTable
        ) );

    //
    // Initialize table used for MJ_PNP/MN_QUERY_INTERFACE requests
    //
    ACPIInterfaceTable.Size                             = sizeof (ACPIInterfaceTable);
    ACPIInterfaceTable.GpeConnectVector                 = ACPIVectorConnect;
    ACPIInterfaceTable.GpeDisconnectVector              = ACPIVectorDisconnect;
    ACPIInterfaceTable.GpeEnableEvent                   = ACPIVectorEnable;
    ACPIInterfaceTable.GpeDisableEvent                  = ACPIVectorDisable;
    ACPIInterfaceTable.GpeClearStatus                   = ACPIVectorClear;
    ACPIInterfaceTable.RegisterForDeviceNotifications   = ACPIRegisterForDeviceNotifications;
    ACPIInterfaceTable.UnregisterForDeviceNotifications = ACPIUnregisterForDeviceNotifications;
    ACPIInterfaceTable.InterfaceReference               = AcpiNullReference;
    ACPIInterfaceTable.InterfaceDereference             = AcpiNullReference;
    ACPIInterfaceTable.Context                          = Context;
    ACPIInterfaceTable.Version                          = 1;

    //
    // Initialize global data structures
    //
    KeInitializeSpinLock (&GpeTableLock);
    KeInitializeSpinLock (&NotifyHandlerLock);
    ProcessorList[0] = 0;
    RtlZeroMemory( ProcessorList, ACPI_SUPPORTED_PROCESSORS * sizeof(PNSOBJ) );

    //
    // Allocate some memory to hold the ACPI Information structure.
    //
    AcpiInformation = (PACPIInformation) ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ACPIInformation),
        ACPI_SHARED_INFORMATION_POOLTAG
        );
    if ( AcpiInformation == NULL ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: Could not allocate AcpiInformation (x%x bytes)\n",
            sizeof(ACPIInformation)
            ) );
        ASSERTMSG(
            "ACPIInitialize: Could not allocate AcpiInformation\n",
            AcpiInformation
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            2,
            0,
            0
            );

    }
    RtlZeroMemory( AcpiInformation, sizeof(ACPIInformation) );
    AcpiInformation->ACPIOnly = TRUE;
    AcpiInformation->RootSystemDescTable = rootSystemDescTable;

    //
    // Initialize queue, lock, and owner info for the Global Lock.
    // This must be done before we ever call the interpreter!
    //
    KeInitializeSpinLock( &AcpiInformation->GlobalLockQueueLock );
    InitializeListHead( &AcpiInformation->GlobalLockQueue );
    AcpiInformation->GlobalLockOwnerContext = NULL;
    AcpiInformation->GlobalLockOwnerDepth = 0;

    //
    // Initialize most of the remaining fields in the AcpiInformation structure.
    // This function will return FALSE in case of a problem finding the required
    //  tables
    //
    status = ACPILoadProcessRSDT();
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPILoadProcessRSDT = 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPILoadProcessRSDT Failed\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            3,
            0,
            0
            );

    }

    //
    // Now switch the machine into ACPI mode and initialize
    // the ACPI registers.
    //
    ACPIEnableInitializeACPI( FALSE );

    //
    // At this point, we can load all of the DDBs. We need to load all of
    // these tables *before* we try to enable any GPEs or Interrupt Vectors
    //
    status = ACPIInitializeDDBs();
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: ACPIInitializeLoadDDBs = 0x%08lx\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitialize: ACPIInitializeLoadDDBs Failed\n",
            NT_SUCCESS(status)
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            4,
            0,
            0
            );

    }

    //
    // Hook the SCI Vector
    //
    bool = OSInterruptVector(
        Context
        );
    if ( !bool ) {

        //
        // Ooops... We were unable to hook the SCI vector.  Clean Up and
        // fail to load.
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitialize: OSInterruptVector Failed!!\n"
            ) );
        ASSERTMSG(
            "ACPIInitialize: OSInterruptVector Failed!!\n",
            bool
            );
        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            5,
            0,
            0
            );

    }

    return (TRUE);
}

NTSTATUS
ACPIInitializeAMLI(
    VOID
    )
/*++

Routine Description:

    Called by ACPIInitialize to init the interpreter. We go and read
    some values from the registry to decide what to initialize the
    interpreter with

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       amliInitFlags;
    ULONG       contextBlockSize;
    ULONG       globalHeapBlockSize;
    ULONG       timeSliceLength;
    ULONG       timeSliceInterval;
    ULONG       argSize;

    PAGED_CODE();

    //
    // Initialize AMLI
    //
    argSize = sizeof(amliInitFlags);
    status = OSReadRegValue(
        "AMLIInitFlags",
        (HANDLE) NULL,
        &amliInitFlags,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        amliInitFlags = 0;

    }

    argSize = sizeof(contextBlockSize);
    status = OSReadRegValue(
        "AMLICtxtBlkSize",
        (HANDLE) NULL,
        &contextBlockSize,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        contextBlockSize = 0;

    }

    argSize = sizeof(globalHeapBlockSize);
    status = OSReadRegValue(
        "AMLIGlobalHeapBlkSize",
        (HANDLE) NULL,
        &globalHeapBlockSize,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        globalHeapBlockSize = 0;

    }

    argSize = sizeof(timeSliceLength);
    status = OSReadRegValue(
        "AMLITimeSliceLength",
        (HANDLE) NULL,
        &timeSliceLength,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        timeSliceLength = 0;

    }

    argSize = sizeof(timeSliceInterval);
    status = OSReadRegValue(
        "AMLITimeSliceInterval",
        (HANDLE) NULL,
        &timeSliceInterval,
        &argSize
        );
    if (!NT_SUCCESS(status) ) {

        timeSliceInterval = 0;

    }

    argSize = sizeof(AMLIMaxCTObjs);
    status = OSReadRegValue(
        "AMLIMaxCTObjs",
        (HANDLE) NULL,
        &AMLIMaxCTObjs,
        &argSize
        );
    if (!NT_SUCCESS(status)) {

        AMLIMaxCTObjs = 0;

    }

    //
    // Allow the OSes to do some work once the interperter has been loaded
    //
    OSInitializeCallbacks();

    //
    // Initialize the interpreter
    //
    return AMLIInitialize(
        contextBlockSize,
        globalHeapBlockSize,
        amliInitFlags,
        timeSliceLength,
        timeSliceInterval,
        AMLIMaxCTObjs
        );
}

NTSTATUS
ACPIInitializeDDB(
    IN  ULONG   Index
    )
/*++

Routine Description:

    This routine is called to load the specificied Differentiated Data Block

Arguments:

    Index   - Index of information in the RsdtInformation

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN     success;
    HANDLE      diffDataBlock = NULL;
    NTSTATUS    status;
    PDSDT       table;

    PAGED_CODE();

    //
    // Convert the index into a table entry
    //
    table = (PDSDT) (RsdtInformation->Tables[Index].Address);

    //
    // Make sure that the checksum of the table is correct
    //
    success = ACPILoadTableCheckSum( table, table->Header.Length );
    if (success == FALSE) {

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            7,
            (ULONG_PTR) table,
            table->Header.CreatorRev
            );


    }

    //
    // Now call the Interpreter to read the Differentiated System
    // Description Block and build the ACPI Name Space.
    //
    status = AMLILoadDDB( table, &diffDataBlock );
    if (NT_SUCCESS(status) ) {

        //
        // Remember that we have loaded this table and that we have a
        // handle to it
        //
        RsdtInformation->Tables[Index].Flags |= RSDTELEMENT_LOADED;
        RsdtInformation->Tables[Index].Handle = diffDataBlock;

    } else {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPIInitializeDDB: AMLILoadDDB failed 0x%8x\n",
            status
            ) );
        ASSERTMSG(
            "ACPIInitializeDDB: AMLILoadDDB failed to load DDB\n",
            0
            );

        KeBugCheckEx(
            ACPI_BIOS_ERROR,
            ACPI_SYSTEM_CANNOT_START_ACPI,
            8,
            (ULONG_PTR) table,
            table->Header.CreatorRev
            );

    }
    return STATUS_SUCCESS;
}

NTSTATUS
ACPIInitializeDDBs(
    VOID
    )
/*++

Routine Description:

    This function looks that the RsdtInformation and attemps to load
    all of the possible Dynamic Data Blocks

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    ULONG       index;
    ULONG       numElements;

    PAGED_CODE();

    //
    // Get the number of elements to process
    //
    numElements = RsdtInformation->NumElements;
    if (numElements == 0) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPInitializeDDBs: No tables found in RSDT\n"
            ) );
        ASSERTMSG(
            "ACPIInitializeDDBs: No tables found in RSDT\n",
            numElements != 0
            );
        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // We would not be here unless we found a DSDT. So we assume that the
    // *LAST* entry in the table points to the DSDT that we will load. Make
    // sure that we can in fact load it, and then do so
    //
    index = numElements - 1;
    if ( !(RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED) ||
         !(RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE) ) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPInitializeDDB: DSDT not mapped or loadable\n"
            ) );
        ASSERTMSG(
            "ACPIInitializeDDB: DSDT not mapped\n",
            (RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED)
            );
        ASSERTMSG(
            "ACPIInitializeDDB: DSDT not loadable\n",
            (RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE)
            );
        return STATUS_ACPI_INVALID_TABLE;

    }
    status = ACPIInitializeDDB( index );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // We have one fewer element to look at, so lets ignore the DSDT entry
    //
    numElements--;

    //
    // Loop for all elements in the table
    //
    for (index = 0; index < numElements; index++) {

        //
        // Is the entry mapped and loadable?
        //
        if ( (RsdtInformation->Tables[index].Flags & RSDTELEMENT_MAPPED) &&
             (RsdtInformation->Tables[index].Flags & RSDTELEMENT_LOADABLE) ) {

            //
            // Load the table
            //
            status = ACPIInitializeDDB( index );
            if (!NT_SUCCESS(status)) {

                return status;

            }

        }

    }

    //
    // If we got here, then everything is okay
    //
    return STATUS_SUCCESS;
}

ULONG
GetPBlkAddress(
    IN  UCHAR   Processor
    )
{
    ULONG           pblk;
    NTSTATUS        status;
    OBJDATA         data;
    PNSOBJ          pnsobj = NULL;
    PPROCESSOROBJ   pobj = NULL;

    if (Processor >= ACPI_SUPPORTED_PROCESSORS) {

        return 0;

    }

    if (!ProcessorList[Processor])  {

        return 0;

    }

    status = AMLIEvalNameSpaceObject(
        ProcessorList[Processor],
        &data,
        0,
        NULL
        );

    if ( !NT_SUCCESS(status) ) {

        ACPIBreakPoint ();
        return (0);

    }

    ASSERT (data.dwDataType == OBJTYPE_PROCESSOR);
    ASSERT (data.pbDataBuff != NULL);

    pblk = ((PROCESSOROBJ *)data.pbDataBuff)->dwPBlk;
    AMLIFreeDataBuffs(&data, 1);

    return (pblk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiio.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiio.c

Abstract:

    ACPI OS Independent I/O routines

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric Nelson - Add Def[ault]Read/Write routines

--*/

#include "pch.h"

//
// This driver is not in alpha or beta stages any more --- we can save some
// CPU calls if we simply define the debug function to nothing
//
#define DebugTraceIO(Write, Port, Length, Value )
static UCHAR IOTrace = 0;

VOID
ACPIIoDebugTrace(
    BOOLEAN Write,
    PUSHORT Port,
    UCHAR Length,
    ULONG Value
    )
{
    if (IOTrace != 0) {

        ACPIPrint( (
           ACPI_PRINT_IO,
           "%x byte %s port 0x%x value %x\n",
           Length, Write ? "WRITE" : "READ", Port, Value
           ) );

    }

}

ULONG
ACPIIoReadPm1Status(
    VOID
    )
/*++

Routine Description:

    This routine reads the PM1 Status registers and masks off any bits that
    we don't care about. This is done because some of these bits are actually
    owned by the HAL

Arguments:

    None

Return Value:

    ULONG

--*/
{

    return READ_PM1_STATUS() &
        (AcpiInformation->pm1_en_bits | PM1_WAK_STS | PM1_TMR_STS | PM1_RTC_STS);
}


VOID
CLEAR_PM1_STATUS_BITS (
    USHORT BitMask
    )
{
    if (AcpiInformation->PM1a_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1a_STATUS, 0, BitMask);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            BitMask
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1b_STATUS, 0, BitMask);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            BitMask
            );

    }
}

VOID
CLEAR_PM1_STATUS_REGISTER (
    VOID
    )
{
    USHORT Value = 0;

    if (AcpiInformation->PM1a_BLK != 0)     {

        Value = READ_ACPI_REGISTER(PM1a_STATUS, 0);
        WRITE_ACPI_REGISTER(PM1a_STATUS, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            Value
            );

    }

    if (AcpiInformation->PM1b_BLK != 0) {

        Value = READ_ACPI_REGISTER(PM1b_STATUS, 0);
        WRITE_ACPI_REGISTER(PM1b_STATUS, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
}

USHORT
READ_PM1_CONTROL(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_CTRL_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_CONTROL, 0);

    }
    if (AcpiInformation->PM1b_CTRL_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_CONTROL, 0);

    }
    return (pm1);

}

USHORT
READ_PM1_ENABLE(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_ENABLE, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_ENABLE, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    return (pm1);
}

USHORT
READ_PM1_STATUS(
    VOID
    )
{
    USHORT  pm1=0;

    if (AcpiInformation->PM1a_BLK != 0) {

        pm1 = READ_ACPI_REGISTER(PM1a_STATUS, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        pm1 |= READ_ACPI_REGISTER(PM1b_STATUS, 0);

        DebugTraceIO(
            FALSE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_STS_OFFSET),
            sizeof(USHORT),
            pm1
            );

    }
    return (pm1);
}

VOID
WRITE_PM1_CONTROL(
    USHORT Value,
    BOOLEAN Destructive,
    ULONG Flags
    )
{

    if (!Destructive) {

        USHORT  pm1;

        if ( (Flags & WRITE_REGISTER_A) && (AcpiInformation->PM1a_BLK != 0) ) {

            pm1 = READ_ACPI_REGISTER(PM1a_CONTROL, 0);
            pm1 |= Value;
            WRITE_ACPI_REGISTER(PM1a_CONTROL, 0, pm1);

        }
        if ( (Flags & WRITE_REGISTER_B) && (AcpiInformation->PM1b_BLK != 0) ) {

            pm1 = READ_ACPI_REGISTER(PM1b_CONTROL, 0);
            pm1 |= Value;
            WRITE_ACPI_REGISTER(PM1b_CONTROL, 0, pm1);

        }

    } else {

        //
        // clear this bit and the system dies
        // it is legit when called by the ACPI shutdown code
        // which will use the WRITE_SCI flag.
        //
        ASSERT ( (Flags & WRITE_SCI) || (Value & PM1_SCI_EN) );

        if ( (Flags & WRITE_REGISTER_A) && (AcpiInformation->PM1a_BLK != 0) ) {

            WRITE_ACPI_REGISTER(PM1a_CONTROL, 0, Value);

        }
        if ( (Flags & WRITE_REGISTER_B) && (AcpiInformation->PM1b_BLK != 0) ) {

            WRITE_ACPI_REGISTER(PM1b_CONTROL, 0, Value);

        }

    }
}

VOID
WRITE_PM1_ENABLE(
    USHORT Value
    )
{

    if (AcpiInformation->PM1a_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1a_ENABLE, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1a_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
    if (AcpiInformation->PM1b_BLK != 0) {

        WRITE_ACPI_REGISTER(PM1b_ENABLE, 0, Value);

        DebugTraceIO(
            TRUE,
            (PUSHORT)(AcpiInformation->PM1b_BLK+PM1_EN_OFFSET),
            sizeof(USHORT),
            Value
            );

    }
}



USHORT
DefPortReadAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register
    )
/*++

Routine Description:

    Read from the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to read from.

    Register - Specifies which GP register to read from. Not used for PM1x
               registers.

Return Value:

    Value of the specified ACPI fixed register.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            return READ_PORT_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1b_ENABLE:
            return READ_PORT_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1a_STATUS:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1b_STATUS:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1a_CONTROL:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK);
            break;

        case PM1b_CONTROL:
            return READ_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK +
                                                Register));
            } else {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                                Register));
            } else {
                return READ_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case SMI_CMD:
            return READ_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD);
            break;

        default:
            break;
    }

    return (USHORT)-1;
}



VOID
DefPortWriteAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register,
    USHORT Value
    )
/*++

Routine Description:

    Write to the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to write to.

    Register - Specifies which GP register to write to. Not used for PM1x
               registers.

    Value - Data to write.

Return Value:

    None.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            WRITE_PORT_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1b_ENABLE:
            WRITE_PORT_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1a_STATUS:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1b_STATUS:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1a_CONTROL:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK, Value);
            break;

        case PM1b_CONTROL:
            WRITE_PORT_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK, Value);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK + Register),
                                 (UCHAR)Value);
            } else {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK + Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                          Register),
                                 (UCHAR)Value);
            } else {
                WRITE_PORT_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                          Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case SMI_CMD:
            WRITE_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD, (UCHAR)Value);
            break;

        default:
            break;
    }
}


USHORT
DefRegisterReadAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register
    )
/*++

Routine Description:

    Read from the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to read from.

    Register - Specifies which GP register to read from. Not used for PM1x
               registers.

Return Value:

    Value of the specified ACPI fixed register.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            return READ_REGISTER_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1b_ENABLE:
            return READ_REGISTER_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                              PM1_EN_OFFSET));
            break;

        case PM1a_STATUS:
            return READ_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1b_STATUS:
            return READ_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                                    PM1_STS_OFFSET);
            break;

        case PM1a_CONTROL:
            return READ_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK);
            break;

        case PM1b_CONTROL:
            return READ_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK +
                                                Register));
            } else {
                return READ_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                return READ_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                                Register));
            } else {
                return READ_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                                Register -
                                                AcpiInformation->Gpe0Size));
            }
            break;

        case SMI_CMD:
            //
            // SMI_CMD is always register based.
            //
            return READ_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD);
            break;

        default:
            break;
    }

    return (USHORT)-1;
}



VOID
DefRegisterWriteAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register,
    USHORT Value
    )
/*++

Routine Description:

    Write to the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to write to.

    Register - Specifies which GP register to write to. Not used for PM1x
               registers.

    Value - Data to write.

Return Value:

    None.

--*/
{
    switch (AcpiReg) {

        case PM1a_ENABLE:
            WRITE_REGISTER_USHORT((PUSHORT)(AcpiInformation->PM1a_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1b_ENABLE:
            WRITE_REGISTER_USHORT((PUSHORT)(AcpiInformation->PM1b_BLK +
                                        PM1_EN_OFFSET), Value);
            break;

        case PM1a_STATUS:
            WRITE_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1a_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1b_STATUS:
            WRITE_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1b_BLK +
                              PM1_STS_OFFSET, Value);
            break;

        case PM1a_CONTROL:
            WRITE_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1a_CTRL_BLK, Value);
            break;

        case PM1b_CONTROL:
            WRITE_REGISTER_USHORT((PUSHORT)AcpiInformation->PM1b_CTRL_BLK, Value);
            break;

        case GP_STATUS:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP0_BLK + Register),
                                 (UCHAR)Value);
            } else {
                WRITE_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP1_BLK + Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case GP_ENABLE:
            if (Register < AcpiInformation->Gpe0Size) {
                WRITE_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP0_ENABLE +
                                          Register),
                                 (UCHAR)Value);
            } else {
                WRITE_REGISTER_UCHAR((PUCHAR)(AcpiInformation->GP1_ENABLE +
                                          Register -
                                          AcpiInformation->Gpe0Size),
                                 (UCHAR)Value);
            }
            break;

        case SMI_CMD:
            //
            // SMI_CMD is always register based.
            //
            WRITE_PORT_UCHAR((PUCHAR)AcpiInformation->SMI_CMD, (UCHAR)Value);
            break;

        default:
            break;
    }
}



//
// READ/WRITE_ACPI_REGISTER macros are implemented via these
// function pointers
//
PREAD_ACPI_REGISTER  AcpiReadRegisterRoutine  = DefPortReadAcpiRegister;
PWRITE_ACPI_REGISTER AcpiWriteRegisterRoutine = DefPortWriteAcpiRegister;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpigpio.c ===
/*
 *  ACPIGPIO.C -- ACPI OS Independent functions for low-level General-Purpose Event register I/O.
 *
 *  Notes:
 *
 *      This file provides OS independent functions that are called to read/write the GPE registers,
 *      perform index <--> register translation, and to validate index values.
 *
 *      This is the only place where the GPE0 and GPE1 blocks are differentiated.
 *
 */

#include "pch.h"


UCHAR
ACPIReadGpeStatusRegister (
    ULONG           Register
    )
/*++

Routine Description:

    Read a GPE status register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE status register to read.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
Return Value:

    The value of the status register

--*/
{
    return (UCHAR) READ_ACPI_REGISTER(GP_STATUS, Register);
}


VOID
ACPIWriteGpeStatusRegister (
    ULONG           Register,
    UCHAR           Value
    )
/*++

Routine Description:

    Write a GPE status register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE status register to write.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
    Value       - The value to be written

Return Value:

    None

--*/
{
    WRITE_ACPI_REGISTER(GP_STATUS, Register, (USHORT) Value);
}


VOID
ACPIWriteGpeEnableRegister (
    ULONG           Register,
    UCHAR           Value
    )
/*++

Routine Description:

    Write a GPE Enable register.  Differentiation between GP0 and GP1 is
    handled here.

Arguments:

    Register    - The GPE enable register to write.  Registers are numbered sequentially,
                  GP0 block first, then GP1 block appended.
    Value       - The value to be written

Return Value:

    None

--*/
{
    ACPIPrint( (
        ACPI_PRINT_DPC,
        "ACPIWriteGpeEnableRegister: Writing GPE Enable register %x = %x\n",
        Register, Value
        ) );

    WRITE_ACPI_REGISTER(GP_ENABLE, Register, (USHORT) Value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpienbl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpienbl.c

Abstract:

    This module contains functions to put an ACPI machine in ACPI mode.

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


VOID
ACPIEnableEnterACPIMode (
    IN BOOLEAN ReEnable
    )
/*++

Routine Description:

    This routine is called to enter ACPI mode

Arguments:

    BOOLEAN ReEnable : TRUE if ACPI is being reenabled after S4.

Return Value:

    None

--*/
{

    ULONG   i;
    BOOLEAN     AffinitySet = FALSE;
    
    ASSERTMSG(
        "ACPIEnableEnterACPIMode: System already in ACPI mode!\n",
        !(READ_PM1_CONTROL() & PM1_SCI_EN)
        );

    ASSERTMSG(
        "ACPIEnableEnterACPIMode: System SMI_CMD port is zero\n",
        (AcpiInformation->SMI_CMD != 0)
        );

    //
    // Let the world know about this
    //
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPIEnableEnterACPIMode: Enabling ACPI\n"
        ) );
    

    //
    // We have seen some machines that display random bughecks (due to ECX corruption) if
    // this code runs on any processor other than 0. So, make sure this code always runs on 
    // processor 0. We don't need to do this in the ReEnable case because on resume from 
    // hibernate, we are guaranteed to be on Processor 0.
    //
    if(!ReEnable){
        
            if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
                
                KeSetSystemAffinityThread((KAFFINITY)1);
                AffinitySet = TRUE;
            }
            else{
                ASSERTMSG("ACPIEnableEnterACPIMode: IRQL >= DISPATCH_LEVEL \n", FALSE);
            }
    }
            
    //
    // Write the magic value to the port
    //

    WRITE_ACPI_REGISTER(SMI_CMD, 0,
            AcpiInformation->FixedACPIDescTable->acpi_on_value);

    //
    // Make sure that we see that PM1 is in fact enabled
    //
    for (i = 0; ; i++) {

        if ( (READ_PM1_CONTROL() & PM1_SCI_EN) ) {

            break;

        }
        if (i > 0xFFFFFF) {

            KeBugCheckEx(
                ACPI_BIOS_ERROR,
                ACPI_SYSTEM_CANNOT_START_ACPI,
                6,
                0,
                0
                );

        }

    }

    //
    // Revert to original affinity
    //
    if(AffinitySet) {
        KeRevertToUserAffinityThread();
    }
    
}

VOID
ACPIEnableInitializeACPI(
    IN BOOLEAN ReEnable
    )
/*++

Routine Description:

    A function to put an ACPI machine into ACPI mode.  This function should be
    called with the SCI IRQ masked since we cannot set the interrupt enable
    mask until after enabling ACPI.  The SCI should be unmasked by the caller
    when the call returns.

    General Sequence:
        Enable ACPI through the SMI command port
        Clear the PM1_STS register to put it in a known state
        Set the PM1_EN register mask
        Build the GP mask
        Clear the GP status register bits which belong to the GP mask
        Set the GP enable register bits according to the GP mask built above
        Set the PM1_CTRL register bits.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    USHORT contents;
    USHORT clearbits;

    
    //
    // Read PM1_CTRL, if SCI_EN is already set then this is an ACPI only machine
    // and we do not need to Enable ACPI
    //
    if ( !(READ_PM1_CONTROL() & PM1_SCI_EN) )   {

        AcpiInformation->ACPIOnly = FALSE;
        ACPIEnableEnterACPIMode(ReEnable);

    } 

    //
    // Put the pm1 status registers into a known state. We will allow the Bus
    // Master bit to be enabled (if we have no choice) across this reset. I do
    // not pretend to understand this code
    //
    CLEAR_PM1_STATUS_REGISTER();
    contents = (USHORT)(READ_PM1_STATUS() & ~(PM1_BM_STS | PM1_RTC_STS));
    if (contents)   {

        CLEAR_PM1_STATUS_REGISTER();
        contents = (USHORT)(READ_PM1_STATUS() & ~(PM1_BM_STS | PM1_RTC_STS));

    }
    ASSERTMSG(
        "ACPIEnableInitializeACPI: Cannot clear PM1 Status Register\n",
        (contents == 0)
        );

    //
    // We determined what the PM1 enable bits are when we processed the FADT.
    // We should now enable those bits
    //
    WRITE_PM1_ENABLE( AcpiInformation->pm1_en_bits );
    ASSERTMSG(
        "ACPIEnableInitializeACPI: Cannot write all PM1 Enable Bits\n",
        (READ_PM1_ENABLE() == AcpiInformation->pm1_en_bits)
        );

    //
    // This is called when we renable ACPI after having woken up from sleep
    // or hibernate
    //
    if (ReEnable) {

        //
        // Re-enable all possible GPE events
        //
        ACPIGpeClearRegisters();
        ACPIGpeEnableDisableEvents( TRUE );

    }

    //
    // Calculate the bits that we should clear. These are the
    // sleep enable bit and the bus master bit.
    //
    // [vincentg] - the original implementation cleared SLP_TYP as well -
    // this breaks C2/C3 on Intel PIIX4 chipsets.  Updated to only clear
    // SLP_EN and BM_RLD.
    //

    clearbits = ((0x8 << SLP_TYP_POS) | PM1_BM_RLD);

    //
    // Read the PM1 control registery, clear the unwanted bits and then
    // write it back
    //
    contents = (READ_PM1_CONTROL() & ~clearbits);
    WRITE_PM1_CONTROL ( contents, TRUE, WRITE_REGISTER_A_AND_B );
}

VOID
ACPIEnablePMInterruptOnly(
    VOID
    )
/*++

Routine Descrition:

    Enable interrupts in the ACPI controller

Arguments:

    None

Return Value:

    None

--*/
{
    WRITE_PM1_ENABLE(AcpiInformation->pm1_en_bits);
}

ULONG
ACPIEnableQueryFixedEnables (
    VOID
    )
/*++

Routine Descrition:

    Returns the enable mask

Arguments:

    None

Return Value:

    None

--*/
{
    return AcpiInformation->pm1_en_bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpilock.c ===
/*
 *  ACPILOCK.C -- ACPI OS Independent functions for managing the ACPI Global Lock
 *
 */

#include "pch.h"

#define ACPI_LOCK_PENDING_BIT 0
#define ACPI_LOCK_OWNED_BIT   1

#define ACPI_LOCK_PENDING (1 << ACPI_LOCK_PENDING_BIT)
#define ACPI_LOCK_OWNED   (1 << ACPI_LOCK_OWNED_BIT)

NTSTATUS EXPORT
GlobalLockEventHandler (
    ULONG                   EventType,
    ULONG                   What,
    ULONG                   dwParam,
    PFNAA                   Callback,
    PVOID                   Context
    )
/*++

Routine Description:

    This is the internal front-end for global lock requests.

Arguments:

    EventType       - Only global lock acquire/release supported
    What            - Acquire or Release
    Param           - Not used
    Callback        - Async callback (acquire only)
    Context         - LockRequest struct and context for callback (must be same for acquire/release)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PACPI_GLOBAL_LOCK       LockRequest = Context;


    ASSERT (EventType == EVTYPE_ACQREL_GLOBALLOCK);

    switch (What) {

        case GLOBALLOCK_ACQUIRE:

            //
            // Fill out the lock request.  Internal requests have no Irp, just pass
            // in the address of the callback routine.
            //
            LockRequest->LockContext = Callback;
            LockRequest->Type = ACPI_GL_QTYPE_INTERNAL;

            status = ACPIAsyncAcquireGlobalLock (LockRequest);

            break;

        case GLOBALLOCK_RELEASE:

            status = ACPIReleaseGlobalLock (Context);
            break;

        default:

            ACPIBreakPoint ();
            status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


NTSTATUS
ACPIAsyncAcquireGlobalLock(
    PACPI_GLOBAL_LOCK       Request
    )
/*++

Routine Description:

    Attempt to acquire the hardware Global Lock.  If the global lock is busy due to another NT thread
    or the BIOS, the request is queued.  The request will be satisfied when 1) All other requests in
    front of it on the queue have released the lock, and 2) The BIOS has released the lock.

Arguments:

    Request                 - Contains context and callback

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   OldIrql;
    PLIST_ENTRY             entry;
    PACPI_GLOBAL_LOCK       queuedRequest;


    ACPIDebugEnter("ACPIAsyncAcquireGlobalLock");
    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIAsyncAcquireGlobalLock: Entered with context %x\n",
        Request
        ) );

    //
    // If caller is the current owner, just increment the depth count
    //

    if (Request == AcpiInformation->GlobalLockOwnerContext) {

        AcpiInformation->GlobalLockOwnerDepth++;

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIAsyncAcquireGlobalLock: Recursive acquire by owner %x, new depth=%d\n",
            Request, AcpiInformation->GlobalLockOwnerDepth
            ) );

        return STATUS_SUCCESS;
    }

    //
    // Lock the Global Lock Queue.  We don't want any state changes while we examine
    // the queue and (possibly) attempt to get the hardware global lock.  For example,
    // if the list is empty, but the BIOS has the lock, we don't want to unlock the queue
    // until we have put the request on it -- so that the release interrupt will dispatch
    // the request.
    //

    KeAcquireSpinLock (&AcpiInformation->GlobalLockQueueLock, &OldIrql);

    //
    // Check if there are others in front of us.  If not, we can try to get the lock
    //

    if (IsListEmpty (&AcpiInformation->GlobalLockQueue)) {

        //
        // Try to grab the lock.  It will only be available if no other thread nor
        // the BIOS has it.
        //

        if (ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

            //
            // Got the lock.  Setup owner and unlock the queue
            //

            AcpiInformation->GlobalLockOwnerContext = Request;
            AcpiInformation->GlobalLockOwnerDepth = 1;

            KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

            ACPIPrint( (
                ACPI_PRINT_IO,
                "ACPIAsyncAcquireGlobalLock: Got lock immediately, Context %x\n",
                Request
                ) );

            return STATUS_SUCCESS;
        }
    }


    //
    // We have to wait for the lock.
    //
    // First, check if context is already queued.
    //
    for (entry = AcpiInformation->GlobalLockQueue.Flink;
            entry != &AcpiInformation->GlobalLockQueue;
            entry = entry->Flink) {

        queuedRequest = CONTAINING_RECORD (entry, ACPI_GLOBAL_LOCK, ListEntry);

        if (queuedRequest == Request) {

            //
            // Already queued, we just increment the depth count and exit.
            //

            ACPIPrint( (
                ACPI_PRINT_IO,
                "ACPIAsyncAcquireGlobalLock: Waiting for lock <again>, Context %x depth %x\n",
                Request, Request->Depth
                ) );

            queuedRequest->Depth++;
            KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

            return STATUS_PENDING;
        }
    }

    //
    // Put this request on the global lock queue
    //

    Request->Depth = 1;

    InsertTailList (
        &AcpiInformation->GlobalLockQueue,
        &Request->ListEntry
        );

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIAsyncAcquireGlobalLock: Waiting for lock, Context %x\n",
        Request
        ) );

    KeReleaseSpinLock (&AcpiInformation->GlobalLockQueueLock, OldIrql);

    return STATUS_PENDING;


    ACPIDebugExit("ACPIAsyncAcquireGlobalLock");
}



NTSTATUS
ACPIReleaseGlobalLock(
    PVOID                   OwnerContext
    )
/*++

Routine Description:

    Release the global lock.  Caller must provide the owning context.  If there are any additional
    requests on the queue, re-acquire the global lock and dispatch the next owner.

    The hardware lock is released and re-acquired so that we don't starve the BIOS from the lock.

Arguments:

    OwnerContext        - Must be same context that was used to acquire the lock

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   OldIrql;

    ACPIDebugEnter("ACPIReleaseGlobalLock");

    //
    // Caller must be the current owner of the lock
    //

    if (OwnerContext != AcpiInformation->GlobalLockOwnerContext) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPIReleaseGlobalLock: Not owner, can't release!  Owner is %x Caller context is %x\n",
            AcpiInformation->GlobalLockOwnerContext, OwnerContext
            ) );

        return STATUS_ACPI_MUTEX_NOT_OWNER;
    }

    //
    // Only the current owner of the global lock gets here.
    // Release the lock when the depth count reaches 0
    //

    if (--AcpiInformation->GlobalLockOwnerDepth > 0) {

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIReleaseGlobalLock:  Recursively owned by context %x, depth remaining %d\n",
            AcpiInformation->GlobalLockOwnerContext, AcpiInformation->GlobalLockOwnerDepth
            ) );

        return STATUS_SUCCESS;
    }

    //
    // Mark lock not owned, and physically release the thing.
    // This allows the BIOS a chance at getting the lock.
    //

    AcpiInformation->GlobalLockOwnerContext = NULL;
    ACPIReleaseHardwareGlobalLock ();

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIReleaseGlobalLock: Lock released by context %x\n",
        OwnerContext
        ) );

    //
    // It is our responsibility to hand off the lock to the next-in-line.
    // First, check if there is anything on the queue.
    //

    if (IsListEmpty (&AcpiInformation->GlobalLockQueue)) {

        return STATUS_SUCCESS;                  // Nope, all done, nothing else to do
    }

    //
    // The queue is not empty, we must get the lock back
    //

    if (!ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

        return STATUS_SUCCESS;                  // BIOS has the lock, just wait for interrupt
    }

    //
    // Got the lock, now dispatch the next owner
    //

    ACPIStartNextGlobalLockRequest ();

    ACPIDebugExit("ACPIReleaseGlobalLock");

    return STATUS_SUCCESS;
}



void
ACPIHardwareGlobalLockReleased (
    void
    )
/*++

Routine Description:

    Called from the ACPI interrupt DPC.  We get here only if an attempt to get the global lock has
    been made, but failed because the BIOS had the lock.  As a result, the lock was marked pending,
    and this interrupt has happened because the BIOS has released the lock.

    Therefore, this procedure must acquire the hardware lock and dispatch ownership to the next
    request on the queue.

Arguments:

    NONE

Return Value:

    NONE

--*/
{

    //
    // Attempt to get the global lock on behalf of the next request in the queue
    //

    if (!ACPIAcquireHardwareGlobalLock (AcpiInformation->GlobalLock)) {

        return;                                 // BIOS has the lock (again), just wait for next interrupt
    }

    //
    // Got the lock, now dispatch the next owner
    //

    ACPIStartNextGlobalLockRequest ();

}



void
ACPIStartNextGlobalLockRequest (
    void
    )
/*++

Routine Description:

    Get the next request off the queue, and give it the global lock.

    This routine can only be called by the thread that currently holds the hardware lock.  If
    the queue is empty, the lock is released.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PLIST_ENTRY             link;
    PACPI_GLOBAL_LOCK       request;
    PFNAA                   callback;
    PIRP                    irp;

    //
    // Get next request from the queue.
    //

    link = ExInterlockedRemoveHeadList (
            &AcpiInformation->GlobalLockQueue,
            &AcpiInformation->GlobalLockQueueLock
            );

    //
    // If something failed after the original thread tried to get the lock, then
    // the queue might be empty.
    //
    if (link == NULL) {

        ACPIPrint( (
            ACPI_PRINT_IO,
            "ACPIStartNextGlobalLockRequest: Queue is empty, releasing lock\n"
            ) );

        ACPIReleaseHardwareGlobalLock ();
        return;
    }

    //
    // Complete the next global lock request
    //

    request = CONTAINING_RECORD (link, ACPI_GLOBAL_LOCK, ListEntry);

    //
    // Bookkeeping
    //

    AcpiInformation->GlobalLockOwnerContext = request;
    AcpiInformation->GlobalLockOwnerDepth = request->Depth;

    ACPIPrint( (
        ACPI_PRINT_IO,
        "ACPIStartNextGlobalLockRequest: Dispatch new owner, ctxt %x callb %x\n",
        request, request->LockContext
        ) );

    //
    // Let the requestor know that it now has the lock
    //

    switch (request->Type) {

        case ACPI_GL_QTYPE_INTERNAL:

            //
            // Internal request - invoke the callback
            //
            callback = (PFNAA) request->LockContext;
            callback (request);

            break;

        case ACPI_GL_QTYPE_IRP:

            //
            // External request - complete the Irp
            //
            irp = (PIRP) request->LockContext;
            irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (irp, IO_NO_INCREMENT);

            break;

        default:        // Shouldn't happen...

            ACPIBreakPoint();
            break;
    }
}



BOOLEAN
ACPIAcquireHardwareGlobalLock(
    PULONG GlobalLock
    )
/*++

Routine Description:

    Attempt to obtain the hardware global lock.

Arguments:

    NONE

Return Value:

    TRUE if acquired, FALSE if pending.

--*/
{
    ULONG lockValue;
    ULONG oldLockValue;
    BOOLEAN owned;

    //
    // don't bother with the lock if we are an ACPI only system.
    //
    if (AcpiInformation->ACPIOnly) {
        return(TRUE);
    }

    lockValue = *((ULONG volatile *)GlobalLock);
    do {

        //
        // Record the original state of the lock.  Shift the contents of
        // the ACPI_LOCK_OWNED bit to the ACPI_LOCK_PENDING bit, and set the
        // ACPI_LOCK_OWNED bit.
        //
        // Finally, update the new value atomically, and repeat the whole
        // process if someone else changed it under us.
        // 

        oldLockValue = lockValue;

        lockValue |= ACPI_LOCK_OWNED |
                     ((lockValue & ACPI_LOCK_OWNED) >>
                         (ACPI_LOCK_OWNED_BIT - ACPI_LOCK_PENDING_BIT));

        lockValue = InterlockedCompareExchange(GlobalLock,
                                               lockValue,
                                               oldLockValue);

    } while (lockValue != oldLockValue);

    //
    // If the lock owned bit was previously clear then we are the owner.
    //

    owned = ((lockValue & ACPI_LOCK_OWNED) == 0);
    return owned;
}


void
ACPIReleaseHardwareGlobalLock(
    void
    )
/*++

Routine Description:

    Release the hardware global lock.  If the BIOS is waiting for the lock (indicated by the
    pending bit), then set GBL_RLS to signal the BIOS.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    ULONG lockValue;
    ULONG oldLockValue;
    ULONG volatile *globalLock;

    globalLock = (ULONG volatile *)AcpiInformation->GlobalLock;
    lockValue = *globalLock;

    //
    // don't bother with the lock if we are an ACPI only system.
    //
    if (AcpiInformation->ACPIOnly) {
        return;
    }

    do {

        ASSERT((lockValue & ACPI_LOCK_OWNED) != 0);

        oldLockValue = lockValue;

        //
        // Clear the owned and pending bits in the lock, and atomically set
        // the new value.  If the cmpxchg fails, go around again.
        // 

        lockValue &= ~(ACPI_LOCK_OWNED | ACPI_LOCK_PENDING);
        lockValue = InterlockedCompareExchange(globalLock,
                                               lockValue,
                                               oldLockValue);

    } while (lockValue != oldLockValue);

    if ((lockValue & ACPI_LOCK_PENDING) != 0) {

        //
        // Signal to bios that the Lock has been released
        //      Set GBL_RLS
        //

        WRITE_PM1_CONTROL( (USHORT)PM1_GBL_RLS, FALSE, WRITE_REGISTER_A_AND_B);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiio.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiio.h

Abstract:

    ACPI OS Independent I/O routines

    We probably need a spinlock or some other form of protection to
    make the split read and writes atomic

Author:

    Jason Clark (JasonCl)
    Stephane Plante (SPlante)

Environment:

    NT Kernel Model Driver only

Revision History:

    Eric Nelson    October, '98 - Add READ/WRITE_ACPI_REGISTER

--*/

#ifndef _ACPIIO_H_
#define _ACPIIO_H_

    //
    // Flags for WRITE_PM1_CONTROL
    //
    #define WRITE_REGISTER_A_BIT        0
    #define WRITE_REGISTER_A            (1 << WRITE_REGISTER_A_BIT)
    #define WRITE_REGISTER_B_BIT        1
    #define WRITE_REGISTER_B            (1 << WRITE_REGISTER_B_BIT)
    #define WRITE_SCI_BIT               2
    #define WRITE_SCI                   (1 << WRITE_SCI_BIT)
    #define WRITE_REGISTER_A_AND_B      WRITE_REGISTER_A+WRITE_REGISTER_B
    #define WRITE_REGISTER_A_AND_B_SCI  WRITE_REGISTER_A+WRITE_REGISTER_B+WRITE_SCI

    ULONG
    ACPIIoReadPm1Status(
        VOID
        );

    VOID
    CLEAR_PM1_STATUS_BITS(
        USHORT BitMask
        );
    #define ACPIIoClearPm1Status        CLEAR_PM1_STATUS_BITS

    VOID
    CLEAR_PM1_STATUS_REGISTER(
        VOID
        );

    USHORT
    READ_PM1_CONTROL(
        VOID
        );

    USHORT
    READ_PM1_ENABLE(
        VOID
        );

    USHORT
    READ_PM1_STATUS(
        VOID
        );

    VOID
    WRITE_PM1_CONTROL(
        USHORT Value,
        BOOLEAN Destructive,
        ULONG Flags
        );

    VOID
    WRITE_PM1_ENABLE(
        USHORT Value
        );

//
// From acpiio.c, these point to DefRead/WriteAcpiRegister
// by default (x86)
//
extern PREAD_ACPI_REGISTER  AcpiReadRegisterRoutine;
extern PWRITE_ACPI_REGISTER AcpiWriteRegisterRoutine;


USHORT
DefPortReadAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register
    );

VOID
DefPortWriteAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register,
    USHORT Value
    );

USHORT
DefRegisterReadAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register
    );

VOID
DefRegisterWriteAcpiRegister(
    ACPI_REG_TYPE AcpiReg,
    ULONG Register,
    USHORT Value
    );

//
// All ACPI register accesses is now done via these macros
//
#define READ_ACPI_REGISTER(AcpiReg, Register) ((*AcpiReadRegisterRoutine)((AcpiReg), (Register)))

#define WRITE_ACPI_REGISTER(AcpiReg, Register, Value) ((*AcpiWriteRegisterRoutine)((AcpiReg), (Register), (Value)))

#endif // _ACPIIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpilock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpilock.h

Abstract:

    This moulde is the header for acpilock.c

Author:

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPILOCK_H_
#define _ACPILOCK_H_

    //
    // Global lock request structure is in acpiioct.h
    // Used only if the requestor must wait for the lock.
    // Cannot grow beyond 4 DWORDs
    //

    // An IRP is queued (LockContext == Irp)
    #define ACPI_GL_QTYPE_IRP       1
    // Internal, LockContext == CallBack
    #define ACPI_GL_QTYPE_INTERNAL  2

    typedef struct _ACPI_GLOBAL_LOCK {
        PVOID       LockContext;
        USHORT      Type;
        USHORT      Depth;
        LIST_ENTRY  ListEntry;
    } ACPI_GLOBAL_LOCK, *PACPI_GLOBAL_LOCK;

    //
    // Public interfaces
    //
    NTSTATUS
    EXPORT
    GlobalLockEventHandler(
        ULONG EventType,
        ULONG What,
        ULONG dwParam,
        PFNAA pfnCallBack,
        PVOID pvCtxt
        );

    //
    // Internal interfaces
    //
    NTSTATUS
    ACPIAsyncAcquireGlobalLock(
        PACPI_GLOBAL_LOCK   Request
        );

    NTSTATUS
    ACPIReleaseGlobalLock(
        PVOID               OwnerContext
        );

    //
    // Hardware Interfaces
    //
    BOOLEAN
    ACPIAcquireHardwareGlobalLock(
        PULONG GlobalLock
        );

    VOID
    ACPIReleaseHardwareGlobalLock(
        VOID
        );

    VOID
    ACPIHardwareGlobalLockReleased (
        VOID
        );

    //
    // Utility procedures
    //
    VOID
    ACPIStartNextGlobalLockRequest (
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpioprg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpioprg.h

Abstract:

    This module is the header for acpioprg.c

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPIOPRG_H_
#define _ACPIOPRG_H_

    typedef struct _OPREGIONHANDLER     {
        PFNHND          Handler;
        PVOID           HandlerContext;
        ULONG           AccessType;
        ULONG           RegionSpace;
    } OPREGIONHANDLER, *POPREGIONHANDLER;

    //
    // Public interfaces
    //
    NTSTATUS
    RegisterOperationRegionHandler (
        PNSOBJ          RegionParent,
        ULONG           AccessType,
        ULONG           RegionSpace,
        PFNHND          Handler,
        ULONG_PTR       Context,
        PVOID           *OperationRegion
        );

    NTSTATUS
    UnRegisterOperationRegionHandler  (
        IN PNSOBJ   RegionParent,
        IN PVOID    OperationRegionObject
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpintfy.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    acpintfy.c

Abstract:

    This modules contains code to deal with notifying interested parties
    of events

Author:

    Jason Clark
    Ken Reneris

Environment:

    NT Kernel Model Driver only
    Some changes are required to work in win9x model

--*/
#include "pch.h"

//
// For handler installation
//
KSPIN_LOCK           NotifyHandlerLock;

NTSTATUS
ACPIRegisterForDeviceNotifications (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify,
    IN PVOID                        Context
    )
/*++

Routine Description:

    Registers the DeviceNotify function as the function to receive device notify
    callbacks

Arguments:

    DeviceObject    - The device object to register a notification handler for
    DeviceNotify    - The handle for device specific notifications

Return Value

    Returns status

--*/
{
    PACPI_POWER_INFO    node;
    PVOID               previous;
    KIRQL               oldIrql;
    NTSTATUS            status;


    //
    // Find the Node associated with this device object (or DevNode)
    // Note: that for NT, the context field is the DeviceExtension of the
    // DeviceObject, since this is what is stored within the ACPI Name Space
    // object
    //
    node = OSPowerFindPowerInfoByContext( DeviceObject );
    if (node == NULL) {

        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // Apply the handler
    //
    KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

    if (node->DeviceNotifyHandler != NULL) {

        //
        // A handler already present
        //
        status = STATUS_UNSUCCESSFUL;

    } else {

        node->DeviceNotifyHandler = DeviceNotify;
        node->HandlerContext = Context;
        status = STATUS_SUCCESS;

    }

    KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

    return status;
}


VOID
ACPIUnregisterForDeviceNotifications (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify
    )
/*++

Routine Description:

    Disconnects a handler from device notify event.

Arguments:

    DeviceObject        - The device object to register a notification handler for

    DeviceNotify        - The handle for device specific notifications

Return Value

    None

--*/
{
    PACPI_POWER_INFO    node;
    PVOID               previous;
    KIRQL               oldIrql;
    NTSTATUS            status;


    //
    // Find the Node associated with this device object (or DevNode)
    // Note: that for NT, the context field is the DeviceExtension of the
    // DeviceObject, since this is what is stored within the ACPI Name Space
    // object
    //
    node = OSPowerFindPowerInfoByContext( DeviceObject );
    if (node == NULL) {
        ASSERTMSG("ACPIUnregisterForDeviceNotifications failed.  "\
                  "Can't find ACPI_POWER_INFO for DeviceObject", FALSE);
        return;
    }

    //
    // Attempt to remove the handler/context from the node
    //
    KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

    if (node->DeviceNotifyHandler != DeviceNotify) {

        //
        // Handler does not match
        //
        ASSERTMSG("ACPIUnregisterForDeviceNotifications failed.  "\
                  "Handler doesn't match.", FALSE);

    } else {

        node->DeviceNotifyHandler = NULL;
        node->HandlerContext = NULL;

    }

    KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

    return;
}


NTSTATUS EXPORT
NotifyHandler (
    ULONG           dwEventType,
    ULONG           dwEventData,
    PNSOBJ          pnsObj,
    ULONG           dwParam,
    PFNAA           CompletionCallback,
    PVOID           CallbackContext
    )
/*++

Routine Description:

    The master ACPI notify handler.

    The design philosophy here is that ACPI should process all notify requests
    that *ONLY* it can handle, namely, DeviceCheck, DeviceEject, and DeviceWake,
    and let *all* other notifies get handled by the driver associated with the
    object. The other driver will also get told about the ACPI handled events,
    but that is only as an FYI, the driver shouldn't do anything...

Arguments:

    dwEventType - The type of event that occured (this is EVTYPE_NOTIFY)
    dwEventData - The event code
    pnsObj      - The name space object that was notified
    dwParam     - The event code

Return Value

    NTSTATUS

--*/
{
    PACPI_POWER_INFO        node;
    KIRQL                   oldIrql;
    PDEVICE_NOTIFY_CALLBACK notifyHandler;
    PVOID                   notifyHandlerContext;

    ASSERT (dwEventType == EVTYPE_NOTIFY);

    ACPIPrint( (
        ACPI_PRINT_DPC,
        "ACPINotifyHandler: Notify on %x value %x, object type %x\n",
        pnsObj,
        dwEventData,
        NSGETOBJTYPE(pnsObj)
        ) );

    //
    // Any events which must be handled by ACPI and is common to all device
    // object types is handled here
    //
    switch (dwEventData) {
        case OPEVENT_DEVICE_ENUM:
            OSNotifyDeviceEnum( pnsObj );
            break;
        case OPEVENT_DEVICE_CHECK:
            OSNotifyDeviceCheck( pnsObj );
            break;
        case OPEVENT_DEVICE_WAKE:
            OSNotifyDeviceWake( pnsObj );
            break;
        case OPEVENT_DEVICE_EJECT:
            OSNotifyDeviceEject( pnsObj );
            break;
    }

    //
    // Look for handle for this node and dispatch it
    //
    node = OSPowerFindPowerInfo(pnsObj);
    if (node) {

        //
        // Get handler address/context with mutex
        //
        KeAcquireSpinLock (&NotifyHandlerLock, &oldIrql);

        notifyHandler = node->DeviceNotifyHandler;
        notifyHandlerContext = node->HandlerContext;

        KeReleaseSpinLock (&NotifyHandlerLock, oldIrql);

        //
        // If we got something, dispatch it
        //
        if (notifyHandler) {

            notifyHandler (notifyHandlerContext, dwEventData);

        }

    }
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpioprg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpioprg.c

Abstract:

    This module provides support for registering ACPI operation regions

Author:

    Stephane Plante (splante)

Environment:

    NT Kernel Mode Driver Only

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,RegisterOperationRegionHandler)
#endif

NTSTATUS
EXPORT
InternalRawAccessOpRegionHandler (
    IN ULONG dwAccType,
    IN PFIELDUNITOBJ FieldUnit,
    IN POBJDATA data,
    IN ULONG_PTR Context,
    IN PFNAA CompletionHandler,
    IN PVOID IntContext
    )
{
    NTSTATUS         status;
    PNSOBJ           HostDevice = NULL;
    PACPI_POWER_INFO DeviceNode;
    PVOID            DeviceHandle;

    //
    // Get the device
    //
    status = AMLIGetFieldUnitRegionObj( FieldUnit, &HostDevice );
    if ( AMLIERR( status ) != AMLIERR_NONE || HostDevice == NULL) {

        return (STATUS_UNSUCCESSFUL);

    }

    HostDevice = NSGETPARENT(HostDevice);
    ACPIPrint( (
        ACPI_PRINT_IO,
        "Raw OpRegion Access on field unit object %x device %x\n",
        FieldUnit, HostDevice
        ));
    if ( (!HostDevice) || (NSGETOBJTYPE(HostDevice)!=OBJTYPE_DEVICE) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceNode = OSPowerFindPowerInfo(HostDevice);
    if ( DeviceNode == NULL ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceHandle = DeviceNode->Context;
    ACPIPrint( (
        ACPI_PRINT_IO,
        "DeviceHandle %x\n",
        DeviceHandle
        ) );


    if ( !(POPREGIONHANDLER)Context || !(((POPREGIONHANDLER)Context)->Handler) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    return(
        (((POPREGIONHANDLER)Context)->Handler)(
            dwAccType,
            FieldUnit,
            data,
            ((POPREGIONHANDLER)Context)->HandlerContext,
            CompletionHandler,
            IntContext
            )
        );
}


NTSTATUS
EXPORT
InternalOpRegionHandler (
    IN ULONG dwAccType,
    IN PNSOBJ pnsOpRegion,
    IN ULONG dwAddr,
    IN ULONG dwSize,
    IN PULONG pdwData,
    IN ULONG_PTR Context,
    IN PFNAA CompletionHandler,
    IN PVOID IntContext
    )
{
    PNSOBJ HostDevice;
    PACPI_POWER_INFO DeviceNode;
    PVOID DeviceHandle;
    NTSTATUS status;


    HostDevice = NSGETPARENT(pnsOpRegion);

    ACPIPrint( (
        ACPI_PRINT_IO,
        "OpRegion Access on region %x device %x\n",
        pnsOpRegion, HostDevice
        ) );
    if ( (!HostDevice) || (NSGETOBJTYPE(HostDevice) != OBJTYPE_DEVICE) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceNode = OSPowerFindPowerInfo (HostDevice);
    if ( DeviceNode == NULL ) {

        return (STATUS_UNSUCCESSFUL);

    }

    DeviceHandle = DeviceNode->Context;
    ACPIPrint( (
        ACPI_PRINT_IO,
        "DeviceHandle %x\n",
        DeviceHandle
        ) );
    if ( !(POPREGIONHANDLER)Context || !(((POPREGIONHANDLER)Context)->Handler) ) {

        return (STATUS_UNSUCCESSFUL);

    }

    status = (((POPREGIONHANDLER)Context)->Handler) (
        dwAccType,
        pnsOpRegion,
        dwAddr,
        dwSize,
        pdwData,
        ((POPREGIONHANDLER)Context)->HandlerContext,
        CompletionHandler,
        IntContext);
    ACPIPrint( (
        ACPI_PRINT_IO,
        "Return from OR handler - status %x\n",
        status
        ) );
    return (status);
}

//
// Register to receive accesses to the specified operation region
//
NTSTATUS
RegisterOperationRegionHandler  (
    IN PNSOBJ           RegionParent,
    IN ULONG            AccessType,
    IN ULONG            RegionSpace,
    IN PFNHND           Handler,
    IN ULONG_PTR        Context,
    OUT PVOID           *OperationRegionObject
    )
{
    NTSTATUS            status;
    OBJDATA             regArgs[2];
    POPREGIONHANDLER    HandlerNode;
    PNSOBJ              regObject;

    PAGED_CODE();

    *OperationRegionObject = NULL;
    status = STATUS_SUCCESS;

    //
    // Allocate a new Operation Region Object
    //
    HandlerNode = ExAllocatePool (NonPagedPool, sizeof(OPREGIONHANDLER));
    if ( !HandlerNode ) {

        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Init the Operation Region Object
    //
    HandlerNode->Handler        = Handler;
    HandlerNode->HandlerContext = (PVOID)Context;
    HandlerNode->AccessType     = AccessType;
    HandlerNode->RegionSpace    = RegionSpace;

    //
    // Raw or Cooked access supported
    //
    switch ( AccessType ) {
    case EVTYPE_RS_COOKACCESS:

        status = AMLIRegEventHandler(
            AccessType,
            RegionSpace,
            InternalOpRegionHandler,
            (ULONG_PTR)HandlerNode
            );
        if ( AMLIERR(status) != AMLIERR_NONE ) {

            status = STATUS_UNSUCCESSFUL;

        }
        break;

    case EVTYPE_RS_RAWACCESS:

        status = AMLIRegEventHandler(
            AccessType,
            RegionSpace,
            InternalRawAccessOpRegionHandler,
            (ULONG_PTR)HandlerNode
            );
        if ( AMLIERR(status) != AMLIERR_NONE ) {

            status = STATUS_UNSUCCESSFUL;

        }
        break;

    default:

        status = STATUS_INVALID_PARAMETER;
        break;

    }

    //
    // Cleanup if needed
    //
    if ( !NT_SUCCESS (status) ) {

        ExFreePool (HandlerNode);
        return (status);

    }

    //
    // Remember the handler
    //
    *OperationRegionObject = HandlerNode;

    //
    // Can we find something?
    //
    if ( RegionParent == NULL ) {

        //
        // Do nothing
        //
        return (STATUS_SUCCESS);

    }

    //
    // see if there is a _REG object to run
    //
    status = AMLIGetNameSpaceObject(
        "_REG",
        RegionParent,
        &regObject,
        NSF_LOCAL_SCOPE
        );
    if ( !NT_SUCCESS(status) ) {

        //
        // Nothing to do
        //
        return (STATUS_SUCCESS);

    }

    //
    // Initialize the parameters
    //
    RtlZeroMemory( regArgs, sizeof(OBJDATA) * 2 );
    regArgs[0].dwDataType = OBJTYPE_INTDATA;
    regArgs[0].uipDataValue = RegionSpace;
    regArgs[1].dwDataType = OBJTYPE_INTDATA;
    regArgs[1].uipDataValue = 1;

    //
    // Eval the request. We can do this asynchronously since we don't actually
    // care when the registration is complete
    //
    AMLIAsyncEvalObject(
        regObject,
        NULL,
        2,
        regArgs,
        NULL,
        NULL
        );

    //
    // Done
    //
    return (STATUS_SUCCESS);
}



//
// UnRegister to receive accesses to the specified operation region
//
NTSTATUS
UnRegisterOperationRegionHandler  (
    IN PNSOBJ   RegionParent,
    IN PVOID    OperationRegionObject
    )
{
    NTSTATUS            status;
    OBJDATA             regArgs[2];
    PNSOBJ              regObject;
    POPREGIONHANDLER    HandlerNode = (POPREGIONHANDLER) OperationRegionObject;

    PAGED_CODE();

    //
    // Is there a _REG method that we should run?
    //
    if ( RegionParent != NULL ) {

        status = AMLIGetNameSpaceObject(
            "_REG",
            RegionParent,
            &regObject,
            NSF_LOCAL_SCOPE
            );
        if ( NT_SUCCESS(status) ) {

            //
            // Initialize the parameters
            //
            RtlZeroMemory( regArgs, sizeof(OBJDATA) * 2 );
            regArgs[0].dwDataType = OBJTYPE_INTDATA;
            regArgs[0].uipDataValue = HandlerNode->RegionSpace;
            regArgs[1].dwDataType = OBJTYPE_INTDATA;
            regArgs[1].uipDataValue = 0;

            //
            // Eval the request. We don't care what it returns, but we must do
            // it synchronously
            //
            AMLIEvalNameSpaceObject(
                regObject,
                NULL,
                2,
                regArgs
                );

        }

    }

    //
    // Call interpreter with null handler to remove the handler for this access/region
    //
    status = AMLIRegEventHandler(
        HandlerNode->AccessType,
        HandlerNode->RegionSpace,
        NULL,
        0
        );
    if ( AMLIERR(status) != AMLIERR_NONE ) {

        return (STATUS_UNSUCCESSFUL);

    }

    //
    // Cleanup
    //
    ExFreePool (HandlerNode);
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpintfy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    acpintfy.h

Abstract:

    This module contains that provides the header support for notifying
    interested parties of events

Author:

    Jason Clark
    Ken Reneris
    Stephane

Environment:

    NT Kernel Mode Driver only

--*/

#ifndef _ACPINTFY_H_
#define _ACPINTFY_H_

    extern KSPIN_LOCK           NotifyHandlerLock;

    NTSTATUS
    ACPIRegisterForDeviceNotifications (
        IN PDEVICE_OBJECT               DeviceObject,
        IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify,
        IN PVOID                        Context
        );

    VOID
    ACPIUnregisterForDeviceNotifications (
        IN PDEVICE_OBJECT               DeviceObject,
        IN PDEVICE_NOTIFY_CALLBACK      DeviceNotify
        );

    NTSTATUS
    EXPORT
    NotifyHandler(
        ULONG dwEventType,
        ULONG dwEventData,
        PNSOBJ pnsObj,
        ULONG dwParam,
        PFNAA CompletionCallback,
        PVOID CallbackContext
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpipriv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpipriv.h

Abstract:

    Internal definitions and structures for ACPI

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _ACPIPRIV_H_
#define _ACPIPRIV_H_

    //
    // This structure lets us know the state of one entry in the RSDT
    //
    typedef struct {

        //
        // Flags that indicate what options apply to this element
        //
        ULONG   Flags;

        //
        // The handle, if we need to unload
        //
        HANDLE  Handle;

        //
        // The address, if we need to unmap
        //
        PVOID   Address;

    } RSDTELEMENT, *PRSDTELEMENT;

    #define RSDTELEMENT_MAPPED      0x1
    #define RSDTELEMENT_LOADED      0x2
    #define RSDTELEMENT_LOADABLE    0x4
    #define RSDTELEMENT_OVERRIDEN   0x8

    //
    // This structure corresponds to the number of elements within the
    // RSDT. For each entry in the RSDT, there is a corresponding entry
    // here.
    //
    typedef struct _RSDTINFORMATION {

        //
        // How many elements are there in the table?
        //
        ULONG       NumElements;

        //
        // The table
        //
        RSDTELEMENT Tables[1];

    } RSDTINFORMATION, *PRSDTINFORMATION;

    typedef struct _DDBINFORMATION  {

        BOOLEAN DSDTNeedsUnload;
        BOOLEAN SSDTNeedsUnload;
        BOOLEAN PSDTNeedsUnload;
        HANDLE  DSDT;
        HANDLE  SSDT;
        HANDLE  PSDT;

    } DDBINFORMATION;


    //
    // ACPIInformation is a global structure which contains frequently needed
    // addresses and flags.  Filled in at initializtion time.
    //
    typedef struct _ACPIInformation {

        //
        // Linear address of Root System Description Table
        //
        PRSDT   RootSystemDescTable;

        //
        // Linear address of Fixed ACPI Description Table
        //
        PFADT FixedACPIDescTable;

        //
        // Linear address of the FACS
        //
        PFACS FirmwareACPIControlStructure;

        //
        // Linear address of Differentiated System Description Table
        //
        PDSDT   DiffSystemDescTable;

        //
        // Linear address of Mulitple APIC table
        //
        PMAPIC  MultipleApicTable;

        //
        // Linear address of GlobalLock ULONG_PTR (contained within Firmware ACPI control structure)
        //
        PULONG  GlobalLock;

        //
        // Queue used for waiting on release of the Global Lock.  Also, queue
        // lock and owner info.
        //
        LIST_ENTRY      GlobalLockQueue;
        KSPIN_LOCK      GlobalLockQueueLock;
        PVOID           GlobalLockOwnerContext;
        ULONG           GlobalLockOwnerDepth;

        //
        // Did we find SCI_EN set when we loaded ?
        //
        BOOLEAN ACPIOnly;

        //
        // I/O address of PM1a_BLK
        //
        ULONG_PTR   PM1a_BLK;

        //
        // I/O address of PM1b_BLK
        //
        ULONG_PTR   PM1b_BLK;

        //
        // I/O address of PM1a_CNT_BLK
        //
        ULONG_PTR   PM1a_CTRL_BLK;

        //
        // I/O address of PM1b_CNT_BLK
        //
        ULONG_PTR   PM1b_CTRL_BLK;

        //
        // I/O address of PM2_CNT_BLK
        //
        ULONG_PTR   PM2_CTRL_BLK;

        //
        // I/O address of PM_TMR
        //
        ULONG_PTR   PM_TMR;
        ULONG_PTR   GP0_BLK;
        ULONG_PTR   GP0_ENABLE;

        //
        // Length of GP0 register block (Total, status+enable regs)
        //
        UCHAR   GP0_LEN;

        //
        // Number of GP0 logical registers
        //
        USHORT  Gpe0Size;
        ULONG_PTR   GP1_BLK;
        ULONG_PTR   GP1_ENABLE;

        //
        // Length of GP1 register block
        //
        UCHAR   GP1_LEN;

        //
        // Number of GP1 logical registers
        //
        USHORT  Gpe1Size;
        USHORT  GP1_Base_Index;

        //
        // Total number of GPE logical registers
        //
        USHORT  GpeSize;

        //
        // I/O address of SMI_CMD
        //
        ULONG_PTR SMI_CMD;

        //
        // Bit mask of enabled PM1 events.
        //
        USHORT  pm1_en_bits;
        USHORT  pm1_wake_mask;
        USHORT  pm1_wake_status;
        USHORT  c2_latency;
        USHORT  c3_latency;

        //
        // see below for bit descriptions.
        //
        ULONG   ACPI_Flags;
        ULONG   ACPI_Capabilities;

        BOOLEAN Dockable;

    } ACPIInformation, *PACPIInformation;

    //
    // Value if GP1 is not supported
    //
    #define GP1_NOT_SUPPORTED       (USHORT) 0xFFFF

    //
    // descriptions of bits in ACPIInformation.ACPI_Flags
    //
    #define C2_SUPPORTED_BIT        3
    #define C2_SUPPORTED            (1 << C2_SUPPORTED_BIT)

    #define C3_SUPPORTED_BIT        4
    #define C3_SUPPORTED            (1 << C3_SUPPORTED_BIT)

    #define C3_PREFERRED_BIT        5
    #define C3_PREFERRED            (1 << C3_PREFERRED_BIT)

    //
    // descriptions of bits in ACPIInformation.ACPI_Capabilities
    //
    #define CSTATE_C1_BIT           4
    #define CSTATE_C1               (1 << CSTATE_C1_BIT)

    #define CSTATE_C2_BIT           5
    #define CSTATE_C2               (1 << CSTATE_C2_BIT)

    #define CSTATE_C3_BIT           6
    #define CSTATE_C3               (1 << CSTATE_C3_BIT)

    //
    // Define some useful pooltags
    //
    #define ACPI_SHARED_GPE_POOLTAG         'gpcA'
    #define ACPI_SHARED_INFORMATION_POOLTAG 'ipcA'
    #define ACPI_SHARED_TABLE_POOLTAG       'tpcA'

    //
    // Define how many processors we support...
    //
    #define ACPI_SUPPORTED_PROCESSORS   (sizeof(KAFFINITY) * 8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpisi.h ===
/*
 *  ACPISI.H - ACPI OS Independent System Indicator Routines
 *
 *  Notes:
 *
 *      This file provides OS independent functions for managing system indicators
 *
 */

typedef enum _SYSTEM_INDICATORS {

    SystemStatus,
    MessageWaiting

} SYSTEM_INDICATORS;


extern BOOLEAN SetSystemIndicator  (SYSTEM_INDICATORS  SystemIndicators, ULONG Value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiterm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiterm.h

Abstract:

    This module is the header for acpiterm.c

Author:

Environment:

    NT Kernel Mode Driver Only

--*/

#ifndef _ACPITERM_H_
#define _ACPITERM_H_

    VOID
    ACPICleanUp(
        VOID
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\loaddsdt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loaddsdt.c

Abstract:

    This handles loading the DSDT table and all steps leading up to it

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    02-Jun-97   Initial Revision

--*/

#ifndef _LOADDSDT_H_
#define _LOADDSDT_H_

    PRSDT
    ACPILoadFindRSDT(
        VOID
        );

    NTSTATUS
    ACPILoadProcessDSDT(
        ULONG_PTR   Address
        );

    NTSTATUS
    ACPILoadProcessFADT(
        PFADT       Fadt
        );

    NTSTATUS
    ACPILoadProcessFACS(
        ULONG_PTR   Address
        );

    NTSTATUS
    ACPILoadProcessRSDT(
        VOID
        );

    BOOLEAN
    ACPILoadTableCheckSum(
        PVOID   StartAddress,
        ULONG   Length
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpiterm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiterm.c

Abstract:

    This module contains functions to put an ACPI machine out of ACPI mode

Author:

    Jason Clark (jasoncl)

Environment:

    NT Kernel Model Driver only

--*/

#include "pch.h"


VOID
ACPICleanUp(
    VOID
    )
/*++

Routine Description:

    Resets the machine state out of ACPI mode and frees data structures
    allocated by this part of the driver

Arguments:

    None

Return Value:

    None

--*/
{
     //
     // Free the ACPIInformation structure.
     //
     ACPIPrint( (
         ACPI_PRINT_WARNING,
         "ACPICleanUp: Cleaning Up --- ACPI Terminated\n"
         ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\acpisi.c ===
/*
 *  ACPISI.C - ACPI OS Independent System Indicator Routines
 *
 *  Notes:
 *
 *      This file provides OS independent functions for managing system indicators
 *
 */

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SetSystemIndicator)
#endif


BOOLEAN
SetSystemIndicator  (
    SYSTEM_INDICATORS  SystemIndicators,
    ULONG Value
    )
{
    PNSOBJ  pns = NULL, pnssi = NULL;
    OBJDATA Arg0,data;
    char    IndicatorName []= "_SST";

    PAGED_CODE();


    switch (SystemIndicators)   {

        case SystemStatus:
            // StrCpy (IndicatorName, "_SST",sizeof(IndicatorName));

            // init arg0 for the control method

            ACPIPrint( (
                ACPI_PRINT_POWER,
                "System Status Value = %x\n",
                Value
                ) );

            Arg0.dwfData = 0;
            Arg0.uipDataValue = Value;
            Arg0.dwDataType = OBJTYPE_INTDATA;
            Arg0.dwDataLen = 0;
            Arg0.pbDataBuff = NULL;

            break;

        case MessageWaiting:
            StrCpy (IndicatorName, "_MSG",sizeof(IndicatorName));

            // init arg0 for the control method

            ACPIPrint( (
                ACPI_PRINT_POWER,
                "Message Waiting Value = %x\n",
                Value
                ) );

            Arg0.dwfData = 0;
            Arg0.uipDataValue = Value;
            Arg0.dwDataType = OBJTYPE_INTDATA;
            Arg0.dwDataLen = 0;
            Arg0.pbDataBuff = NULL;

            break;

        default:
            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "SetSystemIndicator: Unknown Indicator\n"
                ) );

            return FALSE;
    }

    if ( AMLIERR(AMLIGetNameSpaceObject ("\\_SI",NULL, &pnssi,0)) != AMLIERR_NONE )   {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "Could not GET \\_SI\n"
            ) );

        ACPIBreakPoint ();
        return FALSE;
    }

    if ( AMLIERR(AMLIGetNameSpaceObject (IndicatorName, pnssi, &pns,NSF_LOCAL_SCOPE)) == AMLIERR_NONE )    {

        if ( AMLIERR(AMLIEvalNameSpaceObject (pns,&data, 1, &Arg0)) == AMLIERR_NONE )   {

            AMLIFreeDataBuffs (&data,1);

        } else {

            ACPIPrint( (
                ACPI_PRINT_FAILURE,
                "Attempt to Eval %s %x failed using objdata %x\n",
                IndicatorName,pns,&Arg0
                ) );
            ACPIBreakPoint ();

        }

    } else {

        ACPIPrint( (
            ACPI_PRINT_FAILURE,
            "Attempt to GET %s failed\n",
            IndicatorName,pns,&Arg0
            ) );

    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI NT subtree

Author:

    Jason Clark (jasoncl)

Environment:

    Kernel mode only.

Revision History:

--*/

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include <stdarg.h>
#include <stdio.h>
#include <ntos.h>
#include <pci.h>
#include <dockintf.h>

#ifndef SPEC_VER
    #define SPEC_VER 100
#endif

#ifndef FAR
    #define FAR
#endif

#include <poclass.h>
#include <wdmguid.h>
#include <zwapi.h>
#include <ntpoapi.h>

#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// Interaces with the HAL
//
#include <ntacpi.h>

//
// These are the global include files for this project
//
#include "acpitabl.h"
#include "amli.h"
#include "aml.h"
#include "amlreg.h"
#include "hctioctl.h"
#include <devioctl.h>
#include "acpios.h"
#include "ospower.h"
#include "acpiregs.h"
#include <acpi.h>
#include <acpidbg.h>
#include <arbiter.h>
#include "strlib.h"

#include "acpierr.h"
#include "acpibs.h"
#include "acpipriv.h"
#include "acpiioct.h"
#include "acpimsft.h"

#include "acpienbl.h"
#include "acpictl.h"
#include "acpigpio.h"
#include "acpiinit.h"
#include "acpiio.h"
#include "acpilock.h"
#include "acpintfy.h"
#include "acpioprg.h"
#include "acpisi.h"
#include "acpiterm.h"
#include "loaddsdt.h"
#include "reg.h"

//
// Interfaces from the NT part of the driver
//
#include "acpiirp.h"
#include "acpilog.h"
#include "acpiosnt.h"
#include "amlisupp.h"
#include "acpidock.h"
#include "buildsrc.h"
#include "bus.h"
#include "button.h"
#include "cmbutton.h"
#include "dat.h"
#include "debug.h"
#include "detect.h"
#include "devpower.h"
#include "dispatch.h"
#include "errlog.h"
#include "extlist.h"
#include "filter.h"
#include "get.h"
#include "gpe.h"
#include "idevice.h"
#include "init.h"
#include "interfaces.h"
#include "internal.h"
#include "interupt.h"
#include "irqarb.h"
#include "msi.h"
#include "match.h"
#include "osnotify.h"
#include "pciopregion.h"
#include "rangesup.h"
#include "res_bios.h"
#include "res_cm.h"
#include "root.h"
#include "rtl.h"
#include "syspower.h"
#include "thermal.h"
#include "vector.h"
#include "wake.h"
#include "worker.h"

#ifdef ExAllocatePool
    #undef ExAllocatePool
#endif
#define ExAllocatePool(p,s) ExAllocatePoolWithTag(p,s,'ScpA')
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\reg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reg.c

Abstract:

    These functions access the registry

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    03-Jun-97   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

//
// This controls wether or not the various tables will be dumped to the
// registry
//
UCHAR                   DoAcpiTableDump = 0xFF;

#ifdef ALLOC_PRAGMA
#define alloc_text(PAGE,ACPIRegLocalCopyString)
#define alloc_text(PAGE,ACPIRegDumpAcpiTable)
#define alloc_text(PAGE,ACPIRegDumpAcpiTables)
#define alloc_text(PAGE,ACPIRegReadEntireAcpiTable)
#define alloc_text(PAGE,ACPIRegReadAMLRegistryEntry)
#endif


PUCHAR
ACPIRegLocalCopyString (
    PUCHAR  Destination,
    PUCHAR  Source,
    ULONG   MaxLength
    )
/*++

Routine Description:

    A little routine to copy short strings, since using sprintf here is
    like hitting a tack with a sledgehammer.  Terminates when a null or
    the max length is reached, whichever comes first.  Translates blanks
    to underscores, since everyone hates blanks embedded in registry keys.

Arguments:

    Destination     - Where to copy the string to
    Source          - Source string pointer
    MaxLength       - Max number of bytes to copy

Return Value:

    Returns the destination pointer incremented past the copied string

__*/
{
    ULONG               i;


    for (i = 0; i < MaxLength; i++) {

        if (Source[i] == 0) {
            break;

        } else if (Source[i] == ' ') {        // Translate blanks to underscores
            Destination [i] = '_';

        } else {
            Destination [i] = Source[i];
        }
    }

    Destination [i] = 0;
    return (Destination + i);
}

BOOLEAN
ACPIRegReadAMLRegistryEntry(
    IN  PVOID   *Table,
    IN  BOOLEAN MemoryMapped
    )
/*++

Routine Description:

    This reads a table from the registry

Arguments:

    Table   - Where to store the pointer to the table. If non-null, this
              contains a pointer to where the Original Table is stored
    MemorMapped - Indicates wether or not the table is memory mapped and should
              be unmapped once we are done with it

Return Value:

    TRUE - Success
    FALSE - Failure

__*/
{
    BOOLEAN             rc          = FALSE;
    HANDLE              revisionKey = NULL;
    HANDLE              tableIdKey  = NULL;
    NTSTATUS            status;
    PDESCRIPTION_HEADER header      = (PDESCRIPTION_HEADER) *Table;
    PUCHAR              key         = NULL; // ACPI_PARAMETERS_REGISTRY_KEY;
    PUCHAR              buffer;
    ULONG               action;
    ULONG               bytesRead;
    ULONG               baseSize;
    ULONG               totalSize;

    PAGED_CODE();

    //
    // Build a full path name to the thing we want in the registry
    //
    baseSize = strlen( ACPI_PARAMETERS_REGISTRY_KEY);
    totalSize = baseSize + ACPI_MAX_TABLE_STRINGS + 4;

    buffer = key = ExAllocatePool( PagedPool, totalSize );
    if (key == NULL) {

        return FALSE;

    }

    //
    // Generate the path name to the key. This avoids a costly sprintf
    //
    RtlZeroMemory( buffer, totalSize );
    RtlCopyMemory(
        buffer,
        ACPI_PARAMETERS_REGISTRY_KEY,
        baseSize
        );
    buffer += baseSize;
    *buffer++ = '\\';

    //
    // Table Signature (Up to 4 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->Signature, ACPI_MAX_SIGNATURE);
    *buffer++ = '\\';

    //
    // OEM ID field (Up to 6 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->OEMID, ACPI_MAX_OEM_ID);
    *buffer++ = '\\';

    //
    // OEM Table ID field (Up to 8 byte string)
    //
    buffer = ACPIRegLocalCopyString (buffer, (PUCHAR) &header->OEMTableID, ACPI_MAX_TABLE_ID);
    *buffer = 0;        // Terminate

    ACPIPrint ((
        ACPI_PRINT_REGISTRY,
        "ReadAMLRegistryEntry: opening key: %s\n",
        key));

    //
    // Open the <TableId>/OemId>/<OemTableId> key
    //
    status = OSOpenHandle(key, NULL, &tableIdKey);
    if ( !NT_SUCCESS(status) ) {

        ACPIPrint ((
            ACPI_PRINT_WARNING,
            "ReadAMLRegistryEntry: failed to open AML registry entry (rc=%x)\n",
            status));
        goto ReadAMLRegistryEntryExit;

    }

    //
    // Find the largest subkey that is equal or greater than the ROM
    // BIOS version of the table
    //
    status = OSOpenLargestSubkey(
        tableIdKey,
        &revisionKey,
        header->OEMRevision
        );
    if (!NT_SUCCESS(status)) {

       ACPIPrint ((
           ACPI_PRINT_WARNING,
           "ReadAMLRegistryEntry: no valid <OemRevision> key (rc=%#08lx)\n",
           status));
        goto ReadAMLRegistryEntryExit;

    }

    //
    // Get the Action value for this table, which tells us what to do with
    // the table
    //
    bytesRead = sizeof(action);
    status = OSReadRegValue(
        "Action",
        revisionKey,
        &action,
        &bytesRead
        );
    if (!NT_SUCCESS(status) || bytesRead != sizeof(action)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ReadAMLRegistryEntry: read action value = %#08lx. BytesRead=%d\n",
            status, bytesRead
            ) );
        action = ACTION_LOAD_TABLE; // Default action

    }

    //
    // Do the action
    //
    switch (action) {
    case ACTION_LOAD_TABLE:
        //
        // Overload entire ROM table
        //
        status = ACPIRegReadEntireAcpiTable(revisionKey, Table, MemoryMapped);
        if (NT_SUCCESS( status ) ) {

            rc = TRUE;

        }
        break;

    case ACTION_LOAD_ROM:
    case ACTION_LOAD_NOTHING:
        //
        // Nothing to do for these cases (return FALSE however);
        //
        break;

    default:
        //
        // Unsupported actions (return FALSE)
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ReadAMLRegistryEntry: Unsupported action value (action=%d)\n",
            action
            ) );
        break;

    }

    //
    // Always close the open keys
    //
ReadAMLRegistryEntryExit:
    if (key != NULL) {

        ExFreePool( key );

    }
    if (tableIdKey != NULL) {

        OSCloseHandle( tableIdKey );

    }
    if (revisionKey != NULL) {

        OSCloseHandle( revisionKey );


    }
    return rc;
}

NTSTATUS
ACPIRegReadEntireAcpiTable (
    IN  HANDLE  RevisionKey,
    IN  PVOID   *Table,
    IN  BOOLEAN MemoryMapped
    )
/*++

Routine Description:

    Reads the table from the registry into memory

Arguments:

    RevisionKey   - Handle to the key containing the table
    Table         - Pointer to the pointer to the table
    MemorymMapped - If True, indicates that we need to MmUnmapIo the table
                    otherwise, if False, we do no free the table (the
                    memory is static)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PUCHAR                  buffer;
    PVOID                   table;
    UCHAR                   value[9];
    ULONG                   bytesRead;
    ULONG                   index = 0;
    ULONG                   entry;
    PREGISTRY_HEADER        entryHeader;
    PDESCRIPTION_HEADER     descHeader = (PDESCRIPTION_HEADER) *Table;

    PAGED_CODE();

    //
    // We need an 8k buffer
    //
    buffer = ExAllocatePool( PagedPool, 8 * 1024 );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Repeat this forever
    //
    for (index = 0; ;index++) {

        //
        // This is the first data value
        //
        sprintf(value, "%08lx", index );

        //
        // Read the entry header to get the size of the table. This is stored
        // before the actual table
        //
        bytesRead = 8 * 1024;
        status = OSReadRegValue(
            value,
            RevisionKey,
            buffer,
            &bytesRead
            );
        if (!NT_SUCCESS(status) ) {

            //
            // Not being able to read the table isn't a failure case
            //
            status = STATUS_SUCCESS;
            break;

        } else if (bytesRead < sizeof(REGISTRY_HEADER) ) {

            //
            // Not being to read the proper number of bytes is
            //
            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ReadEntireAcpiTable: read registry header (bytes=%d)\n",
                bytesRead
                ) );
            return STATUS_UNSUCCESSFUL;

        }

        //
        // Loop while we still have bytes to process
        //
        for (entry = 0;
             entry < bytesRead;
             entry += (entryHeader->Length + sizeof(REGISTRY_HEADER) )
            ) {

            //
            // Grab a pointer to the entry record
            //
            entryHeader = (PREGISTRY_HEADER) &(buffer[entry]);

            //
            // Crack the record
            //
            if (entryHeader->Length == 0) {

                //
                // Special Case
                //
                if (entryHeader->Offset != descHeader->Length) {

                    //
                    // Must change the table size
                    //
                    table = ExAllocatePoolWithTag(
                        NonPagedPool,
                        entryHeader->Offset,
                        ACPI_SHARED_TABLE_POOLTAG
                        );
                    if (table == NULL) {

                        ExFreePool( buffer );
                        return STATUS_INSUFFICIENT_RESOURCES;

                    }

                    //
                    // How much do we have to copy?
                    //
                    RtlCopyMemory(
                        table,
                        *Table,
                        min( entryHeader->Offset, descHeader->Length )
                        );

                    //
                    // Free the old table based on wether or not its mm mapped
                    //
                    if (MemoryMapped) {

                        MmUnmapIoSpace(*Table, descHeader->Length);

                    } else {

                        ExFreePool( *Table );

                    }

                    //
                    // Remember the address of the new table
                    //
                    descHeader = (PDESCRIPTION_HEADER) *Table = table;

                }

                //
                // Done with this record
                //
                continue;

            }

            //
            // Patch the memory
            //
            ASSERT( entryHeader->Offset < descHeader->Length );
            RtlCopyMemory(
                ( (PUCHAR) *Table) + entryHeader->Offset,
                (PUCHAR) entryHeader + sizeof( REGISTRY_HEADER ),
                entryHeader->Length
                );
        }
    }

    //
    // Normal exit
    //
    if (buffer != NULL) {

        ExFreePool( buffer );
    }
    return status;

}

/****************************************************************************
 *
 *      DumpAcpiTable
 *              Write an ACPI Table to the registry
 *
 *      Not exported.
 *
 *      ENTRY:  pszName     - Name of the table to write (4 byte string)
 *              Table       - Pointer to table data
 *              Length      - of the table
 *              Header      - Pointer to the table header
 *
 *      EXIT:   NONE
 *
 ***************************************************************************/
VOID
ACPIRegDumpAcpiTable (
    PSZ                 pszName,
    PVOID               Table,
    ULONG               Length,
    PDESCRIPTION_HEADER Header
    )
{
    //NTSTATUS            status;
    UCHAR               buffer [80] = "\\Registry\\Machine\\Hardware\\ACPI";
    HANDLE              hSubKey;
    HANDLE              hPrefixKey;

    PAGED_CODE();

    //
    // Create /Registry/Machine/Hardware/ACPI subkey
    //
    if ( !NT_SUCCESS(OSCreateHandle (buffer, NULL, &hPrefixKey) ) ) {
        return;
    }

    //
    // Create table name subkey (DSDT, FACP, FACS, or RSDT) - 4 bytes
    //
    if ( !NT_SUCCESS(OSCreateHandle (pszName, hPrefixKey, &hSubKey) ) ) {
        goto DumpAcpiTableExit;
    }

    //
    // For tables with headers, add subkeys for
    // <OemId>/<OemTableID>/<OemRevision>
    //
    if (Header) {

        OSCloseHandle(hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM ID field (6 byte string)
        //
        ACPIRegLocalCopyString (buffer, Header->OEMID, ACPI_MAX_OEM_ID);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }

        OSCloseHandle (hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM Table ID field (8 byte string)
        //
        ACPIRegLocalCopyString (buffer, Header->OEMTableID, ACPI_MAX_TABLE_ID);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }

        OSCloseHandle (hPrefixKey);
        hPrefixKey = hSubKey;

        //
        // OEM Revision field  (4 byte number)
        //
        sprintf (buffer, "%.8x", Header->OEMRevision);
        if ( !NT_SUCCESS(OSCreateHandle (buffer, hPrefixKey, &hSubKey) ) ) {
            goto DumpAcpiTableExit;
        }
    }

    //
    // Finally, write the entire table
    //
    OSWriteRegValue ("00000000", hSubKey, Table, Length);

    //
    // Delete open handles
    //
    OSCloseHandle (hSubKey);
DumpAcpiTableExit:
    OSCloseHandle (hPrefixKey);

    return;
}


/****************************************************************************
 *
 *      DumpAcpiTables
 *              Write the ACPI Tables to the registry.  Should be called only
 *              after table pointers have been initialized.
 *
 *      Not exported.
 *
 *      ENTRY:  NONE
 *      EXIT:   NONE.
 *
 ***************************************************************************/
VOID
ACPIRegDumpAcpiTables (VOID)
{
    PDSDT       dsdt = AcpiInformation->DiffSystemDescTable;
    PFACS       facs = AcpiInformation->FirmwareACPIControlStructure;
    PFADT       fadt = AcpiInformation->FixedACPIDescTable;
    PRSDT       rsdt = AcpiInformation->RootSystemDescTable;


    if (DoAcpiTableDump) {

        ACPIPrint ((
            ACPI_PRINT_REGISTRY,
            "DumpAcpiTables: Writing DSDT/FACS/FADT/RSDT to registry\n"));

        if (dsdt) {

            ACPIRegDumpAcpiTable(
                "DSDT",
                dsdt,
                dsdt->Header.Length,
                &(dsdt->Header)
                );

        }

        if (facs) {

            ACPIRegDumpAcpiTable(
                "FACS",
                facs,
                facs->Length,
                NULL
                );

        }

        if (fadt) {

            ACPIRegDumpAcpiTable(
                "FADT",
                fadt,
                fadt->Header.Length,
                &(fadt->Header)
                );

        }

        if (rsdt) {

            ACPIRegDumpAcpiTable(
                "RSDT",
                rsdt,
                rsdt->Header.Length,
                &(rsdt->Header)
                );

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\loaddsdt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loaddsdt.c

Abstract:

    This handles loading the DSDT table and all steps leading up to it

Author:

    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    02-Jun-97   Initial Revision

--*/

#include "pch.h"
#include "amlreg.h"
#include <stdio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ACPILoadFindRSDT)
#pragma alloc_text(PAGE,ACPILoadProcessDSDT)
#pragma alloc_text(PAGE,ACPILoadProcessFADT)
#pragma alloc_text(PAGE,ACPILoadProcessFACS)
#pragma alloc_text(PAGE,ACPILoadProcessRSDT)
#pragma alloc_text(PAGE,ACPILoadTableCheckSum)
#endif

#if DBG
BOOLEAN AcpiLoadSimulatorTable = TRUE;
#else
BOOLEAN AcpiLoadSimulatorTable = FALSE;
#endif


PRSDT
ACPILoadFindRSDT(
    VOID
    )
/*++

Routine Description:

    This routine looks at the registry to find the value stored there by
    ntdetect.com

Arguments:

    None

Return Value:

    Pointer to the RSDT

--*/
{
    NTSTATUS                        status;
    PACPI_BIOS_MULTI_NODE           rsdpMulti;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDesc;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialList;
    PHYSICAL_ADDRESS                PhysAddress = {0};
    PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64  keyInfo;
    PRSDT                           rsdtBuffer = NULL;
    PRSDT                           rsdtPointer;
    ULONG                           MemSpace = 0;

    PAGED_CODE();

    //
    // Read the key for that AcpiConfigurationData
    //
    status = OSReadAcpiConfigurationData( &keyInfo );
    if (!NT_SUCCESS(status)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRSDT: Cannot open Configuration Data - 0x%08lx\n",
            status
            ) );
        ACPIBreakPoint();
        return NULL;

    }

    //
    // Crack the structure
    //
    cmPartialList = (PCM_PARTIAL_RESOURCE_LIST) (keyInfo->Data);
    cmPartialDesc = &(cmPartialList->PartialDescriptors[0]);
    rsdpMulti = (PACPI_BIOS_MULTI_NODE) ( (PUCHAR) cmPartialDesc +
        sizeof(CM_PARTIAL_RESOURCE_LIST) );

    //
    // Read the Header part of the table
    //

    PhysAddress.QuadPart = rsdpMulti->RsdtAddress.QuadPart;
    rsdtPointer = MmMapIoSpace(
        PhysAddress,
        sizeof(DESCRIPTION_HEADER),
        MmNonCached
        );

    if (rsdtPointer == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: Cannot Map RSDT Pointer 0x%08lx\n",
            rsdpMulti->RsdtAddress.LowPart
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    } else if ((rsdtPointer->Header.Signature != RSDT_SIGNATURE) &&
               (rsdtPointer->Header.Signature != XSDT_SIGNATURE)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: RSDT 0x%08lx has invalid signature\n",
            rsdtPointer
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    }

    //
    // Read the entire RSDT
    //
    rsdtBuffer = MmMapIoSpace(
        PhysAddress,
        rsdtPointer->Header.Length,
        MmNonCached
        );

    //
    // Give back a PTE now that we're done with the rsdtPointer.
    //
    MmUnmapIoSpace(rsdtPointer, sizeof(DESCRIPTION_HEADER));

    //
    // did we find the right rsdt buffer?
    //
    if (rsdtBuffer == NULL) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadFindRsdt: Cannot Map RSDT Pointer 0x%08lx\n",
            rsdpMulti->RsdtAddress.LowPart
            ) );
        ACPIBreakPoint();
        goto RsdtDone;

    }

RsdtDone:
    //
    // Done with these buffers
    //

    ExFreePool( keyInfo );

    //
    // return the RSDT
    //
    return rsdtBuffer;
}

NTSTATUS
ACPILoadProcessDSDT(
    ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine loads the DSDT (a pointer is stored in the FADT) and forces
    the interpreter to process it

Arguments:

    Address - Where the DSDT is located in memory

Return Value:

    NTSTATUS

--*/
{

    BOOLEAN     foundOverride;
    PDSDT       linAddress;
    ULONG       index;
    ULONG       length;
    ULONG                MemSpace = 0;
    PHYSICAL_ADDRESS     PhysAddress = {0};

    //
    // Map the header in virtual address space to get the length
    //
    PhysAddress.QuadPart = (ULONGLONG) Address;
    linAddress = MmMapIoSpace(
        PhysAddress,
        sizeof(DESCRIPTION_HEADER),
        MmNonCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if ( linAddress->Header.Signature != DSDT_SIGNATURE) {

        //
        // Signature should have matched DSDT but didn't !
        //
        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessDSDT: 0x%08lx does not have DSDT signature\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // Determine the size of the DSDT
    //
    length = linAddress->Header.Length;

    //
    // Now map the whole thing.
    //
    MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));
    linAddress = MmMapIoSpace(
        PhysAddress,
        length,
        MmNonCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Look at the RsdtInformation to determine the index of the last
    // element in the table. We know that we can use that space to store
    // the information about this table
    //
    index = RsdtInformation->NumElements;
    if (index == 0) {

        return STATUS_ACPI_NOT_INITIALIZED;

    }
    index--;

    //
    // Try to read the DSDT from the registry
    //
    foundOverride = ACPIRegReadAMLRegistryEntry( &linAddress, TRUE );
    if (foundOverride) {

        ACPIPrint( (
            ACPI_PRINT_WARNING,
            "ACPILoadProcessDSDT: DSDT Overloaded from registry (0x%08lx)\n",
            linAddress
            ) );
        RsdtInformation->Tables[index].Flags |= RSDTELEMENT_OVERRIDEN;

    }

    //
    // Store a pointer to the DSDT
    //
    AcpiInformation->DiffSystemDescTable = linAddress;

    //
    // Remember this address and that we need to unmap it
    //
    RsdtInformation->Tables[index].Flags |=
        (RSDTELEMENT_MAPPED | RSDTELEMENT_LOADABLE);
    RsdtInformation->Tables[index].Address = linAddress;

    //
    // Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ACPILoadProcessFACS(
    ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine handles the FACS

Arguments:

    Address - Where the FACS is located

Return Value:

    None

--*/
{
    PFACS               linAddress;
    ULONG               MemSpace = 0;
    PHYSICAL_ADDRESS    PhysAddress = {0};

    // Note: On Alpha, the FACS is optional.
    //
    // Return if FACS address is not valid.
    //
    if (!Address) {

        return STATUS_SUCCESS;

    }

    //
    // Map the FACS into virtual address space.
    //
    PhysAddress.QuadPart = (ULONGLONG) Address;

    linAddress = MmMapIoSpace(
        PhysAddress,
        sizeof(FACS),
        MmNonCached
        );
    if (linAddress == NULL) {

        ASSERT (linAddress != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if (linAddress->Signature != FACS_SIGNATURE) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessFACS: 0x%08lx does not have FACS signature\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    if (linAddress->Length != sizeof(FACS)) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessFACS: 0x%08lx does not have correct FACS length\n",
            linAddress
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFACS: FACS located at 0x%8lx\n",
        linAddress
        ) );
    AcpiInformation->FirmwareACPIControlStructure = linAddress;

    //
    // And store the address of the GlobalLock structure that lives within
    // the FACS
    //
    AcpiInformation->GlobalLock = &(ULONG)(linAddress->GlobalLock);
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFACS: Initial GlobalLock state: 0x%8lx\n",
        *(AcpiInformation->GlobalLock)
        ) );

    //
    // At this point, we are successfull
    //
    return STATUS_SUCCESS;
}

ULONG_PTR
GetFadtTablePointerEntry(
    PFADT Fadt,
    PULONG LegacyAddress,
    PGEN_ADDR  NonLegacyAddress,
    SIZE_T Size
    )
/*++

Routine Description:

    This routine reads an address field from the FADT.  If the Fadt revision
    is too old, we use the legacy address. If it's new enough, the generic 
    register address data is used.  If necessary, the address is mapped into
    memory.
    
    KB.  Do not access NonLegacyAddress if the table revision does not support
    the NonLegacyAddress, as this will be pointing to a bogus memory location
    and could cause an illegal memory access.

Arguments:

    Fadt    - Pointer to the Fadt
    LegacyAddress - Pointer to legacy address.
    NonLegacyAddress - Pointer to non-legacy address.
    Size - size of entry that address points to.

Return Value:

    a valid pointer to the table entry, or NULL if it's invalid.

--*/
{
    ULONG_PTR ReturnValue;
    
    //
    // revision 3 and greater of FADT define a generic register address
    // structure.  Before that version we just have to use the legacy address.
    //
    if (Fadt->Header.Revision < 3) {
        ReturnValue = *LegacyAddress;
    } else {
    
        switch(NonLegacyAddress->AddressSpaceID) {
            
            case AcpiGenericSpaceIO:
                ReturnValue = (ULONG_PTR)NonLegacyAddress->Address.QuadPart;
                break;

            case AcpiGenericSpaceMemory:
                //
                // MmMapIoSpace hates it if you pass in zero, so guard against
                // this.
                //
                if (NonLegacyAddress->Address.QuadPart == 0) {
                    ReturnValue = (ULONG_PTR)0;
                } else {
                    ReturnValue = (ULONG_PTR)MmMapIoSpace(
                                    NonLegacyAddress->Address,
                                    Size,
                                    MmNonCached );

                    //
                    // right now, assume all or nothing -- if any of the
                    // items in the FADT are marked as MMIO space, they
                    // all are, and we must use register-based access to
                    // access the backing hardware.
                    //
                    if ( ReturnValue && 
                         (AcpiReadRegisterRoutine == DefPortReadAcpiRegister) &&
                         (AcpiWriteRegisterRoutine == DefPortWriteAcpiRegister) ) {
                        AcpiReadRegisterRoutine  = DefRegisterReadAcpiRegister;
                        AcpiWriteRegisterRoutine  = DefRegisterWriteAcpiRegister;
                    }
                }
                break;
            
            default:
                ASSERT(FALSE);
                ReturnValue = 0;
        }
    }

    
#ifndef IA64
    //
    // We don't want to support this part of acpi 2.0 for anything other
    // than ia64 for the windows server release.  we don't want to risk
    // breaking bios's that get this table information incorrect.  we will turn
    // this on when we have a full testing cycle available.
    //
    ReturnValue = *LegacyAddress;

    if ( (AcpiReadRegisterRoutine == DefRegisterReadAcpiRegister) &&
         (AcpiWriteRegisterRoutine == DefRegisterWriteAcpiRegister)) {
        AcpiReadRegisterRoutine = DefPortReadAcpiRegister;
        AcpiWriteRegisterRoutine = DefPortWriteAcpiRegister;
    }

#endif


    return(ReturnValue);

}


#define GET_FADT_TABLE_ENTRY(_fadt,_legacyaddr,_nonlegacyaddr,_size) \
     (  GetFadtTablePointerEntry( _fadt, &_fadt->_legacyaddr, &_fadt->_nonlegacyaddr, _size ) )


NTSTATUS
ACPILoadProcessFADT(
    PFADT   Fadt
    )
/*++

Routine Description:

    This reads the FADT and stores some useful information in the
    information structure

Arguments:

    Fadt    - Pointer to the Fadt

Return Value:

    None

--*/
{
    KAFFINITY   processors;
    NTSTATUS    status;
    PUCHAR      gpeTable;
    PDSDT       linAddress;
    ULONG       length;
    ULONG       totalSize;
    ULONG                MemSpace = 0;
    PHYSICAL_ADDRESS     PhysAddress = {0};

    PAGED_CODE();

    //
    // This is a 2.0-level FADT.
    //

    //
    // Handle the FACS part of the FADT.  We must do this before the DSDT
    // so that we have the global lock mapped and initialized.
    //
#ifdef IA64
    status = ACPILoadProcessFACS( (Fadt->Header.Revision < 3)
                                    ? Fadt->facs
                                    : (ULONG_PTR)Fadt->x_firmware_ctrl.QuadPart );
#else
    //
    // get rid of this ifdef once we have a full testing cycle available for 
    // catching any broken firmware
    //
    status = ACPILoadProcessFACS(Fadt->facs);
#endif

    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Store the I/O addresses of PM1a_BLK, PM1b_BLK, PM1a_CNT, PM1b_CNT,
    // PM2_CNT, PM_TMR
    //

    AcpiInformation->PM1a_BLK       = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm1a_evt_blk_io_port,
                                                           x_pm1a_evt_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->PM1b_BLK       = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm1b_evt_blk_io_port,
                                                           x_pm1b_evt_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->PM1a_CTRL_BLK  = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm1a_ctrl_blk_io_port,
                                                           x_pm1a_ctrl_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->PM1b_CTRL_BLK  = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm1b_ctrl_blk_io_port,
                                                           x_pm1b_ctrl_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->PM2_CTRL_BLK   = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm2_ctrl_blk_io_port,
                                                           x_pm2_ctrl_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->PM_TMR         = GET_FADT_TABLE_ENTRY(Fadt,
                                                           pm_tmr_blk_io_port,
                                                           x_pm_tmr_blk,
                                                           sizeof(ULONG_PTR));

    AcpiInformation->SMI_CMD        = (ULONG_PTR) Fadt->smi_cmd_io_port;

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM1a_BLK located at port %p\n"
        "ACPILoadProcessFADT: PM1b_BLK located at port %p\n",
        AcpiInformation->PM1a_BLK,
        AcpiInformation->PM1b_BLK
        ) );
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM1a_CTRL_BLK located at port %p\n"
        "ACPILoadProcessFADT: PM1b_CTRL_BLK located at port %p\n",
        AcpiInformation->PM1a_CTRL_BLK,
        AcpiInformation->PM1b_CTRL_BLK
        ) );
    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: PM2_CTRL_BLK located at port %p\n"
        "ACPILoadProcessFADT: PM_TMR located at port %p\n",
        AcpiInformation->PM2_CTRL_BLK,
        AcpiInformation->PM_TMR
        ) );

    //
    // Initialize the global GPE tables.
    //
    // If any of the GPn_BLK addresses are 0 leave GPn_LEN at it's initialized
    // value (0). That way later on we only have to check GPn_LEN to determine
    // the existence of a GP register.
    //

    //
    // Assume this is true until we find out otherwise
    //
    AcpiInformation->GP1_Base_Index = GP1_NOT_SUPPORTED;

    //
    // Crack the GP0 block
    //
    AcpiInformation->GP0_BLK = GET_FADT_TABLE_ENTRY(
                                                Fadt,
                                                gp0_blk_io_port,
                                                x_gp0_blk,
                                                Fadt->gp0_blk_len);
    if (AcpiInformation->GP0_BLK != 0) {

        AcpiInformation->GP0_LEN = Fadt->gp0_blk_len;
        ACPISimpleFatalHardwareAssert(
            (Fadt->gp0_blk_len != 0),
            ACPI_I_GP_BLK_LEN_0
            );

    }

    //
    // Crack the GP1 Block
    //
    AcpiInformation->GP1_BLK = GET_FADT_TABLE_ENTRY(
                                                Fadt,
                                                gp1_blk_io_port,
                                                x_gp1_blk,
                                                Fadt->gp1_blk_len);
    if (AcpiInformation->GP1_BLK != 0) {

        AcpiInformation->GP1_LEN = Fadt->gp1_blk_len;
        AcpiInformation->GP1_Base_Index = Fadt->gp1_base;
        ACPISimpleFatalHardwareAssert (
            (Fadt->gp1_blk_len != 0),
            ACPI_I_GP_BLK_LEN_1
            );

    }

    //
    // Compute sizes of the register blocks.  The first half of each block
    // contains status registers, the second half contains the enable registers.
    //
    AcpiInformation->Gpe0Size   = AcpiInformation->GP0_LEN / 2;
    AcpiInformation->Gpe1Size   = AcpiInformation->GP1_LEN / 2;
    AcpiInformation->GpeSize    = AcpiInformation->Gpe0Size +
        AcpiInformation->Gpe1Size;

    //
    // Addresses of the GPE Enable register blocks
    //
    AcpiInformation->GP0_ENABLE = AcpiInformation->GP0_BLK +
        AcpiInformation->Gpe0Size;
    AcpiInformation->GP1_ENABLE = AcpiInformation->GP1_BLK +
        AcpiInformation->Gpe1Size;

    //
    // Create all GPE bookeeping tables with a single allocate
    //
    if (AcpiInformation->GpeSize) {

        totalSize = (AcpiInformation->GpeSize * 12) +   // Twelve Bitmaps
                    (AcpiInformation->GpeSize * 8);     // One bytewide table
        gpeTable = (PUCHAR)ExAllocatePoolWithTag(
            NonPagedPool,
            totalSize,
            ACPI_SHARED_GPE_POOLTAG
            );
        if (gpeTable == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPILoadProcessFADT: Could not allocate GPE tables, "
                "size = 0x%8lx\n",
                totalSize
                ) );
            return STATUS_INSUFFICIENT_RESOURCES;

        }
        RtlZeroMemory (gpeTable, totalSize);

        //
        // Setup the table pointers
        //
        GpeEnable           = gpeTable;
        GpeCurEnable        = GpeEnable         + AcpiInformation->GpeSize;
        GpeIsLevel          = GpeCurEnable      + AcpiInformation->GpeSize;
        GpeHandlerType      = GpeIsLevel        + AcpiInformation->GpeSize;
        GpeWakeEnable       = GpeHandlerType    + AcpiInformation->GpeSize;
        GpeWakeHandler      = GpeWakeEnable     + AcpiInformation->GpeSize;
        GpeSpecialHandler   = GpeWakeHandler    + AcpiInformation->GpeSize;
        GpePending          = GpeSpecialHandler + AcpiInformation->GpeSize;
        GpeRunMethod        = GpePending        + AcpiInformation->GpeSize;
        GpeComplete         = GpeRunMethod      + AcpiInformation->GpeSize;
        GpeSavedWakeMask    = GpeComplete       + AcpiInformation->GpeSize;
        GpeSavedWakeStatus  = GpeSavedWakeMask  + AcpiInformation->GpeSize;
        GpeMap              = GpeSavedWakeStatus+ AcpiInformation->GpeSize;

    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessFADT: GP0_BLK located at port %p length 0x%08lx\n"
        "ACPILoadProcessFADT: GP1_BLK located at port %p length 0x%08lx\n"
        "ACPILoadProcessFADT: GP1_Base_Index = 0x%x\n",
        AcpiInformation->GP0_BLK,
        AcpiInformation->GP0_LEN,
        AcpiInformation->GP1_BLK,
        AcpiInformation->GP1_LEN,
        AcpiInformation->GP1_Base_Index
        ) );

    //
    // At this point, we should know enough to be able to turn off and
    // clear all the GPE registers
    //
    ACPIGpeClearRegisters();
    ACPIGpeEnableDisableEvents( FALSE );

    AcpiInformation->ACPI_Flags = 0;
    AcpiInformation->ACPI_Capabilities = 0;

    //
    // Can we dock this machine?
    //
    AcpiInformation->Dockable = (Fadt->flags & DCK_CAP) ? TRUE : FALSE;

    //
    // This code used to be executed from within InitializeAndEnableACPI,
    // however we need to know *while* processing the DSDT what the Enable
    // bits are. To start with, we always want the ACPI timer and GL events
    //
    AcpiInformation->pm1_en_bits = PM1_TMR_EN | PM1_GBL_EN;

    //
    // Is there a control method Power Button? If not, then there a fixed
    // power button
    //

    if ( !(Fadt->flags & PWR_BUTTON_GENERIC) ) {

        AcpiInformation->pm1_en_bits   |= PM1_PWRBTN_EN;
        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Power Button in Fixed Feature Space\n"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Power Button not fixed event or "
            "not present\n"
            ) );

    }

    //
    // Is there a control method Sleep Button? If not, then the fixed button
    // always doubles as a wake button
    //
    if ( !(Fadt->flags & SLEEP_BUTTON_GENERIC) ){

        AcpiInformation->pm1_en_bits |= PM1_SLEEPBTN_EN;
        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Sleep Button in Fixed Feature Space\n"
            ) );

    } else {

        ACPIPrint( (
            ACPI_PRINT_LOADING,
            "ACPILoadProcessFADT: Sleep Button not fixed event or "
            "not present\n"
            ) );

    }

    //
    // Handle the DSDT part of the FADT. We handle this last because we
    // need to have the FADT fully parsed before we can load the name space
    // tree. A particular example is the Dockable bit you see directly above.
    //
#ifdef IA64
    return ACPILoadProcessDSDT( (Fadt->Header.Revision < 3)
                                ? Fadt->dsdt
                                : (ULONG_PTR)Fadt->x_dsdt.QuadPart
                              );

#else
    return ACPILoadProcessDSDT(Fadt->dsdt);    
#endif

}

NTSTATUS
ACPILoadProcessRSDT(
    VOID
    )
/*++

Routine Description:

    Called by ACPIInitialize once ACPI has been detected on the machine.
    This walks the tables in the RSDT and fills in the information for the
    global data structure.

    This routine does *NOT* cause the xDSTs to start loading in the
    interpreter

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{
    //
    // Upon entry acpiinformation->RootSystemDescTable contains the linear
    // address of the RSDT walk through the array of the tables pointed to
    // by the RSDT and for each table (whose type we are familiar with)
    // store the linear base address of the table in the acpiinformation
    // structure
    //
    BOOLEAN             foundOverride   = FALSE;
    BOOLEAN             foundFADT       = FALSE;
    BOOLEAN             usingXSDT       = FALSE;
    PDESCRIPTION_HEADER header;
    PVOID               linAddress;
    ULONG               index;
    ULONG               length;
    ULONG               numTables;
    ULONG               MemSpace = 0;
    PHYSICAL_ADDRESS    PhysAddress = {0};

    PAGED_CODE();

    //
    // Get the number of tables
    //
    if (AcpiInformation->RootSystemDescTable->Header.Signature ==
        XSDT_SIGNATURE) {

        numTables = NumTableEntriesFromXSDTPointer(
             AcpiInformation->RootSystemDescTable
             );
        usingXSDT = TRUE;

    } else {

        numTables = NumTableEntriesFromRSDTPointer(
             AcpiInformation->RootSystemDescTable
             );
    }

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadProcessRSDT: RSDT contains %u tables\n",
        numTables
        ) );
    if (numTables == 0) {

        return STATUS_ACPI_INVALID_TABLE;

    }

    //
    // Allocate the RSDTINFORMATION to hold an entry for each element
    // in the table.
    //
    // NOTENOTE: We are actually allocating space for numTables + 2
    // in the RSDT information. The reason for this is that the DSDT
    // is actually stored in the FADT, and so it does not have an entry
    // in the RSDT. We always, always store the DSDT as the last entry
    // in the RsdtInformation structure. In the 2nd to last entry we store
    // the dummy header that we use for the ACPI simulator
    //
    length = sizeof(RSDTINFORMATION) + ( (numTables + 1) * sizeof(RSDTELEMENT) );
    RsdtInformation = ExAllocatePoolWithTag(
        NonPagedPool,
        length,
        ACPI_SHARED_TABLE_POOLTAG
        );
    if (RsdtInformation == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlZeroMemory( RsdtInformation, length );
    RsdtInformation->NumElements = (numTables + 2);

    //
    // Examine each table entry in the RSDT
    //
    for (index = 0;index < numTables; index++) {
       
        //
        // RSDT contains an array of physical pointers.
        //

        //
        // Get the linear address of the table
        //
        PhysAddress.QuadPart = usingXSDT ?
            (ULONGLONG) ((PXSDT)AcpiInformation->RootSystemDescTable)->Tables[index].QuadPart :
            (ULONGLONG) AcpiInformation->RootSystemDescTable->Tables[index];

        
        linAddress = MmMapIoSpace(
            PhysAddress,
            sizeof (DESCRIPTION_HEADER),
            MmNonCached
            );

        if (linAddress == NULL) {
            ASSERT (linAddress != NULL);
            return STATUS_ACPI_INVALID_TABLE;
        }

        //
        // Is this a known, but unused table?
        //
        header = (PDESCRIPTION_HEADER) linAddress;

        
        if (header->Signature == SBST_SIGNATURE) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPILoadProcessRSDT: SBST Found at 0x%08lx\n",
                linAddress
                ) );

            MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));

            continue;
        }

        //
        // Is this an unrecognized table?
        //
        if (header->Signature != FADT_SIGNATURE &&
            header->Signature != SSDT_SIGNATURE &&
            header->Signature != PSDT_SIGNATURE &&
            header->Signature != APIC_SIGNATURE) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPILoadProcessRSDT: Unrecognized table signature 0x%08lx\n",
                header->Signature
                ) );

            MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));

            continue;
        }

        //
        // At this point, we know that we need to bring the entire table
        // in. To do that, we need to remember the length
        //
        length = header->Length;
        
        //
        // map the entire table using the now known length
        //
        MmUnmapIoSpace(linAddress, sizeof(DESCRIPTION_HEADER));

        linAddress = MmMapIoSpace(
            PhysAddress,
            length,
            MmNonCached
            );
        
        
        if (linAddress == NULL) {

            ACPIPrint( (
                ACPI_PRINT_CRITICAL,
                "ACPILoadProcesRSDT: Could not load table at 0x%08lx\n",
                AcpiInformation->RootSystemDescTable->Tables[index]
                ) );
            return STATUS_ACPI_INVALID_TABLE;

        }

        //
        // Should we override the table?
        //
        foundOverride = ACPIRegReadAMLRegistryEntry( &linAddress, TRUE);
        if (foundOverride) {

            ACPIPrint( (
                ACPI_PRINT_WARNING,
                "ACPILoadProcessRSDT: Table Overloaded from "
                "registry (0x%08lx)\n",
                linAddress
                ) );
            RsdtInformation->Tables[index].Flags |= RSDTELEMENT_OVERRIDEN;

        }

        //
        // Remember this address and that we need to unmap it
        //
        RsdtInformation->Tables[index].Flags |= RSDTELEMENT_MAPPED;
        RsdtInformation->Tables[index].Address = linAddress;

        //
        // Remember the new header
        //
        header = (PDESCRIPTION_HEADER) linAddress;

        //
        // At this point, we only need to do any kind of special processing
        // if the table is the FADT or if it is the MAPIC
        //
        if (header->Signature == FADT_SIGNATURE) {
            
            //
            // fill in the appropriate field in acpiinformation
            //
            AcpiInformation->FixedACPIDescTable = (PFADT) linAddress;

            //
            // Process the table. This does not cause the interpreter
            // to load anything
            //
            foundFADT = TRUE;
            ACPILoadProcessFADT( AcpiInformation->FixedACPIDescTable );

        } else if (header->Signature == APIC_SIGNATURE) {

            //
            // fill in the appropriate field in acpiinformation
            //
            AcpiInformation->MultipleApicTable = (PMAPIC)linAddress;

        } else {

            //
            // We can only reach this case if the table is one of the
            // xSDT variety. We need to remember that we will eventually
            // need to load it into the interpreter. If we start supporting
            // any more tables, we need to make sure that they don't fall
            // down here unless they really, really are supported
            //
            RsdtInformation->Tables[index].Flags |= RSDTELEMENT_LOADABLE;

        }

    }

    //
    // At this point, we need to make sure that the ACPI simulator table
    // gets loaded
    //
    header = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(DESCRIPTION_HEADER),
        ACPI_SHARED_TABLE_POOLTAG
        );
    if (header) {

        //
        // Initialize the header so that it can be passed into the overload
        // engine
        //
        RtlZeroMemory( header, sizeof(DESCRIPTION_HEADER) );
        header->Signature   = SSDT_SIGNATURE;
        header->Length      = sizeof(DESCRIPTION_HEADER),
        header->Revision    = 1;
        header->Checksum    = 0;
        header->OEMRevision = 1;
        header->CreatorRev  = 1;
        RtlCopyMemory( header->OEMID, "MSFT", 4 );
        RtlCopyMemory( header->OEMTableID, "simulatr", 8);
        RtlCopyMemory( header->CreatorID, "MSFT", 4);

        //
        // Should we override the table?
        //
        if (AcpiLoadSimulatorTable) {

            foundOverride = ACPIRegReadAMLRegistryEntry( &header, FALSE);

        }
        if (foundOverride) {

            ACPIPrint( (
                ACPI_PRINT_LOADING,
                "ACPILoadProcessRSDT: Simulator Table Overloaded from "
                "registry (0x%08lx)\n",
                linAddress
                ) );

            //
            // Remember this address and that we need to unmap it
            //
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_MAPPED;
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_OVERRIDEN;
            RsdtInformation->Tables[numTables].Flags   |= RSDTELEMENT_LOADABLE;
            RsdtInformation->Tables[numTables].Address  = header;

        } else {

            //
            // If we have found an override, we don't need the dummy table
            //
            ExFreePool( header );

        }

    }
    //
    // Save whatever tables we found in the registry
    //
    ACPIRegDumpAcpiTables ();

    //
    // Did we find an FADT?
    //
    if (!foundFADT) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadProcessRSDT: Did not find an FADT\n"
            ) );
        return STATUS_ACPI_INVALID_TABLE;

    }

    return STATUS_SUCCESS;
}

BOOLEAN
ACPILoadTableCheckSum(
    PVOID   StartAddress,
    ULONG   Length
    )
{
    PUCHAR  currentAddress;
    UCHAR   sum = 0;
    ULONG   i;

    PAGED_CODE();
    ASSERT (Length > 0);

    currentAddress = (PUCHAR)StartAddress;

    ACPIPrint( (
        ACPI_PRINT_LOADING,
        "ACPILoadTableCheckSum: Checking table 0x%p to 0x%p\n",
        StartAddress, (ULONG_PTR)StartAddress + Length - 1
        ) );

    for (i = 0; i < Length; i++, currentAddress++ ) {

        sum += *currentAddress;

    }

    ACPISimpleSoftwareAssert ( (sum == 0), ACPI_ERROR_INT_BAD_TABLE_CHECKSUM );

    if (sum) {

        ACPIPrint( (
            ACPI_PRINT_CRITICAL,
            "ACPILoadTableCheckSum: Checksum Failed!, table %p to %p\n",
            StartAddress, (ULONG_PTR) StartAddress + Length - 1
            ) );
        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\acpiec.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    acpiec.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

    Kernel mode

Notes:


Revision History:
    13-Feb-97
        PnP/Power support - Bob Moore

--*/

#include "ecp.h"


//
// List of FDOs managed by this driver
//
PDEVICE_OBJECT  FdoList = NULL;

#if DEBUG
ULONG           ECDebug = EC_ERRORS;
#endif


//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );


NTSTATUS
AcpiEcPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
AcpiEcPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

//
// ReadWrite and PowerDispatch should stay resident
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,AcpiEcUnload)
#pragma alloc_text(PAGE,AcpiEcOpenClose)
#pragma alloc_text(PAGE,AcpiEcInternalControl)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{

    //
    // Set up the device driver entry points.
    //

#if DEBUG
    // Security: Can only open file handles in debug builds
    DriverObject->MajorFunction[IRP_MJ_CREATE]  = AcpiEcOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = AcpiEcOpenClose;
#endif
    DriverObject->MajorFunction[IRP_MJ_READ]    = AcpiEcReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]   = AcpiEcReadWrite;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = AcpiEcPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]     = AcpiEcPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AcpiEcForwardRequest;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = AcpiEcInternalControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AcpiEcForwardRequest;
    DriverObject->DriverExtension->AddDevice    = AcpiEcAddDevice;
    DriverObject->DriverUnload                  = AcpiEcUnload;

    return STATUS_SUCCESS;
}


VOID
AcpiEcUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine unloads the ACPI Embedded Controller Driver
    Note: The driver should be already disconnected from the GPE by this time.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    None.

--*/
{
    PVOID           LockPtr;
    KIRQL           OldIrql;
    PECDATA         EcData;

    EcPrint(EC_LOW, ("AcpiEcUnload: Entering\n" ));

    LockPtr = MmLockPagableCodeSection(AcpiEcUnload);

    while (DriverObject->DeviceObject) {

        EcData = DriverObject->DeviceObject->DeviceExtension;

        //
        // Device can only be active if initialization was completed
        //

        if (EcData->IsStarted) {

            //
            // Set state to determine when unload can occur, and issue a device service
            // call to get it unloaded now of the device is idle
            //

            ASSERT (EcData->DeviceState == EC_DEVICE_WORKING);
            EcData->DeviceState = EC_DEVICE_UNLOAD_PENDING;
            AcpiEcServiceDevice (EcData);

            //
            // Wait for device to cleanup
            //

            while (EcData->DeviceState != EC_DEVICE_UNLOAD_COMPLETE) {
                KeWaitForSingleObject (&EcData->Unload, Suspended, KernelMode, FALSE, NULL);
            }
        }

        //
        // Make sure caller signalling the unload is done
        //

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);
        KeReleaseSpinLock (&EcData->Lock, OldIrql);

        //
        // Free resources
        //

        IoFreeIrp (EcData->QueryRequest);
        IoFreeIrp (EcData->MiscRequest);

        if (EcData->VectorTable) {
            ExFreePool (EcData->VectorTable);
        }

        IoDeleteDevice (EcData->DeviceObject);
    }

    //
    // Done
    //

    MmUnlockPagableImageSection(LockPtr);

    EcPrint(EC_LOW, ("AcpiEcUnload: Driver Unloaded\n"));
}


NTSTATUS
AcpiEcOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}


NTSTATUS
AcpiEcReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for read & write requests.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PECDATA             EcData;
    KIRQL               OldIrql;
    BOOLEAN             StartIo;
    NTSTATUS            Status;
#if DEBUG
    UCHAR               i;
#endif


    Status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = Status;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

#if !DEBUG
    //
    // Security: Refuse any request sent from user mode (except on debug builds)
    //

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Status = Status;
    } else
#endif    
           if (irpSp->Parameters.Read.ByteOffset.HighPart ||
        irpSp->Parameters.Read.ByteOffset.LowPart > 255 ||
        irpSp->Parameters.Read.ByteOffset.LowPart + irpSp->Parameters.Read.Length > 256) {
        //
        // Verify offset is within Embedded Controller range
        //


        Status = STATUS_END_OF_FILE;
        Irp->IoStatus.Status = Status;

    } else {

        //
        // Queue the transfer up
        //

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);

        if (EcData->DeviceState > EC_DEVICE_UNLOAD_PENDING) {
            //
            // Device is unloading
            //

            Status = STATUS_NO_SUCH_DEVICE;
            Irp->IoStatus.Status = Status;

        } else {

#if DEBUG
            if ((irpSp->MajorFunction == IRP_MJ_WRITE) && (ECDebug & EC_TRANSACTION)) {
                EcPrint (EC_TRANSACTION, ("AcpiEcReadWrite: Write ("));
                for (i=0; i < irpSp->Parameters.Write.Length; i++) {
                    EcPrint (EC_TRANSACTION, ("%02x ", 
                                              ((PUCHAR)Irp->AssociatedIrp.SystemBuffer) [i]));

                }
                EcPrint (EC_TRANSACTION, (") to %02x length %02x\n", 
                                          (UCHAR)irpSp->Parameters.Write.ByteOffset.LowPart,
                                          (UCHAR)irpSp->Parameters.Write.Length));
            }
#endif
            Status = STATUS_PENDING;
            Irp->IoStatus.Status = Status;
            IoMarkIrpPending (Irp);
            InsertTailList (&EcData->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            StartIo = DeviceObject->CurrentIrp == NULL;
            AcpiEcLogAction (EcData, EC_ACTION_QUEUED_IO, StartIo);
        }

        KeReleaseSpinLock (&EcData->Lock, OldIrql);

    }

    //
    // Handle status
    //

    if (Status == STATUS_PENDING) {

        //
        // IO is queued, if device is not busy start it
        //

        if (StartIo) {
            AcpiEcServiceDevice (EcData);
        }

    } else {
        
        //
        // For opregion requests, there is no way to fail the request, so return -1
        //

        RtlFillMemory (Irp->AssociatedIrp.SystemBuffer, irpSp->Parameters.Read.Length, 0xff);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}


NTSTATUS
AcpiEcPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS    status;
    PECDATA     ecData = DeviceObject->DeviceExtension;

    //
    // Start the next power irp
    //
    PoStartNextPowerIrp( Irp );

    //
    // Handle the irp
    //
    if (ecData->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( ecData->LowerDeviceObject, Irp );

    } else {

        //
        // Complete irp with the current code;
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


NTSTATUS
AcpiEcInternalControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Internal IOCTL dispatch routine


Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PECDATA             EcData;
    NTSTATUS            Status;

    PAGED_CODE();

    Status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

    EcPrint (EC_NOTE, ("AcpiEcInternalControl: dispatch, code = %d\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode));

    Status = STATUS_INVALID_PARAMETER;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case EC_CONNECT_QUERY_HANDLER:
            Status = AcpiEcConnectHandler (EcData, Irp);
            break;

        case EC_DISCONNECT_QUERY_HANDLER:
            Status = AcpiEcDisconnectHandler (EcData, Irp);
            break;
    }

    if (Status != STATUS_PENDING) {

        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;

}


NTSTATUS
AcpiEcForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards the irp down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PECDATA     ecData = DeviceObject->DeviceExtension;

    if (ecData->LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( ecData->LowerDeviceObject, Irp );

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\ecp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ecp.h

Abstract:

    Header file for ACPI EC Driver

Author:

Environment:

    NT Kernel Model Driver only

--*/

#include <wdm.h>
#include <ec.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <acpimsft.h>
#include "errlog.h"

//
// Debugging
//
#define DEBUG DBG

#if DEBUG
    extern ULONG            ECDebug;

    #define EcPrint(l,m)    if(l & ECDebug) DbgPrint m
#else
    #define EcPrint(l,m)
#endif

#define EC_LOW          0x00000010
#define EC_NOTE         0x00000001
#define EC_WARN         0x00000002
#define EC_ERROR        0x00000004
#define EC_ERRORS       (EC_ERROR | EC_WARN)
#define EC_HANDLER      0x00000020
#define EC_IO           0x00000040
#define EC_OPREGION     0x00000080
#define EC_QUERY        0x00000200
#define EC_TRACE        0x00000400
#define EC_TRANSACTION  0x00000800

//
// Control methods used by EC
//
#define CM_GPE_METHOD   (ULONG) ('EPG_')    // control method "_GPE"

//
// Misc
//
extern ACPI_INTERFACE_STANDARD     AcpiInterfaces;

#define MAX_QUERY           255
#define BITS_PER_ULONG      (sizeof(ULONG)*8)
#define EVTBITS             ((MAX_QUERY+1)/BITS_PER_ULONG)

extern LARGE_INTEGER        AcpiEcWatchdogTimeout;

//
// Query vector
//
typedef struct {
    UCHAR               Next;
    UCHAR               Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;
} VECTOR_TABLE, *PVECTOR_TABLE;

//
// EC configuration information structure contains information
// about the embedded controller attached and its configuration.
//

typedef struct _ACPIEC_CONFIGURATION_INFORMATION {
    INTERFACE_TYPE                 InterfaceType;
    ULONG                          BusNumber;
    ULONG                          SlotNumber;
    PHYSICAL_ADDRESS               PortAddress;
    USHORT                         PortSize;
    USHORT                         UntranslatedPortAddress;
    CM_PARTIAL_RESOURCE_DESCRIPTOR Interrupt;
    //
    // For PCI-based controllers, indicates the pin number which we need
    // for programming the controller interrupt
    //
    UCHAR                          InterruptPin;
    BOOLEAN                        FloatingSave;
} ACPIEC_CONFIGURATION_INFORMATION, *PACPIEC_CONFIGURATION_INFORMATION;

//
// Definitions for keeping track of the last x actions taken by the EC driver.
//

#define ACPIEC_ACTION_COUNT 0x20
#define ACPIEC_ACTION_COUNT_MASK 0x1f

typedef struct {
    UCHAR               IoStateAction;  // EcData->IoState | EC_ACTION_???? (see definitions below)
    UCHAR               Data;           // Depends on event
    USHORT              Time;           // Delta time of first event of identical events
} ACPIEC_ACTION, *PACPIEC_ACTION;

#define EC_ACTION_MASK          0xf0

#define EC_ACTION_READ_STATUS   0x10
#define EC_ACTION_READ_DATA     0x20
#define EC_ACTION_WRITE_CMD     0x30
#define EC_ACTION_WRITE_DATA    0x40
#define EC_ACTION_INTERRUPT     0x50
#define EC_ACTION_DISABLE_GPE   0x60
#define EC_ACTION_ENABLE_GPE    0x70
#define EC_ACTION_CLEAR_GPE     0x80
#define EC_ACTION_QUEUED_IO     0x90
#define EC_ACTION_REPEATED      0xa0
#define EC_ACTION_MAX           0xb0


//
// ACPI Embedded Control Device object extenstion
//

typedef struct {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      NextFdo;
    PDEVICE_OBJECT      Pdo;                //Pdo corresponding to this fdo
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Static device information
    //

    PUCHAR              DataPort;           // EC Data port
    PUCHAR              StatusPort;         // EC Status port
    PUCHAR              CommandPort;        // EC Command port
    ULONG               MaxBurstStall;      // Max delay for EC reponse in burst mode
    ULONG               MaxNonBurstStall;   // Max delay for EC otherwise
    BOOLEAN             IsStarted;

    //
    // Gpe and Operation Region info
    //

    PVOID               EnableGpe;
    PVOID               DisableGpe;
    PVOID               ClearGpeStatus;
    PVOID               GpeVectorObject;        // Object representing attachment to the EC GPE vector
    ULONG               GpeVector;              // GPE vector assigned to the EC device

    PVOID               OperationRegionObject;  // Attachment to the EC operation region


    ACPIEC_CONFIGURATION_INFORMATION Configuration;

    //
    // Lock for device data
    //

    KSPIN_LOCK          Lock;               // Lock device data

    //
    // Device maintenance
    //

    KEVENT              Unload;             // Event to wait of for unload
    UCHAR               DeviceState;

    //
    // Query/vector operations
    //

    UCHAR               QueryState;
    UCHAR               VectorState;

    ULONG               QuerySet[EVTBITS];      // If pending or not
    ULONG               QueryType[EVTBITS];     // Type of Query or Vector
    PIRP                QueryRequest;           // IRP to execute query methods
    UCHAR               QueryMap[MAX_QUERY+1];  // Query pending list and vector table map
    UCHAR               QueryHead;              // List of pending queries
    UCHAR               VectorHead;             // List of pending vectors
    UCHAR               VectorFree;             // List of free vectors entries
    UCHAR               VectorTableSize;        // Sizeof vector table
    PVECTOR_TABLE       VectorTable;

    //
    // Device's work queue (owned by Lock owner)
    //

    BOOLEAN             InService;          // Serialize in service
    BOOLEAN             InServiceLoop;      // Flag when in service needs to loop
    BOOLEAN             InterruptEnabled;   // Masked or not
    LIST_ENTRY          WorkQueue;          // Queued IO IRPs to the device
    PIRP                MiscRequest;        // IRP for start/stop device

    //
    // Data IO (owned by InService owner)
    //

    UCHAR               IoState;            // Io state
    UCHAR               IoBurstState;       // Pushed state for burst enable
    UCHAR               IoTransferMode;     // read or write transfer

    UCHAR               IoAddress;          // Address in EC for transfer
    UCHAR               IoLength;           // Length of transfer
    UCHAR               IoRemain;           // Length remaining of transfer
    PUCHAR              IoBuffer;           // RAM location for transfer

    //
    // Watchdog Timer to catch hung and/or malfunctioning ECs
    //
    
    UCHAR               ConsecutiveFailures;// Count how many times watdog fired without making progress.
    UCHAR               LastAction;         // Index into RecentActions array.
    LARGE_INTEGER       PerformanceFrequency;
    KTIMER              WatchdogTimer;
    KDPC                WatchdogDpc;
    ACPIEC_ACTION       RecentActions [ACPIEC_ACTION_COUNT];

    //
    // Stats
    //

    ULONG               NonBurstTimeout;
    ULONG               BurstTimeout;
    ULONG               BurstComplete;
    ULONG               BurstAborted;
    ULONG               TotalBursts;
    ULONG               Errors;
    ULONG               MaxServiceLoop;

} ECDATA, *PECDATA;

//
// DeviceState
//

#define EC_DEVICE_WORKING               0
#define EC_DEVICE_UNLOAD_PENDING        1
#define EC_DEVICE_UNLOAD_CANCEL_TIMER   2
#define EC_DEVICE_UNLOAD_COMPLETE       3

//
// QueryState
//

#define EC_QUERY_IDLE                   0
#define EC_QUERY_DISPATCH               1
#define EC_QUERY_DISPATCH_WAITING       2
#define EC_QUERY_DISPATCH_COMPLETE      3

//
// Embedded Control read state
//

#define EC_IO_NONE              0           // Idle
#define EC_IO_READ_BYTE         1           // Read byte on OBF
#define EC_IO_READ_QUERY        2           // Query response on OBF
#define EC_IO_BURST_ACK         3           // Brust ACK on OBF
#define EC_IO_WRITE_BYTE        4           // Write byte on IBE
#define EC_IO_NEXT_BYTE         5           // Issue read/write on IBE
#define EC_IO_SEND_ADDRESS      6           // Send transfer address on IBE
#define EC_IO_UNKNOWN           7

//
// Status port definitions
//

#define EC_OUTPUT_FULL      0x01            // Output buffer full (data from EC to Host)
#define EC_INPUT_FULL       0x02            // Input buffer full (data from Host to EC)
#define EC_BURST            0x10            // In burst transfer
#define EC_QEVT_PENDING     0x20            // Query event is pending
#define EC_BUSY             0x80            // Device is busy

//
// Embedded controller commands
//

#define EC_READ_BYTE        0x80
#define EC_WRITE_BYTE       0x81
#define EC_BURST_TRANSFER   0x82
#define EC_CANCEL_BURST     0x83
#define EC_QUERY_EVENT      0x84

//
// Prototypes
//

NTSTATUS
AcpiEcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
AcpiEcNewEc (
    IN PDEVICE_OBJECT       Fdo
    );

NTSTATUS
AcpiEcOpenClose(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcReadWrite(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcInternalControl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
AcpiEcUnload(
    IN PDRIVER_OBJECT       DriverObject
    );


BOOLEAN
AcpiEcGpeServiceRoutine (
        IN PVOID                GpeVectorObject,
        IN PVOID                ServiceContext
    );

VOID
AcpiEcServiceDevice (
    IN PECDATA              EcData
    );

VOID
AcpiEcDispatchQueries (
    IN PECDATA              EcData
    );

VOID
AcpiEcUnloadPending (
    IN PECDATA              EcData
    );


NTSTATUS
AcpiEcConnectHandler (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcDisconnectHandler (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );


NTSTATUS
AcpiEcGetPdo (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS EXPORT
AcpiEcOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
AcpiEcGetAcpiInterfaces (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcGetGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcConnectGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcDisconnectGpeVector (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcInstallOpRegionHandler (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcRemoveOpRegionHandler (
    IN PECDATA              EcData
    );

NTSTATUS
AcpiEcForwardIrpAndWait (
    IN PECDATA              EcData,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
AcpiEcStartDevice(
    IN PDEVICE_OBJECT       Fdo,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcStopDevice(
    IN PDEVICE_OBJECT       Fdo,
    IN PIRP                 Irp
    );

NTSTATUS
AcpiEcCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    OUT PDEVICE_OBJECT      *NewDeviceObject
    );

VOID
AcpiEcServiceIoLoop (
    IN PECDATA              EcData
    );

VOID
AcpiEcDispatchQueries (
    IN PECDATA              EcData
    );

VOID
AcpiEcWatchdogDpc(
    IN PKDPC   Dpc,
    IN PECDATA EcData,
    IN PVOID   SystemArgument1,
    IN PVOID   SystemArgument2
    );

VOID
AcpiEcLogAction (
    PECDATA EcData, 
    UCHAR Action, 
    UCHAR Data
    );

VOID
AcpiEcLogError (
    PECDATA EcData, 
    NTSTATUS ErrCode
    );
//
// Io extension macro to just pass on the Irp to a lower driver
//
#define AcpiEcCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\driver\shared\reg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reg.h

Abstract:

    These functions access the registry

Author:

    Jason Clark (jasoncl)
    Stephane Plante (splante)

Environment:

    Kernel mode only.

Revision History:

    03-Jun-97   Initial Revision

--*/

#ifndef _REG_H_
#define _REG_H_

    PUCHAR
    ACPIRegLocalCopyString(
        IN  PUCHAR  Destination,
        IN  PUCHAR  Source,
        IN  ULONG   MaxLength
        );

    VOID
    ACPIRegDumpAcpiTable (
        PSZ                     pszName,
        PVOID                   Table,
        ULONG                   Length,
        PDESCRIPTION_HEADER     Header
        );

    VOID
    ACPIRegDumpAcpiTables(
        VOID
        );

    NTSTATUS
    ACPIRegReadEntireAcpiTable (
        IN  HANDLE  RevisionKey,
        IN  PVOID   *Table,
        IN  BOOLEAN MemoryMapped
        );

    BOOLEAN
    ACPIRegReadAMLRegistryEntry(
        IN  PVOID   *Table,
        IN  BOOLEAN Memorymapped
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\eclowio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eclowio.c

Abstract:

    Interface module to ACPI driver functions.  It encapsulates the grungy Irp details.

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

    00-Feb-15 [vincentg] - modified to use oprghdlr.sys to register/deregister
                           op region handler

--*/

#include "ecp.h"
#include "oprghdlr.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcpiEcGetAcpiInterfaces)
#pragma alloc_text(PAGE, AcpiEcGetGpeVector)
#pragma alloc_text(PAGE, AcpiEcInstallOpRegionHandler)
#pragma alloc_text(PAGE, AcpiEcRemoveOpRegionHandler)
#endif

NTSTATUS
AcpiEcGetAcpiInterfaces (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    //
    // Initialize an event to block on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build an irp
    //
    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        EcData->LowerDeviceObject,
        NULL,
        0,
        NULL,
        &event,
        &ioStatus
        );

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Get the the current irp location
    //
    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Use QUERY_INTERFACE to get the address of the direct-call
    // ACPI interfaces.
    //
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    irpSp->Parameters.QueryInterface.Version                = 1;
    irpSp->Parameters.QueryInterface.Size                   = sizeof (AcpiInterfaces);
    irpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &AcpiInterfaces;
    irpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // send the request down
    //
    status = IoCallDriver( EcData->LowerDeviceObject, irp );
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
        status = ioStatus.Status;

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcGetGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Run the _GPE method (Under the EC device in the namespace) to get the
    GPE vector assigned to the EC.

    Note: This routine is called at PASSIVE_LEVEL

Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    //
    // Initialize the event
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Initialize the input buffer
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = CM_GPE_METHOD;

    //
    // Initialize the output buffer
    //
    RtlZeroMemory( &outputBuffer, sizeof(ACPI_EVAL_OUTPUT_BUFFER ) );

    //
    // Initialize an IRP
    //
    irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_EVAL_METHOD,
        EcData->LowerDeviceObject,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        &outputBuffer,
        sizeof(ACPI_EVAL_OUTPUT_BUFFER),
        FALSE,
        &event,
        &ioStatus
        );

    //
    // Irp initialization failed?
    //
    if (!irp) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Send to ACPI driver
    //
    status = IoCallDriver (EcData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );

        //
        // Get the real status
        //
        status = ioStatus.Status;

    }

    //
    // Did we fail the request?
    //
    if (!NT_SUCCESS(status)) {

        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Sanity checks
    //
    ASSERT( ioStatus.Information >= sizeof(ACPI_EVAL_OUTPUT_BUFFER) );
    if (ioStatus.Information < sizeof(ACPI_EVAL_OUTPUT_BUFFER) ||
        outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0) {

        status = STATUS_UNSUCCESSFUL;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Crack the result
    //
    argument = &(outputBuffer.Argument[0]);

    //
    // We are expecting an integer
    //
    if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        status = STATUS_ACPI_INVALID_DATA;
        goto AcpiEcGetGpeVectorExit;

    }

    //
    // Get the value
    //
    EcData->GpeVector  = (UCHAR) argument->Argument;

AcpiEcGetGpeVectorExit:

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcConnectGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to connect the EC driver to a GPE vector


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{

    return (AcpiInterfaces.GpeConnectVector (
                AcpiInterfaces.Context,
                EcData->GpeVector,
                Latched,                            // Edge triggered
                FALSE,                              // Can't be shared
                AcpiEcGpeServiceRoutine,
                EcData,
                &EcData->GpeVectorObject));

}

NTSTATUS
AcpiEcDisconnectGpeVector (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to disconnect the EC driver from a GPE vector.  Called
    from device unload, stop.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS        status;

    if (EcData->GpeVectorObject) {

        status = AcpiInterfaces.GpeDisconnectVector (EcData->GpeVectorObject);
        EcData->GpeVectorObject = NULL;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;

}

NTSTATUS
AcpiEcInstallOpRegionHandler(
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to install the EC driver operation region handler


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();

    status = RegisterOpRegionHandler (EcData->LowerDeviceObject,
                                      ACPI_OPREGION_ACCESS_AS_COOKED,
                                      ACPI_OPREGION_REGION_SPACE_EC,
                                      (PACPI_OP_REGION_HANDLER) AcpiEcOpRegionHandler,
                                      EcData,
                                      0,
                                      &EcData->OperationRegionObject);
    return status;
}

NTSTATUS
AcpiEcRemoveOpRegionHandler (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    Call ACPI driver to remove the EC driver operation region handler.
    Called from device unload, stop.


Arguments:

    EcData          - Pointer to the EC driver device extension

Return Value:

    Status is returned.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();

    status = DeRegisterOpRegionHandler (EcData->LowerDeviceObject,
                                        EcData->OperationRegionObject);


    return status;
}

NTSTATUS
AcpiEcForwardIrpAndWait (
    IN PECDATA          EcData,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Utility routine to send an irp down, and wait for the result.


Arguments:

    EcData          - Pointer to the EC driver device extension
    Irp             - Irp to send and complete

Return Value:

    Status is returned.

--*/
{
    KEVENT              pdoStartedEvent;
    NTSTATUS            status;


    KeInitializeEvent (&pdoStartedEvent, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp, AcpiEcIoCompletion, &pdoStartedEvent,
                            TRUE, TRUE, TRUE);

    //
    // Always wait for the completion routine
    //

    status = IoCallDriver (EcData->LowerDeviceObject, Irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject (&pdoStartedEvent, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\service.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    service.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ecp.h"

#define NTMS                10000L          // 1 millisecond is ten thousand 100ns
#define NTSEC               (NTMS * 1000L)
LARGE_INTEGER   AcpiEcWatchdogTimeout = {(NTSEC * -5L), -1};
LARGE_INTEGER   AcpiEcLastActionTime = {0,0};

PUCHAR AcpiEcActionDescription [EC_ACTION_MAX >> 4] = {
    "Invalid    ",
    "Read Status",
    "Read Data  ",
    "Write Cmd  ",
    "Write Data ",
    "Interrupt  ",
    "Disable GPE",
    "Enable GPE ",
    "Clear GPE  ",
    "Queued IO  ",
    "Repeated Last action this many times:"
};


VOID
AcpiEcServiceDevice (
    IN PECDATA          EcData
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    None

--*/
{
    KIRQL               OldIrql;

    //
    // Even though the device is unloaded, there might still be a
    // service call which occurs until the timer is canceled
    //

    EcPrint(EC_TRACE, ("AcpiEcServiceDevice.\n"));

    if (EcData->DeviceState > EC_DEVICE_UNLOAD_PENDING) {
        return;
    }

    //
    // Acquire device lock and signal function was entered
    //

    KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    EcData->InServiceLoop = TRUE;

    //
    // If not already in service, enter InService
    //

    if (!EcData->InService) {
        EcData->InService = TRUE;

        //
        // Disable the device's interrupt
        //

        if (EcData->InterruptEnabled) {
            EcData->InterruptEnabled = FALSE;

            //
            // Call ACPI to disable the device's interrupt
            //
            AcpiEcLogAction (EcData, EC_ACTION_DISABLE_GPE, 0);
            AcpiInterfaces.GpeDisableEvent (AcpiInterfaces.Context,
                                            EcData->GpeVectorObject);
        }

        //
        // While service invocation pending, loop
        //

        while (EcData->InServiceLoop) {
            EcData->InServiceLoop = FALSE;

            KeReleaseSpinLock (&EcData->Lock, OldIrql);

            //
            // Dispatch service handler
            //

            AcpiEcServiceIoLoop (EcData);

            //
            // Loop and re-service
            //

            KeAcquireSpinLock (&EcData->Lock, &OldIrql);

        }

        //
        // No longer in service loop
        //

        EcData->InService = FALSE;

        //
        // If unload is pending, check to see if the device can be unloaded now
        //

        if (EcData->DeviceState > EC_DEVICE_WORKING) {
            AcpiEcUnloadPending (EcData);
        }

        //
        // Enable the device's interrupt
        //

        if (!EcData->InterruptEnabled) {
            EcData->InterruptEnabled = TRUE;

            //
            // Call ACPI to enable the device's interrupt
            //
            AcpiEcLogAction (EcData, EC_ACTION_ENABLE_GPE, 0);
            AcpiInterfaces.GpeEnableEvent (AcpiInterfaces.Context,
                                            EcData->GpeVectorObject);
        }
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
}

VOID
AcpiEcServiceIoLoop (
    IN PECDATA      EcData
    )
/*++

Routine Description:

    Main embedded controller device service loop.  Services EC events,
    and processes IO queue.  Terminate when the controller is busy (e.g.,
    wait for interrupt to continue) or when all servicing has been completed.

    N.B. Caller must be the owner of the device InService flag

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    none

--*/
{
    PIO_STACK_LOCATION  IrpSp;
    PLIST_ENTRY         Link;
    PIRP                Irp;
    PUCHAR              WritePort;
    UCHAR               WriteData;
    UCHAR               Status;
    UCHAR               Data;
    BOOLEAN             EcBusy;
    BOOLEAN             BurstEnabled;
    BOOLEAN             ProcessQuery;
    ULONG               NoWorkStall;
    ULONG               StallAccumulator;
    PULONG              Timeout;
    KIRQL               OldIrql;
    LIST_ENTRY          CompleteQueue;
    ULONG               i, j;


    //
    // EcBusy flags that there may be work to do.  Initialized to TRUE every time
    // The service loop is entered, or when a timeout almost occured, but then some 
    // work was found.  It is set to FALSE when the IO queue is empty and there are 
    // no query events pending.
    //
    EcBusy = TRUE;

    //
    // Timeout points to the counter to be incremented as the loop exits.  It is 
    // also used as a flag to indicate that the loop should exit.  The loop won't
    // exit until Timeout != NULL.  When exiting because of idleness, it is set
    // to the local vailable i, so that we don't keep a permanent count of those 
    // timeout conditions.  We keep track of how many time we timeout waiting for
    // the EC.  If we do, we expect an interrupt when the EC is ready.
    //
    Timeout = NULL;

    //
    // This is set (along with WriteData) to have write a command or data to the 
    // EC at the appropriate point in the loop.
    //
    WritePort = NULL;

    //
    // NoWorkStall is incremented every time through the loop.  It is reset to 0
    // whenever any work is done.  If it gets too big, Timeout is set.  If it 
    // then gets cleared before the loop actually exits, Timeout is Cleared.
    //
    NoWorkStall = 0;
    
    //
    // BurstEnable keeps trakc of whethe we think Burst Mode is enabled.  If 
    // Burst Mode gets disabled automatically by the EC, we know that and pretend
    // that burst mode is enabled so that the driver can make forward progress.
    //
    BurstEnabled = FALSE;
    
    //
    // ProcessQuery is set if we need to go run some _Qxx methods as the loop exits.
    //
    ProcessQuery = FALSE;
    
    //
    // StallAccumulator counts how many ticks we've stalled for using 
    // KeStallExecutionProcessor during one complete run of the service loop.
    //
    StallAccumulator = 0;

    EcPrint(EC_TRACE, ("AcpiEcServiceIoLoop.\n"));

    InitializeListHead (&CompleteQueue);

    //
    // Loop while busy
    //

    for (; ;) {

        //
        // If there's outgoing data write it, issue the device required
        // stall and indicate work is being done (clear noworkstall)
        //

        if (WritePort) {
            EcPrint(EC_IO, ("AcpiEcServiceIO: Write = %x at %x\n", WriteData, WritePort));
            AcpiEcLogAction (EcData, 
                             (WritePort == EcData->CommandPort) ? 
                                    EC_ACTION_WRITE_CMD : EC_ACTION_WRITE_DATA, 
                             WriteData);
            WRITE_PORT_UCHAR (WritePort, WriteData);
            KeStallExecutionProcessor (1);
            StallAccumulator += 1;
            WritePort = NULL;
            NoWorkStall = 0;        // work was done
        }

        //
        // If work was done, clear pending timeout condition if it exists to
        // continue servicing the device
        //

        if (NoWorkStall == 0  &&  Timeout) {
            Timeout = NULL;
            EcBusy = TRUE;
        }

        //
        // If NoWorkStall is non-zero, then no work was performed.  Determine
        // if the type of delay to issue while waiting (spinning) for the device
        //

        if (NoWorkStall) {

            //
            // No work was done the last time around.
            // If its time to timeout, exit the service loop.
            //

            if (Timeout) {
                break;
            }

            //
            // If device is idle, setup as if a timeout is occuring.  This
            // will acquire the device lock, clear the gpe sts bit and terminate
            // the service loop (or if the device is now busy, continue)
            //

            if (!EcBusy) {

                if (Status & EC_BURST) {
                    //
                    // Before exiting, clear burst mode for embedded controller.
                    // Has no response, no need to wait for EC to read it.
                    //

                    EcPrint (EC_IO, ("AcpiEcServiceIO: Clear Burst mode - Write = %x at %x\n", EC_CANCEL_BURST, EcData->CommandPort));
                    AcpiEcLogAction (EcData, EC_ACTION_WRITE_CMD, EC_CANCEL_BURST);
                    WRITE_PORT_UCHAR (EcData->CommandPort, EC_CANCEL_BURST);
                    Timeout = &EcData->BurstComplete;

                } else {

                    Timeout = &i;

                }

            } else {

                //
                // Interject stalls while spinning on device
                //

                StallAccumulator += NoWorkStall;
                KeStallExecutionProcessor (NoWorkStall);

                //
                // If wait is over the limit, prepare for a timeout.
                //

                if (!(Status & EC_BURST)) {
                    if (NoWorkStall >= EcData->MaxNonBurstStall) {
                        Timeout = &EcData->NonBurstTimeout;
                    }
                } else {
                    if (NoWorkStall >= EcData->MaxBurstStall) {
                        Timeout = &EcData->BurstTimeout;
                    }
                }
            }

            if (Timeout) {

                //
                // Over time limit, clear the GPE status bit
                //
                AcpiEcLogAction (EcData, EC_ACTION_CLEAR_GPE, 0);
                AcpiInterfaces.GpeClearStatus (AcpiInterfaces.Context,
                                                EcData->GpeVectorObject);
            }
        }


        //
        // Increase stall time and indicate no work was done
        //

        NoWorkStall += 1;

        //
        // Check Status
        //

        Status = READ_PORT_UCHAR (EcData->StatusPort);
        AcpiEcLogAction (EcData, EC_ACTION_READ_STATUS, Status);
        EcPrint(EC_IO, ("AcpiEcServiceIO: Status Read = %x at %x\n", Status, EcData->StatusPort));

        //
        // Keep bursts dropped by the EC stat
        //

        if (BurstEnabled && !(Status & EC_BURST)) {
            EcData->BurstAborted += 1;
            BurstEnabled = FALSE;
            Status |= EC_BURST;     // move one char
        }

        //
        // If Embedded controller has data for us, process it
        //

        if (Status & EC_OUTPUT_FULL) {

            Data = READ_PORT_UCHAR (EcData->DataPort);
            AcpiEcLogAction (EcData, EC_ACTION_READ_DATA, Data);
            EcPrint(EC_IO, ("AcpiEcServiceIO: Data Read = %x at %x\n", Data, EcData->DataPort));

            switch (EcData->IoState) {

                case EC_IO_READ_QUERY:
                    //
                    // Response to a read query.  Get the query value and set it
                    //

                    EcPrint(EC_NOTE, ("AcpiEcServiceIO: Query %x\n", Data));

                    if (Data) {
                        //
                        // If not set, set pending bit
                        //

                        KeAcquireSpinLock (&EcData->Lock, &OldIrql);

                        i = Data / BITS_PER_ULONG;
                        j = 1 << (Data % BITS_PER_ULONG);
                        if (!(EcData->QuerySet[i] & j)) {
                            EcData->QuerySet[i] |= j;

                            //
                            // Queue the query or vector operation
                            //

                            if (EcData->QueryType[i] & j) {
                                //
                                // This is a vector, put it in the vector pending list
                                //

                                Data = EcData->QueryMap[Data];
                                EcData->VectorTable[Data].Next = EcData->VectorHead;
                                EcData->VectorHead = Data;

                            } else {
                                //
                                // This is a query, put in in the query pending list
                                //

                                EcData->QueryMap[Data] = EcData->QueryHead;
                                EcData->QueryHead = Data;
                            }
                        }

                        KeReleaseSpinLock (&EcData->Lock, OldIrql);
                        ProcessQuery = TRUE;
                    }

                    EcData->IoState = EC_IO_NONE;
                    
                    break;

                case EC_IO_READ_BYTE:
                    //
                    // Read transfer. Read the data byte
                    //

                    *EcData->IoBuffer = Data;
                    EcData->IoState   = EC_IO_NEXT_BYTE;

                    break;

                case EC_IO_BURST_ACK:
                    //
                    // Burst ACK byte
                    //

                    EcData->IoState      = EcData->IoBurstState;
                    EcData->IoBurstState = EC_IO_UNKNOWN;
                    EcData->TotalBursts += 1;
                    BurstEnabled = TRUE;
                    break;

                default:
                    EcPrint(EC_ERROR,
                            ("AcpiEcService: Spurious data received State = %x, Data = %x\n",
                             EcData->IoState, Data)
                          );
                    if( EcData->Errors < 5 ) {
                        AcpiEcLogError (EcData, ACPIEC_ERR_SPURIOUS_DATA);
                    }

                    EcData->Errors += 1;
                    break;
            }

            NoWorkStall = 0;
            continue;
        }

        if (Status & EC_INPUT_FULL) {
            //
            // The embedded controllers input buffer is full, wait
            //

            continue;
        }

        //
        // Embedded controller is ready to receive data, see if anything
        // is already being sent
        //

        switch (EcData->IoState) {

            case EC_IO_NEXT_BYTE:
                //
                // Data transfer.
                //

                if (EcData->IoRemain) {

                    if (!(Status & EC_BURST)) {
                        //
                        // Not in burst mode.  Write burst mode command
                        //

                        EcData->IoState      = EC_IO_BURST_ACK;
                        EcData->IoBurstState = EC_IO_NEXT_BYTE;

                        WritePort = EcData->CommandPort;
                        WriteData = EC_BURST_TRANSFER;

                    } else {
                        //
                        // Send command to transfer next byte
                        //

                        EcData->IoBuffer  += 1;
                        EcData->IoAddress += 1;
                        EcData->IoRemain  -= 1;
                        EcData->IoState   = EC_IO_SEND_ADDRESS;

                        WritePort = EcData->CommandPort;
                        WriteData = EcData->IoTransferMode;
                    }

                } else {
                    //
                    // Transfer complete
                    //

                    EcData->IoState  = EC_IO_NONE;
                    EcData->IoRemain = 0;

                    Irp = EcData->DeviceObject->CurrentIrp;
                    EcData->DeviceObject->CurrentIrp = NULL;

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = EcData->IoLength;

                    InsertTailList (&CompleteQueue, &Irp->Tail.Overlay.ListEntry);
                }
                break;

            case EC_IO_SEND_ADDRESS:
                //
                // Send address of transfer request
                //

                WritePort = EcData->DataPort;
                WriteData = EcData->IoAddress;


                //
                // Wait or send data byte next
                //

                if (EcData->IoTransferMode == EC_READ_BYTE) {
                    EcData->IoState = EC_IO_READ_BYTE;
                } else {
                    EcData->IoState = EC_IO_WRITE_BYTE;
                }
                break;

            case EC_IO_WRITE_BYTE:
                //
                // Write transfer - write the data byte
                //

                EcData->IoState = EC_IO_NEXT_BYTE;
                WritePort = EcData->DataPort;
                WriteData = *EcData->IoBuffer;
                break;
        }

        //
        // If something to write, loop and handle it
        //

        if (WritePort) {
            continue;
        }

        //
        // If state is NONE, then nothing is pending see what should be
        // initiated
        //

        if (EcData->IoState == EC_IO_NONE) {

            EcData->ConsecutiveFailures = 0;

            if (Status & EC_QEVT_PENDING) {

                //
                // Embedded Controller has some sort of event pending
                //

                EcPrint(EC_QUERY, ("AcpiEcServiceIO: Received Query Request.\n"));

                EcData->IoState = EC_IO_READ_QUERY;
                WritePort = EcData->CommandPort;
                WriteData = EC_QUERY_EVENT;

                //
                // Reset the watchdog timer
                //
                KeSetTimer (&EcData->WatchdogTimer,
                            AcpiEcWatchdogTimeout,
                            &EcData->WatchdogDpc);
            } else {

                //
                // Get next tranfer from IO queue
                //

                Link = ExInterlockedRemoveHeadList (&EcData->WorkQueue, &EcData->Lock);

                //
                // If there's a transfer initiate it
                //

                if (Link) {

                    EcPrint(EC_HANDLER, ("AcpiEcServiceIO: Got next work item %x\n", Link));

                    Irp = CONTAINING_RECORD (
                                Link,
                                IRP,
                                Tail.Overlay.ListEntry
                                );

                    IrpSp = IoGetCurrentIrpStackLocation(Irp);
                    
                    EcData->DeviceObject->CurrentIrp = Irp;
                    
                    EcData->IoBuffer  = Irp->AssociatedIrp.SystemBuffer;
                    EcData->IoAddress = (UCHAR) IrpSp->Parameters.Read.ByteOffset.LowPart;
                    EcData->IoLength  = (UCHAR) IrpSp->Parameters.Read.Length;
                    EcData->IoTransferMode =
                        IrpSp->MajorFunction == IRP_MJ_READ ? EC_READ_BYTE : EC_WRITE_BYTE;

                    //
                    // Set it up via EC_IO_NEXT_BYTE and back up one byte
                    //

                    EcData->IoBuffer  -= 1;
                    EcData->IoAddress -= 1;
                    EcData->IoRemain  = EcData->IoLength;
                    EcData->IoState   = EC_IO_NEXT_BYTE;

                    NoWorkStall = 0;
                    
                    //
                    // Reset the watchdog timer
                    //
                    KeSetTimer (&EcData->WatchdogTimer,
                                AcpiEcWatchdogTimeout,
                                &EcData->WatchdogDpc);

                } else {

                    //
                    // Nothing but nothing to do.
                    //

                    EcBusy = FALSE;
                    
                    //
                    // Clear the Watchdog timer
                    //
                    KeCancelTimer (&EcData->WatchdogTimer);
                }
            }
        }
    }

    //
    // Keep stat as to why service loop terminated
    //

    *Timeout += 1;

    //
    // Track maximum service loop stall accumulator
    //

    if (StallAccumulator > EcData->MaxServiceLoop) {
        EcData->MaxServiceLoop = StallAccumulator;
    }

    //
    // Complete processed io requests
    //

    while (!IsListEmpty(&CompleteQueue)) {
        Link = RemoveHeadList(&CompleteQueue);
        Irp = CONTAINING_RECORD (
                    Link,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        EcPrint(EC_IO, ("AcpiEcServiceIO: IOComplete: Irp=%Lx\n", Irp));
        
        
        #if DEBUG 
        if (ECDebug & EC_TRANSACTION) {
            IrpSp = IoGetCurrentIrpStackLocation(Irp);
            if (IrpSp->MajorFunction == IRP_MJ_READ) {
                EcPrint (EC_TRANSACTION, ("AcpiEcServiceIO: Read ("));
                for (i=0; i < IrpSp->Parameters.Read.Length; i++) {
                    EcPrint (EC_TRANSACTION, ("%02x ", 
                                              ((PUCHAR)Irp->AssociatedIrp.SystemBuffer) [i]));

                }
                EcPrint (EC_TRANSACTION, (") from %02x length %02x\n", 
                                          (UCHAR)IrpSp->Parameters.Read.ByteOffset.LowPart,
                                          (UCHAR)IrpSp->Parameters.Read.Length));
            }
        }
        #endif

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    //
    // If queries occured, dispatch them
    //

    if (ProcessQuery) {
        AcpiEcDispatchQueries (EcData);
    }
}



VOID
AcpiEcWatchdogDpc(
    IN PKDPC   Dpc,
    IN PECDATA EcData,
    IN PVOID   SystemArgument1,
    IN PVOID   SystemArgument2
    )
/*++

Routine Description:

    Gets called if EC doesn't respond within 5 seconds of request.

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

    None.

--*/
{
    UCHAR               ecStatus;
    PIRP                Irp;
    KIRQL               OldIrql;
#if DEBUG
    UCHAR               i;
#endif


    ecStatus = READ_PORT_UCHAR (EcData->StatusPort);
    AcpiEcLogAction (EcData, EC_ACTION_READ_STATUS, ecStatus);

    if (EcData->ConsecutiveFailures < 255) {
        EcData->ConsecutiveFailures++;
    }

    if (EcData->ConsecutiveFailures <= 5) {
        //
        // Only log an error for the first 5 consecutive failures.  After that just be quiet about it.
        //
        AcpiEcLogError(EcData, ACPIEC_ERR_WATCHDOG);
    }

    EcPrint (EC_ERROR, ("AcpiEcWatchdogDpc: EC error encountered.  \nAction History:\n"
                        "   D time  IoState  Action       Data\n"
                        "   *%3dns\n", (ULONG)(1000000000/EcData->PerformanceFrequency.QuadPart)));
    
#if DEBUG
    i = EcData->LastAction;
    do {
        i++;
        i &= ACPIEC_ACTION_COUNT_MASK;
        
        if ((EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) == 0) {
            continue;
        }

        EcPrint (EC_ERROR, ("   %04x    %01x        %s  0x%02x\n",
                            EcData->RecentActions[i].Time,
                            EcData->RecentActions[i].IoStateAction & ~EC_ACTION_MASK,
                            (EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) < EC_ACTION_MAX ? 
                                AcpiEcActionDescription [(EcData->RecentActions[i].IoStateAction & EC_ACTION_MASK) >> 4] : "",
                            EcData->RecentActions[i].Data));
    } while (i != EcData->LastAction);
#endif

    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    if (EcData->InService) {
        //
        // This is not likely to happen.
        // If the service loop is running, this should exit.
        // Reset the Watchdog Timer.  This may be set again or canceld by the service loop
        //

        KeSetTimer (&EcData->WatchdogTimer,
                    AcpiEcWatchdogTimeout,
                    &EcData->WatchdogDpc);
        
        KeReleaseSpinLock (&EcData->Lock, OldIrql);
        return;
    }
    //
    // Hold Spinlock throughout so we can guatantee there won't be a conflict in the IO queue.
    //
    
    EcData->InService = TRUE;
    
    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    
    switch (EcData->IoState) {
    case EC_IO_NONE:
        //
        // This shouldn't happen.  The watchdog should be shut off if the
        // driver isn't busy.
        //
        break;
    case EC_IO_READ_BYTE:
    case EC_IO_BURST_ACK:
        if (ecStatus & EC_OUTPUT_FULL) {
            //
            // EC appears to be ready.  Log an error and continue.
            //

        } else {
            //
            // If the embedded controller is not ready yet, somthing went wrong.
            // Retry the transaction.
            //

            if (EcData->IoState == EC_IO_READ_BYTE) {
                EcData->IoBuffer -= 1;
                EcData->IoAddress -= 1;
                EcData->IoRemain += 1;
            }

            EcData->IoState = EC_IO_NEXT_BYTE;
        }
        break;
    case EC_IO_READ_QUERY:
        if (ecStatus & EC_OUTPUT_FULL) {
            //
            // EC appears to be ready.  Log an error and continue.
            //

        } else {
            //
            // If the embedded controller is not ready yet, somthing went wrong.
            // This could mean that the query was lost.  If the Query bit is still set,
            // the driver will retry automatically.
            //

            EcData->IoState = EC_IO_NONE;
        }
        break;
    case EC_IO_WRITE_BYTE:
    case EC_IO_SEND_ADDRESS:
        //
        // This is just waiting for IBF==0.  If it took this long, chances are the 
        // state was lost.  Retry the transaction.
        //

        EcData->IoBuffer -= 1;
        EcData->IoAddress -= 1;
        EcData->IoRemain += 1;
        EcData->IoState = EC_IO_NEXT_BYTE;
        break;
    case EC_IO_NEXT_BYTE:
        //
        // This could happen if IBF is still set
        //
        
        if (ecStatus & EC_INPUT_FULL) {
            //
            // Try thwaking it to see if it will wake up.
            //

            EcPrint (EC_IO, ("AcpiEcWatchDog: Clear Burst mode - Write = %x at %x\n", EC_CANCEL_BURST, EcData->CommandPort));
            AcpiEcLogAction (EcData, EC_ACTION_WRITE_CMD, EC_CANCEL_BURST);
            WRITE_PORT_UCHAR (EcData->CommandPort, EC_CANCEL_BURST);
        }

    }
    
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    EcData->InService = FALSE;
    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    
    //
    // Set the timer.  The ServiceIoLoop won't reset the timer, until some forward progress is made.
    //
    KeSetTimer (&EcData->WatchdogTimer,
                AcpiEcWatchdogTimeout,
                &EcData->WatchdogDpc);

    AcpiEcServiceDevice(EcData);
}

VOID
AcpiEcLogAction (
    PECDATA EcData, 
    UCHAR Action, 
    UCHAR Data
    )

{
    UCHAR i, j;
    LARGE_INTEGER   time, temp;
    i = EcData->LastAction;
    j = (i-1)&ACPIEC_ACTION_COUNT_MASK;
    if (    ((EcData->RecentActions [i].IoStateAction & EC_ACTION_MASK) == EC_ACTION_REPEATED) &&
            (EcData->RecentActions [j].IoStateAction == (EcData->IoState | Action)) &&
            (EcData->RecentActions [j].Data == Data)) {
        //
        // If we already have a repeated action, increment the count on the repeated action 
        // then update the time on the latest one.  We only care about the time of the first and last one.
        //
        EcData->RecentActions [i].Data++;
        if (EcData->RecentActions [i].Data == 0) {
            //
            // If we've logged 255 repeats, don't roll over to 0.
            //

            EcData->RecentActions [i].Data = 0xff;
        }
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        temp.QuadPart = temp.QuadPart + EcData->RecentActions[i].Time;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[i].Time = (USHORT) temp.LowPart;
    } else if ((EcData->RecentActions [i].IoStateAction == (EcData->IoState | Action)) &&
               (EcData->RecentActions [i].Data == Data)) {
        //
        // This is the same action as the last one.  list as a repeated action
        //
        EcData->LastAction++;
        EcData->LastAction &= ACPIEC_ACTION_COUNT_MASK;
        EcData->RecentActions[EcData->LastAction].Data = 1;
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[EcData->LastAction].Time = (USHORT) temp.LowPart;
        AcpiEcLastActionTime = time;
        // Set this last since it is the key to saying that an entry is complete.
        EcData->RecentActions[EcData->LastAction].IoStateAction = EC_ACTION_REPEATED | EcData->IoState;
    } else {
        EcData->LastAction++;
        EcData->LastAction &= ACPIEC_ACTION_COUNT_MASK;
        EcData->RecentActions[EcData->LastAction].Data = Data;
        time = KeQueryPerformanceCounter (NULL);
        temp.QuadPart = time.QuadPart - AcpiEcLastActionTime.QuadPart;
        if (temp.QuadPart > ((USHORT) -1)) {
            temp.QuadPart = (USHORT) -1;
        }
        EcData->RecentActions[EcData->LastAction].Time = (USHORT) temp.LowPart;
        AcpiEcLastActionTime = time;
        // Set this last since it is the key to saying that an entry is complete.
        EcData->RecentActions[EcData->LastAction].IoStateAction = Action | EcData->IoState;
    }

}

VOID
AcpiEcLogError (
    PECDATA EcData,
    NTSTATUS ErrCode
    )
{
    PIO_ERROR_LOG_PACKET    logEntry = NULL;
    PACPIEC_ACTION          action;
    ULONG                   size;
    UCHAR                   i;


    logEntry = IoAllocateErrorLogEntry(EcData->DeviceObject,
                                       ERROR_LOG_MAXIMUM_SIZE);

    if (!logEntry) {
        EcPrint (EC_ERROR, ("AcpiEcLogError: Couldn't write error to errorlog\n"));
        return;
    }

    RtlZeroMemory(logEntry, ERROR_LOG_MAXIMUM_SIZE);

    //
    // Fill out the packet
    //
    logEntry->DumpDataSize          = (USHORT) ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET);
    logEntry->NumberOfStrings       = 0;
    logEntry->ErrorCode             = ErrCode;

    //
    // Fill in data
    //
    logEntry->DumpData[0] = EcData->PerformanceFrequency.LowPart;
    action = (PACPIEC_ACTION) (&logEntry->DumpData[1]);
    size = sizeof(IO_ERROR_LOG_PACKET) + sizeof(logEntry->DumpData[0]) + sizeof(ACPIEC_ACTION);

    i = EcData->LastAction;
    while (size <= ERROR_LOG_MAXIMUM_SIZE) {
        RtlCopyMemory (action, &EcData->RecentActions[i], sizeof(ACPIEC_ACTION)); 

        i--;
        i &= ACPIEC_ACTION_COUNT_MASK;
        if (i == EcData->LastAction) {
            break;
        }
        action++;
        size += sizeof(ACPIEC_ACTION);
    }
    //
    // Submit error log packet
    //
    IoWriteErrorLogEntry(logEntry);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\query.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    query.c

Abstract:

    ACPI Embedded Controller Driver - query dispatching

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/


#include "ecp.h"



NTSTATUS
AcpiEcCompleteQueryMethod (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,AcpiEcUnloadPending)
#pragma alloc_text(PAGE,AcpiEcConnectHandler)
#pragma alloc_text(PAGE,AcpiEcDisconnectHandler)
#endif

UCHAR   rgHexDigit[] = "0123456789ABCDEF";


NTSTATUS
AcpiEcRunQueryMethod (
    IN PECDATA          EcData,
    IN ULONG            QueryIndex
    )
/*++

Routine Description:

    This routine runs the query control method that corresponds to the QueryIndex.

Arguments:

    EcData      - Pointer to the EC extension
    QueryIndex  - The query to run

Return Value:

    Status

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIRP                    irp;

    ASSERT (QueryIndex <= MAX_QUERY);

    //
    // Note: because the ACPI control method is using INPUT data only and
    // this information is grabbed before STATUS_PENDING is returned, it is
    // safe to allocate the storage for this data on the stack.
    //
    // However, because this is a method that can be called at DISPATCH_LEVEL
    // and because we want to reuse the same irp over and over again, it is not
    // safe to call IoBuildDeviceIoControlRequest for this request
    //

    //
    // Initialize the input data
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = '00Q_';
    inputBuffer.MethodName[2] = rgHexDigit[ QueryIndex / 16];
    inputBuffer.MethodName[3] = rgHexDigit[ QueryIndex % 16];

    EcPrint(
        EC_NOTE,
        ("AcpiEcRunQueryMethod: Running query control method %.4s\n",
        inputBuffer.MethodName )
        );

    //
    // Setup the (pre-allocated) Irp
    //
    irp = EcData->QueryRequest;
    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Setup the call
    //
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_EVAL_INPUT_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irp->AssociatedIrp.SystemBuffer  = &inputBuffer;

    //
    // only matters if it is buffered
    //
    irp->Flags |= IRP_INPUT_OPERATION;

    //
    // We want to reuse this irp, so we need to set a completion routine.
    // This will also let us know when the irp is done
    //
    IoSetCompletionRoutine(
        irp,
        AcpiEcCompleteQueryMethod,
        EcData,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass request to Pdo (ACPI driver).  This is an asynchronous request
    //
    status = IoCallDriver(EcData->Pdo, irp);

    //
    // What happened?
    //
    if (!NT_SUCCESS(status)) {

        EcPrint(
            EC_LOW,
            ("AcpiEcRunQueryMethod:  Query Control Method failed, status = %Lx\n",
             status )
            );

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
AcpiEcCompleteQueryMethod (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This is the routine that is called after the ACPI driver has finished
    running the _Qxx method. This routine is here so that we can do the
    'correct' thing after the method is complete.

    Note: We cannot touch Irp->AssociatedIrp.SystemBuffer here because the
    stack that it might have been on has probably been reclaimed. If it becomes
    important to touch this data, then we must allocate the parameters as
    part of non-paged pool

Arguments:

    DeviceObject    - Us
    Irp             - Request that was completed
    Context         - EcData;

--*/
{
    KIRQL               OldIrql;
    PECDATA             EcData = (PECDATA) Context;
    BOOLEAN             ProcessQuery;

#if DEBUG
    //
    // What happened to the irp?
    //
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        EcPrint(
            EC_LOW,
            ("AcpiEcCompleteQueryMethod: Query Method failed, status = %08x\n",
             Irp->IoStatus.Status )
            );

    } else {

        EcPrint(
            EC_NOTE,
            ("AcpiEcCompleteQueryMethod: QueryMethod succeeded.\n")
            );

    }
#endif

    ProcessQuery = FALSE;
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    switch  (EcData->QueryState) {
        case EC_QUERY_DISPATCH:
            EcData->QueryState = EC_QUERY_DISPATCH_COMPLETE;
            break;

        case EC_QUERY_DISPATCH_WAITING:
            EcData->QueryState = EC_QUERY_IDLE;
            ProcessQuery = TRUE;
            break;

        default:
            // internal error
            ASSERT (FALSE);
            break;
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);

    if (ProcessQuery) {
        AcpiEcDispatchQueries(EcData);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
AcpiEcDispatchQueries (
    IN PECDATA          EcData
    )
{
    KIRQL               OldIrql;
    ULONG               i, j;
    ULONG               Id, Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;


    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // Run the vector pending list
    //

    while (EcData->VectorHead) {

        Id = EcData->VectorHead;
        Vector = EcData->VectorTable[Id].Vector;
        i = Vector / BITS_PER_ULONG;
        j = 1 << (Vector % BITS_PER_ULONG);

        //
        // Remove vector from list
        //

        EcData->QuerySet[i] &= ~j;
        EcData->VectorHead = EcData->VectorTable[Id].Next;

        //
        // Dispatch it
        //

        Handler = EcData->VectorTable[Id].Handler;
        Context = EcData->VectorTable[Id].Context;
        KeReleaseSpinLock (&EcData->Lock, OldIrql);

        Handler (Vector, Context);

        KeAcquireSpinLock (&EcData->Lock, &OldIrql);
    }

    //
    // If QueryState is idle, start dispatching
    //

    if (EcData->QueryState == EC_QUERY_IDLE) {

        //
        // Run query pending list
        //

        while (EcData->QueryHead) {

            Id = EcData->QueryHead;
            i = Id / BITS_PER_ULONG;
            j = 1 << (Id % BITS_PER_ULONG);

            //
            // Remove query from list
            //

            EcData->QuerySet[i] &= ~j;
            EcData->QueryHead = EcData->QueryMap[Id];

            EcData->QueryState = EC_QUERY_DISPATCH;
            KeReleaseSpinLock (&EcData->Lock, OldIrql);

            //
            // Run control method for this event
            //

            EcPrint(EC_NOTE, ("AcpiEcDispatchQueries: Query %x\n", Id));
            AcpiEcRunQueryMethod (EcData, Id);


            //
            // If irp is complete the state will be dispatch_complete, loop
            // and process the next bit.  Else, wait for irp to return
            //

            KeAcquireSpinLock (&EcData->Lock, &OldIrql);
            if (EcData->QueryState == EC_QUERY_DISPATCH) {
                //
                // It's not complete, wait for it to complete
                //

                EcData->QueryState = EC_QUERY_DISPATCH_WAITING;
                KeReleaseSpinLock (&EcData->Lock, OldIrql);
                return ;
            }

        }

        //
        // No longer dispatching query events
        //

        EcData->QueryState = EC_QUERY_IDLE;

        //
        // If unload is pending, check to see if the device can be unloaded now
        //

        if (EcData->DeviceState == EC_DEVICE_UNLOAD_PENDING) {
            AcpiEcUnloadPending (EcData);
        }
    }

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
}

VOID
AcpiEcUnloadPending (
    IN PECDATA  EcData
    )
/*++

Routine Description:

    Called when state is unload pending and some portion of the state
    has gone idle.  If the entire device state is idle, the unload is
    stated.

Arguments:

    EcData  - Pointer to embedded controller to service.

Return Value:

--*/
{

    ASSERT (EcData->DeviceState == EC_DEVICE_UNLOAD_PENDING);

    //
    // Check if device is idle for unload operation
    //

    if (EcData->QueryState      == EC_QUERY_IDLE &&
        EcData->InService       == FALSE &&
        EcData->IoState         == EC_IO_NONE) {

        //
        // Promote unloading device state to next step (which
        // is to clean up the fake ISR timer)
        //

        EcData->DeviceState = EC_DEVICE_UNLOAD_CANCEL_TIMER;
    }
}


NTSTATUS
AcpiEcConnectHandler (
    IN PECDATA  EcData,
    IN PIRP     Irp
    )
/*++

Routine Description:

    This functions connects a specific handled to an Ec query vector

Arguments:

    EcData  - Pointer to embedded controller to service.

    Irp     - IOCTL conntain connect request

Return Value:

--*/
{
    KIRQL               OldIrql;
    PVOID               LockPtr;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp;
    PEC_HANDLER_REQUEST Req;
    PVECTOR_TABLE       Vector;
    ULONG               by, bi, i, j;
    ULONG               TableIndex;

    PAGED_CODE ();

    //
    // Get request
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Req   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(EC_HANDLER_REQUEST)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Setup data concerning request
    //

    by = Req->Vector / BITS_PER_ULONG;
    bi = 1 << (Req->Vector % BITS_PER_ULONG);

    //
    // Lock device
    //

    LockPtr = MmLockPagableCodeSection(AcpiEcConnectHandler);
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // If device handler already set, then fail the request
    //

    Status  = STATUS_UNSUCCESSFUL;
    if (!(EcData->QueryType[by] & bi)) {
        //
        // No handler set, allocate vector entry for it
        //

        EcData->QueryType[by] |= bi;
        if (!EcData->VectorFree) {
            //
            // No free entries on vector table, make some
            //

            i = EcData->VectorTableSize;
            Vector = ExAllocatePoolWithTag (
                        NonPagedPool,
                        sizeof (VECTOR_TABLE) * (i + 4),
                        'V_CE'
                        );

            if (!Vector) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto AcpiEcConnectHandlerExit;
            }

            if (EcData->VectorTable) {
                memcpy (Vector, EcData->VectorTable, sizeof (VECTOR_TABLE) * i);
                ExFreePool (EcData->VectorTable);
            }

            EcData->VectorTableSize += 4;
            EcData->VectorTable = Vector;

            for (j=0; j < 4; j++) {
                EcData->VectorTable[i+j].Next = EcData->VectorFree;
                EcData->VectorFree = (UCHAR) (i+j);
            }
        }

        TableIndex = EcData->VectorFree;
        Vector = &EcData->VectorTable[TableIndex];
        EcData->VectorFree = Vector->Next;

        //
        // Build mapping for the vector
        //

        if (EcData->QueryMap[Req->Vector]) {
            //
            // Vector is in query pending list, remove it
            //

            EcData->QuerySet[by] &= ~bi;
            for (i = EcData->QueryHead; i; i = EcData->QueryMap[i]) {
                if (EcData->QueryMap[i] == Req->Vector) {
                    EcData->QueryMap[i] = EcData->QueryMap[Req->Vector];
                    break;
                }
            }
        }

        EcData->QueryMap[Req->Vector] = (UCHAR) TableIndex;

        //
        // Initialize vector handler
        //

        Vector->Next = 0;
        Vector->Vector  = (UCHAR) Req->Vector;
        Vector->Handler = Req->Handler;
        Vector->Context = Req->Context;
        Req->AllocationHandle = (PVOID)((ULONG_PTR)TableIndex);
        Status = STATUS_SUCCESS;
    }

AcpiEcConnectHandlerExit:
    //
    // Unlock device and return status
    //

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    MmUnlockPagableImageSection(LockPtr);
    return Status;
}

NTSTATUS
AcpiEcDisconnectHandler (
    IN PECDATA  EcData,
    IN PIRP     Irp
    )
/*++

Routine Description:

    This functions disconnects a specific handled to an Ec query vector

Arguments:

    EcData  - Pointer to embedded controller to service.

    Irp     - IOCTL conntain connect request

Return Value:

--*/
{
    KIRQL               OldIrql;
    PVOID               LockPtr;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp;
    PEC_HANDLER_REQUEST Req;
    ULONG               by, bi, i;
    ULONG               TableIndex;

    PAGED_CODE ();

    //
    // Get request
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Req   = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(EC_HANDLER_REQUEST)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Setup data concerning request
    //

    by = Req->Vector / BITS_PER_ULONG;
    bi = 1 << (Req->Vector % BITS_PER_ULONG);

    //
    // Lock device
    //

    LockPtr = MmLockPagableCodeSection(AcpiEcDisconnectHandler);
    KeAcquireSpinLock (&EcData->Lock, &OldIrql);

    //
    // If device handler already set, then fail the request
    //

    Status  = STATUS_UNSUCCESSFUL;
    if (EcData->QueryType[by] & bi) {
        //
        // Clear handler
        //

        EcData->QueryType[by] &= ~bi;
        TableIndex = EcData->QueryMap[Req->Vector];
        ASSERT (Req->AllocationHandle == (PVOID)((ULONG_PTR)TableIndex));

        //
        // If pending, drop it
        //

        if (EcData->QuerySet[by] & bi) {
            EcData->QuerySet[by] &= ~bi;

            for (i = EcData->VectorHead; i; i = EcData->VectorTable[i].Next) {
                if (EcData->VectorTable[i].Next == TableIndex) {
                    EcData->VectorTable[i].Next = EcData->VectorTable[TableIndex].Next;
                    break;
                }
            }
        }

        //
        // Put onto free list
        //

        EcData->VectorTable[TableIndex].Next = EcData->VectorFree;
        EcData->VectorFree = (UCHAR) TableIndex;
        Status = STATUS_SUCCESS;
    }

    //
    // Unlock device and return status
    //

    KeReleaseSpinLock (&EcData->Lock, OldIrql);
    MmUnlockPagableImageSection(LockPtr);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\handlers.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handlers.c

Abstract:

    GPE and Operation Region handlers for the ACPI Embedded Controller Driver

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

--*/

#include "ecp.h"

NTSTATUS
AcpiEcOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    DeviceObject    - EC device object
    Irp             - Completing Irp
    Context         - Not Used

Return Value:

    Status

--*/
{
    PACPI_OPREGION_CALLBACK completionHandler;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID                   completionContext;

    //
    // Grab the arguments from the irp
    //
    completionHandler = (PACPI_OPREGION_CALLBACK) irpSp->Parameters.Others.Argument1;
    completionContext = (PVOID) irpSp->Parameters.Others.Argument2;

    EcPrint(
        EC_HANDLER,
        ("AcpiEcOpRegionCompletion: Callback: %08lx Context: %08lx\n",
         completionHandler, completionContext )
        );

    //
    // What happened?
    //
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        EcPrint(
            EC_ERROR,
            ("AcpiEcOpRegionCompletion: region IO failed: %x\n",
             Irp->IoStatus.Status)
            );

    }

    //
    // Invoke the AML interpreter's callback
    //
    (completionHandler)( completionContext );

    //
    // We are done with this irp and the irp
    //
    IoFreeIrp( Irp );

    //
    // Return always return this --- because had to free the irp
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
EXPORT
AcpiEcOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the EC operation region

Arguments:

    AccessType          - Read or Write data
    OpRegion            - Operation region object
    Address             - Address within the EC address space
    Size                - Number of bytes to transfer
    Data                - Data buffer to transfer to/from
    Context             - EcData
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

    Optimization 1: Queue the IRP directly.
    Optimization 2: Queue the context, modify service loop handle it

--*/
{
    LARGE_INTEGER       startingOffset;
    NTSTATUS            status;
    PECDATA             ecData = (PECDATA) Context;
    PIO_STACK_LOCATION  irpSp;
    PIRP                irp;

    EcPrint(
        (EC_HANDLER | EC_OPREGION),
        ("AcpiEcOpRegionHandler: %s Addr=%x Data = %x EcData=%x, Irql=%x\n",
         (AccessType == ACPI_OPREGION_READ ? "read" : "write"),
         Address, *Data, ecData, KeGetCurrentIrql() )
        );

    //
    // Parameter validation will be done in AcpiEcReadWrite
    //

    //
    // Determine where the read will occur
    //
    startingOffset.LowPart = Address;
    startingOffset.HighPart = 0;

    //
    // Allocate an IRP for ourselves. Since we are going to send this
    // irp to ourselves, we know that we only need 1 stack location for it
    // However, to make life easier for ourselves, we will allocate a
    // second one as well and store some data on it.
    //
    irp = IoAllocateIrp( 2, FALSE );
    if (!irp) {

        EcPrint(EC_ERROR, ("AcpiEcOpRegionHandler: Couldn't allocate Irp\n"));
        
        //
        // Retun -1 for data
        //
        RtlFillMemory (Data, Size, 0xff);
        CompletionHandler( CompletionContext );

        //
        // Always return STATUS_PENDING because ACPI interpreter doesn't handle errors.
        //
        return STATUS_PENDING;

    }

    //
    // Fill in the top location so that we can use it ourselves
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.Others.Argument1 = (PVOID) CompletionHandler;
    irpSp->Parameters.Others.Argument2 = (PVOID) CompletionContext;
    IoSetNextIrpStackLocation( irp );

    //
    // Fill out the irp with the request info
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (AccessType == ACPI_OPREGION_READ ? IRP_MJ_READ : IRP_MJ_WRITE);
    irpSp->Parameters.Read.ByteOffset.HighPart = 0;
    irpSp->Parameters.Read.ByteOffset.LowPart = Address;
    irpSp->Parameters.Read.Length = Size;
    irp->AssociatedIrp.SystemBuffer = Data;

    //
    // Set a completion routine
    //
    IoSetCompletionRoutine(
        irp,
        AcpiEcOpRegionCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Send to the front-end of the EC driver as a normal I/O request
    //
    status = IoCallDriver( ecData->DeviceObject, irp);
    EcPrint(
        EC_HANDLER,
        ("AcpiEcOpRegionHandler: Exiting - Data=%08lx Status=%08lx\n",
         (UCHAR) *Data, status)
        );

    return STATUS_PENDING;
    //
    // Always return STATUS_PENDING since actual status has been returned
    // by the calback function.
    //
}



BOOLEAN
AcpiEcGpeServiceRoutine (
        IN PVOID GpeVectorObject,
        IN PVOID ServiceContext
    )
/*++

Routine Description:

    Routine to service the EC based on a General Purpose Event

Arguments:

    GpeVectorObject     - Object associated with this GPE
    ServiceContext      - EcData

Return Value:

    TRUE, since we always handle this GPE

--*/
{

    PECDATA EcData = (PECDATA) ServiceContext;

    EcPrint (EC_HANDLER, ("AcpiEcGpeServiceRoutine: Vobj=%Lx, EcData=%Lx\n",
                        GpeVectorObject, EcData));

    AcpiEcLogAction (EcData, EC_ACTION_INTERRUPT, 0);
    AcpiEcServiceDevice (EcData);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\app\ec.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>


//
// global handles
//

UCHAR   Usage[] = "ec: r addr len\n    w addr value";
HANDLE  DriverHandle;
UCHAR   Buffer[256];


//
// Prototypes
//

BOOLEAN
InitDriver ();



int
__cdecl
main(USHORT argc, CHAR **argv)
{
    BOOLEAN         Write;
    ULONG           Offset, Value;
    ULONG           l, bw;

    //
    // Locate pentium perf driver
    //

    if (!InitDriver ()) {
        printf ("acpiec.sys is not installed\n");
        exit (1);
    }

    //
    // Check args
    //

    if (argc < 3) {
        printf (Usage);
        exit (1);
    }

    switch (argv[1][0]) {
        case 'r':   Write = FALSE;      break;
        case 'w':   Write = TRUE;       break;
        default:    printf (Usage);     exit(1);
    }

    Offset = atoi(argv[2]);
    if (Offset > 255) {
        printf ("ec: Offset must be 0-255\n");
        exit   (1);
    }

    Value  = atoi(argv[3]);
    if (Value > 255) {
        printf ("ec: len/value must be 0-255\n");
        exit   (1);
    }

    l = SetFilePointer (DriverHandle, Offset, NULL, FILE_BEGIN);
    if (l == -1) {
        printf ("ec: Could not set file pointer\n");
        exit (1);
    }

    if (Write) {
        if (!WriteFile(DriverHandle, &Value, 1, &bw, NULL)) {
            printf ("ec: Write error\n");
            exit (1);
        }
    } else {
        if (!ReadFile(DriverHandle, Buffer, Value, &bw, NULL)) {
            printf ("ec: Read error\n");
            exit (1);
        }

        for (l=0; l < Value; l++) {
            printf ("%3d: %d\n", Offset + l, Buffer[l]);
        }
    }

    return 0;
}

BOOLEAN
InitDriver ()
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    RtlInitUnicodeString(&DriverName, L"\\Device\\ACPIEC");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,     // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    return NT_SUCCESS(status) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\cbattery.h ===
#ifndef _CBATTERY_H
#define _CBATTERY_H

/*
 * title:      cbattery.h
 *
 * purpose:    header for wdm kernel battery object
 *
 */



// HID USAGE PAGE NUMBERS
#define POWER_PAGE                      0x84
#define BATTERY_PAGE                    0x85

// HID USAGE NUMBERS (Power Page)
#define PRESENT_STATUS_ID               0x02
#define UPS_ID                          0x04
#define POWER_SUMMARY_ID                0x24
#define VOLTAGE_ID                      0x30
#define CURRENT_ID                      0x31
#define CONFIG_VOLTAGE_ID               0x40
#define CONFIG_CURRENT_ID               0x41
#define DELAY_BEFORE_SHUTDOWN_ID        0x57
#define SHUTDOWN_IMMINENT_ID            0x69
#define MANUFACTURER_ID                 0xfd
#define PRODUCT_ID                      0xfe
#define SERIAL_NUMBER_ID                0xff

// HID USAGE NUMBERS (Battery Page)
#define REMAINING_CAPACITY_LIMIT_ID     0x29
#define CAPACITY_MODE_ID                0x2c
#define BELOW_REMAINING_CAPACITY_ID     0x42
#define CHARGING_ID                     0x44
#define DISCHARGING_ID                  0x45
#define REMAINING_CAPACITY_ID           0x66
#define FULL_CHARGED_CAPACITY_ID        0x67
#define RUNTIME_TO_EMPTY_ID             0x68
#define DESIGN_CAPACITY_ID              0x83
#define MANUFACTURE_DATE_ID             0x85
#define ICHEMISTRY_ID                   0x89
#define WARNING_CAPACITY_LIMIT_ID       0x8c
#define GRANULARITY1_ID                 0x8d
#define GRANULARITY2_ID                 0x8e
#define OEM_INFO_ID                     0x8f
#define AC_PRESENT_ID                   0xd0


typedef enum {
    PRESENT_STATUS_INDEX,           // 0
    UPS_INDEX,                      // 1
    POWER_SUMMARY_INDEX,            // 2
    VOLTAGE_INDEX,                  // 3
    CURRENT_INDEX,                  // 4
    CONFIG_VOLTAGE_INDEX,           // 5
    CONFIG_CURRENT_INDEX,           // 6
    DELAY_BEFORE_SHUTDOWN_INDEX,    // 7
    SHUTDOWN_IMMINENT_INDEX,        // 8
    MANUFACTURER_INDEX,             // 9
    PRODUCT_INDEX,                  // a
    SERIAL_NUMBER_INDEX,            // b
    REMAINING_CAPACITY_LIMIT_INDEX, // c
    CAPACITY_MODE_INDEX,            // d
    BELOW_REMAINING_CAPACITY_INDEX, // e
    CHARGING_INDEX,                 // f
    DISCHARGING_INDEX,              // 10
    REMAINING_CAPACITY_INDEX,       // 11
    FULL_CHARGED_CAPACITY_INDEX,    // 12
    RUNTIME_TO_EMPTY_INDEX,         // 13
    DESIGN_CAPACITY_INDEX,          // 14
    MANUFACTURE_DATE_INDEX,         // 15
    CHEMISTRY_INDEX,                // 16
    WARNING_CAPACITY_LIMIT_INDEX,   // 17
    GRANULARITY1_INDEX,             // 18
    GRANULARITY2_INDEX,             // 19
    OEM_INFO_INDEX,                 // 1a
    AC_PRESENT_INDEX,               // 1b
    MAX_USAGE_INDEXS                // 1c
} USAGE_INDEX;

typedef struct {
    USAGE       Page;
    USAGE       UsageID;
} USAGE_ENTRY;

extern USAGE_ENTRY UsageArray[];


class CBattery
{

public:  // accessors
    CBattery(CHidDevice *);
    ~CBattery();
    NTSTATUS        RefreshStatus();
    bool            InitValues();                    // initialize static values from device
    bool            GetSetValue(USAGE_INDEX, PULONG, bool);
    CUString *      GetCUString(USAGE_INDEX);
    ULONG           GetUnit(USAGE_INDEX);
    SHORT           GetExponent(USAGE_INDEX);
    CUsage *        GetUsage(USAGE_INDEX);
public: // members
    PVOID           m_pBatteryClass;         // Battery Class handle
    CHidDevice *    m_pCHidDevice;           // the hid device for this battery
    BOOLEAN         m_bIsCacheValid;         // Is cached battery info currently valid?

    //
    // Battery
    //
    BOOLEAN                     m_bRelative;    // indicates capacity in percent or absolute values
    ULONGLONG                   m_RefreshTime;
    BATTERY_STATUS              m_BatteryStatus;
    BATTERY_INFORMATION         m_BatteryInfo;
    PBATTERY_NOTIFY             m_pBatteryNotify;
    USHORT                      m_Tag;
    CUString *                  m_pSerialNumber;
    CUString *                  m_pOEMInformation;
    CUString *                  m_pProduct;
    CUString *                  m_pManufacturer;
    BATTERY_MANUFACTURE_DATE    m_ManufactureDate;
};

#endif // cbattery.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\ec\ecpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ecpnp.c

Abstract:

    ACPI Embedded Controller Driver, Plug and Play support

Author:

    Bob Moore (Intel)

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "ecp.h"

//
// List of FDOs managed by this driver
//
extern PDEVICE_OBJECT       FdoList;

//
// Table of direct-call interfaces into the ACPI driver
//
ACPI_INTERFACE_STANDARD     AcpiInterfaces;



NTSTATUS
AcpiEcIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pdoIoCompletedEvent
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent be this driver.
    Context is the event to set.

--*/
{

   KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
AcpiEcAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each AcpiEc controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject       - a pointer to the object for this driver
    NewDeviceObject    - a pointer to where the FDO is placed

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT  fdo = NULL;
    PDEVICE_OBJECT  ownerDevice = NULL;
    PDEVICE_OBJECT  lowerDevice = NULL;
    PECDATA         EcData;
    NTSTATUS        status;


    PAGED_CODE();

    EcPrint(EC_LOW, ("AcpiEcAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        EcPrint(EC_LOW, ("AcpiEcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = AcpiEcCreateFdo(DriverObject, &fdo);

    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice - error creating Fdo\n"));
        return status;
    }

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(fdo,Pdo);

    //
    // No status. Do the best we can.
    //
    ASSERT(lowerDevice);

    EcData = fdo->DeviceExtension;
    EcData->LowerDeviceObject = lowerDevice;
    EcData->Pdo = Pdo;

    //
    // Allocate and hold an IRP for Query notifications and miscellaneous
    //
    EcData->QueryRequest    = IoAllocateIrp (EcData->LowerDeviceObject->StackSize, FALSE);
    EcData->MiscRequest     = IoAllocateIrp (EcData->LowerDeviceObject->StackSize, FALSE);

    if ((!EcData->QueryRequest) || (!EcData->MiscRequest)) {
        //
        // NOTE: This failure case and other failure cases below should do
        // cleanup of all previous allocations, etc performed in this function.
        //

        EcPrint(EC_ERROR, ("AcpiEcAddDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Link this fdo to the list of fdo's managed by the driver
    // (Probably overkill since there will be only one FDO)
    //
    //
    EcPrint(EC_LOW, ("AcpiEcAddDevice: linking fdo to list\n"));
    EcData->NextFdo = FdoList;
    InterlockedExchangePointer((PVOID *) &FdoList, fdo);

    //
    // Initialize the Timeout DPC
    //

    KeInitializeTimer(&EcData->WatchdogTimer);
    KeInitializeDpc(&EcData->WatchdogDpc, AcpiEcWatchdogDpc, EcData);
    
    //
    // Get the GPE vector assigned to this device
    //

    status = AcpiEcGetGpeVector (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice: Could not get GPE vector, status = %Lx\n", status));
        return status;
    }

    //
    // Get the direct-call ACPI interfaces.
    //

    status = AcpiEcGetAcpiInterfaces (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_LOW, ("AcpiEcAddDevice: Could not get ACPI driver interfaces, status = %Lx\n", status));
        return status;
    }

    //
    // Final flags
    //

    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
    fdo->Flags |= DO_POWER_PAGABLE;             // Don't want power Irps at irql 2

    return STATUS_SUCCESS;
}



NTSTATUS
AcpiEcCreateFdo(
    IN PDRIVER_OBJECT   DriverObject,
    OUT PDEVICE_OBJECT  *NewDeviceObject
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Embedded controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    DeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
#if DEBUG
    UNICODE_STRING  unicodeString;
#endif
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        Status;
    PECDATA         EcData;

    PAGED_CODE();

    EcPrint(EC_LOW, ("AcpiEcCreateFdo: Entry\n") );

#if DEBUG
    RtlInitUnicodeString(&unicodeString, L"\\Device\\ACPIEC");
#endif

    Status = IoCreateDevice(
                DriverObject,
                sizeof (ECDATA),
#if DEBUG
                &unicodeString,
#else
                NULL,
#endif
                FILE_DEVICE_UNKNOWN,    // DeviceType
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &deviceObject
                );

    if (Status != STATUS_SUCCESS) {
        EcPrint(EC_LOW, ("AcpiEcCreateFdo: unable to create device object: %X\n", Status));
        return(Status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;
    deviceObject->StackSize = 1;

    //
    // Initialize EC device extension data
    //

    EcData = (PECDATA) deviceObject->DeviceExtension;
    EcData->DeviceObject        = deviceObject;
    EcData->DeviceState         = EC_DEVICE_WORKING;
    EcData->QueryState          = EC_QUERY_IDLE;
    EcData->IoState             = EC_IO_NONE;
    EcData->IsStarted           = FALSE;
    EcData->MaxBurstStall       = 50;
    EcData->MaxNonBurstStall    = 10;
    EcData->InterruptEnabled    = TRUE;
    EcData->ConsecutiveFailures = 0;
    KeQueryPerformanceCounter (&EcData->PerformanceFrequency);
    RtlFillMemory (EcData->RecentActions, ACPIEC_ACTION_COUNT * sizeof(ACPIEC_ACTION), 0);

    //
    // Initialize EC global synchronization objects
    //

    InitializeListHead (&EcData->WorkQueue);
    KeInitializeEvent (&EcData->Unload, NotificationEvent, FALSE);
    KeInitializeSpinLock (&EcData->Lock);


    *NewDeviceObject = deviceObject;
    return STATUS_SUCCESS;

}



NTSTATUS
AcpiEcPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PECDATA             EcData;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    EcData = DeviceObject->DeviceExtension;

    EcPrint (EC_NOTE, ("AcpiEcPnpDispatch: PnP dispatch, minor = %d\n",
                        irpStack->MinorFunction));

    //
    // Dispatch minor function
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE: {
            status = AcpiEcStartDevice (DeviceObject, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

    //
    // We will never allow the EC driver to stop once it is started.
    //
    // Note:  Stop and remove device should be implemented so that the driver
    // can be unloaded without reboot.  Even if the device can't be removed, it
    // will get an IRP_MN_REMOVE_DEVICE if somthing goes wrong trying to start
    // the device.
    //
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:

        status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:
        Irp->IoStatus.Status = STATUS_SUCCESS;
        AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
        break;

#if 0
    case IRP_MN_STOP_DEVICE: {
            status = AcpiEcStopDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }
#endif
    case IRP_MN_QUERY_DEVICE_RELATIONS: {

            EcPrint(EC_LOW, ("AcpiEcPnp: IRP_MJ_QUERY_DEVICE_RELATIONS  Type:  %d\n",
                        irpStack->Parameters.QueryDeviceRelations.Type));

            //
            // Just pass it down to ACPI
            //

            AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
            break;
        }

    default: {

            //
            // Unimplemented minor, Pass this down to ACPI
            //

            EcPrint(EC_LOW, ("AcpiEcPnp: Unimplemented PNP minor code %d, forwarding\n",
                    irpStack->MinorFunction));

            AcpiEcCallLowerDriver(status, EcData->LowerDeviceObject, Irp);
            break;
        }
    }


    return status;
}


NTSTATUS
AcpiEcGetResources(
    IN PCM_RESOURCE_LIST    ResourceList,
    IN PECDATA              EcData
    )
/*++

Routine Description:
    Get the resources already allocated and pointed to by the PDO.

Arguments:

    ResourceList    - Pointer to the resource list.
    EcData          - Pointer to the extension.

Return Value:

    Status is returned.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG                           i;
    PUCHAR                          port[2] = {NULL, NULL};


    PAGED_CODE();


    if (ResourceList == NULL) {
        EcPrint(EC_LOW, ("AcpiEcGetResources: Null resource pointer\n"));

        return STATUS_NO_MORE_ENTRIES;
    }

    if (ResourceList->Count <= 0 ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Traverse the resource list
    //

    fullResourceDesc=&ResourceList->List[0];
    partialResourceList = &fullResourceDesc->PartialResourceList;
    partialResourceDesc = partialResourceList->PartialDescriptors;

    for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

        if (partialResourceDesc->Type == CmResourceTypePort) {

            port[i] = (PUCHAR)((ULONG_PTR)partialResourceDesc->u.Port.Start.LowPart);
        }
    }

    //
    // Get the important things
    //

    EcData->StatusPort  = port[1];          // Status port same as Command port
    EcData->CommandPort = port[1];
    EcData->DataPort    = port[0];

    EcPrint(EC_LOW, ("AcpiEcGetResources: Status/Command port %x, Data port %x\n", port[1], port[0]));

    return STATUS_SUCCESS;
 }


NTSTATUS
AcpiEcStartDevice(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
    )
/*++

Routine Description:
    Start a device

Arguments:

    Fdo    - Pointer to the Functional Device Object.
    Irp    - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS            status;
    PECDATA             EcData = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);


    EcPrint(EC_LOW, ("AcpiEcStartDevice: Entered with fdo %x\n", Fdo));

    //
    // Always send this down to the PDO first
    //

    status = AcpiEcForwardIrpAndWait (EcData, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (EcData->IsStarted) {

        //
        // Device is already started
        //

        EcPrint(EC_WARN, ("AcpiEcStartDevice: Fdo %x already started\n", Fdo));
        return STATUS_SUCCESS;
    }

    //
    // Parse AllocatedResources.
    //

    status = AcpiEcGetResources (irpStack->Parameters.StartDevice.AllocatedResources, EcData);
    if (!NT_SUCCESS(status)) {
        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not get resources, status = %x\n", status));
        return status;
    }

    //
    // Connect to the dedicated embedded controller GPE
    //

    status = AcpiEcConnectGpeVector (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not attach to GPE vector, status = %Lx\n", status));
        return status;
    }
    EcPrint(EC_NOTE, ("AcpiEcStartDevice: Attached to GPE vector %d\n", EcData->GpeVector));

    //
    // Install the Operation Region handler
    //

    status = AcpiEcInstallOpRegionHandler (EcData);
    if (!NT_SUCCESS(status)) {

        EcPrint(EC_ERROR, ("AcpiEcStartDevice: Could not install Op region handler, status = %Lx\n", status));
        return status;
    }

    EcData->IsStarted = TRUE;
    return STATUS_SUCCESS;
}


NTSTATUS
AcpiEcStopDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++

Routine Description:
    Stop a device

Arguments:

    Fdo    - Pointer to the Functional Device Object.
    Irp    - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PECDATA             EcData = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;


    EcPrint(EC_LOW, ("AcpiEcStopDevice: Entered with fdo %x\n", Fdo));

    //
    // Always send this down to the PDO
    //

    status = AcpiEcForwardIrpAndWait (EcData, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!EcData->IsStarted) {
        //
        // Already stopped
        //

        return STATUS_SUCCESS;
    }

    //
    // Must disconnect from GPE
    //

    status = AcpiEcDisconnectGpeVector (EcData);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Must de-install Operation Region Handler
    //

    status = AcpiEcRemoveOpRegionHandler (EcData);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    EcPrint(EC_LOW, ("AcpiEcStopDevice: Detached from GPE and Op Region\n"));

    //
    // Now the device is stopped.
    //

    EcData->IsStarted = FALSE;          // Mark device stopped
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\cbattery.cpp ===
/*
 * title:      cbattery.cpp
 *
 * purpose:    wdm kernel implementation for battery object classes
 *
 * initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * windows 98 support
 *
 */
#include "hidbatt.h"

static USHORT gBatteryTag = 0;

USAGE_ENTRY UsageArray[MAX_USAGE_INDEXS] = {
    { POWER_PAGE, PRESENT_STATUS_ID},
    { POWER_PAGE, UPS_ID },
    { POWER_PAGE, POWER_SUMMARY_ID },
    { POWER_PAGE, VOLTAGE_ID },
    { POWER_PAGE, CURRENT_ID },
    { POWER_PAGE, CONFIG_VOLTAGE_ID },
    { POWER_PAGE, CONFIG_CURRENT_ID },
    { POWER_PAGE, DELAY_BEFORE_SHUTDOWN_ID },
    { POWER_PAGE, SHUTDOWN_IMMINENT_ID },
    { POWER_PAGE, MANUFACTURER_ID },
    { POWER_PAGE, PRODUCT_ID },
    { POWER_PAGE, SERIAL_NUMBER_ID },
    { BATTERY_PAGE, REMAINING_CAPACITY_LIMIT_ID },
    { BATTERY_PAGE, CAPACITY_MODE_ID},
    { BATTERY_PAGE, BELOW_REMAINING_CAPACITY_ID },
    { BATTERY_PAGE, CHARGING_ID },
    { BATTERY_PAGE, DISCHARGING_ID },
    { BATTERY_PAGE, REMAINING_CAPACITY_ID },
    { BATTERY_PAGE, FULL_CHARGED_CAPACITY_ID },
    { BATTERY_PAGE, RUNTIME_TO_EMPTY_ID},
    { BATTERY_PAGE, DESIGN_CAPACITY_ID },
    { BATTERY_PAGE, MANUFACTURE_DATE_ID },
    { BATTERY_PAGE, ICHEMISTRY_ID },
    { BATTERY_PAGE, WARNING_CAPACITY_LIMIT_ID },
    { BATTERY_PAGE, GRANULARITY1_ID },
    { BATTERY_PAGE, GRANULARITY2_ID },
    { BATTERY_PAGE, OEM_INFO_ID },
    { BATTERY_PAGE, AC_PRESENT_ID }
};




CBattery::CBattery(CHidDevice *)
{
    RtlZeroMemory(&m_BatteryStatus, sizeof(BATTERY_STATUS));
    RtlZeroMemory(&m_BatteryInfo,sizeof(BATTERY_INFORMATION));
    m_pBatteryClass = NULL;
    m_Tag = ++gBatteryTag;
    m_RefreshTime = 0;
    m_bRelative = FALSE;
}

CBattery::~CBattery()
{
    // delete hid device if present
    if(m_pCHidDevice) {
        delete m_pCHidDevice;
        m_pCHidDevice = NULL;
    }
    if(m_pSerialNumber) {
        delete m_pSerialNumber;
        m_pSerialNumber = NULL;
    }
    if(m_pOEMInformation) {
        delete m_pOEMInformation;
        m_pOEMInformation = NULL;
    }
    if(m_pProduct) {
        delete m_pProduct;
        m_pProduct = NULL;
    }
    if(m_pManufacturer) {
        delete m_pManufacturer;
        m_pManufacturer = NULL;
    }
}

bool CBattery::InitValues()
{
    bool     bResult;
    ULONG    ulReturnValue = 0;
    ULONG    ulValue;
    CUString *    pChemString;
    NTSTATUS ntStatus;
    SHORT     sExponent;

    // initialize the static data structures
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    // Init Values
    // start with the info structure
    m_BatteryInfo.Capabilities = BATTERY_SYSTEM_BATTERY |
                                 BATTERY_IS_SHORT_TERM;
    // get CapacityMode, find out what style of reporting is used
    bResult = GetSetValue(CAPACITY_MODE_INDEX,&ulReturnValue,FALSE);
    if (ulReturnValue == 2) {
        m_BatteryInfo.Capabilities |= BATTERY_CAPACITY_RELATIVE;
        m_bRelative = TRUE;
    }

    // now get voltage for use in amperage to watt calculations
    // get voltage
    bResult = GetSetValue(VOLTAGE_INDEX, &ulValue,FALSE);
    if(!bResult)
    {
        bResult = GetSetValue(CONFIG_VOLTAGE_INDEX,&ulValue,FALSE);
        sExponent = GetExponent(CONFIG_VOLTAGE_INDEX);
        if(!bResult) {
            ulValue = 24;
            sExponent = 0;
        }
    } else
    {
        sExponent = GetExponent(VOLTAGE_INDEX);
    }

    ULONG ulNewValue = CorrectExponent(ulValue,sExponent, 4); // HID exponent for millivolts is 4
    m_BatteryStatus.Voltage = ulNewValue;

    // HID unit is typically Volt
    // designed capacity
    bResult = GetSetValue(DESIGN_CAPACITY_INDEX, &ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : BATTERY_UNKNOWN_VOLTAGE;
    if (m_bRelative) {
        m_BatteryInfo.DesignedCapacity = ulValue;  // in percent
    } else {
        // must convert to millwatts from centiAmp
        sExponent = GetExponent(DESIGN_CAPACITY_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        m_BatteryInfo.DesignedCapacity = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    // Technology
    m_BatteryInfo.Technology = 1; // secondary, rechargeable battery
    // init static strings from device
    // Chemistry
    pChemString = GetCUString(CHEMISTRY_INDEX);
    if (pChemString) {
        // make into ascii
        char * pCString;
        ntStatus = pChemString->ToCString(&pCString);
        if (NT_ERROR(ntStatus)) {
            RtlZeroMemory(&m_BatteryInfo.Chemistry,sizeof(m_BatteryInfo.Chemistry));
        } else {
            RtlCopyMemory(&m_BatteryInfo.Chemistry, pCString,sizeof(m_BatteryInfo.Chemistry));
            ExFreePool(pCString);
        }
    } else {
        RtlZeroMemory(&m_BatteryInfo.Chemistry,sizeof(m_BatteryInfo.Chemistry));
    }
    delete pChemString;

    // serial number string
    m_pSerialNumber = GetCUString(SERIAL_NUMBER_INDEX);
    HidBattPrint (HIDBATT_TRACE, ("GetCUString (Serial Number) returned - Serial = %08x\n", m_pSerialNumber));
    if (m_pSerialNumber) {
        HidBattPrint (HIDBATT_TRACE, ("     Serial # = %s\n", m_pSerialNumber));
    }

    // OEMInformation
    m_pOEMInformation = GetCUString(OEM_INFO_INDEX);

    m_pProduct = GetCUString(PRODUCT_INDEX);

    m_pManufacturer = GetCUString(MANUFACTURER_INDEX);

    bResult = GetSetValue(MANUFACTURE_DATE_INDEX, &ulReturnValue,FALSE);
    if (bResult) {
        // make conformant date
        m_ManufactureDate.Day = (UCHAR) ulReturnValue & 0x1f; // low nibble is day
        m_ManufactureDate.Month = (UCHAR) ((ulReturnValue & 0x1e0) >> 5); // high nibble is month
        m_ManufactureDate.Year = (USHORT) ((ulReturnValue & 0xfffe00) >> 9) + 1980; // high byte is year
    } else {
        // set mfr date to zeros
        m_ManufactureDate.Day = m_ManufactureDate.Month = 0;
        m_ManufactureDate.Year = 0;
    }
    // FullChargedCapacity
    bResult = GetSetValue(FULL_CHARGED_CAPACITY_INDEX,&ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : m_BatteryInfo.DesignedCapacity;

    // if absolute must convert from ampsecs to millwatts
    if (!m_bRelative) {
        sExponent = GetExponent(FULL_CHARGED_CAPACITY_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.FullChargedCapacity = ulValue;


    BOOLEAN warningCapacityValid;
    BOOLEAN remainingCapacityValid;

    // DefaultAlert2
    bResult = GetSetValue(WARNING_CAPACITY_LIMIT_INDEX, &ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : 0;
    warningCapacityValid = bResult;
    if (!m_bRelative) {
        sExponent = GetExponent(WARNING_CAPACITY_LIMIT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.DefaultAlert2 = ulValue; // also in ampsecs (millwatts?)


    // DefaultAlert1
    bResult = GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulReturnValue,FALSE);
    ulValue = bResult ? ulReturnValue : 0; // also in ampsecs (millwatts?)
    remainingCapacityValid = bResult;

    //
    // Hack to allow STOP_DEVICE
    // Since Default Alert 1 is only valid initially, after the device is
    // stopped and restarted this data from the device is invalid, so we
    // must use cached data.
    //
    if (((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1 == (ULONG)-1) {
        ((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1 = ulValue;
    } else {
        ulValue = ((CBatteryDevExt *) m_pCHidDevice->m_pDeviceObject->DeviceExtension)->m_ulDefaultAlert1;
    }

    if (!m_bRelative) {
        sExponent = GetExponent(REMAINING_CAPACITY_LIMIT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulNewValue,m_BatteryStatus.Voltage);
    }

    m_BatteryInfo.DefaultAlert1 = ulValue;

    if (warningCapacityValid && !remainingCapacityValid) {
        m_BatteryInfo.DefaultAlert1 = m_BatteryInfo.DefaultAlert2;
    } else if (!warningCapacityValid && remainingCapacityValid) {
        m_BatteryInfo.DefaultAlert2 = m_BatteryInfo.DefaultAlert1;
    }

    // pro forma initialization for unsupported members
    m_BatteryInfo.CriticalBias = 0;
    m_BatteryInfo.CycleCount = 0;
    return TRUE;

}

#define REFRESH_INTERVAL 80000000 // 10 million ticks per sec with 100 nanosec tics * 5 secs
// 8 seconds is my best guess for a reasonable interval - djk

NTSTATUS CBattery::RefreshStatus()
{
    ULONG     ulValue;
    ULONG     ulPowerState;
    bool      bResult;
    ULONGLONG CurrTime;
    SHORT     sExponent;
    ULONG      ulScaledValue,ulNewValue;
    LONG      ulMillWatts;
    ULONG     ulUnit;
    // insure that the values in the Battery Status are fresh for delivery

    // first get power state
    // build battery state mask
    //  or online, discharging,charging,and critical

    CurrTime = KeQueryInterruptTime();
    if(((CurrTime - m_RefreshTime) < REFRESH_INTERVAL) && m_bIsCacheValid)
    {
        return STATUS_SUCCESS;
    }

    m_bIsCacheValid = TRUE;
    m_RefreshTime = CurrTime;


    bResult = GetSetValue(AC_PRESENT_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading AC_PRESENT\n" ));
    }
    ulPowerState = ulValue ? BATTERY_POWER_ON_LINE : 0;

    bResult = GetSetValue(CURRENT_INDEX, &ulValue,FALSE);
    if (!bResult) {
        ulMillWatts = BATTERY_UNKNOWN_RATE;
    } else {
        // convert from amps to watts
        // must convert to millwatts from centiAmp
        sExponent = GetExponent(CURRENT_INDEX);
        ulNewValue = CorrectExponent(ulValue,sExponent,0);
        ulMillWatts = ulNewValue * m_BatteryStatus.Voltage;
        // now have millwatts
    }

    bResult = GetSetValue(DISCHARGING_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading DISCHARGING\n" ));
    }
    if(ulValue) // discharging
    {
        ulPowerState |= BATTERY_DISCHARGING;
        //This assumes that CURRENT is always positive and that
        //it's the right value to begin with.  Need to double check.

        if (ulMillWatts != BATTERY_UNKNOWN_RATE) {
            ulMillWatts = -ulMillWatts;
        }
        m_BatteryStatus.Rate = ulMillWatts;
        //m_BatteryStatus.Rate = BATTERY_UNKNOWN_RATE;
    } else
    {
        m_BatteryStatus.Rate = ulMillWatts;
        //m_BatteryStatus.Rate = BATTERY_UNKNOWN_RATE; // not discharging
    }

    bResult = GetSetValue(CHARGING_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading CHARGING\n" ));
    }
    ulPowerState |= ulValue ? BATTERY_CHARGING : 0;

    bResult = GetSetValue(SHUTDOWN_IMMINENT_INDEX, &ulValue,FALSE);
    if(!bResult) {
        ulValue = 0;
        HidBattPrint (HIDBATT_DATA, ("HidBattRefreshStatus: error reading SHUTDOWN_IMMINENT\n" ));
    }
    ulPowerState |= ulValue ? BATTERY_CRITICAL : 0;

    m_BatteryStatus.PowerState = ulPowerState;

    // next capacity
    bResult = GetSetValue(REMAINING_CAPACITY_INDEX,&ulValue,FALSE);
    // check if relative or absolute
    if(!m_bRelative && bResult && m_BatteryStatus.Voltage)
    {
        sExponent = GetExponent(REMAINING_CAPACITY_INDEX);
        ulValue = CorrectExponent(ulValue,sExponent,-2);
        ulValue = CentiAmpSecsToMilliWattHours(ulValue,m_BatteryStatus.Voltage);

    }

    m_BatteryStatus.Capacity = bResult ? ulValue : BATTERY_UNKNOWN_CAPACITY;


    return STATUS_SUCCESS;
}

CUString * CBattery::GetCUString(USAGE_INDEX eUsageIndex)
{
    NTSTATUS ntStatus;
    ULONG    ulBytesReturned;
    USHORT    usBuffLen = 100; // arbitary size to pick up battery strings
    // build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if(!pThisPath) return NULL;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if(!pThisPath->m_pNextEntry) return NULL;

    // is this one of the values in presentstatus ?
    pThisPath->m_pNextEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if(!pThisPath->m_pNextEntry->m_pNextEntry) return NULL;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    if(!pThisUsage) return NULL;
    PVOID pBuffer = ExAllocatePoolWithTag(NonPagedPool, usBuffLen, HidBattTag);  // allocate a scratch buffer rather than consume stack
    if(!pBuffer) return NULL;
    ntStatus = pThisUsage->GetString((char *) pBuffer, usBuffLen, &ulBytesReturned);
    if(!NT_SUCCESS(ntStatus)) {
        ExFreePool(pBuffer);
        return NULL;
    }
    // create a custring to return
    CUString * pTheString = new (NonPagedPool, HidBattTag) CUString((PWSTR) pBuffer);
    if(!pTheString) return NULL;

    // free our temp buffer
    ExFreePool(pBuffer);
    return pTheString;
}

SHORT CBattery::GetExponent(USAGE_INDEX eUsageIndex)
{
    SHORT exponent;

    CUsage * pThisUsage = GetUsage(eUsageIndex);
    if(!pThisUsage) return 0;

    exponent = pThisUsage->GetExponent();
    HidBattPrint (HIDBATT_DATA, ("HidBattGetExponent: Exponent for USAGE_INDEX_0x%x = 0x%08x\n", eUsageIndex, exponent));

    return exponent;
}

CUsage * CBattery::GetUsage(USAGE_INDEX eUsageIndex)
{
    CUsagePath * pCurrEntry;
    bool bResult;
// build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if (!pThisPath) return NULL;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if (!pThisPath->m_pNextEntry) return NULL;

    pCurrEntry = pThisPath->m_pNextEntry;
    // check if need to tack on presentstatus collection to path
    if(eUsageIndex == AC_PRESENT_INDEX ||
        eUsageIndex == DISCHARGING_INDEX ||
        eUsageIndex == CHARGING_INDEX ||
        eUsageIndex == BELOW_REMAINING_CAPACITY_INDEX ||
        eUsageIndex == CURRENT_INDEX)
    {
        pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag)
                CUsagePath(UsageArray[PRESENT_STATUS_INDEX].Page,
                            UsageArray[PRESENT_STATUS_INDEX].UsageID);
       if (!pCurrEntry->m_pNextEntry) return NULL;

     pCurrEntry = pCurrEntry->m_pNextEntry;
    }

    pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if (!pCurrEntry->m_pNextEntry) return NULL;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    return pThisUsage;
}

ULONG CBattery::GetUnit(USAGE_INDEX eUsageIndex)
{
    CUsage * pThisUsage = GetUsage(eUsageIndex);
    if(!pThisUsage) return 0;
    return pThisUsage->GetUnit();
}

bool CBattery::GetSetValue(USAGE_INDEX eUsageIndex, PULONG ulResult, bool bWriteFlag)
{
    bool    bResult;
    CUsagePath * pCurrEntry;

// build path to to power summary usage
    CUsagePath * pThisPath = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[UPS_INDEX].Page,
                        UsageArray[UPS_INDEX].UsageID);
    if (!pThisPath) return FALSE;

    pThisPath->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[POWER_SUMMARY_INDEX].Page,
                        UsageArray[POWER_SUMMARY_INDEX].UsageID);
    if (!pThisPath->m_pNextEntry) return FALSE;

    pCurrEntry = pThisPath->m_pNextEntry;
    // check if need to tack on presentstatus collection to path
    if(eUsageIndex == AC_PRESENT_INDEX ||
        eUsageIndex == DISCHARGING_INDEX ||
        eUsageIndex == CHARGING_INDEX ||
        eUsageIndex == BELOW_REMAINING_CAPACITY_INDEX ||
        eUsageIndex == CURRENT_INDEX ||
        eUsageIndex == SHUTDOWN_IMMINENT_INDEX)
    {
        pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag)
                CUsagePath(UsageArray[PRESENT_STATUS_INDEX].Page,
                            UsageArray[PRESENT_STATUS_INDEX].UsageID);
        if (!pCurrEntry->m_pNextEntry) return FALSE;

        pCurrEntry = pCurrEntry->m_pNextEntry;
    }

    pCurrEntry->m_pNextEntry = new (NonPagedPool, HidBattTag) CUsagePath(
                        UsageArray[eUsageIndex].Page,
                        UsageArray[eUsageIndex].UsageID);
    if (!pCurrEntry->m_pNextEntry) return FALSE;

    CUsage *  pThisUsage = m_pCHidDevice->FindUsage(pThisPath, READABLE);
    delete pThisPath; // clean up
    if(!pThisUsage) return FALSE;
    if(bWriteFlag) // this is a write
    {
        bResult = pThisUsage->SetValue(*ulResult);
        if(!bResult) return bResult;
    } else
    {
        // this is a read
        bResult = pThisUsage->GetValue();
        if(!bResult) return bResult;
        *ulResult = pThisUsage->m_Value;

        HidBattPrint (HIDBATT_DATA, ("HidBattGetSetValue: Got USAGE_INDEX_0x%x = 0x%08x\n", eUsageIndex, *ulResult ));

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\ckutils.h ===
/*
 * title:      ckutils.cpp
 *
 * purpose:    misc utils headers
 *
 */

struct USAGE_PROPERTIES {
	BYTE *		m_Unit;
	BYTE		m_UnitLength;
	BYTE		m_Exponent;
	TYPEMASK	m_Type; // feature, input, or output, writeable, alertable, etc.
};

struct USAGE_PATH {
	USAGE               UsagePage;
	USAGE               Usage;
	USAGE_PATH       *  pNextUsage;
	USAGE_PROPERTIES *  UsageProperties;
};

BOOL GetUsage(PHID_DEVICE, char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\ckhid.cpp ===
/*
 * title:      chid.cpp
 *
 * purpose:    wdm kernel implementation of a hid device class
 *
 */

// local prototypes

#include "hidbatt.h"

extern CHidDevice * pGlobalHidDevice[];

bool GetNextUsage(
        CHidDevice * pThisDevice,
        SHORT CollectionID,
        USHORT NodeIndex,
        USHORT usUsageIndex,
        CUsage ** Usage)

{

    int i;
    int UsageCounter = 0;
    // cycle through all the called out usages from the pHid structure


    // get feature usages
    for(i = 0; i < pThisDevice->m_pCaps->NumberFeatureValueCaps; i++)
    {
        if(pThisDevice->m_pHidDevice->FeatureValueCaps[i].LinkCollection == NodeIndex)    // cardinal
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->FeatureValueCaps[i];
                pThisUsage->m_eType = eFeatureValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

    // ditto feature buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberFeatureButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->FeatureButtonCaps[i].LinkCollection == NodeIndex    )
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->FeatureButtonCaps[i];
                pThisUsage->m_eType = eFeatureButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

     // ditto input values
    for(i = 0; i < pThisDevice->m_pCaps->NumberInputValueCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->InputValueCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag) CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->InputValueCaps[i];
                pThisUsage->m_eType = eInputValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

      // ditto input buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberInputButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->InputButtonCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->InputButtonCaps[i];
                pThisUsage->m_eType = eInputButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

    // ditto Output values
    for(i = 0; i < pThisDevice->m_pCaps->NumberOutputValueCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->OutputValueCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pValueCaps = &pThisDevice->m_pHidDevice->OutputValueCaps[i];
                pThisUsage->m_eType = eOutputValue;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }

      // ditto Output buttons
    for(i = 0; i < pThisDevice->m_pCaps->NumberOutputButtonCaps; i++)
    {
          if(pThisDevice->m_pHidDevice->OutputButtonCaps[i].LinkCollection == NodeIndex)
        { // found a usage for this collection
            if(usUsageIndex == UsageCounter)
            {
                // got a usage to send back
                CUsage * pThisUsage = new (NonPagedPool, HidBattTag)  CUsage();
                if (!pThisUsage) {
                  // Could not allocate new CUsage, return error
                  return FALSE;
                }
                
                pThisUsage->m_pButtonCaps = &pThisDevice->m_pHidDevice->OutputButtonCaps[i];
                pThisUsage->m_eType = eOutputButton;
                *Usage = pThisUsage;
                return TRUE;

            }
            UsageCounter++;
        }
    }
    return FALSE;
}

CTypeMask::CTypeMask()
{
    // set members to zero
    ReportType = 0;
    bWriteable = 0;
    bIsString = 0;
    bIsNumber = 0;
    bAlertable = 0;
    bVolatile = 0;
}


CProperties::CProperties(CUsage * pUsage)
{
    PHIDP_BUTTON_CAPS pButtCaps;     // fill in the properties for this usage
    PHIDP_VALUE_CAPS pValueCaps;
    eHidType eType = pUsage->m_eType;   // Cash local copy so compiler (and PREFAST
                                        // will know this value doesn't change.
                                        // (This causes more compact compiling as well)

    switch(eType)
    {
        case eFeatureButton:
        case eInputButton:
        case eOutputButton:
            pButtCaps = pUsage->m_pButtonCaps;
            m_UnitExponent = 0; // no exponents on buttons
            m_Unit = 0; // buttons don't have units
            m_LogicalMin = 0; // ditto for max and min pCaps->LogicalMin;
            m_LogicalMax = 0; // pCaps->LogicalMax;
            m_LinkCollection = pButtCaps->LinkCollection;
            m_ReportID = pButtCaps->ReportID;
            m_Usage = pButtCaps->NotRange.Usage;
            m_UsagePage = pButtCaps->UsagePage;
            break;
        case eFeatureValue:
        case eInputValue:
        case eOutputValue:
            pValueCaps = pUsage->m_pValueCaps;
            m_Unit = pValueCaps->Units;
            m_UnitExponent = (SHORT) pValueCaps->UnitsExp;
            m_LogicalMin = pValueCaps->LogicalMin;
            m_LogicalMax = pValueCaps->LogicalMax;
            m_LinkCollection = pValueCaps->LinkCollection;
            m_ReportID = pValueCaps->ReportID;
            m_Usage = pValueCaps->NotRange.Usage;
            m_UsagePage = pValueCaps->UsagePage;
            break;
    }
    // setup type mask
    m_pType = new (NonPagedPool, HidBattTag)  CTypeMask();
    if (m_pType) {
      if(eType == eInputButton || eType == eInputValue)
      {
          m_pType->SetAlertable();
      }

      // set writability


      if(eType == eFeatureButton || eType == eOutputButton)
      {
          if(pButtCaps->BitField & 0x01)
          {
              m_pType->SetIsWriteable();
          }
      } else if(eType == eFeatureValue || eType == eOutputValue)
      {
          if(pValueCaps->BitField & 0x01)
          {
              m_pType->SetIsWriteable();
          }
      }

      // set volatility
      if(eType == eFeatureValue)
      {
          if(pValueCaps->BitField & 0x80)
          {
              m_pType->SetVolatile();
          }
      }
      if(eType == eFeatureButton)
      {
          if(pButtCaps->BitField & 0x80)
          {
              m_pType->SetVolatile();
          }
      }
    
      switch(eType)
      {
          case eFeatureButton:
          case eFeatureValue:
              m_pType->SetReportType(FeatureType);
              break;
          case eInputButton:
          case eInputValue:
              m_pType->SetReportType(InputType);
              break;
          case eOutputButton:
          case eOutputValue:
              m_pType->SetReportType(OutputType);
      }
      // set value to to number until I figure out how to do strings
      m_pType->SetIsNumber();
    }
}

CProperties::~CProperties()
{
    if (m_pType) {
        delete m_pType;
        m_pType = NULL;
    }
    return;
}

CUsagePath::CUsagePath(USAGE UsagePage, USAGE UsageID, CUsage * pThisUsage)
{
    // init members
    m_UsagePage = UsagePage;
    m_UsageNumber    = UsageID;
    m_pUsage = pThisUsage;
    m_pNextEntry = NULL;
    return;
}


CHidDevice::CHidDevice()
{

    // clear out usage arrays
    for(int i = 0; i<MAXREPORTID; i++)
    {
        m_InputUsageArrays[i] = NULL;
        m_FeatureBuffer[i] = NULL;
        m_ReportIdArray[i] = 0;
    }
    m_pThreadObject = NULL;
    m_pReadBuffer = NULL;
    m_pEventHandler = 0;
}


bool CHidDevice::OpenHidDevice(PDEVICE_OBJECT pDeviceObject)
{
    NTSTATUS                    ntStatus;
    ULONG                       ulNodeCount;
    bool                        bResult;
    HID_COLLECTION_INFORMATION  collectionInformation;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint(HIDBATT_TRACE,("CHidDevice::OpenHidDevice\n"));

    // first get collection information for this device

    ntStatus = DoIoctl(
                pDeviceObject,
                IOCTL_HID_GET_COLLECTION_INFORMATION,
                NULL,
                0,
                &collectionInformation,
                sizeof(HID_COLLECTION_INFORMATION),
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        return FALSE;
    }

    m_pPreparsedData = (PHIDP_PREPARSED_DATA)
                ExAllocatePoolWithTag(NonPagedPool,
                                      collectionInformation.DescriptorSize,
                                      HidBattTag);
    if(!m_pPreparsedData)
    {
        return FALSE;
    }

    ntStatus = DoIoctl(
                pDeviceObject,
                IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                NULL,
                0,
                m_pPreparsedData,
                collectionInformation.DescriptorSize,
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        ExFreePool(m_pPreparsedData);
        return FALSE;
    }

    // init the caps structure

    m_pCaps = (PHIDP_CAPS) ExAllocatePoolWithTag (NonPagedPool,
                                                  sizeof(HIDP_CAPS),
                                                  HidBattTag);
    if(!m_pCaps)
    {
        ExFreePool(m_pPreparsedData);
        return FALSE;
    }
    RtlZeroMemory(m_pCaps,sizeof(HIDP_CAPS));

    ntStatus = HidP_GetCaps (m_pPreparsedData, m_pCaps);
    if (NT_ERROR(ntStatus))
    {
        ExFreePool(m_pPreparsedData);
        ExFreePool(m_pCaps);
        return FALSE;
    }

    // set usage page and usage for application level
    m_UsagePage = m_pCaps->UsagePage;
    m_UsageID = m_pCaps->Usage;
    // init the collection array
    ulNodeCount = m_pCaps->NumberLinkCollectionNodes;

    HIDP_LINK_COLLECTION_NODE * pLinkNodes = (HIDP_LINK_COLLECTION_NODE*)
                ExAllocatePoolWithTag (NonPagedPool,
                                       sizeof(HIDP_LINK_COLLECTION_NODE) * ulNodeCount,
                                       HidBattTag);

    if(!pLinkNodes) return FALSE;

    RtlZeroMemory(pLinkNodes,sizeof(HIDP_LINK_COLLECTION_NODE) * ulNodeCount );

    ntStatus = HidP_GetLinkCollectionNodes(
                    pLinkNodes,
                    &ulNodeCount,
                    m_pPreparsedData
                    );

    if(ntStatus != HIDP_STATUS_SUCCESS)
    {
        ExFreePool( m_pPreparsedData);
        ExFreePool(m_pCaps);
        ExFreePool(pLinkNodes);
        return FALSE;
    }


    // the following call will init all the collections in the device
    CCollectionArray * ThisArray = new (NonPagedPool, HidBattTag)  CCollectionArray(pLinkNodes,(USHORT)  ulNodeCount, -1);
    if (!ThisArray) {
      // Creation of the collection failed, return failure
      return FALSE;
    }

    m_CollectionArray = ThisArray;
    // have each collection fill in its usage array

    // this call uses KR's methods to access and setup his original hid structures.
    // ... This data is then used to populate the the hid device class structures

    m_pHidDevice = SetupHidData(
                  m_pPreparsedData,
                  m_pCaps,
                  pLinkNodes);

    for(int i = 0; i < ThisArray->m_CollectionCount; i++)
    {
        ThisArray->m_pCollections[i]->InitUsages(this);
    }

    ExFreePool(pLinkNodes);

    return TRUE;

}

CHidDevice::~CHidDevice()
{

    ULONG i;

    // release any allocated memory and cleanup

    if (m_pHidDevice) {
        if (m_pHidDevice->InputButtonCaps) {
            ExFreePool (m_pHidDevice->InputButtonCaps);
        }

        if (m_pHidDevice->InputValueCaps) {
            ExFreePool (m_pHidDevice->InputValueCaps);
        }

        if (m_pHidDevice->OutputButtonCaps) {
            ExFreePool (m_pHidDevice->OutputButtonCaps);
        }

        if (m_pHidDevice->OutputValueCaps) {
            ExFreePool (m_pHidDevice->OutputValueCaps);
        }

        if (m_pHidDevice->FeatureButtonCaps) {
            ExFreePool (m_pHidDevice->FeatureButtonCaps);
        }

        if (m_pHidDevice->FeatureValueCaps) {
            ExFreePool (m_pHidDevice->FeatureValueCaps);
        }

        ExFreePool (m_pHidDevice);
    }


    if(m_CollectionArray) {
        delete m_CollectionArray;
        m_CollectionArray = NULL;
    }

    for (i = 0; i < MAXREPORTID; i++) {
        if(m_InputUsageArrays[i]) {

            if (m_InputUsageArrays[i]->m_pUsages) {
                ExFreePool (m_InputUsageArrays[i]->m_pUsages);
            }

            ExFreePool (m_InputUsageArrays[i]);

            m_InputUsageArrays[i] = NULL;
        }
    }

    if(m_pReadBuffer) {
        ExFreePool (m_pReadBuffer);
        m_pReadBuffer = NULL;
    }

    for (i = 0; i < MAXREPORTID; i++) {
        if(m_FeatureBuffer[i]) {
            ExFreePool (m_FeatureBuffer[i]);
            m_FeatureBuffer[i] = NULL;
        }
    }

    if (m_pPreparsedData) {
        ExFreePool (m_pPreparsedData);
    }
    if (m_pCaps) {
        ExFreePool (m_pCaps);
    }

    return;
}


CUsage * CHidDevice::FindUsage(CUsagePath * PathToUsage, USHORT usType)
{
    int i = 0;
    CCollection * pActiveCollection = (CCollection *) NULL;
    CCollectionArray * pCurrentCArray = m_CollectionArray;
    // Index into collection array by usage page : usage id
    while(PathToUsage->m_pNextEntry)
    {
        // traversing a collection
        while( pCurrentCArray && i < pCurrentCArray->m_CollectionCount)
        {
            if(pCurrentCArray->m_pCollections[i]->m_UsagePage == PathToUsage->m_UsagePage &&
                pCurrentCArray->m_pCollections[i]->m_CollectionID == PathToUsage->m_UsageNumber)
            {
                // found a node, go down a level
                pActiveCollection = pCurrentCArray->m_pCollections[i];
                pCurrentCArray = pCurrentCArray->m_pCollections[i]->m_CollectionArray;

                i = 0;
                break;
            }
        i++;
        }
        if(i) return (CUsage *) NULL; // not found
        PathToUsage = PathToUsage->m_pNextEntry;

    }
    if(!pActiveCollection) return (CUsage *) NULL; // no collection found, shouldn't get here
    // got to the collection, check its usages
    CUsageArray * pCurrentUArray = pActiveCollection->m_UsageArray;
    if(!pCurrentUArray) return (CUsage *) NULL;
    // interate usage array
    for(i = 0; i < pCurrentUArray->m_UsageCount; i++)
    {

        if(pCurrentUArray->m_pUsages[i]->m_pProperties->m_Usage == PathToUsage->m_UsageNumber &&
                pCurrentUArray->m_pUsages[i]->m_pProperties->m_UsagePage == PathToUsage->m_UsagePage)
        {
            // got it !
            if(usType == WRITEABLE)    // writable returns feature and output usages
                if(pCurrentUArray->m_pUsages[i]->m_eType  == eFeatureValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eOutputValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eFeatureButton ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eOutputButton)
                    // return writeable usage !
                        return pCurrentUArray->m_pUsages[i];
            if(usType == READABLE)    // returns input and feature types
                if(pCurrentUArray->m_pUsages[i]->m_eType  == eFeatureValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eInputValue    ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eFeatureButton ||
                    pCurrentUArray->m_pUsages[i]->m_eType == eInputButton)

                    // return readable usage !
                        return pCurrentUArray->m_pUsages[i];
        }
    }
    return (CUsage *) NULL;
}

NTSTATUS CHidDevice::ActivateInput()
{
    NTSTATUS ntStatus;
    HANDLE hReadThread;
    
    // init notification elements
    HidBattPrint(HIDBATT_TRACE, ("ActivateInput entered\n"));
    if(!m_pReadBuffer)
    {
        if (!m_pCaps->InputReportByteLength) {
            HidBattPrint(HIDBATT_ERROR, ("ActivateInput: InputReportByteLength = %08x; NumberInputButtonCaps = %08x; NumberInputValueCaps = %08x\n",
                         m_pCaps->InputReportByteLength,
                         m_pCaps->NumberInputButtonCaps,
                         m_pCaps->NumberInputValueCaps));

            //
            // This just means that the battery doesn't give notifications.
            //
            return STATUS_SUCCESS;
        }

        m_pReadBuffer = (PBYTE) ExAllocatePoolWithTag (NonPagedPool,
                                                       m_pCaps->InputReportByteLength,
                                                       HidBattTag);
        if(!m_pReadBuffer)
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    // init read event
    KeInitializeEvent(&m_kReadEvent,NotificationEvent,FALSE);

    ntStatus =  PsCreateSystemThread(
                OUT &hReadThread,
                IN THREAD_ALL_ACCESS,
                IN NULL,                // POBJECT_ATTRIBUTES  ObjectAttributes
                IN NULL,                // HANDLE  ProcessHandle
                OUT NULL,                // PCLIENT_ID  ClientId
                IN ReadThread,
                IN this
                );

    if(NT_ERROR(ntStatus))
    {
        // kill refresh loop, then break
        HidBattPrint(HIDBATT_TRACE, ("ActivateInput error, exiting - Status = %x\n",ntStatus));
        ExFreePool(m_pReadBuffer);
        m_pReadBuffer = NULL;
        return ntStatus;
    }
    HidBattPrint(HIDBATT_TRACE, ("ActivateInput exiting = Status = %x\n",ntStatus));

    ntStatus = ObReferenceObjectByHandle (
            hReadThread,
            THREAD_ALL_ACCESS,
            NULL,
            KernelMode,
            &m_pThreadObject,
            NULL
            );
    
    if (!NT_SUCCESS (ntStatus)) {
        HidBattPrint(HIDBATT_ERROR, ("ActivateInput can't get thread object\n",ntStatus));

        // Return without closing hReadThread handle.  
        // This will cause a reboot to be needed to fully unload the driver. 
        return STATUS_SUCCESS;
    }

    ntStatus = ZwClose (hReadThread);
    // Ignore return value.  We can't do anything about a failure, and the
    // driver will still work.  It will simply result in leaking a thread 
    // object when the device is removed.

    return STATUS_SUCCESS;
}

NTSTATUS ReadCompletionRoutine(PDEVICE_OBJECT pDO, PIRP pIrp,PVOID pContext)
{
    CHidDevice * pHidDevice = (CHidDevice *) pContext;
    HidBattPrint(HIDBATT_TRACE,("Read Completed, IO Status = %x\n",pIrp->IoStatus.Status));

    KeSetEvent(&pHidDevice->m_kReadEvent,0,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

void _stdcall ReadThread(PVOID pContext)
{


    USHORT usFailureCount = 0;
    // build a read irp for hid class
    USHORT              usEventIndex = 0;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PVOID               EventArray[2];
    PIO_STACK_LOCATION  pNewStack;
    CBatteryDevExt *    pDevExt;
    PMDL                mdl;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint(HIDBATT_TRACE,("Read Thread entered\n"));

    //
    // first get our "this"
    //
    CHidDevice * pHidDev = (CHidDevice *) pContext;

    pDevExt = (CBatteryDevExt *) pHidDev->m_pEventContext;

    //
    // Hold the remove lock so the remove routine doesn't cancel the irp while
    // we are playing with it.
    //
    if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
        goto ReadThreadCleanup1; // fail
    }

    //
    // Allocate Irp to be used and re-used
    //
    pHidDev->m_pReadIrp = IoAllocateIrp (pHidDev->m_pLowerDeviceObject->StackSize, FALSE);

    if(!pHidDev->m_pReadIrp) {
        goto ReadThreadCleanup1; // fail
    }

    //
    // Create MDL
    //
    mdl = IoAllocateMdl( pHidDev->m_pReadBuffer,
                        pHidDev->m_pCaps->InputReportByteLength,
                        FALSE,
                        FALSE,
                        (PIRP) NULL );
    if (!mdl) {
        goto ReadThreadCleanup2;
    }

    //
    // Lock IO buffer
    //
    __try {
        MmProbeAndLockPages( mdl,
                            KernelMode,
                            (LOCK_OPERATION) IoWriteAccess );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(ntStatus)) {
        goto ReadThreadCleanup3;
    }

    while (TRUE) {
        IoReuseIrp (pHidDev->m_pReadIrp, STATUS_SUCCESS);

        pHidDev->m_pReadIrp->Tail.Overlay.Thread = PsGetCurrentThread();
        pHidDev->m_pReadIrp->MdlAddress = mdl;

        IoSetCompletionRoutine(pHidDev->m_pReadIrp,ReadCompletionRoutine,pHidDev,TRUE,TRUE,TRUE);
        pNewStack= IoGetNextIrpStackLocation(pHidDev->m_pReadIrp);
        pNewStack->FileObject = pHidDev->m_pFCB;
        pNewStack->MajorFunction = IRP_MJ_READ;
        pNewStack->Parameters.Read.Length = pHidDev->m_pCaps->InputReportByteLength;
        pNewStack->Parameters.Read.ByteOffset.QuadPart = 0;

        KeResetEvent(&pHidDev->m_kReadEvent);

        ntStatus = IoCallDriver(pHidDev->m_pLowerDeviceObject,pHidDev->m_pReadIrp);

        //
        // Don't hold the lock while we are waiting for the IRP to complete.
        // The remove routine will cancel the irp if needed.
        //
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(
                        &pHidDev->m_kReadEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
            ntStatus = pHidDev->m_pReadIrp->IoStatus.Status;
        }

        // we awoke on a read completion
        HidBattPrint(HIDBATT_TRACE,("Read woke: status = 0x%08x\n", ntStatus));

        if(ntStatus != STATUS_SUCCESS)
        {
            if(ntStatus == STATUS_DEVICE_NOT_CONNECTED
                || ntStatus == STATUS_CANCELLED)
            {
                HidBattPrint(HIDBATT_ERROR,("Read Failure - Status = %x\n",ntStatus));
                break;
            }
            usFailureCount++;
            if(usFailureCount++ == 10)
            {
                // stop trying
                HidBattPrint(HIDBATT_ERROR,("Read Failure - More than 10 retries\nStatus = %x\n",pHidDev->m_pReadIrp->IoStatus.Status));
                break;
            }

            //
            // Hold the lock while playing with the IRP
            // If we are being removed, we need to break out.
            //
            if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
                break;
            }
            continue;
        }
        usFailureCount = 0;

        //
        // Hold the lock while playing with the IRP
        // If we are being removed, we need to break out.
        //
        if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
            break;
        }

        // process input buffer
        USHORT usReportId = pHidDev->m_pReadBuffer[0];
        USHORT usIndex = pHidDev->GetIndexFromReportId(usReportId);
        if(usIndex == MAXREPORTID)  // is this a report we recognize
        {
            HidBattPrint(HIDBATT_TRACE,("Read: don't recognize report: usIndex = 0x%08x\n", usIndex));
            continue; // we don't recognize this report
        }
        CUsageArray *pThisInputArray = pHidDev->m_InputUsageArrays[usIndex];
        if(!pThisInputArray)
        {
            HidBattPrint(HIDBATT_TRACE,("Read: nothing to update\n"));
            continue; // nothing to update
        }
        for(int i=0; i< pThisInputArray->m_UsageCount; i++)
        {
            HidBattPrint(HIDBATT_TRACE,("Read: Getting value\n"));
            pThisInputArray->m_pUsages[i]->GetValue();
        }
    }  //while

    //
    // Cleanup
    //
    MmUnlockPages( mdl );

ReadThreadCleanup3:

    IoFreeMdl(mdl);

ReadThreadCleanup2:

    // Irp will be freed by Query remove/stop device thread after read thread has terminated.

ReadThreadCleanup1:

    pDevExt->m_pBattery->m_Tag = BATTERY_TAG_INVALID;
    PsTerminateSystemThread(STATUS_SUCCESS);
    HidBattPrint(HIDBATT_ERROR,("Read thread terminated: Why am I seeing this?\n"));
}

// collectionarray methods

CCollectionArray::CCollectionArray(PHIDP_LINK_COLLECTION_NODE pTheNodes, USHORT usNodeCount, SHORT sParentIndex)
{

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    USHORT i;
    m_pCollections = 0;
    m_CollectionCount = 0;

    if(sParentIndex == -1) // exception processing for application level collection
    {
        m_pCollections = (CCollection **)
                    ExAllocatePoolWithTag (NonPagedPool,
                                           sizeof(CCollection *),
                                           HidBattTag);
        if(!m_pCollections) return;
        RtlZeroMemory(m_pCollections,sizeof(CCollection *));
        m_pCollections[0] = new (NonPagedPool, HidBattTag)  CCollection(pTheNodes,usNodeCount, 0); // get my children
        m_CollectionCount = 1;
    } else {

        for( i = 1; i < usNodeCount; i++) {

            PHIDP_LINK_COLLECTION_NODE pThisNode = &pTheNodes[i];

            if( (pTheNodes[i].Parent == sParentIndex) ) {
                m_CollectionCount++; // inc collection count
                if(!m_pCollections) {
                    m_pCollections = (CCollection **)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CCollection *),
                                                       HidBattTag);
                    if(!m_pCollections) return;
                    RtlZeroMemory(m_pCollections,sizeof(CCollection *));
                } else {
                    // make the array bigger
                    //m_Collections = (CCollection **) realloc(m_Collections,(m_CollectionCount * sizeof(CCollection *)));
                    CCollection ** pTemp = m_pCollections;
                    m_pCollections = (CCollection **)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       m_CollectionCount * sizeof(CCollection *),
                                                       HidBattTag);

                    if (!m_pCollections) {
                      // Re-allocation failure, print error and revert to previous state and return
                      HidBattPrint(HIDBATT_ERROR, ("CCollectionArray: Could not resize CCollection"));
                      m_pCollections = pTemp;
                      m_CollectionCount--;
                      return;
                    }

                    RtlCopyMemory(m_pCollections,pTemp,(m_CollectionCount -1) * sizeof(CCollection *));
                    ExFreePool(pTemp);
                }

                // add collection to array
                CCollection * TempCollection = new  (NonPagedPool, HidBattTag) CCollection(pTheNodes,usNodeCount,i);

                if (!TempCollection) {
                  // Could not allocate new CCollection, print debug message and return
                  HidBattPrint(HIDBATT_ERROR, ("CCollectionArray: Could not allocate new CCollection"));

                  return;
                }
                m_pCollections[m_CollectionCount-1] = TempCollection;
            }
        }
    }
}

CCollectionArray::~CCollectionArray()
{
    while(m_CollectionCount) {
        delete m_pCollections[--m_CollectionCount];
    }
    if (m_pCollections) {
        ExFreePool (m_pCollections);
    }
    return;
}


CCollection::CCollection(PHIDP_LINK_COLLECTION_NODE pTheNodes, USHORT usNodeCount,USHORT usNodeIndex)
{
    m_UsageArray        =    (CUsageArray *) NULL;
    m_CollectionArray    =    (CCollectionArray *) NULL; // init vars

    // setup this collection
    CCollectionArray * ThisArray = new  (NonPagedPool, HidBattTag) CCollectionArray(pTheNodes,usNodeCount,usNodeIndex);
    if (ThisArray) {
        if(!ThisArray->m_CollectionCount) {// any child collections
            delete ThisArray;
        } else {
            m_CollectionArray = ThisArray;
        }
    }
    // set the info in this collection
    m_CollectionID = pTheNodes[usNodeIndex].LinkUsage;
    m_UsagePage = pTheNodes[usNodeIndex].LinkUsagePage;
    m_NodeIndex = usNodeIndex;

}

CCollection::~CCollection()
{
        // delete all usages in the usage array
    if(m_UsageArray)
    {
        delete m_UsageArray;
    }
    // delete all the sub collections
    if(m_CollectionArray)
    {
        delete m_CollectionArray;
    }
}

void CCollection::InitUsages(CHidDevice * ThisDevice)
{
    bool        bResult =    FALSE;
    USHORT        usUsageIndex = 0;
    CUsage *    pThisUsage ;
    USHORT        usInputIndex;
    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    while( bResult = GetNextUsage(ThisDevice,m_CollectionID,m_NodeIndex,usUsageIndex,&pThisUsage))
    {

        if(!m_UsageArray) // if first usage
        {
            m_UsageArray = new (NonPagedPool, HidBattTag)  CUsageArray();
            if (!m_UsageArray) {
                delete pThisUsage;
                return;
            }
        }
        pThisUsage->SetCapabilities();
        pThisUsage->m_pHidDevice = ThisDevice; // store this usage's device pointer
        if(pThisUsage->m_eType == eInputButton ||
                pThisUsage->m_eType == eInputValue)
        {
            // get input array index
            usInputIndex = ThisDevice->AssignIndexToReportId(pThisUsage->m_pProperties->m_ReportID);
            if(!ThisDevice->m_InputUsageArrays[usInputIndex])
            {
                // no array in this report position yet, create
                ThisDevice->m_InputUsageArrays[usInputIndex] = new  (NonPagedPool, HidBattTag) CUsageArray();
                if (!(ThisDevice->m_InputUsageArrays[usInputIndex])) return;
            }
            ThisDevice->m_InputUsageArrays[usInputIndex]->AddUsage(pThisUsage);    // add input usages to refresh stack
        }

        usUsageIndex++;
        m_UsageArray->AddUsage(pThisUsage);
    }
    // also init all my collections
    if(!m_CollectionArray) return;
    for(int i = 0; i < m_CollectionArray->m_CollectionCount; i++)
    {
        m_CollectionArray->m_pCollections[i]->InitUsages(ThisDevice);
    }
}



USHORT CHidDevice::AssignIndexToReportId(USHORT usReportId)
{
    USHORT i;
    HidBattPrint(HIDBATT_TRACE,("AssignIndexToReportId: ReportId = %x -- ", usReportId));
    for(i = 0;i < MAXREPORTID; i++)
    {
        if(!m_ReportIdArray[i]) {
            HidBattPrint(HIDBATT_TRACE,("Assigning to %x\n", i));
            m_ReportIdArray[i] = usReportId;
            return i;
        }
        if(m_ReportIdArray[i] == usReportId) {
            HidBattPrint(HIDBATT_TRACE,("Already assigned to %x\n", i));
            return i;
        }
    }

    //
    // It would be really nice if we could dynamically allocate more
    // since there isn't a small limit set to the number of report IDs.
    //
    ASSERTMSG("MAXREPORTID exceeded.\n", FALSE);

    return 0;

}

USHORT CHidDevice::GetIndexFromReportId(USHORT usReportId)
{
    USHORT i;

    HidBattPrint(HIDBATT_TRACE,("GetIndexFromReportId: ReportId = %x\n", usReportId));
    for(i = 0; i< MAXREPORTID; i++) {
        if(m_ReportIdArray[i] == usReportId) {
            return i;
        }
    }
    HidBattPrint(HIDBATT_TRACE,("GetIndexFromReportId: Failed\n", usReportId));
    return i;  // error return is MAXREPORTIDS
}

CUsagePath * CCollection::FindIndexedUsage(USHORT * pCurrentIndex, USHORT TargetIndex)
{
    CUsagePath * ThisPath;
    CUsagePath * NewPath;
    if(m_UsageArray)
    {
        if(m_UsageArray->m_UsageCount + *pCurrentIndex > TargetIndex)
        {
            // do the arithmetic to get the current index
            int ThisIndex = TargetIndex - *pCurrentIndex;
            // found it, construct usage path
            ThisPath = new  (NonPagedPool, HidBattTag) CUsagePath(
                                            m_UsagePage,
                                            m_CollectionID,
                                            m_UsageArray->m_pUsages[ThisIndex]
                                            );
            return ThisPath;
        }
    // didn't find it, inc current index
        *pCurrentIndex += m_UsageArray->m_UsageCount;
    }

    if(!m_CollectionArray) return NULL; // nothing more, quit

    // call out the sub collections

    for(int i = 0; i < m_CollectionArray->m_CollectionCount; i++)
    {
        ThisPath = m_CollectionArray->m_pCollections[i]->FindIndexedUsage(pCurrentIndex, TargetIndex);
        if(ThisPath)
        {
            // one of our subcollections had the usage, add us to the path
            NewPath = new (NonPagedPool, HidBattTag)  CUsagePath(
                                m_UsagePage,
                                m_CollectionID,
                                NULL
                                );

            if (!NewPath) {
                delete ThisPath;
                return NULL;
            }

            NewPath->m_pNextEntry = ThisPath;
            return NewPath;
        }
    }
    return NULL;
}

CUsagePath::~CUsagePath()
{
    CUsagePath  *   tempNextEntry;
    tempNextEntry = m_pNextEntry;
    m_pNextEntry = NULL;
    if (tempNextEntry) {
        delete tempNextEntry;
    }

    return;
}

CUsage::CUsage()
{
    // do member init
    m_pProperties   =    (CProperties      *) NULL;
    m_pButtonCaps   =    (HIDP_BUTTON_CAPS *) NULL;
    m_pValueCaps    =    (HIDP_VALUE_CAPS  *)NULL;
    m_eType         =    (eHidType) 0;
    m_Value         =    0;
    m_String        =    (char *)NULL;

    return;
}

CUsage::~CUsage()
{
    // free all associated objects

    if(m_pProperties) {
        delete m_pProperties;
    }

    return;
}

bool CUsage::GetValue()
{
    NTSTATUS    ntStatus;
    ULONG       ulResult;
    bool        bResult;
    BYTE        ReportID;
    USHORT      usDummy;

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    switch(m_eType)
    {
        case eFeatureValue:
        case eFeatureButton:

            ReportID = (BYTE) m_pProperties->m_ReportID;
            // do we have the report that contains this data?

            if(!m_pHidDevice->m_FeatureBuffer[ReportID])
            {
                // must first create and fill buffer from getfeature

                // allocate memory
                m_pHidDevice->m_FeatureBuffer[ReportID] =
                    (PBYTE) ExAllocatePoolWithTag (NonPagedPool,
                                           m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                                           HidBattTag);
                RtlZeroMemory(m_pHidDevice->m_FeatureBuffer[ReportID],
                                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1);


                // setup first byte of buffer to report id
                *m_pHidDevice->m_FeatureBuffer[ReportID] = ReportID;
                // now read in report
                HIDDebugBreak(HIDBATT_BREAK_DEBUG);
                HidBattPrint(HIDBATT_TRACE,("GetFeature\n"));
                ntStatus = DoIoctl(
                        m_pHidDevice->m_pLowerDeviceObject,
                        IOCTL_HID_GET_FEATURE,
                        NULL,
                        0,
                        m_pHidDevice->m_FeatureBuffer[ReportID],
                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                        m_pHidDevice
                        );
                if (!NT_SUCCESS (ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - IOCTL_HID_GET_FEATURE 0x%08x\n", ntStatus));
                }
            }
            if(m_pProperties->m_pType->IsVolatile())
            {
                // this is a volatile value, refresh report
                RtlZeroMemory(m_pHidDevice->m_FeatureBuffer[ReportID],
                                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1);


                // setup first byte of buffer to report id
                *m_pHidDevice->m_FeatureBuffer[ReportID] = ReportID;
                // now read in report
                HIDDebugBreak(HIDBATT_BREAK_NEVER);
                HidBattPrint(HIDBATT_TRACE,("GetFeature - Refresh\n"));
                ntStatus = DoIoctl(
                        m_pHidDevice->m_pLowerDeviceObject,
                        IOCTL_HID_GET_FEATURE,
                        NULL,
                        0,
                        m_pHidDevice->m_FeatureBuffer[ReportID],
                        m_pHidDevice->m_pCaps->FeatureReportByteLength+1,
                        m_pHidDevice
                        );
                if (!NT_SUCCESS (ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - (volitile) IOCTL_HID_GET_FEATURE 0x%08x\n", ntStatus));

					// return error, fixes bug #357483
					return FALSE;
                }
            }


            if(m_eType == eFeatureValue)
            {
                ntStatus = HidP_GetUsageValue(
                                HidP_Feature,
                                m_pProperties->m_UsagePage,
                                m_pProperties->m_LinkCollection,
                                m_pProperties->m_Usage,
                                &ulResult,
                                m_pHidDevice->m_pPreparsedData,
                                (char *) m_pHidDevice->m_FeatureBuffer[ReportID],
                                m_pHidDevice->m_pCaps->FeatureReportByteLength
                                );
                if(!NT_SUCCESS(ntStatus))
                {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - HidP_GetUsageValue 0x%08x\n", ntStatus));
                    // return error
                    return FALSE;
                }
            } else
            {
                // must get button data
                ULONG Buttons, BufferSize;
                    PUSAGE pButtonBuffer;
                    Buttons = HidP_MaxUsageListLength (HidP_Feature, 0, m_pHidDevice->m_pPreparsedData);
                    BufferSize = Buttons * sizeof(USAGE);
                    pButtonBuffer = (PUSAGE) ExAllocatePoolWithTag (NonPagedPool,
                                                                    BufferSize,
                                                                    HidBattTag);

                    if (pButtonBuffer==NULL) { 
                        HidBattPrint(HIDBATT_DATA,("GetFeature - ExAllocatePoolWithTag returned NULL."));
                        // return error
                        return FALSE;
                    }
                    else {
                      RtlZeroMemory(pButtonBuffer,BufferSize);
                      ntStatus = HidP_GetButtons(
                                      HidP_Feature,
                                      m_pProperties->m_UsagePage,
                                      m_pProperties->m_LinkCollection,
                                      (PUSAGE) pButtonBuffer,
                                      &Buttons,
                                      m_pHidDevice->m_pPreparsedData,
                                      (char *) m_pHidDevice->m_FeatureBuffer[ReportID],
                                      m_pHidDevice->m_pCaps->FeatureReportByteLength
                                      );
                    }

                    if(!NT_SUCCESS(ntStatus))
                    {
                        HidBattPrint(HIDBATT_DATA,("GetFeature - HidP_GetButtons 0x%08x\n", ntStatus));
                        // return error
                        return FALSE;
                    }
                    // get the value for the requested button
                    PUSAGE pUsage = (PUSAGE) pButtonBuffer;
                    ulResult = 0; // set to not found value
                    for(int i = 0; i < (long) Buttons; i++)
                    {
                        if(pUsage[i] == m_pProperties->m_Usage)
                        {
                            ulResult = 1;
                            break;
                        }
                    }
                    ExFreePool(pButtonBuffer);
            }

            m_Value = ulResult;
            return TRUE;
            break;

        case eInputValue:
        case eInputButton:

            // have we had input data ?
            if(!m_pHidDevice->m_pReadBuffer) break; // nope, leave

            // do we have the report that contains this data?
            ReportID = (BYTE) m_pProperties->m_ReportID;

            if(!*m_pHidDevice->m_pReadBuffer == ReportID) break; // not us

            if(m_eType == eInputValue)
            {
                ntStatus = HidP_GetUsageValue(
                                HidP_Input,
                                m_pProperties->m_UsagePage,
                                m_pProperties->m_LinkCollection,
                                m_pProperties->m_Usage,
                                &ulResult,
                                m_pHidDevice->m_pPreparsedData,
                                (char *)m_pHidDevice->m_pReadBuffer,
                                m_pHidDevice->m_pCaps->InputReportByteLength
                                );
                if(NT_ERROR(ntStatus)) {
                    HidBattPrint(HIDBATT_DATA,("GetFeature - (Button) HidP_GetUsageValue 0x%08x\n", ntStatus));
                    return FALSE;
                }
            } else
            {
                // handle button
                // must get button data
                ULONG Buttons, BufferSize;
                    PUSAGE_AND_PAGE pButtonBuffer;
                    Buttons = HidP_MaxUsageListLength (HidP_Input, 0, m_pHidDevice->m_pPreparsedData);
                    BufferSize = Buttons * sizeof(USAGE_AND_PAGE);
                    pButtonBuffer = (PUSAGE_AND_PAGE)
                                ExAllocatePoolWithTag (NonPagedPool,
                                                       BufferSize,
                                                       HidBattTag);
                    RtlZeroMemory(pButtonBuffer,BufferSize);
                    ntStatus = HidP_GetButtons(
                                    HidP_Input,
                                    m_pProperties->m_UsagePage,
                                    m_pProperties->m_LinkCollection,
                                    (PUSAGE) pButtonBuffer,
                                    &Buttons,
                                    m_pHidDevice->m_pPreparsedData,
                                    (char *) m_pHidDevice->m_pReadBuffer,
                                    m_pHidDevice->m_pCaps->InputReportByteLength
                                    );
                    if(!NT_SUCCESS(ntStatus))
                    {
                        HidBattPrint(HIDBATT_DATA,("GetFeature - (Button) HidP_GetButton 0x%08x\n", ntStatus));
                        // return error
                        return FALSE;
                    }
                    // get the value for the requested button
                    USAGE_AND_PAGE * UsagePage = (USAGE_AND_PAGE *) pButtonBuffer;
                    ulResult = 0; // set to not found value
                    for(int i = 0; i < (long) Buttons; i++)
                    {
                        if(UsagePage[i].Usage == m_pProperties->m_Usage)
                            // don't need to check usage page, because it was specified
                            //     && UsagePage[i].UsagePage == m_pProperties->m_UsagePage)
                        {
                            ulResult = 1;
                            break;
                        }
                    }
                    ExFreePool(pButtonBuffer);
            }
            if(m_Value != ulResult)
            {
                m_Value = ulResult;

                // there's been a change, check if this needs alerting

                if(m_pProperties->m_pType->IsAlertable())
                {
                    // call registered notification callback with
                    // ... passing the notificable usage object
                    if(m_pHidDevice->m_pEventHandler)
                    {
                        (*m_pHidDevice->m_pEventHandler)(
                                        m_pHidDevice->m_pEventContext,
                                        this);
                    }
                }
            }

            return TRUE;
            break;

    }

 return FALSE;
}

void CUsage::SetCapabilities()
{
    // init capabilites from value caps and set properties for this usage
    m_pProperties = new (NonPagedPool, HidBattTag)  CProperties(this);

}

ULONG CUsage::GetUnit()
{
    return m_pProperties->m_Unit;
}

SHORT CUsage::GetExponent()
{
    return m_pProperties->m_UnitExponent;
}

NTSTATUS CUsage::GetString(char * pBuffer, USHORT buffLen, PULONG pBytesReturned)
{
    char cBuffer[4];
    ULONG StringIndex;
    NTSTATUS ntStatus;
    ULONG ulBytesWritten = 0;
    bool bResult;
    // first must update this usages value


    bResult = GetValue();
    if(!bResult) return STATUS_UNSUCCESSFUL;
    RtlCopyMemory(cBuffer,&m_Value,sizeof(ULONG));
    ntStatus = DoIoctl(
                m_pHidDevice->m_pLowerDeviceObject,
                IOCTL_HID_GET_INDEXED_STRING,
                cBuffer,
                4,
                pBuffer,
                buffLen,
                m_pHidDevice);


    return ntStatus;
}


// utility to do writefile for output reports
NTSTATUS HidWriteFile(
            CHidDevice *    pHidDevice,
            PVOID            pOutputBuffer,
            USHORT            usBufferLen,
            PULONG            pulBytesWritten
            )
{
    KEVENT                WrittenEvent;
    IO_STATUS_BLOCK        IoStatusBlock;
    PIO_STACK_LOCATION    pNewStack;

    return STATUS_SUCCESS;
    KeInitializeEvent(&WrittenEvent,NotificationEvent,FALSE);
    // allocate write irp
    PIRP pIrp = IoBuildSynchronousFsdRequest(
            IRP_MJ_WRITE,
            pHidDevice->m_pLowerDeviceObject,
            pOutputBuffer,
            usBufferLen,
            0,
            &WrittenEvent,
            &IoStatusBlock
            );

    if(!pIrp) return STATUS_INSUFFICIENT_RESOURCES;
    pNewStack= IoGetNextIrpStackLocation(pIrp);
    pNewStack->FileObject = pHidDevice->m_pFCB;

    NTSTATUS ntStatus = IoCallDriver(pHidDevice->m_pLowerDeviceObject,pIrp);
    if(NT_ERROR(ntStatus))
    {
        IoFreeIrp(pIrp);
        return ntStatus;
    }
    ntStatus = KeWaitForSingleObject(
                            &WrittenEvent,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL
                            );
    IoFreeIrp(pIrp); // done with Irp
    if(NT_ERROR(ntStatus))
    {
        return ntStatus;
    }
    *pulBytesWritten = (ULONG)IoStatusBlock.Information;
    return IoStatusBlock.Status;
}


bool CUsage::SetValue(ULONG ulValue)
{
    NTSTATUS ntStatus;
    USHORT ThisType;
    char * pOutputBuffer;
    USHORT usBufferLen;
    bool bResult;
    ULONG  ulBytesWritten;

    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    // first check that this is an output or feature report
    if(m_eType == eInputButton ||
        m_eType == eInputValue)
    {
        // if this is an input usage, reject update
         return FALSE;
    }

    if(m_eType == eOutputButton ||
        m_eType == eOutputValue)
    {
        ThisType = HidP_Output;
        usBufferLen = m_pHidDevice->m_pCaps->OutputReportByteLength;

    } else
    {
        ThisType = HidP_Feature;
        usBufferLen = m_pHidDevice->m_pCaps->FeatureReportByteLength + 1; // for report id
    }

    pOutputBuffer = (char *) ExAllocatePoolWithTag (NonPagedPool,
                                                    usBufferLen+1,
                                                    HidBattTag);

    if (!pOutputBuffer) {
      // Allocation failed
      return FALSE;
    }

    pOutputBuffer[0] = (char) m_pProperties->m_ReportID;

    // setup buffer for write
    ntStatus = HidP_SetUsageValue(
                (HIDP_REPORT_TYPE) ThisType,        // either feature or output
                m_pProperties->m_UsagePage,
                m_pProperties->m_LinkCollection,
                m_pProperties->m_Usage,
                ulValue,
                m_pHidDevice->m_pPreparsedData,
                pOutputBuffer,
                usBufferLen-1
                );


    if(ThisType == HidP_Output)
    {
        ntStatus = HidWriteFile(
            m_pHidDevice,
            pOutputBuffer,
            usBufferLen,
            &ulBytesWritten
            );
    } else
    {
        ntStatus = DoIoctl(
                m_pHidDevice->m_pLowerDeviceObject,
                IOCTL_HID_SET_FEATURE,
                pOutputBuffer,  //NULL,
                usBufferLen, //0,
                pOutputBuffer,
                usBufferLen,
                m_pHidDevice
                );
    }

    ExFreePool (pOutputBuffer);

    return ntStatus ? FALSE:TRUE;
}



// Usage Array Class
CUsageArray::CUsageArray()
{
    m_UsageCount = 0;
    m_pUsages = (CUsage **) NULL;
    return;
}

CUsageArray::~CUsageArray()
{
    while(m_UsageCount) {
        delete m_pUsages[--m_UsageCount];
    }
    if (m_pUsages) {
        ExFreePool (m_pUsages);
    }
    return;
}


void CUsageArray::AddUsage(CUsage * pNewUsage)
{
    HIDDebugBreak(HIDBATT_BREAK_NEVER);
    if(!m_pUsages)
    {
        m_pUsages = (CUsage **) ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CUsage *),
                                                       HidBattTag);
    } else
    {
        CUsage ** pTemp = m_pUsages;
        m_pUsages = (CUsage **) ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(CUsage *) * (m_UsageCount + 1),
                                                       HidBattTag);

        if (m_pUsages) {
          memcpy(m_pUsages,pTemp,sizeof(CUsage *) * m_UsageCount);
          ExFreePool(pTemp);
        }
    }

	if (m_pUsages) {
		m_pUsages[m_UsageCount] = pNewUsage;
		m_UsageCount++;
	}
	// else - no way to report allocation failure.  The only indication is that
	//        m_UsageCount is not increamented.  (v-stebe)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\ckhid.h ===
#ifndef _CKHID_H
#define _CKHID_H

/*
 * title:      hidpwr.h
 *
 * purpose:    header for wdm kernel hid interface class
 *
 */

#define READABLE        0x01
#define WRITEABLE       0x02

#define UsagePowerPage  0x84
#define UsageUPS        0x04

// objectification of hid class structures
#define FeatureType     0x01
#define InputType       0x02
#define OutputType      0x03


class CTypeMask  {
public:
    int         GetReportType()     { return ReportType; };
    bool        IsWriteable()       { return bWriteable;};
    bool        IsString()          { return bIsString;};
    bool        IsVolatile()        { return bVolatile;};
    bool        IsNumber()          { return bIsNumber;};
    bool        IsAlertable()       { return bAlertable;};
    void        SetIsWriteable()    { bWriteable = 1; };
    void        SetAlertable()      { bAlertable = 1; };
    void        SetIsString()       { bIsString = 1;};
    void        SetIsNumber()       { bIsNumber = 1;};
    void        SetVolatile()       { bVolatile = 1;};
    void        SetReportType(int iType) { ReportType = iType;};
    CTypeMask();
protected:
    unsigned    ReportType  : 2;
    unsigned    bWriteable  : 1;
    unsigned    bIsString   : 1;
    unsigned    bIsNumber   : 1;
    unsigned    bAlertable  : 1;
    unsigned    bVolatile   : 1;
    unsigned    Pad         : 1;
};


typedef enum {
    eFeatureValue = 1,
    eFeatureButton,
    eInputValue,
    eInputButton,
    eOutputValue,
    eOutputButton
} eHidType;

// forward declarations

class CCollectionArray;
class CHidDevice;
class CUsage;

class CProperties {
public:
    LONG        m_Unit;
    SHORT       m_UnitExponent;
    LONG        m_LogicalMin;
    LONG        m_LogicalMax;
    USHORT      m_LinkCollection;
    USHORT      m_ReportID;
    USHORT      m_Usage;
    USHORT      m_UsagePage;
    CTypeMask * m_pType; // feature, input, or output, writeable, alertable, etc.
// methods
    CProperties(CUsage *);
    ~CProperties();
};

class CUsage {
public: // public members
    CProperties      *  m_pProperties;
    HIDP_BUTTON_CAPS *  m_pButtonCaps;
    HIDP_VALUE_CAPS  *  m_pValueCaps;
    eHidType            m_eType;
    union
    {
        ULONG           m_Value;
        char         *  m_String;
    };
    CHidDevice *        m_pHidDevice;
public: // public methods
    CUsage();
    ~CUsage();
    bool GetValue();
    NTSTATUS GetString(char * pBuffer,USHORT usBuffLen,PULONG BytesReturned);
    void SetCapabilities();
    bool SetValue(ULONG);
    short GetExponent();
    ULONG GetUnit();

};

class CUsagePath {
public: // public members
    USAGE           m_UsagePage;
    USAGE           m_UsageNumber;
    CUsage      *   m_pUsage;
    CUsagePath  *   m_pNextEntry;
public: // public methods
    CUsagePath(USAGE UsagePage, USAGE UsageID, CUsage * pUsage = NULL);
    ~CUsagePath();
};



class CUsageArray {
public: // members
    CUsage                **  m_pUsages;
    USHORT                    m_UsageCount;
public: // methods
    CUsageArray();
    ~CUsageArray();
    void AddUsage(CUsage * pNewUsage);
};

class CCollection {
public: // public methods
    USAGE                   m_CollectionID;
    USAGE                   m_UsagePage;
    CUsageArray         *   m_UsageArray;
    CCollectionArray    *   m_CollectionArray;
    USHORT                  m_NodeIndex;
    CHidDevice *            m_HidDevice;
public: // methods and constructors
    CCollection(PHIDP_LINK_COLLECTION_NODE TheNodes, USHORT usNodeCount,USHORT usParentIndex);
    ~CCollection();
    void InitUsages(CHidDevice *);
    CUsagePath * FindIndexedUsage(USHORT *pCurrIndex, USHORT TargetIndex);
};


class CCollectionArray {
public: // members
    CCollection **        m_pCollections;
    USHORT                m_CollectionCount;

public: // methods
    CCollectionArray(PHIDP_LINK_COLLECTION_NODE TheNodes, USHORT usNodeCount,SHORT sParentIndex);
    ~CCollectionArray();

};

#define MAXREPORTID 256

typedef void (*EVENT_HANDLER)(
                IN PVOID                Context,
                IN CUsage *             pUsage
);

// prototypes for callbacks and completion routines used by CHidDevice class

void _stdcall    ReadThread(PVOID);
NTSTATUS _stdcall ReadCompletionRoutine(
                            PDEVICE_OBJECT,
                            PIRP,
                            PVOID);
class CHidDevice
{
public:
    PHID_DEVICE                 m_pHidDevice;
    PDEVICE_OBJECT              m_pDeviceObject;
    PDEVICE_OBJECT              m_pLowerDeviceObject;
    PDEVICE_OBJECT              m_pOpenedDeviceObject;
    USHORT                      m_UsagePage;
    USHORT                      m_UsageID;
    CCollectionArray *          m_CollectionArray;
    CUsageArray      *          m_InputUsageArrays[MAXREPORTID]; // allowing for 10 input reports
    PBYTE                       m_pReadBuffer;
    PBYTE                       m_FeatureBuffer[MAXREPORTID];
    PVOID                       m_pThreadObject;
    KEVENT                      m_kReadEvent;
    KEVENT                      m_kAbortEvent;
    PHIDP_PREPARSED_DATA        m_pPreparsedData;
    PHIDP_CAPS                  m_pCaps;
    EVENT_HANDLER               m_pEventHandler;
    PVOID                       m_pEventContext;
    PFILE_OBJECT                m_pFCB;                    // file control block for hid class read/write i/o
    PIRP                        m_pReadIrp;

private:
    HANDLE                      m_hEventMutex;
    PBYTE                       m_InputBuffer;
    USHORT                      m_ReportIdArray[MAXREPORTID];

public:
    CHidDevice();
    ~CHidDevice();
    bool            OpenHidDevice(PDEVICE_OBJECT pDeviceObject);
    CUsage *        FindUsage(CUsagePath * Path, USHORT usType);
    NTSTATUS        ActivateInput();
    USHORT          GetIndexFromReportId(USHORT ReportId);
    USHORT          AssignIndexToReportId(USHORT ReportId);

private:
};

#endif // CKHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\devext.h ===
#ifndef _DEVEXT_H
#define _DEVEXT_H

//
// Class device extension.
//

#define REGPATHMAX 100

typedef enum {
    eBaseDevice = 1,
    eBatteryDevice,
    eAdaptorDevice
} EXTENSION_TYPE;



typedef struct _CBatteryDevExt {
    UNICODE_STRING      m_RegistryPath;         // will be converted to a unicode string
    WCHAR               m_RegistryBuffer[REGPATHMAX];
    PDEVICE_OBJECT      m_pHidPdo;

    PDEVICE_OBJECT      m_pBatteryFdo;          // Functional Device Object
    PDEVICE_OBJECT      m_pLowerDeviceObject;   // Detected at AddDevice time
    PFILE_OBJECT        m_pHidFileObject;
    CBattery *          m_pBattery;
    ULONG               m_ulTagCount;           // Tag for next battery
    BOOLEAN             m_bIsStarted;           // if non zero, the device is started
    BOOLEAN             m_bFirstStart;          // Need to differentiate between
                                                // first and second start IRP.
    BOOLEAN             m_bJustStarted;         // If set, will open handle on next
                                                // IRP_MN_QUERY_PNP_DEVICE_STATE
    ULONG               m_ulDefaultAlert1;      // Cache DefaultAlert1 accross stop device.
    PVOID               m_pSelector;            // Selector for battery
    EXTENSION_TYPE      m_eExtType;
    PDEVICE_OBJECT      m_pOpenedDeviceObject;
    PKTHREAD            m_OpeningThread;
    IO_REMOVE_LOCK      m_RemoveLock;
    IO_REMOVE_LOCK      m_StopLock;
    ULONG               m_iHibernateDelay;
    ULONG               m_iShutdownDelay;
} CBatteryDevExt;

#endif // devext.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\ckutils.cpp ===
/*
 * title:      ckUtils.cpp
 *
 * purpose:   misc c-style utility functions
 *
*/

#include "hidbatt.h"

// utils

NTSTATUS
HidBattDoIoctlCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pDoIoCompletedEvent
    )
{

    KeSetEvent((KEVENT *) pDoIoCompletedEvent,0, FALSE);
    return pIrp->IoStatus.Status;

}

ULONG CentiAmpSecsToMilliWattHours(ULONG CentiAmps,ULONG MilliVolts)
{
    // conversion from Centiampsec to millWattHours
    // formula = (amps * volts / 3600) ^ (exponent correction)
    ULONG milliWattHours = CentiAmps;
    milliWattHours /= 100;        // now have ampsec
    milliWattHours *= MilliVolts; // now have milliwattsec
    milliWattHours /= 3600;       // milliwatthours

    HidBattPrint (HIDBATT_DATA, ("CentiAmpSecsToMilliWhatHours: CAs = 0x%08x, mV = 0x%08x, mWH = 0x%08x \n",
                                 CentiAmps, MilliVolts, milliWattHours ));
    return milliWattHours;
}

ULONG milliWattHoursToCentiAmpSecs(ULONG mwHours, ULONG MilliVolts)
{
    // inverse of formula above

    ULONG AmpSecs = mwHours;
    AmpSecs *= 3600;
    AmpSecs /= MilliVolts;
    AmpSecs *= 100;

    HidBattPrint (HIDBATT_DATA, ("MilliWattHoursToCentiAmpSecs: mWH = 0x%08x, mV = 0x%08x, CAs = 0x%08x \n",
                                 mwHours, MilliVolts, AmpSecs ));
    return AmpSecs;
}


// subroutine to take a value, it's exponent and the desired exponent and correct the value
ULONG CorrectExponent(ULONG ulBaseValue, SHORT sCurrExponent, SHORT sTargetExponent)
{
    SHORT sCorrection;
    if(!ulBaseValue) return 0; // done all I can with zero
    sCorrection = sCurrExponent - sTargetExponent;
    if(!sCorrection) return ulBaseValue; // no correction
    if(sCorrection < 0)
    {
        for (; sCorrection < 0; sCorrection++) {
            ulBaseValue /= 10;
        }
        return ulBaseValue;
    } else {
        for (; sCorrection > 0; sCorrection--) {
            ulBaseValue *= 10;
        }
        return ulBaseValue;
    }
}



NTSTATUS
DoIoctl(
            PDEVICE_OBJECT pDeviceObject,
            ULONG ulIOCTL,
            PVOID pInputBuffer,
            ULONG ulInputBufferLength,
            PVOID pOutputBuffer,
            ULONG ulOutputBufferLength,
            CHidDevice * pHidDevice)
{
    IO_STATUS_BLOCK StatusBlock;
    NTSTATUS ntStatus;
    PIRP pIrp = NULL;
    PIO_STACK_LOCATION pNewStack;
    KEVENT IOCTLEvent;

    HIDDebugBreak(HIDBATT_BREAK_DEBUG);
    //CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    KeInitializeEvent(&IOCTLEvent , NotificationEvent, FALSE);
    pIrp = IoBuildDeviceIoControlRequest(
                        ulIOCTL,
                        pDeviceObject,
                        pInputBuffer,
                        ulInputBufferLength,
                        pOutputBuffer,
                        ulOutputBufferLength,
                        FALSE,
                        &IOCTLEvent,
                        &StatusBlock
                        );

    if(!pIrp) return STATUS_NO_MEMORY;
    // stuff file control block if requested (non-null hid device ptr)
    if(pHidDevice)
    {
        pNewStack = IoGetNextIrpStackLocation(pIrp);
        pNewStack->FileObject = pHidDevice->m_pFCB;
    }

    ntStatus = IoCallDriver(pDeviceObject,pIrp);
    if(ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&IOCTLEvent, Executive, KernelMode, FALSE, NULL);
    } else
        if(NT_ERROR(ntStatus)) return ntStatus;

    return StatusBlock.Status;
}

// This is a direct adaption of Ken Ray's function to populate the hid inforation structures

PHID_DEVICE SetupHidData(
                  IN        PHIDP_PREPARSED_DATA pPreparsedData,
                  IN OUT    PHIDP_CAPS pCaps,
                  PHIDP_LINK_COLLECTION_NODE pLinkNodes)
{
    PHID_DEVICE         pHidDevice;
    PHIDP_BUTTON_CAPS   pButtonCaps;
    PHIDP_VALUE_CAPS    pValueCaps;
    PHID_DATA           pHidData;
    int                 iNumValues,i;
    USAGE               usage;


    pHidDevice = (PHID_DEVICE) ExAllocatePoolWithTag(NonPagedPool,sizeof(HID_DEVICE),HidBattTag);
    if(!pHidDevice) return NULL;
    RtlZeroMemory(pHidDevice,sizeof(HID_DEVICE));
    //
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we look for all of the usages in the device.
    //



    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    if(pCaps->NumberInputButtonCaps)
    {
        pHidDevice->InputButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberInputButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        
        if (pButtonCaps) {
          RtlZeroMemory(pButtonCaps,pCaps->NumberInputButtonCaps * sizeof(HIDP_BUTTON_CAPS));
        }
    }
    if(pCaps->NumberInputValueCaps)
    {
        pHidDevice->InputValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberInputValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);

        if (pValueCaps) {
          RtlZeroMemory(pValueCaps, pCaps->NumberInputValueCaps * sizeof (HIDP_VALUE_CAPS));
        }
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    if(pButtonCaps)
    {
        HidP_GetButtonCaps (HidP_Input,
                        pButtonCaps,
                        &pCaps->NumberInputButtonCaps,
                        pPreparsedData);
    }

    if(pValueCaps)
    {
        HidP_GetValueCaps (HidP_Input,
                       pValueCaps,
                       &pCaps->NumberInputValueCaps,
                       pPreparsedData);
    }


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    iNumValues = 0;
    for (i = 0; i < pCaps->NumberInputValueCaps; i++, pValueCaps++) {
        if ((pValueCaps) && (pValueCaps->IsRange)) {
            iNumValues += pValueCaps->Range.UsageMax - pValueCaps->Range.UsageMin + 1;
        } else {
            iNumValues++;
        }
    }


    //
    // setup Output Data buffers.
    //

    if(pCaps->NumberOutputButtonCaps)
    {
        pHidDevice->OutputButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberOutputButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        HidP_GetButtonCaps (HidP_Output,
                            pButtonCaps,
                            &pCaps->NumberOutputButtonCaps,
                            pPreparsedData);
    }
    iNumValues = 0;

    if(pCaps->NumberOutputValueCaps)
    {
        pHidDevice->OutputValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberOutputValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);
        HidP_GetValueCaps (HidP_Output,
                       pValueCaps,
                       &pCaps->NumberOutputValueCaps,
                       pPreparsedData);
        for (i = 0; i < pCaps->NumberOutputValueCaps; i++, pValueCaps++) {
            if (pValueCaps->IsRange) {
                iNumValues += pValueCaps->Range.UsageMax
                           - pValueCaps->Range.UsageMin + 1;
            } else {
                iNumValues++;
            }
        }
    }


    //
    // setup Feature Data buffers.
    //


    if(pCaps->NumberFeatureButtonCaps)
    {
        pHidDevice->FeatureButtonCaps = pButtonCaps = (PHIDP_BUTTON_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberFeatureButtonCaps * sizeof (HIDP_BUTTON_CAPS),HidBattTag);
        RtlZeroMemory(pButtonCaps, pCaps->NumberFeatureButtonCaps * sizeof(HIDP_BUTTON_CAPS));
        HidP_GetButtonCaps (HidP_Feature,
                            pButtonCaps,
                            &pCaps->NumberFeatureButtonCaps,
                            pPreparsedData);
    }
    if(pCaps->NumberFeatureValueCaps)
    {
        pHidDevice->FeatureValueCaps = pValueCaps = (PHIDP_VALUE_CAPS)
            ExAllocatePoolWithTag (NonPagedPool, pCaps->NumberFeatureValueCaps * sizeof (HIDP_VALUE_CAPS),HidBattTag);
        RtlZeroMemory(pValueCaps, pCaps->NumberFeatureValueCaps * sizeof (HIDP_VALUE_CAPS));
        HidP_GetValueCaps (HidP_Feature,
                           pValueCaps,
                           &pCaps->NumberFeatureValueCaps,
                           pPreparsedData);

    }


    iNumValues = 0;
    for (i = 0; i < pCaps->NumberFeatureValueCaps; i++, pValueCaps++) {
        if (pValueCaps->IsRange) {
            iNumValues += pValueCaps->Range.UsageMax
                       - pValueCaps->Range.UsageMin + 1;
        } else {
            iNumValues++;
        }
    }


    return pHidDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\drvclass.cpp ===
/*
 * title:      drvclass.cpp
 *
 * purpose:    Implement C++ utilities
 *
 *
 */

extern "C"
{

#include <ntddk.h>

}

#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *

#include "drvclass.h"

#define HidBattTag 'HtaB'

extern "C" NTSTATUS DriverEntry (DRIVER_OBJECT *, UNICODE_STRING *);

void * __cdecl operator new(size_t nSize, POOL_TYPE iType, ULONG iPoolTag)
{
    return ExAllocatePoolWithTag(iType,nSize,iPoolTag);
};

void __cdecl operator delete(void* p)
{
    ExFreePool(p);
};

// CUString::CUString()
//
// Default constructor.  Creates an empty string.
//
CUString :: CUString()
{

    m_String.MaximumLength = 0;
    m_String.Length = 0;
    m_String.Buffer = NULL;

    m_bType = TYPE_SYSTEM_ALLOCATED;
    m_status = STATUS_SUCCESS;

}

//
// CUString::CUString( CUString& )
//
// Copy constructor
//
CUString :: CUString( CUString * pNewString )
{

/*
    RtlInitUnicodeString( &m_String, NULL );

    m_String.MaximumLength = NewString.m_String.MaximumLength;
    m_String.Length = 0;
    m_String.Buffer = ( unsigned short* )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlZeroMemory( m_String.Buffer, m_String.MaximumLength );
    RtlAppendUnicodeStringToString( &m_String, &NewString.m_String );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_status = STATUS_SUCCESS;
    m_String.Buffer[ m_String.Length ] = NULL;
*/
    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.MaximumLength  = pNewString->m_String.MaximumLength;
    m_String.Length            = pNewString->m_String.Length;
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();
    memcpy( m_String.Buffer, pNewString->m_String.Buffer, m_String.MaximumLength );

}

//
// CUString::CUString( UNICODE_STRING& )
//
// Copy constructor for UNICODE_STRING objects
//
CUString :: CUString( UNICODE_STRING * NewString )
{

/*
    RtlInitUnicodeString( &m_String, NULL );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_String.MaximumLength = NewString.MaximumLength + sizeof( WCHAR );
    m_String.Length = 0;
    m_String.Buffer = ( unsigned short* )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlCopyUnicodeString( &m_String, &NewString );

    m_status = STATUS_SUCCESS;
    m_String.Buffer[ m_String.Length ] = NULL;
*/

    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.MaximumLength    = NewString->Length + sizeof( WCHAR );
    m_String.Length            = NewString->Length;
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    memcpy( m_String.Buffer, NewString->Buffer, m_String.Length );

}

//
// CUString::CUString( PWCHAR )
//
// Copy constructor for WCHAR pointer objects
//
CUString :: CUString( PWCHAR NewString )
{


    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_status                = STATUS_SUCCESS;
    m_String.Length            = ( unsigned short )( Length( NewString ) * sizeof( WCHAR ) );
    m_String.MaximumLength    = m_String.Length + sizeof( WCHAR );
    m_String.Buffer            = ( PWSTR )ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    memcpy( m_String.Buffer, NewString, m_String.Length );

}

//
// CUString::CUString( int )
//
// Constructor which creates an empty string but
// allocates a string buffer of the given size of characters
//
CUString :: CUString( int nSize )
{

    ASSERT( nSize >= 0 );

    m_bType = TYPE_CLASS_ALLOCATED;
    m_String.MaximumLength    = 0;
    m_String.Length            = 0;
    m_String.Buffer            = NULL;

    if( nSize > 0 )
    {

        m_String.MaximumLength = (USHORT)(( nSize + 1 ) * sizeof( WCHAR ));

        if( nSize )
        {

            m_String.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
            if( !m_String.Buffer )
            {

                m_status = STATUS_INSUFFICIENT_RESOURCES;
                return;

            }

            ZeroBuffer();

        }

    }

    m_status = STATUS_SUCCESS;

}

//
// CUString::CUString( UNICODE_STRING& )
//
// Constructor with creates a string that is a representation
// of the given integer and radix.
//
CUString :: CUString( int iVal, int iBase )
{

    m_status                = STATUS_INSUFFICIENT_RESOURCES;
    m_bType                    = TYPE_CLASS_ALLOCATED;
    m_String.Length            = 0;
    m_String.MaximumLength    = 0;
    m_String.Buffer            = NULL;

    int iSize = 1;
    int iValCopy = ( !iVal ) ? 1 : iVal;

    while( iValCopy >= 1 )
    {

        iValCopy /= iBase;
        iSize++;

    };

    //
    // iSize is the number of digits in number, max length of string
    // is iSize plus the null terminator
    //
    m_String.MaximumLength = (USHORT)(( iSize + 1 ) * sizeof( WCHAR ));

    m_String.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, m_String.MaximumLength, HidBattTag );
    ASSERT( m_String.Buffer );

    if( !m_String.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    ZeroBuffer();

    m_status = RtlIntegerToUnicodeString(iVal, iBase, &m_String);

}

//
// CUString::~CUString()
//
// Destructor which frees the string buffer if:
//    1. It exists,
//     and
//  2. It was allocated by the class
//
CUString :: ~CUString()
{

    //
    // If the buffer exists and was allocated by the class, free it.
    //
    if( ( m_bType == TYPE_CLASS_ALLOCATED ) && m_String.Buffer )
    {

        ExFreePool(m_String.Buffer);

    }

}

//
// CUString::Append( CUString& )
//
// Append the given string to the object
//
void CUString :: Append( CUString * Append )
{

    UNICODE_STRING NewString;

    //
    // Determine the length of the new string ( including a null ) and allocate its memory
    //
    NewString.MaximumLength = m_String.Length + Append->m_String.Length + sizeof( WCHAR );
    NewString.Length = 0;
    NewString.Buffer = (PWSTR)ExAllocatePoolWithTag( PagedPool, NewString.MaximumLength, HidBattTag );

    ASSERT( NewString.Buffer );

    //
    // Check for allocation failure.
    //
    if( !NewString.Buffer )
    {

        m_status = STATUS_INSUFFICIENT_RESOURCES;
        return;

    }

    RtlZeroMemory( NewString.Buffer, NewString.MaximumLength );

    //
    // Copy the original string into the new string
    //
    RtlCopyUnicodeString( &NewString, &m_String );

    //
    // Append the 'append' string onto the new string
    //
    NTSTATUS Status = RtlAppendUnicodeStringToString( &NewString, &Append->m_String );

    //
    // If we allocated the original string, free it
    //
    if( m_bType == TYPE_CLASS_ALLOCATED && m_String.Buffer )
    {

        ExFreePool( m_String.Buffer );

    }

    //
    // Copy the new string into the original strings place
    //
    m_String.MaximumLength    = NewString.MaximumLength;
    m_String.Length            = NewString.Length;
    m_String.Buffer            = NewString.Buffer;
    m_bType                    = TYPE_CLASS_ALLOCATED;

    m_status = Status;

}

//
// CUString::Append( UNICODE_STRING* )
//
// Append the given string to the object
//
void CUString :: Append( UNICODE_STRING* pAppendString )
{

    ASSERT( pAppendString );

    if( !pAppendString )
        return;

    CUString AppendString( pAppendString );

    Append( &AppendString );

}
/*
//
// operator + ( UNICODE_STRING&, ULONG& )
//
CUString operator + ( UNICODE_STRING * pUCS, ULONG dwValue )
{

    // This routine is broken for now...don't use...
    ASSERT( 0 );

    CUString ReturnString( pUCS );
    CUString ValueString( dwValue, 10 );

    ReturnString.Append( ValueString );

    return ReturnString;

}

//
// operator + ( CUString&, CUString& )
//
CUString operator + ( CUString& l, CUString& r )
{

    CUString ReturnString( l );
    ReturnString.Append( r );

    return ReturnString;

}

//
// operator + ( UNICODE_STRING&, UNICODE_STRING& )
//
CUString operator + ( UNICODE_STRING& l, UNICODE_STRING& r )
{

    CUString ReturnValue( l );
    CUString Right( r );

    ReturnValue.Append( Right );

    return ReturnValue;

}
*/

//
// operator = ( CUString )
//
void CUString :: operator = ( CUString str )
{

    m_String.Length            = str.m_String.Length;
    m_String.MaximumLength    = str.m_String.MaximumLength;
    m_String.Buffer            = NULL;

    //
    // If the source string has a non-zero length buffer make a buffer of
    // equal size in the destination.
    //
    if( str.m_String.MaximumLength > 0 )
    {

        m_String.Buffer    = (PWSTR)ExAllocatePoolWithTag( PagedPool, str.m_String.MaximumLength, HidBattTag );
        if( !m_String.Buffer )
        {

            m_status = STATUS_INSUFFICIENT_RESOURCES;
            return;

        }

        ZeroBuffer();

        //
        // If the source string has a non-zero length, copy it into the dest string.
        //
        if( str.m_String.Length > 0 )
        {

            memcpy( m_String.Buffer, str.m_String.Buffer, str.m_String.Length );

        }

    }

    m_bType = TYPE_CLASS_ALLOCATED;
    m_status = STATUS_SUCCESS;

}

NTSTATUS CUString :: ToCString( char** pString )
{

    ULONG dwLength = m_String.Length >> 1;

    *pString = ( char* )ExAllocatePoolWithTag( PagedPool, dwLength + 1, HidBattTag );
    if(    !*pString )
        return STATUS_UNSUCCESSFUL;

    char* pDst = *pString;
    char* pSrc = ( char* )m_String.Buffer;

    while( *pSrc )
    {

        *pDst++ = *pSrc;

        pSrc += sizeof( WCHAR );

    }

    *pDst = 0x0;

    return STATUS_SUCCESS;

}

void CUString :: Dump()
{

    char* pString;

    ToCString( &pString );

    KdPrint( ( pString ) );
    KdPrint( ( "\n" ) );

    ExFreePool( pString );

}

ULONG CUString :: Length( PWCHAR String )
{

    ULONG dwLength = 0;

    while( *String++ )
    {

        dwLength++;

    }

    return dwLength;

}

// the registry access class

CRegistry::CRegistry(int iSize)
{ m_status = STATUS_INSUFFICIENT_RESOURCES;
  m_pTable = (PRTL_QUERY_REGISTRY_TABLE)
        ExAllocatePoolWithTag(NonPagedPool,sizeof(RTL_QUERY_REGISTRY_TABLE)*(iSize+1),HidBattTag);
  if(m_pTable)
   {
    m_status = STATUS_SUCCESS;
    RtlZeroMemory(m_pTable,sizeof(RTL_QUERY_REGISTRY_TABLE)*(iSize+1)); //this will terminate the table
   };                                                                  // appropriately

};
CRegistry::~CRegistry()
{
 if (m_pTable) ExFreePool(m_pTable);
};


BOOL CRegistry::QueryDirect(CUString *location,CUString *key, void **pReceiveBuffer, ULONG uType)
{
   ULONG zero = 0;

m_pTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
m_pTable[0].Name = key->m_String.Buffer;
m_pTable[0].EntryContext = *pReceiveBuffer;
m_pTable[0].DefaultType = uType;
m_pTable[0].DefaultData = &zero;
m_pTable[0].DefaultLength = sizeof(ULONG); // there must be something here, but we need to know what...
KdPrint( ( "RegClass QueryDirect:  to retrieve Reg name...\n" ) );
location->Dump();
key->Dump();

if (STATUS_SUCCESS!=
    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,location->m_String.Buffer,m_pTable,NULL,NULL))
  return FALSE;
return TRUE;
};

/*NTSTATUS CRegistry::QueryMustExist( CUString* pwzLocation, CUString* pwzKey, void **pReceiveBuffer )
{
    m_pTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_REQUIRED;
    m_pTable[0].Name         = pwzKey->m_String.Buffer;
    m_pTable[0].EntryContext = *pReceiveBuffer;

    KdPrint( ( "RegClass QueryMustExist(): to retriee Reg name...\n" ) );
    pwzLocation->Dump();
    pwzKey->Dump();

    return RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE, pwzLocation->m_String.Buffer, m_pTable, NULL, NULL );
}
*/

BOOL CRegistry::QueryWithCallback(PRTL_QUERY_REGISTRY_ROUTINE callback,ULONG RelativeTo,PWSTR Path,PVOID Context, PVOID Environment)
{
m_pTable[0].QueryRoutine = callback;
m_pTable[0].Name = NULL;
m_status = RtlQueryRegistryValues(RelativeTo|RTL_REGISTRY_OPTIONAL,Path,m_pTable,Context,Environment);
return NT_SUCCESS(m_status);
};

BOOL CRegistry::WriteString(ULONG relativeTo, CUString *pBuffer, CUString *pPath, CUString *pKey)
{
 return NT_SUCCESS(RtlWriteRegistryValue(relativeTo, pPath->GetString(), pKey->GetString(),REG_SZ,pBuffer->GetString(),pBuffer->GetLength()+sizeof(UNICODE_NULL)));
};

BOOL CRegistry::WriteDWord(ULONG relativeTo, void *pBuffer,CUString *pPath,CUString *pKey)
{
 return NT_SUCCESS(RtlWriteRegistryValue(relativeTo, pPath->GetString(), pKey->GetString(),REG_DWORD,pBuffer,sizeof(REG_DWORD)));
};

NTSTATUS CRegistry::zwOpenKey(HANDLE * pKeyHandle,HANDLE hRoot,ACCESS_MASK DesiredAccess,CUString * pPath)
{
    OBJECT_ATTRIBUTES  ThisObject;
    NTSTATUS status;
    // setup target object for call

    InitializeObjectAttributes( &ThisObject,
                            &(pPath->m_String),
                            OBJ_CASE_INSENSITIVE,
                            hRoot,
                            NULL);

    KdPrint( ( "RESMAN: Opening registry key: " ) );
    pPath->Dump();

    status = ZwOpenKey( pKeyHandle,
                        DesiredAccess,
                        &ThisObject );

    return status;
}

/*
NTSTATUS CRegistry::DeleteKey(HANDLE hTheKey)
{
    return ZwDeleteKey(hTheKey);
}
*/

NTSTATUS CRegistry::zwCreateKey(HANDLE * pKeyHandle,HANDLE hRoot,ACCESS_MASK DesiredAccess,CUString * pPath,ULONG CreateOptions)
{
    OBJECT_ATTRIBUTES  ThisObject;
    NTSTATUS status;
    // setup target object for call

    InitializeObjectAttributes( &ThisObject,
                            &(pPath->m_String),
                            OBJ_CASE_INSENSITIVE,
                            hRoot,
                            NULL);

    KdPrint( ( "RESMAN: Creating registry key:  " ) );
    pPath->Dump();

    status = ZwCreateKey(pKeyHandle,
                            DesiredAccess,
                            &ThisObject,
                            0,
                            NULL,
                            CreateOptions,
                            (ULONG*)&m_lDisposition);
    return status;
}

BOOL CRegistry::zwCloseKey(HANDLE TheKey)
{
    return NT_SUCCESS(ZwClose(TheKey));
}

NTSTATUS CRegistry::zwWriteValue(HANDLE hTheKey,CUString * ValueName,ULONG lType,PVOID pData,ULONG lSize)
{
    NTSTATUS status;
    status  = ZwSetValueKey(hTheKey,
            &ValueName->m_String,
            0,
            lType,
            pData,
            lSize);
    return status;
}

NTSTATUS CRegistry::CheckKey(ULONG RelativeTo ,PUNICODE_STRING puRegKey)
{

//    return (RtlCheckRegistryKey( RelativeTo,(PWSTR)puRegKey));
    return FALSE;
}

// error logging methods
/*
CErrorLogEntry::CErrorLogEntry(PVOID pSource, ULONG errorCode, USHORT dumpDataSize, ULONG uniqueErrorValue,
                    NTSTATUS status, ULONG *dumpData, UCHAR FunctionCode)
{
m_pPacket = (PIO_ERROR_LOG_PACKET)
    IoAllocateErrorLogEntry(pSource, (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)+
                                              (dumpDataSize * sizeof(ULONG))));
if (!m_pPacket) return;
int i;
m_pPacket->ErrorCode = errorCode;
m_pPacket->DumpDataSize = dumpDataSize * sizeof(ULONG);
m_pPacket->SequenceNumber = 0;
m_pPacket->MajorFunctionCode = FunctionCode;
m_pPacket->IoControlCode = 0;
m_pPacket->RetryCount = 0;
m_pPacket->UniqueErrorValue = uniqueErrorValue;
m_pPacket->FinalStatus = status;
for (i = 0; i < dumpDataSize; i++)
   m_pPacket->DumpData[i] = dumpData[i];
IoWriteErrorLogEntry(m_pPacket);
};


CErrorLogEntry::~CErrorLogEntry()
{
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\drvclass.h ===
#ifndef _DRVCLASS_H
#define _DRVCLASS_H

/*
 * title:      drvclass.h
 *
 * purpose:    header for wdm kernel device support class
 *
 */


#define FALSE 0
#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *

//
// CPacket
//
// A ringbuffer "node" class
//
class CPacket
{

// Methods
public:

    USHORT&     Function()  { return m_Function; }
    USHORT&     Socket()    { return m_Socket; }

// Instance variables
private:

    USHORT m_Function;
    USHORT m_Socket;

};

//
// CRingBuffer
//
// A ringbuffer class
//
class CRingBuffer
{

// Construction
public:

    CRingBuffer( ULONG dwSize = 32, POOL_TYPE PoolType = PagedPool );
    ~CRingBuffer();

// Methods
public:
    
    void    Insert( CPacket& APacket );
    BOOL    Remove( CPacket* APacket );
    BOOL    IsEmpty();
    BOOL    IsValid() const { return ( m_pBuffer && m_pListMutex ); }

// Restricted Access Methods
protected:

    void    Lock();
    void    Unlock();

// Instance Variables
private:

    ULONG       m_Producer;
    ULONG       m_Consumer;
    CPacket*    m_pBuffer;

    PKMUTEX     m_pListMutex;
    ULONG       m_dwSize;
        
};

//
// CUString
//
// A class that encapsulates the functionality of
// unicode strings.
//
// Revised on 03-May-96 - JohnT
//
#define OK_ALLOCATED(obj) \
   ((obj!=(void *)0) && NT_SUCCESS((obj)->m_status))

void * __cdecl operator new(size_t nSize, POOL_TYPE iType, ULONG iPoolTag);

void __cdecl operator delete(void* p);

class CUString
{

// Construction
public:

    // new CUString()
    CUString();

    // new CUString( ExistingCUString )
    CUString( CUString * );

    // new CUString( ExistingUnicodeString )
    CUString( UNICODE_STRING *);

    // new CUString( L"String" );
    CUString( PWCHAR );

    // new CUString( nNewLength );
    CUString( int );

    // new CUString( 105, 10 );
    CUString( int, int );

    // Standard destructor
    ~CUString();

// Methods
public:

    // String appending.  Argument is appended to object
    void    Append( CUString * );
    void    Append( UNICODE_STRING* );
                                
    void    CopyTo( CUString* pTarget );

    BOOL    operator == ( CUString& );

    void    operator = ( CUString );

    int     GetLength() const   { return m_String.Length; }
    PWCHAR  GetString()         { return m_String.Buffer; }
    void    SetLength( USHORT i )   { m_String.Length = i; }

    NTSTATUS    ToCString( char** );
    static ULONG        Length( PWCHAR );
    void    Dump();

// Class Methods
protected:

    void    NullTerminate()
    { m_String.Buffer[ m_String.Length / sizeof( WCHAR ) ] = ( WCHAR )NULL; }

    void    ZeroBuffer()
    { ASSERT( m_String.Buffer ); RtlZeroMemory( m_String.Buffer, m_String.MaximumLength ); }

// Enums
public:

    enum
    {
        TYPE_SYSTEM_ALLOCATED = 0,
        TYPE_CLASS_ALLOCATED,
    };


// Instance Variables
public:
    
    UNICODE_STRING  m_String;
    NTSTATUS        m_status;
    unsigned char   m_bType;

};


class CRegistry
{
  private: PRTL_QUERY_REGISTRY_TABLE m_pTable;
  public: NTSTATUS m_status;
          signed long m_lDisposition;
  public: CRegistry(int iSize);
          ~CRegistry();
          BOOL QueryDirect(CUString *location,CUString *key, void **pReceiveBuffer, ULONG uType);
          BOOL QueryWithCallback(PRTL_QUERY_REGISTRY_ROUTINE callback,ULONG RelativeTo,PWSTR Path,PVOID Context, PVOID Environment);
          BOOL WriteString(ULONG relativeTo, CUString *pBuffer, CUString *pPath, CUString *pKey);
          BOOL WriteDWord(ULONG relativeTo, void *pBuffer,CUString *pPath,CUString *pKey);
          NTSTATUS zwCreateKey(HANDLE * pKeyHandle,HANDLE root,ACCESS_MASK DesiredAccess,CUString * pPath,ULONG CreateOptions);
          NTSTATUS zwOpenKey(HANDLE * pKeyHandle, HANDLE root, ACCESS_MASK DesiredAccess,CUString * pPath);
          BOOL zwCloseKey(HANDLE KeyHandle);
          NTSTATUS zwWriteValue(HANDLE hTheKey,CUString * ValueName,ULONG lType,PVOID pData,ULONG lSize);
          NTSTATUS CheckKey(ULONG RelativePath,PUNICODE_STRING path);
};


class CErrorLogEntry
{
  private: PIO_ERROR_LOG_PACKET m_pPacket;
  public: CErrorLogEntry(PVOID,ULONG,USHORT,ULONG,NTSTATUS,ULONG *,UCHAR);
          ~CErrorLogEntry();
};

#endif //drvclass.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\hidbatt.h ===
#ifndef _HIDBATT_H
#define _HIDBATT_H

/*
 * title:      hidpwr.h
 *
 * purpose:    header for wdm kernel client interface between HID class and power class
 *
 */

extern "C"
{
#include <ntddk.h>
#include <batclass.h>
#include <hidpddi.h>
#include <hidclass.h>
}
#define BOOL BOOLEAN
#define BYTE unsigned char
#define PBYTE unsigned char *
extern "C"
{
#include "hid.h"
//#include "hidport.h"
}

#include "drvclass.h"
#include "ckhid.h"
#include "cbattery.h"
#include "devext.h"

extern USHORT gusInstance;
extern USHORT gBatteryTag;

//
// Debug
//
#if DBG
    extern ULONG HidBattDebug;
    extern USHORT HidBreakFlag;
    #define HidBattPrint(l,m)    if(l & HidBattDebug) DbgPrint m
    #define HIDDebugBreak(l) if((l & HidBreakFlag) ) DbgBreakPoint()
#else
    #define HidBattPrint(l,m)
    #define HIDDebugBreak(l)
#endif

#define HidBattTag 'HtaB'

#define PrintIoctl(ioctlCode) \
        DbgPrint( "DevType %x, Access %x, Function %x, Method %x\n", \
            (ioctlCode >> 16), \
            ((ioctlCode & 0xc0) >> 12), \
            ((ioctlCode & 0x1fc) >> 2), \
            (ioctlCode & 0x03) \
            )

#define MGE_VENDOR_ID    0x0463
#define APC_VENDOR_ID    0x051D  // per Jurang Huang



#define HIDBATT_LOW          0x00000001
#define HIDBATT_NOTE         0x00000002
#define HIDBATT_WARN         0x00000004
#define HIDBATT_ERROR_ONLY   0x00000008
#define HIDBATT_ERROR        (HIDBATT_ERROR_ONLY | HIDBATT_WARN)
#define HIDBATT_POWER        0x00000010
#define HIDBATT_PNP          0x00000020
#define HIDBATT_HID_EXE      0x00000040
#define HIDBATT_DATA         0x00000100
#define HIDBATT_TRACE        0x00000200
#define HIDBATT_DEBUG        0x80000000
#define HIDBATT_PRINT_ALWAYS 0xffffffff
#define HIDBATT_PRINT_NEVER  0x0

#define HIDBATT_BREAK_DEBUG  0x0001
#define HIDBATT_BREAK_FULL   0X0002
#define HIDBATT_BREAK_ALWAYS 0xffff
#define HIDBATT_BREAK_NEVER  0x0000

typedef struct {
    ULONG                   Granularity;
    ULONG                   Capacity;

} BATTERY_REMAINING_SCALE, *PBATTERY_REMAINING_SCALE;

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//
#define HidBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }


#define GetTid() PsGetCurrentThread()

//
// Prototypes
//

NTSTATUS DoIoctl(
            PDEVICE_OBJECT pDev,
            ULONG ulIOCTL,
            PVOID pInputBuffer,
            ULONG ulInputBufferLength,
            PVOID pOutputBuffer,
            ULONG ulOutputBufferLength,
            CHidDevice * pHidDevice);




PHID_DEVICE
SetupHidData(
      PHIDP_PREPARSED_DATA pPreparsedData,
      PHIDP_CAPS pCaps,
      PHIDP_LINK_COLLECTION_NODE pLinkNodes);

ULONG CentiAmpSecsToMilliWattHours(ULONG Amps,ULONG Volts);

ULONG milliWattHoursToCentiAmpSecs(ULONG mwHours, ULONG Volts);

// convert a given value from one exponent to another
ULONG CorrectExponent(ULONG ulBaseValue, SHORT sCurrExponent, SHORT sTargetExponent);


extern "C"
{
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
HidBattOpen(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
HidBattClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattIoCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID              pdoIoCompletedEvent
    );

NTSTATUS
HidBattInitializeDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidBattIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
HidBattUnload(
    IN PDRIVER_OBJECT   DriverObject
    );



NTSTATUS
HidBattSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

VOID
HidBattAlarm (
    IN PVOID                Context,
    IN UCHAR                Address,
    IN USHORT               Data
    );


NTSTATUS
HidBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
HidBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
HidBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
HidBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
HidBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
HidBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
HidBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );


NTSTATUS
HidBattSetInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    );

VOID
HidBattNotifyHandler (
    IN PVOID                Context,
    IN CUsage *             pUsage
    );

VOID
HidBattPowerNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

NTSTATUS
HidBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

} // extern "C"

#endif // hidbatt_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\hidbatt.cpp ===
/*
 * title:      hidbatt.c
 *
 * purpose:    wdm kernel client interface between HID class and power class
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * windows 98 support
 *
 */

#include "hidbatt.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif


// Global
ULONG       HidBattDebug        = HIDBATT_PRINT_NEVER;
USHORT      HidBreakFlag        = HIDBATT_BREAK_NEVER;


// local protos
NTSTATUS
HidBattSystemControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{


    NTSTATUS status;

    HidBattPrint (HIDBATT_TRACE, ("HidBatt:DriverEntry\n"));
    HIDDebugBreak(HIDBATT_BREAK_FULL);
    /************************************************************************************/
    /*                                                                                    */
    /*   fill in the slots for the functions in                                            */
    /*   the Driver object.                                                                */
    /*                                                                                    */
    /************************************************************************************/

    DriverObject->MajorFunction[IRP_MJ_CREATE]          = HidBattOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = HidBattClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = HidBattIoControl;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = HidBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = HidBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = HidBattSystemControl;  // pass down to hid class
    DriverObject->DriverUnload                          = HidBattUnload; // this is unloadable with current rev of battery class
    DriverObject->DriverExtension->AddDevice            = HidBattAddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
HidBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       pHidPdo
    )
{

    BOOL bResult;
    PDEVICE_OBJECT          pBatteryFdo = NULL;
    NTSTATUS                ntStatus;
    CBatteryDevExt *        pDevExt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];
    // enters here with pdo of hidclass - power class object

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattAddDevice\n"));


/* sberard - Removed due to changes in hidclass.sys (bug #274422)

    HID_COLLECTION_INFORMATION HidInfo;


    RtlZeroMemory(&HidInfo,sizeof(HID_COLLECTION_INFORMATION));

    ntStatus = DoIoctl(
                pHidPdo,
                IOCTL_HID_GET_COLLECTION_INFORMATION,
                NULL,
                0,
                &HidInfo,
                sizeof(HID_COLLECTION_INFORMATION),
                (CHidDevice *) NULL
                );

    if(NT_ERROR(ntStatus))
    {
        HidBattPrint (HIDBATT_ERROR_ONLY, ("HidBattAddDevice: IOCTL_HID_GET_COLLECTION_INFORMATION failed 0x%08x\n", ntStatus));
        return STATUS_UNSUCCESSFUL;
    }
*/
    // too early to communicate with device, stash hid pdo and complete

    ntStatus = IoCreateDevice(
                DriverObject,
                sizeof (CBatteryDevExt),
                NULL,
                FILE_DEVICE_BATTERY,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &pBatteryFdo
                );

    if (ntStatus != STATUS_SUCCESS) {
        HidBattPrint(HIDBATT_ERROR, ("HidBattCreateFdo: error (0x%x) creating device object\n", ntStatus));
        return(ntStatus);
    }


    // layer the battery pdo to the hid class pdo
    // so that we begin to receive the device irps
    PDEVICE_OBJECT pHidDeviceObject = IoAttachDeviceToDeviceStack(pBatteryFdo,pHidPdo);

    if (!pHidDeviceObject) {
        IoDeleteDevice (pBatteryFdo);
        return STATUS_UNSUCCESSFUL;
    }

    pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    pDevExt->m_RegistryPath.Length = 0;
    pDevExt->m_RegistryPath.MaximumLength = sizeof(pDevExt->m_RegistryBuffer);
    RtlZeroMemory(&pDevExt->m_RegistryBuffer, sizeof(pDevExt->m_RegistryBuffer));
    pDevExt->m_RegistryPath.Buffer = &pDevExt->m_RegistryBuffer[0]; // set buffer pointer
    pDevExt->m_pBattery = NULL;

    pBatteryFdo->Flags              |=  DO_BUFFERED_IO | DO_POWER_PAGABLE;
    pBatteryFdo->Flags              &=  ~DO_DEVICE_INITIALIZING;
    pDevExt->m_pHidPdo              =   pHidPdo;
    pDevExt->m_pBatteryFdo          =   pBatteryFdo;
    pDevExt->m_pLowerDeviceObject   =   pHidDeviceObject;
    pDevExt->m_eExtType             =   eBatteryDevice;
    pDevExt->m_bFirstStart          =   TRUE;
    pDevExt->m_bJustStarted         =   FALSE;
    pDevExt->m_ulDefaultAlert1      =   (ULONG)-1;

    IoInitializeRemoveLock (&pDevExt->m_RemoveLock, HidBattTag, 10, 20);
    IoInitializeRemoveLock (&pDevExt->m_StopLock, HidBattTag, 10, 20);
    IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    IoReleaseRemoveLockAndWait (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return STATUS_SUCCESS;

}


NTSTATUS
HidBattOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp;


    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattOpen\n"));
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    if (NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag))) {
        IoSkipCurrentIrpStackLocation (pIrp);
        ntStatus = IoCallDriver(pDevExt->m_pLowerDeviceObject, pIrp);

        HidBattPrint (HIDBATT_NOTE, ("HidBattOpen: lower driver returned 0x%08x\n", ntStatus));

        IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
    } else {
        ntStatus = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }

    return ntStatus;
}



NTSTATUS
HidBattClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp;

    HidBattPrint (HIDBATT_TRACE, ("HidBattClose\n"));
     // get the device extension
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    HidBattCallLowerDriver(ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);
    HidBattPrint (HIDBATT_NOTE, ("HidBattClose: lower driver returned 0x%08x\n", ntStatus));

    return ntStatus;

}


NTSTATUS
HidBattSystemControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP pIrp
    )
{
    HidBattPrint (HIDBATT_TRACE, ("HidBattSystemControl\n"));
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    // all system control calls are passed down for now.
    NTSTATUS ntStatus = STATUS_SUCCESS;
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;
    HidBattCallLowerDriver(ntStatus,pDevExt->m_pLowerDeviceObject,pIrp);
    return ntStatus;
}


VOID
HidBattUnload(
    IN PDRIVER_OBJECT   pDriverObject
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
// we can just return, no driver-only (non-device) resources were allocated
    return;
}


NTSTATUS
HidBattPnpDispatch(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP                pIrp
    )
{

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    PIO_STACK_LOCATION          pIrpStack;
    CBatteryDevExt *            pDevExt;
    NTSTATUS                    ntStatus;
    BOOLEAN                     lockReleased = FALSE;

//    PAGED_CODE();


    ntStatus = STATUS_NOT_SUPPORTED;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    IoAcquireRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);

    //
    // Dispatch minor function
    //
    switch (pIrpStack->MinorFunction)
    {

        case IRP_MN_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_STOP_DEVICE\n"));
            ntStatus = HidBattStopDevice(pDeviceObject, pIrp);
            break;
        }   // IRP_MN_STOP_DEVICE

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_DEVICE_RELATIONS - type (%d)\n",
                        pIrpStack->Parameters.QueryDeviceRelations.Type));

            break;
        }   //  IRP_MN_QUERY_DEVICE_RELATIONS

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - type (%d)\n",
                        pIrpStack->Parameters.QueryDeviceRelations.Type));

            break;
        }   //  IRP_MN_FILTER_RESOURCE_REQUIREMENTS

        case IRP_MN_REMOVE_DEVICE:

        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_REMOVE_DEVICE\n"));

            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: Waiting to remove\n"));
            IoReleaseRemoveLockAndWait (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
            lockReleased = TRUE;

            // then remove device from device stack
            IoDetachDevice(pDevExt->m_pLowerDeviceObject);

            // delete our device
            IoDeleteDevice(pDeviceObject);

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_REMOVE_DEVICE

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_QUERY_REMOVE_DEVICE:

        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_REMOVE_DEVICE\n"));

            ntStatus = HidBattStopDevice(pDeviceObject, pIrp);

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_REMOVE_DEVICE

        case IRP_MN_START_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_START_DEVICE\n"));
            if (pDevExt->m_bFirstStart) {
                pDevExt->m_bJustStarted = TRUE;
                pDevExt->m_bFirstStart = FALSE;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            // else fall through and do the same thing as the cancel remove.

        }   // IRP_MN_START_DEVICE

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            KEVENT cancelRemoveComplete;

            KeInitializeEvent(&cancelRemoveComplete, SynchronizationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext (pIrp);
            IoSetCompletionRoutine (pIrp, HidBattIoCompletion, &cancelRemoveComplete, TRUE, TRUE, TRUE);
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = IoCallDriver (pDevExt->m_pLowerDeviceObject, pIrp);
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Lower driver status: %08x\n", ntStatus));

            if (ntStatus == STATUS_PENDING) {
                KeWaitForSingleObject (&cancelRemoveComplete, Executive, KernelMode, FALSE, NULL);
                ntStatus = pIrp->IoStatus.Status;
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Lower driver 2nd status: %08x\n", ntStatus));
            }

            if (NT_SUCCESS (ntStatus)) {
                ntStatus = HidBattInitializeDevice (pDeviceObject, pIrp);
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_REMOVE_DEVICE, Our status: %08x\n", ntStatus));
            }

            pIrp->IoStatus.Status = ntStatus;

            IoCompleteRequest (pIrp, IO_NO_INCREMENT);

            IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);

            return ntStatus;
        }   //  IRP_MN_CANCEL_REMOVE_DEVICE

        case IRP_MN_QUERY_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_STOP_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_STOP_DEVICE

        case IRP_MN_CANCEL_STOP_DEVICE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_CANCEL_STOP_DEVICE\n"));
            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_CANCEL_STOP_DEVICE

        case IRP_MN_QUERY_RESOURCES:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_RESOURCES\n"));
            break;
        }   //  IRP_MN_QUERY_RESOURCES

        case IRP_MN_READ_CONFIG:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_READ_CONFIG\n"));
            break;
        }   //  IRP_MN_READ_CONFIG

        case IRP_MN_WRITE_CONFIG:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_WRITE_CONFIG\n"));
            break;
        }   //  IRP_MN_WRITE_CONFIG

        case IRP_MN_EJECT:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_EJECT\n"));
            break;
        }   //  IRP_MN_EJECT

        case IRP_MN_SET_LOCK:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_SET_LOCK\n"));
            break;
        }   //  IRP_MN_SET_LOCK

        case IRP_MN_QUERY_ID:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_ID\n"));
            break;
        }   //  IRP_MN_QUERY_ID

        case IRP_MN_QUERY_CAPABILITIES:
        {
            PDEVICE_CAPABILITIES    deviceCaps;
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_QUERY_CAPABILITIES\n"));

            deviceCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;
            deviceCaps->Removable = TRUE;
            deviceCaps->SurpriseRemovalOK = TRUE;

            ntStatus = STATUS_SUCCESS;
            break;
        }   //  IRP_MN_QUERY_CAPABILITIES

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        {
            HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: IRP_MN_PNP_DEVICE_STATE\n"));

            if (pDevExt->m_bJustStarted == TRUE) {

                pDevExt->m_bJustStarted = FALSE;

                ntStatus = HidBattInitializeDevice (pDeviceObject, pIrp);
            }

            if (!NT_SUCCESS (ntStatus)) {
                HidBattPrint (HIDBATT_PNP, ("HidBattPnpDispatch: HidBattInitializeDevice failed %0x\n", ntStatus));
                pIrp->IoStatus.Information |= PNP_DEVICE_FAILED;
                pIrp->IoStatus.Status = STATUS_SUCCESS;
            }

            break;
        }   //  IRP_MN_PNP_DEVICE_STATE

        default:
        {
            HidBattPrint (HIDBATT_PNP,
                    ("HidBattPnpDispatch: Unimplemented minor %0x\n",
                    pIrpStack->MinorFunction));
            break;
        }
    }

    if (ntStatus != STATUS_NOT_SUPPORTED) {
        pIrp->IoStatus.Status = ntStatus;
    }

    if (NT_SUCCESS(ntStatus) || (ntStatus == STATUS_NOT_SUPPORTED)) {
        HidBattCallLowerDriver (ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);

    } else {
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    }

    if (lockReleased == FALSE) {
        IoReleaseRemoveLock (&pDevExt->m_RemoveLock, (PVOID) HidBattTag);
    }

    return ntStatus;
}


NTSTATUS
HidBattPowerDispatch(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP                pIrp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION            pIrpStack;
    CBatteryDevExt *        pDevExt;
    NTSTATUS                    ntStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

//    PAGED_CODE();

    HidBattPrint ((HIDBATT_TRACE | HIDBATT_POWER), ("HidBattPowerDispatch\n"));

    //
    // Never fail a power IRP, even if we don't do anything.
    //

    ntStatus = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    // this switch currently does no dispatches, and is expanded only for
    // documentary purposes
    switch (pIrpStack->MinorFunction) {

    case IRP_MN_WAIT_WAKE: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
            break;
        }

    case IRP_MN_POWER_SEQUENCE: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

    case IRP_MN_SET_POWER: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_SET_POWER\n"));
            if (pIrpStack->Parameters.Power.Type == SystemPowerState &&
                pIrpStack->Parameters.Power.State.SystemState >= PowerSystemShutdown) {

                if (NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
                {
                    //
                    // Write default RemainingCapcitylimit back to UPS so when the system reboots,
                    // the data returned by the device will be correct.
                    //
                    pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,
                                                     &pDevExt->m_ulDefaultAlert1,TRUE);
                    
                    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
                }
            }
            break;
        }

    case IRP_MN_QUERY_POWER: {
            HidBattPrint (HIDBATT_POWER, ("HidBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
            break;
        }

    default: {

            HidBattPrint(HIDBATT_LOW, ("HidBattPowerDispatch: minor %d\n",
                    pIrpStack->MinorFunction));

            break;
        }
    }

    PoStartNextPowerIrp(pIrp); // inform system we are done with this irp
    IoSkipCurrentIrpStackLocation(pIrp);
    ntStatus = PoCallDriver(pDevExt->m_pLowerDeviceObject,pIrp);

    return ntStatus;
}

NTSTATUS HidBattSetInformation(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    )

{
/*
 Routine Description:

    Called by the class driver to set the battery's charge/discharge state.
    The smart battery does not support the critical bias function of this
    call.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    Level           - Action being asked for

Return Value:

    NTSTATUS

--*/
    // charge and discharge forcing not supported for UPS's
    HidBattPrint (HIDBATT_TRACE, ("HidBattSetInformation\n"));
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hidexe.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user more client sample driver.

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include <hidpddi.h>

//
//

#define DIGCF_FUNCTION  0x00000010
#define DIOD_FUNCTION   0x00000008
#define DIREG_FUNCTION  0x00000008


//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage; // The usage page for which we are looking.
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages; // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
 //  HANDLE               HidDevice; // A file handle to the hid device.
 //  PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
 //  HIDP_CAPS            Caps; // The Capabilities of this hid device.

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;
} HID_DEVICE, *PHID_DEVICE;



BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
CloseHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\hidbattpnp.cpp ===
/*
 * title:      hidbattpnp.cpp
 *
 * purpose:    support for plug and play routines
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * Windows 98 support
 *
 */


#include "hidbatt.h"

NTSTATUS HidBattInitializeDevice (PDEVICE_OBJECT pBatteryFdo, PIRP pIrp)
{

    NTSTATUS            ntStatus;
    CBatteryDevExt *    pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    ULONG               ulBatteryStatus;
    bool                bResult;
    BATTERY_MINIPORT_INFO   BattInit;
    UNICODE_STRING      Name;
    ULONG               ulBufferLength = 0;
    PWCHAR              pBuffer = NULL;
    CBattery *          pBattery;
    PFILE_OBJECT        fileObject;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              fileHandle;
    IO_STATUS_BLOCK     ioStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    HidBattPrint (HIDBATT_PNP, ("HidBattInitializeDevice: Sending Irp (0x%x) to Pdo\n", pIrp));

    // now get file object using KenRay's method from mouclass
    ntStatus = IoGetDeviceProperty (
                     pDevExt->m_pHidPdo,
                     DevicePropertyPhysicalDeviceObjectName,
                     ulBufferLength,
                     pBuffer,
                     &ulBufferLength);
    if(ntStatus != STATUS_BUFFER_TOO_SMALL)
    {
        // only thing we expect with a zero buffer is this error,
        // any other error must be fatal
        return STATUS_UNSUCCESSFUL;
    }


    pBuffer = (PWCHAR) ExAllocatePoolWithTag (NonPagedPool, ulBufferLength, HidBattTag);

    if (NULL == pBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ntStatus =  IoGetDeviceProperty (
                  pDevExt->m_pHidPdo,
                  DevicePropertyPhysicalDeviceObjectName,
                  ulBufferLength,
                  pBuffer,
                  &ulBufferLength);

    if(NT_ERROR(ntStatus))
    {
        ExFreePool(pBuffer);
        return ntStatus;

    }


    Name.MaximumLength = (USHORT) ulBufferLength;
    Name.Length = (USHORT) ulBufferLength - sizeof (UNICODE_NULL);
    Name.Buffer = pBuffer;

    pDevExt->m_OpeningThread = KeGetCurrentThread();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &Name,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    ntStatus = ZwOpenFile( &fileHandle,
                         FILE_ALL_ACCESS,
                         &objectAttributes,
                         &ioStatus,
                         FILE_SHARE_WRITE | FILE_SHARE_READ, 
                         FILE_NON_DIRECTORY_FILE );

    ExFreePool (pBuffer);

    if (NT_SUCCESS( ntStatus )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        ntStatus = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pDevExt->m_pHidFileObject,
                                            NULL );

        ZwClose( fileHandle );
    }

    pDevExt->m_OpeningThread = NULL;
    if(NT_ERROR(ntStatus))
    {
        return ntStatus;
    }

    // now init new hid deviceclass object for this device
    CHidDevice * pHidDevice = new (NonPagedPool, HidBattTag) CHidDevice;  // setup a new hid device

    if (!pHidDevice) {
      HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error allocating CHidDevice"));
      return STATUS_UNSUCCESSFUL;
    }

    pHidDevice->m_pFCB = pDevExt->m_pHidFileObject; // put usable file object into hid device
    pHidDevice->m_pLowerDeviceObject = pDevExt->m_pLowerDeviceObject;
    pHidDevice->m_pDeviceObject = pDevExt->m_pBatteryFdo;
    pHidDevice->m_pReadIrp = NULL;
    bResult = pHidDevice->OpenHidDevice(pDevExt->m_pHidPdo); // initialize the members of this device

    if(!bResult)
    {
        delete pHidDevice;
        return STATUS_UNSUCCESSFUL;
    }

    // check if this has a power page, ups application collection

    if(pHidDevice->m_UsagePage != UsagePowerPage || pHidDevice->m_UsageID != UsageUPS)
    {
        delete pHidDevice;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize Fdo device extension data
    //

    // create the battery object
    pBattery            = new (NonPagedPool, HidBattTag) CBattery(pHidDevice);

    if (!pBattery){
      HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error allocating CBattery"));
      return STATUS_UNSUCCESSFUL;
    }
    
    // and initialize battery values
    // now init in both new and replug states
    pBattery->m_pCHidDevice    = pHidDevice;  // save init'ed hid device object
    bResult = pBattery->InitValues();
    if(!bResult)
    {
        return STATUS_UNSUCCESSFUL;
    }

    // Attach to the Class Driver
    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = pDevExt;
    BattInit.QueryTag            = HidBattQueryTag;
    BattInit.QueryInformation    = HidBattQueryInformation;
    BattInit.SetInformation      = HidBattSetInformation;
    BattInit.QueryStatus         = HidBattQueryStatus;
    BattInit.SetStatusNotify     = HidBattSetStatusNotify;
    BattInit.DisableStatusNotify = HidBattDisableStatusNotify;

    BattInit.Pdo                 = pDevExt->m_pHidPdo;
    BattInit.DeviceName          = NULL;

    pHidDevice->m_pEventHandler = HidBattNotifyHandler;
    pHidDevice->m_pEventContext = (PVOID) pDevExt;

    //
    // save battery in device extension
    // This indicates that we are ready for IO.
    //
    pDevExt->m_pBattery = pBattery;

    //
    // Initialize stop lock
    //
    IoInitializeRemoveLock (&pDevExt->m_StopLock, HidBattTag, 10, 20);

    // and finally we can now start actively polling the device
    // start the read/notification process
    ntStatus = pBattery->m_pCHidDevice->ActivateInput();
    if(!NT_SUCCESS(ntStatus))
    {
        delete pHidDevice;
        HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error (0x%x) in ActivateInput.\n", ntStatus));
        return ntStatus;
    }

    ntStatus = BatteryClassInitializeDevice (&BattInit, &pBattery->m_pBatteryClass);
    if (!NT_SUCCESS(ntStatus))
    {
        //
        //  if we can't attach to class driver we're toast
        //
        delete pHidDevice;
        HidBattPrint(HIDBATT_ERROR, ("HidBattInitializeDevice: error (0x%x) registering with class\n", ntStatus));
        return ntStatus;
    }

    HidBattPrint(HIDBATT_TRACE, ("HidBattInitializeDevice: returned ok\n"));
    return ntStatus;
}



NTSTATUS
HidBattStopDevice(
    IN PDEVICE_OBJECT pBatteryFdo,
    IN PIRP           pIrp
    )
/*++

Routine Description:

    This routine is called when we receive a IRP_MN_STOP_DEVICE. It just sends the
    request down the chain of drivers to the Pdo and waits for a response.

Arguments:

    Fdo - a pointer to the fdo for this driver
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pBatteryFdo->DeviceExtension;
    KEVENT              pdoStoppedEvent;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    NTSTATUS            ntStatus;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint ((HIDBATT_TRACE | HIDBATT_PNP), ("HidBattStopDevice\n"));

    if (!NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
        //
        // Don't release twice.
        //
        return STATUS_SUCCESS;
    }

    pDevExt->m_bJustStarted = FALSE;

    HidBattPrint (HIDBATT_PNP, ("HidBattStopDevice: Waiting to remove\n"));
    IoReleaseRemoveLockAndWait (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pBatteryClass) {
        BatteryClassUnload(pDevExt->m_pBattery->m_pBatteryClass);
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp) {
        IoCancelIrp (pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp);
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject) {

        //
        // Clean up worker thread.
        //

        KeWaitForSingleObject (
               pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject,
               Executive,
               KernelMode,
               FALSE,
               NULL
               );
        HidBattPrint (HIDBATT_PNP, ("HidBattStopDevice: Done Waiting to remove\n"));

        ObDereferenceObject (pDevExt->m_pBattery->m_pCHidDevice->m_pThreadObject);
    } else {
        return STATUS_UNSUCCESSFUL;
        // If we can't be sure the Read Thread has terminated, it is unsafe to
        // stop or remove the device.  This may cause a reboot to be needed.
    }

    if (pDevExt->m_pBattery && pDevExt->m_pBattery->m_pCHidDevice &&
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp) {
        IoFreeIrp(pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp); // clean up irp
        pDevExt->m_pBattery->m_pCHidDevice->m_pReadIrp = NULL;
    }

    //
    // Write default RemainingCapcitylimit back to UPS so the next time we enumerate
    // the device, we'll read back the right data.
    //
    pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,
                                     &pDevExt->m_ulDefaultAlert1,TRUE);

    // dereference our file object, if present
    if(pDevExt->m_pHidFileObject) {
        ObDereferenceObject(pDevExt->m_pHidFileObject);
        pDevExt->m_pBattery->m_pCHidDevice->m_pFCB = NULL;
    }


    if (pDevExt->m_pBattery) {
        delete pDevExt->m_pBattery;
        pDevExt->m_pBattery = NULL;
    }

    ntStatus = STATUS_SUCCESS;

    pDevExt->m_bIsStarted = FALSE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\inc\hctioctl.h ===
/****************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hctioctl.h

Abstract:

	This header file is used both by ring3 app and ring0 driver.

Environment:

    Kernel & user mode

Revision History:

    8-20-96 : created

****************************************************************************/


//
//Values for IOCTL_ACPI_GET_CAPABILITIES
//
#define		SYSTEM_S1_BIT		0
#define		SYSTEM_S1			(1 << SYSTEM_S1_BIT)

#define		SYSTEM_S2_BIT		1
#define		SYSTEM_S2			(1 << SYSTEM_S2_BIT)

#define		SYSTEM_S3_BIT		2
#define		SYSTEM_S3			(1 << SYSTEM_S3_BIT)

#define   CPU_C1_BIT      3
#define   CPU_C1        (1 << CPU_C1_BIN)

#define		CPU_C2_BIT			4
#define		CPU_C2				(1 << CPU_C2_BIT)

#define		CPU_C3_BIT			5
#define		CPU_C3				(1 << CPU_C3_BIT)


//
//Processor States
//
#define		CPU_STATE_C1				1
#define		CPU_STATE_C2				2
#define		CPU_STATE_C3				3


//
//Fan States
//
#define		FAN_OFF							0
#define		FAN_ON							1



//
// IOCTL info
//
	
#define ACPIHCT_IOCTL_INDEX  80


//
//The input buffer must contain a ULONG pointer to one of the
//  SYSTEM_POWER_STATE enum values.
//
#define IOCTL_ACPI_SET_SYSTEM_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+0,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to one of the
//	Processor States.
//
#define IOCTL_ACPI_SET_PROCESSOR_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+1,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to on of the Fan
//	States.
//
#define IOCTL_ACPI_SET_FAN_STATE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+2,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The output buffer must contain a ULONG pointer.  The ACPI driver will
//	fill this buffer with the capabilities of the machine.
//
#define IOCTL_ACPI_GET_CAPABILITIES CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+3,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The input buffer must contain a ULONG pointer to a percentage (a
//	number between 1 and 100).
//
#define IOCTL_ACPI_SET_CPU_DUTY_CYCLE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+4,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)



//
//The input buffer must contain a point to a TIME_FIELDS structure
//
#define IOCTL_ACPI_SET_RTC_WAKE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+5,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)


//
//The output buffer points to a structure that will receive a 
//  TIME_FIELDS structure
//
#define IOCTL_ACPI_GET_RTC_WAKE CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	ACPIHCT_IOCTL_INDEX+6,  \
                               	    METHOD_BUFFERED,     \
                                   	FILE_ANY_ACCESS)
                                    
#define IOCTL_ACPI_GET_TEMPERATURE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                           	       	    ACPIHCT_IOCTL_INDEX+7,  \
                               	        METHOD_BUFFERED,     \
                                   	    FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\hidbatt\hidbattio.cpp ===
/*
 * title:      HidBattIOCT.cpp
 *
 * purpose:    Contains misc ioctl handlers for status and query info mainly
 *
 * Initial checkin for the hid to battery class driver.  This should be
 * the same for both Win 98 and NT 5.  Alpha level source. Requires
 * modified composite battery driver and modified battery class driver for
 * Windows 98 support
 *
 */


#include "hidbatt.h"


/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
NTSTATUS
HidBattIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
{
    NTSTATUS            ntStatus = STATUS_NOT_SUPPORTED;
    CBatteryDevExt *    pDevExt;
    PIO_STACK_LOCATION  irpSp;
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    irpSp = IoGetCurrentIrpStackLocation(pIrp);
    HidBattPrint (HIDBATT_TRACE, ("HidBattIoctl = %x\n", irpSp->Parameters.DeviceIoControl.IoControlCode));

//    PrintIoctl(irpSp->Parameters.DeviceIoControl.IoControlCode);

    pDevExt = (CBatteryDevExt *) pDeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)))
    {
        if (pDevExt->m_pBattery &&
            pDevExt->m_pBattery->m_pBatteryClass) {
            ntStatus = BatteryClassIoctl (pDevExt->m_pBattery->m_pBatteryClass, pIrp);
        }
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    } else {
        ntStatus = STATUS_DEVICE_REMOVED;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    }

    if (ntStatus == STATUS_NOT_SUPPORTED)
    {
        HidBattCallLowerDriver(ntStatus, pDevExt->m_pLowerDeviceObject, pIrp);
    }

    return ntStatus;
}

VOID
HidBattNotifyHandler (
    IN PVOID        pContext,
    IN CUsage *        pUsage
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    NTSTATUS ntStatus;
    ULONG ulCapacityLimit = BATTERY_UNKNOWN_CAPACITY;
    BOOL bResult;

    HidBattPrint (HIDBATT_TRACE, ("HidBattNotifyHandler\n"));
    // called by input routine whenever a value change is noted to
    // a notificable usage
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;

    HidBattPrint (HIDBATT_DATA, ("HidBattNotifyHandler: Usage: %x\n", pUsage->m_pProperties->m_Usage));
    switch (pUsage->m_pProperties->m_Usage)
    {
        case    REMAINING_CAPACITY_ID:

          bResult = pDevExt->m_pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulCapacityLimit,FALSE);
          // Only send notification when capacity drops below notify level.
          if ((bResult) && (ulCapacityLimit != BATTERY_UNKNOWN_CAPACITY) && (pUsage->m_Value != BATTERY_UNKNOWN_CAPACITY)
              && (pUsage->m_Value > ulCapacityLimit)) {
               HidBattPrint (HIDBATT_TRACE, ("HidBattNotifyHandler:Suppressing notify\n"));
               break;
          }

        case    AC_PRESENT_ID:            // check for battery off/on line
        case    DISCHARGING_ID:
        case    CHARGING_ID:
        case    BELOW_REMAINING_CAPACITY_ID:
        case    SHUTDOWN_IMMINENT_ID:
        {
            pDevExt->m_pBattery->m_bIsCacheValid=FALSE;

            if (NT_SUCCESS (IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag))) {
                ntStatus = BatteryClassStatusNotify(
                        pDevExt->m_pBattery->m_pBatteryClass);
                IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
            }
            break;
        }
        default:  // nothing to notify
            break;
    }


    return;
}

NTSTATUS
HidBattQueryTag (
    IN PVOID                pContext,
    OUT PULONG              pulBatteryTag
    )
{

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    *pulBatteryTag =     pDevExt->m_pBattery->m_Tag;

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
    return STATUS_SUCCESS;
}


NTSTATUS
HidBattSetStatusNotify (
    IN PVOID                pContext,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      pBatteryNotify
    )
{
    bool bResult;
    ULONG CentiAmpSec;
    ULONG ulValue;
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    HidBattPrint (HIDBATT_TRACE, ("HidBattSetStatusNotify \n"));
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;
    CBattery * pBattery = pDevExt->m_pBattery;


    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->PowerState   = %x\n", pBatteryNotify->PowerState));    
    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->LowCapacity  = %x\n", pBatteryNotify->LowCapacity));    
    HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify->HighCapacity = %x\n", pBatteryNotify->HighCapacity));    

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)))
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    if (pBattery->m_Tag != BatteryTag) {
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((pBatteryNotify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (pBatteryNotify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        HidBattPrint (HIDBATT_DEBUG, ("HidBattSetStatusNotify failing because of BATTERY_UNKNOWN_CAPACITY.\n"));
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NOT_SUPPORTED;
    }

    // first check for relative or absolute
    if(pBattery->m_bRelative)
    {
        ulValue = pBatteryNotify->LowCapacity; // done
    } else
    {
        // first check if setting to zero so that can skip below formula
        if(pBatteryNotify->LowCapacity == 0)
        {
            ulValue = 0;
        } else
        {
            // first must covert value to whatever is being used by this HID device.
            // currently we assume either MilliVolts consistant with battery class or
            // AmpSecs consistant with power spec
            ULONG ulUnit = pBattery->GetUnit(REMAINING_CAPACITY_INDEX);
            if(ulUnit)
            {
                short    sExponent;
                ULONG    lMilliVolts;
                long     milliWattHours,CentiWattHours,CentiWattSecs;

                sExponent = pBattery->GetExponent(REMAINING_CAPACITY_INDEX);

                // conversion from millWattHours to AmpSecs
                // formula = mWHs / 1000 / 3600 / volts ^ exponent correction
                lMilliVolts =  pBattery->m_BatteryStatus.Voltage; // stored as MilliVolts

                if (lMilliVolts == 0) {
                    HidBattPrint (HIDBATT_ERROR,
                                  ("HidBattSetStatusNotify: Error: voltage = 0, fudging with 24V.\n"));
                    lMilliVolts = 24000;
                }
                milliWattHours = pBatteryNotify->LowCapacity;
                CentiWattHours = milliWattHours /10;
                CentiWattSecs = CentiWattHours / 3600;
                CentiAmpSec = (CentiWattSecs *1000)/ lMilliVolts;
                ulValue = CorrectExponent(CentiAmpSec,-2,sExponent);
            } else
            {
                ulValue = pBatteryNotify->LowCapacity;
            }
        } // end if LowCapacity
    }  // end if relative
    // now set low
    bResult = pBattery->GetSetValue(REMAINING_CAPACITY_LIMIT_INDEX,&ulValue,TRUE);

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return bResult ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
HidBattDisableStatusNotify (
    IN PVOID pContext
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt * pDevExt = (CBatteryDevExt *) pContext;
    pDevExt->m_pBattery->m_pBatteryNotify = NULL;  // remove notify procedure
    return STATUS_SUCCESS;
}


/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/

NTSTATUS
HidBattQueryStatus (
    IN PVOID                pContext,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     pBatteryStatus
    )
{
    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);
    CBatteryDevExt *   pDevExt = (CBatteryDevExt *) pContext;
    NTSTATUS    ntStatus;

    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryStatus - Tag (%d)\n",
                    BatteryTag));

    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((BatteryTag == BATTERY_TAG_INVALID) || (pDevExt->m_pBattery->m_Tag == BATTERY_TAG_INVALID)) {
        ntStatus = STATUS_NO_SUCH_DEVICE;
    } else {

        RtlZeroMemory (pBatteryStatus, sizeof(BATTERY_STATUS));
        ntStatus = pDevExt->m_pBattery->RefreshStatus();
        if (NT_SUCCESS(ntStatus)) {
            RtlCopyMemory (pBatteryStatus, &pDevExt->m_pBattery->m_BatteryStatus, sizeof(BATTERY_STATUS));
            HidBattPrint (HIDBATT_DATA, ("HidBattQueryStatus - Data (%08x)(%08x)(%08x)(%08x)\n",
                                         pBatteryStatus->PowerState,
                                         pBatteryStatus->Capacity,
                                         pBatteryStatus->Rate,
                                         pBatteryStatus->Voltage ));

        } else {
            ntStatus = STATUS_NO_SUCH_DEVICE;
            HidBattPrint (HIDBATT_DATA, ("HidBattQueryStatus - Error\n" ));
        }
    }

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return ntStatus;

}


/*++

Routine Description:

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Optional Parameter
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/

NTSTATUS
HidBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN LONG                             AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
{

    CBatteryDevExt * pDevExt = (CBatteryDevExt *) Context;
    ULONG               ulResult;
    NTSTATUS            ntStatus;
    PVOID               pReturnBuffer;
    ULONG               ulReturnBufferLength;
    WCHAR               scratchBuffer[MAX_BATTERY_STRING_SIZE];
    WCHAR               buffer2[MAX_BATTERY_STRING_SIZE];
    UNICODE_STRING      tmpUnicodeString;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    bool                bResult;
    BATTERY_REMAINING_SCALE     ScalePtr[2];
    ULONG                ulReturn,ulNewValue;
    ULONG                ulEstTimeStub = 5;

    HIDDebugBreak(HIDBATT_BREAK_ALWAYS);

    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Tag (%d)\n",
                    BatteryTag));


    if (!NT_SUCCESS(IoAcquireRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag)) )
    {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If caller has the wrong ID give an error
    //

    if (BatteryTag == BATTERY_TAG_INVALID ||
        pDevExt->m_pBattery->m_Tag == BATTERY_TAG_INVALID ||
        BatteryTag != pDevExt->m_pBattery->m_Tag)
    {
        IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);
        return STATUS_NO_SUCH_DEVICE;
    }

    ulResult = 0;
    pReturnBuffer = NULL;
    ulReturnBufferLength = 0;
    ntStatus = STATUS_SUCCESS;
    CUString cUniqueID;
    SHORT    sExponent;
    char * pTemp;
    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            //
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Battery Info\n"));
            pReturnBuffer = (PVOID) &pDevExt->m_pBattery->m_BatteryInfo;
            ulReturnBufferLength = sizeof (pDevExt->m_pBattery->m_BatteryInfo);
            break;

        case BatteryGranularityInformation:
            //
            //  Get the granularity from the static info structure
            //  This data structure is populated by CmBattVerifyStaticInfo
            //
            {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Granularity\n"));
                bResult = pDevExt->m_pBattery->GetSetValue(GRANULARITY1_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(GRANULARITY1_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }

                ScalePtr[0].Granularity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(GRANULARITY2_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(GRANULARITY2_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[1].Granularity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(WARNING_CAPACITY_LIMIT_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(WARNING_CAPACITY_LIMIT_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[0].Capacity = bResult ? ulReturn : 0;
                bResult = pDevExt->m_pBattery->GetSetValue(DESIGN_CAPACITY_INDEX, &ulReturn,FALSE);
                if(!pDevExt->m_pBattery->m_bRelative)
                {
                    // convert from amps to watts
                    sExponent = pDevExt->m_pBattery->GetExponent(DESIGN_CAPACITY_INDEX);
                    ulNewValue = CorrectExponent(ulReturn,sExponent,-2);
                    ulReturn= CentiAmpSecsToMilliWattHours(ulNewValue,pDevExt->m_pBattery->m_BatteryStatus.Voltage);
                }
                ScalePtr[1].Capacity = bResult ? ulReturn : 0;

                pReturnBuffer        = ScalePtr;
                ulReturnBufferLength  = 2 * sizeof (BATTERY_REMAINING_SCALE);
            }
            break;

        case BatteryTemperature:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Temperature\n"));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case BatteryEstimatedTime:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Estimated time\n"));
            bResult = pDevExt->m_pBattery->GetSetValue(RUNTIME_TO_EMPTY_INDEX, &ulReturn,FALSE);

            if(!bResult)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            } else
            {
                SHORT exponent;

                exponent = pDevExt->m_pBattery->GetExponent(RUNTIME_TO_EMPTY_INDEX);
                ulReturn = CorrectExponent (ulReturn, exponent, 0);

                pReturnBuffer = &ulReturn;
                ulReturnBufferLength = sizeof (ULONG);
            }
            break;

        case BatteryDeviceName:
            //
            // Model Number must be returned as a wide string
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Device Name\n"));
            if(pDevExt->m_pBattery->m_pProduct)
            {
                pReturnBuffer = pDevExt->m_pBattery->m_pProduct->m_String.Buffer;
                ulReturnBufferLength = pDevExt->m_pBattery->m_pProduct->m_String.Length;
            }
            break;

        case BatteryManufactureDate:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Mfr Date\n"));
            if(!pDevExt->m_pBattery->m_ManufactureDate.Day)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            pReturnBuffer = &pDevExt->m_pBattery->m_ManufactureDate;
            ulReturnBufferLength = sizeof(pDevExt->m_pBattery->m_ManufactureDate);
            break;

        case BatteryManufactureName:
            //
            // Oem Info must be returned as wide string
            //
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Mfr Name\n"));
            if(pDevExt->m_pBattery->m_pManufacturer)
            {
                pReturnBuffer = pDevExt->m_pBattery->m_pManufacturer->m_String.Buffer;
                ulReturnBufferLength = pDevExt->m_pBattery->m_pManufacturer->m_String.Length;
            }

            break;

        case BatteryUniqueID:
            //
            //  Concatenate the serial #, manufacturer name, and Product           //



             // start off with serial number
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Unique ID\n"));
            if(pDevExt->m_pBattery->m_pSerialNumber) {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Serial = %s\n", pDevExt->m_pBattery->m_pSerialNumber));

                cUniqueID.Append(pDevExt->m_pBattery->m_pSerialNumber);
            } else {
                HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Serial = NULL\n"));
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"1000");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            if(pDevExt->m_pBattery->m_pManufacturer)
                cUniqueID.Append(pDevExt->m_pBattery->m_pManufacturer); // add mfr name
            else
            {
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"Mfr");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            if(pDevExt->m_pBattery->m_pProduct)
                cUniqueID.Append(pDevExt->m_pBattery->m_pProduct); // add Product
            else
            {
                CUString * pSTemp = new (NonPagedPool, HidBattTag) CUString(L"Prod");
                if (pSTemp) {
                  cUniqueID.Append(pSTemp);
                  delete pSTemp;
                }
            }
            pReturnBuffer = cUniqueID.m_String.Buffer;
            ulReturnBufferLength = cUniqueID.m_String.Length;
            break;
        default:
            HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Default\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //

    *ReturnedLength = ulReturnBufferLength;
    if (BufferLength < ulReturnBufferLength) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(ntStatus) && pReturnBuffer) {
        RtlCopyMemory (Buffer, pReturnBuffer, ulReturnBufferLength);   // Copy what's needed
    }


    HidBattPrint (HIDBATT_TRACE, ("HidBattQueryInformation - Status = %08x  Buffer = %08x\n", ntStatus, *(PULONG)Buffer));

    IoReleaseRemoveLock (&pDevExt->m_StopLock, (PVOID) HidBattTag);

    return ntStatus;
}



NTSTATUS
HidBattIoCompletion(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pdoIoCompletedEvent
    )
{
    HidBattPrint (HIDBATT_TRACE, ("HidBattIoCompletion\n"));
    KeSetEvent((KEVENT *) pdoIoCompletedEvent,0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\inc\acpimsft.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    acpimsft

Abstract:

    This module controls all of the Microsoft specific (ie: not exported to
    anyone outside the company) structures, IOCTLS, and Defines.

    This file is included after acpiioct.h

Author:

Environment:

    NT Kernel Model Driver only

--*/

#ifndef _ACPIMSFT_H_
#define _ACPIMSFT_H_

#ifndef _ACPIIOCT_H_
#error Need to include ACPIIOCT.H before ACPIMSFT.H
#endif

//
// IRP_MJ_INTERNAL_DEVICE_CONTROL CODES
//
#define IOCTL_ACPI_REGISTER_OPREGION_HANDLER    CTL_CODE(FILE_DEVICE_ACPI, 0x2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER  CTL_CODE(FILE_DEVICE_ACPI, 0x3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Make sure that we define the right calling convention
//
#ifdef EXPORT
  #undef EXPORT
#endif
#define EXPORT  __cdecl

//
// Data structures used for IOCTL_ACPI_REGISTER_OPREGION
//                          IOCTL_ACPI_UNREGISTER_OPREGION
//
typedef NTSTATUS (EXPORT *PACPI_OPREGION_HANDLER)();
typedef VOID (EXPORT *PACPI_OPREGION_CALLBACK)();

typedef struct _ACPI_REGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    ULONG                   AccessType;
    ULONG                   RegionSpace;
    PACPI_OPREGION_HANDLER  Handler;
    PVOID                   Context;
} ACPI_REGISTER_OPREGION_HANDLER_BUFFER, *PACPI_REGISTER_OPREGION_HANDLER_BUFFER;

typedef struct _ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    PVOID                   OperationRegionObject;
} ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER,*PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER;

//
// Signatures for Register, Unregister of OpRegions
//
#define ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE     'HorA'
#define ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE   'HouA'

//
// Access types for OpRegions
//
#define ACPI_OPREGION_ACCESS_AS_RAW                         0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED                      0x2

//
// Allowable region spaces
//
#define ACPI_OPREGION_REGION_SPACE_MEMORY                   0x0
#define ACPI_OPREGION_REGION_SPACE_IO                       0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG               0x2
#define ACPI_OPREGION_REGION_SPACE_EC                       0x3
#define ACPI_OPREGION_REGION_SPACE_SMB                      0x4
#define ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG              0x5
#define ACPI_OPREGION_REGION_SPACE_PCIBARTARGET             0x6

//
// Operation to perform on region
//
#define ACPI_OPREGION_READ                                  0x0
#define ACPI_OPREGION_WRITE                                 0x1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\inc\smb.h ===
// Warning, this file is going away.
// It has been replaced with smbus.h which has been added to the DDK

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smb.h

Abstract:

    SMBus Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// SMB Request packet
//

#define SMB_MAX_DATA_SIZE   32

typedef struct {
    UCHAR       Status;             // Completion status
    UCHAR       Protocol;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       BlockLength;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// Protocol values
//

#define SMB_WRITE_QUICK                 0x00    // Issue quick command data bit = 0
#define SMB_READ_QUICK                  0x01    // Issue quick command data bit = 1
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0A
#define SMB_MAXIMUM_PROTOCOL            0x0A

//
// SMB Bus Status codes
//

#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1A

//
// Alarm register/deregister requests
//

typedef
VOID
(*SMB_ALARM_NOTIFY) (
    PVOID       Context,
    UCHAR       Address,
    USHORT      Data
    );

// input buffer is SMB_REGISTER_ALARM.  output buffer is PVOID handle for registration.
// PVOID is passed in via DEREGISTER request to free registration

typedef struct {
    UCHAR               MinAddress;     // Min address for notifications
    UCHAR               MaxAddress;     // Max address for notifications
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

//
// Internal ioctls to SMB class driver
//

#define SMB_BUS_REQUEST             CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_REGISTER_ALARM_NOTIFY   CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_DEREGISTER_ALARM_NOTIFY CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Shared SMB Class / Miniport driver structure
//

typedef
NTSTATUS
(*SMB_RESET_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
VOID
(*SMB_START_IO)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
NTSTATUS
(*SMB_STOP_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );



typedef struct _SMB_CLASS {
    USHORT              MajorVersion;
    USHORT              MinorVersion;

    PVOID               Miniport;           // Miniport extension data

    PDEVICE_OBJECT      DeviceObject;       // Device object for this miniport
    PDEVICE_OBJECT      PDO;                // PDO for this miniport
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Current IO
    //

    PIRP                CurrentIrp;         // current request
    PSMB_REQUEST        CurrentSmb;         // pointer to SMB_REQUEST in the CurrentIrp

    //
    // Miniport functions
    //

    SMB_RESET_DEVICE    ResetDevice;        // Initialize/Reset, start device
    SMB_START_IO        StartIo;            // Perform IO
    SMB_STOP_DEVICE     StopDevice;         // Stop device

} SMB_CLASS, *PSMB_CLASS;

#define SMB_CLASS_MAJOR_VERSION     0x0001
#define SMB_CLASS_MINOR_VERSION     0x0000

//
// Class driver initializtion functions
//

#if !defined(SMBCLASS)
    #define SMBCLASSAPI DECLSPEC_IMPORT
#else
    #define SMBCLASSAPI
#endif


typedef
NTSTATUS
(*PSMB_INITIALIZE_MINIPORT) (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SMBCLASSAPI
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SMBCLASSAPI
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

//
// Class driver interface functions for use by the miniport
//

VOID
SMBCLASSAPI
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    );


VOID
SMBCLASSAPI
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    );


VOID
SMBCLASSAPI
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    );

VOID
SMBCLASSAPI
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\inc\ec.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ec.h

Abstract:

    Embedded Controller Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/


//
// Internal ioctls to EC driver
//

#define EC_CONNECT_QUERY_HANDLER    CTL_CODE(FILE_DEVICE_UNKNOWN, 5, METHOD_NEITHER, FILE_ANY_ACCESS)
#define EC_DISCONNECT_QUERY_HANDLER CTL_CODE(FILE_DEVICE_UNKNOWN, 6, METHOD_NEITHER, FILE_ANY_ACCESS)
#define EC_GET_PDO                  CTL_CODE(FILE_DEVICE_UNKNOWN, 7, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef
VOID
(*PVECTOR_HANDLER) (
    IN ULONG            QueryVector,
    IN PVOID            Context
    );

typedef struct {
    ULONG               Vector;
    PVECTOR_HANDLER     Handler;
    PVOID               Context;
    PVOID               AllocationHandle;
} EC_HANDLER_REQUEST, *PEC_HANDLER_REQUEST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\inc\batt.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    batt.h

Abstract:

    Battery Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// Initialization structure
//

typedef
NTSTATUS
(*BCLASS_QUERY_TAG)(
    IN PVOID Context,
    OUT PULONG BatteryTag
    );

typedef
NTSTATUS
(*BCLASS_QUERY_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN ULONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    );

typedef
NTSTATUS
(*BCLASS_QUERY_STATUS)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    );

typedef
NTSTATUS
(*BCLASS_SET_STATUS_NOTIFY)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    );

typedef
NTSTATUS
(*BCLASS_DISABLE_STATUS_NOTIFY)(
    IN PVOID Context
    );

#define BATTERY_CLASS_MAJOR_VERSION     0x0001
#define BATTERY_CLASS_MINOR_VERSION     0x0000


//
// Class driver functions
//

#if !defined(BATTERYCLASS)
    #define BATTERYCLASSAPI DECLSPEC_IMPORT
#else
    #define BATTERYCLASSAPI
#endif


NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\oprghdlr\oprghdlr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    oprghdlr.c

Abstract:

    This module contains the code that implements ACPI op region 
    registration DLL

Author:

    Vincent Geglia (vincentg) 09-Feb-2000

Environment:

    Kernel mode

Notes:

    
Revision History:


--*/

//
// Standard includes
//

#include "stdarg.h"
#include "stdio.h"
#include "wdm.h"

//
// Oprghdlr dll specific includes
//

#include "oprghdlr.h"

//
// Definitions / static definitions
//

#define DEBUG_INFO      1
#define DEBUG_WARN      2
#define DEBUG_ERROR     4

static const UCHAR DebugPrepend[] = {'O', 'P', 'R', 'G', 'H', 'D', 'L', 'R', ':'};

//
// IRP_MJ_INTERNAL_DEVICE_CONTROL CODES
//

#define IOCTL_ACPI_REGISTER_OPREGION_HANDLER    CTL_CODE(FILE_DEVICE_ACPI, 0x2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER  CTL_CODE(FILE_DEVICE_ACPI, 0x3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Signatures for Register, Unregister of OpRegions
//

#define ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE     'HorA'
#define ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE   'HouA'

//
// Globals / Externals
//

extern ULONG OprghdlrDebugLevel = 0;

//
// Structures / type definitions
//

typedef struct _ACPI_REGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    ULONG                   AccessType;
    ULONG                   RegionSpace;
    PACPI_OP_REGION_HANDLER  Handler;
    PVOID                   Context;
} ACPI_REGISTER_OPREGION_HANDLER_BUFFER, *PACPI_REGISTER_OPREGION_HANDLER_BUFFER;

typedef struct _ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER {
    ULONG                   Signature;
    PVOID                   OperationRegionObject;
} ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER,*PACPI_UNREGISTER_OPREGION_HANDLER_BUFFER;

//
// Define the local routines used by this driver module.
//

VOID
DebugPrint (
            IN ULONG DebugLevel,
            IN PUCHAR DebugMessage,
            ...
            );

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

//
// Function code
//

NTSTATUS
RegisterOpRegionHandler (
                         IN PDEVICE_OBJECT DeviceObject,
                         IN ULONG AccessType,
                         IN ULONG RegionSpace,
                         IN PACPI_OP_REGION_HANDLER Handler,
                         IN PVOID Context,
                         IN ULONG Flags,
                         IN OUT PVOID *OperationRegionObject
                         )

/*++

Routine Description:

    This is the operation region registration routine.  It builds the appropriate 
    IOCTL, and sends it to ACPI to register the op region handler.
        
Arguments:

    DeviceObject - Pointer to device object for ACPI PDO
    AccessType - Specifies accesstype for which to register the op region handler
                 (see oprghdlr.h)
    RegionSpace - Specifies the region space type for which the op region handler should
                  be called for
    Handler - Pointer to a function that will handle the op region accesses
    Context - Context passed to handler when op region access occurs
    OperationRegionObject - Contains a pointer to the op region object returned by ACPI
    

Return Value:

    STATUS_SUCCESS if sucessful, otherwise error status.

--*/

{
    ACPI_REGISTER_OPREGION_HANDLER_BUFFER   inputData;
    ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER outputData;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status = STATUS_SUCCESS;
    PIRP irp;

    DebugPrint (DEBUG_INFO,
                "Entering RegisterOpRegionHandler\n");
    
    //
    // Zero out IOCTL buffers
    //

    RtlZeroMemory (&inputData, sizeof (inputData));
    RtlZeroMemory (&outputData, sizeof (outputData));

    //
    // Init our synchronization event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    //
    // Set up the IOCTL buffer
    //
    
    inputData.Signature = ACPI_REGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
    inputData.AccessType = AccessType;
    inputData.RegionSpace = RegionSpace;
    inputData.Handler = Handler;
    inputData.Context = Context;

    //
    // Build the IOCTL
    //
    
    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_REGISTER_OPREGION_HANDLER,
                                         DeviceObject,
                                         &inputData,
                                         sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER),
                                         &outputData,
                                         sizeof(ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER),
                                         FALSE,
                                         &event,
                                         &ioStatus);

    if (!irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send to ACPI driver
    //
    
    status = IoCallDriver (DeviceObject, irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //
        
        status = ioStatus.Status;
    }

    //
    // Check the status code
    //

    if (!NT_SUCCESS(status)) {

        DebugPrint (DEBUG_ERROR,
                    "Registration IRP was failed by ACPI (%lx)\n",
                    status);
        
        return status;
    }

    //
    // Check the signature
    //
    
    if (outputData.Signature != ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE) {

        status = STATUS_ACPI_INVALID_DATA;

        DebugPrint (DEBUG_ERROR,
                    "Signature returned from ACPI is invalid.  Registration failed.\n");

        return status;

    }
    
    *OperationRegionObject = outputData.OperationRegionObject;
    
    return status;

}

NTSTATUS
DeRegisterOpRegionHandler (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PVOID OperationRegionObject
                           )

/*++

Routine Description:

    This is the operation region deregistration routine.  It builds the appropriate 
    IOCTL, and sends it to ACPI to deregister the op region handler.
        
Arguments:

    DeviceObject - Pointer to device object for ACPI PDO
    OperationRegionObject - Contains a pointer to the op region object returned
                            during registration
    

Return Value:

    STATUS_SUCCESS if sucessful, otherwise error status.

--*/
{
    ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER inputData;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    
    DebugPrint (DEBUG_INFO,
                "Entering DeRegisterOpRegionHandler\n");

    //
    // Zero out IOCTL buffer
    //

    RtlZeroMemory (&inputData, sizeof (inputData));

    //
    // Init our synchronization event
    //
    
    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    //
    // Set up the IOCTL buffer
    //
    
    inputData.Signature = ACPI_UNREGISTER_OPREGION_HANDLER_BUFFER_SIGNATURE;
    inputData.OperationRegionObject = OperationRegionObject;

    //
    // Build the IOCTL
    //
    
    irp = IoBuildDeviceIoControlRequest (IOCTL_ACPI_UNREGISTER_OPREGION_HANDLER,
                                         DeviceObject,
                                         &inputData,
                                         sizeof(ACPI_REGISTER_OPREGION_HANDLER_BUFFER),
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatus);

    if (!irp) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send to ACPI driver
    //
    
    status = IoCallDriver (DeviceObject, irp);

    if (status == STATUS_PENDING) {

        //
        // Wait for request to be completed
        //
        
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        //
        // Get the real status
        //
        
        status = ioStatus.Status;
    }

    //
    // Check the status code
    //

    if (!NT_SUCCESS(status)) {

        DebugPrint (DEBUG_ERROR,
                    "Deregistration IRP was failed by ACPI (%lx)\n",
                    status);
        
    }
    
    return status;
}

VOID
DebugPrint (
            IN ULONG DebugLevel,
            IN PUCHAR DebugMessage,
            ...
            )

/*++

Routine Description:

    This is the general debug printing routine.
    
Arguments:

    DebugLevel - Debug level for which this message should be printed
    DebugMessage - Pointer to a buffer for the message to be printed    
    ... - Variable length argument list

Return Value:

    None

--*/
{
    UCHAR Text[200];
    va_list va;

    RtlCopyMemory (Text, DebugPrepend, sizeof (DebugPrepend));

    va_start (va, DebugMessage);
    vsprintf ((PVOID) ((ULONG_PTR) Text + sizeof (DebugPrepend)), DebugMessage, va);
    va_end (va);

    if (OprghdlrDebugLevel & DebugLevel) {
        DbgPrint (Text);
    }
} 

/*++

Routine Description:

    Required DriverEntry routine.  Not used as this is an EXPORT_DRIVER type.
    
Arguments:

    DriverObject - Address of DriverObject
    RegistryPath - Address of the registry path
    
Return Value:

    STATUS_SUCCESS, always

--*/

NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbali\smbpoll.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbpoll.c

Abstract:

    Device polling for
    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbalip.h"

VOID
SmbAliPollDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliPollWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );



//LARGE_INTEGER SmbAlertPollRate  = {-1*SECONDS, -1};  // 1 second poll rate
LARGE_INTEGER SmbDevicePollRate   = {-5*SECONDS, -1};  // 5 second poll rate
LONG    SmbDevicePollPeriod       = 5000; // 5000 ms = 5 sec

// address, command, protocol, valid_data, last_data
SMB_ALI_POLL_ENTRY SmbDevicePollList [2] = {
    {0x0b, 0x16, SMB_READ_WORD, FALSE, 0},          // battery, BatteryStatus()
    {0x09, 0x13, SMB_READ_WORD, FALSE, 0}           // charger, ChargerStatus()
};


    
VOID
SmbAliStartDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    AliData->PollList = SmbDevicePollList;
    AliData->PollListCount = sizeof (SmbDevicePollList)/sizeof(SMB_ALI_POLL_ENTRY);
    AliData->PollWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    KeInitializeTimer (&AliData->PollTimer);
    KeInitializeDpc (&AliData->PollDpc,
                     SmbAliPollDpc,
                     SmbClass);
    KeInitializeEvent (&AliData->PollWorkerActive, NotificationEvent, TRUE);
    KeSetTimerEx (&AliData->PollTimer, 
                  SmbDevicePollRate, 
                  SmbDevicePollPeriod, 
                  &AliData->PollDpc);
}

VOID
SmbAliStopDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    
    KeCancelTimer (&AliData->PollTimer);
    if (KeResetEvent(&AliData->PollWorkerActive) == 0) {
        KeWaitForSingleObject (&AliData->PollWorkerActive, 
                               Executive, KernelMode, FALSE, NULL);
    }
}

VOID
SmbAliPollDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    if (KeResetEvent(&AliData->PollWorkerActive) != 0) {
        IoQueueWorkItem (AliData->PollWorker, SmbAliPollWorker, DelayedWorkQueue, SmbClass);
    }
}

VOID
SmbAliPollWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    PIRP             irp;
    SMB_REQUEST     smbRequest;
    IO_STATUS_BLOCK ioStatus;
    KEVENT          event;
    ULONG           i;

    KeInitializeEvent (&event, SynchronizationEvent, FALSE);

    SmbPrint(SMB_TRACE, ("SmbAliPollWorker: Entered\n"));

    for (i = 0; i < AliData->PollListCount; i++) {
        smbRequest.Protocol = AliData->PollList[i].Protocol;
        smbRequest.Address = AliData->PollList[i].Address;
        smbRequest.Command = AliData->PollList[i].Command;
        
        irp = IoBuildDeviceIoControlRequest (
            SMB_BUS_REQUEST,
            SmbClass->DeviceObject,
            &smbRequest,
            sizeof (smbRequest),
            &smbRequest,
            sizeof (smbRequest),
            TRUE,
            &event,
            &ioStatus);

        if (!irp) {
            continue;
        }

        IoCallDriver (SmbClass->DeviceObject, irp);

        KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

        if (!NT_SUCCESS(ioStatus.Status)) {
            continue;
        }
        if (smbRequest.Status != SMB_STATUS_OK) {
            if (AliData->PollList[i].ValidData) {
                AliData->PollList[i].ValidData = FALSE;
            }
        } else {
            //BUGBUG: only supports word protocols
            if ((!AliData->PollList[i].ValidData) ||
                (AliData->PollList[i].LastData != *((PUSHORT)smbRequest.Data))) {
                AliData->PollList[i].ValidData = TRUE;
                AliData->PollList[i].LastData = *((PUSHORT)smbRequest.Data);
                
                SmbPrint(SMB_TRACE, ("SmbAliPollWorker: Alarm: Address 0x%02x Data 0x%04x\n", AliData->PollList[i].Address, AliData->PollList[i].LastData));
                SmbClassLockDevice (SmbClass);
                SmbClassAlarm (SmbClass,
                               AliData->PollList[i].Address, 
                               AliData->PollList[i].LastData); 
                SmbClassUnlockDevice (SmbClass);
            }
            SmbPrint(SMB_TRACE, ("SmbAliPollWorker: AlarmData: Address 0x%02x Data 0x%04x\n", AliData->PollList[i].Address, AliData->PollList[i].LastData));
        }
    }

    KeSetEvent (&AliData->PollWorkerActive, 0, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbbatt\pnppower.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pnppower.c

Abstract:

    SMBus Smart Battery Subsystem Miniport Driver
    (Selector, Battery, Charger) Plug and Play and
    Power Management IRP dispatch routines.

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"
#include <devioctl.h>
#include <acpiioct.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattPnpDispatch)
#pragma alloc_text(PAGE,SmbBattPowerDispatch)
#pragma alloc_text(PAGE,SmbBattRegisterForAlarm)
#pragma alloc_text(PAGE,SmbBattUnregisterForAlarm)
#pragma alloc_text(PAGE,SmbGetSBS)
#pragma alloc_text(PAGE,SmbGetGLK)
#pragma alloc_text(PAGE,SmbBattCreatePdos)
#pragma alloc_text(PAGE,SmbBattBuildDeviceRelations)
#pragma alloc_text(PAGE,SmbBattQueryDeviceRelations)
#pragma alloc_text(PAGE,SmbBattRemoveDevice)
#pragma alloc_text(PAGE,SmbBattQueryId)
#pragma alloc_text(PAGE,SmbBattQueryCapabilities)
#pragma alloc_text(PAGE,SmbBattBuildSelectorStruct)
#endif



NTSTATUS
SmbBattPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PSMB_BATT               smbBatt;

    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    BOOLEAN                 complete        = TRUE;
    KEVENT                  syncEvent;

    //
    // This routine handles PnP IRPs for three different types of device objects:
    // the battery subsystem FDO, each battery PDO and each battery PDO.  The
    // subsystem PDO creates children since each battery in the system must have
    // it's own device object, so this driver is essential two device drivers in
    // one: the smart battery selector bus driver (It is actually it's own bus
    // because the selector arbitrates between the two batteries.) and the
    // battery function driver.  The two drivers are integrated because it would
    // not make sense to replace one and not the other, and having separate
    // drivers would require additional defined interfaces between them.
    //
    // The device extensions for the three device types are different structures.
    //

    PSMB_BATT_SUBSYSTEM     subsystemExt    =
            (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PSMB_NP_BATT            batteryExt      =
            (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT      lowerDevice = NULL;

    PAGED_CODE();

    status = IoAcquireRemoveLock (&batteryExt->RemoveLock, Irp);

    if (NT_SUCCESS(status)) {
        status = STATUS_NOT_SUPPORTED;

        if (batteryExt->SmbBattFdoType == SmbTypeSubsystem) {
            lowerDevice = subsystemExt->LowerDevice;
        } else if (batteryExt->SmbBattFdoType == SmbTypeBattery) {
            lowerDevice = batteryExt->LowerDevice;
        } else {
            // Assuming (batteryExt->SmbBattFdoType == SmbTypePdo)
            ASSERT (batteryExt->SmbBattFdoType == SmbTypePdo);
            lowerDevice = NULL;
        }

        switch (irpStack->MinorFunction) {

            case IRP_MN_QUERY_DEVICE_RELATIONS: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_DEVICE_RELATIONS, "
                     "type = %x\n",
                     irpStack->Parameters.QueryDeviceRelations.Type)
                );

                status = SmbBattQueryDeviceRelations (DeviceObject, Irp);

                break;
            }


            case IRP_MN_QUERY_CAPABILITIES: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_CAPABILITIES for device %x\n",
                    DeviceObject)
                );

                status = SmbBattQueryCapabilities (DeviceObject, Irp);
                break;
            }


            case IRP_MN_START_DEVICE: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_START_DEVICE for %x\n",
                    DeviceObject)
                );

                if (subsystemExt->SmbBattFdoType == SmbTypeSubsystem) {

                    //
                    // Get the SMB host controller FDO
                    //

                    subsystemExt->SmbHcFdo = subsystemExt->LowerDevice;
                    status = STATUS_SUCCESS;

                } else if (subsystemExt->SmbBattFdoType == SmbTypeBattery) {

                    //
                    // This is a battery.  Just get the SMB host controller FDO.
                    //

                    smbBatt = batteryExt->Batt;
                    smbBatt->SmbHcFdo =
                        ((PSMB_BATT_SUBSYSTEM)(((PSMB_BATT_PDO)
                                                (smbBatt->PDO->DeviceExtension))->
                                               SubsystemFdo->DeviceExtension))->
                        LowerDevice;
                    status = STATUS_SUCCESS;
                } else if (subsystemExt->SmbBattFdoType == SmbTypePdo) {
                    status = STATUS_SUCCESS;
                }

                break;
            }


            case IRP_MN_STOP_DEVICE: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_STOP_DEVICE\n"));

                break;
            }


            case IRP_MN_QUERY_REMOVE_DEVICE: {

                status = STATUS_SUCCESS;
                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_QUERY_REMOVE_DEVICE\n"));
                break;
            }


            case IRP_MN_CANCEL_REMOVE_DEVICE: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_CANCEL_REMOVE_DEVICE\n"));

                break;
            }


            case IRP_MN_SURPRISE_REMOVAL: {
                status = STATUS_SUCCESS;

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_SURPRISE_REMOVAL\n"));

                break;
            }


            case IRP_MN_REMOVE_DEVICE: {
                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_REMOVE_DEVICE\n"));

                status = SmbBattRemoveDevice (DeviceObject, Irp);

                return status;

                break;
            }


            case IRP_MN_QUERY_ID: {

                BattPrint(
                    BAT_IRPS,
                    ("SmbBattPnpDispatch: got IRP_MN_QUERY_ID for %x, query type is - %x\n",
                    DeviceObject,
                    irpStack->Parameters.QueryId.IdType)
                );

                if (batteryExt->SmbBattFdoType == SmbTypePdo) {
                    status = SmbBattQueryId (DeviceObject, Irp);
                }
                break;
            }


            case IRP_MN_QUERY_PNP_DEVICE_STATE: {

                BattPrint(BAT_IRPS, ("SmbBattPnpDispatch: got IRP_MN_PNP_DEVICE_STATE\n"));

                if (subsystemExt->SmbBattFdoType == SmbTypeSubsystem) {
                    IoCopyCurrentIrpStackLocationToNext (Irp);

                    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

                    IoSetCompletionRoutine(Irp, SmbBattSynchronousRequest, &syncEvent, TRUE, TRUE, TRUE);

                    status = IoCallDriver(lowerDevice, Irp);

                    if (status == STATUS_PENDING) {
                        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                        status = Irp->IoStatus.Status;
                    }

                    Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

                    IoCompleteRequest(Irp, IO_NO_INCREMENT);

                    IoReleaseRemoveLock (&batteryExt->RemoveLock, Irp);

                    return status;
                }

                break;
            }

        }   // switch (irpStack->MinorFunction)

        IoReleaseRemoveLock (&batteryExt->RemoveLock, Irp);

    }

    //
    // Only set status if we have something to add
    //
    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status ;

    }

    //
    // Do we need to send it down?
    //
    if ((NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) && (lowerDevice != NULL)) {

        //
        // Forward request
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(lowerDevice,Irp);

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }

    return status;
}





NTSTATUS
SmbBattPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{

    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_NOT_SUPPORTED;
    PSMB_NP_BATT        batteryExt = (PSMB_NP_BATT) Fdo->DeviceExtension;
    PSMB_BATT_SUBSYSTEM subsystemExt = (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;
    PDEVICE_OBJECT      lowerDevice;

    PAGED_CODE();

    //
    // Not using Remove lock in this function because this function doesn't use
    // any resoureces that the remove lock protects.
    //

    if (batteryExt->SmbBattFdoType == SmbTypeSubsystem) {
        lowerDevice = subsystemExt->LowerDevice;
    } else if (batteryExt->SmbBattFdoType == SmbTypeBattery) {
        lowerDevice = batteryExt->LowerDevice;
    } else {
        // Assuming (batteryExt->SmbBattFdoType == SmbTypePdo)
        ASSERT (batteryExt->SmbBattFdoType == SmbTypePdo);
        lowerDevice = NULL;
        status = STATUS_SUCCESS;
    }

    switch (irpStack->MinorFunction) {

        case IRP_MN_WAIT_WAKE: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_WAIT_WAKE\n"));
            
            //
            // Smart batteries can't wake the system.
            //

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        case IRP_MN_POWER_SEQUENCE: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_POWER_SEQUENCE\n"));
            break;
        }

        case IRP_MN_SET_POWER: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_SET_POWER\n"));
            break;
        }

        case IRP_MN_QUERY_POWER: {
            BattPrint(BAT_IRPS, ("SmbBattPowerDispatch: got IRP_MN_QUERY_POWER\n"));
            break;
        }

        default: {
            status = STATUS_NOT_SUPPORTED;
        }

    }   // switch (irpStack->MinorFunction)

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    }

    PoStartNextPowerIrp( Irp );
    if ((NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) && (lowerDevice != NULL)) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( lowerDevice, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}



NTSTATUS
SmbBattRegisterForAlarm(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine register with the SmbHc for alarm notifications.  This
    is only done when smart battery subsystem FDO is started.

Arguments:

    Fdo - Pointer to the Fdo for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    SMB_REGISTER_ALARM      registerAlarm;
    KEVENT                  event;
    NTSTATUS                status;

    PSMB_BATT_SUBSYSTEM     subsystemExtension  =
            (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;

    PAGED_CODE();

    //
    // Register for alarm notifications
    //

    registerAlarm.MinAddress        = SMB_CHARGER_ADDRESS;
    registerAlarm.MaxAddress        = SMB_BATTERY_ADDRESS;
    registerAlarm.NotifyFunction    = SmbBattAlarm;
    registerAlarm.NotifyContext     = subsystemExtension;

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (subsystemExtension->SmbHcFdo->StackSize, FALSE);

    if (!irp) {
        BattPrint(BAT_ERROR, ("SmbBattRegisterForAlarm: couldn't allocate irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack                    = IoGetNextIrpStackLocation(irp);
    irp->UserBuffer             = &subsystemExtension->SmbAlarmHandle;
    irpStack->MajorFunction     = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpStack->Parameters.DeviceIoControl.IoControlCode      = SMB_REGISTER_ALARM_NOTIFY;
    irpStack->Parameters.DeviceIoControl.InputBufferLength  = sizeof(registerAlarm);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer   = &registerAlarm;
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = sizeof(subsystemExtension->SmbAlarmHandle);

    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);
    IoCallDriver (subsystemExtension->SmbHcFdo, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattRegisterForAlarm: couldn't register for alarms - %x\n", status));
    }

    IoFreeIrp (irp);

    return status;

}



NTSTATUS
SmbBattUnregisterForAlarm(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine unregisters with the SmbHc for alarm notifications.  This
    is only done when smart battery subsystem FDO is stopped or unloaded.

Arguments:

    Fdo - Pointer to the Fdo for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    KEVENT                  event;
    NTSTATUS                status;

    PSMB_BATT_SUBSYSTEM     subsystemExtension  = (PSMB_BATT_SUBSYSTEM) Fdo->DeviceExtension;

    PAGED_CODE();

    //
    // DeRegister for alarm notifications
    //

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (subsystemExtension->SmbHcFdo->StackSize, FALSE);

    if (!irp) {
        BattPrint(BAT_ERROR, ("SmbBattUnregisterForAlarm: couldn't allocate irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack                    = IoGetNextIrpStackLocation(irp);
    irp->UserBuffer             = NULL;
    irpStack->MajorFunction     = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpStack->Parameters.DeviceIoControl.IoControlCode      = SMB_DEREGISTER_ALARM_NOTIFY;
    irpStack->Parameters.DeviceIoControl.InputBufferLength  = sizeof(subsystemExtension->SmbAlarmHandle);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer   = &subsystemExtension->SmbAlarmHandle;
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = 0;

    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);
    IoCallDriver (subsystemExtension->SmbHcFdo, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;
    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattUnregisterForAlarm: couldn't unregister for alarms - %x\n", status));
    }

    IoFreeIrp (irp);

    return status;

}



NTSTATUS
SmbGetSBS (
    IN PULONG           NumberOfBatteries,
    IN PBOOLEAN         SelectorPresent,
    IN PDEVICE_OBJECT   LowerDevice
    )
/*++

Routine Description:

    This routine has the ACPI driver run the control method _SBS for the smart battery
    subsystem.  This control method returns a value that tells the driver how many
    batteries are supported and whether or not the system contains a selector.

Arguments:

    NumberOfBatteries   - pointer to return the number of batteries

    SelectorPresent     - Pointer to return whether a selector is present (TRUE)

    LowerDevice         - device object to call

Return Value:

    Status of the IOCTL to the ACPI driver.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    BattPrint (BAT_TRACE, ("SmbGetSBS: Entering\n"));

    //
    //  Initialize the input structure
    //

    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = SMBATT_SBS_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
       IOCTL_ACPI_ASYNC_EVAL_METHOD,
       LowerDevice,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER),
       FALSE,
       &event,
       &ioStatusBlock
    );

    if (irp == NULL) {
        BattPrint (BAT_ERROR, ("SmbGetSBS: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver (LowerDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    //
    // Sanity check the data
    //
    if (outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0) {

        status = STATUS_ACPI_INVALID_DATA;
    }

    *SelectorPresent = FALSE;
    *NumberOfBatteries = 0;

    if (!NT_SUCCESS(status)) {
        BattPrint (BAT_BIOS_ERROR | BAT_ERROR, ("SmbGetSBS: Irp failed - %x\n", status));
    } else {

        argument = outputBuffer.Argument;
        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            return STATUS_ACPI_INVALID_DATA;
        }

        switch (argument->Argument) {
            case 0:
                BattPrint(BAT_DATA, ("SmbGetSBS: Number of batteries = 1, no selector\n"));
                *NumberOfBatteries = 1;
                break;

            case 1:
            case 2:
            case 3:
            case 4:
                BattPrint(BAT_DATA, ("SmbGetSBS: Number of batteries found - %x\n", argument->Argument));
                *SelectorPresent = TRUE;
                *NumberOfBatteries = argument->Argument;
                break;

            default:
                BattPrint(BAT_ERROR, ("SmbGetSBS: Invalid number of batteries - %x\n", argument->Argument));
                return STATUS_NO_SUCH_DEVICE;
        }
    }

    return status;
}




NTSTATUS
SmbGetGLK (
    IN PBOOLEAN         GlobalLockRequired,
    IN PDEVICE_OBJECT   LowerDevice
    )
/*++

Routine Description:

    This routine has the ACPI driver run the control method _SBS for the smart battery
    subsystem.  This control method returns a value that tells the driver how many
    batteries are supported and whether or not the system contains a selector.

Arguments:

    GlobalLockRequired  - Pointer to return whether lock acquisition is needed

    LowerDevice         - device object to call

Return Value:

    Status of the IOCTL to the ACPI driver.

--*/
{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;

    PAGED_CODE();

    BattPrint (BAT_TRACE, ("SmbGetGLK: Entering\n"));

    //
    //  Initialize the input structure
    //

    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = SMBATT_GLK_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(
       IOCTL_ACPI_ASYNC_EVAL_METHOD,
       LowerDevice,
       &inputBuffer,
       sizeof(ACPI_EVAL_INPUT_BUFFER),
       &outputBuffer,
       sizeof(ACPI_EVAL_OUTPUT_BUFFER),
       FALSE,
       &event,
       &ioStatusBlock
    );

    if (irp == NULL) {
        BattPrint (BAT_ERROR, ("SmbGetGLK: couldn't create Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver (LowerDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            *GlobalLockRequired = FALSE;
            BattPrint (BAT_NOTE, ("SmbGetGLK: _GLK not found assuming lock is not needed.\n"));
        } else {
            BattPrint (BAT_ERROR, ("SmbGetGLK: Irp failed - %x\n", status));
        }
    } else {

        //
        // Sanity check the data
        //
        if (outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
            outputBuffer.Count == 0) {

            return STATUS_ACPI_INVALID_DATA;
        }

        argument = outputBuffer.Argument;
        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            return STATUS_ACPI_INVALID_DATA;
        }

        if (argument->Argument == 0) {
            *GlobalLockRequired = FALSE;
        } else if (argument->Argument == 1) {
            *GlobalLockRequired = TRUE;
        } else {
            BattPrint(BAT_BIOS_ERROR, ("SmbGetGLK: Invalid value returned - %x\n", argument->Argument));
            status = STATUS_UNSUCCESSFUL;
        }
    }

    BattPrint (BAT_DATA, ("SmbGetGLK: Returning %x GLK = %d\n", status, SmbBattUseGlobalLock));
    return status;
}




NTSTATUS
SmbBattCreatePdos(
    IN PDEVICE_OBJECT SubsystemFdo
    )
/*++

Routine Description:

    This routine creates a PDO for each battery supported by the system and puts
    it into a list kept with the FDO for the smart battery subsystem.

Arguments:

    SubsystemFdo    - Fdo for the smart battery subsystem

Return Value:

    Status for creation of battery PDO.
--*/
{
    ULONG                   i;
    NTSTATUS                status;
    PSMB_BATT_PDO           batteryPdoExt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];
    PDEVICE_OBJECT          pdo;

    PSMB_BATT_SUBSYSTEM     subsystemExt        = (PSMB_BATT_SUBSYSTEM) SubsystemFdo->DeviceExtension;
    BOOLEAN                 selectorPresent     = FALSE;

    PAGED_CODE();

    //
    // Find out if there are multiple batteries and a selector on this machine.
    //

    status = SmbGetSBS (
        &subsystemExt->NumberOfBatteries,
        &subsystemExt->SelectorPresent,
        subsystemExt->LowerDevice
    );


    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error reading SBS\n"));
        return status;
    }

    status = SmbGetGLK (
        &SmbBattUseGlobalLock,
        subsystemExt->LowerDevice
    );


    if (!NT_SUCCESS(status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error reading GLK\n"));
        //
        // If this failed, ignore the failure and continue.  This is not critical.
        //
    }

    //
    // Build the selector information structure
    //

    // Adjust Number of Batteries to Match SelectorInfo Supported Batteries
    // Just in case the ACPI information is incorrect
    status = SmbBattBuildSelectorStruct (SubsystemFdo);

    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattCreatePdos: couldn't talk to the selector\n"));
        return status;
    }

    //
    // Build device object for each battery
    //

    for (i = 0; i < subsystemExt->NumberOfBatteries; i++) {

        //
        // Create the device object
        //

        status = IoCreateDevice(
            SubsystemFdo->DriverObject,
            sizeof (SMB_BATT_PDO),
            NULL,
            FILE_DEVICE_BATTERY,
            FILE_DEVICE_SECURE_OPEN|FILE_AUTOGENERATED_DEVICE_NAME,
            FALSE,
            &pdo
        );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattCreatePdos: error creating battery pdo %x\n", status));

            //
            // Make sure we don't later try to use devices that weren't created.
            //
            subsystemExt->NumberOfBatteries = i;

            return(status);
        }

        //
        // Initialize the Pdo
        //

        pdo->Flags      |= DO_BUFFERED_IO;
        pdo->Flags      |= DO_POWER_PAGABLE;
        
        //
        // Save the PDO in the subsystem FDO PDO list
        //

        subsystemExt->BatteryPdoList[i] = pdo;

        //
        // Initialize the PDO extension
        //

        batteryPdoExt = (PSMB_BATT_PDO) pdo->DeviceExtension;

        batteryPdoExt->SmbBattFdoType   = SmbTypePdo;
        batteryPdoExt->DeviceObject     = pdo;
        batteryPdoExt->BatteryNumber    = i;
        batteryPdoExt->SubsystemFdo     = SubsystemFdo;
        IoInitializeRemoveLock (&batteryPdoExt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        //
        // Device is ready for use
        //
        
        pdo->Flags      &= ~DO_DEVICE_INITIALIZING;

    }  // for (i = 0; i < subsystemExt->NumberOfBatteries; i++)

    return STATUS_SUCCESS;

}





NTSTATUS
SmbBattBuildDeviceRelations(
    IN  PSMB_BATT_SUBSYSTEM SubsystemExt,
    IN  PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine is checks the device relations structure for existing device
    relations, calculates how big a new device relations structure has to be,
    allocates it, and fills it with the PDOs created for the batteries.

Arguments:

    SubsystemExt        - Device extension for the smart battery subsystem FDO

    DeviceRelations     - The Current DeviceRelations for the device...

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_RELATIONS   newDeviceRelations;
    ULONG               i, j;
    ULONG               newDeviceRelationsSize;
    NTSTATUS            status;

    ULONG               existingPdos            = 0;
    ULONG               deviceRelationsSize     = 0;
    ULONG               numberOfPdos            = 0;

    PAGED_CODE();

    //
    // Calculate the size the new device relations structure has to be
    //

    if (*DeviceRelations != NULL && (*DeviceRelations)->Count > 0) {

        //
        // There are existing device relations to be copied
        //

        existingPdos = (*DeviceRelations)->Count;
        deviceRelationsSize = sizeof (ULONG) + (sizeof (PDEVICE_OBJECT) * existingPdos);
    }


    //
    // Calculate the size needed for the new device relations structure and allocate it
    //

    numberOfPdos = existingPdos + SubsystemExt->NumberOfBatteries;
    newDeviceRelationsSize = sizeof (ULONG) + (sizeof (PDEVICE_OBJECT) * numberOfPdos);

    newDeviceRelations = ExAllocatePoolWithTag (PagedPool, newDeviceRelationsSize, 'StaB');

    if (!newDeviceRelations) {
        BattPrint (BAT_ERROR, ("SmbBattBuildDeviceRelations:  couldn't allocate device relations buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // If there are existing device relations copy them to the new device
    // relations structure and free the old one.
    //

    if (existingPdos) {
        RtlCopyMemory (newDeviceRelations, *DeviceRelations, deviceRelationsSize);
    }

    if (*DeviceRelations) {   // Could be a zero length list, but still need freeing
        ExFreePool (*DeviceRelations);
    }


    //
    // Now add the battery PDOs to the end of the list and reference it
    //

    for (i = existingPdos, j = 0; i < numberOfPdos; i ++, j ++) {
        newDeviceRelations->Objects[i] = SubsystemExt->BatteryPdoList[j];

        status = ObReferenceObjectByPointer(
            SubsystemExt->BatteryPdoList[j],
            0,
            NULL,
            KernelMode
        );

        if (!NT_SUCCESS(status) ) {

            //
            // This should theoretically never happen...
            //
            BattPrint(BAT_ERROR, ("SmbBattBuildDeviceRelations: error referencing battery pdo %x\n", status));
            return status;
        }
    }

    newDeviceRelations->Count = numberOfPdos;
    *DeviceRelations = newDeviceRelations;

    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattQueryDeviceRelations(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_DEVICE_RELATIONS.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PSMB_NP_BATT            SmbNPBatt       = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PSMB_BATT_PDO           PdoExt          = (PSMB_BATT_PDO) DeviceObject->DeviceExtension;
    PSMB_BATT_SUBSYSTEM     SubsystemExt    = (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          pdo;
    PIO_STACK_LOCATION      IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    ULONG                   i;
    PDEVICE_RELATIONS   deviceRelations =
        (PDEVICE_RELATIONS) Irp->IoStatus.Information;


    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryDeviceRelations: ENTERING\n"));

    switch (SmbNPBatt->SmbBattFdoType) {
        case SmbTypeSubsystem: {
            if (IrpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {
                BattPrint(
                    BAT_IRPS,
                    ("SmbBattQueryDeviceRelations: Handling Bus relations request\n")
                );

                if (SubsystemExt->NumberOfBatteries != 0) {
                    //
                    // We've already found our batteries, so we don't need to
                    // look again since smart batteries are static.
                    // Just rebuild the return structure.
                    //

                    status = SmbBattBuildDeviceRelations (SubsystemExt, &deviceRelations);
                } else {
                    status = SmbBattCreatePdos (DeviceObject);

                    if (NT_SUCCESS (status)) {
                        status = SmbBattBuildDeviceRelations (SubsystemExt, &deviceRelations);
                    }

                    if (NT_SUCCESS (status)) {

                        //
                        // Now register for alarms
                        // (Used to register during START_DEVICE,
                        // but don't need notifications until after the batteries
                        // are here. This avoids some other problems too.)

                        status = SmbBattRegisterForAlarm (DeviceObject);
                    }
                }
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            }

            break;
        }
        case SmbTypeBattery: {
            status = STATUS_NOT_SUPPORTED;

            break;
        }
        case SmbTypePdo: {
            if (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation ) {
                BattPrint(
                    BAT_IRPS,
                    ("SmbBattQueryDeviceRelations: Handling TargetDeviceRelation request\n")
                );
                deviceRelations = ExAllocatePoolWithTag (PagedPool,
                                                         sizeof(DEVICE_RELATIONS),
                                                         SMB_BATTERY_TAG);
                if (!deviceRelations) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                status = ObReferenceObjectByPointer(DeviceObject,
                                                    0,
                                                    NULL,
                                                    KernelMode);
                if (!NT_SUCCESS(status)) {
                    ExFreePool(deviceRelations);
                    return status;
                }
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }

            break;
        }
        default: {

            ASSERT (FALSE);
        }
    }

    return status;
}




NTSTATUS
SmbBattRemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_REMOVE_DEVICE.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PSMB_NP_BATT            SmbNPBatt       = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PSMB_BATT_PDO           PdoExt          = (PSMB_BATT_PDO) DeviceObject->DeviceExtension;
    PSMB_BATT_SUBSYSTEM     SubsystemExt    = (PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension;
    PDEVICE_OBJECT          pdo;
    PIO_STACK_LOCATION      IrpSp           = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;
    ULONG                   i;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattRemoveDevice: ENTERING\n"));

    switch (SmbNPBatt->SmbBattFdoType) {
        case SmbTypeSubsystem: {
            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Removing Subsystem FDO.\n"));

            //
            // De-register for notifications
            //

            SmbBattUnregisterForAlarm (DeviceObject);

            IoFreeWorkItem (SubsystemExt->WorkerThread);

            //
            // Remove PDOs
            //

            for (i = 0; i < SubsystemExt->NumberOfBatteries; i++) {
                pdo = SubsystemExt->BatteryPdoList[i];
                if (pdo) {
                    PdoExt = (PSMB_BATT_PDO) pdo->DeviceExtension;
                    status = IoAcquireRemoveLock (&PdoExt->RemoveLock, Irp);
                    IoReleaseRemoveLockAndWait (&PdoExt->RemoveLock, Irp);
                    SubsystemExt->BatteryPdoList[i] = NULL;
                    IoDeleteDevice (pdo);
                }
            }

            if ((SubsystemExt->SelectorPresent) && (SubsystemExt->Selector)) {
                ExFreePool (SubsystemExt->Selector);
            }

            IoSkipCurrentIrpStackLocation (Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = IoCallDriver (SubsystemExt->LowerDevice, Irp);

            IoDetachDevice (SubsystemExt->LowerDevice);
            IoDeleteDevice (DeviceObject);

            break;
        }
        case SmbTypeBattery: {

            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Removing Battery FDO\n"));
            IoReleaseRemoveLockAndWait (&SmbNPBatt->RemoveLock, Irp);

            //
            // Unregister as a WMI Provider.
            //
            SmbBattWmiDeRegistration(SmbNPBatt);
            
            //
            //  Tell the class driver we are going away
            //
            status = BatteryClassUnload (SmbNPBatt->Class);
            ASSERT (NT_SUCCESS(status));

            ExFreePool (SmbNPBatt->Batt);

            ((PSMB_BATT_PDO) SmbNPBatt->LowerDevice->DeviceExtension)->Fdo = NULL;
            
            IoSkipCurrentIrpStackLocation (Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = IoCallDriver (SmbNPBatt->LowerDevice, Irp);

            IoDetachDevice (SmbNPBatt->LowerDevice);
            IoDeleteDevice (DeviceObject);

            break;
        }
        case SmbTypePdo: {
            BattPrint(BAT_IRPS, ("SmbBattRemoveDevice: Remove for Battery PDO (doing nothing)\n"));
            //
            // Don't delete the device until it is physically removed.
            // Usually, the battery subsystem can't be physically removed...
            //

            //
            // Need to release Remove lock, since PnP dispatch won't...
            //
            IoReleaseRemoveLock (&PdoExt->RemoveLock, Irp);

            status = STATUS_SUCCESS;

            //
            // Complete the request with the current status
            //
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            break;
        }
        default: {

            ASSERT (FALSE);
        }
    }

    BattPrint(BAT_TRACE, ("SmbBattRemoveDevice: EXITING\n"));

    return status;
}




NTSTATUS
SmbBattQueryId(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_ID for the newly created battery PDOs.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{
    UNICODE_STRING          unicodeString;
    WCHAR                   unicodeBuffer[MAX_DEVICE_NAME_LENGTH];
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];

    PSMB_BATT_PDO           pdoExt          = (PSMB_BATT_PDO) Pdo->DeviceExtension;
    NTSTATUS                status          = STATUS_SUCCESS;
    PWCHAR                  idString        = NULL;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryId: ENTERING\n"));

    RtlZeroMemory (unicodeBuffer, MAX_DEVICE_NAME_LENGTH);
    unicodeString.MaximumLength = MAX_DEVICE_NAME_LENGTH;
    unicodeString.Length        = 0;
    unicodeString.Buffer        = unicodeBuffer;


    switch (irpStack->Parameters.QueryId.IdType) {

    case BusQueryDeviceID:

        //
        // This string has to have the form BUS\DEVICE.
        //
        // Use SMB as bus and SBS as device
        //

        RtlAppendUnicodeToString  (&unicodeString, SubSystemIdentifier);
        break;

    case BusQueryInstanceID:

        //
        // Return the string "Batteryxx" where xx is the battery number
        //

        numberString.MaximumLength = 10;
        numberString.Buffer = &numberBuffer[0];

        RtlIntegerToUnicodeString (pdoExt->BatteryNumber, 10, &numberString);
        RtlAppendUnicodeToString  (&unicodeString, BatteryInstance);
        RtlAppendUnicodeToString  (&unicodeString, &numberString.Buffer[0]);
        break;

    case BusQueryHardwareIDs:

        //
        // This is the Pnp ID for the smart battery subsystem "ACPI0002".
        // Make new hardware ID SMB\SBS, SmartBattery as a MULTIZ string
        // so we have to add a NULL string to terminate.
        //

        RtlAppendUnicodeToString  (&unicodeString, HidSmartBattery);
        unicodeString.Length += sizeof (WCHAR);
        break;

    default:

        //
        // Unknown Query Type
        //

        status = STATUS_NOT_SUPPORTED;

    }


    if (status != STATUS_NOT_SUPPORTED) {
        //
        // If we created a string, allocate a buffer for it and copy it into the buffer.
        // We need to make sure that we also copy the NULL terminator.
        //

        if (unicodeString.Length) {
            idString = ExAllocatePoolWithTag (PagedPool, unicodeString.Length + sizeof (WCHAR), 'StaB');

            if (!idString) {
                BattPrint (BAT_ERROR, ("SmbBattQueryId:  couldn't allocate id string buffer\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory (idString, unicodeString.Length + sizeof (WCHAR));
            RtlCopyMemory (idString, unicodeString.Buffer, unicodeString.Length);
        }

        Irp->IoStatus.Status = status;

        Irp->IoStatus.Information = (ULONG_PTR) idString;
    }

    BattPrint(BAT_DATA, ("SmbBattQueryId: returning ID = %x\n", idString));

    return status;
}




NTSTATUS
SmbBattQueryCapabilities(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp
    )
/*++

Routine Description:

    This routine handles the IRP_MN_QUERY_CAPABILITIES for the newly created
    battery PDOs.

Arguments:

    Pdo         - Battery PDO

    Irp         - The query Irp

Return Value:

    NTSTATUS

--*/
{

    PDEVICE_CAPABILITIES    deviceCaps;
    PIO_STACK_LOCATION      irpStack        = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    deviceCaps = irpStack->Parameters.DeviceCapabilities.Capabilities;

    if (deviceCaps->Version != 1) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Now set up the bits for the capabilities.
    //

    //All bits are initialized to false.  Only set bits that we support
    deviceCaps->SilentInstall   = TRUE;

    //
    // Now fill in the po manager information.
    //

    deviceCaps->SystemWake      = PowerSystemUnspecified;
    deviceCaps->DeviceWake      = PowerDeviceUnspecified;
    deviceCaps->D1Latency       = 1;
    deviceCaps->D2Latency       = 1;
    deviceCaps->D3Latency       = 1;

    return STATUS_SUCCESS;
}




SmbBattBuildSelectorStruct(
    IN PDEVICE_OBJECT SubsystemFdo
    )
/*++

Routine Description:

    This routine determines that address of the selector (whether it is a stand
    alone selector of part of the charger) and builds a selector structure with
    this information.  It also reads the initial selector information and
    caches this in the structure.  This structure will be passed out to all of
    the smart batteries in the system.

Arguments:

    SubsystemFdo    - Fdo for the smart battery subsystem

Return Value:

    NTSTATUS

--*/
{
    ULONG                   result;
    UCHAR                   smbStatus;

    PBATTERY_SELECTOR       selector     = NULL;
    PSMB_BATT_SUBSYSTEM     subsystemExt = (PSMB_BATT_SUBSYSTEM) SubsystemFdo->DeviceExtension;
    ULONG                   numberOfBatteries;

    PAGED_CODE();

    if (subsystemExt->SelectorPresent) {

        //
        // Allocate the selector structure.  This has to be from non-paged pool because
        // it will be accessed as part of the alarm processing.
        //

        selector = ExAllocatePoolWithTag (NonPagedPool, sizeof (BATTERY_SELECTOR), 'StaB');

        if (!selector) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't allocate selector structure\n"));
            
            //
            // Force Selector Not Present if allocation fails
            //

            subsystemExt->Selector = NULL;
            subsystemExt->SelectorPresent = FALSE;
            subsystemExt->NumberOfBatteries = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // See if the selector is part of the charger.  We do this by reading
        // directly from the selector first.  If this fails, then we verify
        // the charger is implementing the selector.
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            SMB_SELECTOR_ADDRESS,
            SELECTOR_SELECTOR_STATE,
            &result
        );

        if (smbStatus == SMB_STATUS_OK) {

            //
            // We have a stand alone selector
            //

            selector->SelectorAddress       = SMB_SELECTOR_ADDRESS;
            selector->SelectorStateCommand  = SELECTOR_SELECTOR_STATE;
            selector->SelectorPresetsCommand= SELECTOR_SELECTOR_PRESETS;
            selector->SelectorInfoCommand   = SELECTOR_SELECTOR_INFO;

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: The selector is standalone\n"));

        } else {

            //
            // Read the Charger Spec Info to check Selector Implemented Bit
            // NOTE: We're doing this for verification and information purposes
            //

            smbStatus = SmbBattGenericRW (
                subsystemExt->SmbHcFdo,
                SMB_CHARGER_ADDRESS,
                CHARGER_SPEC_INFO,
                &result
            );

            if (smbStatus == SMB_STATUS_OK) {
                if (result & CHARGER_SELECTOR_SUPPORT_BIT) {
                    // If Selector Support Bit is present, then Selector implemented in Charger
                    BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: ChargerSpecInfo indicates charger implementing selector\n"));

                } else {
                    // If Charger says it doesn't implement Selector, let's double-check anyway
                    BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: ChargerSpecInfo indicates charger does not implement selector\n"));
                }
            } else {
                // If it returns an error, let's double-check anyway
                BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read ChargerSpecInfo - %x\n", smbStatus));
            }

            //
            // Read SelectorState for Cache
            //

            smbStatus = SmbBattGenericRW (
                subsystemExt->SmbHcFdo,
                SMB_CHARGER_ADDRESS,
                CHARGER_SELECTOR_STATE,
                &result
            );

            if (smbStatus == SMB_STATUS_OK) {
                BattPrint (BAT_DATA, ("SmbBattBuildSelectorStruct: Selector state %x\n", result));

            } else {

                BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read charger selector state - %x\n", smbStatus));
                goto SelectorErrorExit;
            }

            //
            // The charger is implementing the selector
            //

            selector->SelectorAddress       = SMB_CHARGER_ADDRESS;
            selector->SelectorStateCommand  = CHARGER_SELECTOR_STATE;
            selector->SelectorPresetsCommand= CHARGER_SELECTOR_PRESETS;
            selector->SelectorInfoCommand   = CHARGER_SELECTOR_INFO;

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: Charger implements the selector\n"));

        }

        //
        // Initialize the selector mutex
        //

        ExInitializeFastMutex (&selector->Mutex);

        //
        // Store SelectorState in Cache
        //

        selector->SelectorState = result;

        //
        // Read SelectorPresets for Cache
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            selector->SelectorAddress,
            selector->SelectorPresetsCommand,
            &selector->SelectorPresets
        );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read selector presets - %x\n", smbStatus));
            
            //
            // Should we really fail the whole thing, because of an error reading SelectorPresets?
            // Let's Emulate the Information (Ok To Use All, Use Next A if available)
            //

            selector->SelectorPresets = (selector->SelectorState & SELECTOR_PRESETS_OKTOUSE_MASK);
            if (selector->SelectorPresets & BATTERY_A_PRESENT) {
                selector->SelectorPresets |= (BATTERY_A_PRESENT << SELECTOR_SHIFT_USENEXT);
            }
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Emulating Selector Presets - %x\n", selector->SelectorPresets));

        } else {
            BattPrint (BAT_DATA, ("SmbBattBuildSelectorStruct: Selector presets %x\n", selector->SelectorPresets));
        }

        //
        // Read Selector Info for Cache
        //

        smbStatus = SmbBattGenericRW (
            subsystemExt->SmbHcFdo,
            selector->SelectorAddress,
            selector->SelectorInfoCommand,
            &selector->SelectorInfo
        );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Couldn't read selector info - %x\n", smbStatus));
            //
            // Should we really fail the whole thing, because of an error reading SelectorInfo?
            // Let's Emulate the Information (Specification 1.0, No Charge Indicator)
            //

            selector->SelectorInfo = 0x0010;
            if (subsystemExt->NumberOfBatteries > 0) {
                selector->SelectorInfo |= BATTERY_A_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 1) {
                selector->SelectorInfo |= BATTERY_B_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 2) {
                selector->SelectorInfo |= BATTERY_C_PRESENT;
            }
            if (subsystemExt->NumberOfBatteries > 3) {
                selector->SelectorInfo |= BATTERY_D_PRESENT;
            }
            BattPrint (BAT_ERROR, ("SmbBattBuildSelectorStruct: Emulating Selector Info - %x\n", selector->SelectorInfo));

        } else {

            BattPrint (BAT_NOTE, ("SmbBattBuildSelectorStruct: Selector info %x\n", selector->SelectorInfo));

            // Verify the Number of Batteries against the SelectorInfo
            numberOfBatteries = 0;
            result = (selector->SelectorInfo & SELECTOR_INFO_SUPPORT_MASK);
            if (result & BATTERY_A_PRESENT) numberOfBatteries++;
            if (result & BATTERY_B_PRESENT) numberOfBatteries++;
            if (result & BATTERY_C_PRESENT) numberOfBatteries++;
            if (result & BATTERY_D_PRESENT) numberOfBatteries++;

            // Should we always override ACPI??
            // Proposed Solution: if Selector supports less batteries than
            // ACPI says, then Override ACPI with selector support.  If
            // Selector supports more than ACPI says, then don't override,
            // unless ACPI was invalid and the # of batteries = 1

            if (subsystemExt->NumberOfBatteries > numberOfBatteries) {
                subsystemExt->NumberOfBatteries = numberOfBatteries;
            } else if ((subsystemExt->NumberOfBatteries == 1) && (numberOfBatteries > 1)) {
                subsystemExt->NumberOfBatteries = numberOfBatteries;
            } else if (subsystemExt->NumberOfBatteries < numberOfBatteries) {
                //subsystemExt->NumberOfBatteries = numberOfBatteries;
            }

        }

    }   // if (subsystemFdo->SelectorPresent)

    //
    // Everything was OK
    //

    subsystemExt->Selector = selector;
    return STATUS_SUCCESS;

SelectorErrorExit:

    //
    // If a failure occurs, free the selector structure and don't creat any batery devices.
    //

    ExFreePool (selector);
    subsystemExt->Selector = NULL;
    subsystemExt->SelectorPresent = FALSE;
    subsystemExt->NumberOfBatteries = 0;

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbbatt\smbbattp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    smbbattp.h

Abstract:

    Smart Battery Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:


--*/

#ifndef FAR
#define FAR
#endif

#include <ntddk.h>
#include <wmilib.h>
#include <batclass.h>
#include <acpiioct.h>
#include <smbus.h>

//
// Debugging
//

#define DEBUG   DBG

#if DEBUG
    extern ULONG SMBBattDebug;

    #define BattPrint(l,m)    if(l & SMBBattDebug) DbgPrint m
#else
    #define BattPrint(l,m)
#endif

#define BAT_TRACE       0x00000400
#define BAT_STATE       0x00000200
#define BAT_IRPS        0x00000100

#define BAT_IO          0x00000040
#define BAT_DATA        0x00000020
#define BAT_ALARM       0x00000010

#define BAT_NOTE        0x00000008
#define BAT_WARN        0x00000004
#define BAT_ERROR       0x00000002
#define BAT_BIOS_ERROR  0x00000001


//
// Driver supports the following class driver version
//

#define SMB_BATTERY_MAJOR_VERSION           0x0001
#define SMB_BATTERY_MINOR_VERSION           0x0000

//
// Smart battery device driver tag for memory allocations: "BatS"
//

#define SMB_BATTERY_TAG 'StaB'

//
// Globals
//
extern UNICODE_STRING GlobalRegistryPath;

//
// Remove Lock parameters for checked builds
//

#define REMOVE_LOCK_MAX_LOCKED_MINUTES 1
#define REMOVE_LOCK_HIGH_WATER_MARK 64


//
// Driver Device Names (FDO)
//
#define         BatterySubsystemName    L"\\Device\\SmartBatterySubsystem"
#define         SmbBattDeviceName       L"\\Device\\SmartBattery"

//
// Query ID Names
//

#define         SubSystemIdentifier     L"SMBUS\\SMBBATT"
#define         BatteryInstance         L"Battery"

#define         HidSmartBattery         L"SMBBATT\\SMART_BATTERY"


//
// Structure for input from private Ioctls to read from devices on smbus
//

typedef struct {
    UCHAR       Address;
    UCHAR       Command;
    union {
        USHORT      Block [2];
        ULONG       Ulong;
    } Data;
} SMBBATT_DATA_STRUCT, *PSMBBATT_DATA_STRUCT;

typedef union {
    USHORT Block [2];
    ULONG Ulong;
} _SMBBATT_DATA_STRUCT_UNION;

#define SMBBATT_DATA_STRUCT_SIZE sizeof (SMBBATT_DATA_STRUCT) - sizeof (_SMBBATT_DATA_STRUCT_UNION)

//
// Private Ioctls for test engines
//

#define IOCTL_SMBBATT_DATA      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x100, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


//
// Definitions for the selector state lookup table
//

typedef struct  {
    UCHAR       BatteryIndex;
    BOOLEAN     ReverseLogic;

} SELECTOR_STATE_LOOKUP;


extern const SELECTOR_STATE_LOOKUP SelectorBits [];
extern const SELECTOR_STATE_LOOKUP SelectorBits4 [];


//
// Definitions for control method names neede by the smart battery
//

#define SMBATT_SBS_METHOD   (ULONG) ('SBS_')    // control method "_SBS"
#define SMBATT_GLK_METHOD   (ULONG) ('KLG_')    // control method "_GLK"


//
// Definitions for some string lengths
//

#define MAX_DEVICE_NAME_LENGTH  100
#define MAX_CHEMISTRY_LENGTH    4


//
// Maximum number of smart batteries supported by this driver
//

#define MAX_SMART_BATTERIES_SUPPORTED   4


//
// Types for the FDOs hnadled by this driver:
//  Smart battery subsystem FDO
//  Smart Battery FDO
//  Smart battery PDO
//

typedef enum {
    SmbTypeSubsystem,
    SmbTypeBattery,
    SmbTypePdo
} SMB_FDO_TYPE;


//
// SMB Host Controller Device object extenstion
//

//
// Cached battery info
//

typedef struct {
    ULONG                       Tag;
    UCHAR                       Valid;
    BATTERY_INFORMATION         Info;
    UCHAR                       ManufacturerNameLength;
    UCHAR                       ManufacturerName[SMB_MAX_DATA_SIZE];
    UCHAR                       DeviceNameLength;
    UCHAR                       DeviceName[SMB_MAX_DATA_SIZE];
    BATTERY_MANUFACTURE_DATE    ManufacturerDate;
    ULONG                       SerialNumber;

    ULONG                       PowerState;
    ULONG                       Capacity;
    ULONG                       VoltageScale;
    ULONG                       CurrentScale;
    ULONG                       PowerScale;
} STATIC_BAT_INFO, *PSTATIC_BAT_INFO;

#define VALID_TAG_DATA      0x01            // manufacturer, device, serial #
#define VALID_MODE          0x02
#define VALID_OTHER         0x04
#define VALID_CYCLE_COUNT   0x08
#define VALID_SANITY_CHECK  0x10
#define VALID_TAG           0x80

#define VALID_ALL           0x1F            // (does not include tag)


//
// Selector information structure
//

typedef struct _BATTERY_SELECTOR {
    //
    // Addressing and command information.  This can change based whether or
    // not the selector is stand alone or part of the charger.
    //

    UCHAR               SelectorAddress;
    UCHAR               SelectorStateCommand;
    UCHAR               SelectorPresetsCommand;
    UCHAR               SelectorInfoCommand;

    //
    // Mutex to keep only one person talking with the selector at a time
    //

    FAST_MUTEX          Mutex;

    //
    // Cached information.  We will get notifications when these change.
    //

    ULONG               SelectorState;
    ULONG               SelectorPresets;
    ULONG               SelectorInfo;
} BATTERY_SELECTOR, *PBATTERY_SELECTOR;



typedef struct {
    ULONG               Setting;
    ULONG               Skip;
    LONG                Delta;
    LONG                AllowedFudge;
} BAT_ALARM_INFO, *PBAT_ALARM_INFO;


typedef struct {
    UCHAR               Address;
    USHORT              Data;
    LIST_ENTRY          Alarms;
} SMB_ALARM_ENTRY, *PSMB_ALARM_ENTRY;


//
// Non-pagable device extension for smart battery FDO
// (Created by IoCreateDevice SMB_NP_BATT for each battery)
//

typedef struct {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    FAST_MUTEX          Mutex;              // lets either battery OR subsystem
                                            //   have access to batt
    PVOID               Class;              // Battery Class handle
    struct _SMB_BATT    *Batt;              // Battery pageable extension
    PDEVICE_OBJECT      LowerDevice;        // Battery Subsystem PDO
    WMILIB_CONTEXT      WmiLibContext;
} SMB_NP_BATT, *PSMB_NP_BATT;

//
// Pagable device extension for smart battery FDO
// (Allocated Extra Memory for device information)
//

typedef struct _SMB_BATT {

    //
    //
    //

    PSMB_NP_BATT        NP;                 // Battery device object extension
    PDEVICE_OBJECT      DeviceObject;       // Battery Fdo
    PDEVICE_OBJECT      PDO;                // Battery Pdo


    // SMB host controller

    PDEVICE_OBJECT      SmbHcFdo;           // SM bus Fdo

    //
    // Selector
    //

    PBATTERY_SELECTOR   Selector;           // Selector for battery

    //
    // For handling multiple batteries
    //

    BOOLEAN             SelectorPresent;
    ULONG               SelectorBitPosition;

    //
    // Battery
    //

    ULONG               TagCount;           // Tag for next battery
    STATIC_BAT_INFO     Info;
    BAT_ALARM_INFO      AlarmLow;
} SMB_BATT, *PSMB_BATT;


//
// Device extension for the smart battery subsystem FDO
// (Created by first AddDevice command from ACPI PDO)
//

typedef struct _SMB_BATT_SUBSYSTEM {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    PVOID               SmbAlarmHandle;     // handle for SmbAlarm registration

    PDEVICE_OBJECT      LowerDevice;        // Subsystem PDO
    PDEVICE_OBJECT      DeviceObject;       // Subsystem FDO
    PDEVICE_OBJECT      SmbHcFdo;           // SMBus Fdo

    ULONG               NumberOfBatteries;  // Number of batteries supported
    BOOLEAN             SelectorPresent;    // Is there a selector present

    PBATTERY_SELECTOR   Selector;           // Selector specific info

    //
    // Stuff for handling the SMB alarms for the smart battery subsystem
    //

    LIST_ENTRY          AlarmList;
    KSPIN_LOCK          AlarmListLock;
    PIO_WORKITEM        WorkerThread;       // WORK_QUEUE to get worker thread
    ULONG               WorkerActive;

    //
    // Keep a list of the battery PDOs I "discover"
    //

    PDEVICE_OBJECT      BatteryPdoList[MAX_SMART_BATTERIES_SUPPORTED];
} SMB_BATT_SUBSYSTEM, *PSMB_BATT_SUBSYSTEM;


//
// Device extension for the smart battery PDOs
// (Created by IoCreateDevice SMB_BATT_PDO for each battery)
//

typedef struct _SMB_BATT_PDO {
    SMB_FDO_TYPE        SmbBattFdoType;     // Device object type
    IO_REMOVE_LOCK      RemoveLock;

    //
    // All elements above this point must be identical in
    // SMB_NP_BATT, SMB_BATT_SUBSYSTEM, and SMB_BATT_PDO structures.
    //

    PDEVICE_OBJECT      DeviceObject;       // Battery PDO
    PDEVICE_OBJECT      Fdo;                // Battery FDO layered on top of PDO
    PDEVICE_OBJECT      SubsystemFdo;       // Smart Battery subsystem FDO
    ULONG               BatteryNumber;      // Used by subsystem during battery
                                            //   FDO init
} SMB_BATT_PDO, *PSMB_BATT_PDO;


//
// SMBus Smart battery addresses and registers
//

#define SMB_HOST_ADDRESS     0x8            // Address on bus (10H)
#define SMB_CHARGER_ADDRESS  0x9            // Address on bus (12H)
#define SMB_SELECTOR_ADDRESS 0xa            // Address on bus (14H)
#define SMB_BATTERY_ADDRESS  0xb            // Address on bus (16H)
#define SMB_ALERT_ADDRESS    0xc            // Address on bus (18H)

//
// Smart Battery command codes
//

#define BAT_REMAINING_CAPACITY_ALARM        0x01        // word
#define BAT_REMAINING_TIME_ALARM            0x02        // word
#define BAT_BATTERY_MODE                    0x03        // word
#define BAT_AT_RATE                         0x04        // word
#define BAT_RATE_TIME_TO_FULL               0x05        // word
#define BAT_RATE_TIME_TO_EMPTY              0x06        // word
#define BAT_RATE_OK                         0x07        // word
#define BAT_TEMPERATURE                     0x08        // word
#define BAT_VOLTAGE                         0x09        // word
#define BAT_CURRENT                         0x0a        // word
#define BAT_AVERAGE_CURRENT                 0x0b        // word
#define BAT_MAX_ERROR                       0x0c        // word
#define BAT_RELATIVE_STATE_OF_CHARGE        0x0d        // word
#define BAT_ABSOLUTE_STATE_OF_CHARGE        0x0e        // word
#define BAT_REMAINING_CAPACITY              0x0f        // word
#define BAT_FULL_CHARGE_CAPACITY            0x10        // word
#define BAT_RUN_TO_EMPTY                    0x11        // word
#define BAT_AVERAGE_TIME_TO_EMPTY           0x12        // word
#define BAT_AVERAGE_TIME_TO_FULL            0x13        // word
#define BAT_STATUS                          0x16        // word
#define BAT_CYCLE_COUNT                     0x17        // word
#define BAT_DESIGN_CAPACITY                 0x18        // word
#define BAT_DESIGN_VOLTAGE                  0x19        // word
#define BAT_SPECITICATION_INFO              0x1a        // word
#define BAT_MANUFACTURER_DATE               0x1b        // word
#define BAT_SERIAL_NUMBER                   0x1c        // word
#define BAT_MANUFACTURER_NAME               0x20        // block
#define BAT_DEVICE_NAME                     0x21        // block
#define BAT_CHEMISTRY                       0x22        // block
#define BAT_MANUFACTURER_DATA               0x23        // block

//
// Battery Mode Definitions
//

#define CAPACITY_WATTS_MODE                 0x8000

//
// Battery Scale Factors
//

#define BSCALE_FACTOR_0         1
#define BSCALE_FACTOR_1         10
#define BSCALE_FACTOR_2         100
#define BSCALE_FACTOR_3         1000

#define BATTERY_VSCALE_MASK     0x0f00
#define BATTERY_IPSCALE_MASK    0xf000

#define BATTERY_VSCALE_SHIFT    8
#define BATTERY_IPSCALE_SHIFT   12


//
// Selector command codes
//

#define SELECTOR_SELECTOR_STATE             0x01        // word
#define SELECTOR_SELECTOR_PRESETS           0x02        // word
#define SELECTOR_SELECTOR_INFO              0x04        // word

//
// Selector Equates
//

#define SELECTOR_SHIFT_CHARGE                   4
#define SELECTOR_SHIFT_POWER                    8
#define SELECTOR_SHIFT_COM                      12

#define SELECTOR_STATE_PRESENT_MASK             0x000F
#define SELECTOR_STATE_CHARGE_MASK              0x00F0
#define SELECTOR_STATE_POWER_BY_MASK            0x0F00
#define SELECTOR_STATE_SMB_MASK                 0xF000

#define SELECTOR_SET_COM_MASK                   0x0FFF
#define SELECTOR_SET_POWER_BY_MASK              0xF0FF
#define SELECTOR_SET_CHARGE_MASK                0xFF0F

#define BATTERY_A_PRESENT                       0x0001
#define BATTERY_B_PRESENT                       0x0002
#define BATTERY_C_PRESENT                       0x0004
#define BATTERY_D_PRESENT                       0x0008

#define SELECTOR_STATE_PRESENT_CHANGE           0x1
#define SELECTOR_STATE_CHARGE_CHANGE            0x2
#define SELECTOR_STATE_POWER_BY_CHANGE          0x4
#define SELECTOR_STATE_SMB_CHANGE               0x8

#define SELECTOR_PRESETS_OKTOUSE_MASK           0x000F
#define SELECTOR_PRESETS_USENEXT_MASK           0x00F0

#define SELECTOR_SHIFT_USENEXT                  4

#define SELECTOR_INFO_SUPPORT_MASK              0x000F
#define SELECTOR_INFO_SPEC_REVISION_MASK        0x00F0
#define SELECTOR_INFO_CHARGING_INDICATOR_BIT    0x0100

#define SELECTOR_SHIFT_REVISION                 4

//
// Charger command codes
//

#define CHARGER_SPEC_INFO                   0x11        // word
#define CHARGER_MODE                        0x12        // word
#define CHARGER_STATUS                      0x13        // word
#define CHARGER_CHARGING_CURRENT            0x14        // word
#define CHARGER_CHARGING_VOLTAGE            0x15        // word
#define CHARGER_ALARM_WARNING               0x16        // word

#define CHARGER_SELECTOR_COMMANDS           0x20

#define CHARGER_SELECTOR_STATE              CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_STATE
#define CHARGER_SELECTOR_PRESETS            CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_PRESETS
#define CHARGER_SELECTOR_INFO               CHARGER_SELECTOR_COMMANDS | \
                                            SELECTOR_SELECTOR_INFO

//
// Charger Status Definitions
//

#define CHARGER_STATUS_BATTERY_PRESENT_BIT  0x4000
#define CHARGER_STATUS_AC_PRESENT_BIT       0x8000

//
// Charger Specification Info Definitions
//

#define CHARGER_SELECTOR_SUPPORT_BIT        0x0010

//
// SelectorState ReverseLogic Equates
//

#define INVALID         0xFF


#define BATTERY_A       0x00
#define BATTERY_B       0x01
#define BATTERY_C       0x02
#define BATTERY_D       0x03

#define MULTIBATT_AB    0x04
#define MULTIBATT_AC    0x08
#define MULTIBATT_BC    0x09
#define MULTIBATT_ABC   0x24

#define BATTERY_NONE    0xFF

// word to byte helpers

#define WORD_MSB_SHIFT  8
#define WORD_LSB_MASK   0xFF


//
// Function Prototypes
//

VOID
SmbBattLockDevice (
    IN PSMB_BATT        SmbBatt
);


VOID
SmbBattUnlockDevice (
    IN PSMB_BATT        SmbBatt
);


VOID
SmbBattRequest (
    IN PSMB_BATT        SmbBatt,
    IN PSMB_REQUEST     SmbReq
);


NTSTATUS
SmbBattSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
);


VOID
SmbBattRB(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PUCHAR          Buffer,
    OUT PUCHAR          BufferLength
);


VOID
SmbBattRW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
);


VOID
SmbBattRSW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    OUT PLONG           Result
);


VOID
SmbBattWW(
    IN PSMB_BATT        SmbBatt,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
);


UCHAR
SmbBattGenericRW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
);


UCHAR
SmbBattGenericWW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
);


VOID
SmbBattGenericRequest (
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN PSMB_REQUEST     SmbReq
);


VOID
SmbBattAlarm (
    IN PVOID            Context,
    IN UCHAR            Address,
    IN USHORT           Data
);


BOOLEAN
SmbBattVerifyStaticInfo (
    IN PSMB_BATT        SmbBatt,
    IN ULONG            BatteryTag
);


NTSTATUS
SmbBattPowerDispatch(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
);


NTSTATUS
SmbBattPnpDispatch(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
);


NTSTATUS
SmbBattRegisterForAlarm(
    IN PDEVICE_OBJECT   Fdo
);


NTSTATUS
SmbBattUnregisterForAlarm(
    IN PDEVICE_OBJECT   Fdo
);


NTSTATUS
SmbBattSetSelectorComm (
    IN  PSMB_BATT   SmbBatt,
    OUT PULONG      OldSelectorState
);


NTSTATUS
SmbBattResetSelectorComm (
    IN PSMB_BATT    SmbBatt,
    IN ULONG        OldSelectorState
);


NTSTATUS
SmbGetSBS (
    IN PULONG           NumberOfBatteries,
    IN PBOOLEAN         SelectorPresent,
    IN PDEVICE_OBJECT   LowerDevice
);


NTSTATUS
SmbGetGLK (
    IN PBOOLEAN         GlobalLockRequired,
    IN PDEVICE_OBJECT   LowerDevice
);


NTSTATUS
SmbBattCreatePdos(
    IN PDEVICE_OBJECT   SubsystemFdo
);


NTSTATUS
SmbBattBuildDeviceRelations(
    IN  PSMB_BATT_SUBSYSTEM SubsystemExt,
    IN  PDEVICE_RELATIONS   *DeviceRelations
);


NTSTATUS
SmbBattQueryDeviceRelations(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattRemoveDevice(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattQueryId(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
);


NTSTATUS
SmbBattQueryCapabilities(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
);


SmbBattBuildSelectorStruct(
    IN PDEVICE_OBJECT   SubsystemFdo
);


VOID
SmbBattWorkerThread (
    IN PDEVICE_OBJECT   Fdo,
    IN PVOID            Context
);


VOID
SmbBattLockSelector (
    IN PBATTERY_SELECTOR    Selector
);


VOID
SmbBattUnlockSelector (
    IN PBATTERY_SELECTOR    Selector
);


ULONG
SmbBattGetSelectorDeltas (
    IN ULONG            OriginalSelectorState,
    IN ULONG            NewSelectorState
);


VOID
SmbBattProcessPresentChanges (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);

VOID
SmbBattProcessChargeChange (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);


VOID
SmbBattProcessPowerByChange (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OriginalSelectorState,
    IN ULONG                NewSelectorState
);


VOID
SmbBattNotifyClassDriver (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                BatteryIndex
);

#if DEBUG
NTSTATUS
SmbBattDirectDataAccess (
    IN PSMB_NP_BATT         DeviceExtension,
    IN PSMBBATT_DATA_STRUCT IoBuffer,
    IN ULONG                InputLen,
    IN ULONG                OutputLen
);
#endif


VOID
SmbBattProcessChargerAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                ChargerStatus
);

NTSTATUS
SmbBattSetInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL    Level,
    IN PVOID Buffer                     OPTIONAL
);


UCHAR
SmbBattIndex (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble,
    IN UCHAR                SimultaneousIndex
);

BOOLEAN
SmbBattReverseLogic (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble
);

extern BOOLEAN   SmbBattUseGlobalLock;

NTSTATUS
SmbBattAcquireGlobalLock (
    IN  PDEVICE_OBJECT LowerDeviceObject,
    OUT PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
);

NTSTATUS
SmbBattReleaseGlobalLock (
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
);

NTSTATUS
SmbBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

NTSTATUS
SmbBattWmiRegistration(
    PSMB_NP_BATT SmbNPBatt
);

NTSTATUS
SmbBattWmiDeRegistration(
    PSMB_NP_BATT SmbNPBatt
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbbatt\smbmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbmisc.c

Abstract:

    SMBus handler functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"


//
// Make the SelectorBit table pageable
//

//#ifdef ALLOC_DATA_PRAGMA
//#pragma data_seg("PAGE")
//#endif

//
// Lookup table for the battery that corresponds to bit positions and
// whether or not reverse logic is being used (to indicate charging or
// discharging).
//
// NOTE: To support Simultaneous Charging and Powering, this table
// has been modified to account for multiple bits.  Also, it can't be
// used for battery index lookup since it assumes one bit set maximum.
// Instead, use special indexes for multiple batteries as follows:
//
// 1st Battery = Index & 0x03
// 2nd Battery = (Index >> 2) & 0x03 (Battery A not allowed)
// 3rd Battery = (Index >> 4) & 0x03 (Battery A not allowed)
//
// In < 4 battery systems the Battery D bit can be used to determine
// the nibbles that are inverted, and it allows the following combinations:
//
//          Battery A & B
//          Battery A & C
//          Battery B & C
//          Battery A, B, & C
//

const SELECTOR_STATE_LOOKUP SelectorBits [16] = {
    {BATTERY_NONE,  FALSE},         // Bit Pattern: 0000
    {BATTERY_A,     FALSE},         //              0001
    {BATTERY_B,     FALSE},         //              0010
    {MULTIBATT_AB,  FALSE},         //              0011
    {BATTERY_C,     FALSE},         //              0100
    {MULTIBATT_AC,  FALSE},         //              0101
    {MULTIBATT_BC,  FALSE},         //              0110
    {MULTIBATT_ABC, FALSE},         //              0111
    {MULTIBATT_ABC, TRUE},          //              1000
    {MULTIBATT_BC,  TRUE},          //              1001
    {MULTIBATT_AC,  TRUE},          //              1010
    {BATTERY_C,     TRUE},          //              1011
    {MULTIBATT_AB,  TRUE},          //              1100
    {BATTERY_B,     TRUE},          //              1101
    {BATTERY_A,     TRUE},          //              1110
    {BATTERY_NONE,  TRUE}           //              1111
};

//
// Note: For 4-Battery Systems to support Simultaneous Capability
// properly, the following two assumptions must be made:
//      - Battery D can never be used simultaneously.
//      - Three batteries can not be used simultaneously.
//
// This allows for only the following possible battery combinations:
//
//          Battery A & B
//          Battery A & C
//          Battery B & C
//
// The following table is used for 4-battery lookup
//

const SELECTOR_STATE_LOOKUP SelectorBits4 [16] = {
    {BATTERY_NONE,  FALSE},         // Bit Pattern: 0000
    {BATTERY_A,     FALSE},         //              0001
    {BATTERY_B,     FALSE},         //              0010
    {MULTIBATT_AB,  FALSE},         //              0011
    {BATTERY_C,     FALSE},         //              0100
    {MULTIBATT_AC,  FALSE},         //              0101
    {MULTIBATT_BC,  FALSE},         //              0110
    {BATTERY_D,     TRUE},          //              0111
    {BATTERY_D,     FALSE},         //              1000
    {MULTIBATT_BC,  TRUE},          //              1001
    {MULTIBATT_AC,  TRUE},          //              1010
    {BATTERY_C,     TRUE},          //              1011
    {MULTIBATT_AB,  TRUE},          //              1100
    {BATTERY_B,     TRUE},          //              1101
    {BATTERY_A,     TRUE},          //              1110
    {BATTERY_NONE,  TRUE}           //              1111
};


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattLockDevice)
#pragma alloc_text(PAGE,SmbBattUnlockDevice)
#pragma alloc_text(PAGE,SmbBattLockSelector)
#pragma alloc_text(PAGE,SmbBattUnlockSelector)
#pragma alloc_text(PAGE,SmbBattRequest)
#pragma alloc_text(PAGE,SmbBattRB)
#pragma alloc_text(PAGE,SmbBattRW)
#pragma alloc_text(PAGE,SmbBattRSW)
#pragma alloc_text(PAGE,SmbBattWW)
#pragma alloc_text(PAGE,SmbBattGenericRW)
#pragma alloc_text(PAGE,SmbBattGenericWW)
#pragma alloc_text(PAGE,SmbBattGenericRequest)
#pragma alloc_text(PAGE,SmbBattSetSelectorComm)
#pragma alloc_text(PAGE,SmbBattResetSelectorComm)
#if DEBUG
#pragma alloc_text(PAGE,SmbBattDirectDataAccess)
#endif
#pragma alloc_text(PAGE,SmbBattIndex)
#pragma alloc_text(PAGE,SmbBattReverseLogic)
#pragma alloc_text(PAGE,SmbBattAcquireGlobalLock)
#pragma alloc_text(PAGE,SmbBattReleaseGlobalLock)
#endif



VOID
SmbBattLockDevice (
    IN PSMB_BATT    SmbBatt
    )
{
    PAGED_CODE();

    //
    // Get device lock on the battery
    //

    ExAcquireFastMutex (&SmbBatt->NP->Mutex);
}



VOID
SmbBattUnlockDevice (
    IN PSMB_BATT    SmbBatt
    )
{
    PAGED_CODE();

    //
    // Release device lock on the battery
    //

    ExReleaseFastMutex (&SmbBatt->NP->Mutex);
}



VOID
SmbBattLockSelector (
    IN PBATTERY_SELECTOR    Selector
    )
{
    PAGED_CODE();

    //
    // Get device lock on the selector
    //

    if (Selector) {
        ExAcquireFastMutex (&Selector->Mutex);
    }
}



VOID
SmbBattUnlockSelector (
    IN PBATTERY_SELECTOR    Selector
    )
{
    PAGED_CODE();

    //
    // Release device lock on the selector
    //

    if (Selector) {
        ExReleaseFastMutex (&Selector->Mutex);
    }
}



NTSTATUS
SmbBattSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    Context is the event to set

--*/
{
    PKEVENT         Event;

    Event = (PKEVENT) Context;
    KeSetEvent (Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
SmbBattRequest (
    IN PSMB_BATT    SmbBatt,
    IN PSMB_REQUEST SmbReq
    )
// function to issue SMBus request
{
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    BOOLEAN             useLock = SmbBattUseGlobalLock;
    ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER globalLock;

    PAGED_CODE();

    //
    // Build Io Control for SMB bus driver for this request
    //

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    if (!SmbBatt->SmbHcFdo) {
        //
        // The SMB host controller either hasn't been opened yet (in start device) or
        // there was an error opening it and we did not get deleted somehow.
        //

        BattPrint(BAT_ERROR, ("SmbBattRequest: SmbHc hasn't been opened yet \n"));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    Irp = IoAllocateIrp (SmbBatt->SmbHcFdo->StackSize, FALSE);
    if (!Irp) {
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = SmbReq;
    IoSetCompletionRoutine (Irp, SmbBattSynchronousRequest, &Event, TRUE, TRUE, TRUE);

    //
    // Issue it
    //

    //
    // Note: uselock is a cached value of the global variable, so in case the
    // value changes, we won't aquire and not release etc.
    //
    if (useLock) {
        if (!NT_SUCCESS (SmbBattAcquireGlobalLock (SmbBatt->SmbHcFdo, &globalLock))) {
            useLock = FALSE;
        }
    }

    IoCallDriver (SmbBatt->SmbHcFdo, Irp);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    Status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);

    if (useLock) {
        SmbBattReleaseGlobalLock (SmbBatt->SmbHcFdo, &globalLock);
    }

    //
    // Check result code
    //

    if (!NT_SUCCESS(Status)) {
        BattPrint(BAT_ERROR, ("SmbBattRequest: error in SmbHc request - %x\n", Status));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
    }
}



VOID
SmbBattRB(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PUCHAR      Buffer,
    OUT PUCHAR      BufferLength
    )
// function to read-block from the battery
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_BLOCK;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status == SMB_STATUS_OK) {
        ASSERT (SmbReq.BlockLength < SMB_MAX_DATA_SIZE);
        memcpy (Buffer, SmbReq.Data, SmbReq.BlockLength);
        *BufferLength = SmbReq.BlockLength;
    } else {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }
}



VOID
SmbBattRW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PULONG      Result
    )
// function to read-word from the battery
// N.B. word is returned as a ULONG
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_WORD;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status != SMB_STATUS_OK) {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }

    *Result = SmbReq.Data[0] | SmbReq.Data[1] << WORD_MSB_SHIFT;
    BattPrint(BAT_IO, ("SmbBattRW: Command: %02x == %04x\n", SmbCmd, *Result));
}


VOID
SmbBattRSW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    OUT PLONG       Result
    )
// function to read-signed-word from the battery
// N.B. word is returned as a LONG
{
    ULONG           i;

    PAGED_CODE();

    SmbBattRW(SmbBatt, SmbCmd, &i);
    *Result = ((SHORT) i);
}


VOID
SmbBattWW(
    IN PSMB_BATT    SmbBatt,
    IN UCHAR        SmbCmd,
    IN ULONG        Data
    )
// function to write-word to the battery
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_WRITE_WORD;
    SmbReq.Address  = SMB_BATTERY_ADDRESS;
    SmbReq.Command  = SmbCmd;
    SmbReq.Data[0]  = (UCHAR) (Data & WORD_LSB_MASK);
    SmbReq.Data[1]  = (UCHAR) (Data >> WORD_MSB_SHIFT) & WORD_LSB_MASK;
    BattPrint(BAT_IO, ("SmbBattWW: Command: %02x = %04x\n", SmbCmd, Data));
    SmbBattRequest (SmbBatt, &SmbReq);

    if (SmbReq.Status != SMB_STATUS_OK) {
        // some sort of failure, check tag data for cache validity
        SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
    }
}



UCHAR
SmbBattGenericRW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    OUT PULONG          Result
    )
// function to read-word from the SMB device (charger or selector)
// N.B. word is returned as a ULONG
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_READ_WORD;
    SmbReq.Address  = Address;
    SmbReq.Command  = SmbCmd;
    SmbBattGenericRequest (SmbHcFdo, &SmbReq);

    *Result = SmbReq.Data[0] | (SmbReq.Data[1] << WORD_MSB_SHIFT);
    BattPrint(BAT_IO, ("SmbBattGenericRW: Address: %02x:%02x == %04x\n", Address, SmbCmd, *Result));
    return SmbReq.Status;
}


UCHAR
SmbBattGenericWW(
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN UCHAR            Address,
    IN UCHAR            SmbCmd,
    IN ULONG            Data
    )
// function to write-word to SMB device (charger or selector)
{
    SMB_REQUEST     SmbReq;

    PAGED_CODE();

    SmbReq.Protocol = SMB_WRITE_WORD;
    SmbReq.Address  = Address;
    SmbReq.Command  = SmbCmd;
    SmbReq.Data[0]  = (UCHAR) (Data & WORD_LSB_MASK);
    SmbReq.Data[1]  = (UCHAR) (Data >> WORD_MSB_SHIFT) & WORD_LSB_MASK;

    BattPrint(BAT_IO, ("SmbBattGenericWW: Address: %02x:%02x = %04x\n", Address, SmbCmd, Data));
    SmbBattGenericRequest (SmbHcFdo, &SmbReq);
    return SmbReq.Status;

}



VOID
SmbBattGenericRequest (
    IN PDEVICE_OBJECT   SmbHcFdo,
    IN PSMB_REQUEST     SmbReq
    )
// function to issue SMBus request
{
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    BOOLEAN             useLock = SmbBattUseGlobalLock;
    ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER globalLock;

    PAGED_CODE();


    //
    // Build Io Control for SMB bus driver for this request
    //

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    if (!SmbHcFdo) {
        //
        // The SMB host controller either hasn't been opened yet (in start device) or
        // there was an error opening it and we did not get deleted somehow.
        //

        BattPrint(BAT_ERROR, ("SmbBattGenericRequest: SmbHc hasn't been opened yet \n"));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }


    Irp = IoAllocateIrp (SmbHcFdo->StackSize, FALSE);
    if (!Irp) {
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
        return ;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = SmbReq;
    IoSetCompletionRoutine (Irp, SmbBattSynchronousRequest, &Event, TRUE, TRUE, TRUE);

    //
    // Issue it
    //

    //
    // Note: uselock is a cached value of the global variable, so in case the
    // value changes, we won't acquire and not release etc.
    //
    if (useLock) {
        if (!NT_SUCCESS (SmbBattAcquireGlobalLock (SmbHcFdo, &globalLock))) {
            useLock = FALSE;
        }
    }

    IoCallDriver (SmbHcFdo, Irp);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    Status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);

    if (useLock) {
        SmbBattReleaseGlobalLock (SmbHcFdo, &globalLock);
    }

    //
    // Check result code
    //

    if (!NT_SUCCESS(Status)) {
        BattPrint(BAT_ERROR, ("SmbBattGenericRequest: error in SmbHc request - %x\n", Status));
        SmbReq->Status = SMB_UNKNOWN_FAILURE;
    }
}



NTSTATUS
SmbBattSetSelectorComm (
    IN  PSMB_BATT   SmbBatt,
    OUT PULONG      OldSelectorState
    )
/*++

Routine Description:

    This routine sets the communication path through the selector to the calling
    battery.  It returns the original selector state in the variable provided.

    NOTE:   It is assumed that the caller already has acquired the device lock on the
            selector before calling us.

    NOTE:   This function should always be called in a pair with SmbBattResetSelectorComm

Arguments:

    SmbBatt             - Nonpaged extension for current battery

    OldSelectorState    - Original selector state at start of this function

Return Value:

    NTSTATUS

--*/
{
    PBATTERY_SELECTOR       selector;
    UCHAR                   smbStatus;
    ULONG                   requestData;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetSelectorComm: ENTERING\n"));

    //
    // We only need to do this if there is a selector in the system.
    //

    if (SmbBatt->SelectorPresent) {

        selector            = SmbBatt->Selector;
        *OldSelectorState   = selector->SelectorState;

        //
        // If the battery isn't present, fail the request.
        //
        if (!(selector->SelectorState & SmbBatt->SelectorBitPosition)) {
            return STATUS_NO_SUCH_DEVICE;
        }

        //
        // See if we are already set up to talk with the requesting battery.
        // We will check against the cached information in the selector struct.
        //

        if (selector->SelectorState & (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_COM)) {
            return STATUS_SUCCESS;
        }

        //
        // Build the data word to change the selector communications.  This will
        // look like the following:
        //
        // PRESENT field        0xf     we don't want to change anything here
        // CHARGE field         0xf     we don't want to change anything here
        // POWER BY field       0xf     we don't want to change anything here
        // SMB field            0x_     the bit set according to the battery number
        //

        requestData = (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_COM) | SELECTOR_SET_COM_MASK;

        smbStatus = SmbBattGenericWW (
                        SmbBatt->SmbHcFdo,
                        selector->SelectorAddress,
                        selector->SelectorStateCommand,
                        requestData
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (BAT_ERROR, ("SmbBattSetSelectorComm:  couldn't write selector state - %x\n", smbStatus));
            return STATUS_UNSUCCESSFUL;
        } else {
            selector->SelectorState |= SELECTOR_STATE_SMB_MASK;
            selector->SelectorState &= requestData;

            BattPrint (BAT_IO, ("SmbBattSetSelectorComm: state after write -  %x\n", selector->SelectorState));
        }

    }   // if (subsystemExt->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattSetSelectorComm: EXITING\n"));
    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattResetSelectorComm (
    IN PSMB_BATT    SmbBatt,
    IN ULONG        OldSelectorState
    )
/*++

Routine Description:

    This routine resets the communication path through the selector to the its
    original state.  It returns the original selector state in the variable provided.

    NOTE:   It is assumed that the caller already has acquired the device lock on the
            selector before calling us.

    NOTE:   This function should always be called in a pair with SmbBattSetSelectorComm

Arguments:

    SmbBatt             - Nonpaged extension for current battery

    OldSelectorState    - Original selector state to be restored

Return Value:

    NTSTATUS

--*/
{
    PBATTERY_SELECTOR       selector;
    UCHAR                   smbStatus;
    ULONG                   tmpState;

    NTSTATUS                status      = STATUS_SUCCESS;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattResetSelectorComm: ENTERING\n"));

    //
    // We only need to do this if there is a selector in the system.
    //

    if (SmbBatt->SelectorPresent) {

        selector = SmbBatt->Selector;

        //
        // See if we were already set up to talk with the requesting battery.
        // We will check against the cached information in the selector struct.
        //

        if ((OldSelectorState & selector->SelectorState) & SELECTOR_STATE_SMB_MASK) {
            return STATUS_SUCCESS;
        }

        //
        // Change the selector communications back.  The SMB field is the only
        // that we will write.
        //

        tmpState  = SELECTOR_SET_COM_MASK;
        tmpState |= OldSelectorState & SELECTOR_STATE_SMB_MASK;

        smbStatus = SmbBattGenericWW (
                        SmbBatt->SmbHcFdo,
                        selector->SelectorAddress,
                        selector->SelectorStateCommand,
                        tmpState
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (
                BAT_ERROR,
                ("SmbBattResetSelectorComm: couldn't write selector state - %x\n",
                smbStatus)
            );
            status = STATUS_UNSUCCESSFUL;
        } else {
            selector->SelectorState |= SELECTOR_STATE_SMB_MASK;
            selector->SelectorState &= tmpState;
            BattPrint (
                BAT_IO,
                ("SmbBattResetSelectorComm: state after write -  %x\n",
                selector->SelectorState)
            );
        }

    }   // if (subsystemExt->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattResetSelectorComm: EXITING\n"));
    return status;
}



#if DEBUG
NTSTATUS
SmbBattDirectDataAccess (
    IN PSMB_NP_BATT         DeviceExtension,
    IN PSMBBATT_DATA_STRUCT IoBuffer,
    IN ULONG                InputLen,
    IN ULONG                OutputLen
    )
/*++

Routine Description:

    This routine is used to handle IOCTLs acessing the SMBBatt commands directly.

Arguments:

    DeviceExtension         - Device extension for the smart battery subsystem

    IoBuffer                - Buffer that contains the input structure and will
                              contain the results of the read.

Return Value:

    NTSTATUS
--*/
{
    PSMB_BATT_SUBSYSTEM     SubsystemExt;
    PSMB_BATT               SmbBatt;

    UCHAR                   address;
    UCHAR                   command;
    UCHAR                   smbStatus;
    ULONG                   oldSelectorState;
    ULONG                   ReturnBufferLength;
    UCHAR               strLength;
    UCHAR               strBuffer[SMB_MAX_DATA_SIZE+1]; // +1 extra char to hold NULL
    UCHAR               strBuffer2[SMB_MAX_DATA_SIZE+1];
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    UCHAR               tempFlags;

    NTSTATUS                status = STATUS_SUCCESS;

    PAGED_CODE();

    if (InputLen < sizeof(SMBBATT_DATA_STRUCT)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if ((DeviceExtension->SmbBattFdoType == SmbTypeBattery)
            && (IoBuffer->Address == SMB_BATTERY_ADDRESS)) {
        // This is a battery data request
        SmbBatt = DeviceExtension->Batt;
        SmbBattLockSelector (SmbBatt->Selector);
        SmbBattLockDevice (SmbBatt);
        status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
        if (NT_SUCCESS (status)) {
            if ((InputLen >= sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen == 0)) {
                // This is a write command
                status = STATUS_NOT_IMPLEMENTED;
            } else if ((InputLen == sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen > 0)){
                // This is a Read command

                if ((IoBuffer->Command >= BAT_REMAINING_CAPACITY_ALARM) &&
                    (IoBuffer->Command <= BAT_SERIAL_NUMBER)) {

                    // ReadWord Commands
                    if (OutputLen == sizeof(SMBBATT_DATA_STRUCT)) {
                        tempFlags = SmbBatt->Info.Valid;
                        SmbBatt->Info.Valid |= VALID_TAG_DATA;
                        SmbBattRW(SmbBatt, IoBuffer->Command, &IoBuffer->Data.Ulong);
                        if (SmbBatt->Info.Valid & VALID_TAG_DATA) {
                            ReturnBufferLength = sizeof(ULONG);
                        } else {
                            status = STATUS_DATA_ERROR;
                        }
                        SmbBatt->Info.Valid = tempFlags;
                    } else {
                        status = STATUS_INVALID_BUFFER_SIZE;
                    }

                } else if ((IoBuffer->Command >= BAT_MANUFACTURER_NAME) &&
                    (IoBuffer->Command <= BAT_MANUFACTURER_DATA)) {

                    // ReadBlock Commands
                    if (OutputLen == (SMBBATT_DATA_STRUCT_SIZE)+(SMB_MAX_DATA_SIZE*2)) {
                        memset (&IoBuffer->Data.Block[0], 0, (SMB_MAX_DATA_SIZE*2));
                        unicodeString.Buffer        = &IoBuffer->Data.Block[0];
                        unicodeString.MaximumLength = SMB_MAX_DATA_SIZE*2;
                        unicodeString.Length        = 0;

                        memset (strBuffer, 0, sizeof(strBuffer));
                        memset (strBuffer2, 0, sizeof(strBuffer2));
                        do {
                            SmbBattRB (
                                SmbBatt,
                                IoBuffer->Command,
                                strBuffer,
                                &strLength
                            );

                            SmbBattRB (
                                SmbBatt,
                                IoBuffer->Command,
                                strBuffer2,
                                &strLength
                            );
                        } while (strcmp (strBuffer, strBuffer2));

                        RtlInitAnsiString (&ansiString, strBuffer);
                        RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);

                        ReturnBufferLength  = unicodeString.Length;


                    } else {
                        status = STATUS_INVALID_BUFFER_SIZE;
                    }
                } else {
                    // Unsupported Commands
                    status = STATUS_INVALID_PARAMETER;
                }
            }

        }

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        SmbBattUnlockDevice (SmbBatt);
        SmbBattUnlockSelector (SmbBatt->Selector);
    } else if (DeviceExtension->SmbBattFdoType == SmbTypeSubsystem) {
        // This is a battery subsystem
        SubsystemExt = (PSMB_BATT_SUBSYSTEM) DeviceExtension;
        SmbBattLockSelector (SubsystemExt->Selector);

        if ((InputLen >= sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen == 0)) {
            // This is a write command
            status = STATUS_NOT_IMPLEMENTED;
        } else if ((InputLen == sizeof(SMBBATT_DATA_STRUCT)) && (OutputLen > 0)){
            // This is a Read command

            switch (IoBuffer->Address) {

                case SMB_SELECTOR_ADDRESS:

                    //
                    // We have to do some translation for selector requests depending
                    // on whether the selector is stand alone or implemented in the
                    // charger.
                    //

                    if ((SubsystemExt->SelectorPresent) && (SubsystemExt->Selector)) {

                        address = SubsystemExt->Selector->SelectorAddress;
                        command = IoBuffer->Command;

                        // Map to Charger if Selector is implemented in the Charger
                        if (address == SMB_CHARGER_ADDRESS) {
                            switch (command) {
                                case SELECTOR_SELECTOR_STATE:
                                case SELECTOR_SELECTOR_PRESETS:
                                case SELECTOR_SELECTOR_INFO:
                                    command |= CHARGER_SELECTOR_COMMANDS;
                                    break;

                                default:
                                    status = STATUS_NOT_SUPPORTED;
                                    break;
                            }
                        }

                    } else {
                        status = STATUS_NO_SUCH_DEVICE;
                    }

                    break;

                case SMB_CHARGER_ADDRESS:

                    //
                    // For this one we currently only support the ChargerStatus and
                    // ChargerSpecInfo commands.
                    //
                    // Other commands are not currently supported.
                    //

                    address = IoBuffer->Address;

                    switch (IoBuffer->Command) {
                        case CHARGER_SPEC_INFO:
                        case CHARGER_STATUS:

                            command = IoBuffer->Command;
                            break;

                        default:
                            status = STATUS_NOT_SUPPORTED;
                            break;

                    }

                    break;


                default:
                    status = STATUS_NOT_SUPPORTED;
                    break;

            }   // switch (readStruct->Address)

            if (status == STATUS_SUCCESS) {
                //
                // Do the read command
                //

                smbStatus = SmbBattGenericRW (
                                SubsystemExt->SmbHcFdo,
                                address,
                                command,
                                &IoBuffer->Data.Ulong
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint (
                        BAT_ERROR,
                        ("SmbBattDirectDataAccess:  Couldn't read from - %x, status - %x\n",
                        address,
                        smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;

                }
            }

        }

        SmbBattUnlockSelector (SubsystemExt->Selector);
    } else {
        status=STATUS_INVALID_DEVICE_REQUEST;
        BattPrint (
            BAT_ERROR,
            ("SmbBattDirectDataAccess: Invalid SmbBattFdoType")
        );
    }

    return status;
}
#endif


UCHAR
SmbBattIndex (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble,
    IN UCHAR                SimultaneousIndex
)
/*++

Routine Description:

    This routine is provided as a helper routine to determine which
    battery is selected in a given selector nibble, based on the number
    of batteries supported in the system.

Arguments:

    Selector            - Structure defining selector address and commands

    SelectorNibble      - The nibble of the SelectorState, moved to the low
                          order 4 bits, to check reverse logic on.

    SimultaneousIndex   - Which batteryindex is requested in simultaneous-
                          battery situations (0, 1, or 2)

Return Value:

    BatteryIndex =  0 - Battery A
                    1 - Battery B
                    2 - Battery C
                    3 - Battery D
                   FF - No Battery

--*/
{
    UCHAR   batteryIndex;

    PAGED_CODE();

    // Assume if SelectorInfo supports 4 batteries, use SelectorBits4 table
    if (Selector->SelectorInfo & BATTERY_D_PRESENT) {
        batteryIndex = SelectorBits4[SelectorNibble].BatteryIndex;
    } else {
        batteryIndex = SelectorBits[SelectorNibble].BatteryIndex;
    }

    // If it's valid
    if (batteryIndex != BATTERY_NONE) {

        // return index for First Battery
        if (SimultaneousIndex == 0) {
            return (batteryIndex & 3);

        // return index for Second Battery
        } else if (SimultaneousIndex == 1) {
            batteryIndex = (batteryIndex >> 2) & 3;
            if (batteryIndex != BATTERY_A) {
                return (batteryIndex);
            }

        // return index for Third Battery
        } else if (SimultaneousIndex == 2) {
            batteryIndex = (batteryIndex >> 2) & 3;
            if (batteryIndex != BATTERY_A) {
                return (batteryIndex);
            }
        }
    }

    // return no battery index
    return (BATTERY_NONE);
}



BOOLEAN
SmbBattReverseLogic (
    IN PBATTERY_SELECTOR    Selector,
    IN ULONG                SelectorNibble
)
/*++

Routine Description:

    This routine is provided as a helper routine to determine the reverse
    logic on a given selector nibble, based on the number of batteries
    supported in the system.

Arguments:

    Selector            - Structure defining selector address and commands

    SelectorNibble      - The nibble of the SelectorState, moved to the low
                          order 4 bits, to check reverse logic on.

Return Value:

    FALSE if the nibble is normal
    TRUE if the nibble is inverted

--*/
{

    PAGED_CODE();

    // Assume if SelectorInfo supports 4 batteries, use SelectorBits4 table
    if (Selector->SelectorInfo & BATTERY_D_PRESENT) {
        return (SelectorBits4[SelectorNibble].ReverseLogic);
    } else {
        return (SelectorBits[SelectorNibble].ReverseLogic);
    }
}



NTSTATUS
SmbBattAcquireGlobalLock (
    IN  PDEVICE_OBJECT LowerDeviceObject,
    OUT PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
)
/*++

Routine Description:

    Call ACPI driver to obtain the global lock

    Note: This routine can be called at dispatch level

Arguments:

    LowerDeviceObject - The FDO to pass the request to.

Return Value:

    Return Value from IOCTL.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    KEVENT              event;

    BattPrint (BAT_TRACE, ("SmbBattAcquireGlobalLock: Entering\n"));

    //
    // We wish to acquire the lock
    //
    GlobalLock->Signature = ACPI_ACQUIRE_GLOBAL_LOCK_SIGNATURE;
    GlobalLock->LockObject = NULL;

    //
    // setup the irp
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ACQUIRE_GLOBAL_LOCK;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irp->AssociatedIrp.SystemBuffer = GlobalLock;
    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);

    //
    // Send to ACPI driver
    //
    IoCallDriver (LowerDeviceObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = irp->IoStatus.Status;
    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {
        BattPrint(
            BAT_ERROR,
            ("SmbBattAcquireGlobalLock: Acquire Lock failed, status = %08x\n",
             status )
            );
        DbgBreakPoint ();
    }

    BattPrint (BAT_TRACE, ("SmbBattAcquireGlobalLock: Returning %x\n", status));

    return status;
}



NTSTATUS
SmbBattReleaseGlobalLock (
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER GlobalLock
)
/*++

Routine Description:

    Call ACPI driver to release the global lock

Arguments:

    LowerDeviceObject - The FDO to pass the request to.

Return Value:

    Return Value from IOCTL.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    KEVENT              event;

    BattPrint (BAT_TRACE, ("SmbBattReleaseGlobalLock: Entering\n"));

    //
    // We wish to acquire the lock
    //
    GlobalLock->Signature = ACPI_RELEASE_GLOBAL_LOCK_SIGNATURE;

    //
    // setup the irp
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoAllocateIrp (LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_RELEASE_GLOBAL_LOCK;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER);
    irp->AssociatedIrp.SystemBuffer = GlobalLock;
    IoSetCompletionRoutine (irp, SmbBattSynchronousRequest, &event, TRUE, TRUE, TRUE);

    //
    // Send to ACPI driver
    //
    IoCallDriver (LowerDeviceObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = irp->IoStatus.Status;
    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {
        BattPrint(
            BAT_ERROR,
            ("SmbBattReleaseGlobalLock: Acquire Lock failed, status = %08x\n",
             status )
            );
    }

    BattPrint (BAT_TRACE, ("SmbBattReleaseGlobalLock: Returning %x\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbali\smbalip.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbali.c

Abstract:

    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/
#include <wdm.h>
#include <smbus.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <initguid.h>
#include <wdmguid.h>


//
// Debuging
//
#if DBG
    extern ULONG SmbAliDebug;
    #define SmbPrint(l,m) if(l & SmbAliDebug) DbgPrint m
#else
    #define SmbPrint(l,m)
#endif

#define SMB_IO_RESULT   0x00002000
#define SMB_STATS       0x00001000
#define SMB_ALARM       0x00000800
#define SMB_IO_REQUEST  0x00000400
#define SMB_DATA        0x00000200
#define SMB_IO          0x00000100
#define SMB_TRACE       0x00000010
#define SMB_BUS_ERROR   0x00000002
#define SMB_ERROR       0x00000001

//#define USE_IO_DELAY

#ifdef USE_IO_DELAY
    VOID SmbDelay(VOID);
    #define SMBDELAY SmbDelay ()
#else
    #define SMBDELAY
#endif

// The follow constants are based on 10,000,000 / sec <OR> 100ns time units.
#define MICROSECONDS    (10)
#define MILLISECONDS    (1000*MICROSECONDS)
#define SECONDS         (1000*MILLISECONDS)


#define SMB_ALI_MAJOR_VERSION 1
#define SMB_ALI_MINOR_VERSION 1

extern LARGE_INTEGER SmbIoPollRate;
extern ULONG SmbIoInitTimeOut;
extern ULONG SmbIoCompleteTimeOut;
extern LARGE_INTEGER SmbAlertPollRate;

typedef enum {
    SmbIoIdle,
    SmbIoComplete
} SMB_ALI_IO_STATE;

#define SMB_ALI_IO_RESOURCE_LENGTH 0x40

typedef struct {
    UCHAR   Address;
    UCHAR   Command;
    UCHAR   Protocol;
    BOOLEAN ValidData;
    USHORT   LastData;
} SMB_ALI_POLL_ENTRY, *PSMB_ALI_POL_ENTRY;

typedef struct {

    PUCHAR SmbBaseIo;  // Base IoAddress

    SMB_ALI_IO_STATE IoState;
    ACPI_INTERFACE_STANDARD AcpiInterfaces;
    PIO_WORKITEM    WorkItem;

    PIO_WORKITEM    InitWorker;
    KDPC            InitDpc;
    KTIMER          InitTimer;
    ULONG           InitTimeOut;

    PIO_WORKITEM    CompleteWorker;
    KDPC            CompleteDpc;
    KTIMER          CompleteTimer;
    ULONG           CompleteTimeOut;

    PIO_WORKITEM    PollWorker;
    KEVENT          PollWorkerActive;
    KDPC            PollDpc;
    KTIMER          PollTimer;
    PSMB_ALI_POL_ENTRY  PollList;
    ULONG           PollListCount;

    ULONG           InternalRetries;

} SMB_ALI_DATA, *PSMB_ALI_DATA;

//
// ALI SMBus control registers and bits
//

#define SMB_STS_REG (AliData->SmbBaseIo + 0)
#define SMB_STS_ALERT_STS	0x01	//(1 << 0)
#define SMB_STS_IDLE_STS	0x04	//(1 << 2) // Bus is idle
#define SMB_STS_SMB_IDX_CLR 0x04	//(1 << 2) // Write SMB Index clear.
#define SMB_STS_HOST_BSY	0x08	//(1 << 3) // Bus is busy - do not issue another bus cycle if this is set
#define SMB_STS_SCI_I_STS	0x10	//(1 << 4) // command completed
#define SMB_STS_DRV_ERR		0x20	//(1<<5)
#define SMB_STS_BUS_ERR		0x40	//(1<<6)
#define SMB_STS_FAILED		0x80	//(1<<7)
#define SMB_STS_CLEAR		0xf1
#define SMB_STS_ERRORS		0xe0

#define SMB_STS_LAST_CMD_COMPLETED 0x14
#define SMB_STS_CLEAR_DONE	0x11

#define SMB_TYP_REG (AliData->SmbBaseIo + 1)
#define SMB_TYP_MASK 0x70
#define SMB_TYP_QUICK 0x00
#define SMB_TYP_SEND 0x10
#define SMB_TYP_BYTE 0x20
#define SMB_TYP_WORD 0x30
#define SMB_TYP_BLOCK 0x40
#define SMB_TYP_PROCESS 0x50
#define SMB_TYP_I2C 0x60
#define SMB_TYP_KILL (1<<2)
#define SMB_TYP_T_OUT_CMD (1<<3)


#define STR_PORT_REG (AliData->SmbBaseIo + 2)
#define STR_PORT_START 0xff

#define DEV_ADDR_REG (AliData->SmbBaseIo + 3)
#define DEV_DATA0_REG (AliData->SmbBaseIo + 4)
#define DEV_DATA1_REG (AliData->SmbBaseIo + 5)
#define BLK_DATA_REG (AliData->SmbBaseIo + 6)
#define SMB_CMD_REG (AliData->SmbBaseIo + 7)



NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbAliInitializeMiniport (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SmbAliAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SmbAliResetDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SmbMiniport
    );

VOID
SmbAliStartIo (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    );

VOID
SmbAliInitTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliInitTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );

VOID
SmbAliCompleteTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbAliCompleteTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    );

NTSTATUS
SmbAliStopDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    );

VOID
SmbAliNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    );

VOID
SmbAliWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
SmbAliSyncronousIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
SmbAliTransactionComplete (
    PSMB_ALI_DATA AliData,
    PUCHAR SmbStatus
    );

BOOLEAN
SmbAliHostBusy (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliHandleAlert (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliResetBus (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliResetHost (
    PSMB_ALI_DATA AliData
    );

VOID
SmbAliStartDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    );

VOID
SmbAliStopDevicePolling (
    IN struct _SMB_CLASS* SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbali\smbali.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smbali.c

Abstract:

    SMB Host Controller Driver for ALI chipset

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbalip.h"

#if DBG
    ULONG SmbAliDebug = SMB_ERROR|SMB_ALARM;
    ULONG DbgSuccess = 0;
    
    ULONG DbgFailure = 0;
    ULONG DbgAddrNotAck   = 0;
    ULONG DbgTimeOut      = 0;
    ULONG DbgOtherErr     = 0;
#endif

LARGE_INTEGER SmbIoPollRate = {-20*MILLISECONDS, -1}; // 20 millisecond poll rate. Relative time, so has to be negative
ULONG SmbIoInitTimeOut = 15;                          // 15 IoPollRate intervals before timeout
ULONG SmbIoCompleteTimeOut = 20;                      // 20 IoPollRate intervals before timeout


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the SMBus Host Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS    status;

//    DbgBreakPoint();

    status = SmbClassInitializeDevice (
        SMB_ALI_MAJOR_VERSION,
        SMB_ALI_MINOR_VERSION,
        DriverObject
        );
    DriverObject->DriverExtension->AddDevice = SmbAliAddDevice;

    return status;
}

NTSTATUS
SmbAliInitializeMiniport (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    )
/*++

Routine Description:

    This routine Initializes miniport data, and sets up communication with
    lower device objects.

Arguments:

    DriverObject - Pointer to driver object created by system.
    Pdo - Pointer to physical device object

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) MiniportExtension;
    NTSTATUS                status = STATUS_SUCCESS;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    KEVENT                  syncEvent;


    AliData->IoState = SmbIoIdle;

    //
    // Fill in SmbClass info
    //

    SmbClass->StartIo     = SmbAliStartIo;
    SmbClass->ResetDevice = SmbAliResetDevice;
    SmbClass->StopDevice  = SmbAliStopDevice;

    //
    // Get Acpi Interfaces
    //

    //
    // Allocate an IRP for below
    //
    irp = IoAllocateIrp (SmbClass->LowerDeviceObject->StackSize, FALSE);

    if (!irp) {
        SmbPrint((SMB_ERROR),
            ("SmbAliInitializeMiniport: Failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
    //
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    irpSp->Parameters.QueryInterface.Version                = 1;
    irpSp->Parameters.QueryInterface.Size                   = sizeof (AliData->AcpiInterfaces);
    irpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &AliData->AcpiInterfaces;
    irpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

    //
    // Initialize an event so this will be a syncronous call.
    //

    KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine (irp, SmbAliSyncronousIrpCompletion, &syncEvent, TRUE, TRUE, TRUE);

    //
    // Call ACPI
    //

    status = IoCallDriver (SmbClass->LowerDeviceObject, irp);

    //
    // Wait if necessary, then clean up.
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
        status = irp->IoStatus.Status;
    }

    IoFreeIrp (irp);

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_ERROR,
           ("SmbAliInitializeMiniport: Could not get ACPI driver interfaces, status = %x\n", status));
    }

    //
    // Initiaize worker thread
    //
    AliData->WorkItem = IoAllocateWorkItem (SmbClass->LowerDeviceObject);

    return status;
}

NTSTATUS
SmbAliAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    This routine calls SMBClassCreateFdo to create the FDO

Arguments:

    DriverObject - Pointer to driver object created by system.
    Pdo - Pointer to physical device object

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo = NULL;


    PAGED_CODE();

    SmbPrint(SMB_TRACE, ("SmbAliAddDevice Entered with pdo %x\n", Pdo));


    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        SmbPrint(SMB_ERROR, ("SmbHcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = SmbClassCreateFdo(
                DriverObject,
                Pdo,
                sizeof (SMB_ALI_DATA),
                SmbAliInitializeMiniport,
                NULL,
                &fdo
                );

    if (!NT_SUCCESS(status) || fdo == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliAddDevice - error creating Fdo. Status = %08x\n", status));
    }

    return status;


}

NTSTATUS
SmbAliResetDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SmbMiniport
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
    ULONG                           i;
    PIO_STACK_LOCATION              irpStack;

    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) SmbMiniport;

    PAGED_CODE();


    if (SmbClass->CurrentIrp == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Null CurrentIrp.  Can't get Alloocated Resources.\n"));

        return STATUS_NO_MORE_ENTRIES;
    }
    irpStack = IoGetCurrentIrpStackLocation(SmbClass->CurrentIrp);

    if (irpStack->Parameters.StartDevice.AllocatedResources == NULL) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Null resource pointer\n"));

        return STATUS_NO_MORE_ENTRIES;
    }

    if (irpStack->Parameters.StartDevice.AllocatedResources->Count <= 0 ) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Count <= 0\n"));

        return status;
    }

    //
    // Traverse the resource list
    //

    AliData->SmbBaseIo = NULL;

    fullResourceDesc=&irpStack->Parameters.StartDevice.AllocatedResources->List[0];
    partialResourceList = &fullResourceDesc->PartialResourceList;
    partialResourceDesc = partialResourceList->PartialDescriptors;

    for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

        if (partialResourceDesc->Type == CmResourceTypePort) {

            if (AliData->SmbBaseIo == NULL) {
                AliData->SmbBaseIo = (PUCHAR)((ULONG_PTR)partialResourceDesc->u.Port.Start.LowPart);
                if (partialResourceDesc->u.Port.Length != SMB_ALI_IO_RESOURCE_LENGTH) {
                    SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Wrong Resource length = 0x%08x\n", partialResourceDesc->u.Port.Length));
                    DbgBreakPoint();
                }
                status = STATUS_SUCCESS;
            } else {
                SmbPrint(SMB_ERROR, ("SmbAliResetDevice: More than 1 IO resource.  Resources = 0x%08x\n", irpStack->Parameters.StartDevice.AllocatedResources));
                DbgBreakPoint();
            }
        }
    }

    if (!NT_SUCCESS (status)) {
        SmbPrint(SMB_ERROR, ("SmbAliResetDevice: IO resource error.  Resources = 0x%08x\n", irpStack->Parameters.StartDevice.AllocatedResources));
        DbgBreakPoint();
    }

    SmbPrint(SMB_TRACE, ("SmbAliResetDevice: IO Address = 0x%08x\n", AliData->SmbBaseIo));

    //
    // Register for device notification
    //
    // But this device can't seem to notify so never mind for now
    //status = AliData->AcpiInterfaces.RegisterForDeviceNotifications (
    //            AliData->AcpiInterfaces.Context,
    //            SmbAliNotifyHandler,
    //            AliData);
    //
    //if (!NT_SUCCESS(status)) {
    //    SmbPrint(SMB_ERROR, ("SmbAliResetDevice: Failed RegisterForDeviceNotification. 0x%08x\n", status));
    //}

    KeInitializeTimer (&AliData->InitTimer);
    KeInitializeDpc (&AliData->InitDpc,
                     SmbAliInitTransactionDpc,
                     SmbClass);
    AliData->InitWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    KeInitializeTimer (&AliData->CompleteTimer);
    KeInitializeDpc (&AliData->CompleteDpc,
                     SmbAliCompleteTransactionDpc,
                     SmbClass);
    AliData->CompleteWorker = IoAllocateWorkItem (SmbClass->DeviceObject);

    SmbAliStartDevicePolling (SmbClass);

    return status;

}

NTSTATUS
SmbAliStopDevice (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    )
{
    SmbAliStopDevicePolling (SmbClass);

    AliData->SmbBaseIo = NULL;
    return STATUS_SUCCESS;
}


VOID
SmbAliStartIo (
    IN struct _SMB_CLASS* SmbClass,
    IN PSMB_ALI_DATA AliData
    )

{
    SmbPrint (SMB_TRACE, ("SmbAliStartIo: \n"));

    SmbPrint (SMB_IO_REQUEST, ("  Prtcl = %02x Addr = %02x Cmd = %02x BlkLen = %02x Data[0] = %02x\n",
                               SmbClass->CurrentSmb->Protocol,
                               SmbClass->CurrentSmb->Address,
                               SmbClass->CurrentSmb->Command,
                               SmbClass->CurrentSmb->BlockLength,
                               SmbClass->CurrentSmb->Data[0]));
//    KeSetTimer (&AliData->InitTimer,
//                Smb100ns,
//                &AliData->InitDpc);

    AliData->InternalRetries = 0;
    
    AliData->InitTimeOut = SmbIoInitTimeOut;
    IoQueueWorkItem (AliData->InitWorker, 
                     SmbAliInitTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);

}

VOID
SmbAliInitTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    IoQueueWorkItem (AliData->InitWorker, 
                     SmbAliInitTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);
}

VOID
SmbAliInitTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    UCHAR address;
    UCHAR protocol;

    SmbPrint (SMB_TRACE, ("SmbAliInitTransaction: Entered \n"));

    if (SmbClass->CurrentSmb->Protocol >= SMB_MAXIMUM_PROTOCOL) {
        SmbClass->CurrentSmb->Status = SMB_UNSUPPORTED_PROTOCOL;
        // REVIEW: Shouldn't this complete the request?  jimmat
        return;
    }

    if (SmbAliHostBusy(AliData)) {
        if (AliData->InitTimeOut == 4) {
            // Time out.  Issue kill command.  If that fixes it, good, otherwise 
            // issue bus timeout command next time.
            SmbAliResetHost (AliData);
        }
        if (AliData->InitTimeOut == 0) {
            // Time out.  Issue Bus timeout and kill command to reset host.
            SmbAliResetBus (AliData);
            
            AliData->InitTimeOut = SmbIoInitTimeOut;
        } else {
            SmbPrint (SMB_TRACE, ("SmbAliInitTransaction: Waiting (%d) \n", AliData->InitTimeOut));
            AliData->InitTimeOut--;
        }
        KeSetTimer (&AliData->InitTimer,
                    SmbIoPollRate,
                    &AliData->InitDpc);
        return;
    }

    //
    // Ready to go
    //

    // Set Address and read/write bit
    address = SmbClass->CurrentSmb->Address << 1 | (SmbClass->CurrentSmb->Protocol & 1);
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_ADDR = 0x%02x \n", address));
    WRITE_PORT_UCHAR (DEV_ADDR_REG, address);

    SMBDELAY;
    
    // Set transaction type: Inserts bits 3-1 of protocol into bits 6-4 of SMB_TYP
    // protocol = READ_PORT_UCHAR (SMB_TYP_REG);
    // SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO read SMB_TYP = 0x%02x \n", protocol));
    protocol = /*(protocol & ~SMB_TYP_MASK) |*/
               ((SmbClass->CurrentSmb->Protocol << 3) & SMB_TYP_MASK);
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write SMB_TYP = 0x%02x, Protocol = 0x%02x \n", protocol,SmbClass->CurrentSmb->Protocol));
    WRITE_PORT_UCHAR (SMB_TYP_REG, protocol);
    SMBDELAY;

    // Set SMBus Device Command value
    if (SmbClass->CurrentSmb->Protocol >= SMB_WRITE_BYTE) {
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write SMB_CMD = 0x%02x \n", SmbClass->CurrentSmb->Command));
        WRITE_PORT_UCHAR (SMB_CMD_REG, SmbClass->CurrentSmb->Command);
        SMBDELAY;
    }

    switch (SmbClass->CurrentSmb->Protocol) {
    case SMB_WRITE_WORD:
    case SMB_PROCESS_CALL:

        // Set Data
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_DATA1 = 0x%02x \n", SmbClass->CurrentSmb->Data[1]));
        WRITE_PORT_UCHAR (DEV_DATA1_REG, SmbClass->CurrentSmb->Data[1]);
        SMBDELAY;

        // Fall through to set low byte of word
    case SMB_SEND_BYTE:
    case SMB_WRITE_BYTE:

        // Set Data
        SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write DEV_DATA0 = 0x%02x \n", SmbClass->CurrentSmb->Data[0]));
        WRITE_PORT_UCHAR (DEV_DATA0_REG, SmbClass->CurrentSmb->Data[0]);
        SMBDELAY;

        break;
    case SMB_WRITE_BLOCK:
        // BUGBUG: not yet implemented.
        SmbPrint (SMB_ERROR, ("SmbAliInitTransaction: Write Block not implemented.  press 'g' to write random data.\n"));
        DbgBreakPoint();
        break;
    }

    // Initiate Transaction
    SmbPrint (SMB_IO, ("SmbAliInitTransaction: IO write STR_PORT = 0x%02x \n", STR_PORT_START));
    WRITE_PORT_UCHAR (STR_PORT_REG, STR_PORT_START);

    AliData->CompleteTimeOut = SmbIoCompleteTimeOut;

    KeSetTimer (&AliData->CompleteTimer,
                SmbIoPollRate,
                &AliData->CompleteDpc);


}

VOID
SmbAliCompleteTransactionDpc (
    IN struct _KDPC *Dpc,
    IN struct _SMB_CLASS* SmbClass,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);

    IoQueueWorkItem (AliData->CompleteWorker, 
                     SmbAliCompleteTransactionWorker, 
                     DelayedWorkQueue, 
                     SmbClass);
}

VOID
SmbAliCompleteTransactionWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _SMB_CLASS* SmbClass
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA)(SmbClass->Miniport);
    UCHAR           i, smb_sts;
    UCHAR           smbStatus;

    SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Entered \n"));

    smbStatus = SMB_STATUS_OK;

    if (!SmbAliTransactionComplete(AliData, &smbStatus)) {
        //
        // Timeout
        //

        if (AliData->CompleteTimeOut == 0) {
            SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Transation timed out.  Resetting host. \n"));
            SmbAliResetHost (AliData);

            smbStatus = SMB_TIMEOUT;

        } else {
            SmbPrint (SMB_TRACE, ("SmbAliCompleteTransactionWorker: Not complete.  Waiting (%d)... \n", AliData->CompleteTimeOut));
            AliData->CompleteTimeOut--;
            KeSetTimer (&AliData->CompleteTimer,
                        SmbIoPollRate,
                        &AliData->CompleteDpc);
            return;
        }

    }

    if (smbStatus == SMB_STATUS_OK) {
        //
        // If transaction was successful, read data.
        //

        switch (SmbClass->CurrentSmb->Protocol) {
        case SMB_READ_WORD:
        case SMB_PROCESS_CALL:

            // Read High byte
            SmbClass->CurrentSmb->Data[1] = READ_PORT_UCHAR (DEV_DATA1_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA1 = 0x%02x \n", SmbClass->CurrentSmb->Data[1]));

            // Fall through to set low byte of word
        case SMB_RECEIVE_BYTE:
        case SMB_READ_BYTE:

            // Read Low Byte
            SmbClass->CurrentSmb->Data[0] = READ_PORT_UCHAR (DEV_DATA0_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA0 = 0x%02x \n", SmbClass->CurrentSmb->Data[0]));
            break;
        case SMB_READ_BLOCK:
            // Read Block Count
            SmbClass->CurrentSmb->BlockLength = READ_PORT_UCHAR (DEV_DATA0_REG);
            SMBDELAY;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read DEV_DATA0 (block length)= 0x%02x \n", SmbClass->CurrentSmb->BlockLength));
            if (SmbClass->CurrentSmb->BlockLength >= 32) {
                DbgBreakPoint();
                SmbClass->CurrentSmb->BlockLength = 0;
            }

            // Reset Data pointer
    //        smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
  //          SMBDELAY;
//            SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: IO read SMB_STS = 0x%02x \n", smb_sts));
            smb_sts = SMB_STS_SMB_IDX_CLR;
            SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO write SMB_STS = 0x%02x \n", smb_sts));
            WRITE_PORT_UCHAR (SMB_STS_REG, smb_sts);
            SMBDELAY;

            // Read data
            for (i = 0; i < SmbClass->CurrentSmb->BlockLength; i++) {
                SmbClass->CurrentSmb->Data[i] = READ_PORT_UCHAR (BLK_DATA_REG);
                SMBDELAY;
                SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: IO read BLK_DATA_REG (i = %d) = 0x%02x \n", i, SmbClass->CurrentSmb->Data[i]));
            }
            break;
        }
    }
    else    // smbStatus != SMB_STATUS_OK
    {
        //
        // Retry the transaction up to 5 times before returning to the caller.
        // REVIEW: Only do this for certain devices, commands, or error status results?
        //
        
        if (AliData->InternalRetries < 5)
        {
            //SmbPrint (SMB_IO_RESULT, (" SMBus Transaction status: %02x, retrying...\n", smbStatus));
            AliData->InternalRetries += 1;

            // Send the work item back to the init worker
            AliData->InitTimeOut = SmbIoInitTimeOut;
            KeSetTimer (&AliData->InitTimer,
                        SmbIoPollRate,
                        &AliData->InitDpc);
            return;
        }
    }
    
    // Clear any previous status.
    //SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    //WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
//    SMBDELAY;

    SmbClass->CurrentSmb->Status = smbStatus;
    SmbPrint (SMB_IO, ("SmbAliCompleteTransactionWorker: SMB Status = 0x%x\n", smbStatus));
    SmbClass->CurrentIrp->IoStatus.Status = STATUS_SUCCESS;
    SmbClass->CurrentIrp->IoStatus.Information = sizeof(SMB_REQUEST);

    SmbPrint (SMB_IO_RESULT, (" Prtcl = %02x Addr = %02x Cmd = %02x BL = %02x Data[0,1] = %02x %02x Sts = %02x Rty = %02x\n",
                              SmbClass->CurrentSmb->Protocol,
                              SmbClass->CurrentSmb->Address,
                              SmbClass->CurrentSmb->Command,
                              SmbClass->CurrentSmb->BlockLength,
                              SmbClass->CurrentSmb->Data[0],
                              (SMB_READ_WORD == SmbClass->CurrentSmb->Protocol ||
                               SMB_WRITE_WORD == SmbClass->CurrentSmb->Protocol ||
                               (SMB_READ_BLOCK == SmbClass->CurrentSmb->Protocol &&
                                SmbClass->CurrentSmb->BlockLength >= 2)) ? 
                               SmbClass->CurrentSmb->Data[1] : 0xFF,
                              SmbClass->CurrentSmb->Status,
                              AliData->InternalRetries));
                              
    SmbClassLockDevice (SmbClass);
    SmbClassCompleteRequest (SmbClass);
    SmbClassUnlockDevice (SmbClass);

#if DBG
    //
    // Track the # of successful transactions, and if not successful,
    // the types of errors encountered.
    //
    if (SMB_STATUS_OK == smbStatus)
        DbgSuccess += 1;
    else
    {
        DbgFailure += 1;
        if (SMB_TIMEOUT == smbStatus)
            DbgTimeOut += 1;
        else if (SMB_ADDRESS_NOT_ACKNOWLEDGED == smbStatus)
            DbgAddrNotAck += 1;
        else
            DbgOtherErr += 1;
    }

    if ((DbgSuccess + DbgFailure) % 100 == 0)
        SmbPrint(SMB_STATS, ("SmbAliCompleteTransactionWorker: Stats:\n"
                             "    Success: %d, Failure: %d, %%: %d\n"
                             "    TimeOut: %d, AddrNotAck: %d, Other: %d\n",
                             DbgSuccess, DbgFailure, DbgSuccess * 100 / (DbgSuccess + DbgFailure),
                             DbgTimeOut, DbgAddrNotAck, DbgOtherErr));
#endif
}

VOID
SmbAliNotifyHandler (
    IN PVOID                Context,
    IN ULONG                NotifyValue
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) Context;
    ULONG           address;
    ULONG           data;
    UCHAR           smb_sts;

    SmbPrint (SMB_TRACE, ("SmbAliNotifyHandler: Entered"));

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_TRACE, ("SmbAliNotifyHandler: SMB_STS = %02x", smb_sts));

    if (smb_sts & (SMB_STS_ALERT_STS || SMB_STS_SCI_I_STS)) {
        //
        // Alert Reponse
        //

    } else if (smb_sts & SMB_STS_SCI_I_STS) {
        //
        // Last Transaction completed
        //

    } else {
        //
        // Check for errors, etc.
        //
    }

    IoQueueWorkItem (AliData->WorkItem,
                     SmbAliWorkerThread,
                     DelayedWorkQueue,
                     AliData);

}

VOID
SmbAliWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PSMB_ALI_DATA   AliData = (PSMB_ALI_DATA) Context;

    SmbPrint (SMB_TRACE, ("SmbAliIrpCompletionWorker: Entered"));
    //
    // Complete Irps here
    //
}


NTSTATUS
SmbAliSyncronousIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the lower driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


BOOLEAN
SmbAliTransactionComplete (
    PSMB_ALI_DATA AliData,
    PUCHAR SmbStatus
    )
/*++

Routine Description:

    This routine checks to see if there is the last transation was completed.

Arguments:

    AliData - minidriver device extension.

    SmbStatus - Status being returned.

Return Value:

    True if transaction completed or had an error.
    False if it is still waiting.

--*/

{
    UCHAR           smb_sts;

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_IO, ("SmbAliTransactionComplete: IO read SMB_STS = 0x%02x \n", smb_sts));
    if (smb_sts & SMB_STS_HOST_BSY) {
		SmbPrint (SMB_IO, ("SmbAliTransactionComplete: Transaction Not Complete:  HOST BUSY\n"));
        return FALSE;
    }
    if (!(smb_sts & SMB_STS_IDLE_STS)) {
	    SmbPrint (SMB_IO, ("SmbAliTransactionComplete: Transaction Not Complete: Idle Not Indicated\n"));
        return FALSE;
    }

    if (smb_sts & SMB_STS_SCI_I_STS) {
        //
        // Transaction is complete
        //
        *SmbStatus = SMB_STATUS_OK;
        return TRUE;
    }
    if (smb_sts & SMB_STS_FAILED) {
        *SmbStatus = SMB_UNKNOWN_FAILURE;
    } else if (smb_sts & SMB_STS_BUS_ERR) {
        *SmbStatus = SMB_ADDRESS_NOT_ACKNOWLEDGED;
    } else if (smb_sts & SMB_STS_DRV_ERR) {
        *SmbStatus = SMB_TIMEOUT;
    } else {
        //
        // This state really shouldn't be reached.
        // Reset the SMBus host
        //
        SmbPrint (SMB_BUS_ERROR, ("SmbAliTransactionComplete: Invalid SMBus host state.\n"));

        *SmbStatus = SMB_UNKNOWN_ERROR;
    }
    //
    // For the three know error tpes we want to reset the bus
    //
    SmbPrint (SMB_BUS_ERROR, ("SmbAliTransactionComplete: SMBus error: 0x%x \n", *SmbStatus));

	// Don't reset the bus etc. if this is a Bus Collision error
    if ( *SmbStatus == SMB_ADDRESS_NOT_ACKNOWLEDGED )
	{
		// Should we clear the bits, lets try it
		SmbPrint (SMB_IO, ("SmbAliCompleteTransaction: Clearing Error Bits. IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
		WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
        SMBDELAY;
	}
	else
	{
		SmbAliResetHost (AliData);
		SmbAliResetBus (AliData);
	}

    return TRUE;
}

BOOLEAN
SmbAliHostBusy (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This routine checks to see if the Host controller is free to start a
    new transaction.

Arguments:

    AliData - minidriver device extension.

Return Value:

    True if The host is busy.
    False if it free for use.

--*/

{

    UCHAR           smb_sts;

    SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Entered \n"));

    smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
    SMBDELAY;
    SmbPrint (SMB_IO, ("SmbAliHostBusy: IO read SMB_STS = 0x%02x \n", smb_sts));

    if (smb_sts & SMB_STS_ALERT_STS) {
        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Alert Detected \n"));
        DbgBreakPoint();
        SmbAliHandleAlert (AliData);

        //
        // Say device is still busy for now. BUGBUG
        return TRUE;
    }

	if ( smb_sts == SMB_STS_LAST_CMD_COMPLETED )
	{
		//
		// Clear the done bit
        SmbPrint (SMB_IO, ("SmbAliHostBusy: IO write SMB_TYP = 0x%02x \n", SMB_STS_CLEAR_DONE));
        WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR_DONE);
        SMBDELAY;
		return FALSE;
	}

    if ( smb_sts == SMB_STS_IDLE_STS ) 
	{
        //
        // No bits are set, Host is not busy
        //
        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Not busy \n"));
        return FALSE;
    }

    if ( smb_sts & SMB_STS_ERRORS ) {
        //
        // Clear it.
        // Wait a cycle before continuing.
        //
        SmbPrint (SMB_IO, ("SmbAliHostBusy: IO write SMB_TYP = 0x%02x \n", SMB_STS_CLEAR));
        WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
        SMBDELAY;
        return TRUE;
    }

    if ((smb_sts & SMB_STS_HOST_BSY) || !(smb_sts & SMB_STS_IDLE_STS)) {
        //
        // Host is busy
        //

        SmbPrint (SMB_TRACE, ("SmbAliHostBusy: Host Busy \n"));
        return TRUE;
    }

    SmbPrint (SMB_ERROR, ("SmbAliHostBusy: Exiting (Why?) \n"));
    return TRUE;
}

VOID
SmbAliHandleAlert (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This routine reads the alert data and sends notification to SMB class.

Arguments:

    AliData - minidriver device extension.

Return Value:

    None

--*/

{

    //BUGBUG not yet implemented

    return;
}

VOID
SmbAliResetBus (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This resets the bus by sending the timeout command.

Arguments:

    AliData - minidriver device extension.

Return Value:

--*/
{
    UCHAR           smb_sts;
    
    smb_sts = SMB_TYP_T_OUT_CMD;
    SmbPrint (SMB_IO, ("SmbAliResetBus: IO write SMB_TYP = 0x%02x \n", smb_sts));
    WRITE_PORT_UCHAR (SMB_TYP_REG, smb_sts);
    SMBDELAY;

    SmbPrint (SMB_IO, ("SmbAliResetBus: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);  
    SMBDELAY;
}

VOID
SmbAliResetHost (
    PSMB_ALI_DATA AliData
    )
/*++

Routine Description:

    This resets the host by sending the kill command.

Arguments:

    AliData - minidriver device extension.

Return Value:

--*/
{
    UCHAR           smb_sts;
    UCHAR           timeout = 5;
    
    smb_sts = SMB_TYP_KILL;
    SmbPrint (SMB_IO, ("SmbAliResetHost: IO write SMB_TYP = 0x%02x \n", smb_sts));
    WRITE_PORT_UCHAR (SMB_TYP_REG, smb_sts);
    SMBDELAY;

	SmbPrint (SMB_IO, ("SmbAliResetHost: IO write SMB_STS = 0x%02x \n", SMB_STS_CLEAR));
    WRITE_PORT_UCHAR (SMB_STS_REG, SMB_STS_CLEAR);
    SMBDELAY;

    do {
        KeDelayExecutionThread (KernelMode, FALSE, &SmbIoPollRate);
        smb_sts = READ_PORT_UCHAR (SMB_STS_REG);
        SmbPrint (SMB_IO, ("SmbAliResetHost: IO read SMB_STS = 0x%02x \n", smb_sts));

        if (! (timeout--)) {
            break;
        }
    } while (smb_sts & SMB_STS_FAILED);
}

#ifdef USE_IO_DELAY

LARGE_INTEGER DbgDelay = {-1,-1};
VOID SmbDelay(VOID)
{
    KeDelayExecutionThread (KernelMode, FALSE, &DbgDelay);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbbatt\smbbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbbatt.c

Abstract:

    SMBus Smart Battery Subsystem Miniport Driver
    (Selector, Battery, Charger)

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

    Chris Windle    1/27/98     Bug Fixes

--*/

#include "smbbattp.h"

#include <initguid.h>
#include <batclass.h>



#if DEBUG
ULONG   SMBBattDebug = BAT_WARN | BAT_ERROR | BAT_BIOS_ERROR;
#endif

// Global
BOOLEAN   SmbBattUseGlobalLock = TRUE;
UNICODE_STRING GlobalRegistryPath;

//
// Prototypes
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
SmbBattNewDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
);

NTSTATUS
SmbBattQueryTag (
    IN PVOID Context,
    OUT PULONG BatteryTag
);

NTSTATUS
SmbBattQueryInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
);

NTSTATUS
SmbBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
);

NTSTATUS
SmbBattDisableStatusNotify (
    IN PVOID Context
);

NTSTATUS
SmbBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
);

NTSTATUS
SmbBattCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
SmbBattClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
SmbBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
SmbBattUnload(
    IN PDRIVER_OBJECT DriverObject
);

VOID
SmbBattProcessSelectorAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OldSelectorState,
    IN ULONG                NewSelectorState
);

NTSTATUS
SmbBattGetPowerState (
    IN PSMB_BATT        SmbBatt,
    OUT PULONG          PowerState,
    OUT PLONG           Current
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,SmbBattNewDevice)
#pragma alloc_text(PAGE,SmbBattUnload)
#pragma alloc_text(PAGE,SmbBattCreate)
#pragma alloc_text(PAGE,SmbBattClose)
#pragma alloc_text(PAGE,SmbBattIoctl)
#pragma alloc_text(PAGE,SmbBattQueryTag)
#pragma alloc_text(PAGE,SmbBattQueryInformation)
#pragma alloc_text(PAGE,SmbBattSetInformation)
#pragma alloc_text(PAGE,SmbBattGetPowerState)
#pragma alloc_text(PAGE,SmbBattQueryStatus)
#pragma alloc_text(PAGE,SmbBattSetStatusNotify)
#pragma alloc_text(PAGE,SmbBattDisableStatusNotify)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the Smart Battery Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    OBJECT_ATTRIBUTES   objAttributes;

    BattPrint(BAT_TRACE, ("SmbBatt: DriverEntry\n"));

    //
    // Save the RegistryPath.
    //

    GlobalRegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    GlobalRegistryPath.Length = RegistryPath->Length;
    GlobalRegistryPath.Buffer = ExAllocatePoolWithTag (
                                       PagedPool,
                                       GlobalRegistryPath.MaximumLength,
                                       'StaB');

    if (!GlobalRegistryPath.Buffer) {

        BattPrint ((BAT_ERROR),("SmbBatt: Couldn't allocate pool for registry path."));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&GlobalRegistryPath, RegistryPath);

    BattPrint (BAT_TRACE, ("SmbBatt DriverEntry - Obj (%08x) Path \"%ws\"\n",
                                 DriverObject, RegistryPath->Buffer));
    
    
    DriverObject->DriverUnload                          = SmbBattUnload;
    DriverObject->DriverExtension->AddDevice            = SmbBattNewDevice;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SmbBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = SmbBattCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SmbBattClose;

    DriverObject->MajorFunction[IRP_MJ_PNP]             = SmbBattPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = SmbBattPowerDispatch;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = SmbBattSystemControl;
    return STATUS_SUCCESS;
}



NTSTATUS
SmbBattNewDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PDO
    )

/*++

Routine Description:

    This creates a smb smart battery functional device objects.  The first
    object created will be the one for the "smart battery subsystem" which will
    have a PDO from ACPI.  This will receive a START Irp, then a
    QUERY_DEVICE_RELATIONS Irp.  In the QUERY it will create PDOs for the
    batteries that are supported by the system and eventually they will end
    up here for FDOs to be created and attached to them.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PDO          - PDO for the new device(s)

Return Value:

    Status

--*/
{
    PDEVICE_OBJECT          fdo;
    PSMB_BATT_SUBSYSTEM     subsystemExt;
    PSMB_BATT_PDO           pdoExt;

    PSMB_NP_BATT            SmbNPBatt;
    PSMB_BATT               SmbBatt;
    BATTERY_MINIPORT_INFO   BattInit;

    NTSTATUS                status              = STATUS_UNSUCCESSFUL;
    BOOLEAN                 selectorPresent     = FALSE;

    PAGED_CODE();

    BattPrint(BAT_IRPS, ("SmbBattNewDevice: AddDevice for device %x\n", PDO));

    //
    // Check to see if we are being asked to enumerate ourself
    //

    if (PDO == NULL) {
        BattPrint(BAT_ERROR, ("SmbBattNewDevice: Being asked to enumerate\n"));
        return STATUS_NOT_IMPLEMENTED;
    }


    //
    // Check to see if the PDO is the battery subsystem PDO or a battery PDO.  This will be
    // determined by the PDO's DeviceType.
    //
    // FILE_DEVICE_ACPI     This PDO is from ACPI and belongs to battery subsystem
    // FILE_DEVICE_BATTERY  This PDO is a battery PDO
    //

    if (PDO->DeviceType == FILE_DEVICE_ACPI) {

        //
        // Create the device object
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof (SMB_BATT_SUBSYSTEM),
                    NULL,
                    FILE_DEVICE_BATTERY,
                    FILE_DEVICE_SECURE_OPEN,
                    FALSE,
                    &fdo
                );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error creating Fdo for battery subsystem %x\n", status));
            return(status);
        }


        //
        // Initialize the Fdo
        //

        fdo->Flags |= DO_BUFFERED_IO;
        fdo->Flags |= DO_POWER_PAGABLE;

        //
        // Initialize the extension
        //

        subsystemExt = (PSMB_BATT_SUBSYSTEM)fdo->DeviceExtension;
        RtlZeroMemory (subsystemExt, sizeof (PSMB_BATT_SUBSYSTEM));

        subsystemExt->DeviceObject = fdo;
        subsystemExt->SmbBattFdoType = SmbTypeSubsystem;
        IoInitializeRemoveLock (&subsystemExt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        //
        // These fields are implicitly initialize by zeroing the extension
        //
        //         subsystemExt->NumberOfBatteries = 0;
        //         subsystemExt->SelectorPresent   = FALSE;
        //         subsystemExt->Selector          = NULL;
        //         subsystemExt->WorkerActive      = 0;


        KeInitializeSpinLock (&subsystemExt->AlarmListLock);
        InitializeListHead (&subsystemExt->AlarmList);
        subsystemExt->WorkerThread = IoAllocateWorkItem (fdo);


        //
        // Layer our FDO on top of the ACPI PDO.
        //

        subsystemExt->LowerDevice = IoAttachDeviceToDeviceStack (fdo,PDO);
        
        if (!subsystemExt->LowerDevice) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: Error attaching subsystem to device stack.\n"));

            IoDeleteDevice (fdo);

            return(status);

        }


        //
        // Zero out the battery PDO list
        //  This is already zeroed by the RtlZeroMemory above.
        //
        //  RtlZeroMemory(
        //      &subsystemExt->BatteryPdoList[0],
        //      sizeof(PDEVICE_OBJECT) * MAX_SMART_BATTERIES_SUPPORTED
        //  );


        //
        // Device is ready for use
        //
        
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;


    } else {

        //
        // This is a battery PDO.  Create the FDO to layer on top of it.
        //

        pdoExt       = (PSMB_BATT_PDO) PDO->DeviceExtension;
        subsystemExt = (PSMB_BATT_SUBSYSTEM) pdoExt->SubsystemFdo->DeviceExtension;

        //
        // Allocate space for the paged portion of the device extension
        //

        SmbBatt = ExAllocatePoolWithTag (PagedPool, sizeof(SMB_BATT), SMB_BATTERY_TAG);
        if (!SmbBatt) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: Can't allocate Smart Battery data\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (SmbBatt, sizeof(SMB_BATT));


        //
        // Create the device object
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof (SMB_NP_BATT),
                    NULL,
                    FILE_DEVICE_BATTERY,
                    FILE_DEVICE_SECURE_OPEN,
                    FALSE,
                    &fdo
                 );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error creating Fdo: %x\n", status));

            ExFreePool (SmbBatt);
            return(status);
        }


        //
        // Initialize the Fdo
        //

        fdo->Flags |= DO_BUFFERED_IO;
        fdo->Flags |= DO_POWER_PAGABLE;
        
        
        //
        // Layer our FDO on top of the PDO.
        //

        SmbNPBatt = (PSMB_NP_BATT) fdo->DeviceExtension;
        SmbNPBatt->LowerDevice = IoAttachDeviceToDeviceStack (fdo,PDO);

        if (!SmbNPBatt->LowerDevice) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error attaching to device stack\n"));

            ExFreePool (SmbBatt);

            IoDeleteDevice (fdo);

            return(status);
        }


        //
        // Fill in privates
        //

        SmbNPBatt->Batt             = SmbBatt;
        SmbNPBatt->SmbBattFdoType   = SmbTypeBattery;
        IoInitializeRemoveLock (&SmbNPBatt->RemoveLock,
                                SMB_BATTERY_TAG,
                                REMOVE_LOCK_MAX_LOCKED_MINUTES,
                                REMOVE_LOCK_HIGH_WATER_MARK);

        ExInitializeFastMutex (&SmbNPBatt->Mutex);

        SmbBatt->NP                 = SmbNPBatt;
        SmbBatt->PDO                = PDO;
        SmbBatt->DeviceObject       = fdo;
        SmbBatt->SelectorPresent    = subsystemExt->SelectorPresent;
        SmbBatt->Selector           = subsystemExt->Selector;

        pdoExt->Fdo                 = fdo;

        //
        // Precalculate this batteries SMB_x bit position in the selector status register.
        //
        // Just move it into the lower nibble and any function that needs
        // the bit can shift it left 4 = charger, 8 = power, 12 = smb
        //

        SmbBatt->SelectorBitPosition = 1;
        if (pdoExt->BatteryNumber > 0) {
            SmbBatt->SelectorBitPosition <<= pdoExt->BatteryNumber;
        }


        //
        // Have class driver allocate a new SMB miniport device
        //

        RtlZeroMemory (&BattInit, sizeof(BattInit));
        BattInit.MajorVersion        = SMB_BATTERY_MAJOR_VERSION;
        BattInit.MinorVersion        = SMB_BATTERY_MINOR_VERSION;
        BattInit.Context             = SmbBatt;
        BattInit.QueryTag            = SmbBattQueryTag;
        BattInit.QueryInformation    = SmbBattQueryInformation;
        BattInit.SetInformation      = SmbBattSetInformation;
        BattInit.QueryStatus         = SmbBattQueryStatus;
        BattInit.SetStatusNotify     = SmbBattSetStatusNotify;
        BattInit.DisableStatusNotify = SmbBattDisableStatusNotify;

        BattInit.Pdo                 = PDO;
        BattInit.DeviceName          = NULL;

        status = BatteryClassInitializeDevice (
                    &BattInit,
                    &SmbNPBatt->Class
                 );

        if (status != STATUS_SUCCESS) {
            BattPrint(BAT_ERROR, ("SmbBattNewDevice: error initializing battery: %x\n", status));

            ExFreePool (SmbBatt);

            IoDetachDevice (SmbNPBatt->LowerDevice);
            IoDeleteDevice (fdo);

            return(status);
        }
        
        //
        // Register WMI support.
        //
        status = SmbBattWmiRegistration(SmbNPBatt);

        if (!NT_SUCCESS(status)) {
            //
            // WMI support is not critical to operation.  Just log an error.
            //

            BattPrint(BAT_ERROR,
                ("SmbBattNewDevice: Could not register as a WMI provider, status = %Lx\n", status));
        }


        //
        // Device is ready for use
        //
        
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;



    }   // else (we have a battery PDO)


    return status;
}



VOID
SmbBattUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Cleanup all devices and unload the driver

Arguments:

    DriverObject - Driver object for unload

Return Value:

    Status

--*/
{

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattUnload: ENTERING\n"));

    //
    // Should check here to make sure all DO's are gone.
    //

    ExFreePool (GlobalRegistryPath.Buffer);
    // This is listed as an error so I'll always see when it is unloaded...
    BattPrint(BAT_ERROR, ("SmbBattUnload: Smbbatt.sys unloaded successfully.\n"));

}



NTSTATUS
SmbBattCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSMB_NP_BATT        SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  IrpSp       = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattCreate: ENTERING\n"));


    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, IrpSp->FileObject);

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint(BAT_TRACE, ("SmbBattCreate: EXITING (status = 0x%08x\n", status));
    return(status);
}



NTSTATUS
SmbBattClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSMB_NP_BATT        SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  IrpSp       = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattClose: ENTERING\n"));

    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, IrpSp->FileObject);

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BattPrint(BAT_TRACE, ("SmbBattClose: EXITING\n"));
    return(STATUS_SUCCESS);
}



NTSTATUS
SmbBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request

    Irp             - IO request

Return Value:

    Status of request

--*/
{
    PSMB_NP_BATT            SmbNPBatt;
    PSMB_BATT               SmbBatt;
    ULONG                   InputLen, OutputLen;
    PVOID                   IOBuffer;
    PIO_STACK_LOCATION      IrpSp;

    BOOLEAN                 complete        = TRUE;
    NTSTATUS                status          = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattIoctl: ENTERING\n"));

    IrpSp       = IoGetCurrentIrpStackLocation(Irp);
    SmbNPBatt   = (PSMB_NP_BATT) DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    if (NT_SUCCESS(status)) {
        if (SmbNPBatt->SmbBattFdoType == SmbTypePdo) {
            status = STATUS_NOT_SUPPORTED;
        } else if (SmbNPBatt->SmbBattFdoType == SmbTypeSubsystem) {
#if DEBUG
            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SMBBATT_DATA) {

                //
                // Direct Access Irp
                //

                IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
                InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                status = SmbBattDirectDataAccess (
                    (PSMB_NP_BATT) DeviceObject->DeviceExtension,
                    (PSMBBATT_DATA_STRUCT) IOBuffer,
                    InputLen,
                    OutputLen
                );

                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = OutputLen;
                } else {
                    Irp->IoStatus.Information = 0;
                }

            } else {
#endif
                status = STATUS_NOT_SUPPORTED;
#if DEBUG
            }
#endif
        } else {
            ASSERT (SmbNPBatt->SmbBattFdoType == SmbTypeBattery);

            //
            // Check to see if this is one of the private Ioctls we handle
            //

            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
#if DEBUG
            case IOCTL_SMBBATT_DATA:
                IOBuffer    = Irp->AssociatedIrp.SystemBuffer;
                InputLen    = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                OutputLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // This one is only handled by the battery subsystem
                //

                status = SmbBattDirectDataAccess (
                    (PSMB_NP_BATT) DeviceObject->DeviceExtension,
                    (PSMBBATT_DATA_STRUCT) IOBuffer,
                    InputLen,
                    OutputLen
                );

                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = OutputLen;
                } else {
                    Irp->IoStatus.Information = 0;
                }
                break;
#endif
            default:
                //
                // Not IOCTL for us, see if it's for the battery
                //

                SmbBatt = SmbNPBatt->Batt;
                status  = BatteryClassIoctl (SmbNPBatt->Class, Irp);

                if (NT_SUCCESS(status)) {
                    //
                    // The Irp was completed by the batery class.  Don't
                    // touch the Irp.  Simply release the lock and return.
                    //

                    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);
                    BattPrint(BAT_TRACE, ("SmbBattIoctl: EXITING (was battery IOCTL)\n", status));
                    return status;
                }

                break;

            }   // switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
        }

        IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    BattPrint(BAT_TRACE, ("SmbBattIoctl: EXITING (status = 0x%08x)\n", status));
    return status;
}



NTSTATUS
SmbBattQueryTag (
    IN  PVOID Context,
    OUT PULONG BatteryTag
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current tag value

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Pointer to return current tag


Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    //PSMB_BATT_SUBSYSTEM subsystemExt;
    NTSTATUS            status;
    PSMB_BATT           SmbBatt;
    ULONG               oldSelectorState;

    PAGED_CODE();
    BattPrint(BAT_TRACE, ("SmbBattQueryTag: ENTERING\n"));

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryTag: can't set selector communications path\n"));
    } else {

        //
        // If the tag is not valid, check for one
        //

        if (SmbBatt->Info.Tag == BATTERY_TAG_INVALID) {
            SmbBatt->Info.Valid = 0;
        }

        //
        // Insure the static information regarding the battery up to date
        //

        SmbBattVerifyStaticInfo (SmbBatt, 0);

        //
        // If theres a battery return it's tag
        //

        if (SmbBatt->Info.Tag != BATTERY_TAG_INVALID) {
            *BatteryTag = SmbBatt->Info.Tag;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_NO_SUCH_DEVICE;
        }
    }


    //
    // Done, unlock the device and reset the selector state
    //

    if (NT_SUCCESS (status)) {
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryTag: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }


    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryTag: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattQueryInformation (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN LONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    )
{
    PSMB_BATT           SmbBatt;
    ULONG               ResultData;
    BOOLEAN             IoCheck;
    NTSTATUS            status, st;
    PVOID               ReturnBuffer;
    ULONG               ReturnBufferLength;
    WCHAR               scratchBuffer[SMB_MAX_DATA_SIZE+1]; // +1 for UNICODE_NULL
    UNICODE_STRING      unicodeString;
    UNICODE_STRING      tmpUnicodeString;
    ANSI_STRING         ansiString;
    ULONG               oldSelectorState;
    BATTERY_REPORTING_SCALE granularity;

    PAGED_CODE();
    BattPrint(BAT_TRACE, ("SmbBattQueryInformation: ENTERING\n"));


    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryInformation: can't set selector communications path\n"));
    } else {

        do {
            ResultData = 0;
            ReturnBuffer = NULL;
            ReturnBufferLength = 0;
            status = STATUS_SUCCESS;


            //
            // If no device, or caller has the wrong ID give an error
            //

            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }


            //
            // Get the info requested
            //

            switch (Level) {
                case BatteryInformation:
                    ReturnBuffer = &SmbBatt->Info.Info;
                    ReturnBufferLength = sizeof (SmbBatt->Info.Info);
                    break;

                case BatteryGranularityInformation:
                    SmbBattRW(SmbBatt, BAT_FULL_CHARGE_CAPACITY, &granularity.Capacity);
                    granularity.Capacity *= SmbBatt->Info.PowerScale;
                    granularity.Granularity = SmbBatt->Info.PowerScale;
                    ReturnBuffer = &granularity;
                    ReturnBufferLength  = sizeof (granularity);
                    break;

                case BatteryTemperature:
                    SmbBattRW(SmbBatt, BAT_TEMPERATURE, &ResultData);
                    ReturnBuffer = &ResultData;
                    ReturnBufferLength = sizeof(ULONG);
                    break;

                case BatteryEstimatedTime:

                    //
                    // If an AtRate has been specified, then we will use the AtRate
                    // functions to get this information (AtRateTimeToEmpty()).
                    // Otherwise, we will return the AVERAGE_TIME_TO_EMPTY.
                    //

                    BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AtRate: %08x\n", AtRate));

                    if (AtRate != 0) {
                        //
                        // Currently we only support the time to empty functions.
                        //

                        ASSERT (AtRate < 0);

                        //
                        // The smart battery input value for AtRate is in 10mW increments
                        //

                        AtRate /= (LONG)SmbBatt->Info.PowerScale;
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AtRate scaled to: %08x\n", AtRate));
                        SmbBattWW(SmbBatt, BAT_AT_RATE, AtRate);
                        SmbBattRW(SmbBatt, BAT_RATE_TIME_TO_EMPTY, &ResultData);
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AT_RATE_TIME_TO_EMPTY: %08x\n", ResultData));

                    } else {

                        SmbBattRW(SmbBatt, BAT_AVERAGE_TIME_TO_EMPTY, &ResultData);
                        BattPrint(BAT_DATA, ("SmbBattQueryInformation: EstimatedTime: AVERAGE_TIME_TO_EMPTY: %08x\n", ResultData));
                    }

                    if (ResultData == 0xffff) {
                        ResultData = BATTERY_UNKNOWN_TIME;
                    } else {
                        ResultData *= 60;
                    }
                    BattPrint(BAT_DATA, ("SmbBattQueryInformation: (%01x) EstimatedTime: %08x seconds\n", SmbBatt->SelectorBitPosition, ResultData));

                    ReturnBuffer = &ResultData;
                    ReturnBufferLength = sizeof(ULONG);
                    break;

                case BatteryDeviceName:
                    //
                    // This has to be returned as a WCHAR string but is kept internally
                    // as a character string.  Have to convert it.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    ansiString.Length = SmbBatt->Info.DeviceNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.DeviceName);
                    ansiString.Buffer = SmbBatt->Info.DeviceName;
                    status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status)) {
                        ReturnBuffer       = Buffer;
                        ReturnBufferLength = unicodeString.Length;
                    }
                    break;

                case BatteryManufactureDate:
                    ReturnBuffer = &SmbBatt->Info.ManufacturerDate;
                    ReturnBufferLength = sizeof (SmbBatt->Info.ManufacturerDate);
                    break;

                case BatteryManufactureName:
                    //
                    // This has to be returned as a WCHAR string but is kept internally
                    // as a character string.  Have to convert it.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    ansiString.Length = SmbBatt->Info.ManufacturerNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.ManufacturerName);
                    ansiString.Buffer = SmbBatt->Info.ManufacturerName;
                    status = RtlAnsiStringToUnicodeString (&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status)) {
                        ReturnBuffer        = Buffer;
                        ReturnBufferLength = unicodeString.Length;
                    }
                    break;
                    
                case BatteryUniqueID:
                    //
                    // The unique ID is a character string consisting of the serial
                    // number, the manufacturer name, and the device name.
                    //

                    unicodeString.Buffer        = Buffer;
                    unicodeString.MaximumLength = BufferLength > (USHORT)-1 ? (USHORT) -1 : (USHORT)BufferLength;

                    tmpUnicodeString.Buffer         = scratchBuffer;
                    tmpUnicodeString.MaximumLength  = sizeof (scratchBuffer);

                    RtlIntegerToUnicodeString(SmbBatt->Info.SerialNumber, 10, &unicodeString);

                    ansiString.Length = SmbBatt->Info.ManufacturerNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.ManufacturerName);
                    ansiString.Buffer = SmbBatt->Info.ManufacturerName;
                    status = RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    if (!NT_SUCCESS(status)) break;
                    status = RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
                    if (!NT_SUCCESS(status)) break;

                    ansiString.Length = SmbBatt->Info.DeviceNameLength;
                    ansiString.MaximumLength = sizeof(SmbBatt->Info.DeviceName);
                    ansiString.Buffer = SmbBatt->Info.DeviceName;
                    status = RtlAnsiStringToUnicodeString (&tmpUnicodeString, &ansiString, FALSE);
                    if (!NT_SUCCESS(status)) break;
                    status = RtlAppendUnicodeStringToString (&unicodeString, &tmpUnicodeString);
                    if (!NT_SUCCESS(status)) break;

                    ReturnBuffer        = Buffer;
                    ReturnBufferLength = unicodeString.Length;
                    break;

            }

            //
            // Re-verify static info in case there's been an IO error
            //

            //IoCheck = SmbBattVerifyStaticInfo (SmbBatt, BatteryTag);
            IoCheck = FALSE;

        } while (IoCheck);

    }


    if (NT_SUCCESS (status)) {
        //
        // Done, return buffer if needed
        //

        *ReturnedLength = ReturnBufferLength;
        
        if (ReturnBuffer != Buffer) {
            // ReturnBuffer == Buffer indicates that data is already copied.
            //
            if (BufferLength < ReturnBufferLength) {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            if (NT_SUCCESS(status) && ReturnBuffer) {
                memcpy (Buffer, ReturnBuffer, ReturnBufferLength);
            }
        }

        //
        // Unlock the device and reset the selector state
        //

        st = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (st)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryInformation: can't reset selector communications path\n"));
            status = st;
        }
    } else {
        *ReturnedLength = 0;

        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryInformation: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattSetInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL    Level,
    IN PVOID Buffer                     OPTIONAL
    )
/*++

Routine Description:

    Called by the class driver to set the battery's charge/discharge state.
    The smart battery does not support the critical bias function of this
    call.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    Level           - Action being asked for

Return Value:

    NTSTATUS

--*/
{
    PSMB_BATT           SmbBatt;
    ULONG               newSelectorState;
    ULONG               selectorState;
    UCHAR               smbStatus;
    ULONG               tmp;

    NTSTATUS            status  = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetInformation: ENTERING\n"));


    SmbBatt = (PSMB_BATT) Context;

    //
    // See if this is for our battery
    //

    if ((BatteryTag == BATTERY_TAG_INVALID) || (BatteryTag != SmbBatt->Info.Tag)) {
        return STATUS_NO_SUCH_DEVICE;
    }


    //
    // We can only do this if there is a selector in the system
    //

    if ((SmbBatt->SelectorPresent) && (SmbBatt->Selector)) {

        //
        // Get a lock on the selector
        //

        SmbBattLockSelector (SmbBatt->Selector);

        switch (Level) {

            case BatteryCharge:
                BattPrint(BAT_IRPS, ("SmbBattSetInformation: Got SetInformation for BatteryCharge\n"));

                //
                // Set the appropriate bit in the selector state charge nibble
                //

                newSelectorState = SELECTOR_SET_CHARGE_MASK;
                newSelectorState |= (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_CHARGE);

                //
                // Write the new selector state, then read it back.  The system
                // may or may not let us do this.
                //

                smbStatus = SmbBattGenericWW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                newSelectorState
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint(BAT_ERROR,
                         ("SmbBattSetInformation:  couldn't write selector state - %x\n",
                         smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                smbStatus = SmbBattGenericRW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                &selectorState
                            );

                if ((smbStatus != SMB_STATUS_OK)) {
                    BattPrint(BAT_ERROR,
                        ("SmbBattSetInformation:  couldn't read selector state - %x\n",
                        smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Check the status that was read versus what we wrote
                // to see if the operation was successful
                //

                // To support simultaneous charging of more than one battery,
                // we can't check the charge nibble to see if it is equal to
                // what we wrote, but we can check to see if the battery
                // we specified to charge is now set to charge.

                tmp = (selectorState & SELECTOR_STATE_CHARGE_MASK) >> SELECTOR_SHIFT_CHARGE;
                if (SmbBattReverseLogic(SmbBatt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }

                if (tmp & SmbBatt->SelectorBitPosition) {

                    BattPrint(BAT_IRPS, ("SmbBattSetInformation: successfully set charging battery\n"));

                    //
                    // Success!  Save the new selector state in the cache
                    //

                    SmbBatt->Selector->SelectorState = selectorState;
                    status = STATUS_SUCCESS;

                } else {
                    BattPrint(BAT_ERROR, ("SmbBattSetInformation:  couldn't set charging battery\n"));
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

            case BatteryDischarge:

                BattPrint(BAT_IRPS, ("SmbBattSetInformation: Got SetInformation for BatteryDischarge\n"));

                //
                // Set the appropriate bit in the selector state power by nibble
                //

                newSelectorState = SELECTOR_SET_POWER_BY_MASK;
                newSelectorState |= (SmbBatt->SelectorBitPosition << SELECTOR_SHIFT_POWER);

                //
                // Write the new selector state, then read it back.  The system
                // may or may not let us do this.
                //

                smbStatus = SmbBattGenericWW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                newSelectorState
                            );

                if (smbStatus != SMB_STATUS_OK) {
                    BattPrint(BAT_ERROR,
                             ("SmbBattSetInformation:  couldn't write selector state - %x\n",
                             smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                smbStatus = SmbBattGenericRW (
                                SmbBatt->SmbHcFdo,
                                SmbBatt->Selector->SelectorAddress,
                                SmbBatt->Selector->SelectorStateCommand,
                                &selectorState
                            );

                if ((smbStatus != SMB_STATUS_OK)) {
                    BattPrint(BAT_ERROR,
                             ("SmbBattSetInformation:  couldn't read selector state - %x\n",
                             smbStatus)
                    );

                    status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Check the status that was read versus what we wrote
                // to see if the operation was successful
                //

                // To support simultaneous powering of more than one battery,
                // we can't check the power nibble to see if it is equal to
                // what we wrote, but we can check to see if the battery
                // we specified to power by is now set to power the system.

                tmp = (selectorState & SELECTOR_STATE_POWER_BY_MASK) >> SELECTOR_SHIFT_POWER;
                if (SmbBattReverseLogic(SmbBatt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }

                if (tmp & SmbBatt->SelectorBitPosition) {

                    BattPrint(BAT_IRPS, ("SmbBattSetInformation: successfully set powering battery\n"));

                    //
                    // Success!  Save the new selector state in the cache
                    //

                    SmbBatt->Selector->SelectorState = selectorState;
                    status = STATUS_SUCCESS;

                } else {
                    BattPrint(BAT_ERROR, ("SmbBattSetInformation:  couldn't set powering battery\n"));
                    status = STATUS_UNSUCCESSFUL;
                }
                break;

        }   // switch (Level)

        //
        // Release the lock on the selector
        //

        SmbBattUnlockSelector (SmbBatt->Selector);

    }   // if (SmbBatt->Selector->SelectorPresent)

    BattPrint(BAT_TRACE, ("SmbBattSetInformation: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattGetPowerState (
    IN PSMB_BATT        SmbBatt,
    OUT PULONG          PowerState,
    OUT PLONG           Current
    )
/*++

Routine Description:

    Returns the current state of AC power.  There are several cases which
    make this far more complex than it really ought to be.

    NOTE: the selector must be locked before entering this routine.

Arguments:

    SmbBatt         - Miniport context value for battery

    AcConnected     - Pointer to a boolean where the AC status is returned

Return Value:

    NTSTATUS

--*/
{
    ULONG               tmp;
    ULONG               chargeBattery;
    ULONG               powerBattery;
    NTSTATUS            status;
    UCHAR               smbStatus;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    *PowerState = 0;

    //
    // Is there a selector in the system?  if not, go read directly from the charger
    //

    if ((SmbBatt->SelectorPresent) && (SmbBatt->Selector)) {

        //
        // There is a selector, we will examine the CHARGE nibble of the state register
        //

        SmbBattGenericRW(
                SmbBatt->SmbHcFdo,
                SMB_SELECTOR_ADDRESS,
                SELECTOR_SELECTOR_STATE,
                &SmbBatt->Selector->SelectorState);

        chargeBattery  = (SmbBatt->Selector->SelectorState & SELECTOR_STATE_CHARGE_MASK) >> SELECTOR_SHIFT_CHARGE;
        powerBattery  = (SmbBatt->Selector->SelectorState & SELECTOR_STATE_POWER_BY_MASK) >> SELECTOR_SHIFT_POWER;


        //
        // If the bits in the CHARGE_X nibble of the selector state register are in the
        // reverse logic state, then AC is connected, otherwise AC is not connected.
        //
        // NOTE: This code depends on every selector implementing this.  If it turns out
        // that this is optional, we can no longer depend on this, and must enable the
        // code below it.
        //

        if (SmbBattReverseLogic(SmbBatt->Selector, chargeBattery)) {
            *PowerState |= BATTERY_POWER_ON_LINE;
        }

        //
        // Look at Charge Indicator if it is supported
        //

        if (*PowerState & BATTERY_POWER_ON_LINE) {

            if (SmbBatt->Selector->SelectorInfo & SELECTOR_INFO_CHARGING_INDICATOR_BIT) {
                if (SmbBattReverseLogic(SmbBatt->Selector, powerBattery)) {
                    *PowerState |= BATTERY_CHARGING;
                }
            }

            if (*Current > 0) {
                *PowerState |= BATTERY_CHARGING;

            }

        } else {

            if (*Current <= 0) {

                //
                // There is some small leakage on some systems, even when AC
                // is present.  So, if AC is present, and the draw
                // is below this "noise" level we will not report as discharging
                // and zero this out.
                //

                if (*Current < -25) {
                    *PowerState |= BATTERY_DISCHARGING;

                } else {
                    *Current = 0;

                }
            }

            //else {
            //    *PowerState |= BATTERY_CHARGING;
            //
            //}

            // If we don't report as discharging, then the AC adapter removal
            // might cause a PowerState of 0 to return, which PowerMeter assumes
            // means, don't change anything

            *PowerState |= BATTERY_DISCHARGING;

        }

    } else {

        //
        // There is no selector, so we'll try to read from the charger.
        //

        smbStatus = SmbBattGenericRW (
                        SmbBatt->SmbHcFdo,
                        SMB_CHARGER_ADDRESS,
                        CHARGER_STATUS,
                        &tmp
                    );

        if (smbStatus != SMB_STATUS_OK) {
            BattPrint (
                BAT_ERROR,
                ("SmbBattGetPowerState: Trying to get charging info, couldn't read from charger at %x, status %x\n",
                SMB_CHARGER_ADDRESS,
                smbStatus)
            );

            *PowerState = 0;

            status = STATUS_UNSUCCESSFUL;
        }

        // Read Charger Successful

        else {

            if (tmp & CHARGER_STATUS_AC_PRESENT_BIT) {
                *PowerState = BATTERY_POWER_ON_LINE;

                if (*Current > 0) {
                    *PowerState |= BATTERY_CHARGING;
                }


            } else {

                if (*Current <= 0) {

                    //
                    // There is some small leakage on some systems, even when AC
                    // is present.  So, if AC is present, and the draw
                    // is below this "noise" level we will not report as discharging
                    // and zero this out.
                    //

                    if (*Current < -25) {
                        *PowerState |= BATTERY_DISCHARGING;
                    } else {
                        *Current = 0;
                    }
                }

                // If we don't report as discharging, then the AC adapter removal
                // might cause a PowerState of 0 to return, which PowerMeter assumes
                // means, don't change anything
                *PowerState |= BATTERY_DISCHARGING;

            }
        }
    }

    return status;
}



NTSTATUS
SmbBattQueryStatus (
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    Called by the class driver to retrieve the batteries current status

    N.B. the battery class driver will serialize all requests it issues to
    the miniport for a given battery.  However, this miniport implements
    a lock on the battery device as it needs to serialize to the smb
    battery selector device as well.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    PSMB_BATT           SmbBatt;
    NTSTATUS            status;
    BOOLEAN             IoCheck;
    LONG                Current;
    ULONG               oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattQueryStatus: ENTERING\n"));


    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    status = STATUS_SUCCESS;

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;
    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattQueryStatus: can't set selector communications path\n"));
    } else {

        do {
            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            SmbBattRW(SmbBatt, BAT_VOLTAGE, &BatteryStatus->Voltage);
            BatteryStatus->Voltage *= SmbBatt->Info.VoltageScale;

            SmbBattRW(SmbBatt, BAT_REMAINING_CAPACITY, &BatteryStatus->Capacity);
            BatteryStatus->Capacity *= SmbBatt->Info.PowerScale;

            SmbBattRSW(SmbBatt, BAT_CURRENT, &Current);
            Current *= SmbBatt->Info.CurrentScale;

            BattPrint(BAT_DATA,
                ("SmbBattQueryStatus: (%01x)\n"
                "-------  Remaining Capacity - %x\n"
                "-------  Voltage            - %x\n"
                "-------  Current            - %x\n",
                SmbBatt->SelectorBitPosition,
                BatteryStatus->Capacity,
                BatteryStatus->Voltage,
                Current)
            );

            BatteryStatus->Rate = (Current * ((LONG)BatteryStatus->Voltage))/1000;

            //
            // Check to see if we are currently connected to AC.
            //

            status = SmbBattGetPowerState (SmbBatt, &BatteryStatus->PowerState, &Current);
            if (!NT_SUCCESS (status)) {

                BatteryStatus->PowerState = 0;
            }

            //
            // Re-verify static info in case there's been an IO error
            //

            IoCheck = SmbBattVerifyStaticInfo (SmbBatt, BatteryTag);

        } while (IoCheck);

    }


    if (NT_SUCCESS (status)) {
        //
        // Set batteries current power state & capacity
        //

        SmbBatt->Info.PowerState = BatteryStatus->PowerState;
        SmbBatt->Info.Capacity = BatteryStatus->Capacity;

        //
        // Done, unlock the device and reset the selector state
        //

        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattQueryStatus: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattQueryStatus: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattSetStatusNotify (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    IN PBATTERY_NOTIFY  Notify
    )
/*++

Routine Description:

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

Arguments:

    Context         - Miniport context value for battery

    BatteryTag      - Tag of current battery

    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    PSMB_BATT           SmbBatt;
    NTSTATUS            status;
    BOOLEAN             UpdateAlarm;
    ULONG               Target, NewAlarm;
    LONG                DeltaAdjustment, Attempt, i;
    ULONG               oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattSetStatusNotify: ENTERING\n"));

    if (BatteryTag == BATTERY_TAG_INVALID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if ((Notify->HighCapacity == BATTERY_UNKNOWN_CAPACITY) ||
        (Notify->LowCapacity == BATTERY_UNKNOWN_CAPACITY)) {
        BattPrint(BAT_WARN, ("SmbBattSetStatusNotify: Failing because of BATTERY_UNKNOWN_CAPACITY.\n"));
        return STATUS_NOT_SUPPORTED;
    }

    status = STATUS_SUCCESS;

    //
    // Get device lock and make sure the selector is set up to talk to us.
    // Since multiple people may be doing this, always lock the selector
    // first followed by the battery.
    //

    SmbBatt = (PSMB_BATT) Context;

    BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x): Called with LowCapacity = %08x\n",
            SmbBatt->SelectorBitPosition, Notify->LowCapacity));

    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattSetStatusNotify: can't set selector communications path\n"));

    } else {

        // Target (10*PS*mWh) = Lowcapacity (mWh) / 10*PS (1/(10*PS))
        Target = Notify->LowCapacity / SmbBatt->Info.PowerScale;
        DeltaAdjustment = 0;

        BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x): Last set to: %08x\n",
                SmbBatt->SelectorBitPosition, SmbBatt->AlarmLow.Setting));

        //
        // Some batteries are messed up and won't just take an alarm setting.  Fortunately,
        // the error is off in some linear fashion, so this code attempts to hone in on the
        // adjustment needed to get the proper setting, along with an "allowable fudge value",
        // since sometimes the desired setting can never be obtained.
        //

        for (; ;) {
            if (BatteryTag != SmbBatt->Info.Tag) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            //
            // If the status is charging we can't detect.  Let the OS poll
            //

            if (SmbBatt->Info.PowerState & (BATTERY_CHARGING | BATTERY_POWER_ON_LINE)) {
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // If the current capacity is below the target, fire an alarm and we're done
            //

            if (SmbBatt->Info.Capacity < Target) {
                BatteryClassStatusNotify (SmbBatt->NP->Class);
                break;
            }

            //
            // If the target setting is the Skip value then there was an error attempting
            // this value last time.
            //

            if (Target == SmbBatt->AlarmLow.Skip) {
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // If the current setting is above the current capacity then we need to
            // program the alarm
            //

            UpdateAlarm = FALSE;
            if (Target < SmbBatt->AlarmLow.Setting) {
                UpdateAlarm = TRUE;
            }

            //
            // If the target alarm is above the current setting, and the current setting
            // is off by more then AllowedFudge then it needs updated
            //

            if (Target > SmbBatt->AlarmLow.Setting &&
                Target - SmbBatt->AlarmLow.Setting > (ULONG) SmbBatt->AlarmLow.AllowedFudge) {

                UpdateAlarm = TRUE;
            }

            //
            // If alarm doesn't need updated, done
            //

            if (!UpdateAlarm) {
                BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x) NOT Updating Alarm.\n", SmbBatt->SelectorBitPosition));
                break;
            }
            BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: (%01x) Updating Alarm.\n", SmbBatt->SelectorBitPosition));

            //
            // If this is not the first time, then delta is not good enough.  Let's start
            // adjusting it
            //

            if (DeltaAdjustment) {

                //
                // If delta is positive subtract off 1/2 of fudge
                //

                if (DeltaAdjustment > 0) {
                    DeltaAdjustment -= SmbBatt->AlarmLow.AllowedFudge / 2 + (SmbBatt->AlarmLow.AllowedFudge & 1);
                    // too much - don't handle it
                    if (DeltaAdjustment > 50) {
                        status = STATUS_NOT_SUPPORTED;
                        break;
                    }
                } else {
                    // too much - don't handle it
                    if (DeltaAdjustment < -50) {
                        status = STATUS_NOT_SUPPORTED;
                        break;
                    }
                }

                SmbBatt->AlarmLow.Delta += DeltaAdjustment;
            }

            //
            // If attempt is less then 1, then we can't set it
            //

            Attempt = Target + SmbBatt->AlarmLow.Delta;
            if (Attempt < 1) {
                // battery class driver needs to poll for it
                status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Perform IOs to update & read back the alarm.  Use VerifyStaticInfo after
            // IOs in case there's an IO error and the state is lost.
            //

            SmbBattWW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, Attempt);

            // verify in case there was an IO error

            //if (SmbBattVerifyStaticInfo (SmbBatt, BatteryTag)) {
            //  DeltaAdjustment = 0;
            //  continue;
            //}

            SmbBattRW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, &NewAlarm);

            // verify in case there was an IO error

            //if (SmbBattVerifyStaticInfo (SmbBatt, BatteryTag)) {
            //  DeltaAdjustment = 0;
            //  continue;
            //}

            BattPrint(BAT_DATA,
                ("SmbBattSetStatusNotify: (%01x) Want %X, Had %X, Got %X, CurrentCap %X, Delta %d, Fudge %d\n",
                SmbBatt->SelectorBitPosition,
                Target,
                SmbBatt->AlarmLow.Setting,
                NewAlarm,
                SmbBatt->Info.Capacity / SmbBatt->Info.PowerScale,
                SmbBatt->AlarmLow.Delta,
                SmbBatt->AlarmLow.AllowedFudge
            ));

            //
            // If DeltaAdjustment was applied to Delta but the setting
            // moved by more then DeltaAdjustment, then increase the
            // allowed fudge.
            //

            if (DeltaAdjustment) {
                i = NewAlarm - SmbBatt->AlarmLow.Setting - DeltaAdjustment;
                if (DeltaAdjustment < 0) {
                    DeltaAdjustment = -DeltaAdjustment;
                    i = -i;
                }
                if (i > SmbBatt->AlarmLow.AllowedFudge) {
                    SmbBatt->AlarmLow.AllowedFudge = i;
                    BattPrint(BAT_DATA, ("SmbBattSetStatusNotify: Fudge increased to %x\n", SmbBatt->AlarmLow.AllowedFudge));
                }
            }

            //
            // Current setting
            //

            SmbBatt->AlarmLow.Setting = NewAlarm;

            //
            // Compute next delta adjustment
            //

            DeltaAdjustment = Target - SmbBatt->AlarmLow.Setting;
        }

        //
        // If there was an attempt to set the alarm but it failed, set the
        // skip value so we don't keep trying to set an alarm for this value
        // which isn't working
        //

        if (!NT_SUCCESS(status)  &&  DeltaAdjustment) {
            SmbBatt->AlarmLow.Skip = Target;
        }
    }

    //
    // Done, unlock the device and reset the selector state
    //

    if (NT_SUCCESS (status)) {
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattSetStatusNotify: can't reset selector communications path\n"));
        }
    } else {
        //
        // Ignore the return value from ResetSelectorComm because we already
        // have an error here.
        //

        SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
    }

    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);


    BattPrint(BAT_TRACE, ("SmbBattSetStatusNotify: EXITING\n"));
    return status;
}



NTSTATUS
SmbBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to SmbBattSetStatusNotify.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    NTSTATUS    status;
    PSMB_BATT   SmbBatt;
    ULONG       oldSelectorState;

    PAGED_CODE();

    BattPrint(BAT_TRACE, ("SmbBattDisableStatusNotify: ENTERING\n"));

    SmbBatt = (PSMB_BATT) Context;

    SmbBattLockSelector (SmbBatt->Selector);
    SmbBattLockDevice (SmbBatt);

    status = SmbBattSetSelectorComm (SmbBatt, &oldSelectorState);
    if (!NT_SUCCESS (status)) {
        BattPrint(BAT_ERROR, ("SmbBattDisableStatusNotify: can't set selector communications path\n"));

    } else {

        SmbBatt->AlarmLow.Setting = 0;
        SmbBattWW(SmbBatt, BAT_REMAINING_CAPACITY_ALARM, 0);

        //
        // Done, reset the selector state.
        //
        status = SmbBattResetSelectorComm (SmbBatt, oldSelectorState);
        if (!NT_SUCCESS (status)) {
            BattPrint(BAT_ERROR, ("SmbBattDisableStatusNotify: can't reset selector communications path\n"));
        }
    }

    //
    // Done, unlock the device
    //


    SmbBattUnlockDevice (SmbBatt);
    SmbBattUnlockSelector (SmbBatt->Selector);

    BattPrint(BAT_TRACE, ("SmbBattDisableStatusNotify: EXITING\n"));
    return STATUS_SUCCESS;
}



BOOLEAN
SmbBattVerifyStaticInfo (
    IN PSMB_BATT        SmbBatt,
    IN ULONG            BatteryTag
    )
/*++

Routine Description:

    Reads any non-valid cached battery info and set Info.Valid accordingly.
    Performs a serial number check after reading in battery info in order
    to detect verify the data is from the same battery.  If the value does
    not match what is expect, the cached info is reset and the function
    iterates until a consistent snapshot is obtained.

Arguments:

    SmbBatt         - Battery to read

    BatteryTag      - Tag of battery as expected by the caller

Return Value:

    Returns a boolean to indicate to the caller that IO was performed.
    This allows the caller to iterate on changes it may be making until
    the battery state is correct.

--*/
{
    ULONG               BatteryMode;
    ULONG               ManufacturerDate;
    UCHAR               Buffer[SMB_MAX_DATA_SIZE];
    UCHAR               BufferLength = 0;
    BOOLEAN             IoCheck;
    STATIC_BAT_INFO     NewInfo;
    ULONG               tmp;

    BattPrint(BAT_TRACE, ("SmbBattVerifyStaticInfo: ENTERING\n"));

    IoCheck = FALSE;

    //
    // Loop until state doesn't change
    //

    do {

        //
        // If device name and serial # not known, get them.
        //

        if (!(SmbBatt->Info.Valid & VALID_TAG_DATA)) {

            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_TAG_DATA;

            RtlZeroMemory (&NewInfo, sizeof(NewInfo));
            SmbBattRW(SmbBatt, BAT_SERIAL_NUMBER, &NewInfo.SerialNumber);
            BattPrint(BAT_DATA,
                ("SmbBattVerifyStaticInfo: serial number = %x\n",
                NewInfo.SerialNumber)
            );

            //
            // If SerialNumber was read without a problem, read the rest
            //

            if (SmbBatt->Info.Valid & VALID_TAG_DATA) {


                BattPrint(BAT_IRPS, ("SmbBattVerifyStaticInfo: reading manufacturer name\n"));
                SmbBattRB (
                    SmbBatt,
                    BAT_MANUFACTURER_NAME,
                    NewInfo.ManufacturerName,
                    &NewInfo.ManufacturerNameLength
                );

                BattPrint(BAT_IRPS, ("SmbBattVerifyStaticInfo: reading device name\n"));
                SmbBattRB (
                    SmbBatt,
                    BAT_DEVICE_NAME,
                    NewInfo.DeviceName,
                    &NewInfo.DeviceNameLength
                );

                //
                // See if battery ID has changed
                //

                if (SmbBatt->Info.SerialNumber != NewInfo.SerialNumber ||
                    SmbBatt->Info.ManufacturerNameLength != NewInfo.ManufacturerNameLength ||
                    memcmp (SmbBatt->Info.ManufacturerName, NewInfo.ManufacturerName, NewInfo.ManufacturerNameLength) ||
                    SmbBatt->Info.DeviceNameLength != NewInfo.DeviceNameLength ||
                    memcmp (SmbBatt->Info.DeviceName, NewInfo.DeviceName, NewInfo.DeviceNameLength)) {

                    //
                    // This is a new battery, reread all information
                    //

                    SmbBatt->Info.Valid = VALID_TAG_DATA;

                    //
                    // Pickup ID info
                    //

                    SmbBatt->Info.SerialNumber = NewInfo.SerialNumber;
                    SmbBatt->Info.ManufacturerNameLength = NewInfo.ManufacturerNameLength;
                    memcpy (SmbBatt->Info.ManufacturerName, NewInfo.ManufacturerName, NewInfo.ManufacturerNameLength);
                    SmbBatt->Info.DeviceNameLength = NewInfo.DeviceNameLength;
                    memcpy (SmbBatt->Info.DeviceName, NewInfo.DeviceName, NewInfo.DeviceNameLength);
                }
            } else {

                //
                // No battery, set cached info for no battery
                //

                SmbBatt->Info.Valid = VALID_TAG | VALID_TAG_DATA;
                SmbBatt->Info.Tag   = BATTERY_TAG_INVALID;
            }
        }

        //
        // If the battery tag is valid, and it's NO_BATTERY there is no other
        // cached info to read
        //

        if (SmbBatt->Info.Valid & VALID_TAG  &&  SmbBatt->Info.Tag == BATTERY_TAG_INVALID) {
            break;
        }

        //
        // If the mode has not been verified, do it now
        //

        if (!(SmbBatt->Info.Valid & VALID_MODE)) {

            SmbBatt->Info.Valid |= VALID_MODE;
            SmbBattRW(SmbBatt, BAT_BATTERY_MODE, &BatteryMode);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo:(%01x) Was set to report in %s (BatteryMode = %04x)\n",
                    SmbBatt->SelectorBitPosition,
                    (BatteryMode & CAPACITY_WATTS_MODE)? "10mWH" : "mAH", BatteryMode));

            if (!(BatteryMode & CAPACITY_WATTS_MODE)) {

                //
                // Battery not in watts mode, clear valid_mode bit and
                // set the battery into watts mode now
                //

                BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo:(%01x) Setting battery to report in 10mWh\n",
                            SmbBatt->SelectorBitPosition));

                SmbBatt->Info.Valid &= ~VALID_MODE;
                BatteryMode |= CAPACITY_WATTS_MODE;
                SmbBattWW(SmbBatt, BAT_BATTERY_MODE, BatteryMode);
                continue;       // re-read mode
            }
        }

        //
        // If other static manufacturer info not known, get it
        //

        if (!(SmbBatt->Info.Valid & VALID_OTHER)) {
            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_OTHER;

            SmbBatt->Info.Info.Capabilities = (BATTERY_SYSTEM_BATTERY |
                                    BATTERY_SET_CHARGE_SUPPORTED |
                                    BATTERY_SET_DISCHARGE_SUPPORTED);
            SmbBatt->Info.Info.Technology = 1;  // secondary cell type

            // Read chemistry
            SmbBattRB (SmbBatt, BAT_CHEMISTRY, Buffer, &BufferLength);
            if (BufferLength > MAX_CHEMISTRY_LENGTH) {
                ASSERT (BufferLength > MAX_CHEMISTRY_LENGTH);
                BufferLength = MAX_CHEMISTRY_LENGTH;
            }
            RtlZeroMemory (SmbBatt->Info.Info.Chemistry, MAX_CHEMISTRY_LENGTH);
            memcpy (SmbBatt->Info.Info.Chemistry, Buffer, BufferLength);

            //
            // Voltage and Current scaling information
            //

            SmbBattRW (SmbBatt, BAT_SPECITICATION_INFO, &tmp);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%04x) specification info = %x\n",
                            SmbBatt->SelectorBitPosition, tmp));

            switch ((tmp & BATTERY_VSCALE_MASK) >> BATTERY_VSCALE_SHIFT) {

                case 1:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_1;
                    break;

                case 2:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_2;
                    break;

                case 3:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_3;
                    break;

                case 0:
                default:
                    SmbBatt->Info.VoltageScale = BSCALE_FACTOR_0;
                    break;
            }

            switch ((tmp & BATTERY_IPSCALE_MASK) >> BATTERY_IPSCALE_SHIFT) {
                case 1:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_1;
                    break;

                case 2:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_2;
                    break;

                case 3:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_3;
                    break;

                case 0:
                default:
                    SmbBatt->Info.CurrentScale = BSCALE_FACTOR_0;
                    break;
            }

            SmbBatt->Info.PowerScale = SmbBatt->Info.CurrentScale * SmbBatt->Info.VoltageScale * 10;

            //
            // Read DesignCapacity & FullChargeCapacity and multiply them by the
            // scaling factor
            //

            SmbBattRW(SmbBatt, BAT_DESIGN_CAPACITY, &SmbBatt->Info.Info.DesignedCapacity);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%01x) DesignCapacity = %04x ... PowerScale = %08x\n",
                        SmbBatt->SelectorBitPosition, SmbBatt->Info.Info.DesignedCapacity, SmbBatt->Info.PowerScale));
            SmbBatt->Info.Info.DesignedCapacity *= SmbBatt->Info.PowerScale;

            SmbBattRW(SmbBatt, BAT_FULL_CHARGE_CAPACITY, &SmbBatt->Info.Info.FullChargedCapacity);
            BattPrint(BAT_DATA, ("SmbBattVerifyStaticInfo: (%01x) FullChargedCapacity = %04x ... PowerScale = %08x\n",
                        SmbBatt->SelectorBitPosition, SmbBatt->Info.Info.FullChargedCapacity, SmbBatt->Info.PowerScale));
            SmbBatt->Info.Info.FullChargedCapacity *= SmbBatt->Info.PowerScale;


            //
            // Smart batteries have no Use the RemainingCapacityAlarm from the smart battery for the alert values
            //

            SmbBatt->Info.Info.DefaultAlert1 = 0;
            SmbBatt->Info.Info.DefaultAlert2 = 0;

            // Critical bias is 0 for smart batteries.
            SmbBatt->Info.Info.CriticalBias = 0;

            // Manufacturer date
            SmbBattRW (SmbBatt, BAT_MANUFACTURER_DATE, &ManufacturerDate);
            SmbBatt->Info.ManufacturerDate.Day      = (UCHAR) ManufacturerDate & 0x1f;        // day
            SmbBatt->Info.ManufacturerDate.Month    = (UCHAR) (ManufacturerDate >> 5) & 0xf;  // month
            SmbBatt->Info.ManufacturerDate.Year     = (USHORT) (ManufacturerDate >> 9) + 1980;
        }

        //
        // If cycle count is not known, read it
        //

        if (!(SmbBatt->Info.Valid & VALID_CYCLE_COUNT)) {
            IoCheck = TRUE;
            SmbBatt->Info.Valid |= VALID_CYCLE_COUNT;

            SmbBattRW(SmbBatt, BAT_CYCLE_COUNT, &SmbBatt->Info.Info.CycleCount);
        }

        //
        // If redundant serial # read hasn't been done, do it now
        //

        if (!(SmbBatt->Info.Valid & VALID_SANITY_CHECK)) {
            SmbBatt->Info.Valid |= VALID_SANITY_CHECK;
            SmbBattRW(SmbBatt, BAT_SERIAL_NUMBER, &NewInfo.SerialNumber);
            if (SmbBatt->Info.SerialNumber != NewInfo.SerialNumber) {
                SmbBatt->Info.Valid &= ~VALID_TAG_DATA;
            }
        }

        //
        // If cached info isn't complete, loop
        //

    } while ((SmbBatt->Info.Valid & VALID_ALL) != VALID_ALL) ;

    //
    // If the tag isn't assigned, assign it
    //

    if (!(SmbBatt->Info.Valid & VALID_TAG)) {
        SmbBatt->TagCount += 1;
        SmbBatt->Info.Tag  = SmbBatt->TagCount;
        SmbBatt->Info.Valid |= VALID_TAG;
        SmbBatt->AlarmLow.Setting = 0;      // assume not set
        SmbBatt->AlarmLow.Skip = 0;
        SmbBatt->AlarmLow.Delta = 0;
        SmbBatt->AlarmLow.AllowedFudge = 0;
    }

    //
    // If callers BatteryTag does not match current tag, let caller know
    //

    if (SmbBatt->Info.Tag != BatteryTag) {
        IoCheck = TRUE;
    }

    //
    // Let caller know if there's been an IoCheck
    //

    BattPrint(BAT_TRACE, ("SmbBattVerifyStaticInfo: EXITING\n"));
    return IoCheck;
}



VOID
SmbBattInvalidateTag (
    PSMB_BATT_SUBSYSTEM SubsystemExt,
    ULONG BatteryIndex,
    BOOLEAN NotifyClient
)
/*++

Routine Description:

    This routine processes battery insertion/removal by invalidating the
    tag information and then notifies the client of the change.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    BatteryIndex            - Index of Battery to Process Changes for
                - Power and Charge

    NotifyClient             - Whether or not to Notify Client

Return Value:

    None
--*/

{
    PDEVICE_OBJECT      batteryPdo;
    PSMB_BATT_PDO       batteryPdoExt;
    PDEVICE_OBJECT      batteryFdo;
    PSMB_NP_BATT        smbNpBatt;
    PSMB_BATT           smbBatt;

    BattPrint(BAT_TRACE, ("SmbBattInvalidateTag: ENTERING for battery %x\n", BatteryIndex));

    batteryPdo = SubsystemExt->BatteryPdoList[BatteryIndex];

    if (batteryPdo) {
        batteryPdoExt   = (PSMB_BATT_PDO) batteryPdo->DeviceExtension;
        batteryFdo      = batteryPdoExt->Fdo;

        if (batteryFdo) {

            //
            // Invalidate this battery's tag data
            //

            BattPrint (
                BAT_ALARM,
                ("SmbBattInvalidateTag: Battery present status change, invalidating battery %x\n",
                BatteryIndex)
            );

            smbNpBatt   = (PSMB_NP_BATT) batteryFdo->DeviceExtension;
            smbBatt     = smbNpBatt->Batt;

            SmbBattLockDevice (smbBatt);

            smbBatt->Info.Valid = 0;
            smbBatt->Info.Tag   = BATTERY_TAG_INVALID;

            SmbBattUnlockDevice (smbBatt);

            //
            // Notify the class driver
            //

            if (NotifyClient) {
                BattPrint(BAT_ALARM, ("SmbBattInvalidateTag: Status Change notification for battery %x\n", BatteryIndex));
                SmbBattNotifyClassDriver (SubsystemExt, BatteryIndex);
            }
        }
    }

    BattPrint(BAT_TRACE, ("SmbBattInvalidateTag: EXITING\n"));
}



VOID
SmbBattAlarm (
    IN PVOID    Context,
    IN UCHAR    Address,
    IN USHORT   Data
    )
{
    PSMB_ALARM_ENTRY        newAlarmEntry;
    ULONG                   compState;

    PSMB_BATT_SUBSYSTEM     subsystemExt    = (PSMB_BATT_SUBSYSTEM) Context;

    BattPrint(BAT_TRACE, ("SmbBattAlarm: ENTERING\n"));
    BattPrint(BAT_DATA, ("SmbBattAlarm: Alarm - Address %x, Data %x\n", Address, Data));

    // If we have a selector and the message is from the address that
    // implements the selector, then handle it.  If there is no selector
    // and the message is from the charger, then process it. Or, if the
    // message is from the battery, then process it.  Or, in other words,
    // if the message is from the charger and we have a stand-alone selector,
    // then ignore the message.

    if (Address != SMB_BATTERY_ADDRESS) {
        if ((subsystemExt->SelectorPresent) && (subsystemExt->Selector)) {

            // If a Selector is implemented and the Alarm Message came from
            // something besides the Selector or a Battery, then ignore it.

            if (Address != subsystemExt->Selector->SelectorAddress) {
                return;
            }
        }
    }

    //
    // Allocate a new alarm list structure.  This has to be from non-paged pool
    // because we are being called at Dispatch level.
    //

    newAlarmEntry = ExAllocatePoolWithTag (NonPagedPool, sizeof (SMB_ALARM_ENTRY), 'StaB');
    if (!newAlarmEntry) {
        BattPrint (BAT_ERROR, ("SmbBattAlarm:  couldn't allocate alarm structure\n"));
        return;
    }

    newAlarmEntry->Data     = Data;
    newAlarmEntry->Address  = Address;

    //
    // Add this alarm to the alarm queue
    //

    ExInterlockedInsertTailList(
        &subsystemExt->AlarmList,
        &newAlarmEntry->Alarms,
        &subsystemExt->AlarmListLock
    );

    //
    // Add 1 to the WorkerActive value, if this is the first count
    // queue a worker thread
    //

    if (InterlockedIncrement(&subsystemExt->WorkerActive) == 1) {
        IoQueueWorkItem (subsystemExt->WorkerThread, SmbBattWorkerThread, DelayedWorkQueue, subsystemExt);
    }

    BattPrint(BAT_TRACE, ("SmbBattAlarm: EXITING\n"));
}



VOID
SmbBattWorkerThread (
    IN PDEVICE_OBJECT   Fdo,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine handles the alarms for the batteries.

Arguments:

    Context         - Non-paged extension for the battery subsystem FDO

Return Value:

    None
--*/
{
    PSMB_ALARM_ENTRY        alarmEntry;
    PLIST_ENTRY             nextEntry;
    ULONG                   selectorState;
    ULONG                   batteryIndex;

    BOOLEAN                 charging = FALSE;
    BOOLEAN                 acOn = FALSE;

    PSMB_BATT_SUBSYSTEM     subsystemExt = (PSMB_BATT_SUBSYSTEM) Context;


    BattPrint(BAT_TRACE, ("SmbBattWorkerThread: ENTERING\n"));

    do {

        //
        // Check to see if we have more alarms to process.  If so retrieve
        // the next one and decrement the worker active count.
        //

        nextEntry = ExInterlockedRemoveHeadList(
                        &subsystemExt->AlarmList,
                        &subsystemExt->AlarmListLock
                    );

        //
        //It should only get here if there is an entry in the list
        //
        ASSERT (nextEntry != NULL);

        alarmEntry = CONTAINING_RECORD (nextEntry, SMB_ALARM_ENTRY, Alarms);

        BattPrint(
            BAT_ALARM,
            ("SmbBattWorkerThread: processing alarm, address = %x, data = %x\n",
            alarmEntry->Address,
            alarmEntry->Data)
        );

        //
        // Get last Selector State Cached Value (update cache with new value)
        //

        if (subsystemExt->SelectorPresent) {
            if (subsystemExt->Selector) {
                selectorState = subsystemExt->Selector->SelectorState;
            } else {
                // We're not initialized enough to handle a message
                break;
            }
        }

        // Determine Source of Alarm Message and then Process it

        switch (alarmEntry->Address) {

            case SMB_CHARGER_ADDRESS:

                //
                // Handle Charger Message - If Charger/Selector Combo, then
                // fall through and handle it as a Selector.  If no Selector,
                // then attempt processing as a Charger. Ignore Charger messages
                // if Selector is present.
                //

                if (!subsystemExt->SelectorPresent) {

                    SmbBattProcessChargerAlarm (subsystemExt, alarmEntry->Data);
                    break;

                } else {

                    // If SelectorPresent, but no Selector Structure, Ignore message
                    if (!subsystemExt->Selector) {
                        break;
                    } else {
                        if (subsystemExt->Selector->SelectorAddress != SMB_CHARGER_ADDRESS) {

                            break;
                        }
                    }
                }


                //
                // Fall through to Selector Procesing for integrated Charger/Selector
                //

            case SMB_SELECTOR_ADDRESS:

                if (!subsystemExt->SelectorPresent) {
                    BattPrint (
                        BAT_BIOS_ERROR,
                        ("SmbBattProcessSelectorAlarm: Received alarm from selector address, but BIOS reports no selector is present.\n")
                    );
                    break;
                }

                //
                // This is a selector alarm indicating a change in the selector state.
                // There are four different areas that could change: SMB, POWER_BY,
                // CHARGE, PRESENT. First try to determine which ones changed.
                //

                SmbBattLockSelector (subsystemExt->Selector);
                BattPrint (
                    BAT_DATA,
                    ("SmbBattProcessSelectorAlarm: New SelectorState being written as - %x\n",
                    alarmEntry->Data)
                );
                subsystemExt->Selector->SelectorState = alarmEntry->Data;
                SmbBattUnlockSelector (subsystemExt->Selector);

                SmbBattProcessSelectorAlarm (subsystemExt, selectorState, alarmEntry->Data);
                break;

            case SMB_BATTERY_ADDRESS:

                //
                // Send notifications to all batteries.
                // It seems we get notifications even for batteries not currently selected.
                //

                for (batteryIndex = 0; batteryIndex < subsystemExt->NumberOfBatteries; batteryIndex++) {
                    BattPrint(BAT_ALARM, ("SmbBattWorkerThread: Notification to battery %x\n", batteryIndex));
                    SmbBattNotifyClassDriver (subsystemExt, batteryIndex);
                }
                break;

        } //  switch (alarmEntry->Address)

        //
        // Free the alarm structure
        //

        ExFreePool (alarmEntry);

    } while (InterlockedDecrement (&subsystemExt->WorkerActive) != 0);

    BattPrint(BAT_TRACE, ("SmbBattWorkerThread: EXITING\n"));
}



VOID
SmbBattProcessSelectorAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                OldSelectorState,
    IN ULONG                NewSelectorState
    )
/*++

Routine Description:

    This routine process alarms generated by the selector.  We will only get
    here is there is a change in the SelectorState for one or more of the
    following state changes:

    - PowerBy nibble change caused by the power source changing to a different
      battery or to AC adapter.

    - PowerBy nbble change caused by optional Charge Indicator state change
      when the charger starts or stops charging a battery.

    - ChargeWhich nibble change caused by a change in the current battery
      connected to the Charger.

    - ChargeWhich nibble change caused by AC adapter insertion/removal.

    - BatteryPresent nibble change caused by insertion/removal of 1 or more batteries.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    NewSelectorState        - Data value sent by the selector alarm, which is
                              New SelectorState.

Return Value:

    None
--*/
{
    ULONG   tmp;
    ULONG   BatteryMask;
    ULONG   NotifyMask;
    ULONG   ChangeSelector;
    ULONG   index;

    BattPrint(BAT_TRACE, ("SmbBattProcessSelectorAlarm: ENTERING\n"));

    //
    // Determine SelectorState changes and combine them together
    //

    ChangeSelector = NewSelectorState ^ OldSelectorState;

    if (!(ChangeSelector & ~SELECTOR_STATE_SMB_MASK)) {
        //
        // If the only change is in SMB nibble, no nothing.
        //
        return;
    }

    //
    // Check for change to Batteries Present nibble. Invalidate and Notify
    // each battery that changes state.
    //
    BatteryMask = ChangeSelector & SELECTOR_STATE_PRESENT_MASK;
    NotifyMask = BatteryMask;

    //
    // Check for change to Charge Which nibble. If all bits set, then the nibble
    // just inverted state indicating an AC adapter Insertion/Removal.  Notify
    // all batteries of change.  If only one or two bits changed, notify just
    // the batteries that changed status.
    //

    tmp = (ChangeSelector >> SELECTOR_SHIFT_CHARGE) & SELECTOR_STATE_PRESENT_MASK;
    if (tmp) {

        // If nibble inverted state, then the AC Adapter changed state

        if (tmp == SELECTOR_STATE_PRESENT_MASK) {

            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: AC Adapter was inserted/removed\n"));
            NotifyMask |= tmp;

        // Battery Charge Which changed

        } else {
            //if (SmbBattReverseLogic(SubsystemExt->Selector, tmp)) {
            //    tmp ^= SELECTOR_STATE_PRESENT_MASK;
            //}

            // Let's just notify all batteries to be safe

            tmp = SELECTOR_STATE_PRESENT_MASK;
            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Charger Nibble changed status\n"));
            NotifyMask |= tmp;
        }
    }

    //
    // Check for change in Power By nibble. Notify all batteries of any change.
    //

    tmp = (ChangeSelector >> SELECTOR_SHIFT_POWER) & SELECTOR_STATE_PRESENT_MASK;
    if (tmp) {

        // If nibble inverted state, then the check for Charge Indicator change
        // and notify the battery that started/stopped charging

        if (tmp == SELECTOR_STATE_PRESENT_MASK) {
            if (SubsystemExt->Selector->SelectorInfo & SELECTOR_INFO_CHARGING_INDICATOR_BIT) {
                tmp = (NewSelectorState >> SELECTOR_SHIFT_CHARGE) & SELECTOR_STATE_PRESENT_MASK;
                if (SmbBattReverseLogic(SubsystemExt->Selector, tmp)) {
                    tmp ^= SELECTOR_STATE_PRESENT_MASK;
                }
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Charging Indicator changed status\n"));
                NotifyMask |= tmp;
            } else {
                // If not Charging Indicator, then all battery power by nibbles inverted
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Power By inverted state, without supporting Charge Indication\n"));
                NotifyMask |= SELECTOR_STATE_PRESENT_MASK;
            }

        } else {

            // Let's notify all batteries if the Power By nibble changes

            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Power By Nibble changed status\n"));
            NotifyMask |= SELECTOR_STATE_PRESENT_MASK;
        }
    }

    //
    // Notify all batteries of change in Present Status
    //

    tmp = BATTERY_A_PRESENT;
    for (index = 0; index < SubsystemExt->NumberOfBatteries; index++) {
        if (BatteryMask & tmp) {
            if (!(NewSelectorState & tmp)) {
                BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Invalidating battery %x\n", index));
                SmbBattInvalidateTag (SubsystemExt, index, FALSE);
            }
        }
        tmp <<= 1;
    }

    // Don't notify batteries already notified
    //NotifyMask &= ~BatteryMask;

    //
    // Process Notifications Now for changes to SelectorState for Power, Charge, etc.
    //

    tmp = BATTERY_A_PRESENT;
    for (index = 0; index < SubsystemExt->NumberOfBatteries; index++) {
        if (NotifyMask & tmp) {
            BattPrint(BAT_DATA, ("SmbBattProcessSelectorAlarm: Status Change notification for battery %x\n", index));
            SmbBattNotifyClassDriver (SubsystemExt, index);
        }
        tmp <<= 1;
    }

    BattPrint(BAT_TRACE, ("SmbBattProcessSelectorAlarm: EXITING\n"));
}



VOID
SmbBattProcessChargerAlarm (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                ChargerStatus
    )
/*++

Routine Description:

    This routine process alarms generated by the charger.  We will only get
    here is there is no selector in the system and the alarm is the one to
    tell us when AC and batteries come and go.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    ChargerStatus           - Data value sent by the charger alarm, which is
                              charger status register

Return Value:

    None
--*/
{
    BattPrint(BAT_TRACE, ("SmbBattProcessChargeAlarm: ENTERING\n"));

    //
    // There should only be two reasons we get called: a change in AC, or
    // a change in the battery present.  We are really only interested in
    // whether or not there is a battery in the system.  If there isn't, we
    // will invalidate battery 0.  If it was already gone this re-invalidation
    // won't matter.
    //

    if (!(ChargerStatus & CHARGER_STATUS_BATTERY_PRESENT_BIT)) {
        SmbBattInvalidateTag (SubsystemExt, BATTERY_A, TRUE);
    }

    // Notify Change

    SmbBattNotifyClassDriver (SubsystemExt, 0);

    BattPrint(BAT_TRACE, ("SmbBattProcessChargerAlarm: EXITING\n"));
}




VOID
SmbBattNotifyClassDriver (
    IN PSMB_BATT_SUBSYSTEM  SubsystemExt,
    IN ULONG                BatteryIndex
    )
/*++

Routine Description:

    This routine gets the FDO for the battery indicated by index from the
    smart battery subsystem and notifies the class driver there has been
    a status change.

Arguments:

    SubsystemExt            - Device extension for the smart battery subsystem

    BatteryIndex            - Index for the battery in the subsystem battery
                              list

Return Value:

    None
--*/
{
    PDEVICE_OBJECT      batteryPdo;
    PSMB_BATT_PDO       batteryPdoExt;
    PDEVICE_OBJECT      batteryFdo;
    PSMB_NP_BATT        smbNpBatt;


    BattPrint(BAT_TRACE, ("SmbBattNotifyClassDriver: ENTERING\n"));

    batteryPdo      = SubsystemExt->BatteryPdoList[BatteryIndex];
    if (batteryPdo) {
        batteryPdoExt   = (PSMB_BATT_PDO) batteryPdo->DeviceExtension;
        batteryFdo      = batteryPdoExt->Fdo;

        if (batteryFdo) {
            BattPrint (
                BAT_IRPS,
                ("SmbBattNotifyClassDriver: Calling BatteryClassNotify for battery - %x\n",
                batteryFdo)
            );

            smbNpBatt = (PSMB_NP_BATT) batteryFdo->DeviceExtension;

            BatteryClassStatusNotify (smbNpBatt->Class);
        }
    } else {
        BattPrint (
            BAT_ERROR,
            ("SmbBattNotifyClassDriver: No PDO for device.\n")
        );
    }

    BattPrint(BAT_TRACE, ("SmbBattNotifyClassDriver: EXITING\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbc.h ===
#define SMBCLASS    1

#include <wdm.h>
#include <smbus.h>
#include <devioctl.h>
#include <acpiioct.h>
#include <acpimsft.h>

#define _INC_NSOBJ_ONLY
#include <amli.h>
#include <aml.h>

#if DBG
#define DEBUG   1
#else
#define DEBUG   0
#endif

//
// Debug
//

extern ULONG SMBCDebug;

#if DEBUG
    #define SmbPrint(l,m)               if(l & SMBCDebug) DbgPrint m
    #define ASSERT_DEVICE_LOCKED(a)     ASSERT(a->SpinLockAcquired);
#else
    #define SmbPrint(l,m)
    #define ASSERT_DEVICE_LOCKED(a)
#endif

#define SMB_LOW         0x00000010
#define SMB_STATE       0x00000020
#define SMB_HANDLER     0x00000040
#define SMB_ALARMS      0x00000080
#define SMB_NOTE        0x00000001
#define SMB_WARN        0x00000002
#define SMB_ERROR       0x00000004
#define SMB_ERRORS      (SMB_ERROR | SMB_WARN)
#define SMB_TRANSACTION 0x00000100


//
// Internal SMB class data
//


#define MAX_RETRIES     5
#define RETRY_TIME      -800000             // Delay 80ms

//typedef
//VOID
//(*SMB_ALARM_NOTIFY)(
//    IN PVOID            Context,
//    IN USHORT           AlarmData
//    );

typedef struct {
    LIST_ENTRY          Link;               // List of all alarm notifies
    UCHAR               Flag;
    UCHAR               Reference;
    UCHAR               MinAddress;         // Min address on bus
    UCHAR               MaxAddress;         // Max address
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;

} SMB_ALARM, *PSMB_ALARM;

#define SMBC_ALARM_DELETE_PENDING     0x01


typedef struct {
    SMB_CLASS           Class;              // Shared Class/Miniport data

    KSPIN_LOCK          SpinLock;           // Lock device data
    KIRQL               SpinLockIrql;       // Irql spinlock acquired at
    BOOLEAN             SpinLockAcquired;   // Debug only

    //
    // Alarm notifies
    //

    LIST_ENTRY          Alarms;             // List of all Alarm notifies
    KEVENT              AlarmEvent;         // Used to delete alarms

    //
    // IO
    //

    LIST_ENTRY          WorkQueue;          // Queued IO IRPs to the device
    BOOLEAN             InService;          // Irp
    UCHAR               IoState;

    //
    // Current IO request
    //

    UCHAR               RetryCount;
    KTIMER              RetryTimer;
    KDPC                RetryDpc;

    //
    // Operation Region
    //

    PVOID               RawOperationRegionObject;

} SMBDATA, *PSMBDATA;

//
// IoState
//

#define SMBC_IDLE                       0
#define SMBC_START_REQUEST              1
#define SMBC_WAITING_FOR_REQUEST        2
#define SMBC_COMPLETE_REQUEST           3
#define SMBC_COMPLETING_REQUEST         4
#define SMBC_WAITING_FOR_RETRY          5


//
// ACPI SMBus opregion details
//

typedef struct {
    UCHAR        Status;
    UCHAR        Length;
    UCHAR        Data [32];
} BUFFERACC_BUFFER, *PBUFFERACC_BUFFER;

#define SMB_QUICK 0x02
#define SMB_SEND_RECEIVE 0x04
#define SMB_BYTE 0x06
#define SMB_WORD 0x08
#define SMB_BLOCK 0x0a
#define SMB_PROCESS 0x0c
#define SMB_BLOCK_PROCESS 0x0d

//
// Prototypes
//

VOID
SmbClassStartIo (
    IN PSMBDATA             Smb
    );

VOID
SmbCRetry (
    IN struct _KDPC         *Dpc,
    IN PVOID                DeferredContext,
    IN PVOID                SystemArgument1,
    IN PVOID                SystemArgument2
    );


NTSTATUS
SmbCRegisterAlarm (
    PSMBDATA                Smb,
    PIRP                    Irp
    );

NTSTATUS
SmbCDeregisterAlarm (
    PSMBDATA                Smb,
    PIRP                    Irp
    );

NTSTATUS EXPORT
SmbCRawOpRegionHandler (
    ULONG                   AccessType,
    PFIELDUNITOBJ           FieldUnit,
    POBJDATA                Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
SmbCRawOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
SmbCSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              IoCompletionEvent
    );

//
// Io extension macro to just pass on the Irp to a lower driver
//

#define SmbCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbbatt\smbwmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SmbWmi.c

Abstract:

    Wmi section for Smart Battery Miniport Driver

Author:

    Michael Hills

Environment:

    Kernel mode

Revision History:

--*/

#include "SmbBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>

NTSTATUS
SmbBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
SmbBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

#if DEBUG
PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
);
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbBattWmiRegistration)
#pragma alloc_text(PAGE,SmbBattWmiDeRegistration)
#pragma alloc_text(PAGE,SmbBattSystemControl)
#pragma alloc_text(PAGE,SmbBattQueryWmiRegInfo)
#endif


NTSTATUS
SmbBattSystemControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine passes the request down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PSMB_NP_BATT            SmbNPBatt;
    PIO_STACK_LOCATION      stack;
    PDEVICE_OBJECT          lowerDevice;
    SYSCTL_IRP_DISPOSITION  disposition = IrpForward;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);

    BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: %s\n",
                WMIMinorFunctionString(stack->MinorFunction)));

    SmbNPBatt = (PSMB_NP_BATT) DeviceObject->DeviceExtension;

    //
    // Aquire remove lock
    //
    status = IoAcquireRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    if (SmbNPBatt->SmbBattFdoType == SmbTypeBattery) {
        lowerDevice = SmbNPBatt->LowerDevice;
        status = BatteryClassSystemControl(SmbNPBatt->Class,
                                           &SmbNPBatt->WmiLibContext,
                                           DeviceObject,
                                           Irp,
                                           &disposition);
    } else if (SmbNPBatt->SmbBattFdoType == SmbTypeSubsystem) {
        lowerDevice = ((PSMB_BATT_SUBSYSTEM) DeviceObject->DeviceExtension)->LowerDevice;
    } else {
        //
        // There is no lower device.  Just complete the IRP.
        //
        lowerDevice = NULL;
        disposition = IrpNotCompleted;
        status = Irp->IoStatus.Status;
    }

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Processed\n"));

            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Not Completed.\n"));
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            BattPrint((BAT_TRACE), ("SmbBatt: SystemControl: Irp Forward.\n"));
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (lowerDevice, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (lowerDevice, Irp);
            break;
        }
    }

    //
    // Release Removal Lock
    //
    IoReleaseRemoveLock (&SmbNPBatt->RemoveLock, Irp);

    return status;
}


NTSTATUS
SmbBattWmiRegistration(
    PSMB_NP_BATT SmbNPBatt
)
/*++
Routine Description

    Registers with WMI as a data provider for this
    instance of the device

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // This is essentially blank since smbbatt.sys doesn't have any
    // data to handle other than the default battery class data which is handled
    // by the battery class driver.
    // If there were driver specific data, such as Device Wake Enable controls, 
    // it would be listed here.
    // 

    SmbNPBatt->WmiLibContext.GuidCount = 0;
    SmbNPBatt->WmiLibContext.GuidList = NULL;
    SmbNPBatt->WmiLibContext.QueryWmiRegInfo = SmbBattQueryWmiRegInfo;
    SmbNPBatt->WmiLibContext.QueryWmiDataBlock = SmbBattQueryWmiDataBlock;
    SmbNPBatt->WmiLibContext.SetWmiDataBlock = NULL;
    SmbNPBatt->WmiLibContext.SetWmiDataItem = NULL;
    SmbNPBatt->WmiLibContext.ExecuteWmiMethod = NULL;
    SmbNPBatt->WmiLibContext.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //

    status = IoWMIRegistrationControl(SmbNPBatt->Batt->DeviceObject,
                             WMIREG_ACTION_REGISTER
                             );

    return status;

}

NTSTATUS
SmbBattWmiDeRegistration(
    PSMB_NP_BATT SmbNPBatt
)
/*++
Routine Description

     Inform WMI to remove this DeviceObject from its
     list of providers. This function also
     decrements the reference count of the deviceobject.

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(SmbNPBatt->Batt->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER
                                 );

}

//
// WMI System Call back functions
//

NTSTATUS
SmbBattQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PSMB_NP_BATT SmbNPBatt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    BattPrint ((BAT_TRACE), ("SmbBatt: Entered SmbBattQueryWmiRegInfo\n"));


    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &GlobalRegistryPath;
    *Pdo = SmbNPBatt->Batt->PDO;

    return STATUS_SUCCESS;
}

NTSTATUS
SmbBattQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PSMB_NP_BATT    SmbNPBatt = (PSMB_NP_BATT) DeviceObject->DeviceExtension;
    NTSTATUS        status;

    PAGED_CODE();

    BattPrint ((BAT_TRACE), ("Entered SmbBattQueryWmiDataBlock\n"));

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    status = BatteryClassQueryWmiDataBlock(
        SmbNPBatt->Class,
        DeviceObject,
        Irp,
        GuidIndex,
        InstanceLengthArray,
        OutBufferSize,
        Buffer);

    if (status != STATUS_WMI_GUID_NOT_FOUND) {
        BattPrint ((BAT_TRACE), ("SmbBattQueryWmiDataBlock: Handled by Battery Class.\n"));
        return status;
    }

    //
    // Fail Request: Smart battery has no other GUIDs
    //

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  STATUS_WMI_GUID_NOT_FOUND,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}


#if DEBUG

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE";
        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM";
        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION";
        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS";
        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION";
        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS";
        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD";
        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA";
        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE";
        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO";
        default:
            return "IRP_MN_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbclass.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbclass.c

Abstract:

    SMBus Class Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:
    27-Feb-97
        Pnp support - Bob Moore

--*/

#include "smbc.h"



ULONG   SMBCDebug = SMB_ERRORS;

//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SmbClassDeviceInitialize (
    PSMB_CLASS      SmbClass
    );

VOID
SmbCUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SmbCInternalIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SmbCForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,SmbClassInitializeDevice)
#pragma alloc_text(PAGE,SmbCUnload)
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{

    return STATUS_SUCCESS;
}


NTSTATUS
SmbClassInitializeDevice (
    IN ULONG            MajorVersion,
    IN ULONG            MinorVersion,
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    This function is called by the SM bus miniport driver/DriverEntry
    to perform class specific initialization

Arguments:

    MajorVersion    - Version #
    MinorVersion    - Version #
    DriverObject    - From miniport DriverEntry

Return Value:

    Status

--*/
{

    if (MajorVersion != SMB_CLASS_MAJOR_VERSION) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverUnload                  = SmbCUnload;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = SmbCPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]     = SmbCPnpDispatch;

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SmbCInternalIoctl;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SmbCForwardRequest;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SmbCForwardRequest;

    //
    // Miniport will set up the AddDevice entry
    //

    return STATUS_SUCCESS;

}



VOID
SmbCUnload(
    IN PDRIVER_OBJECT   DriverObject
    )
{
    SmbPrint (SMB_NOTE, ("SmBCUnLoad: \n"));

    if (DriverObject->DeviceObject != NULL) {
        SmbPrint (SMB_ERROR, ("SmBCUnLoad: Unload called before all devices removed.\n"));
    }
}


NTSTATUS
SmbCPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for power requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PSMBDATA            SmbData;
    NTSTATUS            status;

    SmbData = DeviceObject->DeviceExtension;

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (SmbData->Class.LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( SmbData->Class.LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return status;
}


NTSTATUS
SmbCInternalIoctl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal IOCTLs.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PSMB_REQUEST        SmbReq;
    PSMBDATA                Smb;
    NTSTATUS            Status;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    Status = STATUS_NOT_SUPPORTED;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Smb = (PSMBDATA) DeviceObject->DeviceExtension;


    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case SMB_BUS_REQUEST:

            Irp->IoStatus.Information = 0;
            
            //
            // Verify bus request is valid
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SMB_REQUEST)) {

                // Invalid buffer length
                SmbPrint(SMB_NOTE, ("SmbCIoctl: Invalid bus_req length\n"));
                Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(SMB_REQUEST);
                break;
            }

            SmbReq = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if (SmbReq->Protocol > SMB_MAXIMUM_PROTOCOL ||
                SmbReq->Address  > 0x7F ||
                (SmbReq->Protocol == SMB_WRITE_BLOCK &&
                 SmbReq->BlockLength > SMB_MAX_DATA_SIZE)) {

                // Invalid param in request
                SmbPrint(SMB_NOTE, ("SmbCIoctl: Invalid bus_req\n"));
                break;
            }

            //
            // Mark request pending and queue it to the service queue
            //

            Status = STATUS_PENDING;
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending (Irp);

            SmbClassLockDevice (&Smb->Class);
            InsertTailList (&Smb->WorkQueue, &Irp->Tail.Overlay.ListEntry);

            //
            // Start IO if needed
            //

            SmbClassStartIo (Smb);
            SmbClassUnlockDevice (&Smb->Class);
            break;

        case SMB_REGISTER_ALARM_NOTIFY:

            //
            // Registry for alarm notifications
            //

            Irp->IoStatus.Information = 0;
            Status = SmbCRegisterAlarm (Smb, Irp);
            break;

        case SMB_DEREGISTER_ALARM_NOTIFY:

            //
            // Deregister for alarm notifications
            //

            Irp->IoStatus.Information = 0;
            Status = SmbCDeregisterAlarm (Smb, Irp);
            break;

        default:
            // Forard Irp or complete Irp without modifying it.
            return SmbCForwardRequest(DeviceObject, Irp);
    }


    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
SmbCForwardRequest(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine forwards the irp down the stack

Arguments:

    DeviceObject    - The target
    Irp             - The request

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    Status;
    PSMBDATA    Smb = (PSMBDATA) DeviceObject->DeviceExtension;

    if (Smb->Class.LowerDeviceObject != NULL) {

        IoSkipCurrentIrpStackLocation( Irp );
        Status = IoCallDriver( Smb->Class.LowerDeviceObject, Irp );

    } else {

        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbcpnp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcpnp.c

Abstract:

    SMBus Class Driver Plug and Play support

Author:

    Bob Moore (Intel)

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"
#include "oprghdlr.h"


#define SMBHC_DEVICE_NAME       L"\\Device\\SmbHc"
extern ULONG   SMBCDebug;

//
// Prototypes
//

NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
SmbCStartDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    );

NTSTATUS
SmbCStopDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    );

NTSTATUS
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbCPnpDispatch)
#pragma alloc_text(PAGE,SmbCStartDevice)
#pragma alloc_text(PAGE,SmbClassCreateFdo)
#endif


NTSTATUS
SmbCPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatcher for plug and play requests.

Arguments:

    DeviceObject    - Pointer to class device object.
    Irp             - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PSMBDATA            SmbData;
    KEVENT              syncEvent;
    NTSTATUS            status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    SmbData = (PSMBDATA) DeviceObject->DeviceExtension;

    SmbPrint (SMB_NOTE, ("SmbCPnpDispatch: PnP dispatch, minor = %d\n",
                        irpStack->MinorFunction));

    //
    // Dispatch minor function
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
            IoCopyCurrentIrpStackLocationToNext (Irp);

            KeInitializeEvent(&syncEvent, SynchronizationEvent, FALSE);

            IoSetCompletionRoutine(Irp, SmbCSynchronousRequest, &syncEvent, TRUE, TRUE, TRUE);

            status = IoCallDriver(SmbData->Class.LowerDeviceObject, Irp);

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&syncEvent, Executive, KernelMode, FALSE, NULL);
                status = Irp->IoStatus.Status;
            }
            
            status = SmbCStartDevice (DeviceObject, Irp);
            
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
            return status;


    case IRP_MN_STOP_DEVICE:
            status = SmbCStopDevice(DeviceObject, Irp);
            break;


    case IRP_MN_QUERY_STOP_DEVICE:

            SmbPrint(SMB_LOW, ("SmbCPnp: IRP_MN_QUERY_STOP_DEVICE\n"));

            status = STATUS_SUCCESS;
            break;


    case IRP_MN_CANCEL_STOP_DEVICE:

            SmbPrint(SMB_LOW, ("SmbCPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));

            status = STATUS_SUCCESS;
            break;


    default:
            SmbPrint(SMB_LOW, ("SmbCPnp: Unimplemented PNP minor code %d\n",
                    irpStack->MinorFunction));
    }

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver(SmbData->Class.LowerDeviceObject, Irp) ;

    } else {

        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    }

    return status;
}



NTSTATUS
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *OutFDO
    )
/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a SMBus Host controller PDO.  It is called from the miniport
    AddDevice routine.

Arguments:

    DriverObject            - a pointer to the driver object this is created under
    PDO                     - a pointer to the SMBus HC PDO
    MiniportExtensionSize   - Extension size required by the miniport
    MiniportInitialize      - a pointer to the miniport init routine
    MiniportContext         - Miniport-defined context info
    OutFDO                  - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    NTSTATUS            Status;
    PDEVICE_OBJECT      FDO;
    PDEVICE_OBJECT      lowerDevice = NULL;
    PSMBDATA                SmbData;

    //
    // Allocate a device object for this miniport
    //

    Status = IoCreateDevice(
                DriverObject,
                sizeof (SMBDATA) + MiniportExtensionSize,
                NULL,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &FDO
                );

    if (Status != STATUS_SUCCESS) {
        SmbPrint(SMB_LOW, ("SmbC: unable to create device object: %X\n", Status ));
        return(Status);
    }

    //
    // Initialize class data
    //

    FDO->Flags |= DO_BUFFERED_IO;

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(FDO,PDO);

    //
    // No status. Do the best we can.
    //
    if (!lowerDevice) {
        IoDeleteDevice (FDO);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Fill out class data
    //

    SmbData = (PSMBDATA) FDO->DeviceExtension;
    SmbData->Class.MajorVersion         = SMB_CLASS_MAJOR_VERSION;
    SmbData->Class.MinorVersion         = SMB_CLASS_MINOR_VERSION;
    SmbData->Class.Miniport             = SmbData + 1;
    SmbData->Class.DeviceObject         = FDO;
    SmbData->Class.LowerDeviceObject    = lowerDevice;
    SmbData->Class.PDO                  = PDO;
    SmbData->Class.CurrentIrp           = NULL;
    SmbData->Class.CurrentSmb           = NULL;

    KeInitializeEvent (&SmbData->AlarmEvent, NotificationEvent, FALSE);
    KeInitializeSpinLock (&SmbData->SpinLock);
    InitializeListHead (&SmbData->WorkQueue);
    InitializeListHead (&SmbData->Alarms);

    KeInitializeTimer (&SmbData->RetryTimer);
    KeInitializeDpc (&SmbData->RetryDpc, SmbCRetry, SmbData);

    //
    // Miniport initialization
    //

    Status = MiniportInitialize (&SmbData->Class, SmbData->Class.Miniport, MiniportContext);
    FDO->Flags |= DO_POWER_PAGABLE;
    FDO->Flags &= ~DO_DEVICE_INITIALIZING;

    if (!NT_SUCCESS(Status)) {
        IoDeleteDevice (FDO);
        return Status;
    }

    *OutFDO = FDO;
    return Status;
}


NTSTATUS
SmbCStartDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    )
{
    NTSTATUS            Status;
    PSMBDATA            SmbData;


    SmbPrint(SMB_LOW, ("SmbCStartDevice Entered with fdo %x\n", FDO));

    SmbData = (PSMBDATA) FDO->DeviceExtension;
    
    //
    // Initialize the Miniclass driver.
    //
    SmbData->Class.CurrentIrp = Irp;

    Status = SmbData->Class.ResetDevice (
                    &SmbData->Class,
                    SmbData->Class.Miniport
                    );

    SmbData->Class.CurrentIrp = NULL;
    
    if (!NT_SUCCESS(Status)) {

        SmbPrint(SMB_ERROR,
            ("SmbCStartDevice: Class.ResetDevice failed. = %Lx\n",
            Status));

        return Status;
    }
    
    //
    // Install the Operation Region handlers
    //

    Status = RegisterOpRegionHandler (SmbData->Class.LowerDeviceObject,
                                      ACPI_OPREGION_ACCESS_AS_RAW,
                                      ACPI_OPREGION_REGION_SPACE_SMB,
                                      (PACPI_OP_REGION_HANDLER)SmbCRawOpRegionHandler,
                                      SmbData,
                                      0,
                                      &SmbData->RawOperationRegionObject);
    if (!NT_SUCCESS(Status)) {

        SmbPrint(SMB_ERROR,
            ("SmbCStartDevice: Could not install raw Op region handler, status = %Lx\n",
            Status));
        
        //
        // Failure to register opregion handler is not critical.  It just reduces functionality
        //
        SmbData->RawOperationRegionObject = NULL;
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
SmbCStopDevice (
    IN PDEVICE_OBJECT   FDO,
    IN PIRP             Irp
    )
{
    NTSTATUS            Status;
    PSMBDATA                SmbData;


    SmbPrint(SMB_LOW, ("SmbCStopDevice Entered with fdo %x\n", FDO));


    SmbData = (PSMBDATA) FDO->DeviceExtension;

    //
    // Stop handling operation regions before turning off driver.
    //
    if (SmbData->RawOperationRegionObject) {
        DeRegisterOpRegionHandler (SmbData->Class.LowerDeviceObject,
                                   SmbData->RawOperationRegionObject);
    }

    //
    // Stop the device
    //

    SmbData->Class.CurrentIrp = Irp;
    
    Status = SmbData->Class.StopDevice (
                    &SmbData->Class,
                    SmbData->Class.Miniport
                    );

    SmbData->Class.CurrentIrp = NULL;

    return Status;
}



NTSTATUS
SmbCSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          IoCompletionEvent
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    No event.

--*/
{
    KeSetEvent(IoCompletionEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbhc\smbhc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbhc.c

Abstract:

    SMB Host Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbhcp.h"


ULONG           SMBHCDebug  = 0x0;


//
// Prototypes
//


typedef struct {
    ULONG               Base;
    ULONG               Query;
} NEW_HC_DEVICE, *PNEW_HC_DEVICE;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SmbHcAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SmbHcNewHc (
    IN PSMB_CLASS SmbClass,
    IN PVOID Extension,
    IN PVOID Context
    );

NTSTATUS
SmbHcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

NTSTATUS
SmbHcResetDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

NTSTATUS
SmbHcStopDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,SmbHcAddDevice)
#pragma alloc_text(PAGE,SmbHcResetDevice)
#pragma alloc_text(PAGE,SmbHcStopDevice)
#pragma alloc_text(PAGE,SmbHcNewHc)
#pragma alloc_text(PAGE,SmbHcSynchronousRequest)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the SM Bus Host Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.
    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS        Status;


    //
    // Have class driver allocate a new SMB miniport device
    //

    Status = SmbClassInitializeDevice (
                SMB_HC_MAJOR_VERSION,
                SMB_HC_MINOR_VERSION,
                DriverObject
                );

    //
    // AddDevice comes directly to this miniport
    //
    DriverObject->DriverExtension->AddDevice = SmbHcAddDevice;

    return (Status);
}

NTSTATUS
SmbHcAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each SmbHc controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo = NULL;


    PAGED_CODE();

    SmbPrint(SMB_LOW, ("SmbHcAddDevice Entered with pdo %x\n", Pdo));


    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        SmbPrint(SMB_LOW, ("SmbHcAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Create and initialize the new functional device object
    //

    status = SmbClassCreateFdo(
                DriverObject,
                Pdo,
                sizeof (SMB_DATA),
                SmbHcNewHc,
                NULL,
                &fdo
                );

    if (!NT_SUCCESS(status) || fdo == NULL) {
        SmbPrint(SMB_LOW, ("SmbHcAddDevice - error creating Fdo. Status = %08x\n", status));
    }

    return status;
}



NTSTATUS
SmbHcNewHc (
    IN PSMB_CLASS SmbClass,
    IN PVOID Extension,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called by the smb bus class driver for the
    miniport to perform miniport specific initialization

Arguments:

    SmbClass    - Shared class driver & miniport structure.
    Extension   - Buffer for miniport specific storage
    Context     - Passed through class driver

Return Value:

    Status

--*/

{
    ACPI_EVAL_INPUT_BUFFER  inputBuffer;
    ACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    IO_STATUS_BLOCK         ioStatusBlock;
    KEVENT                  event;
    NTSTATUS                status;
    PACPI_METHOD_ARGUMENT   argument;
    PIRP                    irp;
    PSMB_DATA               smbData;
    ULONG                   cmReturn;


    PAGED_CODE();

    SmbPrint(SMB_LOW, ("SmbHcNewHc: Entry\n") );

    smbData = (PSMB_DATA) Extension;

    //
    // Fill in SmbClass info
    //

    SmbClass->StartIo     = SmbHcStartIo;
    SmbClass->ResetDevice = SmbHcResetDevice;
    SmbClass->StopDevice  = SmbHcStopDevice;

    //
    // Lower device is the EC driver, but we will use the ACPI PDO, since
    // the ACPI filter driver will pass it thru.
    //

    smbData->Pdo = SmbClass->PDO;
    smbData->LowerDeviceObject = SmbClass->LowerDeviceObject;     // ACPI filter will handle it

    //
    // Initialize the input parameters
    //
    RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
    inputBuffer.MethodNameAsUlong = CM_EC_METHOD;
    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the synchronouxe request
    //
    irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_ASYNC_EVAL_METHOD,
        SmbClass->LowerDeviceObject,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        &outputBuffer,
        sizeof(ACPI_EVAL_OUTPUT_BUFFER),
        FALSE,
        &event,
        &ioStatusBlock
        );
    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcNewHc: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send to ACPI driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    argument = outputBuffer.Argument;
    if (!NT_SUCCESS(status) ||
        outputBuffer.Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE ||
        outputBuffer.Count == 0 ||
        argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        SmbPrint(SMB_LOW, ("SmbHcNewHc: _EC Control Method failed, status = %Lx\n", status));
        return status;

    }

    //
    // Remember the result
    //
    cmReturn = argument->Argument;

    //
    // Fill in miniport info
    //
    smbData->Class      = SmbClass;
    smbData->IoState    = SMB_IO_IDLE;
    smbData->EcQuery    = (UCHAR) cmReturn;        // Per ACPI Spec, LSB=Query
    smbData->EcBase     = (UCHAR) (cmReturn >> 8); // Per ACPI Spec, MSB=Base


    SmbPrint(SMB_LOW, ("SmbHcNewHc: Exit\n"));
    return status;
}


NTSTATUS
SmbHcSynchronousRequest (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    Context is the event to set

--*/
{
    PAGED_CODE();
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SmbHcResetDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    )
{
    EC_HANDLER_REQUEST      queryConnect;
    PSMB_DATA               smbData;
    KEVENT                  event;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    PIRP                    irp;

    SmbPrint(SMB_LOW, ("SmbHcResetDevice: Entry\n") );

    PAGED_CODE();

    smbData = (PSMB_DATA) SmbMiniport;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the input data to the EC
    //
    queryConnect.Vector  = smbData->EcQuery;
    queryConnect.Handler = SmbHcQueryEvent;
    queryConnect.Context = smbData;

    //
    // Connect Query notify with EC driver
    //
    irp = IoBuildDeviceIoControlRequest(
        EC_CONNECT_QUERY_HANDLER,
        smbData->LowerDeviceObject,
        &queryConnect,
        sizeof(EC_HANDLER_REQUEST),
        NULL,
        0,
        TRUE,
        &event,
        &ioStatusBlock
        );

    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcResetDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send off to EC driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_LOW, ("SmbHcResetDevice: Connect query failed, status = %Lx\n", status));

    }

    SmbPrint(SMB_LOW, ("SmbHcResetDevice: Exit\n"));
    return status;
}


NTSTATUS
SmbHcStopDevice (
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    )
{
    EC_HANDLER_REQUEST      queryConnect;
    PSMB_DATA               smbData;
    KEVENT                  event;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    PIRP                    irp;

    SmbPrint(SMB_LOW, ("SmbHcStopDevice: Entry\n") );

    //
    // There is currently no way to test this code path.
    // Leaving untested code for potential future use/development
    //

    DbgPrint("SmbHcStopDevice: Encountered previously untested code.\n"
             "enter 'g' to continue, or contact the appropriate developer.\n");
    DbgBreakPoint();

    // Cutting code to reduce file size (see above comment)
#if 0
    PAGED_CODE();

    smbData = (PSMB_DATA) SmbMiniport;

    //
    // Initialize the even to wait on
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE);

    //
    // Build the input data to the EC
    //
    queryConnect.Vector  = smbData->EcQuery;
    queryConnect.Handler = SmbHcQueryEvent;
    queryConnect.Context = smbData;

    //
    // Connect Query notify with EC driver
    //
    irp = IoBuildDeviceIoControlRequest(
        EC_DISCONNECT_QUERY_HANDLER,
        smbData->LowerDeviceObject,
        &queryConnect,
        sizeof(EC_HANDLER_REQUEST),
        NULL,
        0,
        TRUE,
        &event,
        &ioStatusBlock
        );

    if (!irp) {

        SmbPrint(SMB_ERROR, ("SmbHcStopDevice: Couldn't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Send off to EC driver
    //
    status = IoCallDriver (smbData->LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;

    }

    if (!NT_SUCCESS(status)) {

        SmbPrint(SMB_LOW, ("SmbHcStopDevice: Connect query failed, status = %Lx\n", status));

    }

    SmbPrint(SMB_LOW, ("SmbHcStopDevice: Exit\n"));
    return status;
#endif
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbcalrm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcsrv.c

Abstract:

    SMBus class driver service functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"

VOID
SmbCCheckAlarmDelete (
    IN PSMBDATA         Smb,
    IN PSMB_ALARM   SmbAlarm
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SmbCCheckAlarmDelete)
#pragma alloc_text(PAGE,SmbCRegisterAlarm)
#pragma alloc_text(PAGE,SmbCDeregisterAlarm)
#endif

UCHAR gHexDigits [] = "0123456789ABCDEF";


NTSTATUS
SmbCRunAlarmMethodCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    SmbPrint(SMB_ALARMS, ("SmbCRunAlarmMethodCompletionRoutine: Done running Control Method.  Status=0x%08x\n", Irp->IoStatus.Status));
    
    ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SmbCRunAlarmMethod (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    )
/*++

Routine Description:

    Run _Rxx for the alarm

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    SmbPrint(SMB_ALARMS, ("SmbCRunAlarmMethod: Running Control method _R%02x\n", Address));
    
    inputBuffer = ExAllocatePoolWithTag (
        NonPagedPool,
        sizeof (ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
        'AbmS'
        );
    if (!inputBuffer) {
        return;
    }

    RtlZeroMemory( inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER) );
    inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer->MethodNameAsUlong = '00Q_';
    inputBuffer->MethodName[2] = gHexDigits[ Address / 16];
    inputBuffer->MethodName[3] = gHexDigits[ Address % 16];
    inputBuffer->IntegerArgument = Data;

    irp = IoAllocateIrp (SmbClass->LowerDeviceObject->StackSize, FALSE);
    if (!irp) {
        ExFreePool (inputBuffer);
        return;
    }
    
    irp->AssociatedIrp.SystemBuffer = inputBuffer;

    ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
    irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER);
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

    irp->UserBuffer = NULL;

    IoSetCompletionRoutine(
        irp,
        SmbCRunAlarmMethodCompletionRoutine,
        NULL, // No Context  This just frees the IRP
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(SmbClass->LowerDeviceObject, irp);

}


VOID
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    )
/*++

Routine Description:

    Miniport has an alarm input

--*/
{
    PSMBDATA            Smb;
    PSMB_ALARM      SmbAlarm;
    PLIST_ENTRY     Entry, NextEntry;
    BOOLEAN         AlarmRegistered = FALSE;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    ASSERT_DEVICE_LOCKED (Smb);

    Entry = Smb->Alarms.Flink;
    while (Entry != &Smb->Alarms) {
        SmbAlarm = CONTAINING_RECORD (Entry, SMB_ALARM, Link);

        //
        // If notification is for this address, issue it
        //

        if (Address >= SmbAlarm->MinAddress && Address <= SmbAlarm->MaxAddress) {

            //
            // A driver has registered for this notification.  Don't call the BIOS.
            //
            AlarmRegistered = TRUE;

            //
            // Raise reference count before calling notifcation function
            //

            SmbAlarm->Reference += 1;
            ASSERT (SmbAlarm->Reference != 0);
            SmbClassUnlockDevice (SmbClass);

            //
            // Issue notification
            //

            SmbAlarm->NotifyFunction (SmbAlarm->NotifyContext, Address, Data);

            //
            // Continue
            //

            SmbClassLockDevice (SmbClass);
            SmbAlarm->Reference -= 1;
        }

        //
        // Get next entry
        //

        NextEntry = Entry->Flink;

        //
        // If entry is pending delete, hand it to deleting thread
        //

        if (SmbAlarm->Flag & SMBC_ALARM_DELETE_PENDING) {
            SmbCCheckAlarmDelete (Smb, SmbAlarm);

        }

        //
        // Move on
        //

        Entry = NextEntry;
    }

    //
    // If no one registered for this alarm, call the _Rxx control method
    //
    if (!AlarmRegistered) {
        
        SmbCRunAlarmMethod (SmbClass, Address, Data);

    }
}

VOID
SmbCCheckAlarmDelete (
    IN PSMBDATA         Smb,
    IN PSMB_ALARM   SmbAlarm
    )
{
    //
    // If alarm structure is referenced, wait somemore
    //

    if (SmbAlarm->Reference) {
        return ;
    }


    //
    // Time to free it.  Remove it from the notification list, clear
    // the pending flag and set the event to let waiting threads know
    // that some entry was removed
    //

    RemoveEntryList (&SmbAlarm->Link);
    SmbAlarm->Flag &= ~SMBC_ALARM_DELETE_PENDING;
    KeSetEvent (&Smb->AlarmEvent, 0, FALSE);
}

NTSTATUS
SmbCRegisterAlarm (
    PSMBDATA        Smb,
    PIRP        Irp
    )
/*++

Routine Description:

    Called to register for an alarm event

--*/
{
    PVOID               LockPtr;
    PSMB_ALARM          SmbAlarm, *Result;
    PSMB_REGISTER_ALARM RegAlarm;
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (ExGetPreviousMode() != KernelMode ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SMB_REGISTER_ALARM) ||
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PSMB_ALARM) ) {

        return STATUS_INVALID_PARAMETER;
    }

    RegAlarm = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    SmbAlarm = ExAllocatePoolWithTag (
                    NonPagedPool,
                    sizeof (SMB_ALARM),
                    'AbmS'
                    );

    if (!SmbAlarm) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SmbAlarm->Flag = 0;
    SmbAlarm->Reference = 0;
    SmbAlarm->MinAddress     = RegAlarm->MinAddress;
    SmbAlarm->MaxAddress     = RegAlarm->MaxAddress;
    SmbAlarm->NotifyFunction = RegAlarm->NotifyFunction;
    SmbAlarm->NotifyContext  = RegAlarm->NotifyContext;


    //
    // Add it to the alarm notification list
    //

    LockPtr = MmLockPagableCodeSection(SmbCRegisterAlarm);
    SmbClassLockDevice (&Smb->Class);
    InsertTailList (&Smb->Alarms, &SmbAlarm->Link);
    SmbClassUnlockDevice (&Smb->Class);
    MmUnlockPagableImageSection(LockPtr);

    //
    // Return value caller needs to deregister with
    //

    Result  = (PSMB_ALARM *) Irp->UserBuffer;
    *Result = SmbAlarm;
    Irp->IoStatus.Information = sizeof(PSMB_ALARM);

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCDeregisterAlarm (
    PSMBDATA        Smb,
    PIRP        Irp
    )
/*++

Routine Description:

    Called to register for an alarm event

--*/
{
    PVOID               LockPtr;
    PSMB_ALARM          SmbAlarm;
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (ExGetPreviousMode() != KernelMode ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PSMB_ALARM) ) {
        return STATUS_INVALID_PARAMETER;
    }

    SmbAlarm = * (PSMB_ALARM *) IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    LockPtr = MmLockPagableCodeSection(SmbCDeregisterAlarm);
    SmbClassLockDevice (&Smb->Class);

    //
    // Flag alarm structure as delete pending
    //


    SmbAlarm->Flag |= SMBC_ALARM_DELETE_PENDING;

    //
    // While delete is pending wait
    //

    while (SmbAlarm->Flag & SMBC_ALARM_DELETE_PENDING) {

        //
        // Issue bogus alarm to generate freeing
        //

        KeResetEvent (&Smb->AlarmEvent);
        SmbClassAlarm (&Smb->Class, 0xFF, 0);

        //
        // Wait for alarm structure to get freed, then check if it
        // was ours
        //

        SmbClassUnlockDevice (&Smb->Class);
        KeWaitForSingleObject (
            &Smb->AlarmEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        SmbClassLockDevice (&Smb->Class);
    }

    //
    // It's been removed, free the memory
    //

    SmbClassUnlockDevice (&Smb->Class);
    MmUnlockPagableImageSection(LockPtr);

    ExFreePool (SmbAlarm);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbcsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcsrv.c

Abstract:

    SMBus class driver service functions

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"


VOID
SmbCRetry (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    Handles retry timer

--*/
{
    PSMBDATA    Smb;

    Smb = (PSMBDATA) DeferredContext;
    SmbClassLockDevice (&Smb->Class);

    //
    // State is waiting for retry, move it to send request
    //
    ASSERT (Smb->IoState == SMBC_WAITING_FOR_RETRY);
    Smb->IoState = SMBC_START_REQUEST;
    SmbClassStartIo (Smb);

    SmbClassUnlockDevice (&Smb->Class);
}

VOID
SmbClassStartIo (
    IN PSMBDATA         Smb
    )
/*++

Routine Description:

    Main class driver state loop

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PLIST_ENTRY         Entry;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    PSMB_REQUEST        SmbReq;
    LARGE_INTEGER       duetime;

    //
    // If already servicing the device, done
    //

    if (Smb->InService) {
        return ;
    }


    //
    // Service the device
    //

    Smb->InService = TRUE;
    while (Smb->InService) {
        ASSERT_DEVICE_LOCKED (Smb);

        switch (Smb->IoState) {
            case SMBC_IDLE:
                //
                // Check if there is a request to give to the miniport
                //

                ASSERT (!Smb->Class.CurrentIrp);
                if (IsListEmpty(&Smb->WorkQueue)) {
                    // nothing to do, stop servicing the device
                    Smb->InService = FALSE;
                    break;
                }

                //
                // Get the next IRP
                //

                Entry = RemoveHeadList(&Smb->WorkQueue);
                Irp = CONTAINING_RECORD (
                            Entry,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

                //
                // Make it the current request
                //

                Smb->RetryCount = 0;
                Smb->Class.DeviceObject->CurrentIrp = Irp;

                Smb->IoState = SMBC_START_REQUEST;
                break;

            case SMBC_START_REQUEST:
                //
                // Tell miniport to start on this request
                //

                Irp = Smb->Class.DeviceObject->CurrentIrp;
                IrpSp = IoGetCurrentIrpStackLocation(Irp);
                Smb->Class.CurrentIrp = Irp;
                Smb->Class.CurrentSmb = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                Smb->IoState = SMBC_WAITING_FOR_REQUEST;
                
                #if DEBUG 
                if (SMBCDebug & SMB_TRANSACTION) {
                    PUCHAR protocols [SMB_MAXIMUM_PROTOCOL+1] = {
                        "SMB_WRITE_QUICK",
                        "SMB_READ_QUICK",
                        "SMB_SEND_BYTE",
                        "SMB_RECEIVE_BYTE",
                        "SMB_WRITE_BYTE",
                        "SMB_READ_BYTE",
                        "SMB_WRITE_WORD",
                        "SMB_READ_WORD",
                        "SMB_WRITE_BLOCK",
                        "SMB_READ_BLOCK",
                        "SMB_PROCESS_CALL",
                        "SMB_BLOCK_PROCESS_CALL"};
                    UCHAR i;
                    
                    SmbPrint (SMB_TRANSACTION, ("SmbClassStartIo: started %s (%02x) Add: %02x", 
                                                (Smb->Class.CurrentSmb->Protocol <= SMB_MAXIMUM_PROTOCOL) ?
                                                    protocols[Smb->Class.CurrentSmb->Protocol] : "BAD PROTOCOL",
                                                Smb->Class.CurrentSmb->Protocol, Smb->Class.CurrentSmb->Address));
                    switch (Smb->Class.CurrentSmb->Protocol) {
                    case SMB_WRITE_QUICK:
                    case SMB_READ_QUICK:
                    case SMB_RECEIVE_BYTE:
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                        break;
                    case SMB_SEND_BYTE:
                        SmbPrint (SMB_TRANSACTION, (", Data: %02x\n", Smb->Class.CurrentSmb->Data[0]));
                        break;
                    case SMB_WRITE_BYTE:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %02x\n", 
                                                    Smb->Class.CurrentSmb->Command, Smb->Class.CurrentSmb->Data[0]));
                        break;
                    case SMB_READ_BYTE:
                    case SMB_READ_WORD:
                    case SMB_READ_BLOCK:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x\n",
                                                    Smb->Class.CurrentSmb->Command));
                        break;
                    case SMB_WRITE_WORD:
                    case SMB_PROCESS_CALL:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %04x\n", 
                                                    Smb->Class.CurrentSmb->Command, *((PUSHORT)Smb->Class.CurrentSmb->Data)));
                        break;
                    case SMB_WRITE_BLOCK:
                    case SMB_BLOCK_PROCESS_CALL:
                        SmbPrint (SMB_TRANSACTION, (", Com: %02x, Len: %02x, Data:", 
                                                    Smb->Class.CurrentSmb->Command, Smb->Class.CurrentSmb->BlockLength));
                        for (i=0; i < Smb->Class.CurrentSmb->BlockLength; i++) {
                            SmbPrint (SMB_TRANSACTION, (" %02x", Smb->Class.CurrentSmb->Data[i]));

                        }
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                        break;
                    default:
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                    }
                }
                #endif

                Smb->Class.StartIo (&Smb->Class, Smb->Class.Miniport);
                break;

            case SMBC_WAITING_FOR_REQUEST:
                //
                // Waiting for miniport, just keep waiting
                //

                Smb->InService = FALSE;
                break;

            case SMBC_COMPLETE_REQUEST:
                //
                // Miniport has returned the request
                //

                Irp = Smb->Class.DeviceObject->CurrentIrp;
                IrpSp = IoGetCurrentIrpStackLocation(Irp);
                SmbReq = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                #if DEBUG 
                if (SMBCDebug & SMB_TRANSACTION) {
                    PUCHAR protocols [SMB_MAXIMUM_PROTOCOL+1] = {
                        "SMB_WRITE_QUICK",
                        "SMB_READ_QUICK",
                        "SMB_SEND_BYTE",
                        "SMB_RECEIVE_BYTE",
                        "SMB_WRITE_BYTE",
                        "SMB_READ_BYTE",
                        "SMB_WRITE_WORD",
                        "SMB_READ_WORD",
                        "SMB_WRITE_BLOCK",
                        "SMB_READ_BLOCK",
                        "SMB_PROCESS_CALL",
                        "SMB_BLOCK_PROCESS_CALL"};
                    UCHAR i;
                    
                    SmbPrint (SMB_TRANSACTION, ("SmbClassStartIo: finished %s (%02x) Status: %02x, Add: %02x", 
                                                (SmbReq->Protocol <= SMB_MAXIMUM_PROTOCOL) ?
                                                    protocols[SmbReq->Protocol] : "BAD PROTOCOL",
                                                SmbReq->Protocol, SmbReq->Status, SmbReq->Address));
                    if (SmbReq->Status != SMB_STATUS_OK) {
                        SmbPrint (SMB_TRANSACTION, ("\n"));
                    } else {
                        switch (SmbReq->Protocol) {
                        case SMB_WRITE_QUICK:
                        case SMB_READ_QUICK:
                        case SMB_SEND_BYTE:
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                            break;
                        case SMB_RECEIVE_BYTE:
                            SmbPrint (SMB_TRANSACTION, (", Data: %02x\n", SmbReq->Data[0]));
                            break;
                        case SMB_READ_BYTE:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %02x\n", 
                                                        SmbReq->Command, SmbReq->Data[0]));
                            break;
                        case SMB_WRITE_BYTE:
                        case SMB_WRITE_WORD:
                        case SMB_WRITE_BLOCK:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x\n",
                                                        SmbReq->Command));
                            break;
                        case SMB_READ_WORD:
                        case SMB_PROCESS_CALL:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Data: %04x\n", 
                                                        SmbReq->Command, *((PUSHORT)SmbReq->Data)));
                            break;
                        case SMB_READ_BLOCK:
                        case SMB_BLOCK_PROCESS_CALL:
                            SmbPrint (SMB_TRANSACTION, (", Com: %02x, Len: %02x, Data:", 
                                                        SmbReq->Command, SmbReq->BlockLength));
                            for (i=0; i < SmbReq->BlockLength; i++) {
                                SmbPrint (SMB_TRANSACTION, (" %02x", SmbReq->Data[i]));

                            }
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                            break;
                        default:
                            SmbPrint (SMB_TRANSACTION, ("\n"));
                        }
                    }
                }
                #endif


                if (SmbReq->Status != SMB_STATUS_OK) {

                    //
                    // SMB request had an error, check for a retry
                    //

                    SmbPrint (SMB_WARN, ("SmbCStartIo: smb request error %x\n", SmbReq->Status));
                    if (Smb->RetryCount < MAX_RETRIES) {
                        Smb->RetryCount += 1;
                        Smb->IoState = SMBC_WAITING_FOR_RETRY;

                        duetime.QuadPart = RETRY_TIME;
                        KeSetTimer (&Smb->RetryTimer, duetime, &Smb->RetryDpc);
                        break;
                    }

                }

                //
                // Complete the request
                //

                Smb->Class.DeviceObject->CurrentIrp = NULL;
                Smb->IoState = SMBC_COMPLETING_REQUEST;
                SmbClassUnlockDevice (&Smb->Class);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                SmbClassLockDevice (&Smb->Class);

                //
                // Now idle
                //

                Smb->IoState = SMBC_IDLE;
                break;

            case SMBC_WAITING_FOR_RETRY:
                //
                // Waiting to retry, just keep waiting
                //

                Smb->InService = FALSE;
                break;

            default:
                SmbPrint(SMB_ERROR, ("SmbCStartIo: unknown state\n"));
                Smb->IoState = SMBC_IDLE;
                Smb->InService = FALSE;
                break;
        }
    }

    return ;
}

VOID
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called by the miniport to complete the request it was given

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PSMBDATA        Smb;

    //
    // Device must be locked, and waiting for a request to compelte
    //

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    ASSERT_DEVICE_LOCKED (Smb);
    ASSERT (Smb->IoState == SMBC_WAITING_FOR_REQUEST);

    //
    // No irp at miniport
    //

    SmbClass->CurrentIrp = NULL;
    SmbClass->CurrentSmb = NULL;

    //
    // Update state to complete it and handle it
    //

    Smb->IoState = SMBC_COMPLETE_REQUEST;
    SmbClassStartIo (Smb);
}

VOID
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called to acquire the device lock

--*/
{
    PSMBDATA        Smb;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
    KeAcquireSpinLock (&Smb->SpinLock, &Smb->SpinLockIrql);
#if DEBUG
    ASSERT (!Smb->SpinLockAcquired);
    Smb->SpinLockAcquired = TRUE;
#endif
}


VOID
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    )
/*++

Routine Description:

    Called to release the device lock

--*/
{
    PSMBDATA        Smb;

    Smb = CONTAINING_RECORD (SmbClass, SMBDATA, Class);
#if DEBUG
    ASSERT_DEVICE_LOCKED (Smb);
    Smb->SpinLockAcquired = FALSE;
#endif
    KeReleaseSpinLock (&Smb->SpinLock, Smb->SpinLockIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbclass\smbcoprg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbcpnp.c

Abstract:

    SMBus Class Driver Plug and Play support

Author:

    Michael Hills

Environment:

Notes:


Revision History:

--*/

#include "smbc.h"


NTSTATUS
SmbCRawOpRegionCompletion (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    This routine starts or continues servicing the device's work queue

Arguments:

    DeviceObject    - EC device object
    Irp             - Completing Irp
    Context         - Note used

Return Value:

    Status

--*/
{
    PACPI_OPREGION_CALLBACK completionHandler;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID                   completionContext;
    PFIELDUNITOBJ           FieldUnit;
    POBJDATA                Data;
    PBUFFERACC_BUFFER       dataBuffer;
    PSMB_REQUEST            request;
    ULONG                   i;

    //
    // Grab the arguments from the irp
    //
    completionHandler = (PACPI_OPREGION_CALLBACK) irpSp->Parameters.Others.Argument1;
    completionContext = (PVOID) irpSp->Parameters.Others.Argument2;
    FieldUnit = (PFIELDUNITOBJ) irpSp->Parameters.Others.Argument3;
    Data = (POBJDATA) irpSp->Parameters.Others.Argument4;

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionCompletion: Callback: %08lx Context: %08lx "
         "Status: %08lx\n",
         completionHandler, completionContext, Irp->IoStatus.Status )
        );

    //
    // Copy the results into the buffer for a read.
    //

    request = (PSMB_REQUEST) Data->uipDataValue;
    Data->uipDataValue = 0;
    dataBuffer = (PBUFFERACC_BUFFER) Data->pbDataBuff;

    
    dataBuffer->Status = request->Status;
    switch (request->Protocol) {
    case SMB_RECEIVE_BYTE:
    case SMB_READ_BYTE:
    case SMB_READ_WORD:
    case SMB_READ_BLOCK:
    case SMB_PROCESS_CALL:
    case SMB_BLOCK_PROCESS_CALL:

        //
        // There is data to return
        //

        if (request->Status != SMB_STATUS_OK) {
            SmbPrint(SMB_ERROR, ("SmbCRawOpRegionCompletion: SMBus error %x\n", request->Status));
            dataBuffer->Length = 0xff;
            RtlFillMemory (dataBuffer->Data, 32, 0xff);
        } else {
            if ((request->Protocol == SMB_READ_BLOCK) || (request->Protocol == SMB_BLOCK_PROCESS_CALL)) {

                RtlCopyMemory (dataBuffer->Data, request->Data, request->BlockLength); 
                dataBuffer->Length = request->BlockLength;
            } else {
                *(PULONG)dataBuffer->Data = *((PULONG)(request->Data));
                dataBuffer->Length = 0xff;
                // This field is reseved for all but block accesses
            }
        }
    }

    //
    // Invoke the AML interpreter's callback
    //
    (completionHandler)( completionContext);

    //
    // We are done with this irp
    //

    ExFreePool (request);

    IoFreeIrp (Irp);

    //
    // Return this always --- we had to free the irp ourselves
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS EXPORT
SmbCRawOpRegionHandler (
    ULONG                   AccessType,
    PFIELDUNITOBJ           FieldUnit,
    POBJDATA                Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

    This routine handles requests to service the EC operation region

Arguments:

    AccessType          - Read or Write data
    FieldUnit           - Opregion field info (address, command, protocol, etc.)
    Data                - Data Buffer
    Context             - SMBDATA
    CompletionHandler   - AMLI handler to call when operation is complete
    CompletionContext   - Context to pass to the AMLI handler

Return Value:

    Status

Notes:

    Could this be optimized by bypassing some of the IO subsystem?

--*/
{
    NTSTATUS            status;
    PIRP                irp = NULL;
    PIO_STACK_LOCATION  irpSp;
    PSMBDATA            smbData = (PSMBDATA) Context;
    PSMB_REQUEST        request = NULL;

    PNSOBJ              opRegion;
    PBUFFERACC_BUFFER   dataBuffer;

    ULONG               accType = FieldUnit->FieldDesc.dwFieldFlags & ACCTYPE_MASK;
    ULONG               i;

//    DbgBreakPoint ();

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionHandler: Entered - NSObj(%08x) ByteOfs(%08x) Start(%08x)"
         " Num(%08x) Flags(%08x)\n",
         FieldUnit->pnsFieldParent,
         FieldUnit->FieldDesc.dwByteOffset,
         FieldUnit->FieldDesc.dwStartBitPos,
         FieldUnit->FieldDesc.dwNumBits,
         FieldUnit->FieldDesc.dwFieldFlags)
        );

    //
    // Parameter validation
    //

    if (accType != ACCTYPE_BUFFER) {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid Access type = 0x%08x should be ACCTYPE_BUFFER\n", accType) );
        goto SmbCOpRegionHandlerError;
    }
    
    if (AccessType == ACPI_OPREGION_WRITE) {
        if (Data->dwDataType != OBJTYPE_BUFFDATA) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataType = 0x%08x should be OBJTYPE_BUFFDATA\n", Data->dwDataType) );
            goto SmbCOpRegionHandlerError;
        }
        if (Data->dwDataLen != sizeof(BUFFERACC_BUFFER)) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataLen = 0x%08x should be 0x%08x\n", Data->dwDataLen, sizeof(BUFFERACC_BUFFER)) );
            goto SmbCOpRegionHandlerError;
        }
    } else if (AccessType == ACPI_OPREGION_READ) {
        if ((Data->dwDataType != OBJTYPE_BUFFDATA) || (Data->pbDataBuff == NULL)) {
            Data->dwDataType = OBJTYPE_INTDATA;
            Data->dwDataValue = sizeof(BUFFERACC_BUFFER);

            return STATUS_BUFFER_TOO_SMALL;
        }
        if (Data->dwDataLen != sizeof(BUFFERACC_BUFFER)) {
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid dwDataLen = 0x%08x should be 0x%08x\n", Data->dwDataLen, sizeof(BUFFERACC_BUFFER)) );
            goto SmbCOpRegionHandlerError;
        }
    } else {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid AccessType = 0x%08x\n", AccessType) );
        goto SmbCOpRegionHandlerError;
    }
    

    //
    // Allocate an IRP for below. Allocate one extra stack location to store
    // some data in.
    //

    irp = IoAllocateIrp((CCHAR)(smbData->Class.DeviceObject->StackSize + 1),
                        FALSE
                        );

    request = ExAllocatePoolWithTag (NonPagedPool, sizeof (SMB_REQUEST), 'CbmS');

    if (!irp || !request) {
        SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Cannot allocate irp\n") );

        goto SmbCOpRegionHandlerError;
    }

    //
    // Fill in the top location so that we can use it ourselves
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.Others.Argument1 = (PVOID) CompletionHandler;
    irpSp->Parameters.Others.Argument2 = (PVOID) CompletionContext;
    irpSp->Parameters.Others.Argument3 = (PVOID) FieldUnit;
    irpSp->Parameters.Others.Argument4 = (PVOID) Data;
    IoSetNextIrpStackLocation( irp );

    //
    // Fill out the irp with the request info
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = SMB_BUS_REQUEST;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(SMB_REQUEST);
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = request;

    request->Status = 0;

    //
    // Translate between Opregion Protocols and smbus protocols
    // and fill copy data.
    //

    
    //
    // Copy data into data buffer for writes.
    //
    dataBuffer = (PBUFFERACC_BUFFER)Data->pbDataBuff;
    
    if (AccessType == ACPI_OPREGION_WRITE) {
        switch ((FieldUnit->FieldDesc.dwFieldFlags & FDF_ACCATTRIB_MASK) >> 8) {
        case SMB_QUICK:
            break;
        case SMB_SEND_RECEIVE:
        case SMB_BYTE:
            *((PUCHAR) (request->Data)) = *((PUCHAR) (dataBuffer->Data));

            break;
        case SMB_WORD:
        case SMB_PROCESS:
            *((PUSHORT) (request->Data)) = *((PUSHORT) (dataBuffer->Data));
            break;
        case SMB_BLOCK:
        case SMB_BLOCK_PROCESS:
            dataBuffer = (PBUFFERACC_BUFFER)Data->pbDataBuff;
            for (i = 0; i < dataBuffer->Length; i++) {
                request->Data[i] = dataBuffer->Data[i];
            }

            request->BlockLength = (UCHAR) dataBuffer->Length;
            break;
        default:
            SmbPrint( SMB_ERROR, ("SmbCRawOpRegionHandler: Invalid AccessAs: FieldFlags = 0x%08x\n", FieldUnit->FieldDesc.dwFieldFlags) );
            goto SmbCOpRegionHandlerError;
        }
    }

    //
    // Determine protocol
    //

    request->Protocol = (UCHAR) ((FieldUnit->FieldDesc.dwFieldFlags & FDF_ACCATTRIB_MASK) >> 8);
    if ((request->Protocol < SMB_QUICK) || (request->Protocol > SMB_BLOCK_PROCESS)) {
        SmbPrint (SMB_ERROR, ("SmbCRawOpRegionHandler: BIOS BUG Unknown Protocol (access attribute) 0x%02x.\n", request->Protocol));
        ASSERTMSG ("SmbCRawOpRegionHandler:  Access type DWordAcc is not suported for SMB opregions.\n", FALSE);
        goto SmbCOpRegionHandlerError;
    } 
    if (request->Protocol <= SMB_BLOCK) {
        request->Protocol -= (AccessType == ACPI_OPREGION_READ) ? 1 : 2;
    } else {
        request->Protocol -= 2;
    }
    SmbPrint(SMB_HANDLER, 
             ("SmbCRawOpRegionHandler: request->Protocol = %08x\n", request->Protocol)); 



    //
    // Find the Slave address nd Command value (not used for all protocols)
    //
    request->Address = (UCHAR) ((FieldUnit->FieldDesc.dwByteOffset >> 8) & 0xff);
    request->Command = (UCHAR) (FieldUnit->FieldDesc.dwByteOffset & 0xff);


    //
    // Pass Pointer to request in the data structure because
    // there is not enough space in the irp stack.
    // If this is a write, the data has already been copied out.
    // If this is a read, we will read the value of request before 
    // copying the result data.
    //
    Data->uipDataValue = (ULONG_PTR) request;

    //
    // Set a completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SmbCRawOpRegionCompletion,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Send to the front-end of the SMB driver as a normal I/O request
    //
    status = IoCallDriver (smbData->Class.DeviceObject, irp);

    if (!NT_SUCCESS(status)) {
        SmbPrint (SMB_ERROR, ("SmbCRawOpRegionHandler: Irp failed with status %08x\n", status));
        goto SmbCOpRegionHandlerError;
    }

    SmbPrint(
        SMB_HANDLER,
        ("SmbCRawOpRegionHandler: Exiting - Data=%x Status=%x\n",
         Data->uipDataValue, status)
        );


    return status;

SmbCOpRegionHandlerError:
    if (irp) {
        IoFreeIrp (irp);
    }
    if (request) {
        ExFreePool (request);
    }

    Data->uipDataValue = 0xffffffff;
    Data->dwDataLen = 0;
    CompletionHandler( CompletionContext );

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiload\makefile.inc ===
$(O)\acpiload.res: acpiload.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\driver\acpisim.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "oprghdlr.h"
#include "acpiioct.h"

//
// Specific includes
//

#include "asimlib.h"
#include "acpisim.h"

//
// Globals
//

PVOID   g_OpRegionSharedMemory = 0;
PVOID   g_OperationRegionObject = 0;

//
// Private function prototypes
//

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

//
// Code
//

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to register our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    g_OpRegionSharedMemory = ExAllocatePoolWithTag (NonPagedPool,
                                                    OPREGION_SIZE,
                                                    ACPISIM_POOL_TAG);

    status = RegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                      ACPI_OPREGION_ACCESS_AS_COOKED,
                                      ACPISIM_OPREGION_TYPE,
                                      (PACPI_OP_REGION_HANDLER) AcpisimOpRegionHandler,
                                      (PVOID) ACPISIM_TAG,
                                      0,
                                      &g_OperationRegionObject);

    return status;
}

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called to unregister our operation region
    handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    status = DeRegisterOpRegionHandler (AcpisimLibGetNextDevice (DeviceObject),
                                        g_OperationRegionObject);

    ExFreePool (g_OpRegionSharedMemory);

    return status;
}

NTSTATUS
EXPORT
AcpisimOpRegionHandler (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    )

/*++

Routine Description:

    This routine is called when ASL touches the op region.
    
Arguments:

    AccessType - Indicates whether it is a read or write.
    OperationRegionObject - A pointer to our op region
    Address - Offset into the op region for which the access occurred
    Size - Number of bytes of the access
    Data - Data being written, or location to store data being read
    Context - A user definable context (in this case, device extension)
    CompletionHandler - internal, not used
    CompletionContext - internal, not used

Return Value:

    STATUS_SUCCESS, if successful

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    
    ASSERT (AccessType == ACPI_OPREGION_WRITE || AccessType == ACPI_OPREGION_READ);

    //
    // Insert additional handler code here
    //

    switch (AccessType) {
    
    case ACPI_OPREGION_WRITE:

        RtlCopyMemory ((PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Data, Size);
        status = STATUS_SUCCESS;
        break;
    
    case ACPI_OPREGION_READ:

        RtlCopyMemory (Data, (PVOID) ((ULONG_PTR) g_OpRegionSharedMemory + Address), Size);
        status = STATUS_SUCCESS;
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Unknown Opregion access type.  Ignoring.\n");

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return status;
}

NTSTATUS AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for IOCTL requests. This is the "meat" of 
    the driver so to speak.  All of the op-region accesses from user
    mode are handled here.  
    
    The implementer should perform the action and return an appropriate
    status, or return STATUS_UNSUPPORTED if the IOCTL is unrecognized.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbhc\smbhcp.h ===
#include <wdm.h>
#include <smbus.h>
#include <ec.h>

#include <devioctl.h>
#include <acpiioct.h>

#define DEBUG   DBG

//
// Debuging
//


extern ULONG SMBHCDebug;


#if DEBUG
    #define SmbPrint(l,m)    if(l & SMBHCDebug) DbgPrint m
#else
    #define SmbPrint(l,m)
#endif


//
// Control methods used by EC
//
#define CM_EC_METHOD   (ULONG) (0,'CE_')


#define SMB_LOW         0x00000010
#define SMB_STATE       0x00000020
#define SMB_NOTE        0x00000001
#define SMB_WARN        0x00000002
#define SMB_ERROR       0x00000004


//
// SMB Host Controller interface definitions
//

typedef struct {
    UCHAR       Protocol;
    UCHAR       Status;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
    UCHAR       BlockLength;
    UCHAR       AlarmAddress;
    UCHAR       AlarmData[2];
} SMB_HC, *PSMB_HC;

//
// Protocol values
//

#define SMB_HC_NOT_BUSY             0x00
#define SMB_HC_WRITE_QUICK          0x02    // quick cmd with data bit = 0
#define SMB_HC_READ_QUICK           0x03    // quick cmd with data bit = 1
#define SMB_HC_SEND_BYTE            0x04
#define SMB_HC_RECEIVE_BYTE         0x05
#define SMB_HC_WRITE_BYTE           0x06
#define SMB_HC_READ_BYTE            0x07
#define SMB_HC_WRITE_WORD           0x08
#define SMB_HC_READ_WORD            0x09
#define SMB_HC_WRITE_BLOCK          0x0A
#define SMB_HC_READ_BLOCK           0x0B
#define SMB_HC_PROCESS_CALL         0x0C

//
// Status field masks
//

#define SMB_DONE                    0x80
#define SMB_ALRM                    0x40
#define SMB_STATUS_MASK             0x1F

//
// SMB Host Controller Device object extenstion
//

typedef struct {
    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      NextFdo;
    PDEVICE_OBJECT      Pdo;         //Pdo corresponding to this fdo
    PDEVICE_OBJECT      LowerDeviceObject;
    PSMB_CLASS          Class;              // Shared class data

    //
    // Configuration information
    //

    UCHAR               EcQuery;            // EC Query value
    UCHAR               EcBase;             // EC Base value

    //
    // Miniport data
    //

    PIRP                StatusIrp;          // IRP in progress to read status without user irp

    UCHAR               IoState;            // Io state
    UCHAR               IoWaitingState;     // Io state once register read/write completed
    UCHAR               IoStatusState;      // Io state to revert to if idle status

    UCHAR               IoReadData;         // Size of data buffer read after complete status

    SMB_HC              HcState;            // Current host controller registers

} SMB_DATA, *PSMB_DATA;

//
// IoState, IoWaitingState, IoStatusState, StatusState,
//

#define SMB_IO_INVALID                      0
#define SMB_IO_IDLE                         1
#define SMB_IO_CHECK_IDLE                   2
#define SMB_IO_WAITING_FOR_HC_REG_IO        3
#define SMB_IO_WAITING_FOR_STATUS           4
#define SMB_IO_START_TRANSFER               5
#define SMB_IO_READ_STATUS                  6
#define SMB_IO_CHECK_STATUS                 7
#define SMB_IO_COMPLETE_REQUEST             8
#define SMB_IO_COMPLETE_REG_IO              9
#define SMB_IO_CHECK_ALARM                  10
#define SMB_IO_START_PROTOCOL               11

//
// Driver supports the following class driver version
//

#define SMB_HC_MAJOR_VERSION                0x0001
#define SMB_HC_MINOR_VERSION                0x0000


//
// Prototypes
//

VOID
SmbHcStartIo (
    IN PSMB_CLASS   SmbClass,
    IN PVOID        SmbMiniport
    );

VOID
SmbHcQueryEvent (
    IN ULONG        QueryVector,
    IN PSMB_DATA    SmbData
    );

VOID
SmbHcServiceIoLoop (
    IN PSMB_CLASS   SmbClass,
    IN PSMB_DATA    SmbData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\driver\acpisim.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 ioctl.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     IO Device Control Handler module
     
Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:
    
     This header file shows all of the functions that must be exported
     in order to compile against the ACPI BIOS Simulator Library.
     
Revision History:
	 

--*/

#if !defined(_ACPISIM_H_)
#define _ACPISIM_H_

//
// Defines
//

#define OPREGION_SIZE               1024    // use a hardcoded value of 1024 for our operation region size
#define ACPISIM_POOL_TAG            (ULONG) 'misA'

//
// Specify the operation region type here
//

#define ACPISIM_OPREGION_TYPE      0x81

//
// Public function prototypes
//

NTSTATUS 
AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

#endif // _ACPISIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiload\acpiload.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiload.c

Abstract:

    This program installs an AML file into the NT registry

Author:

    Ken Reneris

Environment:

    Command-line.

Revision History:

2-23-2000 - mmurph - Added support for images besides DSDTs
2-23-2000 - mmurph - Added support to force load for unknown image type

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <amlreg.h>
//#include <varargs.h>

#define SIGNATURES {'TDSD', 'TDSR', 'TDSS', 'TDSP', 'CIPA', 'PCAF', 'SCAF', 'TSBS'}

#define DATA_SIZE   7*1024      // max value to write into registry

typedef struct {
   ULONG       Signature;
   ULONG       Length;
   UCHAR       Revision;
   UCHAR       Checksum;
   UCHAR       OemID[6];
   UCHAR       OemTableID[8];
   ULONG       OemRevision;
   UCHAR       CreatorID[4];
   UCHAR       CreatorRevision[4];
} DSDT, *PDSDT;


IFILE       Update;                     // Image of updated aml file
IFILE       Orig;                       // Image of original aml file
BOOLEAN     Verbose;
BOOLEAN     DeleteUpdate;
BOOLEAN     Force;
BOOLEAN     ArgsParsed;
BOOLEAN     RegInProgress;
HKEY        RegKey;

ULONG       RegDataSequence;
ULONG       RegDataSize;
UCHAR       RegDataBuffer[DATA_SIZE];
UCHAR       s[500];                     // Registry path
PUCHAR signa;

//
// Internal prototypes
//

VOID
ParseArgs (
          IN int  argc,
          IN char *argv[]
          );

VOID
CheckImageHeader (
                 IN PIFILE   File
                 );

VOID
GetRegistryKey (
               IN PIFILE   Image
               );

VOID
FAbort (
       PUCHAR  Text,
       PIFILE  File
       );

VOID
Abort (
      VOID
      );

VOID
BuildUpdate (
            VOID
            );

VOID
AddRun (
       IN ULONG    Offset,
       IN ULONG    Length
       );

VOID
FlushRun (
         VOID
         );

VOID
DeleteRegistryNode (
                   IN HKEY Handle
                   );

PUCHAR
FixString (
          IN PUCHAR   Str,
          IN ULONG    Len
          );

int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    ) {
   //
   // Init globals
   //

   Update.Desc = "update image";
   Orig.Desc   = "original image";

   //
   // Parse args
   //

   ParseArgs(argc, argv);

   //
   // Parse image headers
   //

   CheckImageHeader (&Update);
   if (Orig.Opened) {
      CheckImageHeader (&Orig);

      // verify oem info
      if (strcmp (Update.OemID, Orig.OemID)) {
         printf ("OEM id in update image mis-matches original image\n");
         Abort ();
      }

      if (strcmp (Update.OemTableID, Orig.OemTableID)) {
         printf ("OEM table id in update image mis-matches original image\n");
         Abort ();
      }

      if (Update.OemRevision != Orig.OemRevision) {
         printf ("OEM revision in update image revision does not match\n");
         Abort ();
      }
   }

   //
   // Open/create proper registry location
   //

   GetRegistryKey (&Update);

   //
   // Delete any existing stuff
   //

   DeleteRegistryNode (RegKey);
   if (DeleteUpdate) {
      printf ("Registry data deleted\n");
      exit (1);
   }

   //
   // For now hardcoded to "update" action
   //
   BuildUpdate ();

   return 0;
}

VOID
BuildUpdate (
            VOID
            ) {
   LONG        Status;
   ULONG       i, Len, Offs, RunLen, match;

   RegDataSequence = 0;
   RegDataSize     = 0;
   RegInProgress   = TRUE;

   //
   // If there's no original image, just write the new one
   //

   if (!Orig.Opened) {
      AddRun (Update.FileSize, 0);
      AddRun (0, Update.FileSize);
   } else {
      if (Update.FileSize != Orig.FileSize) {
         AddRun (Update.FileSize, 0);
      }

      Len = Update.FileSize;
      if (Orig.FileSize < Update.FileSize) {
         Len = Orig.FileSize;
      }

      Offs=0;
      while (Offs < Len) {
         //
         // Skip matching bytes
         //
         if (Update.Image[Offs] == Orig.Image[Offs]) {
            Offs += 1;
            continue;
         }

         //
         // Count mismatching bytes
         //
         match = 0;
         for (RunLen=1; Offs+RunLen < Len; RunLen++) {
            if (Update.Image[Offs+RunLen] == Orig.Image[Offs+RunLen]) {
               match += 1;
               if (match > 8) {
                  break;
               }
            } else {
               match = 0;
            }
         }

         RunLen -= match;
         AddRun (Offs, RunLen);
         Offs += RunLen;
      }

      //
      // If there's more at the end add it
      //

      if (Len < Update.FileSize) {
         AddRun (Len, Update.FileSize - Len);
      }

   }

   FlushRun();
   if (RegDataSequence) {
      if (Verbose) {
         printf ("SetValue Action\n");
      }

      i = 0;      // BUGBUG: values need defined
      Status = RegSetValueEx (RegKey, "Action", 0L, REG_DWORD,(PUCHAR) &i, sizeof(i));
   }

   RegInProgress = FALSE;

   if (Verbose) {
      printf ("Registry path:\n%s\n", s);
   }

}


VOID
AddRun (
       IN ULONG    Offset,
       IN ULONG    Length
       ) {
   PREGISTRY_HEADER    regHdr;
   ULONG               RunLength;


   do {
      if (RegDataSize + sizeof(REGISTRY_HEADER) > DATA_SIZE - 128) {
         FlushRun ();
      }

      regHdr = (PREGISTRY_HEADER) (RegDataBuffer + RegDataSize);
      RegDataSize += sizeof(REGISTRY_HEADER);

      if (DATA_SIZE - RegDataSize < Length) {
         RunLength = DATA_SIZE - RegDataSize;
      } else {
         RunLength = Length;
      }

      //printf ("Add Hdr %x %x\n", Offset, RunLength);

      regHdr->Offset = Offset;
      regHdr->Length = RunLength;
      RtlCopyMemory (RegDataBuffer + RegDataSize, Update.Image + Offset, RunLength);

      RegDataSize += RunLength;
      Offset += RunLength;
      Length -= RunLength;
   } while (Length);
}


VOID
FlushRun
(
VOID
) {
   LONG    Status;
   UCHAR   s[50];

   if (RegDataSize) {
      sprintf (s, "%08x", RegDataSequence);
      RegDataSequence += 1;

      if (Verbose) {
         printf ("SetValue %s\n", s);
      }

      Status = RegSetValueEx (RegKey, s, 0L, REG_BINARY, RegDataBuffer, RegDataSize);
      RegDataSize = 0;
      if (Status != ERROR_SUCCESS) {
         printf ("Error writting registry value %s\n", s);
         Abort();
      }
   }
}


VOID
DeleteRegistryNode (
                   IN HKEY Handle
                   ) {
   UCHAR   s[500];
   ULONG   i;
   LONG    Status;
   HKEY    SubKey;
   ULONG   Type;
   ULONG   DataSize;

#if 0
   i = 0;
   for (; ;) {
      Status = RegEnumKey(Handle, i, s, sizeof(s));
      i += 1;
      if (Status == ERROR_NO_MORE_ITEMS) {
         break;
      }

      Status = RegOpenKey(Handle, s, &SubKey);
      if (Status == ERROR_SUCCESS) {
         DeleteRegistryNode (SubKey);
         RegCloseKey (SubKey);

         if (Verbose) {
            printf ("Delete key %s\n", s);
         }
         RegDeleteKey (Handle, s);
         i = 0;
      }
   }
#endif

   i = 0;
   for (; ;) {
      s[0] = 0;
      DataSize = 0;
      Status = RegEnumValue(
                           Handle,
                           i,
                           s,
                           &DataSize,
                           NULL,
                           &Type,
                           NULL,
                           0
                           );
      i += 1;
      if (Status == ERROR_NO_MORE_ITEMS) {
         break;
      }

      s[DataSize] = 0;
      if (Verbose) {
         printf ("Delete value %s\n", s);
      }

      Status = RegDeleteValue (Handle, s);
      if (Status == ERROR_SUCCESS) {
         i = 0;
      }
   }
}


VOID
GetRegistryKey (
               IN PIFILE   Image
               ) {
   LONG    Status;
   char    OemID[7]={0};
   char    OemTableID[20]={0};
   ULONG   i;

   strcpy(OemID, Image->OemID);
   strcpy(OemTableID, Image->OemTableID);

   for (i = 0; i < strlen(OemID); i++) {
       if (OemID[i] == ' ') {
           OemID[i] = '_';
       }
   }
   for (i = 0; i < strlen(OemTableID); i++) {
       if (OemTableID[i] == ' ') {
           OemTableID[i] = '_';
       }
   }

   sprintf (s, "System\\CurrentControlSet\\Services\\ACPI\\Parameters\\%c%c%c%c\\%s\\%s\\%.8x",
            signa[0],
            signa[1],
            signa[2],
            signa[3],
            OemID,
            OemTableID,
            Image->OemRevision
           );

   Status = RegCreateKey (HKEY_LOCAL_MACHINE, s, &RegKey);
   if (Status == ERROR_SUCCESS) {
      RegCloseKey (RegKey);
   }

   Status = RegOpenKeyEx (
                         HKEY_LOCAL_MACHINE,
                         s,
                         0L,
                         KEY_ALL_ACCESS,
                         &RegKey
                         );

   if (Status != ERROR_SUCCESS) {
      RegKey = NULL;
      printf ("Count not access the registry path: %s\n", s);
      Abort ();
   }
}


VOID
CheckImageHeader (
                 IN PIFILE   File
                 ) {
   PUCHAR      Image;
   PDSDT       Dsdt; // Variable name kept as Dsdt even though this program can handle all types
   UCHAR       check;
   ULONG       i;
   BOOL found = FALSE;
   //ULONG signatures[] = SIGNATURES;
   ULONG signatures[] = SIGNATURES;


   if (File->FileSize < sizeof(DSDT)) {
      FAbort ("Invalid image size in", File);
   }

   Dsdt  = (PDSDT) File->Image;

   for (i=0;i<sizeof(signatures);i++) {
      if (signatures[i] == Dsdt->Signature) {
         found = TRUE;
         signa = (PUCHAR)(&(Dsdt->Signature));
         break;
      }
   }
   if (!found && !Force) {
      UCHAR sig[64];
      sprintf(sig, "Image signature (%c%c%c%c) not recognized in",
              ((PUCHAR)(&Dsdt->Signature))[0],
              ((PUCHAR)(&Dsdt->Signature))[1],
              ((PUCHAR)(&Dsdt->Signature))[2],
              ((PUCHAR)(&Dsdt->Signature))[3]);
      FAbort (sig, File);
   }

   
//
// BUGBUG: remove? (Or at least revision should be "1")
//
//    if (Dsdt->Revision != 0) {
//        FAbort ("DSDT revision not 0 in", File);
//    }

   if (File->FileSize != Dsdt->Length) {
      UCHAR sig[64];
      sprintf(sig, "File size in %c%c%c%c does not match image size in",
              signa[0],
              signa[1],
              signa[2],
              signa[3]);
      FAbort (sig, File);
   }

   check = 0;
   for (Image = File->Image; Image < File->EndOfImage; Image += 1) {
      check += *Image;
   }

   if (check) {
      FAbort ("Image checksum is incorrect in", File);
   }

   //
   // normalize fixed strings
   //
   File->OemID = FixString (Dsdt->OemID, 6);
   File->OemTableID = FixString (Dsdt->OemTableID, 8);
   File->OemRevision = Dsdt->OemRevision;


//    for (i=0; i < 4; i++) {
//        if (File->OemRevision[i] == 0 || File->OemRevision[i] == ' ') {
//            File->OemRevision[i] = '_';
//        }
//    }

   if (Verbose) {
      printf ("\n");
      printf ("%c%c%c%c info for %s (%s)\n", 
              signa[0],
              signa[1],
              signa[2],
              signa[3],
              File->Desc, File->FileName);
      printf ("  Size of image: %d\n", File->FileSize);
      printf ("  OEM id.......: %s\n", File->OemID);
      printf ("  OEM Table id.: %s\n", File->OemTableID);
      printf ("  OEM revision.: %.8x\n", File->OemRevision);

   }
         
}

PUCHAR
FixString (
          IN PUCHAR   Str,
          IN ULONG    Len
          ) {
   PUCHAR  p;
   ULONG   i;

   p = malloc(Len+1);
   memcpy (p, Str, Len);
   p[Len] = 0;

   for (i=Len; i; i--) {
      if (p[i] != ' ') {
         break;
      }
      p[i] = 0;
   }
   return p;
}

VOID
FAbort (
       PUCHAR  Text,
       PIFILE  File
       ) {
   
   printf ("%s %s (%s)\n", Text, File->Desc, File->FileName);
   Abort();
}


VOID
Abort(
     VOID
     ) {
   if (RegInProgress) {
      DeleteRegistryNode(RegKey);
   }

   if (!ArgsParsed) {
      printf ("amlload: UpdateImage [OriginalImage] [-v] [-d] [-f]\n");
   }
   exit (1);
}


VOID
ParseArgs (
          IN int  argc,
          IN char *argv[]
          ) {
   PIFILE      File;
   OFSTRUCT    OpenBuf;

   File = &Update;

   while (--argc) {
      argv += 1;

      //
      // If it's a flag crack it
      //

      if (argv[0][0] == '-') {
         switch (argv[0][1]) {
         case 'v':
         case 'V':
            Verbose = TRUE;
            break;

         case 'd':
         case 'D':
            DeleteUpdate = TRUE;
            break;

         case 'f':
         case 'F':
            Force = TRUE;
            break;

         default:
            printf ("Unknown flag %s\n", argv[0]);
            Abort ();
         }

      } else {

         if (!File) {
            printf ("Unexcepted parameter %s\n", argv[0]);
            Abort();
         }

         //
         // Open the file
         //

         File->FileName = argv[0];
         File->FileHandle = (HANDLE) OpenFile(
                                             argv[0],
                                             &OpenBuf,
                                             OF_READ
                                             );
         if (File->FileHandle == (HANDLE) HFILE_ERROR) {
            FAbort ("Can not open", File);
         }

         File->FileSize = GetFileSize(File->FileHandle, NULL);

         //
         // Map it
         //

         File->MapHandle =
         CreateFileMapping(
                          File->FileHandle,
                          NULL,
                          PAGE_READONLY,
                          0,
                          File->FileSize,
                          NULL
                          );

         if (!File->MapHandle) {
            FAbort ("Cannot map", File);
         }

         File->Image =
         MapViewOfFile (
                       File->MapHandle,
                       FILE_MAP_READ,
                       0,
                       0,
                       File->FileSize
                       );

         if (!File->Image) {
            FAbort ("Cannot map view of image", File);
         }
         File->EndOfImage = File->Image + File->FileSize;
         File->Opened = TRUE;

         //
         // Next file param
         //

         if (File == &Update) {
            File = &Orig;
         } else {
            File = NULL;
         }
      }
   }

   //
   // At least a update image is needed
   //

   if (!Update.Opened) {
      Abort ();
   }

   ArgsParsed = TRUE;
   return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\smbus\smbhc\smbsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    service.c

Abstract:

    ACPI Embedded Controller Driver

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "smbhcp.h"

//
// Transfer information based on protocol
//

struct {
    UCHAR       SetupSize;
    UCHAR       ReturnSize;
    UCHAR       Protocol;
} SmbTransfer[] = {
    0,      0,      SMB_HC_WRITE_QUICK,     // 0
    0,      0,      SMB_HC_READ_QUICK,      // 1
    2,      0,      SMB_HC_SEND_BYTE,       // 2
    1,      1,      SMB_HC_RECEIVE_BYTE,    // 3
    3,      0,      SMB_HC_WRITE_BYTE,      // 4
    2,      1,      SMB_HC_READ_BYTE,       // 5
    4,      0,      SMB_HC_WRITE_WORD,      // 6
    2,      2,      SMB_HC_READ_WORD,       // 7
    35,     0,      SMB_HC_WRITE_BLOCK,     // 8
    2,     33,      SMB_HC_READ_BLOCK,      // 9
    4,      2,      SMB_HC_PROCESS_CALL     // A
} ;

VOID
SmbHcStartIo (
    IN PSMB_CLASS   SmbClass,
    IN PVOID        SmbMiniport
    )
/*++

Routine Description:

    This routine is called by the class driver when a new request has been
    given to the device.   If the device is not being processed, then IO is
    started; else, nothing is done as the context processing the device will
    handle it

Arguments:

    SmbClass    - SMB class data

    SmbMiniport - Miniport context

Return Value:

    None

--*/
{
    PSMB_DATA   SmbData;


    SmbData = (PSMB_DATA) SmbMiniport;
    switch (SmbData->IoState) {
        case SMB_IO_IDLE:
            //
            // Device is idle, go check it
            //

            SmbData->IoState = SMB_IO_CHECK_IDLE;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_CHECK_IDLE:
        case SMB_IO_CHECK_ALARM:
        case SMB_IO_WAITING_FOR_HC_REG_IO:
        case SMB_IO_WAITING_FOR_STATUS:
            //
            // Device i/o is in process which will check for a CurrentIrp
            //

            break;

        default:
            SmbPrint (SMB_ERROR, ("SmbHcStartIo: Unexpected state\n"));
            break;
    }
}



VOID
SmbHcQueryEvent (
    IN ULONG        QueryVector,
    IN PSMB_DATA    SmbData
    )
/*++

Routine Description:

    This routine is called by the embedded controller driver when the
    smb controller has signalled for servicing.  This function sets
    the miniport state to ensure the STATUS register is read and checked
    and if needed starts the device processing to check it

--*/
{
    PSMB_CLASS          SmbClass;

    SmbPrint (SMB_STATE, ("SmbHcQueryEvent\n"));

    //
    // Check status of device.
    //

    SmbClass = SmbData->Class;
    SmbClassLockDevice (SmbClass);

    switch (SmbData->IoState) {
        case SMB_IO_CHECK_IDLE:
        case SMB_IO_IDLE:
            //
            // Device is idle.  Read status and check for an alarm
            //

            SmbData->IoState = SMB_IO_READ_STATUS;
            SmbData->IoStatusState = SMB_IO_CHECK_IDLE;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_WAITING_FOR_STATUS:
            //
            // Waiting for completion status, read status now to see if alarm is set
            //

            SmbData->IoState = SMB_IO_READ_STATUS;
            SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
            SmbHcServiceIoLoop (SmbClass, SmbData);
            break;

        case SMB_IO_CHECK_ALARM:
            //
            // Status is read after alarm is processed so state is OK
            //

            break;

        case SMB_IO_WAITING_FOR_HC_REG_IO:

            //
            // Waiting for register transfer to/from host controller interface,
            // check the waiting state
            //

            switch (SmbData->IoWaitingState) {
                case SMB_IO_CHECK_ALARM:
                case SMB_IO_START_PROTOCOL:
                case SMB_IO_READ_STATUS:
                    //
                    // Status will be read, so state is OK
                    //

                    break;

                case SMB_IO_CHECK_STATUS:
                    //
                    // Back check status up and re-read the status before
                    // the check status
                    //

                    SmbData->IoWaitingState = SMB_IO_READ_STATUS;
                    break;

                case SMB_IO_WAITING_FOR_STATUS:
                    //
                    // Going to wait for completion status, read status once
                    // hc i/o has completed
                    //

                    SmbData->IoWaitingState = SMB_IO_READ_STATUS;
                    SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
                    break;

                default:
                    SmbPrint (SMB_ERROR, ("SmbHcQuery: Unknown IoWaitingState %d\n", SmbData->IoWaitingState));
                    break;
            }
            break;

        default:
            SmbPrint (SMB_ERROR, ("SmbHcQuery: Unknown IoState %d\n", SmbData->IoState));
            break;
    }

    SmbClassUnlockDevice (SmbClass);
}

NTSTATUS
SmbHcRegIoComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )
/*++

Routine Description:

    Completion function for IRPs sent to the embedded control for EC io.

--*/
{
    PSMB_DATA   SmbData;
    PSMB_CLASS  SmbClass;

    SmbPrint (SMB_STATE, ("SmbHcRegIoComplete: Enter.  Irp %x\n", Irp));

    SmbData = (PSMB_DATA) Context;
    SmbClass = SmbData->Class;
    SmbClassLockDevice (SmbClass);

    //
    // Move state to IoWaitingState and continue
    //

    ASSERT (SmbData->IoState == SMB_IO_WAITING_FOR_HC_REG_IO);
    SmbData->IoState = SMB_IO_COMPLETE_REG_IO;
    SmbHcServiceIoLoop (SmbClass, SmbData);

    SmbClassUnlockDevice (SmbClass);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
SmbHcServiceIoLoop (
    IN PSMB_CLASS   SmbClass,
    IN PSMB_DATA    SmbData
    )
/*++

Routine Description:

    Main host controller interface service loop.

    N.B. device lock is held by caller.
    N.B. device lock may be released and re-acquired during call

--*/
{
    PIRP                Irp;
    PUCHAR              IoBuffer;
    UCHAR               IoWaitingState;
    UCHAR               ErrorCode;
    BOOLEAN             IoWrite;
    ULONG               IoLength;
    PSMB_REQUEST        SmbReq;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;

    IoWrite = FALSE;
    IoBuffer = NULL;
    IoWaitingState = SMB_IO_IDLE;

    SmbPrint (SMB_STATE, ("SmbService: Enter - SmbData %x\n", SmbData));

    do {
        switch (SmbData->IoState) {

            case SMB_IO_CHECK_IDLE:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_IDLE\n"));

                //
                // Fallthrough to SMB_IO_IDLE.
                //

                SmbData->IoState = SMB_IO_IDLE;
            case SMB_IO_IDLE:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_IDLE\n"));

                //
                // If there's an alarm pending, read and clear it
                //

                if (SmbData->HcState.Status & SMB_ALRM) {
                    IoBuffer = &SmbData->HcState.AlarmAddress;
                    IoLength = 3;
                    IoWaitingState = SMB_IO_CHECK_ALARM;
                    break;
                }

                //
                // If there's an IRP, lets start it
                //

                if (SmbClass->CurrentIrp) {
                    SmbData->IoState = SMB_IO_START_TRANSFER;
                    break;
                }
                break;

            case SMB_IO_START_TRANSFER:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_START_TRANSFER\n"));

                //
                // Begin CurrentIrp transfer
                //

                Irp = SmbClass->CurrentIrp;
                SmbReq = SmbClass->CurrentSmb;
                SmbData->HcState.Protocol = SmbTransfer[SmbReq->Protocol].Protocol;
                SmbData->HcState.Address  = SmbReq->Address << 1;
                SmbData->HcState.Command  = SmbReq->Command;
                SmbData->HcState.BlockLength = SmbReq->BlockLength;

                //
                // Write HC registers
                //

                IoWrite  = TRUE;
                IoBuffer = &SmbData->HcState.Address;
                IoLength = SmbTransfer[SmbReq->Protocol].SetupSize;
                IoBuffer = &SmbData->HcState.Address;
                IoWaitingState = SMB_IO_START_PROTOCOL;

                //
                // Move data bytes (after address & command byte)
                //

                if (IoLength > 2) {
                   memcpy (SmbData->HcState.Data, SmbReq->Data, IoLength-2);
                }

                //
                // Setup for result length once command completes
                //

                SmbData->IoReadData = SmbTransfer[SmbReq->Protocol].ReturnSize;

                //
                // Handle HC specific protocol mappings
                //

                switch (SmbData->HcState.Protocol) {
                    case SMB_HC_WRITE_QUICK:
                    case SMB_HC_READ_QUICK:
                        //
                        // Host controller wants quick data bit in bit 0
                        // of address
                        //

                        SmbData->HcState.Address |=
                            (SmbData->HcState.Protocol & 1);
                        break;

                    case SMB_HC_SEND_BYTE:
                        //
                        // Host controller wants SEND_BYTE byte in the command
                        // register
                        //

                        SmbData->HcState.Command = SmbReq->Data[0];
                        break;
                }
                break;

            case SMB_IO_START_PROTOCOL:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_START_PROTOCOL\n"));

                //
                // Transfer registers have been setup.  Initiate the protocol
                //

                IoWrite  = TRUE;
                IoBuffer = &SmbData->HcState.Protocol;
                IoLength = 1;
                IoWaitingState = SMB_IO_WAITING_FOR_STATUS;
                break;

            case SMB_IO_WAITING_FOR_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_WAITING_FOR_STATUS\n"));

                //
                // Transfer is in progress, just waiting for a status to
                // indicate its complete
                //

                SmbData->IoState = SMB_IO_READ_STATUS;
                SmbData->IoStatusState = SMB_IO_WAITING_FOR_STATUS;
                break;

            case SMB_IO_READ_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_READ_STATUS\n"));

                //
                // Read status+protocol and then check it (IoStatusState already set)
                //

                IoBuffer = &SmbData->HcState.Protocol;
                IoLength = 2;   // read protocol & status bytes
                IoWaitingState = SMB_IO_CHECK_STATUS;
                break;

            case SMB_IO_CHECK_STATUS:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_STATUS\n"));

                Irp = SmbClass->CurrentIrp;

                //
                // If there's an Irp
                //

                if (SmbData->IoStatusState == SMB_IO_WAITING_FOR_STATUS  &&
                    SmbData->HcState.Protocol == 0) {

                    SmbReq = SmbClass->CurrentSmb;

                    //
                    // If there's an error set handle it
                    //

                    if (SmbData->HcState.Status & SMB_STATUS_MASK) {
                        ErrorCode = SmbData->HcState.Status & SMB_STATUS_MASK;

                        //
                        // Complete/abort the IO with the error
                        //

                        SmbReq->Status = ErrorCode;
                        SmbData->IoState = SMB_IO_COMPLETE_REQUEST;
                        break;
                    }



                    //
                    // If the done is set continue the IO
                    //

                    if (SmbData->HcState.Status & SMB_DONE) {
                        //
                        // Get any return data registers then complete it
                        //

                        SmbReq->Status = SMB_STATUS_OK;
                        IoBuffer = SmbData->HcState.Data;
                        IoLength = SmbData->IoReadData;
                        IoWaitingState = SMB_IO_COMPLETE_REQUEST;
                        break;
                    }
                }

                //
                // Current status didn't have any effect
                //

                SmbData->IoState = SmbData->IoStatusState;
                break;

            case SMB_IO_COMPLETE_REQUEST:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_COMPLETE_REQUEST\n"));

                Irp = SmbClass->CurrentIrp;
                SmbReq = SmbClass->CurrentSmb;

                SmbData->IoState = SMB_IO_CHECK_IDLE;
                SmbData->IoStatusState = SMB_IO_INVALID;

                //
                // Return any read data if needed
                //

                memcpy (SmbReq->Data, SmbData->HcState.Data, SMB_MAX_DATA_SIZE);
                SmbReq->BlockLength = SmbData->HcState.BlockLength;
                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(SMB_REQUEST);

                //
                // Note SmbClass driver will drop the lock during this call
                //

                SmbClassCompleteRequest (SmbClass);
                break;

            case SMB_IO_CHECK_ALARM:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_CHECK_ALARM\n"));

                //
                // HC alarm values read, check them
                //

                SmbPrint (SMB_NOTE, ("SmbHcService: Process Alarm Data %x %x %x\n",
                    SmbData->HcState.AlarmAddress,
                    SmbData->HcState.AlarmData[0],
                    SmbData->HcState.AlarmData[1]
                    ));

                //
                // Inform the class driver of the event.
                //

                SmbClassAlarm (
                    SmbClass,
                    (UCHAR)  (SmbData->HcState.AlarmAddress >> 1),
                    (USHORT) (SmbData->HcState.AlarmData[0] | (SmbData->HcState.AlarmData[1] << 8))
                    );

                //
                // Clear the alarm bit in the status value, and then check
                // for idle state
                //

                SmbData->HcState.Status = 0;
                IoBuffer = &SmbData->HcState.Status;
                IoLength = 1;
                IoWrite  = TRUE;
                IoWaitingState = SMB_IO_READ_STATUS;
                SmbData->IoStatusState = SMB_IO_CHECK_IDLE;
                break;

            case SMB_IO_COMPLETE_REG_IO:
                SmbPrint (SMB_STATE, ("SmbService: SMB_IO_COMPLETE_REQ_IO\n"));

                //
                // Irp for HC reg IO is complete, check it
                //

                Irp = SmbClass->CurrentIrp;

                if (!Irp) {
                    //
                    // No current irp - check for status irp
                    //

                    Irp = SmbData->StatusIrp;

                    if (Irp) {
                        // just reading status
                        IoFreeIrp (Irp);
                        SmbData->StatusIrp = NULL;
                    } else {
                        SmbPrint (SMB_WARN, ("SmbHcServiceIoLoop: HC Reg Io for what?\n"));
                    }

                } else {

                    //
                    // Check for error on register access
                    //

                    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
                        SmbPrint (SMB_WARN, ("SmbHcServiceIoLoop: HC Reg Io request failed\n"));

                        //
                        // Condition is likely fatal, give it up
                        //

                        SmbData->HcState.Protocol = 0;
                        SmbData->HcState.Status = SMB_UNKNOWN_ERROR;
                    }
                }

                //
                // Continue to next state
                //

                SmbData->IoState = SmbData->IoWaitingState;
                SmbPrint (SMB_STATE, ("SmbService: Next state: %x\n", SmbData->IoState));
                break;

            default:
                SmbPrint (SMB_ERROR, ("SmbHcServiceIoLoop: Invalid state: %x\n", SmbData->IoState));
                SmbData->IoState = SMB_IO_CHECK_IDLE;
                break;
        }

        //
        // If there's an IO operation to the HC registers required, dispatch it
        //

        if (IoWaitingState != SMB_IO_IDLE) {
            SmbPrint (SMB_STATE, ("SmbService: IoWaitingState %d\n", IoWaitingState));

            if (IoLength) {
                //
                // There's an Io operation dispatch. Set status as REG IO pending,
                // and drop the device lock
                //

                SmbData->IoWaitingState = IoWaitingState;
                SmbData->IoState = SMB_IO_WAITING_FOR_HC_REG_IO;
                SmbClassUnlockDevice(SmbClass);

                //
                // Setup IRP to perform the register IO to the HC
                //

                Status = STATUS_INSUFFICIENT_RESOURCES;
                Irp = SmbClass->CurrentIrp;
                if (!Irp) {
                    Irp = IoAllocateIrp (SmbClass->DeviceObject->StackSize, FALSE);
                    SmbData->StatusIrp = Irp;
                }

                if (Irp) {

                    //
                    // Fill in register transfer request
                    //

                    IrpSp = IoGetNextIrpStackLocation (Irp);
                    IrpSp->MajorFunction = IoWrite ? IRP_MJ_WRITE : IRP_MJ_READ;
                    IrpSp->Parameters.Read.Length = IoLength;
                    IrpSp->Parameters.Read.Key    = 0;
                    IrpSp->Parameters.Read.ByteOffset.HighPart = 0;
                    IrpSp->Parameters.Read.ByteOffset.LowPart =
                            (ULONG) ((PUCHAR) IoBuffer - (PUCHAR) &SmbData->HcState) +
                            SmbData->EcBase;

                    Irp->AssociatedIrp.SystemBuffer = IoBuffer;

                    //
                    // Setup completion routine
                    //

                    IoSetCompletionRoutine (
                        Irp,
                        SmbHcRegIoComplete,
                        SmbData,
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    SmbPrint (SMB_STATE, ("SmbService: IRP=%x, IrpSp=%x\n", Irp, IrpSp));
                    SmbPrint (SMB_STATE, ("SmbService: %s Off=%x, Len=%x, Buffer=%x\n",
                        IoWrite ? "write" : "read",
                        IrpSp->Parameters.Read.ByteOffset.LowPart,
                        IoLength,
                        IoBuffer
                        ));


                    //
                    // Call lower FDO to perform the IO
                    //

                    Status = IoCallDriver (SmbData->LowerDeviceObject, Irp);
                }

                //
                // If the request is not pending, complete it
                //

                SmbClassLockDevice(SmbClass);
                if (Status != STATUS_PENDING) {
                    SmbData->IoState = SMB_IO_COMPLETE_REG_IO;
                }

            } else {
                // no data to transfer continue with next state
                SmbData->IoState = IoWaitingState;
            }

            IoWaitingState = SMB_IO_IDLE;       // was: SMB_IO_CHEC_IDLE
            IoBuffer = NULL;
            IoWrite  = FALSE;
        }


        //
        // Loop unless state requires some asynchronous to exit
        //

    } while (SmbData->IoState != SMB_IO_IDLE   &&
             SmbData->IoState != SMB_IO_WAITING_FOR_HC_REG_IO   &&
             SmbData->IoState != SMB_IO_WAITING_FOR_STATUS) ;


    SmbPrint (SMB_STATE, ("SmbService: Exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\inc\asimlib.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 asimlib.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_ASIMLIB_H_)
#define _ASIMLIB_H_

//
// includes
//

//
// Definitions
//

#define ACPISIM_GUID                {0x27FC71F0, 0x8B2D, 0x4D05, { 0xBD, 0xD0, 0xE8, 0xEA, 0xCA, 0xA0, 0x78, 0xA0}}
#define ACPISIM_TAG                 (ULONG) 'misA'

//
// Debug Flags
//

#define DBG_ERROR   0x00000001
#define DBG_WARN    0x00000002
#define DBG_INFO    0x00000004

//
// Public function prototypes
//

VOID
AcpisimDbgPrint
    (
    ULONG DebugLevel,
    TCHAR *Text,
    ...
    );

PDEVICE_OBJECT
AcpisimLibGetNextDevice
    (
        PDEVICE_OBJECT DeviceObject
    );


#define DBG_PRINT AcpisimDbgPrint

#endif // _ASIMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\util.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_UTIL_H_)
#define _UTIL_H_


//
// Public function prototypes
//                

VOID
AcpisimSetDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    );

VOID
AcpisimClearDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    );

VOID
AcpisimUpdatePnpState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PNP_STATE PnpState
    );
VOID
AcpisimUpdateDevicePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEVICE_POWER_STATE DevicePowerState
    );

VOID
AcpisimUpdatePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PWR_STATE PowerState
    );

NTSTATUS
AcpisimEnableDisableDeviceInterface
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN BOOLEAN Enable
    );

VOID
AcpisimDecrementIrpCount
    (
        PDEVICE_OBJECT DeviceObject
    );

PDEVICE_EXTENSION
AcpisimGetDeviceExtension
    (
        PDEVICE_OBJECT DeviceObject
    );


#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\acpisim.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>
#include <ntpoapi.h>

//
// Specific includes
//

#include "acpisim.h"
#include "dispatch.h"
#include "util.h"

//
// Debug global flag
//
#ifdef DBG
extern ULONG AcpisimDebugMask = 0x00000000;
#endif


//
// Globals
//

PDRIVER_OBJECT_EXTENSION g_DriverObjectExtension = 0;

//
// Define supported IRPs, friendly name them, and associate handlers
//

IRP_DISPATCH_TABLE g_IrpDispatchTable [] = {
    IRP_MJ_PNP,             "PnP Irp",              AcpisimDispatchPnp,
    IRP_MJ_POWER,           "Power Irp",            AcpisimDispatchPower,
    IRP_MJ_DEVICE_CONTROL,  "IOCTL Irp",            AcpisimDispatchIoctl,
    IRP_MJ_CREATE,          "Create Irp",           AcpisimCreateClose,
    IRP_MJ_CLOSE,           "Close Irp",            AcpisimCreateClose,
    IRP_MJ_SYSTEM_CONTROL,  "System Control IRP",   AcpisimDispatchSystemControl
};

//
// Private funtion prototypes
//

NTSTATUS DriverEntry
	(
	    IN PDRIVER_OBJECT DriverObject,
	    IN PUNICODE_STRING RegistryPath 
	);

NTSTATUS
AcpisimGeneralDispatch
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

VOID
AcpisimUnload
    (
        IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
AcpisimAddDevice
    (
        IN PDRIVER_OBJECT DriverObject,
        IN PDEVICE_OBJECT Pdo
    );

//
// Define pageable / init discardable routines
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#endif


NTSTATUS DriverEntry
	(
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath 
	)

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise.

--*/

{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       count = 0, subcount = 0;

    DBG_PRINT (DBG_INFO, "Entering DriverEntry\n");
    
    status = IoAllocateDriverObjectExtension (DriverObject,
                                              (PVOID) 'GLBL',
                                              sizeof (DRIVER_OBJECT_EXTENSION),
                                              &g_DriverObjectExtension);

    if (!NT_SUCCESS (status)) {
        DBG_PRINT (DBG_ERROR, "Unable to allocate global driver object extension (%lx).\n", status);
        goto EndDriverEntry;
    }

    RtlZeroMemory (g_DriverObjectExtension, sizeof (DRIVER_OBJECT_EXTENSION));
    
    RtlInitUnicodeString (&g_DriverObjectExtension->RegistryPath,
                          (PCWSTR) RegistryPath->Buffer);
    
    g_DriverObjectExtension->DriverObject = DriverObject;

    //
    // Init dispatch points.  We'll use a generic dispatch routine for
    // IRP types we handle.
    //

    while (count <= IRP_MJ_MAXIMUM_FUNCTION) {
        
        for (subcount = 0; subcount < sizeof (g_IrpDispatchTable) / sizeof (IRP_DISPATCH_TABLE); subcount++) {
            
            if (count == g_IrpDispatchTable[subcount].IrpFunction) {
                DriverObject->MajorFunction [count] = AcpisimGeneralDispatch;
            }
        }

        count ++;
    }

    DriverObject->DriverUnload = AcpisimUnload;
    DriverObject->DriverExtension->AddDevice = AcpisimAddDevice;


EndDriverEntry:
    
    DBG_PRINT (DBG_INFO, "Exiting DriverEntry\n");
    return status;
}

NTSTATUS
AcpisimGeneralDispatch
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is a general dispatch routine for supported IRPs.
    
Arguments:

    DeviceObject - pointer to the device object

    Irp - pointer to the IRP being passed in

Return Value:

    status of IRP handling

--*/

{
    PDEVICE_EXTENSION		deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION		irpsp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS				status = STATUS_UNSUCCESSFUL;
    ULONG                   count = 0;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimGeneralDispatch\n");

    
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    
    //
    // Acquire the remove lock for outstanding I/O
    //

    IoAcquireRemoveLock (&deviceextension->RemoveLock, Irp);
    
    while (count < sizeof (g_IrpDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MajorFunction == g_IrpDispatchTable[count].IrpFunction) {
            
            DBG_PRINT (DBG_INFO,
                       "Recognized IRP MajorFunction = 0x%x '%s'.\n",
                       g_IrpDispatchTable[count].IrpFunction,
                       g_IrpDispatchTable[count].IrpName
                       );

            status = g_IrpDispatchTable[count].IrpHandler (DeviceObject, Irp);
            
            goto EndAcpisimProcessIncomingIrp;
        }

        count ++;
    }

    //
    // Unrecognized IRP - pass it on
    //

    DBG_PRINT (DBG_INFO, "Unrecognized IRP MajorFunction = 0x%x\n, pass it on.\n", irpsp->MajorFunction);
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (deviceextension->NextDevice, Irp);

EndAcpisimProcessIncomingIrp:
    
    //
    // If the status is pending, the IRP hasn't "left" our
    // driver yet.  Whoever completes the IRP will do the
    // decrement.
    //
    
    if (status != STATUS_PENDING)
    {
        AcpisimDecrementIrpCount (DeviceObject);
        IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);
    }
     
    DBG_PRINT (DBG_INFO, "Exiting AcpisimGeneralDispatch\n");
    return status;
}

VOID
AcpisimUnload
    (
        IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the driver unload routine.
    
Arguments:

    DriverObject - pointer to the driver object

Return Value:

    none

--*/

{
    PDRIVER_OBJECT_EXTENSION driverobjectextension = 0;

    driverobjectextension = IoGetDriverObjectExtension (DriverObject,
                                                        (PVOID) 'GLBL');
    if (!driverobjectextension) {
        DBG_PRINT (DBG_ERROR, "Unable to get driver object extension.  Memory will probably leak.\n");

        goto EndAcpisimUnload;
    }

EndAcpisimUnload:

    return;
}

NTSTATUS
AcpisimAddDevice
    (
        IN PDRIVER_OBJECT DriverObject,
        IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This is the driver WDM AddDevice Routine
    
Arguments:

    DriverObject - pointer to the driver object
    Pdo - pointer to PDO for this device

Return Value:

    status of device addition

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT      deviceobject = 0;
    PDEVICE_EXTENSION   deviceextension = 0;
    CONST GUID          guid = ACPISIM_GUID;

    
    DBG_PRINT (DBG_INFO, "Entering AcpisimAddDevice.\n");
    
    //
    // If Pdo is NULL, we are being asked to do legacy detection.
    // Our device is never legacy detected, so return accordingly.
    //

    if (Pdo == NULL) {

        DBG_PRINT (DBG_WARN, "AddDevice - asked to do legacy detection (Pdo = NULL).  Not supported...\n");
        status = STATUS_NO_MORE_ENTRIES;
        goto EndAcpisimAddDevice;
    }

    //
    // Create our FDO.  Don't use a name - we'll use a device interface
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (DEVICE_EXTENSION),
                             0,
                             FILE_DEVICE_UNKNOWN,
                             0,
                             TRUE,
                             &deviceobject);

    if (!NT_SUCCESS (status)) {
        
        DBG_PRINT (DBG_ERROR, "Can't create FDO.  Status = %lx.\n", status);
        goto EndAcpisimAddDevice;
    }

    //
    // Init our device extension
    //

    deviceextension = deviceobject->DeviceExtension;
    RtlZeroMemory (deviceextension, sizeof (DEVICE_EXTENSION));
    
    deviceextension->Signature = ACPISIM_TAG;
    deviceextension->PnpState = PNP_STATE_INITIALIZING;
    deviceextension->OutstandingIrpCount = 1;
    deviceextension->DeviceObject = deviceobject;
    deviceextension->Pdo = Pdo;

    KeInitializeEvent (&deviceextension->IrpsCompleted, SynchronizationEvent, FALSE);

    //
    // Initialize the remove lock
    //

    IoInitializeRemoveLock (&deviceextension->RemoveLock,
                            ACPISIM_TAG,
                            1,
                            20);

    //
    // Attach our newly created FDO to the device stack
    //

    deviceextension->NextDevice = IoAttachDeviceToDeviceStack (deviceobject, Pdo);

    if (!deviceextension->NextDevice) {
        DBG_PRINT (DBG_ERROR, "Error attaching to device stack.  AddDevice failed.\n");

        status = STATUS_UNSUCCESSFUL;
        goto EndAcpisimAddDevice;
    }

    //
    // Set up device object flags
    // Copy DO_POWER_PAGABLE and DO_POWER_INRUSH from next device to
    // play by rules, and avoid bugcheck 0x9F.
    //

    deviceobject->Flags |= (deviceextension->NextDevice->Flags & DO_POWER_PAGABLE);
	deviceobject->Flags |= (deviceextension->NextDevice->Flags & DO_POWER_INRUSH);
	
    //
    // Register our device interface, so we can be accessed from user mode
    //

    status = IoRegisterDeviceInterface (Pdo,
                                        &guid,
                                        NULL,
                                        &deviceextension->InterfaceString);

    if (!NT_SUCCESS (status)) {
        DBG_PRINT (DBG_ERROR, "Error registering device interface.  Status = %lx.\n", status);

        goto EndAcpisimAddDevice;
    }

    AcpisimSetDevExtFlags (deviceobject, DE_FLAG_INTERFACE_REGISTERED);

    //
    // In AddDevice, we cannot determine power state because
    // we are not allowed to touch the hardware.  Initialize
    // it to PowerDeviceUnspecified.
    //

    AcpisimUpdatePowerState (deviceobject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (deviceobject, PowerDeviceUnspecified);
    
    //
    // We are done adding our device - clear DO_DEVICE_INITIALIZING
    //
    
    deviceobject->Flags &= ~DO_DEVICE_INITIALIZING;
 

EndAcpisimAddDevice:

    //
    // Do cleanup, if necessary
    //

    if (!NT_SUCCESS (status)) {

        if (deviceobject) {

            if (deviceextension && deviceextension->NextDevice) {

                IoDetachDevice (deviceextension->NextDevice);
            }

            IoDeleteDevice (deviceobject);
        }
    }

    DBG_PRINT (DBG_INFO, "Exiting AcpisimAddDevice (%lx).\n", status);
    return status;
}

VOID
AcpisimDbgPrint
    (
    ULONG DebugLevel,
    TCHAR *Text,
    ...
    )

/*++

Routine Description:

    Prints to the debugger if checked build, and the print level
    is unmasked.
        
Arguments:

    DebugLevel - print level to associate message with

    Text - Message to print

Return Value:

    None

--*/

{
    TCHAR textout[2000];
    
    va_list va;
    va_start (va, Text);
    vsprintf (textout, Text, va);
    va_end (va);

#if DBG
    
    if (DebugLevel & AcpisimDebugMask) {
        DbgPrint ("ACPISIM:");
        DbgPrint (textout);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiuasm\acpiuasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiuasm.c

Abstract:

    Test wrapper for the unassembler

Author:

    Stephane Plante
    Based on code by Ken Reneris

Environment:

    User

Revision History:

--*/

#include "acpiuasm.h"

IFILE       Orig;           // Image of original aml file
BOOLEAN     Verbose;
BOOLEAN     ArgsParsed;

int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    )
{
    //
    // Init globals
    //
    Orig.Desc   = "original image";

    //
    // Parse args
    //
    ParseArgs(argc, argv);

    //
    // Check the image header
    //
    CheckImageHeader(
        &Orig
        );

    //
    // Debug the image
    //
    return ScopeParser(
        (PUCHAR) (Orig.Image + sizeof(DSDT)),
        Orig.FileSize,
        (ULONG) ( 0 - (ULONG) Orig.Image - sizeof(DSDT) ),
        0
        );

}

VOID
CheckImageHeader (
    IN PIFILE   File
    )
{
    PUCHAR      Image;
    PDSDT       Dsdt;
    UCHAR       check;
    ULONG       i;


    if (File->FileSize < sizeof(DSDT)) {
        FAbort ("Invalid image size in", File);
    }

    Dsdt  = (PDSDT) File->Image;
    if (Dsdt->Signature != 'TDSD') {
        FAbort ("Image signature not DSDT in", File);
    }

    if (File->FileSize != Dsdt->Length) {
        FAbort ("File size in DSDT does not match image size in", File);
    }

    check = 0;
    for (Image = File->Image; Image < File->EndOfImage; Image += 1) {
        check += *Image;
    }

    if (check) {
        FAbort ("Image checksum is incorrect in", File);
    }

    // normalize fixed strings
    File->OemID = FixString (Dsdt->OemID, 6);
    File->OemTableID = FixString (Dsdt->OemID, 8);
    memcpy (File->OemRevision, Dsdt->OemRevision, 4);
    for (i=0; i < 4; i++) {
        if (File->OemRevision[i] == 0 || File->OemRevision[i] == ' ') {
            File->OemRevision[i] = '_';
        }
    }

    if (Verbose) {
        printf ("\n");
        printf ("DSDT info for %s (%s)\n",  File->Desc, File->FileName);
        printf ("  size of image: %d\n", File->FileSize);
        printf ("  OEM id.......: %s\n", File->OemID);
        printf ("  OEM Table id.: %s\n", File->OemTableID);
        printf ("  OEM revision.: %4x\n", File->OemRevision);
    }
}

PUCHAR
FixString (
    IN PUCHAR   Str,
    IN ULONG    Len
    )
{
    PUCHAR  p;
    ULONG   i;

    p = malloc(Len+1);
    memcpy (p, Str, Len);
    p[Len] = 0;

    for (i=Len; i; i--) {
        if (p[i] != ' ') {
            break;
        }
        p[i] = 0;
    }
    return p;
}

VOID
FAbort (
    PUCHAR  Text,
    PIFILE  File
    )
{
    printf ("%s %s (%s)\n", Text, File->Desc, File->FileName);
    Abort();
}

VOID
Abort(
    VOID
    )
{
    if (!ArgsParsed) {
        printf ("amlload: UpdateImage [OriginalImage] [-v] [-d]\n");
    }
    exit (1);
}

VOID
ParseArgs (
    IN int  argc,
    IN char *argv[]
    )
{
    PIFILE      File;
    OFSTRUCT    OpenBuf;

    File = &Orig;

    while (--argc) {
        argv += 1;

        //
        // If it's a flag crack it
        //

        if (argv[0][0] == '-') {
            switch (argv[0][1]) {
                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                default:
                    printf ("Unkown flag %s\n", argv[0]);
                    Abort ();
            }

        } else {

            if (!File) {
                printf ("Unexcepted parameter %s\n", argv[0]);
                Abort();
            }

            //
            // Open the file
            //

            File->FileName = argv[0];
            File->FileHandle = OpenFile(argv[0], &OpenBuf, OF_READ);
            if (File->FileHandle == HFILE_ERROR) {
                FAbort ("Can not open", File);
            }

            File->FileSize = GetFileSize(File->FileHandle, NULL);

            //
            // Map it
            //

            File->MapHandle =
                CreateFileMapping(
                    File->FileHandle,
                    NULL,
                    PAGE_READONLY,
                    0,
                    File->FileSize,
                    NULL
                    );

            if (!File->MapHandle) {
                FAbort ("Can not map", File);
            }

            File->Image =
                MapViewOfFile (
                    File->MapHandle,
                    FILE_MAP_READ,
                    0,
                    0,
                    File->FileSize
                    );

            if (!File->Image) {
                FAbort ("Can not map view of image", File);
            }
            File->EndOfImage = File->Image + File->FileSize;
            File->Opened = TRUE;

            //
            // Next file param
            //
            File = NULL;
        }

    }

    //
    // At least a update image is needed
    //

    if (!Orig.Opened) {
        Abort ();
    }

    ArgsParsed = TRUE;
    return ;
}

PVOID
MEMORY_ALLOCATE(
    ULONG   Num
    )
{
    return malloc( Num );
}

VOID
MEMORY_COPY(
    PVOID   Dest,
    PVOID   Src,
    ULONG   Length
    )
{
    memcpy( Dest, Src, Length);
}

VOID
MEMORY_FREE(
    PVOID   Dest
    )
{
    free( Dest );
}

VOID
MEMORY_SET(
    PVOID   Src,
    UCHAR   Value,
    ULONG   Length
    )
{
    memset(Src, Value, Length );
}

VOID
MEMORY_ZERO(
    PVOID   Src,
    ULONG   Length
    )
{
    memset( Src, 0, Length );
}

VOID
PRINTF(
    PUCHAR  String,
    ...
    )
{
    va_list ap;

    va_start( ap, String );
    vprintf( String, ap );
    va_end( ap );
}

ULONG
STRING_LENGTH(
    PUCHAR  String
    )
{
    return strlen( String );
}

VOID
STRING_PRINT(
    PUCHAR  Buffer,
    PUCHAR  String,
    ...
    )
{
    va_list ap;

    va_start( ap, String );
    vsprintf( Buffer, String, ap );
    va_end( ap );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\acpisim.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 acpisim.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_ACPISIM_H_)
#define _ACPISIM_H_

//
// includes
//

#include "asimlib.h"


//
// State definitions for PNP
//

typedef enum {
    PNP_STATE_INITIALIZING = 0,
    PNP_STATE_STARTED,
    PNP_STATE_STOPPED,
    PNP_STATE_REMOVED,
    PNP_STATE_SURPRISE_REMOVAL,
    PNP_STATE_STOP_PENDING,
    PNP_STATE_REMOVE_PENDING
} PNP_STATE;

//
// State definitions for Power
//

typedef enum {
    POWER_STATE_WORKING = 0,
    POWER_STATE_POWER_PENDING,
    POWER_STATE_POWERED_DOWN
} PWR_STATE;

//
// Device extension flag types
//

typedef enum {
    DE_FLAG_INTERFACE_REGISTERED = 1,
    DE_FLAG_INTERFACE_ENABLED = 2,
    DE_FLAG_OPREGION_REGISTERED = 4
} DEV_EXT_FLAGS;

//
// Global driver object extension definition
//

typedef struct _DRIVER_OBJECT_EXTENSION {
    UNICODE_STRING      RegistryPath;
    PDRIVER_OBJECT      DriverObject;
} DRIVER_OBJECT_EXTENSION, *PDRIVER_OBJECT_EXTENSION;

//
// Device extension definition
//

typedef struct _DEVICE_EXTENSION {
    ULONG               Signature;
    PNP_STATE           PnpState;
    PWR_STATE           PowerState;
    DEVICE_POWER_STATE  DevicePowerState;
    ULONG               OperationsInProgress;
    ULONG               OutstandingIrpCount;
    ULONG               HandleCount;
    UNICODE_STRING      InterfaceString;
    KEVENT              IrpsCompleted;
    PDEVICE_OBJECT      NextDevice;
    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      Pdo;
    DEVICE_POWER_STATE  PowerMappings [6];
    IO_REMOVE_LOCK      RemoveLock;

    //
    // Project specific fields
    //
    
    DEV_EXT_FLAGS       Flags;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Irp dispatch routine handler function prototype
//

typedef
NTSTATUS
(*PIRP_DISPATCH_ROUTINE) (
                            IN PDEVICE_OBJECT   DeviceObject,
                            IN PIRP             Irp
                         );
//
// Irp dispatch table definition
//

typedef struct _IRP_DISPATCH_TABLE {
    ULONG                   IrpFunction;
    TCHAR                   IrpName[50];
    PIRP_DISPATCH_ROUTINE   IrpHandler;
} IRP_DISPATCH_TABLE, *PIRP_DISPATCH_TABLE;

//
// Public function prototypes
//

#endif // _ACPISIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\dispatch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 dispatch.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Pnp / Power handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:

           
Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"

//
// Specific includes
//

#include "acpisim.h"
#include "dispatch.h"
#include "util.h"

//
// Private function prototypes
//

NTSTATUS
AcpisimPnpStartDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpCancelStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpCancelRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpSurpriseRemoval
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPnpQueryCapabilities
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerQueryPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerSetPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimPowerSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimQueryPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimSetPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimCompletionRoutine
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

NTSTATUS
AcpisimForwardIrpAndWait
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimIssuePowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

NTSTATUS
AcpisimCompleteSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
AcpisimD0Completion
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );

VOID
AcpisimInitDevPowerStateTable 
    (
        IN PDEVICE_OBJECT   DeviceObject
    );


//
// Pnp minor dispatch table
//

IRP_DISPATCH_TABLE PnpDispatchTable[] = {
    IRP_MN_START_DEVICE,        "Pnp/START_DEVICE",         AcpisimPnpStartDevice,
    IRP_MN_STOP_DEVICE,         "Pnp/STOP_DEVICE",          AcpisimPnpStopDevice,
    IRP_MN_QUERY_STOP_DEVICE,   "Pnp/QUERY_STOP_DEVICE",    AcpisimPnpQueryStopDevice,
    IRP_MN_CANCEL_STOP_DEVICE,  "Pnp/CANCEL_STOP_DEVICE",   AcpisimPnpCancelStopDevice,
    IRP_MN_REMOVE_DEVICE,       "Pnp/REMOVE_DEVICE",        AcpisimPnpRemoveDevice,
    IRP_MN_QUERY_REMOVE_DEVICE, "Pnp/QUERY_REMOVE_DEVICE",  AcpisimPnpQueryRemoveDevice,
    IRP_MN_CANCEL_REMOVE_DEVICE,"Pnp/CANCEL_REMOVE_DEVICE", AcpisimPnpCancelRemoveDevice,
    IRP_MN_SURPRISE_REMOVAL,    "Pnp/SURPRISE_REMOVAL",     AcpisimPnpSurpriseRemoval,
    IRP_MN_QUERY_CAPABILITIES,  "Pnp/QUERY_CAPABILITIIES",  AcpisimPnpQueryCapabilities
};

//
// Power minor dispatch table
//

IRP_DISPATCH_TABLE PowerDispatchTable[] = {
    IRP_MN_QUERY_POWER,         "Power/QUERY_POWER",        AcpisimPowerQueryPower,
    IRP_MN_SET_POWER,           "Power/SET_POWER",          AcpisimPowerSetPower
};

NTSTATUS
AcpisimDispatchPnp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the pnp IRP handler.  It checks the minor code,
    and passes on to the appropriate minor handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchPnp.\n");

    while (count < sizeof (PnpDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MinorFunction == PnpDispatchTable[count].IrpFunction) {
            DBG_PRINT (DBG_INFO,
                       "Recognized PnP IRP 0x%x '%s'.\n",
                       irpsp->MinorFunction,
                       PnpDispatchTable[count].IrpName);

            status = PnpDispatchTable[count].IrpHandler (DeviceObject, Irp);

            goto EndAcpisimDispatchPnp;
        }
        
        count ++;
    }

    DBG_PRINT (DBG_INFO, "Unrecognized PnP IRP 0x%x, pass it on.\n", irpsp->MinorFunction);
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (deviceextension->NextDevice, Irp);
    
EndAcpisimDispatchPnp:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchPnp.\n");
    return status;
}

NTSTATUS
AcpisimDispatchPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the power IRP handler.  It checks the minor code,
    and passes on to the appropriate minor handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchPower.\n");

    while (count < sizeof (PowerDispatchTable) / sizeof (IRP_DISPATCH_TABLE)) {

        if (irpsp->MinorFunction == PowerDispatchTable[count].IrpFunction) {
            DBG_PRINT (DBG_INFO,
                       "Recognized Power IRP 0x%x '%s'.\n",
                       irpsp->MinorFunction,
                       PowerDispatchTable[count].IrpName);

            status = PowerDispatchTable[count].IrpHandler (DeviceObject, Irp);

            goto EndAcpisimDispatchPower;
        }

        count ++;
    }

    DBG_PRINT (DBG_INFO, "Unrecognized Power IRP 0x%x, pass it on.\n", irpsp->MinorFunction);
    
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (deviceextension->NextDevice, Irp);
    
EndAcpisimDispatchPower:

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchPower.\n");
    return status;
}

NTSTATUS
AcpisimPnpStartDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Start Device handler.  It enables the device interface
    and registers the operation region handler.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_START_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    KIRQL               oldirql;
    
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpStartDevice.\n");
    
    //
    // We handle this IRP on the way back up.
    //
    
    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if ((status != STATUS_SUCCESS && status != STATUS_PENDING) || !NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_ERROR,
                   "Error processing, or lower driver failed start IRP.  IoCallDriver = %lx, Irp->IoStatus.Status = %lx\n",
                   status,
                   Irp->IoStatus.Status);

        goto EndAcpisimPnpStartDevice;
    }

    //
    // Check to see if we are already started.  If we are,
    // just return success since we aren't using resources
    // anyway.
    //
    
    if (deviceextension->PnpState == PNP_STATE_STARTED) {

        status = STATUS_SUCCESS;
        goto EndAcpisimPnpStartDevice;
    }

    //
    // Enable our device interface
    //
    
    status = AcpisimEnableDisableDeviceInterface (DeviceObject, TRUE);

    ASSERT (NT_SUCCESS (status));
    
    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "Error enabling device interface.  Fail the start. Status = %lx.\n",
                   status);

        Irp->IoStatus.Status = status;
        
        goto EndAcpisimPnpStartDevice;
    }

    AcpisimSetDevExtFlags (DeviceObject, DE_FLAG_INTERFACE_ENABLED);

    //
    // Typically, we would check the state of our hardware, and
    // set our internal power state to reflect the current state
    // of the hardware.  However, in this case we are a virtual
    // device, and it is safe to assume we are in D0 when we
    // receive IRP_MN_START_DEVICE.
    //

    AcpisimUpdatePowerState (DeviceObject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (DeviceObject, PowerDeviceD0);

    //
    // Finally, we can register our operation region handler.
    //

    status = AcpisimRegisterOpRegionHandler (DeviceObject);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "Couldn't register op region handler (%lx).  Fail start IRP.\n",
                   status);

        goto EndAcpisimPnpStartDevice;
    }

    AcpisimSetDevExtFlags (DeviceObject, DE_FLAG_OPREGION_REGISTERED);


EndAcpisimPnpStartDevice:
       
    //
    // If we completed the start successfully, change our pnp state
    // to PNP_STARTED
    //

    if (NT_SUCCESS (status)) {

        AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);
        
    } else {

        AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOPPED);
    }

    //
    // Because we are handling this IRP "on the way up", we need
    // to complete it when we are done working with it.
    //
    
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpStartDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
/*++

Routine Description:

    This is the Pnp Stop Device handler.  It checks to see if
    there are any outstanding requests, and fails the stop IRP 
    if there are.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_STOP_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpStopDevice.\n");
    
    //
    // BUGBUG - We currently don't handle the case where
    // there is still an outstanding request at stop
    // time.  If we were to do things correctly, we'd 
    // complete any outstanding requests in the driver
    // with an appropriate error code.  In this 
    // particular case, if a request happened to squeak
    // by our check at QUERY STOP time, it is likely
    // the request would not be completed at all.
    //

    //
    // Oh, and we had better not have LESS then 2 count
    // or we've got a bug somewhere.
    //

    if (deviceextension->OutstandingIrpCount < 2) {
        DBG_PRINT (DBG_WARN,
               "Possible internal consistency error - OutstandingIrpCount too low.\n");
    }
    
    ASSERT (deviceextension->OutstandingIrpCount == 2);
    
    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_STOP forwarding failed (%lx).\n",
                   status);

        goto EndAcpisimPnpStopDevice;
    }

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOPPED);
    
EndAcpisimPnpStopDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpStopDevice.\n");

    return status;
}

NTSTATUS
AcpisimPnpQueryStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Query Stop Device handler.  If there are any
    outstanding requests, it vetos the IRP.
    
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP_MN_QUERY_STOP_DEVICE processing

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryStopDevice.\n");
    
    //
    // Let existing IRPs in the driver complete before we say OK.
    // But to do this, we need to get the OutstandingIrpsCount
    // right.  Subtract 2 since we are biased to 1, and we have an
    // additional 1 for the QUERY_STOP IRP.
    //

    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);
    
    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);
    
    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "KeWaitForSingleObject failed (%lx). IRP_MN_QUERY_STOP failed.\n",
                   status);

        IoSkipCurrentIrpStackLocation (Irp);
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        status = IoCallDriver (deviceextension->NextDevice, Irp);

        ASSERT (NT_SUCCESS (status));

        goto EndPnpQueryStopDevice;
    }
    
    //
    // We can stop - change our state to stopping, and pass it on.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STOP_PENDING);

EndPnpQueryStopDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryStopDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpCancelStopDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Cancel Stop Device handler.  It does nothing
    more then returns the pnp state to started.  This is a virtual
    device so there is no work to do.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpCancelStopDevice.\n");

    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_CANCEL_STOP forwarding failed (%lx).\n",
                   status);

        goto EndPnpCancelStopDevice;
    }
    
    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);

EndPnpCancelStopDevice:

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpCancelStopDevice.\n");

    return status;
}

NTSTATUS
AcpisimPnpRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Remove Device handler.  It de-registers the
    operation region handler, detaches the device object, and
    deletes it if all goes well.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    status of removal operation

--*/


{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PDEVICE_OBJECT      nextdevice = deviceextension->NextDevice;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpRemoveDevice.\n");
    
    //
    // BUGBUG - We currently don't handle the case where
    // there is still an outstanding request at remove
    // time.  If we were to do things correctly, we'd 
    // complete any outstanding requests in the driver
    // with an appropriate error code.  In this 
    // particular case, if a request happened to squeak
    // by our check at QUERY REMOVE time, it is likely
    // the request would not be completed at all.
    //
    
    //
    // Our OutstandingIrpCount logic is biased to 1.  So
    // if we are processing a remove IRP, and there are
    // no other requests in the driver, OustandingIrpCount
    // had better be 2.
    
    if (deviceextension->OutstandingIrpCount < 2) {
        DBG_PRINT (DBG_WARN,
               "Possible internal consistency error - OutstandingIrpCount too low.\n");
    }
    
    ASSERT (deviceextension->OutstandingIrpCount == 2);

    //
    // Ok, we are ready to remove the device.  Shut down the
    // interface, deregister the opregion handler, and
    // delete the device object.
    //

    status = AcpisimEnableDisableDeviceInterface (DeviceObject, FALSE);

    ASSERT (NT_SUCCESS (status));

    if (NT_SUCCESS (status)) {

        AcpisimClearDevExtFlags (DeviceObject, DE_FLAG_INTERFACE_ENABLED);
    }

    status = AcpisimUnRegisterOpRegionHandler (DeviceObject);

    ASSERT (NT_SUCCESS (status));

    if (NT_SUCCESS (status)) {

        AcpisimClearDevExtFlags (DeviceObject, DE_FLAG_OPREGION_REGISTERED);
    }
    
    RtlFreeUnicodeString (&deviceextension->InterfaceString);

    IoDetachDevice (deviceextension->NextDevice);
    IoDeleteDevice (DeviceObject);

    //
    // Now, pass it on...
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (nextdevice, Irp);

    ASSERT (NT_SUCCESS (status));
    if (!NT_SUCCESS (status)) {
        
        DBG_PRINT (DBG_ERROR,
                   "Passing remove IRP onto next driver failed for some reason (%lx).\n",
                   status);
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpRemoveDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpQueryRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Query Remove Device handler.  It waits for
    existing requests in the driver to finish, and then completes
    the IRP successfully.
            
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status of query remove device operation

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryRemoveDevice.\n");

    //
    // Make sure our state is correct
    //

    ASSERT (deviceextension->OutstandingIrpCount >= 2);
    
    //
    // Let existing IRPs in the driver complete before we say OK.
    // But to do this, we need to get the OutstandingIrpsCount
    // right.  Subtract 2 since we are biased to 1, and we have an
    // additional 1 for the QUERY_STOP IRP.
    //
    
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);

    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);
    
    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "KeWaitForSingleObject failed (%lx). IRP_MN_QUERY_REMOVE failed.\n",
                   status);

        IoSkipCurrentIrpStackLocation (Irp);
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        status = IoCallDriver (deviceextension->NextDevice, Irp);

        ASSERT (NT_SUCCESS (status));

        goto EndPnpQueryRemoveDevice;
    }
    
    //
    // We can remove - change our state to remove pending, and pass it on.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_REMOVE_PENDING);

EndPnpQueryRemoveDevice:
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryRemoveDevice.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpCancelRemoveDevice
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
/*++

Routine Description:

    This is the Pnp Cancel Remove Device handler.  It does nothing
    more then returns the pnp state to started.  This is a virtual
    device so there is no work to do.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpCancelRemoveDevice.\n");

    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    ASSERT (NT_SUCCESS (status));

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR,
                   "IRP_MN_CANCEL_REMOVE forwarding failed (%lx).\n",
                   status);

        goto EndPnpCancelRemoveDevice;
    }
    
    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_STARTED);

EndPnpCancelRemoveDevice:

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpCancelRemoveDevice.\n");    

    return status;
}

NTSTATUS
AcpisimPnpSurpriseRemoval
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the Pnp Surprise Remove handler.  It basically updates
    the state, and passes the IRP on.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpSurpriseRemoval.\n");

    //
    // Again, because we are a virtual device, handling
    // surprise remove is really a no-op.  Just update
    // our state, and succeed the IRP.
    //

    AcpisimUpdatePnpState (DeviceObject, PNP_STATE_SURPRISE_REMOVAL);

    IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = IoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpSurpriseRemoval.\n");
    
    return status;
}

NTSTATUS
AcpisimPnpQueryCapabilities
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MN_QUERY_CAPABILITIES.  We need this
    information to build our power state table correctly.  All
    we do here is set a completion routine, as we need to gather this
    data after the PDO has filled out DeviceState.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status of operation

--*/


{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp;
    UCHAR               count = 0;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPnpQueryCapabilities.\n");
    
    //
    // Fill out the power mapping table with a default
    //

    AcpisimInitDevPowerStateTable (DeviceObject);
    
    //
    // Handle this IRP after the PDO has filled out the structure
    //
    
    status = AcpisimForwardIrpAndWait (DeviceObject, Irp);

    if (!NT_SUCCESS (status)) {

        DBG_PRINT (DBG_ERROR, "Somebody failed the QUERY_CAPABILITIES IRP...\n");
        goto EndAcpisimPnpQueryCapabilities;
    }

    irpsp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Update our power mappings with what we found in the device
    // capabilities structure.  We only use valid mappings, e.g.
    // PowerDeviceUnspecified is ignored.
    //
    
    DBG_PRINT (DBG_INFO, "Device mappings:\n");
    
    for (count = 0; count < 6; count ++) {

        if (irpsp->Parameters.DeviceCapabilities.Capabilities->DeviceState[count + 1] != PowerDeviceUnspecified) {

            deviceextension->PowerMappings[count] = irpsp->Parameters.DeviceCapabilities.Capabilities->DeviceState [count + 1];
        }
        
        DBG_PRINT (DBG_INFO, "S%d --> D%d\n", count, deviceextension->PowerMappings[count] - 1);    
    }

    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;

EndAcpisimPnpQueryCapabilities:

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPnpQueryCapabilities.\n");

    return status;
}

NTSTATUS
AcpisimPowerQueryPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the QUERY Power handler.  It determines if the power
    IRP is an S or D IRP, and passes it on to the proper handler.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

     DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerQueryPower.\n");
    
    switch (irpsp->Parameters.Power.Type) {
    
    case SystemPowerState:
        
        status = AcpisimPowerSIrp (DeviceObject, Irp);
        break;

    case DevicePowerState:

        status = AcpisimQueryPowerDIrp (DeviceObject, Irp);
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Undefined QUERY Power IRP type.  Ignoring.\n");

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceextension->NextDevice, Irp);
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerQueryPower.\n");
    
    return status;
}

NTSTATUS
AcpisimPowerSetPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the SET Power handler.  It determines if the power
    IRP is an S or D IRP, and passes it on to the proper handler.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerSetPower.\n");

    switch (irpsp->Parameters.Power.Type) {
    
    case SystemPowerState:
        
        status = AcpisimPowerSIrp (DeviceObject, Irp);
        break;

    case DevicePowerState:

        status = AcpisimSetPowerDIrp (DeviceObject, Irp);
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "Undefined SET Power IRP type.  Ignoring.\n");

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (deviceextension->NextDevice, Irp);
    }

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerSetPower.\n");
    
    return status;
}

NTSTATUS
AcpisimPowerSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the power handler for S IRPs.  It sets a
    completion routine, which will queue a D IRP.  We don't
    do anything unless it is a D IRP.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimPowerSIrp.\n");

    IoMarkIrpPending (Irp);	

    IoCopyCurrentIrpStackLocationToNext (Irp);
	IoSetCompletionRoutine (Irp,
                            AcpisimIssuePowerDIrp,
                            0,
                            TRUE,
                            TRUE,
                            TRUE);
	
    PoCallDriver (deviceextension->NextDevice, Irp);
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimPowerSIrp.\n");
    
    return STATUS_PENDING;
}

NTSTATUS
AcpisimQueryPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the QUERY Power DIrp handler.  Validate the state, and
    say yes.  
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    Status returned from power handler

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimQueryPowerDIrp.\n");
    
    //
    // Here, we are supposed to figure out if we can go to the
    // power state specified by the IRP.  Since we are a virtual
    // device, we don't have a good reason to not go to a different
    // power state.  Update our state, and wait to complete requests.
    //
    
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);
    AcpisimDecrementIrpCount (DeviceObject);


    status = KeWaitForSingleObject (&deviceextension->IrpsCompleted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    0);

    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    InterlockedIncrement (&deviceextension->OutstandingIrpCount);
    KeResetEvent (&deviceextension->IrpsCompleted);

    ASSERT (NT_SUCCESS (status));

    //
    // Validate the D IRP
    //

    switch (irpsp->Parameters.Power.State.DeviceState) {
    case PowerDeviceD0:
    case PowerDeviceD1:
    case PowerDeviceD2:
    case PowerDeviceD3:

        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWER_PENDING);
        status = STATUS_SUCCESS;
        break;

    default:

        ASSERT (0);
        DBG_PRINT (DBG_ERROR,
                   "AcpisimQueryPowerDIrp: Illegal or unknown PowerDeviceState.  Failing.\n");
        
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    PoStartNextPowerIrp (Irp);
	IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = status;
    status = PoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

    DBG_PRINT (DBG_INFO,
               "Leaving AcpisimQueryPowerDIrp.\n");
    
    return status;
}

NTSTATUS
AcpisimSetPowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimSetPowerDIrp.\n");
    
    //
    // Validate the D IRP
    //

    switch (irpsp->Parameters.Power.State.DeviceState) {
    
    //
    // For D0, if we are powered down, we need to pass the IRP down, and
    // set a completion routine.  We need the PDO to succeed the power
    // up before we do.
    //
    
    case PowerDeviceD0:

        if (deviceextension->PowerState != POWER_STATE_WORKING) {

            IoCopyCurrentIrpStackLocationToNext (Irp);
	        
            IoSetCompletionRoutine (Irp,
                                    AcpisimD0Completion,
                                    0,
                                    TRUE,
                                    TRUE,
                                    TRUE);
	
            IoMarkIrpPending (Irp); 
            PoCallDriver (deviceextension->NextDevice, Irp);
            status = STATUS_PENDING;
            goto EndAcpisimSetPowerDIrp;
        }
        
        break;

    case PowerDeviceD1:
        
        powerstate.DeviceState = PowerDeviceD1;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
        
        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    case PowerDeviceD2:
        
        powerstate.DeviceState = PowerDeviceD2;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);

        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    case PowerDeviceD3:
        
        powerstate.DeviceState = PowerDeviceD3;
        PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
        
        AcpisimUpdatePowerState (DeviceObject, POWER_STATE_POWERED_DOWN);
        AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);
        status = STATUS_SUCCESS;
        break;

    default:

        ASSERT (0);
        DBG_PRINT (DBG_ERROR,
                   "AcpisimSetPowerDIrp: Illegal or unknown PowerDeviceState.  Failing.\n");
        
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    PoStartNextPowerIrp (Irp);
	IoSkipCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Status = status;
    status = PoCallDriver (deviceextension->NextDevice, Irp);

    ASSERT (NT_SUCCESS (status));

EndAcpisimSetPowerDIrp:

    DBG_PRINT (DBG_INFO,
               "Leaving AcpisimSetPowerDIrp.\n");

    return status;
}

NTSTATUS
AcpisimCompletionRoutine
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the generic Irp completion routine for when we
    want to wait for an IRP to be completed by the PDO and
    do post-completion work.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP
    
    Context - Context passed in by IoSetCompletionRoutine.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    DBG_PRINT (DBG_INFO,
               "Entering AcpisimCompletionRoutine.\n");

    KeSetEvent (Context, 0, FALSE);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimCompletionRoutine.\n");

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AcpisimForwardIrpAndWait
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This forwards the IRP down the device stack, sets
    a completion routine, and waits on the completion
    event. Useful for doing IRP post-completion, based
    on the result of the completion.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    The status set in the IRP when the IRP was completed.

--*/

{
    KEVENT              context;
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimForwardIrpAndWait.\n");
    
    KeInitializeEvent (&context, SynchronizationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            AcpisimCompletionRoutine,
                            &context,
                            TRUE,
                            TRUE,
                            TRUE);

    status = IoCallDriver (deviceextension->NextDevice, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject (&context,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        status = Irp->IoStatus.Status;
    }

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimForwardIrpAndWait.\n");

    return status;
}

NTSTATUS
AcpisimIssuePowerDIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the S-IRP completion routine.  It examines the completed
    IRP, and if there are no problems, asks the power manager to 
    send us the appropriate D-IRP.
        
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

    Context - Context passed into IoSetCompletionRoutine
    
Return Value:

    Status of requesting D-IRP operation.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;
    PPOWER_CONTEXT      context = NULL;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimIssuePowerDIrp.\n");
    
    powerstate.DeviceState = PowerDeviceUnspecified;

    //
    // Make sure this IRP wasn't failed by the PDO or Lower FFDO
    //

    if (!NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_INFO,
                   "AcpisimIssuePowerDIrp:  Lower FFDO, BFDO, or PDO failed this IRP (%lx).\n",
                   status);

        status = Irp->IoStatus.Status;
        
        goto EndAcpisimIssuePowerDIrp;
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {

        //
        // Ok, everybody is agreeing to this S state.  Send ourselves
        // the appropriate D IRP.
        //
        
        //
        // Make sure this is an S Irp
        //

        ASSERT (irpsp->Parameters.Power.Type == SystemPowerState);

        if (irpsp->Parameters.Power.Type != SystemPowerState) {

            DBG_PRINT (DBG_ERROR,
                       "Didn't recieve an S Irp when we expected to, or somebody messed up the IRP.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;

            goto EndAcpisimIssuePowerDIrp;
        }

        ASSERT (irpsp->MinorFunction == IRP_MN_QUERY_POWER || irpsp->MinorFunction == IRP_MN_SET_POWER);
        
        if (irpsp->MinorFunction != IRP_MN_QUERY_POWER && irpsp->MinorFunction != IRP_MN_SET_POWER) {

            DBG_PRINT (DBG_ERROR,
                       "Irp isn't SET or QUERY.  Not sure why this wasn't caught earlier (somebody probably messed it up).\nWe don't support any other type.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;

            goto EndAcpisimIssuePowerDIrp;
        }

        //
        // Make sure the S IRP is valid
        //

        if (irpsp->Parameters.Power.State.SystemState >= PowerSystemMaximum) {
            
            ASSERT (0);

            DBG_PRINT (DBG_ERROR,
                       "Received an undefined S IRP, or somebody messed up the IRP.  Fail it.\n");

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto EndAcpisimIssuePowerDIrp;
        }

        //
        // Use our power mapping table to convert S-->D state
        //
        
        powerstate.DeviceState = deviceextension->PowerMappings [irpsp->Parameters.Power.State.SystemState - 1];

        DBG_PRINT (DBG_INFO,
                       "S%d --> D%d\n", irpsp->Parameters.Power.State.SystemState - 1, powerstate.DeviceState - 1);

        //
        // We need a context to pass a pointer to the S IRP to the D IRP handler
        // and a pointer to the device object.
        //
        
        context = ExAllocatePoolWithTag (NonPagedPool,
                                         sizeof (POWER_CONTEXT)+4,
                                         POWER_CONTEXT_TAG);

        if (!context) {

            DBG_PRINT (DBG_ERROR,
                       "Unable to allocate memory for the context.\n");

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto EndAcpisimIssuePowerDIrp;
        }

        context->SIrp = Irp;
        context->Context = DeviceObject;

        //
        // Send the D Irp
        //
        
        status = PoRequestPowerIrp (deviceextension->Pdo,
                                    irpsp->MinorFunction,
                                    powerstate,
                                    AcpisimCompleteSIrp,
                                    context,
                                    NULL);

        ASSERT (NT_SUCCESS (status));

        if (!NT_SUCCESS (status)) {

            DBG_PRINT (DBG_ERROR,
                       "AcpisimIssuePowerDIrp:  PoRequestPowerIrp failed (%lx).\n");

            goto EndAcpisimIssuePowerDIrp;
        }
    }

    status = STATUS_MORE_PROCESSING_REQUIRED;
    
EndAcpisimIssuePowerDIrp:
    
    //
    // We need to complete the request if something went wrong.  Also note,
    // it is not necessary to assume our state is S0/D0 again.  The power 
    // manager will send us an S0 IRP.
    //
    
    if (!NT_SUCCESS (status)  && status != STATUS_MORE_PROCESSING_REQUIRED) {

        DBG_PRINT (DBG_ERROR,
                   "AcpisimIssuePowerDIrp:  Something bad happened.  Just complete the S Irp with an error.");
        
        PoStartNextPowerIrp (Irp);    
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);

        AcpisimDecrementIrpCount (DeviceObject);
        
        if (context) {

            ExFreePool (context);
        }
    }
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimIssuePowerDIrp.\n");
    
    return status;
}

NTSTATUS
AcpisimCompleteSIrp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This is the S-Irp completion routine set by PoRequestPowerIrp.
        
Arguments:

    DeviceObject - pointer to the FDO
    
    MinorFunction - type of request
    
    PowerState - type of IRP
    
    Context - Context passed into PoRequestPowerIrp
    
    IoStatus - IoStatus block of completed D Irp

    
Return Value:

    STATUS_SUCCESS

--*/

{
    PPOWER_CONTEXT      context = (PPOWER_CONTEXT) Context;
    PDEVICE_OBJECT      deviceobject = context->Context;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (deviceobject);
    PIRP                sirp = context->SIrp;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimCompleteSIrp.\n");

    //
	// Propagate the device power IRP's status in the system power IRP
	//

	sirp->IoStatus.Status = IoStatus->Status;

    //
	// Tell the power manager we are done with this IRP
	//

	PoStartNextPowerIrp (sirp);
	
    IoCompleteRequest (sirp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceextension->RemoveLock, sirp);
    ExFreePool (Context);

    //
    // Normally our dispatch routine decrements IRP counts,
    // but since it was returned STATUS_PENDING, it wasn't
    // decremented earlier
    //

    AcpisimDecrementIrpCount (deviceobject);

    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimCompleteSIrp.\n");

    return STATUS_SUCCESS;
}

NTSTATUS
AcpisimD0Completion
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    )

/*++

Routine Description:

    This is the D0 Irp completion routine
        
Arguments:

    DeviceObject - pointer to the FDO
    
    MinorFunction - type of request
    
    Context - Context passed into IoSetCompletionRoutine
    
    
Return Value:

    Error status or STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    POWER_STATE         powerstate;

    DBG_PRINT (DBG_INFO,
               "Entering AcpisimD0Completion.\n");
    
    //
    // Make sure this IRP wasn't failed by the PDO or Lower FFDO
    //

    if (!NT_SUCCESS (Irp->IoStatus.Status)) {

        DBG_PRINT (DBG_INFO,
                   "AcpisimD0Completion:  Lower FFDO, BFDO, or PDO failed this IRP (%lx).\n",
                   status);
        
        status = Irp->IoStatus.Status;
        
        goto EndAcpisimD0Completion;
    }

    //
    // This is where we do actual D0 transition work.  Since this
    // is a virtual device, the only thing we do is change our
    // internal state.
    //

    AcpisimUpdatePowerState (DeviceObject, POWER_STATE_WORKING);
    AcpisimUpdateDevicePowerState (DeviceObject, irpsp->Parameters.Power.State.DeviceState);

    powerstate.DeviceState = PowerDeviceD0;
    PoSetPowerState (DeviceObject, DevicePowerState, powerstate);
    
    status = STATUS_MORE_PROCESSING_REQUIRED;
    
EndAcpisimD0Completion:

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceextension->RemoveLock, Irp);
    AcpisimDecrementIrpCount (DeviceObject);
    
    DBG_PRINT (DBG_INFO,
               "Exiting AcpisimD0Completion.\n");

    return status;

}

VOID
AcpisimInitDevPowerStateTable 
    (
        IN PDEVICE_OBJECT   DeviceObject
    )

/*++

Routine Description:

    This routine fills out the power mapping structure with defaults.
    We simply default to using D3 in any non-S0 state.
        
Arguments:

    DeviceObject - pointer to the FDO
    
Return Value:

    None

--*/

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    UCHAR   count;

    deviceextension->PowerMappings[0] = PowerDeviceD0;

    for (count = 1; count < 5; count ++) {

        deviceextension->PowerMappings[count] = PowerDeviceD3;
    }
}

NTSTATUS AcpisimDispatchIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for IOCTL requests.  We just call the supplied
    function to handle the IOCTL, or pass it on if the handler doesn't
    handle it.
    
Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    PIO_STACK_LOCATION  irpsp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    ULONG               count = 0;
    
    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchIoctl\n");

    status = AcpisimHandleIoctl (DeviceObject, Irp);

    if (status == STATUS_NOT_SUPPORTED) {

        //
        // IOCTL wasn't handled, pass it on...
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), Irp);

    } else {

        //
        // IOCTL was handled, complete it.
        //

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchIoctl\n");
    return status;
}

NTSTATUS
AcpisimDispatchSystemControl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for System Control requests. Since we currently
    don't support any System Control calls, we are just going to pass
    them on to the next driver.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IoCallDriver

--*/

{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    DBG_PRINT (DBG_INFO, "Entering AcpisimDispatchSystemControl\n");
    
    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (AcpisimLibGetNextDevice (DeviceObject), Irp);

    DBG_PRINT (DBG_INFO, "Exiting AcpisimDispatchSystemControl\n");

    return status;
}

NTSTATUS AcpisimCreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the handler for CreateFile and CloseHandle requests.
    We do nothing except update our internal extension to track
    the number of outstanding handles.

Arguments:

    DeviceObject - pointer to the device object the IRP pertains to

    Irp - pointer to the IRP

Return Value:

    result of IRP processing

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION      irpsp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_EXTENSION       deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    ASSERT (irpsp->MajorFunction == IRP_MJ_CREATE || irpsp->MajorFunction == IRP_MJ_CLOSE);

    switch (irpsp->MajorFunction) {
    
    case IRP_MJ_CREATE:
        InterlockedIncrement (&deviceextension->HandleCount);
        status = STATUS_SUCCESS;
        break;

    case IRP_MJ_CLOSE:
        InterlockedDecrement (&deviceextension->HandleCount);
        status = STATUS_SUCCESS;
        break;

    default:

        DBG_PRINT (DBG_ERROR,
                   "AcpisimCreateClose - unexpected Irp type.\n");

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, 0);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\dispatch.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 pnppower.h

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Pnp / Power handler module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

#if !defined(_PNPPOWER_H_)
#define _PNPPOWER_H_

//
// Power context structure
//

typedef struct _POWER_CONTEXT {

    PIRP    SIrp;
    PVOID   Context;
} POWER_CONTEXT, *PPOWER_CONTEXT;

#define POWER_CONTEXT_TAG   'misA'

//
// External functions
//

extern
NTSTATUS
AcpisimRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

extern
NTSTATUS
AcpisimUnRegisterOpRegionHandler
    (
        IN PDEVICE_OBJECT DeviceObject
    );

extern
NTSTATUS
AcpisimHandleIoctl
    (
        IN PDEVICE_OBJECT   DeviceObject,
        IN PIRP             Irp
    );

//
// Public function prototypes
//

NTSTATUS
AcpisimDispatchPnp
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimDispatchPower
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS 
AcpisimDispatchIoctl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS
AcpisimDispatchSystemControl
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

NTSTATUS 
AcpisimCreateClose
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
    );

#endif // _PNPPOWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpisim\lib\util.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

	 util.c

Abstract:

	 ACPI BIOS Simulator / Generic 3rd Party Operation Region Provider
     Utility module

Author(s):

	 Vincent Geglia
     Michael T. Murphy
     Chris Burgess
     
Environment:

	 Kernel mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include "ntddk.h"

//
// Specific includes
//

#include "acpisim.h"
#include "util.h"

//
// Private function prototypes
//

VOID
AcpisimSetDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    )

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->Flags &= Flags;
    
}

VOID
AcpisimClearDevExtFlags
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEV_EXT_FLAGS Flags
    )

{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->Flags &= ~Flags;
    
}

VOID
AcpisimUpdatePnpState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PNP_STATE PnpState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->PnpState = PnpState;

}

VOID
AcpisimUpdateDevicePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN DEVICE_POWER_STATE DevicePowerState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->DevicePowerState = DevicePowerState;
    
}

VOID
AcpisimUpdatePowerState
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN PWR_STATE PowerState
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    
    deviceextension->PowerState = PowerState;
    
}

NTSTATUS
AcpisimEnableDisableDeviceInterface
    (
        IN PDEVICE_OBJECT DeviceObject,
        IN BOOLEAN Enable
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    status = IoSetDeviceInterfaceState (&deviceextension->InterfaceString, Enable);

    return status;
}

VOID
AcpisimDecrementIrpCount
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = AcpisimGetDeviceExtension (DeviceObject);

    if (!deviceextension->OutstandingIrpCount) {

        DBG_PRINT (DBG_ERROR, "*** Internal consistency error - AcpisimDecrementIrpCount called with OutstandingIrpCount at 0!\n");
    }

    if (!InterlockedDecrement (&deviceextension->OutstandingIrpCount)) {

        DBG_PRINT (DBG_INFO, "All IRPs cleared - remove event signalled.\n");
        KeSetEvent (&deviceextension->IrpsCompleted, 0, FALSE);
    }

    return;
}

PDEVICE_EXTENSION
AcpisimGetDeviceExtension
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = DeviceObject->DeviceExtension;

    //
    // Check to make sure it is OUR extension
    //

    ASSERT (deviceextension->Signature == ACPISIM_TAG);

    return deviceextension;
}

PDEVICE_OBJECT
AcpisimLibGetNextDevice
    (
        PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceextension = DeviceObject->DeviceExtension;

    //
    // Check to make sure it is OUR extension
    //

    ASSERT (deviceextension->Signature == ACPISIM_TAG);

    return deviceextension->NextDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiuasm\acpiuasm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpiuasm.h

Abstract:

    Test wrapper for the unassembler

Author:

    Stephane Plante
    Based on code by Ken Reneris

Environment:

    User

Revision History:

--*/

#ifndef _ACPIUASM_H_
#define _ACPIUASM_H_

    #include <windows.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdarg.h>

    #define DATA_SIZE   7*1024      // max value to write into registry

    typedef struct _DSDT {
        ULONG       Signature;
        ULONG       Length;
        UCHAR       Revision;
        UCHAR       Checksum;
        UCHAR       OemID[6];
        UCHAR       OemTableID[8];
        UCHAR       OemRevision[4];
        UCHAR       CreatorID[4];
        UCHAR       CreatorRevision[4];
    } DSDT, *PDSDT;


    typedef struct _IFILE {
        BOOLEAN     Opened;
        PUCHAR      Desc;
        PUCHAR      FileName;
        HANDLE      FileHandle;
        HANDLE      MapHandle;
        ULONG       FileSize;
        PUCHAR      Image;
        PUCHAR      EndOfImage;

        PUCHAR      OemID;
        PUCHAR      OemTableID;
        UCHAR       OemRevision[4];
    } IFILE, *PIFILE;

    //
    // External references
    //
    extern
    ULONG
    ScopeParser(
        IN  PUCHAR  String,
        IN  ULONG   Length,
        IN  ULONG   BaseAddress,
        IN  ULONG   IndentLevel
        );

    //
    // Internal prototypes
    //
    VOID
    ParseArgs (
        IN int  argc,
        IN char *argv[]
        );

    VOID
    CheckImageHeader (
        IN PIFILE   File
        );

    VOID
    FAbort (
        PUCHAR  Text,
        PIFILE  File
        );

    VOID
    Abort (
        VOID
        );

    PUCHAR
    FixString (
        IN PUCHAR   Str,
        IN ULONG    Len
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\cmdarg.c ===
/*** cmdarg.c - Command argument parsing functions
 *
 *  This module contains all the debug functions.
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/18/96
 *
 *  MODIFICATION HISTORY
 */


#include "pch.h"

#ifdef DEBUGGER

/*** Local function prototypes
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs);
PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs);

/*** Local data
 */

PSZ pszSwitchChars = "-/";
PSZ pszOptionSeps = "=:";

/***EP  DbgParseArgs - parse command arguments
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      pdwNumArgs -> to hold the number of arguments parsed
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *      pszTokenSeps -> token separator characters string
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseArgs(PCMDARG ArgTable, PULONG pdwNumArgs,
                        PULONG pdwNonSWArgs, PSZ pszTokenSeps)
{
    LONG rc = ARGERR_NONE;
    PSZ psz;

    *pdwNumArgs = 0;
    *pdwNonSWArgs = 0;
    while ((psz = STRTOK(NULL, pszTokenSeps)) != NULL)
    {
        (*pdwNumArgs)++;
        if ((rc = DbgParseOneArg(ArgTable, psz, *pdwNumArgs, pdwNonSWArgs)) !=
            ARGERR_NONE)
        {
            break;
        }
    }

    return rc;
}       //DbgParseArgs

/***LP  DbgParseOneArg - parse one command argument
 *
 *  ENTRY
 *      pArgs -> command argument table
 *      psz -> argument string
 *      dwArgNum - argument number
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns ARGERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL DbgParseOneArg(PCMDARG ArgTable, PSZ psz, ULONG dwArgNum,
                          PULONG pdwNonSWArgs)
{
    LONG rc = ARGERR_NONE;
    PCMDARG pArg;
    PSZ pszEnd;

    if ((pArg = DbgMatchArg(ArgTable, &psz, pdwNonSWArgs)) != NULL)
    {
        switch (pArg->dwArgType)
        {
            case AT_STRING:
            case AT_NUM:
                if (pArg->dwfArg & AF_SEP)
                {
                    if ((*psz != '\0') &&
                        (STRCHR(pszOptionSeps, *psz) != NULL))
                    {
                        psz++;
                    }
                    else
                    {
                        ARG_ERROR(("argument missing option separator - %s",
                                   psz));
                        rc = ARGERR_SEP_NOT_FOUND;
                        break;
                    }
                }

                if (pArg->dwArgType == AT_STRING)
                {
                    *((PSZ *)pArg->pvArgData) = psz;
                }
                else
                {
                    *((PLONG)pArg->pvArgData) =
                        STRTOL(psz, &pszEnd, pArg->dwArgParam);
                    if (psz == pszEnd)
                    {
                        ARG_ERROR(("invalid numeric argument - %s", psz));
                        rc = ARGERR_INVALID_NUMBER;
                        break;
                    }
                }

                if (pArg->pfnArg != NULL)
                {
                    rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (pArg->dwArgType == AT_ENABLE)
                    *((PULONG)pArg->pvArgData) |= pArg->dwArgParam;
                else
                    *((PULONG)pArg->pvArgData) &= ~pArg->dwArgParam;

                if ((pArg->pfnArg != NULL) &&
                    (pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs) !=
                     ARGERR_NONE))
                {
                    break;
                }

                if (*psz != '\0')
                {
                    rc = DbgParseOneArg(ArgTable, psz, dwArgNum, pdwNonSWArgs);
                }
                break;

            case AT_ACTION:
                ASSERT(pArg->pfnArg != NULL);
                rc = pArg->pfnArg(pArg, psz, dwArgNum, *pdwNonSWArgs);
                break;

            default:
                ARG_ERROR(("invalid argument table"));
                rc = ARGERR_ASSERT_FAILED;
        }
    }
    else
    {
        ARG_ERROR(("invalid command argument - %s", psz));
        rc = ARGERR_INVALID_ARG;
    }

    return rc;
}       //DbgParseOneArg

/***LP  DbgMatchArg - match argument type from argument table
 *
 *  ENTRY
 *      ArgTable -> argument table
 *      ppsz -> argument string pointer
 *      pdwNonSWArgs -> to hold the number of non-switch arguments parsed
 *
 *  EXIT-SUCCESS
 *      returns pointer to argument entry matched
 *  EXIT-FAILURE
 *      returns NULL
 */

PCMDARG LOCAL DbgMatchArg(PCMDARG ArgTable, PSZ *ppsz, PULONG pdwNonSWArgs)
{
    PCMDARG pArg;

    for (pArg = ArgTable; pArg->dwArgType != AT_END; pArg++)
    {
        if (pArg->pszArgID == NULL)     //NULL means match anything.
        {
            (*pdwNonSWArgs)++;
            break;
        }
        else
        {
            ULONG dwLen;

            if (STRCHR(pszSwitchChars, **ppsz) != NULL)
                (*ppsz)++;

            dwLen = STRLEN(pArg->pszArgID);
            if (StrCmp(pArg->pszArgID, *ppsz, dwLen,
                       (BOOLEAN)((pArg->dwfArg & AF_NOI) != 0)) == 0)
            {
                (*ppsz) += dwLen;
                break;
            }
        }
    }

    if (pArg->dwArgType == AT_END)
        pArg = NULL;

    return pArg;
}       //DbgMatchArg

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiwake\makefile.inc ===
obj\$(TARGET_DIRECTORY)\acpiwake.res: acpiwake.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\inc\parsearg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.h

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#ifndef _PARSEARG_H_
#define _PARSEARG_H_

//
// Error Codes
//
#define ARGERR_NONE             0
#define ARGERR_UNKNOWN_SWITCH   1
#define ARGERR_NO_SEPARATOR     2
#define ARGERR_INVALID_NUM      3
#define ARGERR_INVALID_TAIL     4

//
// Parsing options
//
#define DEF_SWITCHCHARS         "/-"
#define DEF_SEPARATORS          ":="

//
// Argument types
//
#define AT_STRING       1
#define AT_NUM          2
#define AT_ENABLE       3
#define AT_DISABLE      4
#define AT_ACTION       5

//
// Parse flags
//
#define PF_NOI          0x0001  //No-Ignore-Case
#define PF_SEPARATOR    0x0002  //parse for separator

//
// Type definitions
//
typedef struct _ARGTYPE ARGTYPE, *PARGTYPE;
typedef int (*PFNARG)(char **, PARGTYPE);
struct _ARGTYPE {
    UCHAR       *ArgID;         // argument ID string
    ULONG       ArgType;        // see argument types defined above
    ULONG       ParseFlags;     // see parse flags defined above
    VOID        *ArgData;       // ARG_STRING: (char **) - ptr to string ptr
                                // ARG_NUM: (int *) - ptr to integer number
                                // ARG_ENABLE: (unsigned *) - ptr to flags
                                // ARG_DISABLE: (unsigned *) - ptr to flags
                                // ARG_ACTION: ptr to function
    ULONG       ArgParam;       // ARG_STRING: none
                                // ARG_NUM: base
                                // ARG_ENABLE: flag bit mask
                                // ARG_DISABLE: flag bit mask
                                // ARG_ACTION: none
    PFNARG      ArgVerify;      // pointer to argument verification function
                                // this will be ignored for ARG_ACTION
};

typedef struct _PROGINFO {
    UCHAR *SwitchChars;         // if null, DEF_SWITCHCHARS is used
    UCHAR *Separators;          // if null, DEF_SEPARATORS is used
    UCHAR *ProgPath;            // ParseProgInfo set this ptr to prog. path
    UCHAR *ProgName;            // ParseProgInfo set this ptr to prog. name
} PROGINFO;
typedef PROGINFO *PPROGINFO;

//
// Export function prototypes
//
extern
VOID
EXPORT
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    );

extern
ULONG
EXPORT
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\inc\unasmdll.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasmdll.h

Abstract:

    This contains all the data structures used by the ACPI Unassember. It
    also contains the only legal entry point into the library

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _UNASMDLL_H_
#define _UNASMDLL_H_

    #ifndef LOCAL
        #define LOCAL   __cdecl
    #endif
    #ifndef EXPORT
        #define EXPORT  __cdecl
    #endif

    typedef VOID (*PUNASM_PRINT)(PCCHAR DebugMessage, ... );

    extern
    ULONG
    EXPORT
    IsDSDTLoaded(
        VOID
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmLoadDSDT(
        PUCHAR          DSDT
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmDSDT(
        PUCHAR          DSDT,
        PUNASM_PRINT    PrintFunction,
        ULONG_PTR       BaseAddress,
        ULONG           IndentLevel
        );

    extern
    NTSTATUS
    EXPORT
    UnAsmScope(
        PUCHAR          *OpCode,
        PUCHAR          OpCodeEnd,
        PUNASM_PRINT    PrintFunction,
        ULONG_PTR       BaseAddress,
        ULONG           IndentLevel
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\acpiwake\acpiwake.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    amlload.c

Abstract:

    This program installs an AML file into the NT registry

Author:

    Ken Reneris

Environment:

    Command-line.

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct _pm_tables {
    DWORD   bit;
    UCHAR   *name;
} pm_tables, *ppm_tables;

pm_tables pm_table_1[] = {
    { 0, "System Timer" },
    { 4, "BusMaster Request" },
    { 5, "Global Lock Request" },
};

pm_tables pm_table_2[] = {
    { 0, "Power Button" },
    { 1, "Sleep Button" },
    { 2, "Real Time Clock" },
};

UCHAR       s[500];                     // Registry path

VOID
Abort(
    )
{
    exit(1);
}

PUCHAR
get_fixed_event_name(
    IN  ppm_tables  CurTable,
    IN  DWORD       Index
    )
{
    DWORD   i;

    for (i = 0; i < 8; i++) {

        if (CurTable[i].bit == Index) {

            return CurTable[i].name;

        }
    }
    return NULL;
}

VOID
display_fixed_event_info(
    IN  UCHAR   *fixedmaskdata,
    IN  UCHAR   *fixedstatusdata,
    IN  DWORD   data_length)
{
    DWORD       i;
    DWORD       j;
    DWORD       k;
    ppm_tables  curTable;
    PUCHAR      text;

    printf("Fixed Event Information\n");

    for (i = 0; i < data_length && i < 2; i++) {

        if (i == 0) {
            curTable = pm_table_1;
        } else {
            curTable = pm_table_2;
        }

        /*
        printf("  MaskRegister[%d]:%x StatusRegister[%d]:%x\n",
            i, fixedmaskdata[i], i, fixedstatusdata[i]);
        */

        for (j = 1, k = 0; k < 8; k++, j = (j << 1)) {

            text = get_fixed_event_name( curTable, k);
            if (text == NULL) {

                continue;

            }

            if ( (fixedmaskdata[i] & j) && (fixedstatusdata[i] & j) ) {

                printf("  The %s is enabled and has awoken the system.\n", text);


            } else if (fixedmaskdata[i] & j) {

                printf("  The %s is enabled to wake the system.\n", text );

            } else if (fixedstatusdata[i] & j) {

                printf("  The %s was set but not enabled to wake the system.\n", text );

            }
        }
    }
    printf("\n");
}

VOID
display_generic_event_info(
    IN  UCHAR   *genericmaskdata,
    IN  UCHAR   *genericstatusdata,
    IN  DWORD   data_length
    )
{
    DWORD   i;
    DWORD   j;
    DWORD   k;

    printf("Generic Event Information\n");

    for (i = 0; i < data_length; i++) {

        /*
        printf("  MaskRegister[%d]:%x StatusRegister[%d]:%x\n",
            i, genericmaskdata[i], i, genericstatusdata[i]);
        */

        for (j = 1, k = 0; k < 8; k++, j = (j << 1) ) {

            if ( (genericmaskdata[i] & j) && (genericstatusdata[i] && j) ) {

                printf("  Event %02x is enabled and has awoken the system.\n",
                    ( (i * 8) + k ) );

            } else if (genericmaskdata[i] & j) {

                printf("  Event %02x is enabled to wake the system.\n",
                    ( (i * 8) + k ) );

            } else if (genericstatusdata[i] & j) {

                printf("  Event %02x was set but not enabled to wake the system.\n",
                    ( (i * 8) + k ) );

            }
        }
    }
    printf("\n");
}
int
__cdecl
main(
    IN int  argc,
    IN char *argv[]
    )
{
    DWORD   data_type;
    DWORD   data_length;
    HKEY    regKey;
    LONG    status;
    UCHAR   fixedmaskdata[32];
    UCHAR   fixedstatusdata[32];
    UCHAR   genericmaskdata[32];
    UCHAR   genericstatusdata[32];

    sprintf(s, "System\\CurrentControlSet\\Services\\ACPI\\Parameters\\WakeUp");

    status = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        s,
        0L,
        KEY_ALL_ACCESS,
        &regKey
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not access the registry path: %s\n", s);
        Abort();
    }

    //
    // Read the fixed event mask
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "FixedEventMask", 0,
        &data_type,
        fixedmaskdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read FixedEventMask from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("FixedEventMask does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();

    }

    //
    // Read the fixed event Status
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "FixedEventStatus", 0,
        &data_type,
        fixedstatusdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read FixedEventStatus from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("FixedEventStatus does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();

    }
    display_fixed_event_info( fixedmaskdata, fixedstatusdata, data_length );

    //
    // Read the generic event mask
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "GenericEventMask", 0,
        &data_type,
        genericmaskdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read GenericEventMask from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("GenericEventMask does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();
    }

    //
    // Read the generic event status
    //
    data_length = 32;
    status = RegQueryValueEx(
        regKey,
        "GenericEventStatus", 0,
        &data_type,
        genericstatusdata,
        &data_length
        );
    if (status != ERROR_SUCCESS) {
        printf("Could not read GenericEventStatus from %s:%x\n", s, status );
        RegCloseKey( regKey );
        Abort();
    }
    if (data_type != REG_BINARY) {
        printf("GenericEventStatus does not contain binary data\n");
        RegCloseKey( regKey );
        Abort();
    }
    display_generic_event_info( genericmaskdata, genericstatusdata, data_length );

    RegCloseKey( regKey );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\acpi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
UCHAR       Buffer[2048];
PCCHAR      DeviceStateTable[] = {
    "Stopped",
    "Inactive",
    "Started",
    "Removed",
    "SurpriseRemoved",
    "Invalid",
};
PCCHAR      DevicePowerStateTable[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
};
PCCHAR      SystemPowerStateTable[] = {
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleepingS1",
    "PowerSystemSleepingS2",
    "PowerSystemSleepingS3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
    "PowerSystemMaximum",
};
PCCHAR      SystemPowerActionTable[] = {
    "PowerActionNone",
    "PowerActionReserved",
    "PowerActionSleep",
    "PowerActionHibernate",
    "PowerActionShutdown",
    "PowerActionShutdownReset",
    "PowerActionShutdownOff",
    "PowerActionWarmEject"
};
CCHAR       ReallyShortDevicePowerStateTable[] = {
    'W',
    '0',
    '1',
    '2',
    '3',
    'M',
};
PCCHAR      ShortDevicePowerStateTable[] = {
    "Dw",
    "D0",
    "D1",
    "D2",
    "D3",
    "Dmax",
};
CCHAR       ReallyShortSystemPowerStateTable[] = {
    'W',
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    'M',
};
PCCHAR      ShortSystemPowerStateTable[] = {
    "Sx",
    "S0",
    "S1",
    "S2",
    "S3",
    "S4",
    "S5",
    "SM",
};
PCCHAR     WorkDone[] = {
    "Complete",
    "Pending",
    "Failure",
    "Step 0",
    "Step 1",
    "Step 2",
    "Step 3",
    "Step 4",
    "Step 5",
    "Step 6",
    "Step 7",
    "Step 8",
    "Step 9",
    "Step 10",
    "Step 11",
    "Step 12",
    "Step 13",
    "Step 14",
    "Step 15",
    "Step 16",
    "Step 17",
    "Step 18",
    "Step 19",
    "Step 20",
    "Step 21",
    "Step 22",
    "Step 23",
    "Step 24",
    "Step 25",
    "Step 26",
};

FLAG_RECORD DeviceExtensionButtonEventFlags[] = {
    { 0x00000001, "Pwr", "\"Power Button\"" , NULL, NULL },
    { 0x00000002, "Slp", "\"Sleep Button\"" , NULL, NULL },
    { 0x00000004, "Lid", "\"Lid Switch\"" , NULL, NULL },
    { 0x80000000, "Wake", "\"Wake Capable\"" , NULL, NULL },
};

FLAG_RECORD DeviceExtensionFlags[] = {
    { 0x0000000000000001, "Nev",   "NeverPresent" , NULL, NULL },
    { 0x0000000000000002, "!P" ,   "NotPresent" , NULL, NULL },
    { 0x0000000000000004, "Rmv",   "Removed" , NULL, NULL },
    { 0x0000000000000008, "!F" ,   "NotFound" , NULL, NULL },
    { 0x0000000000000010, "Fdo",   "FunctionalDeviceObject" , NULL, NULL  },
    { 0x0000000000000020, "Pdo",   "PhysicalDeviceObject" , NULL, NULL },
    { 0x0000000000000040, "Fil",   "Filter" , NULL, NULL },
    { 0x0000000000010000, "Wak",   "Wake" , NULL, NULL },
    { 0x0000000000020000, "Raw",   "RawOK" , NULL, NULL },
    { 0x0000000000040000, "But",   "Button" , NULL, NULL },
    { 0x0000000000080000, "PS0",   "AlwaysOn" , NULL, NULL },
    { 0x0000000000100000, "!Fil",  "NeverFilter" , NULL, NULL },
    { 0x0000000000200000, "!Stop", "NeverStop" , NULL, NULL },
    { 0x0000000000400000, "!Off",  "NeverOverrideOff" , NULL, NULL },
    { 0x0000000000800000, "ISA",   "ISABus" , NULL, NULL },
    { 0x0000000001000000, "EIO",   "EIOBus" , NULL, NULL },
    { 0x0000000002000000, "PCI",   "PCIBus" , NULL, NULL },
    { 0x0000000004000000, "Ser",   "SerialPort" , NULL, NULL },
    { 0x0000000008000000, "Tz",    "ThermalZone" , NULL, NULL },
    { 0x0000000010000000, "Lnk",   "LinkNode" , NULL, NULL },
    { 0x0000000020000000, "!UI",   "NoShowInUI" , NULL, NULL },
    { 0x0000000040000000, "!!UI",  "NeverShowInUI" , NULL, NULL },
    { 0x0000000080000000, "D3",    "StartInD3" , NULL, NULL },
    { 0x0000000100000000, "pci",   "PCIDevice" , NULL, NULL },
    { 0x0000000200000000, "PIC",   "ProgrammableInterruptController" , NULL, NULL },
    { 0x0000000400000000, "Dock-", "UnattachedDock" , NULL, NULL },
    { 0x0000100000000000, "Adr",   "HasAddress" , NULL, NULL },
    { 0x0000200000000000, "HID",   "HasHardwareID" , NULL, NULL },
    { 0x0000400000000000, "UID",   "HasUniqueID" , NULL, NULL },
    { 0x0000800000000000, "hid",   "FakeHardwareID" , NULL, NULL },
    { 0x0001000000000000, "uid",   "FakeUniqueID" , NULL, NULL },
    { 0x0002000000000000, "BAD",   "FailedInit" , NULL, NULL },
    { 0x0004000000000000, "SRS",   "Programmable" , NULL, NULL },
    { 0x0008000000000000, "Fake",  "NoAcpiObject" , NULL, NULL },
    { 0x0010000000000000, "Excl",  "Exclusive" , NULL, NULL },
    { 0x0020000000000000, "Ini",   "RanINI" , NULL, NULL },
    { 0x0040000000000000, "Ena",   "Enabled" , "!Ena", "NotEnabled" },
    { 0x0080000000000000, "BAD",   "Failed" , NULL, NULL },
    { 0x0100000000000000, "Pwr",   "AcpiPower" , NULL, NULL },
    { 0x0200000000000000, "Dock",  "DockProfile" , NULL, NULL },
    { 0x0400000000000000, "S->D",  "BuiltPowerTables" , NULL, NULL },
    { 0x0800000000000000, "PME",   "UsesPME" , NULL, NULL },
    { 0x1000000000000000, "!Lid",  "NoLidAction" , NULL, NULL },
};

FLAG_RECORD DeviceExtensionThermalFlags[] = {
    { 0x00000001, "Cooling", "\"Cooling Level\"" , NULL, NULL },
    { 0x00000002, "Temp", "Temp" , NULL, NULL },
    { 0x00000004, "Trip", "\"Trip Points\"" , NULL, NULL },
    { 0x00000008, "Mode", "Mode" , NULL, NULL },
    { 0x00000010, "Init", "Initialize" , NULL, NULL },
    { 0x20000000, "Wait", "\"Wait for Notify\"" , NULL, NULL },
    { 0x40000000, "Busy", "Busy" , NULL, NULL },
    { 0x80000000, "Loop", "\"In Service Loop\"" , NULL, NULL },
};

FLAG_RECORD PM1ControlFlags[] = {
    { 0x0001, "", "SCI_EN" , NULL, NULL },
    { 0x0002, "", "BM_RLD" , NULL, NULL },
    { 0x0004, "", "GBL_RLS" , NULL, NULL },
    { 0x0400, "", "SLP_TYP0" , NULL, NULL },
    { 0x0800, "", "SLP_TYP1" , NULL, NULL },
    { 0x1000, "", "SLP_TYP2" , NULL, NULL  },
    { 0x2000, "", "SLP_EN" , NULL, NULL  },
};

FLAG_RECORD PM1StatusFlags[] = {
    { 0x0001, "", "TMR_STS" , NULL, NULL },
    { 0x0010, "", "BM_STS" , NULL, NULL },
    { 0x0020, "", "GBL_STS" , NULL, NULL },
    { 0x0100, "", "PWRBTN_STS" , NULL, NULL },
    { 0x0200, "", "SLPBTN_STS" , NULL, NULL },
    { 0x0400, "", "RTC_STS" , NULL, NULL },
    { 0x8000, "", "WAK_STS" , NULL, NULL },
};

FLAG_RECORD PM1EnableFlags[] = {
    { 0x0001, "", "TMR_EN" , NULL, NULL },
    { 0x0020, "", "GBL_EN" , NULL, NULL },
    { 0x0100, "", "PWRBTN_EN" , NULL, NULL },
    { 0x0200, "", "SLPBTN_EN" , NULL, NULL },
    { 0x0400, "", "RTC_EN" , NULL, NULL },
};

FLAG_RECORD PowerNodeFlags[] = {
    { 0x00001, "PO", "Present" , NULL, NULL },
    { 0x00002, "Init", "Initialized" , NULL, NULL },
    { 0x00004, "!STA", "\"Status Unknown\"" , NULL, NULL },
    { 0x00010, "On", "On" , "Off", "Off" },
    { 0x00020, "On+", "OverrideOn" , NULL, NULL },
    { 0x00040, "Off-", "OverrideOff" , NULL, NULL },
    { 0x00200, "On++", "AlwaysOn" , NULL, NULL },
    { 0x00400, "Off--", "AlwaysOff" , NULL, NULL },
    { 0x10000, "Fail", "Failed" , NULL, NULL },
    { 0x20000, "Hiber", "HibernatePath" , NULL, NULL },
};

FLAG_RECORD PowerRequestFlags[] = {
    { 0x00001, "Dly",  "Delayed", NULL, NULL },
    { 0x00002, "!Q",   "NoQueue", NULL, NULL },
    { 0x00004, "Lck",  "LockDevice", NULL, NULL },
    { 0x00008, "!Lck", "UnlockDevice", NULL, NULL },
    { 0x00010, "+Hbr", "LockHiber", NULL, NULL },
    { 0x00020, "-Hbr", "UnlockHiber", NULL, NULL },
    { 0x00040, "Can",  "HasCancel", NULL, NULL },
};

VOID
displayAcpiDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    )
/*++

Routine Description:

    This routine is responsible for displaying a device extension

Arguments:

    DeviceExtension - Extension to display
    Address         - Where the extension lives in memory
    Verbose         - How much information to display
    IndentLevel     - How much to tab it over

Return Value:

    None

--*/
{
    BOOL                b;
    DEVICE_POWER_STATE  k;
    DWORD_PTR           displacement;
    IRP_DISPATCH_TABLE  dispatchTable;
    PACPI_POWER_INFO    powerInfo;
    SYSTEM_POWER_STATE  s;
    UCHAR               indent[80];
    ULONG               i,j;
    ULONG               returnLength;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    powerInfo = &(DeviceExtension->PowerInfo);

    //
    // Check signature
    //
    if (DeviceExtension->Signature != ACPI_SIGNATURE) {

        dprintf(
            "%s  Unknown Signature. This does appear to be an "
            "ACPI Extension\n",
            indent
            );
        return;

    }

    //
    // Line #1
    //
    dprintf("%sACPI DeviceExtension - %lx - ",indent, Address);
    displayAcpiDeviceExtensionName( Address );
#if 0
    if (DeviceExtension->Flags & DEV_PROP_HID) {

        if (DeviceExtension->DeviceID != NULL) {

            memset( Buffer, '0', 2048 );
            b = ReadMemory(
                (ULONG_PTR) DeviceExtension->DeviceID,
                Buffer,
                32,
                &returnLength
                );
            if (!b || Buffer[0] == '\0') {

                dprintf(" (%lx)", DeviceExtension->DeviceID );

            } else {

                dprintf(" %s", Buffer );

            }

        } else {

            dprintf( " NULL" );

        }
        if (DeviceExtension->Flags & DEV_PROP_UID) {

            if (DeviceExtension->InstanceID) {

                memset( Buffer, '0', 256 );
                b = ReadMemory(
                    (ULONG_PTR) DeviceExtension->InstanceID,
                    Buffer,
                    256,
                    &returnLength);
                if (!b || returnLength != 256 || Buffer[0] == '\0') {

                    dprintf(" [ (%lx) ]", DeviceExtension->InstanceID );

                } else {

                    dprintf(" [%s]", Buffer );

                }

            } else {

                dprintf(" [NULL]");

            }

        }

    } else if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" %lx", DeviceExtension->Address );

    }
#endif
    dprintf("\n");

    //
    // Line #2
    //
    dprintf(
        "%s  DevObj     %8lx   PhysicalObj  %8lx   ",
        indent,
        DeviceExtension->DeviceObject,
        DeviceExtension->PhysicalDeviceObject
        );
    if (DeviceExtension->TargetDeviceObject != NULL) {

        dprintf("AttachedTo %8lx", DeviceExtension->TargetDeviceObject );

    }
    dprintf("\n");

    //
    // Line #3
    //
    dprintf(
        "%s  AcpiObject %8lx   ParentExt    %8lx\n",
        indent,
        DeviceExtension->AcpiObject,
        DeviceExtension->ParentExtension
        );

    //
    // Line #4
    //
    dprintf(
        "%s  PnpState   %-8s   OldPnpState  %-8s\n",
        indent,
        DeviceStateTable[DeviceExtension->DeviceState],
        DeviceStateTable[DeviceExtension->PreviousState]
        );

    //
    // Line #4
    //
    dprintf("%s  ",indent);
    if (DeviceExtension->ResourceList != NULL) {

        dprintf("CmResList  %lx   ", DeviceExtension->ResourceList );

    } else {

        dprintf("                      ");

    }
    if (DeviceExtension->PnpResourceList != NULL) {

        dprintf("PnpResList   %lx   ", DeviceExtension->PnpResourceList );

    } else {

        dprintf("                        ");

    }

    dprintf(
        "RefCounts  %dD %dI %dH %dW\n",
        DeviceExtension->ReferenceCount,
        DeviceExtension->OutstandingIrpCount,
        DeviceExtension->HibernatePathCount,
        powerInfo->WakeSupportCount
        );

    //
    // Line #5
    //
    if (DeviceExtension->Flags & DEV_PROP_DOCK) {

        dprintf( "%s  Dock       %8lx   ", indent, DeviceExtension->Dock );

    } else {

        dprintf( "%s                        ", indent );

    }
    dprintf(
        "Dispatch     %8lx   ",
        DeviceExtension->DispatchTable
        );
    if (DeviceExtension->RemoveEvent != NULL) {

        dprintf("Remove %lx", DeviceExtension->RemoveEvent);

    }
    dprintf("\n");

    //
    // Line #6
    //
    if (powerInfo->DeviceNotifyHandler != NULL) {

        GetSymbol(
            powerInfo->DeviceNotifyHandler,
            Buffer,
            &displacement
            );
        dprintf(
            "%s  Handler    %lx   Context      %8lx   %s+%x\n",
            indent,
            powerInfo->DeviceNotifyHandler,
            powerInfo->Context,
            Buffer,
            displacement
            );

    }

    //
    // Line #7-12
    //
    for (k = PowerDeviceUnspecified; k <= PowerDeviceD3; k++) {

        if (k < PowerDeviceD3) {

            if (powerInfo->PowerObject[k] == NULL &&
                powerInfo->PowerNode[k] == NULL) {

                continue;

            }

        } else {

            if (powerInfo->PowerObject[k] == NULL) {

                continue;

            }

        }

        //
        // Did we print on this line?
        //
        b = FALSE;
        dprintf("%s  ", indent);
        if (powerInfo->PowerObject[k] != NULL) {

            dprintf(
                "_PS%c       %lx   ",
                ReallyShortDevicePowerStateTable[k],
                powerInfo->PowerObject[k]
                );
            b = TRUE;

        }
        if (k <= PowerDeviceD2 && powerInfo->PowerNode[k] != NULL) {

            if (b) {

                dprintf(
                    "%s Nodes     %lx   ",
                    ShortDevicePowerStateTable[k],
                    powerInfo->PowerNode[k]
                    );

            } else {

                dprintf(
                    "%s Nodes   %lx   ",
                    ShortDevicePowerStateTable[k],
                    powerInfo->PowerNode[k]
                    );

            }

        }
        dprintf("\n");

    }

    //
    // Line #13
    //
    dprintf( "%s  State      %-2s", indent, ShortDevicePowerStateTable[powerInfo->PowerState]);
    if (powerInfo->DesiredPowerState != powerInfo->PowerState) {

        dprintf("->%-4s   ", ShortDevicePowerStateTable[powerInfo->DesiredPowerState]);

    } else {

        dprintf("         ");

    }
    dprintf("SxD Mapping  ");
    for (s = PowerSystemWorking; s < PowerSystemMaximum; s++) {

        k = powerInfo->DevicePowerMatrix[s];
        if (k == PowerDeviceUnspecified) {

            continue;

        }
        dprintf(
            "S%c->D%c ",
            ReallyShortSystemPowerStateTable[s],
            ReallyShortDevicePowerStateTable[k]
            );

    }
    dprintf("\n");

    //
    // Line #14
    //
    if (DeviceExtension->Flags & DEV_CAP_WAKE) {

        //
        // Print the start of the line
        //
        dprintf("%s      ", indent);

        s = powerInfo->SystemWakeLevel;
        if (s == PowerSystemUnspecified) {

            dprintf("Sw->Sx " );

        } else {

            dprintf("Sw->S%c ", ReallyShortSystemPowerStateTable[s] );

        }

        k = DeviceExtension->PowerInfo.DeviceWakeLevel;
        if (k == PowerDeviceUnspecified) {

            dprintf("Dw->Dx " );

        } else {

            dprintf("Dw->D%c ", ReallyShortDevicePowerStateTable[k] );

        }
        dprintf(
            "    Wake Pin     %8d   WakeCount  %8x\n",
            powerInfo->WakeBit,
            powerInfo->WakeSupportCount
            );

    }

    //
    // Line #15
    //
    if (powerInfo->CurrentPowerRequest != NULL) {

        dprintf(
            "%s  CurrentReq %lx   ",
            indent,
            powerInfo->CurrentPowerRequest
            );
        if (powerInfo->PowerRequestListEntry.Flink !=
            (PLIST_ENTRY) (Address + FIELD_OFFSET(DEVICE_EXTENSION, PowerInfo.PowerRequestListEntry) ) ) {

            dprintf(
                "PowerReqList %lx %lx",
                CONTAINING_RECORD( powerInfo->PowerRequestListEntry.Flink, ACPI_POWER_REQUEST, SerialListEntry ),
                CONTAINING_RECORD( powerInfo->PowerRequestListEntry.Blink, ACPI_POWER_REQUEST, SerialListEntry )
                );

        }
        dprintf("\n");

    }

    //
    // At this point, we are done with the common bits, and now deal with the
    // special parts of the extension
    //
    if ( (DeviceExtension->Flags & DEV_TYPE_FDO) ) {

        dprintf(
            "%s  DPC Obj    %8lx   Int Object   %08lx\n",
            indent,
            (Address + FIELD_OFFSET(DEVICE_EXTENSION, Fdo.InterruptDpc) ),
            DeviceExtension->Fdo.InterruptObject
            );
        dprintf(
            "%s  PM1 Status %8lx\n",
            indent,
            DeviceExtension->Fdo.Pm1Status
            );
        dumpPM1StatusRegister( DeviceExtension->Fdo.Pm1Status, IndentLevel + 2 );

    }
    if ( (DeviceExtension->Flags & DEV_CAP_BUTTON) ) {

        dprintf(
            "%s  LidState   %-8s   SpinLock     %x   ",
            indent,
            (DeviceExtension->Button.LidState ? "TRUE" : "FALSE"),
            (Address + FIELD_OFFSET(DEVICE_EXTENSION, Button.SpinLock) )
        );
        if (DeviceExtension->Button.Events) {

            dumpFlags(
                (DeviceExtension->Button.Events),
                &DeviceExtensionButtonEventFlags[0],
                sizeof(DeviceExtensionButtonEventFlags)/sizeof(FLAG_RECORD),
                IndentLevel,
                (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
                );

        }
        dprintf("\n");

        if (DeviceExtension->Button.Capabilities) {

            dprintf(
                "%s  Capability %lx   ",
                indent,
                DeviceExtension->Button.Capabilities
                );
            dumpFlags(
                (DeviceExtension->Button.Capabilities),
                &DeviceExtensionButtonEventFlags[0],
                sizeof(DeviceExtensionButtonEventFlags)/sizeof(FLAG_RECORD),
                IndentLevel,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
                );
            dprintf("\n");

        }

    }
    if ( (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) ) {

        THRM_INFO   thrm;

        dprintf(
            "%s  Info       %lx   Flags        %8x   ",
            indent,
            DeviceExtension->Thermal.Info,
            DeviceExtension->Thermal.Flags
            );
        dumpFlags(
            (DeviceExtension->Thermal.Flags),
            &DeviceExtensionThermalFlags[0],
            sizeof(DeviceExtensionThermalFlags)/sizeof(FLAG_RECORD),
            IndentLevel,
            (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
             DUMP_FLAG_SINGLE_LINE | DUMP_FLAG_NO_EOL)
            );
        dprintf("\n");

        //
        // Read the thermal Information and print it
        //
        b = ReadMemory(
            (ULONG_PTR) DeviceExtension->Thermal.Info,
            &thrm,
            sizeof(THRM_INFO),
            &returnLength
            );
        if (!b || returnLength != sizeof(THRM_INFO)) {

            dprintf(
                "%s  Could not read THRM_INFO @ %08lx\n",
                indent,
                DeviceExtension->Thermal.Info
                );

        } else {

            displayThermalInfo(
                &thrm,
                (ULONG_PTR) DeviceExtension->Thermal.Info,
                Verbose,
                IndentLevel + 2
                );

        }
    }

    //
    // Last Line. At this point, we can dump the ACPI Flags
    //
    dprintf("%s  Flags      %016I64x ", indent, DeviceExtension->Flags );
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_LONG_NAME)
        );

}

VOID
displayAcpiDeviceExtensionBrief(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    )
/*++

Routine Description:

    This routine displays a one line summary of the device extension

Arguments:

    DeviceExtension - The extension to display
    Address         - Where the extension is located
    Verbose         - How much information to display
    IndentLevel     - How much whitespace to use

Return Value:

    VOID

--*/
{
    BOOL                b;
    PDEVICE_EXTENSION   deviceExtension;
    ULONG               address;
    ULONG               i;
    ULONG               returnLength;
    ULONG               startAddress;

    //
    // Should we print this extension?
    //
    if ( (Verbose & VERBOSE_PRESENT) &&
         (DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) ) {

        return;

    }

    //
    // Make the IndentLevel 'relative' - Device By 4
    //
    IndentLevel /= 4;

    //
    // Indent the text
    //
    for (i = 0; i < IndentLevel; i++) {

        dprintf("| ");

    }

    //
    // Print the address of the object
    //
    dprintf("%08lx", Address );

    //
    // Try to get the name & instance
    //
    if (DeviceExtension->Flags & DEV_PROP_HID) {

        if (DeviceExtension->DeviceID) {

            memset( Buffer, '0', 2048 );
            b = ReadMemory(
                (ULONG_PTR) DeviceExtension->DeviceID,
                Buffer,
                256,
                &returnLength
                );
            if (b && Buffer[0] != '\0') {

                dprintf(" %s", Buffer );

            }

        } else {

            dprintf(" <Unknown HID>");

        }

        if (DeviceExtension->Flags & DEV_PROP_UID) {

            if (DeviceExtension->InstanceID) {

                memset( Buffer, '0', 2048 );
                b = ReadMemory(
                    (ULONG_PTR) DeviceExtension->InstanceID,
                    Buffer,
                    256,
                    &returnLength
                    );
                if (b && Buffer[0] != '\0') {

                    dprintf("(%s)", Buffer );

                }

            } else {

                dprintf(" <Unknown UID>");

            }

        }

    } else if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" %lx", DeviceExtension->Address );

    } else {

        dprintf(" <NULL>");

    }

    if (Verbose & VERBOSE_THERMAL) {

        DEVICE_POWER_STATE  d;
        SYSTEM_POWER_STATE  s;

        if (DeviceExtension->PowerInfo.PowerState == 0) {

            dprintf(" Dx" );

        } else {

            dprintf(" D%d", (DeviceExtension->PowerInfo.PowerState - 1) );

        }

        for (s = PowerSystemWorking; s < PowerSystemMaximum; s++) {

            d = DeviceExtension->PowerInfo.DevicePowerMatrix[s];
            if (d == PowerDeviceUnspecified) {

                continue;

            }

            dprintf(
                " S%c->D%c",
                ReallyShortSystemPowerStateTable[s],
                ReallyShortDevicePowerStateTable[d]
                );

        }

        if (DeviceExtension->Flags & DEV_CAP_WAKE) {

            s = DeviceExtension->PowerInfo.SystemWakeLevel;
            if (s == PowerSystemUnspecified) {

                dprintf(" Sw->Sx" );

            } else {

                dprintf(" Sw->S%c", ReallyShortSystemPowerStateTable[s] );

            }

            d = DeviceExtension->PowerInfo.DeviceWakeLevel;
            if (d == PowerDeviceUnspecified) {

                dprintf(" Dw->Dx" );

            } else {

                dprintf(" Dw->D%c", ReallyShortDevicePowerStateTable[d] );

            }

        }

        //
        // If we are displaying thermal information, cut short early
        //
        dprintf("\n");
        return;

    }

    dprintf(" NS %08lx", DeviceExtension->AcpiObject );
    if (DeviceExtension->PowerInfo.PowerState == 0) {

        dprintf(" Dx" );

    } else {

        dprintf(" D%d", (DeviceExtension->PowerInfo.PowerState - 1) );

    }

    //
    // Print the device state
    //
    if (DeviceExtension->DeviceState == Stopped) {

        dprintf(" stop");

    } else if (DeviceExtension->DeviceState == Inactive) {

        dprintf(" inac");

    } else if (DeviceExtension->DeviceState == Started) {

        dprintf(" star");

    } else if (DeviceExtension->DeviceState == Removed) {

        dprintf(" remv");

    } else if (DeviceExtension->DeviceState == SurpriseRemoved) {

        dprintf(" surp");

    } else {

        dprintf(" inva");

    }
    dprintf(" %d-%d-%d",
        DeviceExtension->OutstandingIrpCount,
        DeviceExtension->ReferenceCount,
        DeviceExtension->HibernatePathCount
        );

    //
    // Display the flags
    //
    dumpFlags(
        (DeviceExtension->Flags),
        &DeviceExtensionFlags[0],
        sizeof(DeviceExtensionFlags)/sizeof(FLAG_RECORD),
        IndentLevel + 4,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );

    // displayAcpiDeviceExtensionFlags( DeviceExtension );
}

VOID
displayAcpiDeviceExtensionFlags(
    IN  PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    This routine displays the Flag for a device extension

    This routine prints a new line at the end of the only line of text that
    it consumes

Arguments:

    DeviceExtension - The extension whose flags to dump

Return Value:

    None

--*/
{
    //
    // Dump the flags
    //
    if (DeviceExtension->Flags & DEV_TYPE_NEVER_PRESENT) {

        dprintf(" Nev");

    }
    if (DeviceExtension->Flags & DEV_TYPE_NOT_PRESENT) {

        dprintf(" N/P");

    }
    if (DeviceExtension->Flags & DEV_TYPE_REMOVED) {

        dprintf(" Rmv");

    }
    if (DeviceExtension->Flags & DEV_TYPE_NOT_FOUND) {

        dprintf(" N/F");

    }
    if (DeviceExtension->Flags & DEV_TYPE_FDO) {

        dprintf(" Fdo");

    }
    if (DeviceExtension->Flags & DEV_TYPE_PDO) {

        dprintf(" Pdo");

    }
    if (DeviceExtension->Flags & DEV_TYPE_FILTER) {

        dprintf(" Fil");

    }
    if (DeviceExtension->Flags & DEV_CAP_WAKE) {

        dprintf(" Wak");

    }
    if (DeviceExtension->Flags & DEV_CAP_RAW) {

        dprintf(" Raw");

    }
    if (DeviceExtension->Flags & DEV_CAP_BUTTON) {

        dprintf(" But");

    }
    if (DeviceExtension->Flags & DEV_CAP_ALWAYS_PS0) {

        dprintf(" PS0");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_FILTER) {

        dprintf(" !Fil");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_STOP) {

        dprintf(" !Stop");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_OVERRIDE) {

        dprintf(" !Off");

    }
    if (DeviceExtension->Flags & DEV_CAP_ISA) {

        dprintf(" Isa");

    }
    if (DeviceExtension->Flags & DEV_CAP_EIO) {

        dprintf(" Eio");

    }
    if (DeviceExtension->Flags & DEV_CAP_PCI) {

        dprintf(" Pci");

    }
    if (DeviceExtension->Flags & DEV_CAP_SERIAL) {

        dprintf(" Ser");

    }
    if (DeviceExtension->Flags & DEV_CAP_THERMAL_ZONE) {

        dprintf(" Thrm");

    }
    if (DeviceExtension->Flags & DEV_CAP_LINK_NODE) {

        dprintf(" Lnk");

    }
    if (DeviceExtension->Flags & DEV_CAP_NO_SHOW_IN_UI) {

        dprintf(" !UI");

    }
    if (DeviceExtension->Flags & DEV_CAP_NEVER_SHOW_IN_UI) {

        dprintf(" !!UI");

    }
    if (DeviceExtension->Flags & DEV_CAP_START_IN_D3) {

        dprintf(" D3");

    }
    if (DeviceExtension->Flags & DEV_CAP_PCI_DEVICE) {

        dprintf(" PciD");

    }
    if (DeviceExtension->Flags & DEV_CAP_PIC_DEVICE) {

        dprintf(" PIC");

    }
    if (DeviceExtension->Flags & DEV_CAP_UNATTACHED_DOCK) {

        dprintf(" Dock-");

    }
    if (DeviceExtension->Flags & DEV_PROP_ADDRESS) {

        dprintf(" Adr");

    }
    if (DeviceExtension->Flags & DEV_PROP_FIXED_HID) {

        dprintf(" FHid");

    } else if (DeviceExtension->Flags & DEV_PROP_HID) {

        dprintf(" Hid");

    }
    if (DeviceExtension->Flags & DEV_PROP_FIXED_UID) {

        dprintf(" FUid");

    } else if (DeviceExtension->Flags & DEV_PROP_UID) {

        dprintf(" Uid");

    }
    if (DeviceExtension->Flags & DEV_PROP_FAILED_INIT) {

        dprintf(" !INIT");

    }
    if (DeviceExtension->Flags & DEV_PROP_SRS_PRESENT) {

        dprintf(" SRS");

    }
    if (DeviceExtension->Flags & DEV_PROP_NO_OBJECT) {

        dprintf(" Fake");

    }
    if (DeviceExtension->Flags & DEV_PROP_EXCLUSIVE) {

        dprintf(" Excl");

    }
    if (DeviceExtension->Flags & DEV_PROP_RAN_INI) {

        dprintf(" Ini");

    }
    if (!(DeviceExtension->Flags & DEV_PROP_DEVICE_ENABLED)) {

        dprintf(" !Ena");

    }
    if (DeviceExtension->Flags & DEV_PROP_DEVICE_FAILED) {

        dprintf(" Fail");

    }
    if (DeviceExtension->Flags & DEV_PROP_ACPI_POWER) {

        dprintf(" Pwr");

    }

    if (DeviceExtension->Flags & DEV_PROP_DOCK) {

       dprintf(" Prof");

    }
    if (DeviceExtension->Flags & DEV_PROP_BUILT_POWER_TABLE) {

        dprintf(" S->D");

    }
    if (DeviceExtension->Flags & DEV_PROP_HAS_PME) {

        dprintf(" PME");

    }
    dprintf("\n");

}

VOID
displayAcpiDeviceExtensionName(
    IN  ULONG_PTR DeviceExtensionAddress
    )
/*++

Routine Description:


    This routine is tasked to with displaying the name of the device in the
    best possible manner

Arguments:

    DeviceExtensionAddress  - The Address of the DeviceExtension

Return Value:

    NONE

--*/
{
    BOOL                status;
    DEVICE_EXTENSION    deviceExtension;
    NSOBJ               acpiObject;
    UCHAR               nameBuffer[80];
    ULONG_PTR           nameAddress;
    ULONG               returnLength;

    //
    // Read the entier extension
    //
    status = ReadMemory(
        DeviceExtensionAddress,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        &returnLength
        );
    if (status && returnLength == sizeof(DEVICE_EXTENSION) ) {

        if (deviceExtension.Flags & DEV_PROP_HID) {

            if (deviceExtension.DeviceID != NULL) {

                //
                // Now, try to read the name into the buffer
                //
                status = ReadMemory(
                    (ULONG_PTR) deviceExtension.DeviceID,
                    nameBuffer,
                    79,
                    &returnLength
                    );
                if (status && returnLength) {

                    nameBuffer[returnLength] = '\0';
                    dprintf("%s",nameBuffer);


                } else {

                    dprintf("(%lx)", deviceExtension.DeviceID);

                }

            } else {

                dprintf("NULL");

            }

        }
        if (deviceExtension.Flags & DEV_PROP_UID) {

            if (deviceExtension.InstanceID != NULL) {

                //
                // Now, try to read the name into the buffer
                //
                status = ReadMemory(
                    (ULONG_PTR) deviceExtension.InstanceID,
                    nameBuffer,
                    79,
                    &returnLength
                    );
                if (status && returnLength) {

                    nameBuffer[returnLength] = '\0';
                    dprintf(" [%s]",nameBuffer);


                } else {

                    dprintf(" [ (%lx) ]", deviceExtension.InstanceID);

                }

            } else {

                dprintf(" [NULL]");

            }

        }
        if (deviceExtension.Flags & DEV_PROP_ADDRESS) {

            dprintf("%lx", deviceExtension.Address );

        }
        return;

    }

    //
    // In this case, obtain the address of the ACPIObject for this device
    //
    nameAddress = (ULONG_PTR) &(deviceExtension.AcpiObject) -
        (ULONG_PTR) &(deviceExtension) + DeviceExtensionAddress;
    status = ReadMemory(
        nameAddress,
        &(deviceExtension.AcpiObject),
        sizeof(PNSOBJ),
        &returnLength
        );
    if (status && returnLength == sizeof(PNSOBJ)) {

        //
        // Read the object
        //
        status = ReadMemory(
            (ULONG_PTR) deviceExtension.AcpiObject,
            &acpiObject,
            sizeof(NSOBJ),
            &returnLength
            );
        if (status && returnLength == sizeof(NSOBJ)) {

            memcpy( nameBuffer, &(acpiObject.dwNameSeg), 4 );
            nameBuffer[4] = '\0';

            dprintf("Acpi(%s)", nameBuffer);
            return;

        }

    }

    dprintf("Unknown");
    return;
}
VOID
displayThermalInfo(
    IN  PTHRM_INFO  ThrmInfo,
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

    This routine displays a thermal information structure

--*/
{
    BOOLEAN             noIndent;
    UCHAR               indent[80];
    UINT                i;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf(
        "%s  Stamp      %8lx   Affinity     %08lx   Mode       %s\n",
        indent,
        ThrmInfo->Info.ThermalStamp,
        ThrmInfo->Info.Processors,
        (ThrmInfo->Mode == 0 ? "Active" : "Passive")
        );
    dprintf(
        "%s  SampleRate %8ss  Constant1    %08lx   Constant2  %08lx\n",
        indent,
        TimeToSeconds( ThrmInfo->Info.SamplingPeriod ),
        ThrmInfo->Info.ThermalConstant1,
        ThrmInfo->Info.ThermalConstant2
        );
    dprintf(
        "%s  _TMP       %8lx   TempData     %8lx   CoolingLvl  %2d\n",
        indent,
        ThrmInfo->TempMethod,
        Address + FIELD_OFFSET( THRM_INFO, Temp ),
        ThrmInfo->CoolingLevel
        );
    for (i = 0; i < 10; i++) {

        noIndent = FALSE;

        if (i == 0) {

            dprintf(
                "%s  Current    %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.CurrentTemperature )
                );

        } else if (i == 1) {

            dprintf(
                "%s  Critical   %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.CriticalTripPoint )
                );

        } else if (i == 2) {

            dprintf(
                "%s  Passive    %8sK  ",
                indent,
                TempToKelvins( ThrmInfo->Info.PassiveTripPoint )
                );

        } else {

            noIndent = TRUE;

        }

        if (i >= ThrmInfo->Info.ActiveTripPointCount) {

            if (ThrmInfo->Info.ActiveTripPoint[i] != 0 ||
                ThrmInfo->ActiveList[i] != NULL) {

                if (noIndent == TRUE) {

                    dprintf( "%s                        ", indent );

                }
                dprintf(
                    "*Active #%d   %8sK  Method     %lx\n",
                    i,
                    TempToKelvins( ThrmInfo->Info.ActiveTripPoint[i] ),
                    ThrmInfo->ActiveList[i]
                    );

            } else if (i < 3) {

                dprintf("\n");

            } else {

                break;

            }


        } else {

            if (noIndent == TRUE) {

                dprintf( "%s                        ", indent );

            }
            dprintf(
                "Active #%d    %8sK  Method     %lx\n",
                i,
                TempToKelvins( ThrmInfo->Info.ActiveTripPoint[i] ),
                ThrmInfo->ActiveList[i]
                );

        }

    }
}

VOID
dumpAcpiDeviceNode(
    IN  PACPI_DEVICE_POWER_NODE DeviceNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    )
/*++

Routine Description:

    This routine dumps the contents of a single device node

Arguments:

    DeviceNode  - What to dump
    Address     - Where that node is located
    IndentLevel - How much whitespace to use

Return Value:

    None

--*/
{
    UCHAR   indent[80];

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf(
        "%sDevice Node - %08lx -> Extension - %08lx",
        indent,
        Address,
        DeviceNode->DeviceExtension
        );
    if (DeviceNode->DeviceExtension != NULL) {

        dprintf(" - ");
        displayAcpiDeviceExtensionName(
            (ULONG_PTR) DeviceNode->DeviceExtension
            );

    }
    dprintf("\n");

    dprintf(
        "%s  System     %2s         Device       %2s         Wake       %s\n",
        indent,
        ShortSystemPowerStateTable[DeviceNode->SystemState],
        ShortDevicePowerStateTable[DeviceNode->AssociatedDeviceState],
        (DeviceNode->WakePowerResource ? "TRUE" : "FALSE")
        );

}

VOID
dumpAcpiDeviceNodes(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This routine walks a Device Power List (given the address of the
    start of that list)

Arguments:

    Address     - Where in memory the first node is located
    Verbose     - How much information to display
    IndentLevel - How many characters to indent

Return Value:

    VOID

--*/
{
    BOOL                    status;
    ACPI_DEVICE_POWER_NODE  deviceNode;
    ACPI_POWER_DEVICE_NODE  powerNode;
    ULONG                   returnLength;
    ULONG_PTR               deviceAddress = Address;

    while (deviceAddress != 0) {

        //
        // Read the current node
        //
        status = ReadMemory(
            deviceAddress,
            &deviceNode,
            sizeof(ACPI_DEVICE_POWER_NODE),
            &returnLength
            );
        if (status != TRUE || returnLength != sizeof(ACPI_DEVICE_POWER_NODE)) {

            dprintf(
                "dumpAcpiDeviceNodes: could not read device node memory "
                "%08lx\n",
                deviceAddress
                );
            return;

        }

        //
        // Dump the node
        //
        dumpAcpiDeviceNode(
            &deviceNode,
            deviceAddress,
            Verbose,
            IndentLevel
            );

        status = ReadMemory(
            (ULONG_PTR) deviceNode.PowerNode,
            &powerNode,
            sizeof(ACPI_POWER_DEVICE_NODE),
            &returnLength);
        if (status != TRUE ||
            returnLength != sizeof(ACPI_POWER_DEVICE_NODE)) {

            dprintf(
                "dumpAcpiDeviceNode: could not read power node memory "
                "%08lx\n",
                deviceNode.PowerNode
                );
            return;

        }

        //
        // Dump the power resource
        //
        dumpAcpiPowerNode(
            &powerNode,
            (ULONG_PTR) deviceNode.PowerNode,
            Verbose,
            IndentLevel
            );

        //
        // setup next entry in the list
        //
        deviceAddress = (ULONG_PTR) deviceNode.Next;

    }

}

VOID
dumpAcpiExtension(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This dumps the ACPI device extension in a format that is readable by the
    user debugging the system

Arguments:

    Address     - Where the DeviceObject is located
    Verbose     - How much information to display
    IndentLevel - How much whitespace to have

Return Value:

    None

--*/
{
    BOOL                b;
    DEVICE_EXTENSION    deviceExtension;
    PLIST_ENTRY         listEntry;
    UCHAR               indent[80];
    ULONG_PTR           curAddress;
    ULONG               returnLength;
    ULONG_PTR           stopAddress;
    ULONG               subVerbose;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Read the sibling device extension
    //
    b = ReadMemory(
        Address,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        &returnLength
        );
    if (!b) {

        dprintf(
            "%s***ReadMemory Failed from %p\n",
            Address
            );
        return;

    } else if (returnLength != sizeof(DEVICE_EXTENSION) ) {

        dprintf(
            "%s***Error: Only read %08lx of %08lx bytes for %p\n",
            returnLength,
            sizeof(DEVICE_EXTENSION),
            Address
            );
        return;

    }

    if ( (Verbose & VERBOSE_ALL) ) {

        displayAcpiDeviceExtension(
            &deviceExtension,
            Address,
            Verbose,
            IndentLevel
            );

    } else {

        displayAcpiDeviceExtensionBrief(
            &deviceExtension,
            Address,
            Verbose,
            IndentLevel
            );

    }

    if (! (Verbose & VERBOSE_LOOP) ) {

        return;

    }

    //
    // Determine the current and stop addresses
    //
    stopAddress = (ULONG_PTR) &(deviceExtension.ChildDeviceList) -
        (ULONG_PTR) &deviceExtension + Address;
    listEntry = deviceExtension.ChildDeviceList.Flink;

    //
    // Loop while there are children
    //
    while (listEntry != (PLIST_ENTRY) stopAddress) {

        //
        // Check for Ctrl-C
        //
        if (CheckControlC()) {

            break;

        }

        //
        // The currentAddress is at the ListEntry --- lets convert
        //
        curAddress = (ULONG_PTR) CONTAINING_RECORD(
            listEntry,
            DEVICE_EXTENSION,
            SiblingDeviceList
            );

        //
        // Read the entry
        //
        b = ReadMemory(
            curAddress,
            &deviceExtension,
            sizeof(DEVICE_EXTENSION),
            &returnLength
            );
        if (!b) {

            dprintf(
                "%s    ***ReadMemory Failed from %p\n",
                curAddress
                );
            return;

        } else if (returnLength != sizeof(DEVICE_EXTENSION) ) {

            dprintf(
                "%s    ***Error: Only read %08lx of %08lx bytes "
                "for %p\n",
                returnLength,
                sizeof(DEVICE_EXTENSION),
                curAddress
                );
            return;

        }

        //
        // Recurse
        //
        dumpAcpiExtension(
            curAddress,
            Verbose,
            IndentLevel + 4
            );

        //
        // Point to the next extension
        //
        listEntry = deviceExtension.SiblingDeviceList.Flink;

    }
}

VOID
dumpPM1ControlRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{


    //
    // Dump the PM1 Control Flags
    //
    dumpFlags(
        (Value & 0xFF),
        &PM1StatusFlags[0],
        sizeof(PM1ControlFlags) / sizeof(FLAG_RECORD),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

}

VOID
dumpPM1StatusRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    )
{

    //
    // Dump the PM1 Status Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1StatusFlags,
        (sizeof(PM1StatusFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );

    //
    // Switch to the PM1 Enable Flags
    //
    Value >>= 16;


    //
    // Dump the PM1 Enable Flags
    //
    dumpFlags(
        (Value & 0xFFFF),
        PM1EnableFlags,
        (sizeof(PM1EnableFlags) / sizeof(FLAG_RECORD)),
        IndentLevel,
        (DUMP_FLAG_LONG_NAME | DUMP_FLAG_SHOW_BIT | DUMP_FLAG_TABLE)
        );
}

VOID
dumpAcpiPowerList(
    IN  PUCHAR  ListName
    )
/*++

    This routine fetects a single Power Device List from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;

    //
    // Handle the queue list
    //
    address = GetExpression( ListName );
    if (!address) {

        dprintf( "dumpAcpiPowerList: could not read %s\n", ListName );

    } else {

        dprintf("  %s at %p\n", ListName, address );
        status = ReadMemory(
            address,
            &listEntry,
            sizeof(LIST_ENTRY),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

            dprintf(
                "dumpAcpiPowerList: could not read LIST_ENTRY at %08lx\n",
                address
                );

        } else {

            dumpDeviceListEntry(
                &listEntry,
                address
                );
            dprintf("\n");

        }

    }
}

VOID
dumpAcpiPowerLists(
    VOID
    )
/*++

Routine Description:

    This routine fetches the Power Device list from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;
    ULONG       value;

    status = GetUlongPtr( "ACPI!AcpiPowerLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerLock\n");
        return;

    }

    dprintf("ACPI Power Information\n");
    if (address) {

        dprintf("  + ACPI!AcpiPowerLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerLock is not owned\n");

    }

    status = GetUlongPtr( "ACPI!AcpiPowerQueueLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerQueueLock\n");
        return;

    }
    if (address) {

        dprintf("  + ACPI!AcpiPowerQueueLock is owned\n");

        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerQueueLock is not owned\n" );

    }

    status = GetUlong( "ACPI!AcpiPowerWorkDone", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerWorkDone\n");
        return;

    }
    dprintf("  + AcpiPowerWorkDone = %s\n", (value ? "TRUE" : "FALSE" ) );


    status = GetUlong( "ACPI!AcpiPowerDpcRunning", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerLists: Could not read ACPI!AcpiPowerDpcRunning\n");
        return;

    }
    dprintf("  + AcpiPowerDpcRunning = %s\n", (value ? "TRUE" : "FALSE" ) );

    dumpAcpiPowerList( "ACPI!AcpiPowerQueueList" );
    dumpAcpiPowerList( "ACPI!AcpiPowerDelayedQueueList" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase0List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase1List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase2List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase3List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase4List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerPhase5List" );
    dumpAcpiPowerList( "ACPI!AcpiPowerWaitWakeList" );

}

VOID
dumpAcpiPowerNode(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    )
/*++

Routine Description:

    This routine is called to display a power node

Arguments:

    PowerNode   - The power node to dump
    Address     - Where the power node is located
    Verbose     - How much information to display
    IndentLevel - How many characters to indent

Return Value:

    None

--*/
{
    BOOL    status;
    NSOBJ   ns;
    UCHAR   buffer[5];
    UCHAR   indent[80];
    ULONG   returnLength;

    buffer[4] = '\0';
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //
    // Read the associated power resource object
    //
    status = ReadMemory(
        (ULONG_PTR) PowerNode->PowerObject,
        &ns,
        sizeof(NSOBJ),
        &returnLength
        );
    if (status != FALSE && returnLength == sizeof(NSOBJ)) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );

    } else {

        buffer[0] = '\0';

    }

    dprintf("%sPower Node - %08lx %s\n", indent, Address, buffer );
    dprintf(
        "%s  Resource   %8lx   Order        %8lx   WorkDone    %8s\n",
        indent,
        PowerNode->PowerObject,
        PowerNode->ResourceOrder,
        WorkDone[ PowerNode->WorkDone ]
        );
    dprintf(
        "%s  On Method  %8lx   Off Method   %8lx   UseCounts   %8lx\n",
        indent,
        PowerNode->PowerOnObject,
        PowerNode->PowerOffObject,
        PowerNode->UseCounts
        );
    dprintf(
        "%s  Level      %8s   Flags        %8lx   ",
        indent,
        ShortSystemPowerStateTable[PowerNode->SystemLevel],
        PowerNode->Flags
        );
    dumpFlags(
        (PowerNode->Flags),
        &PowerNodeFlags[0],
        sizeof(PowerNodeFlags)/sizeof(FLAG_RECORD),
        0,
        (DUMP_FLAG_SHORT_NAME | DUMP_FLAG_NO_INDENT |
         DUMP_FLAG_SINGLE_LINE)
        );
    if (Verbose & VERBOSE_4) {

        dumpFlags(
            (PowerNode->Flags),
            &PowerNodeFlags[0],
            sizeof(PowerNodeFlags)/sizeof(FLAG_RECORD),
            IndentLevel + 4,
            (DUMP_FLAG_LONG_NAME)
            );

    }

}

VOID
dumpAcpiPowerNodes(
    VOID
    )
/*++

Routine Description:

    This routine fetches the Power Device list from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    ACPI_DEVICE_POWER_NODE  deviceNode;
    ACPI_POWER_DEVICE_NODE  powerNode;
    BOOL                    status;
    LIST_ENTRY              listEntry;
    PLIST_ENTRY             list;
    ULONG_PTR               addr;
    ULONG_PTR               address;
    ULONG_PTR               endAddress;
    ULONG                   returnLength;
    ULONG_PTR               startAddress;

    status = GetUlongPtr( "ACPI!AcpiPowerLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiPowerNodes: Could not read ACPI!AcpiPowerLock\n");
        return;

    }

    dprintf("ACPI Power Nodes\n");
    if (address) {

        dprintf("  + ACPI!AcpiPowerLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiPowerLock is not owned\n");

    }

    dprintf("Power Node List\n");
    startAddress = GetExpression( "ACPI!AcpiPowerNodeList" );
    if (!startAddress) {

        dprintf("dumpAcpiPowerNodes: could not read ACPI!AcpiPowerNodeList\n");
        return;

    }
    status = ReadMemory(
        startAddress,
        &listEntry,
        sizeof(LIST_ENTRY),
        &returnLength
        );
    if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

        dprintf(
            "dumpAcpiPowerNodes: could not read LIST_ENTRY at %08lx\n",
            startAddress
            );
        return;

    }

    //
    // Check to see if the list is empty
    //
    if ( (ULONG_PTR) listEntry.Flink == startAddress) {

        dprintf("  Empty\n");
        return;

    }

    address = (ULONG_PTR) CONTAINING_RECORD(
        (listEntry.Flink),
        ACPI_POWER_DEVICE_NODE,
        ListEntry
        );
    while (address != startAddress && address != 0) {

        //
        // Read the queued item
        //
        status = ReadMemory(
            address,
            &powerNode,
            sizeof(ACPI_POWER_DEVICE_NODE),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(ACPI_POWER_DEVICE_NODE)) {

            dprintf(
                "dumpIrpListEntry: Cannot read Node at %08lx\n",
                address
                );
            return;

        }

        //
        // dump the node
        //
        dumpAcpiPowerNode(
            &powerNode,
            address,
            0,
            0
            );

        //
        // Lets walk the list of power nodes
        //
        list = powerNode.DevicePowerListHead.Flink;
        endAddress = ( (ULONG_PTR) &(powerNode.DevicePowerListHead) -
                 (ULONG_PTR) &(powerNode) ) +
               address;

        //
        // Loop until back at the start
        //
        while (list != (PLIST_ENTRY) endAddress) {

            //
            // Crack the record
            //
            addr = (ULONG_PTR) CONTAINING_RECORD(
                list,
                ACPI_DEVICE_POWER_NODE,
                DevicePowerListEntry
                );

            status = ReadMemory(
                addr,
                &deviceNode,
                sizeof(ACPI_DEVICE_POWER_NODE),
                &returnLength
                );
            if (status == FALSE ||
                returnLength != sizeof(ACPI_DEVICE_POWER_NODE)) {

                dprintf(
                    "dumpIrpListEntry: Cannot read Node at %08lx\n",
                    addr
                    );
                continue;

            }

            //
            // Dump the record
            //
            dumpAcpiDeviceNode(
                &deviceNode,
                addr,
                0,
                2
                );

            //
            // Next record
            //
            list = deviceNode.DevicePowerListEntry.Flink;

        }

        dprintf("\n");

        //
        // Next record
        //
        address = (ULONG_PTR) CONTAINING_RECORD(
            powerNode.ListEntry.Flink,
            ACPI_POWER_DEVICE_NODE,
            ListEntry
            );

    }

}

VOID
dumpDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    ULONG_PTR           displacement;
    ACPI_POWER_REQUEST  request;
    BOOL                stat;
    PACPI_POWER_REQUEST nextRequest;
    PACPI_POWER_REQUEST requestAddress;
    ULONG               i = 0;
    ULONG               returnLength;

    //
    // Look at the next address
    //
    ListEntry = ListEntry->Flink;

    while (ListEntry != (PLIST_ENTRY) Address) {

        //
        // Crack the listEntry to determine where the powerRequest is
        //
        requestAddress = CONTAINING_RECORD(
            ListEntry,
            ACPI_POWER_REQUEST,
            ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) requestAddress,
            &request,
            sizeof(ACPI_POWER_REQUEST),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(ACPI_POWER_REQUEST)) {

            dprintf(
                "dumpDeviceListEntry: Cannot read PowerRequest at %08lx\n",
                requestAddress
                );
            return;

        }

        if (request.CallBack != NULL) {

            GetSymbol(
                request.CallBack,
                Buffer,
                &displacement
                );

        } else {

            Buffer[0] = '\0';

        }

        //
        // Dump the entry for the device
        //
        dprintf(
            "      %08lx\n"
            "        DeviceExtension:     %08lx",
            requestAddress,
            request.DeviceExtension
            );
        if (request.DeviceExtension != NULL) {

            dprintf(" - ");
            displayAcpiDeviceExtensionName(
                (ULONG_PTR) request.DeviceExtension
                );

        }
        dprintf("\n");
        dprintf(
            "        Status:              %08lx %s->%s\n",
            request.Status,
            WorkDone[request.WorkDone],
            WorkDone[request.NextWorkDone]
            );
        nextRequest = CONTAINING_RECORD(
            request.SerialListEntry.Flink,
            ACPI_POWER_REQUEST,
            SerialListEntry
            );
        if (nextRequest != requestAddress) {

            dprintf(
                "        SerialListEntry:     F - %08lx B - %08lx -> %08lx\n",
                request.SerialListEntry.Flink,
                request.SerialListEntry.Blink,
                nextRequest
                );

        }
        dprintf(
            "        CallBack:            %08lx (%s)\n"
            "        Context:             %08lx\n"
            "        RequestType:         %02lx\n"
            "        ResultData:          %08lx\n",
            request.CallBack,
            Buffer,
            request.Context,
            request.RequestType,
            requestAddress + (FIELD_OFFSET(ACPI_POWER_REQUEST, ResultData ) )
            );

        //
        // Dump some of the request specific information
        //
        if (request.RequestType == AcpiPowerRequestDevice) {

            dprintf(
                "        RequestType:         AcpiPowerRequestDevice\n"
                "        DevicePowerState:    %s\n"
                "        Flags:               %x ",
                DevicePowerStateTable[request.u.DevicePowerRequest.DevicePowerState],
                request.u.DevicePowerRequest.Flags
                );
            dumpFlags(
                (request.u.DevicePowerRequest.Flags),
                &PowerRequestFlags[0],
                sizeof(PowerRequestFlags)/sizeof(FLAG_RECORD),
                0,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE)
                );

        } else if (request.RequestType == AcpiPowerRequestSystem) {

            dprintf(
                "        RequestType:         AcpiPowerRequestSystem\n"
                "        SystemPowerState:    %s\n"
                "        SystemPowerAction:   %s\n",
                SystemPowerStateTable[request.u.SystemPowerRequest.SystemPowerState],
                SystemPowerActionTable[request.u.SystemPowerRequest.SystemPowerAction]
                );

        } else if (request.RequestType == AcpiPowerRequestWaitWake) {

            dprintf(
                "        RequestType:         AcpiPowerRequestWaitWake\n"
                "        SystemPowerState:    %s\n"
                "        Flags:               %x ",
                SystemPowerStateTable[request.u.WaitWakeRequest.SystemPowerState],
                request.u.WaitWakeRequest.Flags
                );
            dumpFlags(
                (request.u.WaitWakeRequest.Flags),
                &PowerRequestFlags[0],
                sizeof(PowerRequestFlags)/sizeof(FLAG_RECORD),
                0,
                (DUMP_FLAG_LONG_NAME | DUMP_FLAG_NO_INDENT |
                 DUMP_FLAG_SINGLE_LINE)
                );

        }

        //
        // Point to the next entry
        //
        ListEntry = request.ListEntry.Flink;

    } // while

}

VOID
dumpIrpListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    BOOL                stat;
    DEVICE_OBJECT       deviceObject;
    DEVICE_EXTENSION    deviceExtension;
    IO_STACK_LOCATION   irpStack;
    PIRP                irpAddress;
    PIO_STACK_LOCATION  tempStack;
    IRP                 irp;
    ULONG               returnLength;

    //
    // Look at the first element in the list
    //
    ListEntry = ListEntry->Flink;

    //
    // Loop for all items in the list
    //
    while (ListEntry != (PLIST_ENTRY) Address) {

        irpAddress = CONTAINING_RECORD(
            ListEntry,
            IRP,
            Tail.Overlay.ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) irpAddress,
            &irp,
            sizeof(IRP),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(IRP)) {

            dprintf(
                "dumpIrpListEntry: Cannot read Irp at %08lx\n",
                irpAddress
                );
            return;

        }

        //
        // Get the current stack location
        //
        tempStack = IoGetCurrentIrpStackLocation( &irp );
        if (tempStack == NULL) {

            dprintf(
                "dumpIrpListEntry: Cannot read IrpStack for Irp at %08lx\n",
                irpAddress
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) tempStack,
            &irpStack,
            sizeof(IO_STACK_LOCATION),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(IO_STACK_LOCATION)) {

            dprintf(
                "dumpIrpListEntry: Cannot read IoStackLocation at %08lx\n",
                tempStack
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) irpStack.DeviceObject,
            &deviceObject,
            sizeof(DEVICE_OBJECT),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(DEVICE_OBJECT)) {

            dprintf(
                "dumpIrpListEntry: Cannot read DeviceObject at %08lx\n",
                irpStack.DeviceObject
                );
            return;

        }

        stat = ReadMemory(
            (ULONG_PTR) deviceObject.DeviceExtension,
            &deviceExtension,
            sizeof(DEVICE_EXTENSION),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(DEVICE_EXTENSION)) {

            dprintf(
                "dumpIrpListEntry: Cannot read DeviceExtension at %08lx\n",
                deviceObject.DeviceExtension
                );
            return;

        }

        memset( Buffer, '0', 2048 );
        stat = ReadMemory(
            (ULONG_PTR) deviceExtension.DeviceID,
            Buffer,
            256,
            &returnLength
            );
        if (stat && Buffer[0] != '\0' && returnLength != 0) {

            dprintf(
                "    Irp: %08x Device: %08lx (%s)\n",
                irpAddress,
                irpStack.DeviceObject,
                Buffer
                );

        } else {

            dprintf(
                "    Irp: %08x Device: %08lx\n",
                irpAddress,
                irpStack.DeviceObject
                );

        }

        //
        // Next item on the queue
        //
        ListEntry = irp.Tail.Overlay.ListEntry.Flink;

    }

}

VOID
dumpNSObject(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This function dumps a Name space object

Arguments:

    Address     - Where to find the object
    Verbose     - Should the object be dumped as well?
    IndentLevel - How much to indent

Return Value:

    None

--*/
{
    BOOL    b;
    NSOBJ   ns;
    UCHAR   buffer[5];
    UCHAR   indent[80];

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    buffer[4] = '\0';

    //
    // First step is to read the root NS
    //
    b = ReadMemory(
        Address,
        &ns,
        sizeof(NSOBJ),
        NULL
        );
    if (!b) {

        dprintf("%sdumpNSObject: could not read %x\n", indent,Address );
        return;

    }

    if (ns.dwNameSeg != 0) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );

    } else {

        sprintf( buffer, "    ");

    }

    dprintf(
        "%sNameSpace Object %s (%08lx) - Device %08lx\n",
        indent,
        buffer,
        Address,
        ns.Context
        );
    if (Verbose & VERBOSE_NSOBJ) {

        dprintf(
            "%s  Flink %08lx  Blink  %08lx  Parent %08lx  Child %08lx\n",
            indent,
            ns.list.plistNext,
            ns.list.plistPrev,
            ns.pnsParent,
            ns.pnsFirstChild
            );

    }
    dprintf(
        "%s  Value %08lx  Length %08lx  Buffer %08lx  Flags %08lx",
        indent,
        ns.ObjData.uipDataValue,
        ns.ObjData.dwDataLen,
        ns.ObjData.pbDataBuff,
        ns.ObjData.dwfData
        );
    if (ns.ObjData.dwfData & DATAF_BUFF_ALIAS) {

        dprintf("  Alias" );

    }
    if (ns.ObjData.dwfData & DATAF_GLOBAL_LOCK) {

        dprintf("  Lock");

    }
    dprintf("\n");

    dumpObject( Address, &(ns.ObjData), Verbose, IndentLevel + 4);
}

VOID
dumpNSTree(
    IN  ULONG_PTR   Address,
    IN  ULONG       Level
    )
/*++

Routine Description:

    This thing dumps the NS tree

Arguments:

    Address - Where to find the root node --- we start dumping at the children

Return Value:

    None

--*/
{
    BOOL        end = FALSE;
    BOOL        b;
    NSOBJ       ns;
    UCHAR       buffer[5];
    ULONG_PTR   next;
    ULONG       back;
    ULONG_PTR   m1 = 0;
    ULONG_PTR   m2 = 0;
    ULONG       reason;
    ULONG       dataBuffSize;

    buffer[4] = '\0';

    //
    // Indent
    //
    for (m1 = 0; m1 < Level; m1 ++) {

        dprintf("| ");

    }

    //
    // First step is to read the root NS
    //
    b = ReadMemory(
        Address,
        &ns,
        sizeof(NSOBJ),
        NULL
        );
    if (!b) {

        dprintf("dumpNSTree: could not read %x\n", Address );
        return;

    }

    if (ns.dwNameSeg != 0) {

        memcpy( buffer, &(ns.dwNameSeg), 4 );
        dprintf("%4s ", buffer );

    } else {

        dprintf("     " );

    }
    dprintf(
        "(%08x) - ", Address );

    if (ns.Context != 0) {

        dprintf("Device %08lx\n", ns.Context );

    } else {

        //
        // We need to read the pbDataBuff here
        //
        if (ns.ObjData.pbDataBuff != 0) {

            dataBuffSize = (ns.ObjData.dwDataLen > 2047 ?
                2047 : ns.ObjData.dwDataLen
                );
            b = ReadMemory(
                (ULONG_PTR) ns.ObjData.pbDataBuff,
                Buffer,
                dataBuffSize,
                NULL
                );
            if (!b) {

                dprintf(
                    "dumpNSTree: could not read %x\n",
                    ns.ObjData.pbDataBuff
                    );
                return;

            }

        }
        switch(ns.ObjData.dwDataType) {
            default:
            case OBJTYPE_UNKNOWN:       dprintf("Unknown\n");           break;
            case OBJTYPE_INTDATA:
                dprintf("Integer - %lx\n", ns.ObjData.uipDataValue);
                break;
            case OBJTYPE_STRDATA:
                Buffer[dataBuffSize+1] = '\0';
                dprintf(
                     "String - %s\n",
                     Buffer
                     );
                break;
            case OBJTYPE_BUFFDATA:
                dprintf(
                     "Buffer - %08lx L=%04x\n",
                     ns.ObjData.pbDataBuff,
                     ns.ObjData.dwDataLen
                     );
                break;
            case OBJTYPE_PKGDATA: {

                PPACKAGEOBJ package = (PPACKAGEOBJ) Buffer;

                dprintf("Package - NumElements %x\n",package->dwcElements);
                break;

            }
            case OBJTYPE_FIELDUNIT:{

                PFIELDUNITOBJ   fieldUnit = (PFIELDUNITOBJ) Buffer;

                dprintf(
                    "FieldUnit - Parent %x Offset %x Start %x "
                    "Num %x Flags %x\n",
                    fieldUnit->pnsFieldParent,
                    fieldUnit->FieldDesc.dwByteOffset,
                    fieldUnit->FieldDesc.dwStartBitPos,
                    fieldUnit->FieldDesc.dwNumBits,
                    fieldUnit->FieldDesc.dwFieldFlags
                    );
                break;

            }
            case OBJTYPE_DEVICE:
                dprintf("Device\n");
                break;
            case OBJTYPE_EVENT:
                dprintf("Event - PKEvent %x\n", ns.ObjData.pbDataBuff);
                break;
            case OBJTYPE_METHOD: {

                PMETHODOBJ  method = (PMETHODOBJ) Buffer;

                dprintf(
                     "Method - Flags %x Start %08lx Len %x\n",
                     method->bMethodFlags,
                     (ULONG_PTR) method->abCodeBuff - (ULONG_PTR) method +
                        (ULONG_PTR) ns.ObjData.pbDataBuff,
                     (ULONG) ns.ObjData.dwDataLen - sizeof(METHODOBJ) +
                        ANYSIZE_ARRAY
                     );
                 break;

            }
            case OBJTYPE_OPREGION: {

                POPREGIONOBJ    opRegion = (POPREGIONOBJ) Buffer;

                dprintf(
                    "Opregion - RegionsSpace=%08x OffSet=%x Len=%x\n",
                    opRegion->bRegionSpace,
                    opRegion->uipOffset,
                    opRegion->dwLen
                    );
                break;

            }
            case OBJTYPE_BUFFFIELD: {

                PBUFFFIELDOBJ   field   = (PBUFFFIELDOBJ) Buffer;

                dprintf(
                    "Buffer Field Ptr=%x Len=%x Offset=%x Start=%x"
                    "NumBits=%x Flgas=%x\n",
                    field->pbDataBuff,
                    field->dwBuffLen,
                    field->FieldDesc.dwByteOffset,
                    field->FieldDesc.dwStartBitPos,
                    field->FieldDesc.dwNumBits,
                    field->FieldDesc.dwFieldFlags
                    );
                break;

            }
            case OBJTYPE_FIELD: {

                dprintf("Field\n");
                break;

            }
            case OBJTYPE_INDEXFIELD:    dprintf("Index Field\n");       break;

            case OBJTYPE_MUTEX:         dprintf("Mutex\n");             break;
            case OBJTYPE_POWERRES:      dprintf("Power Resource\n");    break;
            case OBJTYPE_PROCESSOR:     dprintf("Processor\n");         break;
            case OBJTYPE_THERMALZONE:   dprintf("Thermal Zone\n");      break;
            case OBJTYPE_DDBHANDLE:     dprintf("DDB Handle\n");        break;
            case OBJTYPE_DEBUG:         dprintf("Debug\n");             break;
            case OBJTYPE_OBJALIAS:      dprintf("Object Alias\n");      break;
            case OBJTYPE_DATAALIAS:     dprintf("Data Alias\n");        break;
            case OBJTYPE_BANKFIELD:     dprintf("Bank Field\n");        break;

        }

    }
    m1 = next = (ULONG_PTR) ns.pnsFirstChild;

    while (next != 0 && end == FALSE) {

        if (CheckControlC()) {

            break;

        }

        b = ReadMemory(
            next,
            &ns,
            sizeof(NSOBJ),
            NULL
            );
        if (!b) {

            dprintf("dumpNSTree: could not read %x\n", next );
            return;

        }

        dumpNSTree( next, Level + 1);

        //
        // Do the end check tests
        //
        if ( m2 == 0) {

            m2 = (ULONG_PTR) ns.list.plistPrev;

        } else if (m1 == (ULONG_PTR) ns.list.plistNext) {

            end = TRUE;
            reason = 1;

        } else if (m2 == next) {

            end = TRUE;
            reason = 2;
        }

        next = (ULONG_PTR) ns.list.plistNext;

    }

}

VOID
dumpObject(
    IN  ULONG_PTR   Address,
    IN  POBJDATA    Object,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

Routine Description:

    This dumps an Objdata so that it can be understand --- great for debugging some of the
    AML code

Arguments:

    Address - Where the Object is located
    Object  - Pointer to the object

Return Value:

    None

--*/
{
    BOOL        b;
    NTSTATUS    status;
    UCHAR       buffer[2048];
    UCHAR       indent[80];
    ULONG       max;
    ULONG       returnLength;

    //
    // Init the buffers
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    dprintf("%sObject Data - %08lx Type - ", indent, Address );

    //
    // First step is to read whatever the buffer points to, if it
    // points to something
    //
    if (Object->pbDataBuff != 0) {

        max = (Object->dwDataLen > 2047 ? 2047 : Object->dwDataLen );
        b = ReadMemory(
            (ULONG_PTR) Object->pbDataBuff,
            buffer,
            max,
            &returnLength
            );
        if (!b || returnLength != max) {

            dprintf(
                "%sdumpObject: Could not read buffer %08lx (%d) %x<->%x\n",
                indent,
                Object->pbDataBuff,
                b,
                max,
                returnLength
                );
            return;

        }

    }
    switch( Object->dwDataType ) {
        case OBJTYPE_INTDATA:
            dprintf(
                "%02x <Integer> Value=%08lx\n",
                Object->dwDataType,
                Object->uipDataValue
                );
            break;
        case OBJTYPE_STRDATA:
            buffer[max] = '\0';
            dprintf(
                "%02x <String> String=%s\n",
                Object->dwDataType,
                buffer
                );
            break;
        case OBJTYPE_BUFFDATA:
            dprintf(
                "%02x <Buffer> Ptr=%08lx Length = %2x\n",
                Object->dwDataType,
                Object->pbDataBuff,
                Object->dwDataLen
                );
            break;
        case OBJTYPE_PKGDATA: {

            PPACKAGEOBJ package = (PPACKAGEOBJ) buffer;
            ULONG       i = 0;
            ULONG       j = package->dwcElements;

            dprintf(
                "%02x <Package> NumElements=%02x\n",
                Object->dwDataType,
                j
                );

            if (Verbose & VERBOSE_OBJECT) {

                for (; i < j; i++) {

                    dumpObject(
                        (ULONG_PTR) &(package->adata[i]) - (ULONG_PTR) package +
                        (ULONG_PTR) Object->pbDataBuff,
                        &(package->adata[i]),
                        Verbose,
                        IndentLevel+ 2
                        );

                }

            }

            break;

        }
        case OBJTYPE_FIELDUNIT: {

            PFIELDUNITOBJ   fieldUnit = (PFIELDUNITOBJ) buffer;

            dprintf(
                "%02x <Field Unit> Parent=%08lx Offset=%08lx Start=%08x "
                "Num=%x Flags=%x\n",
                Object->dwDataType,
                fieldUnit->pnsFieldParent,
                fieldUnit->FieldDesc.dwByteOffset,
                fieldUnit->FieldDesc.dwStartBitPos,
                fieldUnit->FieldDesc.dwNumBits,
                fieldUnit->FieldDesc.dwFieldFlags
                );
            break;

        }
        case OBJTYPE_DEVICE:
            dprintf(
                "%02x <Device>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_EVENT:
            dprintf(
                "%02x <Event> PKEvent=%08lx\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;
        case OBJTYPE_METHOD: {

            PMETHODOBJ  method = (PMETHODOBJ) buffer;

            max = Object->dwDataLen - sizeof(METHODOBJ) + ANYSIZE_ARRAY;
            dprintf(
                "%02x <Method> Flags=%x Start=%x Len=%x\n",
                Object->dwDataType,
                method->bMethodFlags,
                (ULONG_PTR) method->abCodeBuff - (ULONG_PTR) method +
                (ULONG_PTR) Object->pbDataBuff,
                max
                );
            break;

        }
        case OBJTYPE_MUTEX:

            dprintf(
                "%02x <Mutex> Mutex=%08lx\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;

        case OBJTYPE_OPREGION: {

            POPREGIONOBJ    opRegion = (POPREGIONOBJ) buffer;

            dprintf(
                "%02x <Operational Region> RegionSpace=%08x OffSet=%x "
                "Len=%x\n",
                Object->dwDataType,
                opRegion->bRegionSpace,
                opRegion->uipOffset,
                opRegion->dwLen
                );
            break;

        }

        case OBJTYPE_POWERRES: {

            PPOWERRESOBJ    powerRes = (PPOWERRESOBJ) buffer;

            dprintf(
                "%02x <Power Resource> SystemLevel=S%d Order=%x\n",
                Object->dwDataType,
                powerRes->bSystemLevel,
                powerRes->bResOrder
                );
            break;

        }

        case OBJTYPE_PROCESSOR: {

            PPROCESSOROBJ   proc = (PPROCESSOROBJ) buffer;

            dprintf(
                "%02x <Processor> AcpiID=%x PBlk=%x PBlkLen=%x\n",
                Object->dwDataType,
                proc->bApicID,
                proc->dwPBlk,
                proc->dwPBlkLen
                );
            break;

        }

        case OBJTYPE_THERMALZONE:
            dprintf(
                "%02x <Thermal Zone>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_BUFFFIELD: {

            PBUFFFIELDOBJ   field   = (PBUFFFIELDOBJ) buffer;

            dprintf(
                "%02x <Buffer Field> Ptr=%x Len=%x Offset=%x Start=%x "
                "NumBits=%x Flags=%x\n",
                Object->dwDataType,
                field->pbDataBuff,
                field->dwBuffLen,
                field->FieldDesc.dwByteOffset,
                field->FieldDesc.dwStartBitPos,
                field->FieldDesc.dwNumBits,
                field->FieldDesc.dwFieldFlags
                );
            break;

        }

        case OBJTYPE_DDBHANDLE:
            dprintf(
                "%02x <DDB Handle> Handle=%x\n",
                Object->dwDataType,
                Object->pbDataBuff
                );
            break;
        case OBJTYPE_DEBUG:
            dprintf(
                "%02x <Internal Debug>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_OBJALIAS:

            dprintf(
                "%02x <Internal Object Alias> NS Object=%x\n",
                Object->dwDataType,
                Object->uipDataValue
                );
            dumpNSObject( Object->uipDataValue, Verbose, IndentLevel + 2 );
            break;
        case OBJTYPE_DATAALIAS: {

            OBJDATA     objData;

            dprintf(
                "%02x <Internal Data Alias> Data Object=%x\n",
                Object->dwDataType,
                Object->uipDataValue
                );

            b = ReadMemory(
                (ULONG) Object->uipDataValue,
                &objData,
                sizeof(OBJDATA),
                NULL
                );
            if (!b) {

                dprintf(
                    "dumpObject: could not read %x\n",
                    Object->uipDataValue
                    );
                return;

            }
            dumpObject(
                (ULONG) Object->uipDataValue,
                &objData,
                Verbose,
                IndentLevel + 2
                );
            break;

        }
        case OBJTYPE_BANKFIELD:
            dprintf(
                "%02x <Internal Bank Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_FIELD:
            dprintf(
                "%02x <Internal Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_INDEXFIELD:
            dprintf(
                "%02x <Index Field>\n",
                Object->dwDataType
                );
            break;
        case OBJTYPE_UNKNOWN:
        default:
            dprintf(
                "%02x <Unknown>\n",
                Object->dwDataType
                );
            break;
    }
}


VOID
dumpPObject(
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose,
    IN  ULONG       IndentLevel
    )
/*++

Routine Description:

    This is a wrapper for dumpObject


--*/
{
    BOOL    result;
    OBJDATA objdata;
    ULONG   returnLength;

    result = ReadMemory(
        Address,
        &objdata,
        sizeof(OBJDATA),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(OBJDATA) ) {

        UCHAR   indent[80];

        IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
        memset( indent, ' ', IndentLevel );
        indent[IndentLevel] = '\0';

        dprintf(
            "%sdumpPObject: Could not OBJDATA %08lx\n",
            indent,
            Address
            );
        return;

    }

    dumpObject(
        Address,
        &objdata,
        Verbose,
        IndentLevel
        );
    return;

}

PUCHAR
TempToKelvins(
    IN  ULONG   Temp
    )
{
    static  UCHAR buffer[80];

    sprintf( buffer, "%d.%d", (Temp / 10 ), (Temp % 10) );
    return buffer;
}

PUCHAR
TimeToSeconds(
    IN  ULONG   Time
    )
{
    static  UCHAR buffer[80];

    sprintf( buffer, "%d.%d", (Time / 10 ), (Time % 10) );
    return buffer;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\build.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _BUILD_H_
#define _BUILD_H_

    VOID
    dumpAcpiBuildList(
        PUCHAR  ListName
        );

    VOID
    dumpAcpiBuildLists(
        VOID
        );

    VOID
    dumpBuildDeviceListEntry(
        IN  PLIST_ENTRY ListEntry,
        IN  ULONG_PTR   Address,
        IN  ULONG       Verbose
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\build.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

UCHAR       BuildBuffer[2048];


VOID
dumpAcpiBuildListHeader(
    )
/*++

Routine Description:

    This routine displays the top line in the build list dump

Arguments:

    None

Return value:

    None

--*/
{
    dprintf("Request  Wd Cu Nx BuildCon  NsObj    Status   Union   Special\n");
}

VOID
dumpAcpiBuildList(
    IN  PUCHAR  ListName
    )
/*++

    This routine fetects a single Power Device List from the target and
    displays it

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;

    //
    // Handle the queue list
    //
    address = GetExpression( ListName );
    if (!address) {

        dprintf( "dumpAcpiBuildList: could not read %s\n", ListName );

    } else {

        dprintf("%s at %08lx\n", ListName, address );
        status = ReadMemory(
            address,
            &listEntry,
            sizeof(LIST_ENTRY),
            &returnLength
            );
        if (status == FALSE || returnLength != sizeof(LIST_ENTRY)) {

            dprintf(
                "dumpAcpiBuildList: could not read LIST_ENTRY at %p\n",
                address
                );

        } else {

            dumpAcpiBuildListHeader();
            dumpBuildDeviceListEntry(
                &listEntry,
                address,
                0
                );
            dprintf("\n");

        }

    }
}

VOID
dumpAcpiBuildLists(
    VOID
    )
/*++

Routine Description:

    This routine dumps all of the devices lists used by the Build DPC

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL        status;
    LIST_ENTRY  listEntry;
    ULONG_PTR   address;
    ULONG       returnLength;
    ULONG       value;

    status = GetUlongPtr( "ACPI!AcpiDeviceTreeLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiDeviceTreeLock\n");
        return;

    }

    dprintf("ACPI Build Tree Information\n");
    if (address) {

        dprintf("  + ACPI!AcpiDeviceTreeLock is owned");

        //
        // The bits other then the lowest is where the owning thread is
        // located. This function uses the property that -2 is every bit
        // except the least significant one
        //
        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiDeviceTreeLock is not owned\n");

    }

    status = GetUlongPtr( "ACPI!AcpiBuildQueueLock", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildQueueLock\n");
        return;

    }
    if (address) {

        dprintf("  + ACPI!AcpiBuildQueueLock is owned\n");

        if ( (address & (ULONG_PTR) -2) != 0) {

            dprintf(" by thread at %p\n", (address & (ULONG_PTR) - 2) );

        } else {

            dprintf("\n");

        }

    } else {

        dprintf("  - ACPI!AcpiBuildQueueLock is not owned\n" );

    }

    status = GetUlong( "ACPI!AcpiBuildWorkDone", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildWorkDone\n");
        return;

    }
    dprintf("  + AcpiBuildWorkDone = %s\n", (value ? "TRUE" : "FALSE" ) );


    status = GetUlong( "ACPI!AcpiBuildDpcRunning", &value );
    if (status == FALSE) {

        dprintf("dumpAcpiBuildLists: Could not read ACPI!AcpiBuildDpcRunning\n");
        return;

    }
    dprintf("  + AcpiBuildDpcRunning = %s\n", (value ? "TRUE" : "FALSE" ) );

    dumpAcpiBuildList( "ACPI!AcpiBuildQueueList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildDeviceList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildOperationRegionList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildPowerResourceList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildRunMethodList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildSynchronizationList" );
    dumpAcpiBuildList( "ACPI!AcpiBuildThermalZoneList" );
}

VOID
dumpBuildDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address,
    IN  ULONG       Verbose
    )
/*++

Routine Description:

    This routine is called to dump a list of devices in one of the queues

Arguments:

    ListEntry   - The head of the list
    Address     - The original address of the list (to see when we looped
                  around

Return Value:

    NONE

--*/
{
    ULONG_PTR displacement;
    ACPI_BUILD_REQUEST  request;
    BOOL                stat;
    PACPI_BUILD_REQUEST requestAddress;
    UCHAR               buffer1[80];
    UCHAR               buffer2[80];
    UCHAR               buffer3[5];
    ULONG               i = 0;
    ULONG               returnLength;

    memset( buffer3, 0, 5);
    memset( buffer2, 0, 80);
    memset( buffer1, 0, 80);

    //
    // Look at the next address
    //
    ListEntry = ListEntry->Flink;

    while (ListEntry != (PLIST_ENTRY) Address) {

        //
        // Crack the listEntry to determine where the powerRequest is
        //
        requestAddress = CONTAINING_RECORD(
            ListEntry,
            ACPI_BUILD_REQUEST,
            ListEntry
            );

        //
        // Read the queued item
        //
        stat = ReadMemory(
            (ULONG_PTR) requestAddress,
            &request,
            sizeof(ACPI_BUILD_REQUEST),
            &returnLength
            );
        if (stat == FALSE || returnLength != sizeof(ACPI_BUILD_REQUEST)) {

            dprintf(
                "dumpBuildDeviceListEntry: Cannot read BuildRequest at %08lx\n",
                requestAddress
                );
            return;

        }

        if (request.CallBack != NULL) {

            GetSymbol(
                request.CallBack,
                buffer1,
                &displacement
                );

        } else {

            buffer1[0] = '\0';

        }
        if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

            GetSymbol(
                request.TargetListEntry,
                buffer2,
                &displacement
                );

        } else {

            buffer2[0] = '\0';

        }

        //
        // Dump the entry for the device
        //
        if (!Verbose) {

            dprintf(
                "%08lx %2x %2x %2x %08lx %08lx %08lx %08lx",
                requestAddress,
                request.WorkDone,
                request.CurrentWorkDone,
                request.NextWorkDone,
                request.BuildContext,
                request.CurrentObject,
                request.Status,
                request.String
                );
            if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

                dprintf(
                    " T: %08lx (%s)",
                    request.TargetListEntry,
                    buffer2
                    );

            } else if (request.Flags & BUILD_REQUEST_DEVICE) {

                 dprintf(
                     " O: %08lx",
                     requestAddress + FIELD_OFFSET( ACPI_BUILD_REQUEST, DeviceRequest.ResultData )
                 );

            } else if (request.Flags & BUILD_REQUEST_RUN) {

                memcpy( buffer3, request.RunRequest.ControlMethodNameAsUchar, 4);
                dprintf(
                    " R: %4s",
                    buffer3
                    );
                if (request.RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

                    dprintf(" Sta");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_MARK_INI) {

                    dprintf(" Ini");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

                    dprintf(" Rec");

                }

            } else if (request.Flags & BUILD_REQUEST_SYNC) {

                dprintf(
                    " S: %08lx",
                    request.SynchronizeRequest.SynchronizeListEntry
                    );
                if (request.SynchronizeRequest.Flags & SYNC_REQUEST_HAS_METHOD) {

                    memcpy( buffer3, request.SynchronizeRequest.SynchronizeMethodNameAsUchar, 4);
                    dprintf(
                        " %4s",
                        buffer3
                        );
                }

            }

            if (request.CallBack != NULL) {

                dprintf(" C: %s(%08lx)", buffer1, request.CallBackContext);

            }
            dprintf("\n");

        } else {

            dprintf(
                "%08lx\n"
                "  BuildContext:        %08lx\n"
                "  ListEntry:           F - %08lx B - %08lx\n"
                "  CallBack:            %08lx (%s)\n"
                "  CallBackContext:     %08lx\n"
                "  WorkDone:            %lx\n"
                "  CurrentWorkDone:     %lx\n"
                "  NextWorkDone:        %lx\n"
                "  CurrentObject:       %08lx\n"
                "  Status:              %08lx\n"
                "  Flags:               %08lx\n"
                "  Spare:               %08lx\n",
                requestAddress,
                request.BuildContext,
                request.ListEntry.Flink,
                request.ListEntry.Blink,
                request.CallBack,
                buffer1,
                request.CallBackContext,
                request.WorkDone,
                request.CurrentWorkDone,
                request.NextWorkDone,
                request.CurrentObject,
                request.Status,
                request.Flags,
                request.String
                );
            if (request.Flags & BUILD_REQUEST_VALID_TARGET) {

                dprintf(
                    "  TargetListEntry:     %08lx (%s)\n",
                    request.TargetListEntry,
                    buffer2
                    );

            } else if (request.Flags & BUILD_REQUEST_DEVICE) {

                dprintf(
                    "  ResultData:          %08lx\n",
                    requestAddress + FIELD_OFFSET( ACPI_BUILD_REQUEST, DeviceRequest.ResultData )
                    );

            } else if (request.Flags & BUILD_REQUEST_RUN) {

                dprintf(
                    "  ControlMethodName:   %4s\n"
                    "  ControlMethodFlags:  %08lx",
                    request.RunRequest.ControlMethodName
                    );
                if (request.RunRequest.Flags & RUN_REQUEST_CHECK_STATUS) {

                    dprintf(" Sta");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_MARK_INI) {

                    dprintf(" Ini");

                }
                if (request.RunRequest.Flags & RUN_REQUEST_RECURSIVE) {

                    dprintf(" Rec");

                }
                dprintf("\n");

            } else if (request.Flags & BUILD_REQUEST_SYNC) {

                dprintf(
                    " SynchronizeListEntry: %08lx\n"
                    " MethodName:           %4s\n",
                    request.SynchronizeRequest.SynchronizeListEntry,
                    request.SynchronizeRequest.SynchronizeMethodNameAsUchar
                    );

            }
            dprintf("\n");

        }

        //
        // Point to the next entry
        //
        ListEntry = request.ListEntry.Flink;

    } // while

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\dump.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dump.c

Abstract:

    Dumps a block of memory to file

Author:

    Stephane Plante (splante)

Environment:

    User Mode

--*/

#include "pch.h"

VOID
dumpMemory(
    IN  ULONG_PTR Address,
    IN  ULONG   Length,
    IN  PUCHAR  Name
    )
{
    BOOL    b;
    HANDLE  file;
    PUCHAR  buffer;
    ULONG   readLength;

    //
    // Open the file
    //
    file = CreateFile(
        Name,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL
        );
    if (file == INVALID_HANDLE_VALUE) {

        dprintf("dm: could not open '%s'\n",Name);
        return;

    }

    //
    // Read the bytes from memory
    //
    buffer = LocalAlloc( LPTR, Length );
    if (buffer == NULL) {

        dprintf("dm: could not allocate '0x%x' bytes\n", Length );
        CloseHandle( file );
        return;

    }
    b = ReadMemory(
        Address,
        buffer,
        Length,
        &readLength
        );
    if (!b) {

        dprintf(
            "dm: could not read '0x%x' bytes from '0x%p'\n",
            Length,
            Address
            );
        LocalFree ( buffer );
        CloseHandle( file );
        return;

    }

    //
    // Write the contents of memory to the file
    //
    WriteFile( file, buffer, readLength, &readLength, NULL );

    //
    // Done
    //
    CloseHandle( file );
    LocalFree( buffer );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\flags.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _FLAGS_H_
#define _FLAGS_H_

    #define DUMP_FLAG_NO_INDENT         0x000001
    #define DUMP_FLAG_NO_EOL            0x000002
    #define DUMP_FLAG_SINGLE_LINE       0x000004
    #define DUMP_FLAG_TABLE             0x000008
    #define DUMP_FLAG_LONG_NAME         0x000010
    #define DUMP_FLAG_SHORT_NAME        0x000020
    #define DUMP_FLAG_SHOW_BIT          0x000040
    #define DUMP_FLAG_ALREADY_INDENTED  0x000080

    typedef struct _FLAG_RECORD {
        ULONGLONG   Bit;
        PCCHAR      ShortName;
        PCCHAR      LongName;
        PCCHAR      NotShortName;
        PCCHAR      NotLongName;
    } FLAG_RECORD, *PFLAG_RECORD;

    ULONG
    dumpFlags(
        IN  ULONGLONG       Value,
        IN  PFLAG_RECORD    FlagRecords,
        IN  ULONG           FlagRecordSize,
        IN  ULONG           IndentLEvel,
        IN  ULONG           Flags
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\context.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    context.c

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 21-Mar-1997

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

VOID
dumpAccessFieldObject(
    IN  ULONG_PTR AccessFieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ACCFIELDOBJ     fieldObj;
    BOOL            result;
    UCHAR           buffer[80];
    ULONG           returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AccessFieldAddress,
        &fieldObj,
        sizeof(ACCFIELDOBJ),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(ACCFIELDOBJ) ||
        fieldObj.FrameHdr.dwSig != SIG_ACCFIELDOBJ) {

        dprintf(
            "%sdumpAccessFieldUnit: Coult not read ACCFIELDOBJ %08lx\n",
            buffer,
            AccessFieldAddress
            );
        return;

    }

    dprintf(
        "%sAccess Field Object - %08lx\n"
        "%s  Field Data Object:     %08lx\n",
        buffer, AccessFieldAddress,
        buffer, fieldObj.pdataObj
        );
    if (fieldObj.pdataObj != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldObj.pdataObj,
            Verbose,
            IndentLevel + 4
            );

    }
    dprintf(
        "%s  Target Buffer:         %08lx - %08lx\n"
        "%s  Access Size:           %08lx\n"
        "%s  # of Accesses:         %08lx\n"
        "%s  Data Mask:             %08lx\n"
        "%s  # of Left Bits:        %08lx\n"
        "%s  # of Right Bits:       %08lx\n"
        "%s  Index to #/Accesses:   %08lx\n"
        "%s  Temp Data:             %08lx\n",
        buffer, fieldObj.pbBuff, fieldObj.pbBuffEnd,
        buffer, fieldObj.dwAccSize,
        buffer, fieldObj.dwcAccesses,
        buffer, fieldObj.dwDataMask,
        buffer, fieldObj.iLBits,
        buffer, fieldObj.iRBits,
        buffer, fieldObj.iAccess,
        buffer, fieldObj.dwData
        );

    dprintf(
        "%s  Field Descriptor:      %p\n",
        buffer,
        ( (ULONG_PTR) &(fieldObj.fd) - (ULONG_PTR) &fieldObj + AccessFieldAddress )
        );
    dumpFieldAddress(
        ( (ULONG_PTR) &(fieldObj.fd) - (ULONG_PTR) &fieldObj + AccessFieldAddress ),
        Verbose,
        IndentLevel + 4
        );

}

VOID
dumpAccessFieldUnit(
    IN  ULONG_PTR AccessFieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ACCFIELDUNIT    fieldUnit;
    BOOL            result;
    UCHAR           buffer[80];
    ULONG           returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AccessFieldAddress,
        &fieldUnit,
        sizeof(ACCFIELDUNIT),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(ACCFIELDUNIT) ||
        fieldUnit.FrameHdr.dwSig != SIG_ACCFIELDUNIT) {

        dprintf(
            "%sdumpAccessFieldUnit: Coult not read ACCFIELDUNIT %08lx\n",
            buffer,
            AccessFieldAddress
            );
        return;

    }

    dprintf(
        "%sAccess Field Unit - %08lx\n"
        "%s  Field Data Object:     %08lx\n",
        buffer, AccessFieldAddress,
        buffer, fieldUnit.pdataObj
        );
    if (fieldUnit.pdataObj != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldUnit.pdataObj,
            Verbose,
            IndentLevel + 4
            );

    }
    dprintf(
        "%s  Source/Result Object:  %08lx\n",
        buffer,
        fieldUnit.pdata
        );
    if (fieldUnit.pdata != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpPObject(
            (ULONG_PTR) fieldUnit.pdata,
            Verbose,
            IndentLevel + 4
            );

    }

}

VOID
dumpAmlTerm(
    IN  ULONG_PTR AmlTermAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    AMLTERM     amlTerm;
    BOOL        result;
    INT         i;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        AmlTermAddress,
        &amlTerm,
        sizeof(AMLTERM),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(AMLTERM)) {

        dprintf(
            "\n%sdumpAmlTerm: Could not read AMLTERM 0x%08lx\n",
            buffer,
            AmlTermAddress
            );
        return;

    }

    if (amlTerm.pszTermName != NULL) {

        result = ReadMemory(
            (ULONG_PTR) amlTerm.pszTermName,
            Buffer,
            32,
            &returnLength
            );
        if (result && returnLength <= 32) {

            Buffer[returnLength] = '\0';
            dprintf(" - %s\n", Buffer );

        }

    }

}

VOID
dumpCall(
    IN  ULONG_PTR CallAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    CALL        call;
    INT         i;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        CallAddress,
        &call,
        sizeof(CALL),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(CALL) ||
        call.FrameHdr.dwSig != SIG_CALL) {

        dprintf(
            "%sdumpCall: Coult not read CALL %08lx\n",
            buffer,
            CallAddress
            );
        return;

    }

    dprintf(
        "%sCall - %08lx\n", buffer, CallAddress
        );

    //
    // Method
    //
    dprintf(
        "%s  Method:                %08lx\n",
        buffer,
        call.pnsMethod
        );
    if (call.pnsMethod != NULL && (Verbose & VERBOSE_CONTEXT)) {

        dumpNSObject( (ULONG_PTR) call.pnsMethod, Verbose, IndentLevel + 4);

    }

    //
    // Previous Call Frame
    //
    if (Verbose & VERBOSE_CALL) {

        dprintf(
            "%s  Previous Call Frame:   %08lx\n"
            "%s  Previous Owner:        %08lx\n",
            buffer,
            call.pcallPrev,
            buffer,
            call.pownerPrev
            );
        if (call.pownerPrev != NULL && (Verbose & VERBOSE_CONTEXT)) {

            dumpObjectOwner(
                (ULONG_PTR) call.pownerPrev,
                IndentLevel + 2
                );

        }

    }

    if (Verbose & VERBOSE_CONTEXT) {

        //
        // Dump arguments
        //
        dprintf(
            "%s  Arguments (Current):   %1d (%1d)\n",
            buffer,
            call.icArgs,
            call.iArg
            );
        for (i = 0; i < call.icArgs; i++) {

            dprintf(
                "%s  Argument(%d):          %p\n",
                buffer,
                i,
                (ULONG_PTR) (call.pdataArgs + i)
                );
            dumpPObject(
                (ULONG_PTR) (call.pdataArgs + i),
                Verbose,
                IndentLevel + 4
                );

        }

        dprintf(
            "%s  Result:                %08lx\n",
            buffer,
            call.pdataResult
            );
        if (call.pdataResult != NULL) {

            dumpPObject(
                (ULONG_PTR) call.pdataResult,
                Verbose,
                IndentLevel + 4
                );

        }

        if (Verbose & VERBOSE_CALL) {

            dprintf(
                "%s  Locals:\n",
                buffer
                );
            for (i = 0; i < MAX_NUM_LOCALS; i++) {

                dumpObject(
                    (ULONG) ( (PUCHAR) &(call.Locals[i]) - (PUCHAR) &call) +
                    CallAddress,
                    &(call.Locals[i]),
                    Verbose,
                    IndentLevel + 4
                    );

            }

        }

    }

}

VOID
dumpContext(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    )
/*++

Routine Description:

    This routine dumps a context structure in HRF

Arguments:

    ContextAddress  - Where on the target machine the context is located
    Verbose         - How verbose we should be

Return Value:

    None

--*/
{
    ULONG_PTR   displacement;
    BOOL        result;
    CTXT        context;
    ULONG       returnLength;

    //
    // Read the context from the target
    //
    result = ReadMemory(
        ContextAddress,
        &context,
        sizeof(CTXT),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(CTXT) ) {

        dprintf(
            "dumpContext: could not read CTXT %08lx\n",
            ContextAddress
            );
        return;

    }

    //
    // Is it a context?
    //
    if (context.dwSig != SIG_CTXT) {

        dprintf(
            "dumpContext: Signature (%08lx) != SIG_CTXT (%08lx)\n",
            context.dwSig,
            SIG_CTXT
            );
        return;

    }

    dprintf("Context - %08lx-%08lx\n",ContextAddress, context.pbCtxtEnd );
    if (Verbose & VERBOSE_CONTEXT) {

        dprintf(
            "  AllocatedContextList:    F:%08lx B:%08lx\n"
            "  QueingContextList:       F:%08lx B:%08lx\n"
            "  ContextListHead:         %08lx\n"
            "  SynchronizeLevel:        %08lx\n"
            "  CurrentOpByte:           %08lx\n"
            "  AsyncCallBack:           %08lx",
            context.listCtxt.plistNext, context.listCtxt.plistPrev,
            context.listQueue.plistNext, context.listQueue.plistPrev,
            context.pplistCtxtQueue,
            context.dwSyncLevel,
            context.pbOp,
            context.pfnAsyncCallBack
            );
        if (context.pfnAsyncCallBack != NULL) {

            GetSymbol(
                context.pfnAsyncCallBack,
                Buffer,
                &displacement
                );
            dprintf(" %s",
                Buffer
                );
        }
        dprintf(
            "\n"
            "  AsyncCallBackContext:    %08lx\n"
            "  AsyncDataCallBack:       %08lx\n",
            context.pvContext,
            context.pdataCallBack
            );

    }
    dprintf(
        "  Flags:                   %08lx",
        context.dwfCtxt
        );
    if (context.dwfCtxt & CTXTF_TIMER_PENDING) {

        dprintf(" Timer");

    }
    if (context.dwfCtxt & CTXTF_TIMEOUT) {

        dprintf(" Timeout");

    }
    if (context.dwfCtxt & CTXTF_READY) {

        dprintf(" Ready");

    }
    if (context.dwfCtxt & CTXTF_NEED_CALLBACK) {

        dprintf(" CallBack");

    }
    dprintf("\n");

    dprintf(
        "  NameSpace Object:        %08lx\n",
        context.pnsObj
        );
    if (Verbose & VERBOSE_CONTEXT) {

        dprintf(
            "  NameSpace Scope:         %08lx\n"
            "  NameSpace Owner:         %08lx\n",
            context.pnsScope,
            context.powner
            );
        if (context.powner != NULL) {

            dumpObjectOwner(
                (ULONG_PTR) context.powner,
                2
                );

        }

    }

    dprintf(
        "  Current Call Frame:      %08lx\n",
        context.pcall
        );
    if (context.pcall != NULL) {

        dumpCall(
            (ULONG_PTR) context.pcall,
            (Verbose & ~VERBOSE_CONTEXT),
            4
            );

    }

    dumpStack(
        ContextAddress,
        &context,
        Verbose,
        2
        );

}

VOID
dumpFieldAddress(
    IN  ULONG_PTR FieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    FIELDDESC   fd;
    BOOL        result;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        FieldAddress,
        &fd,
        sizeof(FIELDDESC),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(FIELDDESC) ) {

        dprintf(
            "%sdumpFieldAddress: Coult not read FIELDDESC %08lx\n",
            buffer,
            FieldAddress
            );
        return;

    }

    dprintf(
        "%sField Descriptor - %08lx\n"
        "%s  ByteOffset:          %08lx\n"
        "%s  Start Bit Position:  %08lx\n"
        "%s  Number of Bits:      %08lx\n"
        "%s  Flags:               %08lx\n",
        buffer, FieldAddress,
        buffer, fd.dwByteOffset,
        buffer, fd.dwStartBitPos,
        buffer, fd.dwNumBits,
        buffer, fd.dwFieldFlags
        );
}

VOID
dumpListContexts(
    IN  VOID
    )
/*++

--*/
{
    PLIST   pList;
    PLIST   pListNext;
}

VOID
dumpObjectOwner(
    IN  ULONG_PTR ObjOwnerAddress,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    OBJOWNER    objowner;
    UCHAR       buffer[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( buffer, ' ', IndentLevel );
    buffer[IndentLevel] = '\0';

    result = ReadMemory(
        ObjOwnerAddress,
        &objowner,
        sizeof(OBJOWNER),
        &returnLength
        );
    if (result == TRUE &&
        returnLength == sizeof(OBJOWNER) &&
        objowner.dwSig == SIG_OBJOWNER) {

        dprintf(
            "%sObjectOwner - %08lx\n"
            "%s  NameSpaceObject:     %08lx\n"
            "%s  List:                F:%08lx B:%08lx\n",
            buffer,
            ObjOwnerAddress,
            buffer,
            objowner.pnsObjList,
            buffer,
            objowner.list.plistNext,
            objowner.list.plistPrev
            );

    } else {

        dprintf(
            "%sdumpObjectOwner: Could not read OBJOWNER %08lx\n",
            buffer,ObjOwnerAddress
            );

    }
}

VOID
dumpScope(
    IN  ULONG_PTR ScopeAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    SCOPE       scope;
    UCHAR       indent[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';


    result = ReadMemory(
        ScopeAddress,
        &scope,
        sizeof(SCOPE),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(SCOPE) ||
        scope.FrameHdr.dwSig != SIG_SCOPE) {

        dprintf(
            "%sdumpScope: Coult not read SCOPE %08lx\n",
            indent,
            ScopeAddress
            );
        return;

    }

    dprintf(
        "%sScope - %08lx\n",
        indent,
        ScopeAddress
        );

    dprintf(
        "%s  ScopeEnd:              %08lx\n"
        "%s  ReturnAddress:         %08lx\n"
        "%s  Previous Scope:        %08lx\n",
        indent,
        scope.pbOpEnd,
        indent,
        scope.pbOpRet,
        indent,
        scope.pnsPrevScope
        );
    if (Verbose & VERBOSE_CALL) {

        dumpNSObject( (ULONG_PTR) scope.pnsPrevScope, Verbose, IndentLevel + 4);

    }

    dprintf(
        "%s  Previous Owner:        %08lx\n",
        indent,
        scope.pownerPrev
        );
    if (Verbose & VERBOSE_CALL) {

        dumpObjectOwner(
            (ULONG_PTR) scope.pownerPrev,
            IndentLevel + 4
            );

    }

    dprintf(
        "%s  Result Object:         %08lx\n",
        indent,
        scope.pdataResult
        );
    if (scope.pdataResult != NULL && (Verbose & VERBOSE_CALL) ) {

        dumpPObject(
            (ULONG_PTR) scope.pdataResult,
            Verbose,
            IndentLevel + 4
            );

    }
}

VOID
dumpStack(
    IN  ULONG_PTR ContextAddress,
    IN  PCTXT   Context,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    ULONG_PTR   displacement;
    BOOL        result;
    FRAMEHDR    frame;
    PUCHAR      frameAddress;
    UCHAR       indent[80];
    UCHAR       buffer[5];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';
    buffer[4] = '\0';

    dprintf(
        "%sStack - %p-%08lx (%08lx)\n",
        indent,
        ContextAddress,
        Context->LocalHeap.pbHeapEnd,
        Context->pbCtxtEnd
        );

    //
    // Calculate where the first frame lies
    //
    frameAddress = Context->LocalHeap.pbHeapEnd;
    while (frameAddress < Context->pbCtxtEnd) {

        result = ReadMemory(
            (ULONG_PTR) frameAddress,
            &frame,
            sizeof(FRAMEHDR),
            &returnLength
            );
        if (result != TRUE ||
            returnLength != sizeof(FRAMEHDR)) {

            dprintf(
                "%sdumpStack: could not read FRAMEHDR %08lx\n",
                indent,
                (ULONG_PTR) frameAddress
                );
            return;

        }

        memcpy( buffer, (PUCHAR) &(frame.dwSig), 4 );
        dprintf(
            "%s  %p: %s - (Length %08lx) (Flags %08lx)\n"
            "%s    ParseFunction          %08lx",
            indent,
            (ULONG_PTR) frameAddress,
            buffer,
            frame.dwLen,
            frame.dwfFrame,
            indent,
            frame.pfnParse
            );
        if (frame.pfnParse != NULL) {

            GetSymbol(
                frame.pfnParse,
                Buffer,
                &displacement
                );
            dprintf(" %s",
                Buffer
                );

        }
        dprintf("\n");

        //
        // Do we know how to crack the frame?
        //
        switch(frame.dwSig) {
            case SIG_CALL:

                dumpCall(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;
            case SIG_SCOPE:

                dumpScope(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_TERM:

                dumpTerm(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_ACCFIELDUNIT:

                dumpAccessFieldUnit(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

            case SIG_ACCFIELDOBJ:

                dumpAccessFieldObject(
                    (ULONG_PTR) frameAddress,
                    Verbose,
                    IndentLevel + 4
                    );
                break;

        }

        //
        // Make sure that there is some white space present
        //
        dprintf("\n\n");

        //
        // Next11
        //
        frameAddress += frame.dwLen;

    }

}

VOID
dumpTerm(
    IN  ULONG_PTR TermAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    )
{
    BOOL        result;
    INT         i;
    TERM        term;
    UCHAR       indent[80];
    ULONG       returnLength;

    //
    // Initialize the indent buffer
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    result = ReadMemory(
        TermAddress,
        &term,
        sizeof(TERM),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(TERM) ||
        term.FrameHdr.dwSig != SIG_TERM) {

        dprintf(
            "%sdumpTerm: Coult not read TERM %08lx\n",
            indent,
            TermAddress
            );
        return;

    }

    dprintf(
        "%sTerm - %08lx\n",
        indent,
        TermAddress
        );

    dprintf(
        "%s  OpCodeStart:           %08lx\n"
        "%s  OpCodeEnd:             %08lx\n"
        "%s  ScopeEnd:              %08lx\n"
        "%s  NameSpaceObject:       %08lx\n",
        indent,
        term.pbOpTerm,
        indent,
        term.pbOpEnd,
        indent,
        term.pbScopeEnd,
        indent,
        term.pnsObj
        );
    if ( term.pnsObj != NULL && (Verbose & VERBOSE_CALL)) {

        dumpNSObject( (ULONG_PTR) term.pnsObj, Verbose, IndentLevel + 4);

    }

    dprintf(
        "%s  Aml Term:              %08lx",
        indent,
        term.pamlterm
        );
    if (term.pamlterm != NULL) {

        dumpAmlTerm( (ULONG_PTR) term.pamlterm, Verbose, IndentLevel + 4);

    } else {

        dprintf("\n");

    }

    //
    // Dump arguments
    //
    dprintf(
        "%s  Arguments (Current):   %1d (%1d)\n",
        indent,
        term.icArgs,
        term.iArg
        );

    for (i = 0; i < term.icArgs; i++) {

        dprintf(
            "%s  Argument(%d):           %p\n",
            indent,
            i,
            (ULONG_PTR) (term.pdataArgs + i)
            );

        if (Verbose & VERBOSE_CALL) {

            dumpPObject(
                (ULONG_PTR) (term.pdataArgs + i),
                Verbose,
                IndentLevel + 4
                );

        }

    }

    dprintf(
        "%s  Result:                %08lx\n",
        indent,
        term.pdataResult
        );
    if (term.pdataResult != NULL && (Verbose & VERBOSE_CALL) ) {

        dumpPObject(
            (ULONG_PTR) term.pdataResult,
            Verbose,
            IndentLevel + 4
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\flags.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    flags.c

Abstract:

    dumps the various flags that ACPIKD knows about

Author:

    Stephane Plante

Environment:

    User

Revision History:

--*/

#include "pch.h"

ULONG
dumpFlags(
    IN  ULONGLONG       Value,
    IN  PFLAG_RECORD    FlagRecords,
    IN  ULONG           FlagRecordSize,
    IN  ULONG           IndentLevel,
    IN  ULONG           Flags
    )
/*++

Routine Description:

    This routine dumps the flags specified in Value according to the
    description passing into FlagRecords. The formating is affected by
    the flags field

Arguments:

    Value           - The values
    FlagRecord      - What each bit in the flags means
    FlagRecordSize  - How many flags there are
    IndentLevel     - The base indent level
    Flags           - How we will process the flags

Return Value:

    ULONG   - the number of characters printed. 0 if we printed nothing

--*/
#define STATUS_PRINTED          0x00000001
#define STATUS_INDENTED         0x00000002
#define STATUS_NEED_COUNTING    0x00000004
#define STATUS_COUNTED          0x00000008
{
    PCHAR       string;
    UCHAR       indent[80];
    ULONG       column = IndentLevel;
    ULONG       currentStatus = 0;
    ULONG       fixedSize = 0;
    ULONG       stringSize;
    ULONG       tempCount;
    ULONG       totalCount = 0;
    ULONGLONG   i, j, k;

    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel);
    memset( indent, ' ', IndentLevel );
    indent[IndentLevel] = '\0';

    //dprintf("DumpFlags( %I64x, %x, %x, %x, %x )\n", Value, FlagRecords, FlagRecordSize, IndentLevel, Flags );

    //
    // Do we need to make a table?
    //
    if ( (Flags & DUMP_FLAG_TABLE) &&
        !(Flags & DUMP_FLAG_SINGLE_LINE) ) {

        currentStatus |= STATUS_NEED_COUNTING;

    }
    if ( (Flags & DUMP_FLAG_ALREADY_INDENTED) ) {

        currentStatus |= STATUS_INDENTED;

    }

    //
    // loop over all the steps that we need to do
    //
    while (1) {

        //dprintf("While(1)\n");

        for (i = 0; i < 64; i++) {

            k = ((ULONGLONG)1 << i);
            for (j = 0; j < FlagRecordSize; j++) {

                //dprintf("FlagRecords[%x].Bit = %I64x\n", j, FlagRecords[j].Bit );
                if (!(FlagRecords[j].Bit & Value) ) {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].NotLongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].NotShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].NotLongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].NotShortName;

                    }

                } else {

                    //
                    // Are we looking at the correct bit?
                    //
                    if (!(FlagRecords[j].Bit & k) ) {

                        continue;

                    }

                    //
                    // Yes, we are, so pick the not-present values
                    //
                    if ( (Flags & DUMP_FLAG_LONG_NAME && FlagRecords[j].LongName == NULL) ||
                         (Flags & DUMP_FLAG_SHORT_NAME && FlagRecords[j].ShortName == NULL) ) {

                        continue;

                    }

                    if ( (Flags & DUMP_FLAG_LONG_NAME) ) {

                        string = FlagRecords[j].LongName;

                    } else if ( (Flags & DUMP_FLAG_SHORT_NAME) ) {

                        string = FlagRecords[j].ShortName;

                    }

                }

                if (currentStatus & STATUS_NEED_COUNTING) {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }
                    if (stringSize > fixedSize) {

                        fixedSize = stringSize;

                    }
                    continue;

                }


                if (currentStatus & STATUS_COUNTED) {

                    stringSize = fixedSize;

                } else {

                    stringSize = strlen( string ) + 1;
                    if (Flags & DUMP_FLAG_SHOW_BIT) {

                        stringSize += (4 + ( (ULONG) i / 4));
                        if ( (i % 4) != 0) {

                            stringSize++;

                        }

                    }

                }

                if (!(Flags & DUMP_FLAG_SINGLE_LINE) ) {

                    if ( (stringSize + column) > 79 ) {

                        dprintf("\n%n", &tempCount);
                        currentStatus &= ~STATUS_INDENTED;
                        totalCount += tempCount;
                        column = 0;

                    }
                }
                if (!(Flags & DUMP_FLAG_NO_INDENT) ) {

                    if (!(currentStatus & STATUS_INDENTED) ) {

                        dprintf("%s%n", indent, &tempCount);
                        currentStatus |= STATUS_INDENTED;
                        totalCount += tempCount;
                        column += IndentLevel;

                    }

                }
                if ( (Flags & DUMP_FLAG_SHOW_BIT) ) {

                    dprintf("%I64x - %n", k, &tempCount);
                    tempCount++; // to account for the fact that we dump
                                 // another space at the end of the string
                    totalCount += tempCount;
                    column += tempCount;

                } else {

                    tempCount = 0;

                }

                //
                // Actually print the string
                //
                dprintf( "%.*s %n", (stringSize - tempCount), string, &tempCount );
                if (Flags & DUMP_FLAG_SHOW_BIT) {

                    dprintf(" ");

                }

                totalCount += tempCount;
                column += tempCount;

            }

        }

        //
        // Change states
        //
        if (currentStatus & STATUS_NEED_COUNTING) {

            currentStatus &= ~STATUS_NEED_COUNTING;
            currentStatus |= STATUS_COUNTED;
            continue;

        }

        if (!(Flags & DUMP_FLAG_NO_EOL) && totalCount != 0) {

            dprintf("\n");
            totalCount++;

        }

        //
        // Done
        //
        break;

    }

    return totalCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\kdext.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    kdext.h

Abstract:

    Header files for KD extension

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#ifndef _KDEXT_H_
#define _KDEXT_H_

//
// Various Defines
//
#define Move(dst, src)                                                  \
    try {                                                               \
        b = ReadMemory( (ULONG_PTR) (src), &(dst), sizeof(dst), NULL ); \
        if (!b) {                                                       \
            return;                                                     \
        }                                                               \
    } except (EXCEPTION_EXECUTE_HANDLER)  {                             \
        return;                                                         \
    }

#define MoveBlock( dst, src, size )                                     \
    try {                                                               \
        b = ReadMemory( (ULONG_PTR) (src), &(ds), size, NULL );         \
        if (!b) {                                                       \
            return;                                                     \
        }                                                               \
    } except (EXCEPTION_EXECUTE_HANDLER) {                              \
        return;                                                         \
    }

//
// Various Structures
//
typedef struct _EXTERNAL_HELP_TABLE {

    PUCHAR  ExternalName;
    PUCHAR  ExternalDescription;

} EXTERNAL_HELP_TABLE, *PEXTERNAL_HELP_TABLE;

//
// Verbose flags (for contexts)
//
#define VERBOSE_CONTEXT 0x01
#define VERBOSE_CALL    0x02
#define VERBOSE_HEAP    0x04
#define VERBOSE_OBJECT  0x08
#define VERBOSE_NSOBJ   0x10
#define VERBOSE_RECURSE 0x20

//
// Verbose flags (for device extensions)
//
#define VERBOSE_1       0x01
#define VERBOSE_2       0x02
#define VERBOSE_3       0x04
#define VERBOSE_4       0x08
#define VERBOSE_ALL     0x0f

//
// Verbose Flags (for walking the tree)
//
#define VERBOSE_LOOP    0x10
#define VERBOSE_THERMAL 0x20
#define VERBOSE_PRESENT 0x40

//
// Various data and externs
//
extern  UCHAR  Buffer[2048];

BOOL
GetUlong(
    IN  PCHAR   Name,
    IN  PULONG  Value
    );

BOOL
GetUlongPtr(
    IN  PCHAR   Name,
    IN  PULONG_PTR Address
    );

BOOL
ReadPhysicalOrVirtual(
    IN      ULONG_PTR Address,
    IN      PVOID   Buffer,
    IN      ULONG   Size,
    IN  OUT PULONG  ReturnLength,
    IN      BOOL    Virtual
    );

VOID
displayAcpiDeviceExtension(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayAcpiDeviceExtensionBrief(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayAcpiDeviceExtensionFlags(
    IN  PDEVICE_EXTENSION   DeviceExtension
    );

VOID
displayAcpiDeviceExtensionName(
    IN  ULONG_PTR DeviceExtensionAddress
    );

VOID
displayThermalInfo(
    IN  PTHRM_INFO          Thrm,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
displayThermalInfoEx(
    IN  PTHRM_INFO          Thrm,
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAccessFieldObject(
    IN  ULONG_PTR           AccessFieldAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAccessFieldUnit(
    IN  ULONG_PTR           AccessFieldAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpAcpiDeviceNode(
    IN  PACPI_DEVICE_POWER_NODE DeviceNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    );

VOID
dumpAcpiDeviceNodes(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpAcpiExtension(
    IN  ULONG_PTR Address,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpAcpiGpeInformation(
    VOID
    );

VOID
dumpAcpiInformation(
    VOID
    );

VOID
dumpAcpiPowerList(
    PUCHAR  ListName
    );

VOID
dumpAcpiPowerLists(
    VOID
    );

VOID
dumpAcpiPowerNode(
    IN  PACPI_POWER_DEVICE_NODE PowerNode,
    IN  ULONG_PTR               Address,
    IN  ULONG                   Verbose,
    IN  ULONG                   IndentLevel
    );

VOID
dumpAcpiPowerNodes(
    VOID
    );

VOID
dumpAmlTerm(
    IN  ULONG_PTR           AmlTermAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpCall(
    IN  ULONG_PTR           CallAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpContext(
    IN  ULONG_PTR           ContextAddress,
    IN  ULONG               Verbose
    );

VOID
dumpDeviceListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    );

VOID
dumpFieldAddress(
    IN  ULONG_PTR FieldAddress,
    IN  ULONG   Verbose,
    IN  ULONG   IndentLevel
    );

VOID
dumpIrpListEntry(
    IN  PLIST_ENTRY ListEntry,
    IN  ULONG_PTR   Address
    );

VOID
dumpMemory(
    IN  ULONG_PTR           Address,
    IN  ULONG               Length,
    IN  PUCHAR              FileName
    );

VOID
dumpNSObject(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpNSTree(
    IN  ULONG_PTR           Address,
    IN  ULONG               Level
    );

VOID
dumpObject(
    IN  ULONG_PTR           Address,
    IN  POBJDATA            Object,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpObjectOwner(
    IN  ULONG_PTR           ObjOwnerAddress,
    IN  ULONG               IndentLevel
    );

VOID
dumpPM1StatusRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    );

VOID
dumpPM1ControlRegister(
    IN  ULONG   Value,
    IN  ULONG   IndentLevel
    );

VOID
dumpPnPResources(
    IN  ULONG_PTR Address
    );

VOID
dumpPObject(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpScope(
    IN  ULONG_PTR           ScopeAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpStack(
    IN  ULONG_PTR           ContextAddress,
    IN  PCTXT               Context,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpTerm(
    IN  ULONG_PTR           TermAddress,
    IN  ULONG               Verbose,
    IN  ULONG               IndentLevel
    );

VOID
dumpIrqArb(
    IN  PVOID   IrqArb
    );

PUCHAR
TempToKelvins(
    IN  ULONG   Temp
    );

PUCHAR
TimeToSeconds(
    IN  ULONG   Time
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\kdutil.c ===
/*** kdutil.c - KD Extension Utility Functions
 *
 *  This module contains KD Extension Utility Functions.
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     06/22/99
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

/***EP  MemZero - Fill target buffer with zeros
 *
 *  ENTRY
 *      uipAddr - target buffer address
 *      dwSize - target buffer size
 *
 *  EXIT
 *      None
 */

VOID MemZero(ULONG_PTR uipAddr, ULONG dwSize)
{
    PUCHAR pbBuff;
    //
    // LPTR will zero init the buffer
    //
    if ((pbBuff = LocalAlloc(LPTR, dwSize)) != NULL)
    {
        if (!WriteMemory(uipAddr, pbBuff, dwSize, NULL))
        {
            DBG_ERROR(("MemZero: failed to write memory"));
        }
        LocalFree(pbBuff);
    }
    else
    {
        DBG_ERROR(("MemZero: failed to allocate buffer"));
    }
}       //MemZero

/***EP  ReadMemByte - Read a byte from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

BYTE ReadMemByte(ULONG_PTR uipAddr)
{
    BYTE bData = 0;

    if (!ReadMemory(uipAddr, &bData, sizeof(bData), NULL))
    {
        DBG_ERROR(("ReadMemByte: failed to read address %x", uipAddr));
    }

    return bData;
}       //ReadMemByte

/***EP  ReadMemWord - Read a word from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

WORD ReadMemWord(ULONG_PTR uipAddr)
{
    WORD wData = 0;

    if (!ReadMemory(uipAddr, &wData, sizeof(wData), NULL))
    {
        DBG_ERROR(("ReadMemWord: failed to read address %x", uipAddr));
    }

    return wData;
}       //ReadMemWord

/***EP  ReadMemDWord - Read a dword from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

DWORD ReadMemDWord(ULONG_PTR uipAddr)
{
    DWORD dwData = 0;

    if (!ReadMemory(uipAddr, &dwData, sizeof(dwData), NULL))
    {
        DBG_ERROR(("ReadMemDWord: failed to read address %x", uipAddr));
    }

    return dwData;
}       //ReadMemDWord

/***EP  ReadMemUlongPtr - Read a ulong ptr from target address
 *
 *  ENTRY
 *      uipAddr - target address
 *
 *  EXIT
 *      None
 */

ULONG_PTR ReadMemUlongPtr(ULONG_PTR uipAddr)
{
    ULONG_PTR uipData = 0;

    if (!ReadMemory(uipAddr, &uipData, sizeof(uipData), NULL))
    {
        DBG_ERROR(("ReadMemUlongPtr: failed to read address %x", uipAddr));
    }

    return uipData;
}       //ReadMemUlongPtr

/***LP  GetObjBuff - Allocate and read object buffer
 *
 *  ENTRY
 *      pdata -> object data
 *
 *  EXIT
 *      return the allocated object buffer pointer
 */

PVOID LOCAL GetObjBuff(POBJDATA pdata)
{
    PVOID pbuff;

    if ((pbuff = LocalAlloc(LPTR, pdata->dwDataLen)) == NULL)
    {
        DBG_ERROR(("failed to allocate object buffer (size=%d)",
                   pdata->dwDataLen));
    }
    else if (!ReadMemory((ULONG_PTR)pdata->pbDataBuff,
                         pbuff,
                         pdata->dwDataLen,
                         NULL))
    {
        DBG_ERROR(("failed to read object buffer at %x", pdata->pbDataBuff));
        LocalFree(pbuff);
        pbuff = NULL;
    }

    return pbuff;
}       //GetObjBuff

/***LP  GetNSObj - Find a name space object
 *
 *  ENTRY
 *      pszObjPath -> object path string
 *      pnsScope - object scope to start the search (NULL means root)
 *      puipns -> to hold the pnsobj address if found
 *      pns -> buffer to hold the object found
 *      dwfNS - flags
 *
 *  EXIT-SUCCESS
 *      returns DBGERR_NONE
 *  EXIT-FAILURE
 *      returns DBGERR_ code
 */

LONG LOCAL GetNSObj(PSZ pszObjPath, PNSOBJ pnsScope, PULONG_PTR puipns,
                    PNSOBJ pns, ULONG dwfNS)
{
    LONG rc = DBGERR_NONE;
    BOOLEAN fSearchUp = (BOOLEAN)(!(dwfNS & NSF_LOCAL_SCOPE) &&
                                  (pszObjPath[0] != '\\') &&
                                  (pszObjPath[0] != '^') &&
                                  (STRLEN(pszObjPath) <= sizeof(NAMESEG)));
    BOOLEAN fMatch = TRUE;
    PSZ psz;
    NSOBJ NSObj, NSChildObj;

    if (*pszObjPath == '\\')
    {
        psz = &pszObjPath[1];
        pnsScope = NULL;
    }
    else
    {
        for (psz = pszObjPath;
             (*psz == '^') && (pnsScope != NULL) &&
             (pnsScope->pnsParent != NULL);
             psz++)
        {
            if (!ReadMemory((ULONG_PTR)pnsScope->pnsParent,
                            &NSObj,
                            sizeof(NSObj),
                            NULL))
            {
                DBG_ERROR(("failed to read parent object at %x",
                           pnsScope->pnsParent));
                rc = DBGERR_CMD_FAILED;
                break;
            }
            else
            {
                pnsScope = &NSObj;
            }
        }

        if ((rc == DBGERR_NONE) && (*psz == '^'))
        {
            if (dwfNS & NSF_WARN_NOTFOUND)
            {
                DBG_ERROR(("object %s not found", pszObjPath));
            }
            rc = DBGERR_CMD_FAILED;
        }
    }

    if ((rc == DBGERR_NONE) && (pnsScope == NULL))
    {
        if ((*puipns = READSYMULONGPTR("gpnsNameSpaceRoot")) == 0)
        {
            DBG_ERROR(("failed to get root object address"));
            rc = DBGERR_CMD_FAILED;
        }
        else if (!ReadMemory(*puipns, &NSObj, sizeof(NSObj), NULL))
        {
            DBG_ERROR(("failed to read NameSpace root object at %x", *puipns));
            rc = DBGERR_CMD_FAILED;
        }
        else
        {
            pnsScope = &NSObj;
        }
    }

    while ((rc == DBGERR_NONE) && (*psz != '\0'))
    {
        if (pnsScope->pnsFirstChild == NULL)
        {
            fMatch = FALSE;
        }
        else
        {
            PSZ pszEnd = STRCHR(psz, '.');
            ULONG dwLen = (ULONG)(pszEnd? (pszEnd - psz): STRLEN(psz));

            if (dwLen > sizeof(NAMESEG))
            {
                DBG_ERROR(("invalid name path %s", pszObjPath));
                rc = DBGERR_CMD_FAILED;
            }
            else
            {
                NAMESEG dwName = NAMESEG_BLANK;
                BOOLEAN fFound = FALSE;
                ULONG_PTR uip;
                ULONG_PTR uipFirstChild = (ULONG_PTR)pnsScope->pnsFirstChild;

                MEMCPY(&dwName, psz, dwLen);
                //
                // Search all siblings for a matching NameSeg.
                //
                for (uip = uipFirstChild;
                     (uip != 0) &&
                     ReadMemory(uip, &NSChildObj, sizeof(NSObj), NULL);
                     uip = ((ULONG_PTR)NSChildObj.list.plistNext ==
                            uipFirstChild)?
                           0: (ULONG_PTR)NSChildObj.list.plistNext)
                {
                    if (NSChildObj.dwNameSeg == dwName)
                    {
                        *puipns = uip;
                        fFound = TRUE;
                        NSObj = NSChildObj;
                        pnsScope = &NSObj;
                        break;
                    }
                }

                if (fFound)
                {
                    psz += dwLen;
                    if (*psz == '.')
                    {
                        psz++;
                    }
                }
                else
                {
                    fMatch = FALSE;
                }
            }
        }

        if ((rc == DBGERR_NONE) && !fMatch)
        {
            if (fSearchUp && (pnsScope->pnsParent != NULL))
            {
                if (!ReadMemory((ULONG_PTR)pnsScope->pnsParent,
                                &NSObj,
                                sizeof(NSObj),
                                NULL))
                {
                    DBG_ERROR(("failed to read parent object at %x",
                               pnsScope->pnsParent));
                    rc = DBGERR_CMD_FAILED;
                }
                else
                {
                    fMatch = TRUE;
                    pnsScope = &NSObj;
                }
            }
            else
            {
                if (dwfNS & NSF_WARN_NOTFOUND)
                {
                    DBG_ERROR(("object %s not found", pszObjPath));
                }
                rc = DBGERR_CMD_FAILED;
            }
        }
    }

    if (rc != DBGERR_NONE)
    {
        *puipns = 0;
    }
    else if (pns != NULL)
    {
        MEMCPY(pns, pnsScope, sizeof(NSObj));
    }

    return rc;
}       //GetNSObj

/***LP  ParsePackageLen - parse package length
 *
 *  ENTRY
 *      ppbOp -> instruction pointer
 *      ppbOpNext -> to hold pointer to next instruction (can be NULL)
 *
 *  EXIT
 *      returns package length
 */

ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext)
{
    ULONG dwLen;
    UCHAR bFollowCnt, i;

    if (ppbOpNext != NULL)
        *ppbOpNext = *ppbOp;

    dwLen = (ULONG)(**ppbOp);
    (*ppbOp)++;
    bFollowCnt = (UCHAR)((dwLen & 0xc0) >> 6);
    if (bFollowCnt != 0)
    {
        dwLen &= 0x0000000f;
        for (i = 0; i < bFollowCnt; ++i)
        {
            dwLen |= (ULONG)(**ppbOp) << (i*8 + 4);
            (*ppbOp)++;
        }
    }

    if (ppbOpNext != NULL)
        *ppbOpNext += dwLen;

    return dwLen;
}       //ParsePackageLen

/***LP  NameSegString - convert a NameSeg to an ASCIIZ stri
 *
 *  ENTRY
 *      dwNameSeg - NameSeg
 *
 *  EXIT
 *      returns string
 */

PSZ LOCAL NameSegString(ULONG dwNameSeg)
{
    static char szNameSeg[sizeof(NAMESEG) + 1] = {0};

    STRCPYN(szNameSeg, (PSZ)&dwNameSeg, sizeof(NAMESEG));

    return szNameSeg;
}       //NameSegString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\help.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

EXTERNAL_HELP_TABLE extensions[] =  {
    { "accfield",   "Dumps an Access Field Record from the AML stack" },
    { "acpiext",    "Dumps the ACPI Device Extension\n"
                    "\t\t\t  Arguments: <address> <flags>\n"
                    "\t\t\t    Flags: 0x1,0x2,0x4,0x8 - Verbosity Bits\n"
                    "\t\t\t           0x10            - Recurse" },
    { "amli",       "\tInvoke AMLI debugger\n"
                    "\t\t\t  Usage: amli <cmd> [arguments ...]" },
    { "call",       "\tDumps an Call Record from the AML stack" },
    { "context",    "Dumps an AML Stcak Context\n"
                    "\t\t\t  Arguments: <address> <flags>\n"
                    "\t\t\t    Flags: 0x00 - 0xff     - Verbosity Bits" },
    { "dm",         "\tDumps Memory to File: <Address> <Length> <File>" },
    { "dsdt",       "\tDumps the Differentiated System Description Table\n"
                    "\t\t\t  Arguments: <address> [savefile]" },
    { "facs",       "\tMoved to kdexts.dll" },
    { "fadt",       "\tMoved to kdexts.dll" },
    { "hdr",        "\tDumps the header at the specified address" },
    { "kb",         "\tDumps the AML Stack Trace (no nested terms)" },
    { "kv",         "\tDumps the AML Stack Trace (nested terms)" },
    { "inf",        "\tMoved to kdexts.dll -- see acpiinf" },
    { "mapic",      "Moved to kdexts.dll" },
    { "node",       "\tDumps a Device Power Node" },
    { "nsobj",      "Moved to kdexts.dll" },
    { "nstree",     "Moved to kdexts.dll" },
    { "objdata",    "Dumps the result of an AML call" },
    { "pnpreslist", "Dumps an ACPI PnP Resource Buffer" },
    { "polist",     "Dumps the ACPI Driver's Power Queues"},
    { "ponodes",    "Dumps the ACPI Driver's Power Node List"},
    { "rsdt",       "\tMoved to kdexts.dll" },
    { "scope",      "Dumps a Scope Record from the AML stack" },
    { "ssdt",       "\tDumps the Secondary System Description Table" },
    { "term",       "\tDums an Term Record from the AML stack" },
    { "unasm",      "Unassembles a section of AML" },
    { NULL,         NULL }
};

DECLARE_API( help )
{
    int i = 0;

    dprintf("\nACPI Debugger Extension\n");
    while(extensions[i].ExternalName != NULL)    {

        dprintf("\t%s - \t%s\n", extensions[i].ExternalName, extensions[i].ExternalDescription);
        i++;

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Stephane Plante (splante)

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;
ULONG_PTR               AcpiExtAddress = 0;
ULONG_PTR               AcpiTreeAddress = 0;
ULONG_PTR               AcpiObjAddress = 0;
ULONG_PTR               AcpiFacsAddress = 0;
ULONG_PTR               AcpiFadtAddress = 0;
ULONG_PTR               AcpiHdrAddress = 0;
ULONG_PTR               AcpiMapicAddress = 0;
ULONG_PTR               AcpiRsdtAddress = 0;
ULONG_PTR               AcpiUnasmAddress = 0;
ULONG                   AcpiUnasmLength = 0;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    return;
}

BOOL
GetUlong (
    IN  PCHAR   String,
    IN  PULONG  Value
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Value,
        sizeof(ULONG),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}

BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG_PTR Address
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Address,
        sizeof(ULONG_PTR),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( accfield )
{
    ULONG_PTR fieldAddress = 0;

    if (args != NULL) {

        fieldAddress = GetExpression( args );

    }

    if (fieldAddress == 0) {

        dprintf("accfield: <address>\n");
        return;

    }

    dumpAccessFieldUnit(
        fieldAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( acpiext )
{
    BOOL                b;
    DEVICE_EXTENSION    deviceExtension;
    DEVICE_OBJECT       deviceObject;
    ULONG_PTR           deviceExtensionAddress = 0;
    ULONG               verbose = VERBOSE_ALL;

    //
    // Read the address of the device object
    //
    if ( args != NULL) {

        if (!sscanf( args, "%lx %x", &deviceExtensionAddress, &verbose )) {
            return;
        }

    }

    if (deviceExtensionAddress == 0) {

        if ( args != NULL) {

            deviceExtensionAddress = GetExpression( args );

        }
        if (deviceExtensionAddress == 0) {

            b = GetUlongPtr(
                "ACPI!RootDeviceExtension",
                &deviceExtensionAddress
                );
            if (!b) {

                deviceExtensionAddress = 0;

            }

        }
        if (deviceExtensionAddress == 0) {

            dprintf("acpiext <address>\n");
            return;

        }

    }

    //
    // Read the device object
    //
    b = ReadMemory(
        deviceExtensionAddress,
        &deviceExtension,
        sizeof(DEVICE_EXTENSION),
        NULL
        );
    if (!b || deviceExtension.Signature != ACPI_SIGNATURE) {

        //
        // Try to read a device object instead
        //
        b = ReadMemory(
            deviceExtensionAddress,
            &deviceObject,
            sizeof(DEVICE_OBJECT),
            NULL
            );
        if (!b) {

            dprintf("0x%08lx: Could not read DeviceObject\n", deviceExtensionAddress);
            return;

        }

        //
        // Try to read an extension now
        //
        deviceExtensionAddress = (ULONG_PTR) deviceObject.DeviceExtension;
        if (deviceExtensionAddress == 0) {

            dprintf("acpiext: Could not find ACPI Extension\n");
            return;

        }
    }

    dumpAcpiExtension(
        deviceExtensionAddress,
        verbose,
        0
        );
    return;
}

DECLARE_API( buildlist )
{
    UCHAR   tempBuff[100];

    if (args != NULL && args[0] != 0) {

        _snprintf( tempBuff, 100, "ACPI!ACPIBuild%sList", args );
        tempBuff[sizeof(tempBuff) - 1] = '\0';
        dumpAcpiBuildList( tempBuff );

    } else {

        dumpAcpiBuildLists();

    }

}

DECLARE_API( call )
{
    ULONG_PTR callAddress = 0;

    if (args != NULL) {

        callAddress = GetExpression( args );

    }

    if (callAddress == 0) {

        dprintf("call: <address>\n");
        return;

    }

    dumpCall(
        callAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( context )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if ( args != NULL) {

        if (!sscanf( args, "%lx %x", &contextAddress, &verbose )) {
            return;
        }

    }

    if (contextAddress == 0) {

        if (args != NULL) {

            contextAddress = GetExpression(args);

        }

        if (contextAddress == 0) {

            CTXT    context;
            PLIST   listEntry;
            ULONG   resultLength;

            //
            // Try to read the default address
            //
            b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
            if (!b || contextAddress == 0) {

                dprintf("context: Could not read ACPI!gplistCtxtHead\n" );
                return;


            }

            //
            // Read the list and look at the first item
            //
            b = ReadMemory(
                contextAddress,
                &listEntry,
                sizeof(PLIST),
                &resultLength
                );
            if (!b || resultLength != sizeof(PLIST)) {

                dprintf(
                    "context: Could not read PLIST @ 0x%08lx\n",
                    contextAddress
                    );
                return;

            }

            //
            // The first item in the list is the context that we are
            // interested in
            //
            contextAddress = (ULONG_PTR) listEntry -
                ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

            //
            // Is there a context there?
            //
            if (contextAddress == 0) {

                dprintf(
                    "context: No current context\n"
                    );

            }

        }

    }

    dumpContext( contextAddress, verbose );
    return;

}

DECLARE_API( dm )
{
    ULONG_PTR   address = 0;
    ULONG       i;
    ULONG       length = 0;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    char        sz[1000];


    if (args != NULL) {

        strcpy(sz, args);

        for (i = 0, tok = strtok( sz, " \t" );
             i < 3, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                length = (ULONG)GetExpression ( tok );
                tok = strtok( NULL, " \t\n\r");

            } else if (i == 2) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0 || length == 0 || name == NULL) {

        dprintf("dm <address> L<length> <filename>\n");
        return;

    }

    dumpMemory( address, length, name );
    return;
}

#if 0
DECLARE_API( dsdt )
{
    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " \n\r\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       infAddress = 0;
        ULONG           returnLength;

        status = GetUlongPtr("ACPI!AcpiInformation", &infAddress );
        if (status == TRUE) {

            status = ReadMemory(
                infAddress,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                address = (ULONG_PTR) acpiInformation.DiffSystemDescTable;

            }
        }

    }

    if (address == 0) {

        dprintf("dsdt <address>\n");

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( facs )
{

    if (args != NULL) {

        AcpiFacsAddress = GetExpression( args );

    }

    if (AcpiFacsAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiFacsAddress = (ULONG_PTR) acpiInformation.FirmwareACPIControlStructure;

            }

        }

    }

    if (AcpiFacsAddress == 0) {

        dprintf("facs <address>\n");
        return;

    }

    dumpFACS( AcpiFacsAddress );
    return;

}

DECLARE_API( fadt )
{

    if (args != NULL && *args != '\0') {

        AcpiFadtAddress = GetExpression( args );

    }

    if (AcpiFadtAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiFadtAddress = (ULONG_PTR) acpiInformation.FixedACPIDescTable;

            }

        }

    }

    if (AcpiFadtAddress == 0) {

        dprintf("fadt <address>\n");
        return;

    }
    dumpFADT( AcpiFadtAddress );
    return;

}

DECLARE_API( gbl )
{
    ULONG   verbose = VERBOSE_1;

    if (args != NULL) {

        if (!strcmp(args, "-v")) {

            verbose |= VERBOSE_2;

        }

    }

    dumpGBL( verbose );
}

DECLARE_API ( gpe )
{
    dumpAcpiGpeInformation( );
    return;
}

DECLARE_API( hdr )
{
    BOOL                b;
    BOOL                virtualMemory = FALSE;
    DESCRIPTION_HEADER  header;
    ULONG               returnLength;

    if (args != NULL) {

        AcpiHdrAddress = GetExpression( args );

    }
    if (AcpiHdrAddress == 0) {

        dprintf("hdr <address>\n");
        return;

    }

    //
    // First check to see if we find the correct things
    //
    b = ReadPhysicalOrVirtual(
        AcpiHdrAddress,
        &header,
        sizeof(DESCRIPTION_HEADER),
        &returnLength,
        virtualMemory
        );
    if (!b) {

        //
        // Attempt to read a Virtual address
        //
        virtualMemory = !virtualMemory;
        b = ReadPhysicalOrVirtual(
            AcpiHdrAddress,
            &header,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            virtualMemory
            );

    }

    //
    // Is the signature 'known'?
    //
    if (header.Signature != FADT_SIGNATURE &&
        header.Signature != FACS_SIGNATURE &&
        header.Signature != RSDT_SIGNATURE &&
        header.Signature != APIC_SIGNATURE &&
        header.Signature != DSDT_SIGNATURE &&
        header.Signature != SSDT_SIGNATURE &&
        header.Signature != PSDT_SIGNATURE &&
        header.Signature != SBST_SIGNATURE) {

        //
        // Unknown -- try again
        //
        virtualMemory = !virtualMemory;
        b = ReadPhysicalOrVirtual(
            AcpiHdrAddress,
            &header,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            virtualMemory
            );
        if (!b) {

            virtualMemory = !virtualMemory;
            b = ReadPhysicalOrVirtual(
                AcpiHdrAddress,
                &header,
                sizeof(DESCRIPTION_HEADER),
                &returnLength,
                virtualMemory
                );

        }

    }
    dumpHeader( AcpiHdrAddress, &header, TRUE );
    return;

}

DECLARE_API( kb )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if (args != NULL) {

        contextAddress = GetExpression(args);

    }

    if (contextAddress == 0) {

        CTXT    context;
        PLIST   listEntry;
        ULONG   resultLength;

        //
        // Try to read the default address
        //
        b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
        if (!b || contextAddress == 0) {

            dprintf("kb: Could not read ACPI!gplistCtxtHead\n" );
            return;


        }

        //
        // Read the list and look at the first item
        //
        b = ReadMemory(
            contextAddress,
            &listEntry,
            sizeof(PLIST),
            &resultLength
            );
        if (!b || resultLength != sizeof(PLIST)) {

            dprintf(
                "kb: Could not read PLIST @ 0x%08lx\n",
                contextAddress
                );
            return;

        }

        //
        // The first item in the list is the context that we are
        // interested in
        //
        contextAddress = (ULONG_PTR) listEntry -
            ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

        //
        // Is there a context there?
        //
        if (contextAddress == 0) {

            dprintf(
                "kb: No current context\n"
                );

        }

    }

    stackTrace( contextAddress, 0 );
    return;

}

DECLARE_API( kv )
{
    BOOL    b;
    ULONG_PTR contextAddress = 0;
    ULONG   verbose = 0;

    //
    // If there are arguments, try to read them
    //
    if (args != NULL) {

        contextAddress = GetExpression(args);

    }

    if (contextAddress == 0) {

        CTXT    context;
        PLIST   listEntry;
        ULONG   resultLength;

        //
        // Try to read the default address
        //
        b = GetUlongPtr( "ACPI!gplistCtxtHead", &contextAddress );
        if (!b || contextAddress == 0) {

            dprintf("kv: Could not read ACPI!gplistCtxtHead\n" );
            return;


        }

        //
        // Read the list and look at the first item
        //
        b = ReadMemory(
            contextAddress,
            &listEntry,
            sizeof(PLIST),
            &resultLength
            );
        if (!b || resultLength != sizeof(PLIST)) {

            dprintf(
                "kv: Could not read PLIST @ 0x%08lx\n",
                contextAddress
                );
            return;

        }

        //
        // The first item in the list is the context that we are
        // interested in
        //
        contextAddress = (ULONG_PTR) listEntry -
            ( (ULONG_PTR) &(context.listCtxt) - (ULONG_PTR) &(context) );

        //
        // Is there a context there?
        //
        if (contextAddress == 0) {

            dprintf(
                "kv: No current context\n"
                );

        }

    }

    stackTrace( contextAddress, 1 );
    return;

}

DECLARE_API( inf )
{
    dumpAcpiInformation( );
    return;
}

DECLARE_API( mapic )
{
    if (args != NULL) {

        AcpiMapicAddress = GetExpression( args );

    }

    if (AcpiMapicAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiMapicAddress = (ULONG_PTR) acpiInformation.MultipleApicTable;
            }
        }
    }

    if (AcpiMapicAddress == 0) {
        dprintf("mapic <address>");
        return;
    }

    dumpMAPIC( AcpiMapicAddress );
    return;

}

DECLARE_API( node )
{
    ULONG_PTR nodeAddress;

    nodeAddress = GetExpression( args );
    if (nodeAddress == 0) {

        dprintf("node: Illegal Address (%s == NULL)\n", args );
        return;
    }
    dumpAcpiDeviceNodes( nodeAddress, VERBOSE_4, 0 );

}

DECLARE_API( nsobj )
{
    ULONG_PTR address = 0;

    if (args != NULL) {

        address = GetExpression( args );

    }

    if (args == 0) {

        dprintf(
            "nsobj: Could not find %s\n",
            (args != NULL ? args : "null")
            );
        return;

    }

    dumpNSObject( address, 0xFFFF, 0 );
}

DECLARE_API( nstree )
{
    ULONG_PTR address = 0;

    if ((args != NULL) && (*args != '\0')) {

        address = GetExpression( args );

    } else {

        address = GetExpression( "acpi!gpnsNameSpaceRoot" );

    }
    if (address == 0) {

        dprintf(
            "nstree: Could not find %s\n",
            (args != NULL ? args : "acpi!gpnsNameSpaceRoot" )
            );
        return;

    }

    dumpNSTree( address, 0 );
}

DECLARE_API( objdata )
{
    BOOL    b;
    ULONG   address = 0;

    //
    // Read the address of the device object
    //
    if (args != NULL) {

        AcpiObjAddress = GetExpression( args );

    }
    if (AcpiObjAddress == 0) {

        dprintf("object <address>\n");
        return;

    }

    dumpPObject( AcpiObjAddress, 0xFFFF, 0);
    return;

}

DECLARE_API( pnpreslist )
{
    ULONG_PTR address = 0;

    if (args != NULL) {

        address = GetExpression( args );

    }
    if (address == 0) {

        dprintf("pnpreslist <address>\n");
        return;

    }

    dumpPnPResources( address );
}

DECLARE_API( polist )
{
    UCHAR   tempBuff[100];

    if (args != NULL && args[0] != 0) {

        _snprintf( tempBuff, 100, "ACPI!ACPIPower%sList", args );
        tempBuff[sizeof(tempBuff) - 1] = '\0';
        dumpAcpiPowerList( tempBuff );

    } else {

        dumpAcpiPowerLists();

    }

}

DECLARE_API( ponodes )
{
    dumpAcpiPowerNodes();
}

#if 0
DECLARE_API( psdt )
{

    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        dprintf("psdt <address>");
        return;

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( rsdt )
{

    if (args != NULL) {

        AcpiRsdtAddress = GetExpression( args );

    }
    if (AcpiRsdtAddress == 0) {

        ACPIInformation acpiInformation;
        BOOL            status;
        ULONG_PTR       address;
        ULONG           returnLength;

        status = GetUlongPtr( "ACPI!AcpiInformation", &address );
        if (status == TRUE) {

            status = ReadMemory(
                address,
                &acpiInformation,
                sizeof(ACPIInformation),
                &returnLength
                );
            if (status && returnLength == sizeof(ACPIInformation)) {

                AcpiRsdtAddress = (ULONG_PTR) acpiInformation.RootSystemDescTable;
            }

        }

    }
    if (AcpiRsdtAddress == 0) {

        if (!findRSDT( &AcpiRsdtAddress) ) {

            dprintf("Could not locate the RSDT pointer\n");
            return;

        }

    }

    dumpRSDT( AcpiRsdtAddress );
    return;

}

DECLARE_API( scope )
{
    ULONG_PTR scopeAddress = 0;

    if (args != NULL) {

        scopeAddress = GetExpression( args );

    }

    if (scopeAddress == 0) {

        dprintf("scope: <address>\n");
        return;

    }

    dumpScope(
        scopeAddress,
        (ULONG) -1,
        0
        );

}

#if 0
DECLARE_API( ssdt )
{

    ULONG_PTR   address = 0;
    ULONG       i;
    PUCHAR      name = NULL;
    PUCHAR      tok = NULL;
    UCHAR       tempBuff[1000];

    if (args != NULL) {

        strcpy(tempBuff, args);

        for (i = 0, tok = strtok( tempBuff, " \t" );
             i < 2, tok != NULL;
             i +=1 ) {

            if (i == 0) {

                address = GetExpression( tok );
                tok = strtok( NULL, " Ll\t" );

            } else if (i == 1) {

                name = tok;
                tok = strtok( NULL, " \t\n\r");

            }

        }

    }

    if (address == 0) {

        dprintf("ssdt <address>");
        return;

    }

    dumpDSDT( address, name );
    return;
}
#endif

DECLARE_API( term )
{
    ULONG_PTR termAddress = 0;

    if (args != NULL) {

        termAddress = GetExpression( args );

    }

    if (termAddress == 0) {

        dprintf("term: <address>\n");
        return;

    }

    dumpTerm(
        termAddress,
        (ULONG) -1,
        0
        );

}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf(
        "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
        );
}

DECLARE_API( amli )
/*++

Routine Description:

    Invoke AMLI debugger

Arguments:

    None

Return Value:

    None

--*/
{
    dprintf("*******************************************************************************\n");
    dprintf("*                                                                             *\n");
    dprintf("*      \"!acpikd.amli\" has been moved to kdexts.dll.\t\t\t\t\t*\n");
    dprintf("*      Please use \"!amli\" to access the amli debugger extensions.\t\t\t*\n");
    dprintf("*      Type \"!unload acpikd\" to unload acpikd.\t\t\t\t\t\t*\n");
    dprintf("*      Then try \"!amli ?\" for more information.\t\t\t\t\t\t*\n");
    dprintf("*                                                                             *\n");
    dprintf("*******************************************************************************\n");
    
}

DECLARE_API( irqarb )
{

    dprintf("Moved to kdexts.dll  Try '!acpiirqarb'\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\kdutil.h ===
#define ConPrintf               dprintf
#define MZERO                   MemZero
#define ADDROF(s)               GetExpression("ACPI!" s)
#define FIELDADDROF(s,t,f)      (ULONG_PTR)(ADDROF(s) + FIELD_OFFSET(t, f))
#define READMEMBYTE             ReadMemByte
#define READMEMWORD             ReadMemWord
#define READMEMDWORD            ReadMemDWord
#define READMEMULONGPTR         ReadMemUlongPtr
#define READSYMBYTE(s)          ReadMemByte(ADDROF(s))
#define READSYMWORD(s)          ReadMemWord(ADDROF(s))
#define READSYMDWORD(s)         ReadMemDWord(ADDROF(s))
#define READSYMULONGPTR(s)      ReadMemUlongPtr(ADDROF(s))
#define WRITEMEMBYTE(a,d)       WriteMemory(a, &(d), sizeof(BYTE), NULL)
#define WRITEMEMWORD(a,d)       WriteMemory(a, &(d), sizeof(WORD), NULL)
#define WRITEMEMDWORD(a,d)      WriteMemory(a, &(d), sizeof(DWORD), NULL)
#define WRITEMEMULONGPTR(a,d)   WriteMemory(a, &(d), sizeof(ULONG_PTR), NULL)
#define WRITESYMBYTE(s,d)       WRITEMEMBYTE(ADDROF(s), d)
#define WRITESYMWORD(s,d)       WRITEMEMWORD(ADDROF(s), d)
#define WRITESYMDWORD(s,d)      WRITEMEMDWORD(ADDROF(s), d)
#define WRITESYMULONGPTR(s,d)   WRITEMEMULONGPTR(ADDROF(s), d)
#define TRACENAME(s)
#define ENTER(n,e)
#define EXIT(n,e)

VOID MemZero(ULONG_PTR uipAddr, ULONG dwSize);
BYTE ReadMemByte(ULONG_PTR uipAddr);
WORD ReadMemWord(ULONG_PTR uipAddr);
DWORD ReadMemDWord(ULONG_PTR uipAddr);
ULONG_PTR ReadMemUlongPtr(ULONG_PTR uipAddr);
PVOID LOCAL GetObjBuff(POBJDATA pdata);
LONG LOCAL GetNSObj(PSZ pszObjPath, PNSOBJ pnsScope, PULONG_PTR puipns,
                    PNSOBJ pns, ULONG dwfNS);
ULONG LOCAL ParsePackageLen(PUCHAR *ppbOp, PUCHAR *ppbOpNext);
PSZ LOCAL NameSegString(ULONG dwNameSeg);

VOID STDCALL AMLIDbgExecuteCmd(PSZ pszCmd);
LONG LOCAL AMLIDbgHelp(PCMDARG pArg, PSZ pszArg, ULONG dwArgNum,
                       ULONG dwNonSWArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


VOID
dumpPnPResources(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This routine processes the ACPI version of a PnP resource list given
    the address that it starts at

Arguments:

    Address - The Starting address

Return Value:

    NULL

--*/
{
    BOOL    success;
    PUCHAR  dataBuffer = NULL;
    UCHAR   currentTag;
    ULONG_PTR currentAddress = Address;
    ULONG   i;
    ULONG   indentLevel = 0;
    ULONG   returnLength;
    ULONG   tagCount = 0;
    USHORT  increment;

    //
    // repeat forever
    //
    while (1) {

        //
        // Allow a way to end this
        //
        if (CheckControlC()) {

            break;

        }

        //
        // Read the current tag
        //
        success = ReadMemory(
            currentAddress,
            &currentTag,
            sizeof(UCHAR),
            &returnLength
            );
        if (!success || returnLength != sizeof(UCHAR)) {

            dprintf(
                "dumpPnPResources: could not read tag at 0x%08lx\n",
                currentAddress
                );
            return;

        }

        //
        // Determine what we are looking at
        //
        if ( !(currentTag & LARGE_RESOURCE_TAG)) {

            //
            // We are looking at a small tag
            //
            increment = (USHORT) (currentTag & SMALL_TAG_SIZE_MASK) + 1;
            currentTag &= SMALL_TAG_MASK;

        } else {

            //
            // We are looking at a large Tag. We must read the length as
            // the next short in memory
            //
            success = ReadMemory(
                currentAddress + 1,
                &increment,
                sizeof(USHORT),
                &returnLength
                );
            if (!success || returnLength != sizeof(USHORT)) {

                dprintf(
                    "dumpPnPResources: could not read increment at 0x%08lx\n",
                    currentAddress + 1
                    );
                break;

            }

            //
            // Account for the increment
            //
            increment += 3;

        }

        //
        // Allocate space for the buffer
        //
        if (increment > 1) {

            dataBuffer = LocalAlloc( LPTR, increment);
            if (dataBuffer == NULL) {

                dprintf(
                    "dumpPnPResources: could not allocate 0x%x bytes\n",
                    (increment - 1)
                    );

            }

            //
            // Read the data into the buffer
            //
            success = ReadMemory(
                currentAddress,
                dataBuffer,
                increment,
                &returnLength
                );
            if (!success || returnLength != (ULONG) increment) {

                dprintf(
                    "dumpPnPResources: read buffer at 0x%08lx (0x%x)\n",
                    currentAddress,
                    increment
                    );
                LocalFree( dataBuffer );
                return;

            }

        }

        //
        // Indent the tag
        //
        for (i = 0; i < indentLevel; i++) {

            dprintf("| ");

        }

        //
        // What tag are we looking at
        //
        switch (currentTag) {
            case TAG_IRQ: {

                PPNP_IRQ_DESCRIPTOR res = (PPNP_IRQ_DESCRIPTOR) dataBuffer;

                if (res) {
                    USHORT          mask = res->IrqMask;
                    USHORT          interrupt = 0;

                    dprintf("%d - TAG_IRQ -", tagCount );
                    for( ;mask; interrupt++, mask >>= 1) {

                        if (mask & 1) {

                            dprintf(" %d", interrupt );

                        }

                    }
                    if ( (res->Tag & SMALL_TAG_SIZE_MASK) == 3) {

                        if (res->Information & PNP_IRQ_LATCHED) {

                            dprintf(" Lat");

                        }
                        if (res->Information & PNP_IRQ_LEVEL) {

                            dprintf(" Lvl");

                        }
                        if (res->Information & PNP_IRQ_SHARED) {

                            dprintf(" Shr");

                        } else {

                            dprintf(" Exc");

                        }

                    } else {

                        dprintf(" Edg Sha");

                    }
                    dprintf("\n");
                }
                break;
            }
            case TAG_EXTENDED_IRQ: {

                PPNP_EXTENDED_IRQ_DESCRIPTOR    res =
                    (PPNP_EXTENDED_IRQ_DESCRIPTOR) dataBuffer;
                UCHAR                           tableCount = 0;
                UCHAR                           tableSize = res->TableSize;

                dprintf("%d - TAG_EXTENDED_IRQ -", tagCount );
                for (; tableCount < tableSize; tableCount++) {

                    dprintf(" %d", res->Table[tableCount] );

                }
                if (res->Flags & PNP_EXTENDED_IRQ_MODE) {

                    dprintf(" Lat");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_POLARITY ) {

                    dprintf(" Edg");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_SHARED) {

                    dprintf(" Shr");

                } else {

                    dprintf(" Exc");

                }
                if (res->Flags & PNP_EXTENDED_IRQ_RESOURCE_CONSUMER_ONLY) {

                    dprintf(" Con");

                } else {

                    dprintf(" Prod Con");

                }
                dprintf("\n");
                break;

            }
            case TAG_DMA: {

                PPNP_DMA_DESCRIPTOR res = (PPNP_DMA_DESCRIPTOR) dataBuffer;
                UCHAR               channel = 0;
                UCHAR               mask = res->ChannelMask;

                dprintf("%d - TAG_DMA -", tagCount );
                for (; mask; channel++, mask >>= 1) {

                    if (mask & 1) {

                        dprintf(" %d", channel);

                    }

                }
                switch( (res->Flags & PNP_DMA_SIZE_MASK) ) {
                case PNP_DMA_SIZE_8:
                    dprintf(" 8bit");
                    break;
                case PNP_DMA_SIZE_8_AND_16:
                    dprintf(" 8-16bit");
                    break;
                case PNP_DMA_SIZE_16:
                    dprintf(" 16bit");
                    break;
                case PNP_DMA_SIZE_RESERVED:
                default:
                    dprintf(" ??bit");
                    break;
                }
                if (res->Flags & PNP_DMA_BUS_MASTER) {
                    dprintf(" BM");

                }
                switch( (res->Flags & PNP_DMA_TYPE_MASK) ) {
                default:
                case PNP_DMA_TYPE_COMPATIBLE:
                    dprintf(" Com");
                    break;
                case PNP_DMA_TYPE_A:
                    dprintf(" A");
                    break;
                case PNP_DMA_TYPE_B:
                    dprintf(" B");
                    break;
                case PNP_DMA_TYPE_F:
                    dprintf(" F");
                }
                dprintf("\n");
                break;

            }
            case TAG_START_DEPEND:

                indentLevel++;
                dprintf("%d - TAG_START_DEPEND\n", tagCount);
                break;

            case TAG_END_DEPEND:

                indentLevel = 0;
                dprintf("%d - TAG_END_DEPEND\n", tagCount);
                break;

            case TAG_IO: {

                PPNP_PORT_DESCRIPTOR    res = (PPNP_PORT_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_IO - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->Length
                    );
                switch (res->Information & PNP_PORT_DECODE_MASK) {
                default:
                case PNP_PORT_10_BIT_DECODE:
                    dprintf(" 10bit");
                    break;
                case PNP_PORT_16_BIT_DECODE:
                    dprintf(" 16bit");
                    break;
                }
                dprintf("\n");
                break;

            }
            case TAG_IO_FIXED: {

                PPNP_FIXED_PORT_DESCRIPTOR  res =
                    (PPNP_FIXED_PORT_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_FIXED_IO - 0x%x L:0x%x\n",
                    tagCount,
                    res->MinimumAddress,
                    res->Length
                    );
                break;

            }
            case TAG_MEMORY: {

                PPNP_MEMORY_DESCRIPTOR  res =
                    (PPNP_MEMORY_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_MEMORY24 - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_MEMORY32: {

                PPNP_MEMORY32_DESCRIPTOR  res =
                    (PPNP_MEMORY32_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_MEMORY32 - 0x%x-0x%x A:0x%x L:0x%x",
                    tagCount,
                    res->MinimumAddress,
                    res->MaximumAddress,
                    res->Alignment,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_MEMORY32_FIXED: {

                PPNP_FIXED_MEMORY32_DESCRIPTOR  res =
                    (PPNP_FIXED_MEMORY32_DESCRIPTOR) dataBuffer;

                dprintf(
                    "%d - TAG_FIXED_MEMORY32 - 0x%x L:0x%x",
                    tagCount,
                    res->BaseAddress,
                    res->MemorySize
                    );

                if (res->Information & PNP_MEMORY_READ_WRITE) {

                    dprintf(" RW");

                } else {

                    dprintf(" R");

                }
                break;

            }
            case TAG_WORD_ADDRESS: {

                PPNP_WORD_ADDRESS_DESCRIPTOR    res =
                    (PPNP_WORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_WORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_WORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        dataBuffer[sizeof(PNP_WORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_WORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_DOUBLE_ADDRESS: {

                PPNP_DWORD_ADDRESS_DESCRIPTOR   res =
                    (PPNP_DWORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_DWORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        (UCHAR) dataBuffer[sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_DWORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_QUAD_ADDRESS: {

                PPNP_QWORD_ADDRESS_DESCRIPTOR   res =
                    (PPNP_QWORD_ADDRESS_DESCRIPTOR) dataBuffer;

                dprintf("%d - TAG_QWORD_ADDRESS -", tagCount);
                switch (res->RFlag) {
                case 0:
                    //
                    // Memory range
                    //
                    dprintf(
                         "Mem 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_READ_WRITE) {

                        dprintf(" RW");

                    } else {

                        dprintf(" R");

                    }

                    switch (res->TFlag & PNP_ADDRESS_TYPE_MEMORY_MASK) {
                    default:
                    case PNP_ADDRESS_TYPE_MEMORY_NONCACHEABLE:
                        dprintf(" NC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_CACHEABLE:
                        dprintf(" C");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_WRITE_COMBINE:
                        dprintf(" WC");
                        break;
                    case PNP_ADDRESS_TYPE_MEMORY_PREFETCHABLE:
                        dprintf(" PC");
                        break;
                    }
                    break;
                case 1:
                    //
                    // IO range
                    //
                    dprintf(
                         "IO 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_ISA_RANGE) {

                        dprintf(" ISA");

                    }
                    if (res->TFlag & PNP_ADDRESS_TYPE_IO_NON_ISA_RANGE) {

                        dprintf(" Non-ISA");

                    }
                    break;
                case 2:
                    dprintf(
                         "Bus 0x%x-0x%x A:0x%x T:0x%x L:0x%x",
                         res->MinimumAddress,
                         res->MaximumAddress,
                         res->Granularity,
                         res->TranslationAddress,
                         res->AddressLength
                         );
                    break;
                } // switch( buffer->RFlag )

                //
                // Global Flags
                //
                if (res->GFlag & PNP_ADDRESS_FLAG_CONSUMED_ONLY) {

                    dprintf(" Consumed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_SUBTRACTIVE_DECODE) {

                    dprintf(" Subtractive");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MINIMUM_FIXED) {

                    dprintf(" MinFixed");

                }
                if (res->GFlag & PNP_ADDRESS_FLAG_MAXIMUM_FIXED) {

                    dprintf(" MaxFixed");

                }

                if (increment > sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR) + 1) {

                    dprintf(
                        " %d<-%s",
                        (UCHAR) dataBuffer[sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR)],
                        &(dataBuffer[sizeof(PNP_QWORD_ADDRESS_DESCRIPTOR)+1])
                        );

                }
                dprintf("\n");
                break;

            }
            case TAG_END:

                dprintf("%d - TAG_END\n", tagCount);
                if (dataBuffer) {

                    LocalFree(dataBuffer );

                }
                return;

            default:

                dprintf("%d - TAG_UNKNOWN %d\n", tagCount, currentTag );
                break;


        } // switch

        //
        // Free the buffer if it was allocated
        //
        if (dataBuffer != NULL) {

            LocalFree( dataBuffer );
            dataBuffer = NULL;

        }

        //
        // Update the current address and tag number
        //
        tagCount++;
        currentAddress += increment;

    } // while

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE
#define SPEC_VER    100

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>
#include <pnp.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>

#include <memory.h>

#include <wmistr.h>
#include <wmilib.h>

//
// This header is part of the global one, but is only required because of
// thermal.h
//
#include <poclass.h>

//
// Load the debugger version of the files
//
#define DEBUGGER

//
// These are the ACPI specific include files
//
#include <acpitabl.h>
#include <aml.h>
#include <amli.h>
#include <acpi.h>
#include <acpipriv.h>
#include <acpidbg.h>
#include <acpiregs.h>
#include <dockintf.h>
#include <ospower.h>
#include <acpiosnt.h>
#include <buildsrc.h>
#include <res_bios.h>
#include <amlipriv.h>
#include <ctxt.h>
#include <thermal.h>
#include <arbiter.h>
#include <irqarb.h>
#include <ntacpi.h>
#include <cmdarg.h>
#include <debugger.h>
#include <strlib.h>
#include "build.h"
#include "flags.h"
#include "kdext.h"
#include "stack.h"
#include "table.h"
//#include "udata.h"
//#include "udebug.h"
//#include "ulist.h"
//#include "unamespac.h"
#include "unasm.h"
#include "kdutil.h"


// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\stack.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 26-Oct-1997

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

VOID
stackArgument(
    IN  ULONG_PTR ObjectAddress
    )
{
    BOOL    result;
    OBJDATA object;
    PUCHAR  buffer = NULL;
    ULONG   returnLength;

    //
    // Read the object
    //
    result = ReadMemory(
        ObjectAddress,
        &object,
        sizeof(OBJDATA),
        &returnLength
        );
    if (!result || returnLength != sizeof(OBJDATA)) {

        dprintf("_BAD_");
        return;

    }

    if (object.pbDataBuff != 0) {

        buffer = LocalAlloc( LPTR, object.dwDataLen+1 );
        if (buffer == NULL) {

            dprintf("_MEM_");
            return;

        }
        result = ReadMemory(
            (ULONG_PTR) object.pbDataBuff,
            buffer,
            object.dwDataLen,
            &returnLength
            );
        if (!result || returnLength != object.dwDataLen) {

            dprintf("_BUF_");
            return;

        }

    }

    switch (object.dwDataType) {
    case OBJTYPE_INTDATA:
        dprintf("0x%x", object.uipDataValue);
        break;
    case OBJTYPE_STRDATA:
        buffer[object.dwDataLen] = '\0';
        dprintf("%s",buffer);
        break;
    case OBJTYPE_BUFFDATA:
        dprintf(
            "<buffer> %08lx-%08lx",
            object.pbDataBuff,
            object.pbDataBuff+object.dwDataLen
            );
        break;
    case OBJTYPE_PKGDATA:
        dprintf("<package> %08lx", ObjectAddress );
        break;
    case OBJTYPE_FIELDUNIT:
        dprintf("<fieldunit> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DEVICE:
        dprintf("<device> %08lx", ObjectAddress );
        break;
    case OBJTYPE_EVENT:
        dprintf("<event> %08lx", ObjectAddress );
        break;
    case OBJTYPE_METHOD:
        dprintf("<method> %08lx", ObjectAddress );
        break;
    case OBJTYPE_MUTEX:
        dprintf("<mutex> %08lx", ObjectAddress );
        break;
    case OBJTYPE_OPREGION:
        dprintf("<opregion> %08lx", ObjectAddress );
        break;
    case OBJTYPE_POWERRES:
        dprintf("<powerres> %08lx", ObjectAddress );
        break;
    case OBJTYPE_PROCESSOR:
        dprintf("<processor> %08lx", ObjectAddress );
        break;
    case OBJTYPE_THERMALZONE:
        dprintf("<thermalzone> %08lx", ObjectAddress );
        break;
    case OBJTYPE_BUFFFIELD:
        dprintf("<bufffield> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DDBHANDLE:
        dprintf("<ddbhandle> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DEBUG:
        dprintf("<debug> %08lx", ObjectAddress );
        break;
    case OBJTYPE_DATAALIAS:
        dprintf("<dataalias> %08lx", ObjectAddress );
        break;
    case OBJTYPE_BANKFIELD:
        dprintf("<bankfield> %08lx", ObjectAddress );
        break;
    case OBJTYPE_FIELD:
        dprintf("<field> %08lx", ObjectAddress );
        break;
    case OBJTYPE_INDEXFIELD:
        dprintf("<indexfield> %08lx", ObjectAddress );
        break;
    default:
        dprintf("<unknown> %08lx", ObjectAddress );
        break;
    }

}

VOID
stackCall(
    IN  ULONG_PTR CallAddress
    )
/*++

Format Displayed:

    ResultAddress  MethodName( Arg0, ..., ArgN )

--*/
{
    ULONG_PTR   address;
    BOOL        result;
    CALL        call;
    INT         i;
    NSOBJ       object;
    PUCHAR      objectPath;
    ULONG       returnLength;

    result = ReadMemory(
        CallAddress,
        &call,
        sizeof(CALL),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(CALL) ||
        call.FrameHdr.dwSig != SIG_CALL) {

        dprintf(
            "stackCall: --- Coult not read call frame %08lx\n",
            CallAddress
            );
        return;

    }

    if (call.pnsMethod == NULL) {

        dprintf( "%08lx --- No method\n", CallAddress );
        return;

    }

    //
    // Display result address
    //
    dprintf("CALL %08lx  ", CallAddress );

    //
    // Display the function name
    //
    objectPath = stackGetObjectPath( (ULONG_PTR) call.pnsMethod );
    dprintf("%s(", objectPath);

    //
    // Display all parsed arguments;
    //
    for (i = 0; i < call.iArg; i++) {

        //
        // What is the address of the argument
        //
        address = (ULONG_PTR) &call.pdataArgs[i];

        //
        // Display that argument
        //
        stackArgument(
            address
            );

        if (i < (call.icArgs - 1)) {

            dprintf(",");

        }
    }

    //
    // Let the user know how many unprocessed arguments there are
    //
    for (; i < call.icArgs; i++) {

        dprintf("_???_");
        if (i < (call.icArgs-1)) {

            dprintf(",");

        }

    }
    dprintf(")\n");

}

PUCHAR
stackGetAmlTermPath(
    IN  ULONG_PTR AmlTermAddress
    )
{
    AMLTERM         amlTerm;
    BOOL            result;
    static  UCHAR   termPath[2049];
    ULONG           i;
    ULONG           resultLength;

    result = ReadMemory(
        AmlTermAddress,
        &amlTerm,
        sizeof(AMLTERM),
        &resultLength
        );
    if (!result || resultLength != sizeof(AMLTERM)) {

        return NULL;

    }

    if (amlTerm.pszTermName == NULL) {

        return NULL;
    }

    result = ReadMemory(
        (ULONG_PTR) amlTerm.pszTermName,
        &termPath,
        2048,
        &resultLength
        );
    if (!result || resultLength == 0) {

        return NULL;

    }
    termPath[resultLength] = '\0';
    return termPath;

}

PUCHAR
stackGetObjectPath(
    IN  ULONG_PTR ObjectAddress
    )
{
    BOOL            result;
    NSOBJ           object;
    static  UCHAR   namePath[2049];
    ULONG           i;
    ULONG           resultLength;

    //
    // Read the object
    //
    result = ReadMemory(
        ObjectAddress,
        &object,
        sizeof(NSOBJ),
        &resultLength
        );
    if (!result || resultLength != sizeof(NSOBJ)) {

        return NULL;

    }

    if (object.pnsParent == NULL) {

        strcpy( namePath, "\\");

    } else {

        NSOBJ   parent;

        stackGetObjectPath( (ULONG_PTR) object.pnsParent );

        result = ReadMemory(
            (ULONG_PTR) object.pnsParent,
            &parent,
            sizeof(NSOBJ),
            &resultLength
            );
        if (!result || resultLength != sizeof(NSOBJ)) {

            return NULL;

        }

        if (parent.pnsParent != NULL) {

            strcat(namePath, ".");

        }
        strncat( namePath, (PUCHAR) &(object.dwNameSeg), sizeof(NAMESEG) );

        for (i = strlen(namePath); i > 0; --i) {

            if (namePath[i-1] == '_') {

                namePath[i-1] = '\0';

            } else {

                break;

            }

        }

    }

    return namePath;
}

VOID
stackTerm(
    IN  ULONG_PTR TermAddress
    )
/*++

Format Displayed:

    term TermAddress  TermName( Arg0, ..., ArgN )

--*/
{
    ULONG_PTR   address;
    BOOL        result;
    INT         i;
    NSOBJ       object;
    PUCHAR      objectPath;
    TERM        term;
    ULONG       returnLength;

    result = ReadMemory(
        TermAddress,
        &term,
        sizeof(TERM),
        &returnLength
        );
    if (result != TRUE ||
        returnLength != sizeof(TERM) ||
        term.FrameHdr.dwSig != SIG_TERM) {

        dprintf(
            "stackTerm: --- Coult not read call frame %08lx\n",
            TermAddress
            );
        return;

    }

    if (term.pamlterm == NULL) {

        dprintf( "%08lx --- No term\n", TermAddress );
        return;

    }

    //
    // Display result address
    //
    dprintf("TERM %08lx  ", TermAddress );

    //
    // Display the function name
    //
    objectPath = stackGetAmlTermPath( (ULONG_PTR) term.pamlterm );
    dprintf("%s(", objectPath);

    //
    // Display all parsed arguments;
    //
    for (i = 0; i < term.iArg; i++) {

        //
        // What is the address of the argument
        //
        address = (ULONG_PTR) &term.pdataArgs[i];

        //
        // Display that argument
        //
        stackArgument(
            address
            );

        if (i < (term.icArgs - 1)) {

            dprintf(",");

        }
    }

    //
    // Let the user know how many unprocessed arguments there are
    //
    for (; i < term.icArgs; i++) {

        dprintf("_???_");
        if (i < (term.icArgs-1)) {

            dprintf(",");

        }

    }
    dprintf(")\n");

}

VOID
stackTrace(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    )
/*++

Routine Description:

    This routine dumps a context as a stack

Arguments:

    ContextAddress  - Where the stack is located
    Verbose         - How much information to display

Return Value:

    None

--*/
{
    BOOL        callSeen = FALSE;
    BOOL        result;
    CTXT        context;
    FRAMEHDR    frame;
    PUCHAR      frameAddress;
    ULONG       returnLength;

    //
    // Read the context from the target
    //
    result = ReadMemory(
        ContextAddress,
        &context,
        sizeof(CTXT),
        &returnLength
        );
    if (result != TRUE || returnLength != sizeof(CTXT)) {

        dprintf(
            "stackTrace: --- Could not read Context %08lx\n",
            ContextAddress
            );
        return;

    }
    if (context.dwSig != SIG_CTXT) {

        dprintf(
            "stackTrace: --- Not a Context (%08lx)\n",
            context.dwSig
            );
        return;

    }

    //
    // Begin to walk the frames
    //
    frameAddress = context.LocalHeap.pbHeapEnd;
    while (frameAddress < context.pbCtxtEnd) {

        result = ReadMemory(
            (ULONG_PTR) frameAddress,
            &frame,
            sizeof(FRAMEHDR),
            &returnLength
            );
        if (result != TRUE || returnLength != sizeof(FRAMEHDR)) {

            dprintf(
                "stackTrace: --- could not read frame %08lx\n",
                frameAddress
                );
            return;

        }

        //
        // Do we care about the frame?
        //
        switch(frame.dwSig) {
        case SIG_CALL:

            callSeen = TRUE;
            stackCall(
                (ULONG_PTR) frameAddress
                );
            break;

        case SIG_TERM:

            if (!callSeen || (callSeen && Verbose)) {

                stackTerm(
                    (ULONG_PTR) frameAddress
                    );

            }

        } // switch

        //
        // Next
        //
        frameAddress += frame.dwLen;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\stack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.h

Abstract:

    Dumps the AML Context Structure in Human-Readable-Form (HRF)

Author:

    Stephane Plante (splante) 26-Oct-1997

Environment:

    User Mode.

Revision History:

--*/

#ifndef _STACK_H_
#define _STACK_H_

VOID
stackArgument(
    IN  ULONG_PTR ObjectAddress
    );

VOID
stackCall(
    IN  ULONG_PTR CallAddress
    );

PUCHAR
stackGetAmlTermPath(
    IN  ULONG_PTR AmlTermAddress
    );

PUCHAR
stackGetObjectPath(
    IN  ULONG_PTR AmlTermAddress
    );

VOID
stackTerm(
    IN  ULONG_PTR TermAddress
    );

VOID
stackTrace(
    IN  ULONG_PTR ContextAddress,
    IN  ULONG   Verbose
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\table.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    table.h

Abstract:

    ACPI table functions

Author:

    splante

Environment:

    User mode only

Revision History:

--*/

#ifndef _TABLE_H_
#define _TABLE_H_

    VOID
    dumpDSDT(
        IN  ULONG_PTR           Address,
        IN  PUCHAR              Name
        );

    VOID
    dumpFACS(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpFADT(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpGBL(
        IN  ULONG               Verbose
        );

    VOID
    dumpGBLEntry(
        IN  ULONG_PTR           Address,
        IN  ULONG               Verbose
        );

    VOID
    dumpHeader(
        IN  ULONG_PTR           Address,
        IN  PDESCRIPTION_HEADER Header,
        IN  BOOLEAN             Verbose
        );

    VOID
    dumpMAPIC(
        IN  ULONG_PTR           Address
        );

    VOID
    dumpRSDT(
        IN  ULONG_PTR           Address
        );

    BOOLEAN
    findRSDT(
        IN  PULONG_PTR          Address
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\strlib.c ===
/*** strlib.c - string functions
 *
 *  Copyright (c) 1996,1997 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     09/09/96
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef	LOCKABLE_PRAGMA
#pragma	ACPI_LOCKABLE_DATA
#pragma	ACPI_LOCKABLE_CODE
#endif

/***EP  StrLen - determine string length
 *
 *  ENTRY
 *      psz -> string
 *	n - limiting length
 *
 *  EXIT
 *      returns string length
 */

ULONG EXPORT StrLen(PSZ psz, ULONG n)
{
    TRACENAME("STRLEN")
    ULONG dwLen;

    ENTER(5, ("StrLen(str=%s,n=%d)\n", psz, n));

    ASSERT(psz != NULL);
    if (n != (ULONG)-1)
        n++;
    for (dwLen = 0; (dwLen <= n) && (*psz != '\0'); psz++)
        dwLen++;

    EXIT(5, ("StrLen=%u\n", dwLen));
    return dwLen;
}       //StrLen

/***EP  StrCpy - copy string
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to copy
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCpy(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCPY")
    ULONG dwSrcLen;

    ENTER(5, ("StrCpy(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    MEMCPY(pszDst, pszSrc, n);
    pszDst[n] = '\0';

    EXIT(5, ("StrCpy=%s\n", pszDst));
    return pszDst;
}       //StrCpy

/***EP  StrCat - concatenate strings
 *
 *  ENTRY
 *      pszDst -> destination string
 *      pszSrc -> source string
 *      n - number of bytes to concatenate
 *
 *  EXIT
 *      returns pszDst
 */

PSZ EXPORT StrCat(PSZ pszDst, PSZ pszSrc, ULONG n)
{
    TRACENAME("STRCAT")
    ULONG dwSrcLen, dwDstLen;

    ENTER(5, ("StrCat(Dst=%s,Src=%s,n=%d)\n", pszDst, pszSrc, n));

    ASSERT(pszDst != NULL);
    ASSERT(pszSrc != NULL);

    dwSrcLen = StrLen(pszSrc, n);
    if ((n == (ULONG)(-1)) || (n > dwSrcLen))
        n = dwSrcLen;

    dwDstLen = StrLen(pszDst, (ULONG)(-1));
    MEMCPY(&pszDst[dwDstLen], pszSrc, n);
    pszDst[dwDstLen + n] = '\0';

    EXIT(5, ("StrCat=%s\n", pszDst));
    return pszDst;
}       //StrCat

/***EP  StrCmp - compare strings
 *
 *  ENTRY
 *      psz1 -> string 1
 *      psz2 -> string 2
 *      n - number of bytes to compare
 *      fMatchCase - TRUE if case sensitive
 *
 *  EXIT
 *      returns 0  if string 1 == string 2
 *              <0 if string 1 < string 2
 *              >0 if string 1 > string 2
 */

LONG EXPORT StrCmp(PSZ psz1, PSZ psz2, ULONG n, BOOLEAN fMatchCase)
{
    TRACENAME("STRCMP")
    LONG rc;
    ULONG dwLen1, dwLen2;
    ULONG i;

    ENTER(5, ("StrCmp(s1=%s,s2=%s,n=%d,fMatchCase=%d)\n",
              psz1, psz2, n, fMatchCase));

    ASSERT(psz1 != NULL);
    ASSERT(psz2 != NULL);

    dwLen1 = StrLen(psz1, n);
    dwLen2 = StrLen(psz2, n);
    if (n == (ULONG)(-1))
        n = (dwLen1 > dwLen2)? dwLen1: dwLen2;

    if (fMatchCase)
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(psz1[i] - psz2[i]);
        }
    }
    else
    {
        for (i = 0, rc = 0;
             (rc == 0) && (i < n) && (i < dwLen1) && (i < dwLen2);
             ++i)
        {
            rc = (LONG)(TOUPPER(psz1[i]) - TOUPPER(psz2[i]));
        }
    }

    if ((rc == 0) && (i < n))
    {
        if (i < dwLen1)
            rc = (LONG)psz1[i];
        else if (i < dwLen2)
            rc = (LONG)(-psz2[i]);
    }

    EXIT(5, ("StrCmp=%d\n", rc));
    return rc;
}       //StrCmp

/***EP  StrChr - look for a character in a string
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = pszStr; (*psz != c) && (*psz != '\0'); psz++)
        ;

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrChr=%x\n", psz));
    return psz;
}       //StrChr

/***EP  StrRChr - look for a character in a string in reverse direction
 *
 *  ENTRY
 *      psz -> string
 *      c - character to look for
 *
 *  EXIT-SUCCESS
 *      returns a pointer to the character found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrRChr(PSZ pszStr, CHAR c)
{
    TRACENAME("STRRCHR")
    PSZ psz;

    ENTER(5, ("StrChr(s=%s,c=%c)\n", pszStr, c));

    ASSERT(pszStr != NULL);
    for (psz = &pszStr[StrLen(pszStr, (ULONG)-1)];
         (*psz != c) && (psz > pszStr);
	 psz--)
    {
    }

    if (*psz != c)
        psz = NULL;

    EXIT(5, ("StrRChr=%x\n", psz));
    return psz;
}       //StrRChr

/***EP  StrTok - find the next token in string
 *
 *  ENTRY
 *      pszStr -> string containing tokens
 *      pszSep -> string containing delimiters
 *
 *  EXIT-SUCCESS
 *      returns the pointer to the beginning of the token
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrTok(PSZ pszStr, PSZ pszSep)
{
    TRACENAME("STRTOK")
    static PSZ pszNext = NULL;


    ENTER(5, ("StrTok(Str=%s,Sep=%s)\n", pszStr, pszSep));

    ASSERT(pszSep != NULL);

    if (pszStr == NULL)
        pszStr = pszNext;

    if (pszStr != NULL)
    {
        //
        // Skip leading delimiter characters
        //
        while ((*pszStr != '\0') && (StrChr(pszSep, *pszStr) != NULL))
            pszStr++;

        for (pszNext = pszStr;
             (*pszNext != '\0') && (StrChr(pszSep, *pszNext) == NULL);
             pszNext++)
            ;

        if (*pszStr == '\0')
            pszStr = NULL;
        else if (*pszNext != '\0')
        {
            *pszNext = '\0';
            pszNext++;
        }
    }

    EXIT(5, ("StrTok=%s (Next=%s)\n",
             pszStr? pszStr: "(null)", pszNext? pszNext: "(null)"));
    return pszStr;
}       //StrTok

/***EP  StrToUL - convert the number in a string to a unsigned long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

ULONG EXPORT StrToUL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOUL")
    ULONG n = 0;
    ULONG m;

    ENTER(5, ("StrToUL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (dwBase == 0)
    {
        if (psz[0] == '0')
        {
            if ((psz[1] == 'x') || (psz[1] == 'X'))
            {
                dwBase = 16;
                psz += 2;
            }
            else
            {
                dwBase = 8;
                psz++;
            }
        }
        else
            dwBase = 10;
    }

    while (*psz != '\0')
    {
        if ((*psz >= '0') && (*psz <= '9'))
            m = *psz - '0';
        else if ((*psz >= 'A') && (*psz <= 'Z'))
            m = *psz - 'A' + 10;
        else if ((*psz >= 'a') && (*psz <= 'z'))
            m = *psz - 'a' + 10;
	else
	    break;

        if (m < dwBase)
        {
            n = (n*dwBase) + m;
            psz++;
        }
        else
            break;
    }

    if (ppszEnd != NULL)
        *ppszEnd = psz;

    EXIT(5, ("StrToUL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToUL

/***EP  StrToL - convert the number in a string to a long integer
 *
 *  ENTRY
 *      psz -> string
 *      ppszEnd -> string pointer to the end of the number (can be NULL)
 *      dwBase - the base of the number (if 0, auto-detect base)
 *
 *  EXIT
 *      returns the converted number
 */

LONG EXPORT StrToL(PSZ psz, PSZ *ppszEnd, ULONG dwBase)
{
    TRACENAME("STRTOL")
    LONG n = 0;
    BOOLEAN fMinus;

    ENTER(5, ("StrToL(Str=%s,ppszEnd=%x,Base=%x)\n", psz, ppszEnd, dwBase));

    if (*psz == '-')
    {
        fMinus = TRUE;
        psz++;
    }
    else
        fMinus = FALSE;

    n = (LONG)StrToUL(psz, ppszEnd, dwBase);

    if (fMinus)
        n = -n;

    EXIT(5, ("StrToL=%x (pszEnd=%x)\n", n, ppszEnd? *ppszEnd: 0));
    return n;
}       //StrToL

/***EP  StrStr - find a substring in a given string
 *
 *  ENTRY
 *      psz1 -> string to be searched
 *      psz2 -> substring to find
 *
 *  EXIT-SUCCESS
 *      returns pointer to psz1 where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ EXPORT StrStr(PSZ psz1, PSZ psz2)
{
    TRACENAME("STRSTR")
    PSZ psz = psz1;
    ULONG dwLen;

    ENTER(5, ("StrStr(psz1=%s,psz2=%s)\n", psz1, psz2));

    dwLen = StrLen(psz2, (ULONG)-1);
    while ((psz = StrChr(psz, *psz2)) != NULL)
    {
        if (StrCmp(psz, psz2, dwLen, TRUE) == 0)
            break;
        else
            psz++;
    }

    EXIT(5, ("StrStr=%s\n", psz));
    return psz;
}       //StrStr

/***EP  StrUpr - convert string to upper case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrUpr(PSZ pszStr)
{
    TRACENAME("STRUPR")
    PSZ psz;

    ENTER(5, ("StrUpr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOUPPER(*psz);
    }

    EXIT(5, ("StrUpr=%s\n", pszStr));
    return pszStr;
}       //StrUpr

/***EP  StrLwr - convert string to lower case
 *
 *  ENTRY
 *      pszStr -> string
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT StrLwr(PSZ pszStr)
{
    TRACENAME("STRLWR")
    PSZ psz;

    ENTER(5, ("StrLwr(Str=%s)\n", pszStr));

    for (psz = pszStr; *psz != '\0'; psz++)
    {
        *psz = TOLOWER(*psz);
    }

    EXIT(5, ("StrLwr=%s\n", pszStr));
    return pszStr;
}       //StrLwr

/***EP  UlToA - convert an unsigned long value to a string
 *
 *  ENTRY
 *      dwValue - data
 *      pszStr -> string
 *      dwRadix - radix
 *
 *  EXIT
 *      returns pszStr
 */

PSZ EXPORT UlToA(ULONG dwValue, PSZ pszStr, ULONG dwRadix)
{
    TRACENAME("ULTOA")
    PSZ psz;
    char ch;

    ENTER(5, ("UlToA(Value=%x,pszStr=%x,Radix=%d\n", dwValue, pszStr, dwRadix));

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PSZ psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    EXIT(5, ("UlToA=%s\n", pszStr));
    return pszStr;
}       //UlToA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\table.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpi.c

Abstract:

    WinDbg Extension Api for interpretting ACPI data structures

Author:

    Stephane Plante (splante) 21-Mar-1997

    Based on Code by:
        Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

extern  FILE    *outputFile;

BOOL
ReadPhysicalOrVirtual(
    IN      ULONG_PTR Address,
    IN      PVOID   Buffer,
    IN      ULONG   Size,
    IN  OUT PULONG  ReturnLength,
    IN      BOOL    Virtual
    )
/*++

Routine Description:

    This is a way to abstract out the differences between ROM images
    and mapped memory

Arguments:

    Address         - Where (either physical, or virtual) the buffer is located
    Buffer          - Address of where to copy the memory to
    Size            - How many bytes to copy (maximum)
    ReturnLength    - How many bytes where copied
    Virtual         - False if this is physical memory

--*/
{
    BOOL                status = TRUE;
    PHYSICAL_ADDRESS    physicalAddress = { 0L, 0L };

    if (Virtual) {

        status = ReadMemory(
            Address,
            Buffer,
            Size,
            ReturnLength
            );

    } else {

        physicalAddress.QuadPart = Address;
        ReadPhysical(
            physicalAddress.QuadPart,
            Buffer,
            Size,
            ReturnLength
            );

    }

    if (ReturnLength && *ReturnLength != Size) {

        //
        // Didn't get enough memory
        //
        status = FALSE;

    }
    return status;
}

VOID
dumpAcpiGpeInformation(
    VOID
    )
{
    ACPIInformation acpiInformation;
    BOOL            status;
    UCHAR           gpeEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeCurEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeWakeEnable[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeIsLevel[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeHandlerType[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeWakeHandler[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeSpecialHandler[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpePending[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeMap[MAX_GPE_BUFFER_SIZE * 8];
    UCHAR           gpeRunMethod[MAX_GPE_BUFFER_SIZE];
    UCHAR           gpeComplete[MAX_GPE_BUFFER_SIZE];
    ULONG_PTR       address;
    ULONG           acpiGpeRunning;
    ULONG           acpiGpeWorkDone;
    ULONG           returnLength;
    ULONG           size;
    ULONG           value = 0;
    ULONG           i;

    //
    // Get the ACPI Information Table
    //
    status = GetUlongPtr("ACPI!AcpiInformation", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiInformation\n");
        return;

    }
    status = ReadMemory(
        address,
        &acpiInformation,
        sizeof(ACPIInformation),
        &returnLength
        );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            sizeof(ACPIInformation),
            address
            );
        return;

    }

    //
    // Read the current masks from the OS
    //
    status = GetUlongPtr("ACPI!GpeEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeCurEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeCurEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeCurEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeWakeEnable", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeWakeEnable\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeWakeEnable,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeIsLevel", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeIsLevel\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeIsLevel,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeHandlerType", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeHandlerType\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeHandlerType,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeWakeHandler", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeWakeHandler\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeWakeHandler,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeSpecialHandler", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeSpecialHandler\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeSpecialHandler,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpePending", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        gpePending,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeRunMethod", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeRunMethod,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeComplete", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpePending\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeComplete,
        acpiInformation.GpeSize,
        &returnLength
        );
    if (!status || returnLength != acpiInformation.GpeSize) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            acpiInformation.GpeSize,
            address
            );
        return;

    }

    status = GetUlongPtr("ACPI!GpeMap", &address);
    if (!status) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!GpeMap\n");
        return;

    }
    status = ReadMemory(
        address,
        gpeMap,
        (acpiInformation.GpeSize * 8),
        &returnLength
        );
    if (!status || returnLength != (ULONG) (acpiInformation.GpeSize * 8) ) {

        dprintf(
            "dumpAcpiGpeInformation: Could not read %x bytes at %x\n",
            (acpiInformation.GpeSize * 8),
            address
            );
        return;

    }

    status = GetUlong( "ACPI!AcpiGpeDpcRunning", &acpiGpeRunning );
    if (status == FALSE) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiGpeDpcRunning\n");
        return;

    }

    status = GetUlong( "ACPI!AcpiGpeWorkDone", &acpiGpeWorkDone );
    if (status == FALSE) {

        dprintf("dumpAcpiGpeInformation: Could not read ACPI!AcpiGpeDpcRunning\n");
        return;

    }

    dprintf("ACPI General Purpose Events\n");
    dprintf("  + AcpiGpeDpcRunning = %s\n", (acpiGpeRunning ? "TRUE" : "FALSE" ) );
    dprintf("  + AcpiGpeWorkDone   = %s\n", (acpiGpeRunning ? "TRUE" : "FALSE" ) );
    dprintf(
        "   Register Size:     %d bytes\n",
        (acpiInformation.Gpe0Size + acpiInformation.Gpe1Size)
        );

    dprintf("   Status Register:  ");
    for (i = acpiInformation.Gpe1Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP1_BLK + (i - 1), &value, &size );
        if (!size) {


        }
        dprintf(" %02x", value );

    }
    for (i = acpiInformation.Gpe0Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP0_BLK + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    dprintf("\n");

    dprintf("   Enable Register:  ");
    for (i = acpiInformation.Gpe1Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP1_ENABLE + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    for (i = acpiInformation.Gpe0Size; i > 0; i--) {

        size = 1;
        ReadIoSpace( (ULONG) acpiInformation.GP0_ENABLE + (i - 1), &value, &size );
        if (!size) {

            value = 0;

        }
        dprintf(" %02x", value );

    }
    dprintf("\n");

    dprintf("   OS Enable Mask:   ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   OS Current Mask:  ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeCurEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   OS Wake Mask:     ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeWakeEnable[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Level Type:   ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeIsLevel[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Handler Type: ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeHandlerType[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Wake Handler: ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeWakeHandler[i-1] );

    }
    dprintf("\n");
    dprintf("   Special GPEs    : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeSpecialHandler[i-1] );

    }
    dprintf("\n");
    dprintf("   Pending GPEs    : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpePending[i-1] );

    }
    dprintf("\n");
    dprintf("   RunMethod GPEs  : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeRunMethod[i-1] );

    }
    dprintf("\n");
    dprintf("   Complete GPEs   : ");
    for (i = acpiInformation.GpeSize; i > 0; i--) {

        dprintf(" %02x", gpeComplete[i-1] );

    }
    dprintf("\n");
    dprintf("   GPE Map         : ");
    for (i = 0 ; i < (ULONG) (acpiInformation.GpeSize * 8); i++) {

        dprintf(" %02x", gpeMap[i]);
        if ( ((i+1) % 16) == 0) {

            dprintf("\n                     ");

        }

    }
    dprintf("\n");
}

VOID
dumpAcpiInformation(
    VOID
    )
{
    BOOL            status;
    ACPIInformation acpiInformation;
    ULONG_PTR       address;
    ULONG           returnLength;
    ULONG           size;
    ULONG           value;
    ULONG           i;

    status = GetUlongPtr( "ACPI!AcpiInformation", &address );
    if (status == FALSE) {

        dprintf("dumpAcpiInformation: Could not read ACPI!AcpiInformation\n");
        return;

    }

    status = ReadMemory(
        address,
        &acpiInformation,
        sizeof(ACPIInformation),
        &returnLength
        );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf(
            "dumpAcpiInformation: Could not read %x bytes at %x\n",
            sizeof(ACPIInformation),
            address
            );
        return;

    }

    dprintf("ACPIInformation (%08lx)\n", address);
    dprintf(
        "  RSDT                     - %x\n",
        acpiInformation.RootSystemDescTable
        );
    dprintf(
        "  FADT                     - %x\n",
        acpiInformation.FixedACPIDescTable
        );
    dprintf(
        "  FACS                     - %x\n",
        acpiInformation.FirmwareACPIControlStructure
        );
    dprintf(
        "  DSDT                     - %x\n",
        acpiInformation.DiffSystemDescTable
        );
    dprintf(
        "  GlobalLock               - %x\n",
        acpiInformation.GlobalLock
        );
    dprintf(
        "  GlobalLockQueue          - F - %x B - %x\n",
        acpiInformation.GlobalLockQueue.Flink,
        acpiInformation.GlobalLockQueue.Blink
        );
    dprintf(
        "  GlobalLockQueueLock      - %x\n",
        acpiInformation.GlobalLockQueueLock
        );
    dprintf(
        "  GlobalLockOwnerContext   - %x\n",
        acpiInformation.GlobalLockOwnerContext
        );
    dprintf(
        "  GlobalLockOwnerDepth     - %x\n",
        acpiInformation.GlobalLockOwnerDepth
        );
    dprintf(
        "  ACPIOnly                 - %s\n",
        (acpiInformation.ACPIOnly ? "TRUE" : "FALSE" )
        );
    dprintf(
        "  PM1a_BLK                 - %x",
        acpiInformation.PM1a_BLK
        );
    if (acpiInformation.PM1a_BLK) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1a_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM1b_BLK                 - %x",
        acpiInformation.PM1b_BLK
        );
    if (acpiInformation.PM1b_BLK) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1b_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x) (%04x)\n", (value & 0xFFFF), (value >> 16) );
            dumpPM1StatusRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1a_CTRL_BLK            - %x",
        acpiInformation.PM1a_CTRL_BLK
        );
    if (acpiInformation.PM1a_CTRL_BLK) {

        size = 2;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1a_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF) );
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM1b_CTRL_BLK            - %x",
        acpiInformation.PM1b_CTRL_BLK
        );

    if (acpiInformation.PM1b_CTRL_BLK) {

        size = 2;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM1b_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%04x)\n", (value & 0xFFFF));
            dumpPM1ControlRegister( value, 5 );

        } else {

            dprintf(" (N/A)\n" );

        }

    } else {

        dprintf(" (N/A)\n" );

    }
    dprintf(
        "  PM2_CTRL_BLK             - %x",
        acpiInformation.PM2_CTRL_BLK
        );
    if (acpiInformation.PM2_CTRL_BLK) {

        size = 1;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM2_CTRL_BLK, &value, &size );
        if (size) {

            dprintf(" (%02x)\n", (value & 0xFF) );
            if (value & 0x1) {

                dprintf("     0 - ARB_DIS\n");

            }

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  PM_TMR                   - %x",
        acpiInformation.PM_TMR
        );
    if (acpiInformation.PM_TMR) {

        size = 4;
        value = 0;
        ReadIoSpace( (ULONG) acpiInformation.PM_TMR, &value, &size );
        if (size) {

            dprintf(" (%08lx)\n", value );

        } else {

            dprintf(" (N/A)\n");

        }

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_BLK                  - %x",
        acpiInformation.GP0_BLK
        );
    if (acpiInformation.GP0_BLK) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP0_BLK + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_ENABLE               - %x",
        acpiInformation.GP0_ENABLE
        );
    if (acpiInformation.GP0_ENABLE) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP0_ENABLE + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP0_LEN                  - %x\n",
        acpiInformation.GP0_LEN
        );
    dprintf(
        "  GP0_SIZE                 - %x\n",
        acpiInformation.Gpe0Size
        );
    dprintf(
        "  GP1_BLK                  - %x",
        acpiInformation.GP1_BLK
        );
    if (acpiInformation.GP1_BLK) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP1_BLK + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_ENABLE               - %x",
        acpiInformation.GP1_ENABLE
        );
    if (acpiInformation.GP1_ENABLE) {

        for(i = 0; i < acpiInformation.Gpe0Size; i++) {

            size = 1;
            value = 0;
            ReadIoSpace( (ULONG) acpiInformation.GP1_ENABLE + i, &value, &size );
            if (size) {

                dprintf(" (%02x)", value );

            } else {

                dprintf(" (N/A)" );

            }

        }
        dprintf("\n");

    } else {

        dprintf(" (N/A)\n");

    }
    dprintf(
        "  GP1_LEN                  - %x\n",
        acpiInformation.GP1_LEN
        );
    dprintf(
        "  GP1_SIZE                 - %x\n",
        acpiInformation.Gpe1Size
        );
    dprintf(
        "  GP1_BASE_INDEX           - %x\n",
        acpiInformation.GP1_Base_Index
        );
    dprintf(
        "  GPE_SIZE                 - %x\n",
        acpiInformation.GpeSize
        );
    dprintf(
        "  PM1_EN_BITS              - %04x\n",
        acpiInformation.pm1_en_bits
        );
    dumpPM1StatusRegister( ( (ULONG) acpiInformation.pm1_en_bits << 16), 5 );
    dprintf(
        "  PM1_WAKE_MASK            - %04x\n",
        acpiInformation.pm1_wake_mask
        );
    dumpPM1StatusRegister( ( (ULONG) acpiInformation.pm1_wake_mask << 16), 5 );
    dprintf(
        "  C2_LATENCY               - %x\n",
        acpiInformation.c2_latency
        );
    dprintf(
        "  C3_LATENCY               - %x\n",
        acpiInformation.c3_latency
        );
    dprintf(
        "  ACPI_FLAGS               - %x\n",
        acpiInformation.ACPI_Flags
        );
    if (acpiInformation.ACPI_Flags & C2_SUPPORTED) {

        dprintf("    %2d - C2_SUPPORTED\n", C2_SUPPORTED_BIT);

    }
    if (acpiInformation.ACPI_Flags & C3_SUPPORTED) {

        dprintf("    %2d - C3_SUPPORTED\n", C3_SUPPORTED_BIT);

    }
    if (acpiInformation.ACPI_Flags & C3_PREFERRED) {

        dprintf("    %2d - C3_PREFERRED\n", C3_PREFERRED_BIT);

    }
    dprintf(
        "  ACPI_CAPABILITIES        - %x\n",
        acpiInformation.ACPI_Capabilities
        );
    if (acpiInformation.ACPI_Capabilities & CSTATE_C1) {

        dprintf("    %2d - CSTATE_C1\n", CSTATE_C1_BIT );

    }    if (acpiInformation.ACPI_Capabilities & CSTATE_C2) {

        dprintf("    %2d - CSTATE_C2\n", CSTATE_C2_BIT );

    }    if (acpiInformation.ACPI_Capabilities & CSTATE_C3) {

        dprintf("    %2d - CSTATE_C3\n", CSTATE_C3_BIT );

    }
}

#if 0
VOID
dumpDSDT(
    IN  ULONG_PTR Address,
    IN  PUCHAR  Name
    )
/*++

Routine Description:

    This dumps the DSDT at the specified address

Arguments:

    The address where the DSDT is located at

Return Value:

    None

--*/
{
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  dsdtHeader;
    NTSTATUS            result;
    PDSDT               dsdt;
    ULONG               returnLength;
    ULONG               index;

    //
    // Determine if we have virtual or physical memory
    //
    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &dsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status) {

            continue;

        } else if (dsdtHeader.Signature != DSDT_SIGNATURE &&
                   dsdtHeader.Signature != SSDT_SIGNATURE &&
                   dsdtHeader.Signature != PSDT_SIGNATURE ) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpDSDT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpDSDT: Unknown Signature 0x%08lx\n",
                dsdtHeader.Signature
                );
            dumpHeader( Address, &dsdtHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    dsdt = LocalAlloc( LPTR, dsdtHeader.Length );
    if (dsdt == NULL) {

        dprintf(
            "dumpDSDT: Could not allocate %#08lx bytes\n",
            Address,
            dsdtHeader.Length
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        dsdt,
        dsdtHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpDSDT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            dsdtHeader.Length
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        LocalFree( dsdt );
        return;

    } else if (dsdt->Header.Signature != DSDT_SIGNATURE &&
               dsdt->Header.Signature != SSDT_SIGNATURE &&
               dsdt->Header.Signature != PSDT_SIGNATURE) {

        dprintf(
            "dumpDSDT: Unkown Signature (%#08lx)\n",
            dsdt->Header.Signature
            );
        dumpHeader( Address, &dsdtHeader, TRUE );
        LocalFree( dsdt );
        return;

    }

    //
    // Load the DSDT into the unassembler
    //
    if (!IsDSDTLoaded()) {

        result = UnAsmLoadDSDT(
            (PUCHAR) dsdt
            );
        if (!NT_SUCCESS(result)) {

            dprintf(
                "dumpDSDT: Could not load DSDT %08lx because %08lx\n",
                dsdt,
                result
                );
            return;

        }
        result = UnAsmLoadXSDTEx();
        if (!NT_SUCCESS(result)) {

            dprintf(
                "dumpDSDT: Could not load XSDTs because %08lx\n",
                result
                );
            return;

        }

    }

    if (Name == NULL) {

        result = UnAsmDSDT(
            (PUCHAR) dsdt,
            DisplayPrint,
            Address,
            0
            );

    } else {

        outputFile = fopen( Name, "w");
        if (outputFile == NULL) {

            dprintf("dumpDSDT: Could not open file \"%s\"\n", Name );

        } else {

            result = UnAsmDSDT(
                (PUCHAR) dsdt,
                FilePrint,
                Address,
                0
                );

            fflush( outputFile );
            fclose( outputFile );

        }

    }

    if (!NT_SUCCESS(result)) {

        dprintf("dumpDSDT: Unasm Error 0x%08lx\n", result );

    }
    LocalFree( dsdt );
    return;
}
#endif

VOID
dumpFACS(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    BOOL    status;
    FACS    facs;
    ULONG   index;
    ULONG   returnLength;

    //
    // Read the data
    //
    dprintf("FACS - %#08lx\n", Address);

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &facs,
            sizeof(FACS),
            &returnLength,
            (BOOL) index
            );
        if (!status || facs.Signature != FACS_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    default:
        break;
    case 2:
        if (!status) {

            dprintf(
                "dumpFACS: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(FACS)
                );

        } else {

            dprintf(
                "dumpFACS: Invalid Signature 0x%08lx != FACS_SIGNATURE\n",
                facs.Signature
                );

        }
        return;
    } // switch

    //
    // Dump the table
    //
    memset( Buffer, 0, 2048 );
    memcpy( Buffer, &(facs.Signature), sizeof(ULONG) );
    dprintf(
        "  Signature:               %s\n"
        "  Length:                  %#08lx\n"
        "  Hardware Signature:      %#08lx\n"
        "  Firmware Wake Vector:    %#08lx\n"
        "  Global Lock :            %#08lx\n",
        Buffer,
        facs.Length,
        facs.HardwareSignature,
        facs.pFirmwareWakingVector,
        facs.GlobalLock
        );

    if ( (facs.GlobalLock & GL_PENDING) ) {

        dprintf("    Request for Ownership Pending\n");

    }
    if ( (facs.GlobalLock & GL_OWNER) ) {

        dprintf("    Global Lock is Owned\n");

    }
    dprintf("  Flags:                   %#08lx\n", facs.Flags );
    if ( (facs.Flags & FACS_S4BIOS_SUPPORTED) ) {

        dprintf("    S4BIOS_REQ Supported\n");

    }
    return;
}

VOID
dumpFADT(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the FADT at the specified address

Arguments:

    The address where the FADT is located at

Return Value:

    NONE

--*/
{
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  fadtHeader;
    FADT                fadt;
    ULONG               fadtLength;
    ULONG               returnLength;
    ULONG               index;
    PCHAR               addressSpace;

    //
    // First check to see if we find the correct things
    //
    dprintf("FADT - ");

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &fadtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || fadtHeader.Signature != FADT_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpFADT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpFADT: Invalid Signature 0x%08lx != FADT_SIGNATURE\n",
                fadtHeader.Signature
                );
            dumpHeader( Address, &fadtHeader, TRUE );

        }
        return;
    } // switch

    if (fadtHeader.Revision == 1) {
        fadtLength = FADT_REV_1_SIZE; // 116
    } else if (fadtHeader.Revision == 2) {
        fadtLength = FADT_REV_2_SIZE; // 129
    } else {
        fadtLength = sizeof(FADT);
    }

    //
    // Do we have a correctly sized data structure
    //
    if (fadtHeader.Length < fadtLength) {

        dprintf(
            "dumpFADT: Length (%#08lx) is not the size of the FADT (%#08lx)\n",
            Address,
            fadtHeader.Length,
            fadtLength
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        &fadt,
        fadtLength,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpFADT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            sizeof(FADT)
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    } else if (fadt.Header.Signature != FADT_SIGNATURE) {

        dprintf(
            "%#08lx: Signature (%#08lx) != fadt_SIGNATURE (%#08lx)\n",
            Address,
            fadt.Header.Signature,
            FADT_SIGNATURE
            );
        dumpHeader( Address, &fadtHeader, TRUE );
        return;

    }

    //
    // Dump the table
    //
    dumpHeader( Address, &(fadt.Header), TRUE );
    dprintf(
        "FADT - BODY - %#08lx\n"
        "  FACS:                    0x%08lx\n"
        "  DSDT:                    0x%08lx\n"
        "  Int Model:               %s\n"
        "  SCI Vector:              0x%03x\n"
        "  SMI Port:                0x%08lx\n"
        "  ACPI On Value:           0x%03x\n"
        "  ACPI Off Value:          0x%03x\n"
        "  SMI CMD For S4 State:    0x%03x\n"
        "  PM1A Event Block:        0x%08lx\n"
        "  PM1B Event Block:        0x%08lx\n"
        "  PM1 Event Length:        0x%03x\n"
        "  PM1A Control Block:      0x%08lx\n"
        "  PM1B Control Block:      0x%08lx\n"
        "  PM1 Control Length:      0x%03x\n"
        "  PM2 Control Block:       0x%08lx\n"
        "  PM2 Control Length:      0x%03x\n"
        "  PM Timer Block:          0x%08lx\n"
        "  PM Timer Length:         0x%03x\n"
        "  GP0 Block:               0x%08lx\n"
        "  GP0 Length:              0x%03x\n"
        "  GP1 Block:               0x%08lx\n"
        "  GP1 Length:              0x%08lx\n"
        "  GP1 Base:                0x%08lx\n"
        "  C2 Latency:              0x%05lx\n"
        "  C3 Latency:              0x%05lx\n"
        "  Memory Flush Size:       0x%05lx\n"
        "  Memory Flush Stride:     0x%05lx\n"
        "  Duty Cycle Index:        0x%03x\n"
        "  Duty Cycle Index Width:  0x%03x\n"
        "  Day Alarm Index:         0x%03x\n"
        "  Month Alarm Index:       0x%03x\n"
        "  Century byte (CMOS):     0x%03x\n"
        "  Boot Architecture:       0x%04x\n"
        "  Flags:                   0x%08lx\n",
        Address + sizeof(DESCRIPTION_HEADER),
        fadt.facs,
        fadt.dsdt,
        (fadt.int_model == 0 ? "Dual PIC" : "Multiple APIC" ),
        fadt.sci_int_vector,
        fadt.smi_cmd_io_port,
        fadt.acpi_on_value,
        fadt.acpi_off_value,
        fadt.s4bios_req,
        fadt.pm1a_evt_blk_io_port,
        fadt.pm1b_evt_blk_io_port,
        fadt.pm1_evt_len,
        fadt.pm1a_ctrl_blk_io_port,
        fadt.pm1b_ctrl_blk_io_port,
        fadt.pm1_ctrl_len,
        fadt.pm2_ctrl_blk_io_port,
        fadt.pm2_ctrl_len,
        fadt.pm_tmr_blk_io_port,
        fadt.pm_tmr_len,
        fadt.gp0_blk_io_port,
        fadt.gp0_blk_len,
        fadt.gp1_blk_io_port,
        fadt.gp1_blk_len,
        fadt.gp1_base,
        fadt.lvl2_latency,
        fadt.lvl3_latency,
#ifndef _IA64_   // XXTF
        fadt.flush_size,
        fadt.flush_stride,
        fadt.duty_offset,
        fadt.duty_width,
#endif
        fadt.day_alarm_index,
        fadt.month_alarm_index,
        fadt.century_alarm_index,
#ifndef _IA64_   // XXTF
        fadt.boot_arch,
#endif
        fadt.flags
        );
    if (fadt.flags & WRITEBACKINVALIDATE_WORKS) {

        dprintf("    Write Back Invalidate is supported\n");

    }
    if (fadt.flags & WRITEBACKINVALIDATE_DOESNT_INVALIDATE) {

        dprintf("    Write Back Invalidate doesn't invalidate the caches\n");

    }
    if (fadt.flags & SYSTEM_SUPPORTS_C1) {

        dprintf("    System cupports C1 Power state on all processors\n");

    }
    if (fadt.flags & P_LVL2_UP_ONLY) {

        dprintf("    System supports C2 in MP and UP configurations\n");

    }
    if (fadt.flags & PWR_BUTTON_GENERIC) {

        dprintf("    Power Button is treated as a generic feature\n");

    }
    if (fadt.flags & SLEEP_BUTTON_GENERIC) {

        dprintf("    Sleep Button is treated as a generic feature\n");

    }
    if (fadt.flags & RTC_WAKE_GENERIC) {

        dprintf("    RTC Wake is not supported in fixed register space\n");

    }
    if (fadt.flags & RTC_WAKE_FROM_S4) {

        dprintf("    RTC Wake can work from an S4 state\n");

    }
    if (fadt.flags & TMR_VAL_EXT) {

        dprintf("    TMR_VAL implemented as 32-bit value\n");

    }
#ifndef _IA64_   // XXTF
    if (fadt.Header.Revision > 1) {

        if (!(fadt.boot_arch & LEGACY_DEVICES)) {

            dprintf("    The machine does not contain legacy ISA devices\n");
        }
        if (!(fadt.boot_arch & I8042)) {

            dprintf("    The machine does not contain a legacy i8042\n");
        }
        if (fadt.flags & RESET_CAP) {

            dprintf("    The reset register is supported\n");
            dprintf("      Reset Val: %x\n", fadt.reset_val);

            switch (fadt.reset_reg.AddressSpaceID) {
            case 0:
                addressSpace = "Memory";
                break;
            case 1:
                addressSpace = "I/O";
                break;
            case 2:
                addressSpace = "PCIConfig";
                break;
            default:
                addressSpace = "undefined";
            }
            dprintf("      Reset register: %s - %08x'%08x\n",
                    addressSpace,
                    fadt.reset_reg.Address.HighPart,
                    fadt.reset_reg.Address.LowPart
                    );

        }

    }
#endif
    return;
}

VOID
dumpGBL(
    ULONG   Verbose
    )
/*++

Routine Description:

    This routine reads in all the system tables and prints out
    what the ACPI Good Bios List Entry for this machine should
    be

Arguments:

    None

Return Value:

    None

--*/
{
    ACPIInformation     inf;
    BOOL                status;
    DESCRIPTION_HEADER  hdr;
    ULONG64             dateAddress;
    PRSDTINFORMATION    info;
    PUCHAR              tempPtr;
    ULONG               i;
    ULONG               numElements;
    ULONG               returnLength;
    ULONG               size;
    ULONG_PTR           address;
    ULONG_PTR           address2;

    //
    // Remember where the date address is stored
    //
    dateAddress = 0xFFFF5;

    //
    // Make sure that we can read the pointer
    //
    address2 = GetExpression( "ACPI!RsdtInformation" );
    if (!address2) {

        dprintf("dumpGBL: Could not find RsdtInformation\n");
        return;

    }

    status = GetUlongPtr( "ACPI!RsdtInformation", &address );
    if (status == FALSE || !address) {

        dprintf("dumpGBL: No RsdtInformation present\n");
        return;

    }

    //
    // Read the ACPInformation table, so that we know where the RSDT lives
    //
    status = GetUlongPtr( "ACPI!AcpiInformation", &address2 );
    if (status == FALSE || !address2) {

        dprintf("dumpGBL: Could not read AcpiInformation\n");
        return;

    }
    status = ReadMemory( address2, &inf, sizeof(ACPIInformation), &returnLength );
    if (!status || returnLength != sizeof(ACPIInformation)) {

        dprintf("dumpGBL: Could not read AcpiInformation- %d %x\n", status, returnLength);
        return;

    }

    //
    // Read in the header for the RSDT
    //
    address2 = (ULONG_PTR) inf.RootSystemDescTable;
    status = ReadMemory( address2, &hdr, sizeof(DESCRIPTION_HEADER), &returnLength );
    if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

        dprintf("dumpGBL: Could not read RSDT @%x - %d %x\n", address2, status, returnLength );
        return;

    }

    //
    // The number of elements in the table is the first entry
    // in the structure
    //
    status = ReadMemory(address, &numElements, sizeof(ULONG), &returnLength);
    if (status == FALSE || returnLength != sizeof(ULONG) ) {

        dprintf("dumpGBL: Could not read RsdtInformation\n");
        return;

    }

    //
    // If there are no elements, then return
    //
    if (numElements == 0) {

        dprintf("dumpGBL: No tables the RsdtInformation\n");
        return;

    }

    //
    // Allocate the table, and read in all the pointers
    //
    size = sizeof(RSDTINFORMATION) + ( (numElements - 1) * sizeof(RSDTELEMENT) );
    info = LocalAlloc( LPTR, size );
    if (info == NULL) {

        dprintf("dumpGBL: Could not allocate %x bytes for table\n", size);
        return;

    }

    //
    // Read the entire table
    //
    status = ReadMemory(
        address,
        info,
        size,
        &returnLength
        );
    if (!status || returnLength != size) {

        dprintf("dumpGBL: Could not read RsdtInformation Table\n");
        return;

    }

    //
    // Dump a header so that people know what this is
    //
    memset( Buffer, 0, 2048 );
    ReadPhysical( dateAddress, Buffer, 8, &returnLength );
    dprintf("\nGood Bios List Entry --- Machine BIOS Date %s\n\n", Buffer);

    memset( Buffer, 0, 2048 );
    memcpy( Buffer, hdr.OEMID, 6);
    tempPtr = Buffer;
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    memcpy( tempPtr, hdr.OEMTableID, 8 );
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }
    ReadPhysical( dateAddress, tempPtr, 8, &returnLength );
    while (*tempPtr) { if (*tempPtr == ' ') { *tempPtr = '\0'; break; } tempPtr++; }

    //
    // This is the entry name
    //
    dprintf("[%s]\n", Buffer );

    //
    // Dump the all the tables that are loaded in the RSDT table
    //
    for (i = 0; i < numElements; i++) {

        if (!(info->Tables[i].Flags & RSDTELEMENT_MAPPED) ) {

            continue;

        }

        dumpGBLEntry( (ULONG_PTR) info->Tables[i].Address, Verbose );

    }

    //
    // Dump the entry for the RSDT
    //
    dumpGBLEntry( (ULONG_PTR) inf.RootSystemDescTable, Verbose );

    //
    // Add some whitespace
    //
    dprintf("\n");

    //
    // Free the RSDT information structure
    //
    LocalFree( info );

    //
    // Done
    //
    return;
}

VOID
dumpGBLEntry(
    IN  ULONG_PTR           Address,
    IN  ULONG               Verbose
    )
/*++

Routine Description:

    This routine actually prints the rule for the table at the
    specified address

Arguments:

    Address - where the table is located

Return Value:

    None

--*/
{
    BOOL                status;
    DESCRIPTION_HEADER  header;
    ULONG               returnLength;
    UCHAR               tableId[7];
    UCHAR               entryId[20];


    //
    // Read the header for the table
    //
    status = ReadMemory(
        Address,
        &header,
        sizeof(DESCRIPTION_HEADER),
        &returnLength
        );
    if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

        dprintf("dumpGBLEntry: %x - can't read header\n", Address );
        return;

    }

    //
    // Don't print out a table unless its the FACP or we are being verbose
    //
    if (!(Verbose & VERBOSE_2) && header.Signature != FADT_SIGNATURE) {

        return;

    }

    //
    // Initialize the table id field
    //
    memset( tableId, 0, 7 );
    tableId[0] = '\"';
    memcpy( &tableId[1], &(header.Signature), sizeof(ULONG) );
    strcat( tableId, "\"" );

    //
    // Get the entry ready for the OEM Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], header.OEMID, 6 );
    strcat( entryId, "\"");
    dprintf("AcpiOemId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Table Id
    //
    memset( entryId, 0, 20 );
    entryId[0] = '\"';
    memcpy( &entryId[1], header.OEMTableID, 8 );
    strcat( entryId, "\"");
    dprintf("AcpiOemTableId=%s,%s\n", tableId, entryId );

    //
    // Get the entry ready for the OEM Revision
    //
    dprintf("AcpiOemRevision=\">=\",%s,%x\n", tableId, header.OEMRevision );

    //
    // Get the entry ready for the ACPI revision
    //
    if (header.Revision != 1) {

        dprintf("AcpiRevision=\">=\",%s,%x\n", tableId, header.Revision );

    }

    //
    // Get the entry ready for the ACPI Creator Revision
    //
    dprintf("AcpiCreatorRevision=\">=\",%s,%x\n", tableId, header.CreatorRev );

}

VOID
dumpHeader(
    IN  ULONG_PTR           Address,
    IN  PDESCRIPTION_HEADER Header,
    IN  BOOLEAN             Verbose
    )
/*++

Routine Description:

    This function dumps out a table header

Arugments:

    Address - Where the table is located
    Header  - The table header
    Verbose - How much information to give

Return Value:

    NULL

--*/
{
    memset( Buffer, 0, 2048 );
    memcpy( Buffer, &(Header->Signature), sizeof(ULONG) );

    if (Verbose) {

        dprintf(
            "HEADER - %#08lx\n"
            "  Signature:               %s\n"
            "  Length:                  0x%08lx\n"
            "  Revision:                0x%02x\n"
            "  Checksum:                0x%02x\n",
            Address,
            Buffer,
            Header->Length,
            Header->Revision,
            Header->Checksum
            );

        memset( Buffer, 0, 7 );
        memcpy( Buffer, Header->OEMID, 6 );
        dprintf("  OEMID:                   %s\n", Buffer );
        memcpy( Buffer, Header->OEMTableID, 8 );
        dprintf("  OEMTableID:              %s\n", Buffer );
        dprintf("  OEMRevision:             0x%08lx\n", Header->OEMRevision );
        memset( Buffer, 0, 8 );
        memcpy( Buffer, Header->CreatorID, 4 );
        dprintf("  CreatorID:               %s\n", Buffer );
        dprintf("  CreatorRev:              0x%08lx\n", Header->CreatorRev );

    } else {

        dprintf(
            "  %s @(%#08lx) Rev: %#03x Len: %#08lx",
            Buffer,
            Address,
            Header->Revision,
            Header->Length
            );
        memset( Buffer, 0, sizeof(ULONG) );
        memcpy( Buffer, Header->OEMTableID, 8 );
        dprintf(" TableID: %s\n", Buffer );

    }

    return;
}

VOID
dumpMAPIC(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This dumps the multiple apic table

Arguments:

    Address of the table

Return Value:

    None

--*/
{
    BOOL                hasMPSFlags;
    BOOL                status;
    BOOL                virtualMemory;
    DESCRIPTION_HEADER  mapicHeader;
    PIOAPIC             ioApic;
    PISA_VECTOR         interruptSourceOverride;
    PMAPIC              mapic;
    PIO_NMISOURCE       nmiSource;
    PLOCAL_NMISOURCE    localNmiSource;
    PPROCLOCALAPIC      localApic;
    PUCHAR              buffer;
    PUCHAR              limit;
    ULONG               index;
    ULONG               returnLength;
    ULONG               flags;

    //
    // First check to see if we find the correct things
    //
    dprintf("MAPIC - ");

    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &mapicHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || mapicHeader.Signature != APIC_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpMAPIC: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpMAPIC: Invalid Signature 0x%08lx != ACPI_SIGNATURE\n",
                mapicHeader.Signature
                );
            dumpHeader( Address, &mapicHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    mapic = LocalAlloc( LPTR, mapicHeader.Length );
    if (mapic == NULL) {

        dprintf(
            "%#08lx: Could not allocate %#08lx bytes\n",
            Address,
            mapicHeader.Length
            );
        dumpHeader( Address, &mapicHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        mapic,
        mapicHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpMAPIC: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            mapicHeader.Length
            );
        dumpHeader( Address, &mapicHeader, TRUE );
        LocalFree( mapic );
        return;

    }

    //
    // At this point, we are confident that everything worked
    //
    dumpHeader( Address, &(mapic->Header), TRUE );
    dprintf("MAPIC - BODY - %#08lx\n", Address + sizeof(DESCRIPTION_HEADER) );
    dprintf("  Local APIC Address:      %#08lx\n", mapic->LocalAPICAddress );
    dprintf("  Flags:                   %#08lx\n", mapic->Flags );
    if (mapic->Flags & PCAT_COMPAT) {

        dprintf("    PC-AT dual 8259 compatible setup\n");

    }

    buffer = (PUCHAR) &(mapic->APICTables[0]);
    limit = (PUCHAR) ( (ULONG_PTR)mapic + mapic->Header.Length );
    while (buffer < limit) {

        //
        // Assume that no flags are set
        //
        hasMPSFlags = FALSE;

        //
        // Lets see what kind of table we have?
        //
        localApic = (PPROCLOCALAPIC) buffer;
        ioApic = (PIOAPIC) buffer;
        interruptSourceOverride = (PISA_VECTOR) buffer;
        nmiSource = (PIO_NMISOURCE) buffer;
        localNmiSource = (PLOCAL_NMISOURCE) buffer;

        //
        // Is it a localApic?
        //
        if (localApic->Type == PROCESSOR_LOCAL_APIC) {

            buffer += localApic->Length;
            dprintf(
                "  Processor Local Apic\n"
                "    ACPI Processor ID:     0x%02x\n"
                "    APIC ID:               0x%02x\n"
                "    Flags:                 0x%08lx\n",
                localApic->ACPIProcessorID,
                localApic->APICID,
                localApic->Flags
                );
            if (localApic->Flags & PLAF_ENABLED) {

                dprintf("      Processor is Enabled\n");

            }
            if (localApic->Length != PROCESSOR_LOCAL_APIC_LENGTH) {

                dprintf(
                    "  Local Apic has length 0x%x instead of 0x%x\n",
                    localApic->Length,
                    PROCESSOR_LOCAL_APIC_LENGTH
                    );
                break;

            }

        } else if (ioApic->Type == IO_APIC) {

            buffer += ioApic->Length;
            dprintf(
                "  IO Apic\n"
                "    IO APIC ID:            0x%02x\n"
                "    IO APIC ADDRESS:       0x%08lx\n"
                "    System Vector Base:    0x%08lx\n",
                ioApic->IOAPICID,
                ioApic->IOAPICAddress,
                ioApic->SystemVectorBase
                );
            if (ioApic->Length != IO_APIC_LENGTH) {

                dprintf(
                    "  IO Apic has length 0x%x instead of 0x%x\n",
                    ioApic->Length,
                    IO_APIC_LENGTH
                    );
                break;

            }

        } else if (interruptSourceOverride->Type == ISA_VECTOR_OVERRIDE) {

            buffer += interruptSourceOverride->Length;
            dprintf(
                "  Interrupt Source Override\n"
                "    Bus:                   0x%02x\n"
                "    Source:                0x%02x\n"
                "    Global Interrupt:      0x%08lx\n"
                "    Flags:                 0x%04x\n",
                interruptSourceOverride->Bus,
                interruptSourceOverride->Source,
                interruptSourceOverride->GlobalSystemInterruptVector,
                interruptSourceOverride->Flags
                );

            if (interruptSourceOverride->Length != ISA_VECTOR_OVERRIDE_LENGTH) {

                dprintf(
                    "  Interrupt Source Override has length 0x%x instead of 0x%x\n",
                    interruptSourceOverride->Length,
                    ISA_VECTOR_OVERRIDE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = interruptSourceOverride->Flags;

        } else if (nmiSource->Type == IO_NMI_SOURCE) {

            buffer += nmiSource->Length;
            dprintf(
                "  Non Maskable Interrupt Source - on I/O APIC\n"
                "    Flags:                 0x%02x\n"
                "    Global Interrupt:      0x%08lx\n",
                nmiSource->Flags,
                nmiSource->GlobalSystemInterruptVector
                );
            if (nmiSource->Length != IO_NMI_SOURCE_LENGTH) {

                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    nmiSource->Length,
                    IO_NMI_SOURCE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = nmiSource->Flags;


        } else if (localNmiSource->Type == LOCAL_NMI_SOURCE) {

            buffer += localNmiSource->Length;
            dprintf(
                "  Non Maskable Interrupt Source - local to processor\n"
                "    Flags:                 0x%04x\n"
                "    Processor:             0x%02x %s\n"
                "    LINTIN:                0x%02x\n",
                localNmiSource->Flags,
                localNmiSource->ProcessorID,
                localNmiSource->ProcessorID == 0xff ? "(all)" : "",
                localNmiSource->LINTIN
                );
            if (localNmiSource->Length != LOCAL_NMI_SOURCE_LENGTH) {

                dprintf(
                    "  Non Maskable Interrupt source has length 0x%x instead of 0x%x\n",
                    localNmiSource->Length,
                    IO_NMI_SOURCE_LENGTH
                    );
                break;

            }

            hasMPSFlags = TRUE;
            flags = localNmiSource->Flags;


        } else {

            dprintf("  UNKOWN RECORD\n");
            dprintf("    Length:                0x%8lx\n", ioApic->Length );
            buffer += ioApic->Length;

        }

        //
        // Do we have any flags to dump out?
        //
        if (hasMPSFlags) {

            switch (flags & PO_BITS) {
            case POLARITY_HIGH:
                dprintf("      POLARITY_HIGH\n");
                break;
            case POLARITY_LOW:
                dprintf("      POLARITY_LOW\n");
                break;
            case POLARITY_CONFORMS_WITH_BUS:
                dprintf("      POLARITY_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      POLARITY_UNKNOWN\n");
                break;

            }

            switch (flags & EL_BITS) {
            case EL_EDGE_TRIGGERED:
                dprintf("      EL_EDGE_TRIGGERED\n");
                break;
            case EL_LEVEL_TRIGGERED:
                dprintf("      EL_LEVEL_TRIGGERED\n");
                break;
            case EL_CONFORMS_WITH_BUS:
                dprintf("      EL_CONFORMS_WITH_BUS\n");
                break;
            default:
                dprintf("      EL_UNKNOWN\n");
                break;

            }

        }

    }

    LocalFree( mapic );
    return;

}

VOID
dumpRSDT(
    IN  ULONG_PTR Address
    )
/*++

Routine Description:

    This search the dumps the RSDT table

Arguments:

    Pointer to the table

Return Value:

    NONE

--*/
{
    BOOL                status;
    BOOL                virtualMemory = FALSE;
    DESCRIPTION_HEADER  rsdtHeader;
    PRSDT               rsdt;
    ULONG               index;
    ULONG               numEntries;
    ULONG               returnLength;

    dprintf("RSDT - ");

    //
    // Determine if we have virtual or physical memory
    //
    for (index = 0; index < 2; index++) {

        status = ReadPhysicalOrVirtual(
            Address,
            &rsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            (BOOL) index
            );
        if (!status || rsdtHeader.Signature != RSDT_SIGNATURE) {

            continue;

        } else {

            break;

        }

    }

    //
    // This will set the policy for the rest of the operation
    //
    switch (index) {
    case 0:
        virtualMemory = FALSE;
        break;
    case 1:
        virtualMemory = TRUE;
        break;
    default:
        if (!status) {

            dprintf(
                "dumpRSDT: Could only read 0x%08lx of 0x%08lx bytes\n",
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );

        } else {

            dprintf(
                "dumpRSDT: Invalid Signature 0x%08lx != RSDT_SIGNATURE\n",
                rsdtHeader.Signature
                );
            dumpHeader( Address, &rsdtHeader, TRUE );

        }
        return;
    } // switch

    //
    // Do we have a correctly sized data structure
    //
    rsdt = LocalAlloc( LPTR, rsdtHeader.Length );
    if (rsdt == NULL) {

        dprintf(
            "dumpRSDT: Could not allocate %#08lx bytes\n",
            Address,
            rsdtHeader.Length
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        return;

    }

    //
    // Read the data
    //
    status = ReadPhysicalOrVirtual(
        Address,
        rsdt,
        rsdtHeader.Length,
        &returnLength,
        virtualMemory
        );
    if (!status) {

        dprintf(
            "dumpRSDT: Read %#08lx of %#08lx bytes\n",
            Address,
            returnLength,
            rsdtHeader.Length
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        LocalFree( rsdt );
        return;

    } else if (rsdt->Header.Signature != RSDT_SIGNATURE) {

        dprintf(
            "dumpRSDT: Signature (%#08lx) != RSDT_SIGNATURE (%#08lx)\n",
            Address,
            rsdt->Header.Signature,
            RSDT_SIGNATURE
            );
        dumpHeader( Address, &rsdtHeader, TRUE );
        LocalFree( rsdt );
        return;

    }

    //
    // At this point, we are confident that everything worked
    //
    dumpHeader( Address, &(rsdt->Header), TRUE );
    dprintf("RSDT - BODY - %#08lx\n", Address + sizeof(DESCRIPTION_HEADER) );
    numEntries = ( rsdt->Header.Length - sizeof(DESCRIPTION_HEADER) ) /
        sizeof(rsdt->Tables[0]);
    for (index = 0; index < numEntries; index++) {

        //
        // Note: unless things radically change, the pointers in the
        // rsdt will always point to bios memory!
        //
        status = ReadPhysicalOrVirtual(
            rsdt->Tables[index],
            &rsdtHeader,
            sizeof(DESCRIPTION_HEADER),
            &returnLength,
            FALSE
            );
        if (!status || returnLength != sizeof(DESCRIPTION_HEADER)) {

            dprintf(
                "dumpRSDT: [%d:0x%08lx] - Read %#08lx of %#08lx bytes\n",
                index,
                rsdt->Tables[index],
                returnLength,
                sizeof(DESCRIPTION_HEADER)
                );
            continue;

        }

        dumpHeader( rsdt->Tables[index], &rsdtHeader, FALSE );

    }

    LocalFree( rsdt );
    return;
}

BOOLEAN
findRSDT(
    IN  PULONG_PTR Address
    )
/*++

Routine Description:

    This searchs the memory on the target system for the RSDT pointer

Arguments:

    Address - Where to store the result

Return Value:

    TRUE    - If we found the RSDT

--*/
{
    PHYSICAL_ADDRESS    address = { 0L, 0L };
    RSDP                rsdp;
    RSDT                rsdt;
    UCHAR               index;
    UCHAR               sum;
    ULONG               limit;
    ULONG               returnLength;
    ULONG               start;

    //
    // Calculate the start and end of the search range
    //
    start = (ULONG) RSDP_SEARCH_RANGE_BEGIN;
    limit = (ULONG) start + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;

    dprintf( "Searching for RSDP.");

    //
    // Loop for a while
    //
    for (; start <= limit; start += RSDP_SEARCH_INTERVAL) {

        if (start % (RSDP_SEARCH_INTERVAL * 100 ) == 0) {

            dprintf(".");

        }
        //
        // Read the data from the target
        //
        address.LowPart = start;
        ReadPhysical( address.QuadPart, &rsdp, sizeof(RSDP), &returnLength);
        if (returnLength != sizeof(RSDP)) {

            dprintf(
                "%#08lx: Read %#08lx of %#08lx bytes\n",
                start,
                returnLength,
                sizeof(RSDP)
                );
            return FALSE;

        }

        //
        // Is this a match?
        //
        if (rsdp.Signature != RSDP_SIGNATURE) {

            continue;

        }

        //
        // Check the checksum out
        //
        for (index = 0, sum = 0; index < sizeof(RSDP); index++) {

            sum = (UCHAR) (sum + *( (UCHAR *) ( (ULONG_PTR) &rsdp + index ) ) );

        }
        if (sum != 0) {

            continue;

        }

        //
        // Found RSDP
        //
        dprintf("\nRSDP - %#08lx\n", start );
        memset( Buffer, 0, 2048 );
        memcpy( Buffer, &(rsdp.Signature), sizeof(ULONGLONG) );
        dprintf("  Signature:   %s\n", Buffer );
        dprintf("  Checksum:    %#03x\n", rsdp.Checksum );
        memset( Buffer, 0, sizeof(ULONGLONG) );
        memcpy( Buffer, rsdp.OEMID, 6 );
        dprintf("  OEMID:       %s\n", Buffer );
        dprintf("  Reserved:    %#03x\n", rsdp.Reserved );
        dprintf("  RsdtAddress: %#08lx\n", rsdp.RsdtAddress );

        //
        // Done
        //
        *Address = rsdp.RsdtAddress;
        return TRUE;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\udebug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   globalDebugIndentLevel = 0;
ULONG   globalVerbosityLevel = 0;
UCHAR   DebugMessageBuffer[2048];

VOID
IndentProcedure(
    VOID
    )
{
    ULONG   i;

    for (i = 0; i < globalDebugIndentLevel; i++) {

        if (GlobalPrintFnc != NULL) {

            GlobalPrintFnc("| ");

        } else {

            fprintf( stderr, "| ");

        }

    }
}

VOID
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    entered

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }
    globalDebugIndentLevel++;
}

VOID
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    globalDebugIndentLevel--;
    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }

}

VOID
DebugPrintProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        IndentProcedure();
        va_start( marker, Format );
        if (GlobalPrintFnc != NULL) {

            vsprintf( DebugMessageBuffer, Format, marker );
            GlobalPrintFnc( DebugMessageBuffer );

        } else {

            vfprintf( stderr, Format, marker );
            fflush( stderr );

        }
        va_end ( marker );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\udata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList
#define SK      TF_DELAY_UNASM          //term cannot be unasmed on the first pass

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN      UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

//
// Field flags
//
#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

//
// AccessAttribute
//

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

//
// Operation region space
//
#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

//
// Method flags
//
#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

//
// Match operation values
//
#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock", CD, 0, OP_NONE,     NULL, NULL, OL|CL|LL|AF|AV,
    "Include",         CD, 0, OP_NONE,     NULL, NULL, AF,
    "External",        CD, 0, OP_NONE,     NULL, "uX", AF,

    // Short Objects
    "Zero",            CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",             CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",            CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",        CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",            SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",            SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",            SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",            SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",            SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",            SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",            SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",          SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",          SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",          SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",          SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",          SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",          SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",          SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",          SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",           SN, 0, OP_DEBUG,    NULL, NULL, 0,

    // Named Terms
    "Alias",           NS, 0, OP_ALIAS,    "NN", "Ua", 0,
    "Name",            NS, 0, OP_NAME,     "NO", "u",  0,
    "Scope",           NS, 0, OP_SCOPE,    "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",          DO, 0, OP_BUFFER,   "C", "U",  DL|LN,
    "Package",         DO, 0, OP_PACKAGE,  "B", NULL, PL|LN,
    "EISAID",          DO, 0, OP_DWORD,    NULL,NULL, AF,

    // Argument Keywords
    "AnyAcc",          KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",         KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",         KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",        KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",        KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",       KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",            KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",          KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",        KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",     KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",    KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",    KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",        KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",      KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl", KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",           KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",      KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",   KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",             KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",             KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",             KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",             KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",             KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",             KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",            KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",           KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",      KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",       KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",          KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",       KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",   KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",           KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",           KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",           KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",       KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",    KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",       KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",    KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",      KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",        KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",        KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",       KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",        KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer",KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer",KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",       KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",       KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",        KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",     KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",        KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",     KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",       KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",  KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",    KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",    KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",   KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges",KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",     KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",         KW, ($HGH | $EDG),  OP_NONE, NULL, "U", 0,
    "ExtLevel",        KW, ($LOW | $LVL),  OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",   KW, ($HGH | $EDG),  OP_NONE, NULL, "V", 0,
    "ExtActiveLow",    KW, ($LOW | $LVL),  OP_NONE, NULL, "V", 0,

    "ExtShared",       KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",    KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",      KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",          KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",          KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",         KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",          KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",    KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",       KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",        KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",       KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",        KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",     KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",     KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",  KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",    KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",    KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",          FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",        FM, 0, 0x01,    NULL, "A" , AF,

    // Named Object Creators
    "BankField",       NO, 0, OP_BANKFIELD,  "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",  NO, 0, OP_BITFIELD,   "CCN",   "UUb",    0,
    "CreateByteField", NO, 0, OP_BYTEFIELD,  "CCN",   "UUb",    0,
    "CreateDWordField",NO, 0, OP_DWORDFIELD, "CCN",   "UUb",    0,
    "CreateField",     NO, 0, OP_CREATEFIELD,"CCCN",  "UUUb",   0,
    "CreateWordField", NO, 0, OP_WORDFIELD,  "CCN",   "UUb",    0,
    "Device",          NO, 0, OP_DEVICE,     "N",     "d",      OL|LN|CC,
    "Event",           NO, 0, OP_EVENT,      "N",     "e",      0,
    "Field",           NO, 0, OP_FIELD,      "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",      NO, 0, OP_IDXFIELD,   "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",          NO, 0, OP_METHOD,     "NKk",   "m!E",    CL|OL|LN|AF|CC|SK,
    "Mutex",           NO, 0, OP_MUTEX,      "NB",    "x",      0,
    "OperationRegion", NO, 0, OP_OPREGION,   "NKCC",  "oDUU",   AF,
    "PowerResource",   NO, 0, OP_POWERRES,   "NBW",   "p",      OL|LN|CC,
    "Processor",       NO, 0, OP_PROCESSOR,  "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",     NO, 0, OP_THERMALZONE,"N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",           C1, 0, OP_BREAK,       NULL,  NULL, 0,
    "BreakPoint",      C1, 0, OP_BREAKPOINT,  NULL,  NULL, 0,
    "Else",            C1, 0, OP_ELSE,        NULL,  NULL, AF|CL|OL|LN,
    "Fatal",           C1, 0, OP_FATAL,       "BDC", "  U",0,
    "If",              C1, 0, OP_IF,          "C",   "U",  CL|OL|LN,
    "Load",            C1, 0, OP_LOAD,        "NS",  "UU", 0,
    "Noop",            C1, 0, OP_NOP,         NULL,  NULL, 0,
    "Notify",          C1, 0, OP_NOTIFY,      "SC",  "UU", 0,
    "Release",         C1, 0, OP_RELEASE,     "S",   "X",  0,
    "Reset",           C1, 0, OP_RESET,       "S",   "E",  0,
    "Return",          C1, 0, OP_RETURN,      "C",   "U",  0,
    "Signal",          C1, 0, OP_SIGNAL,      "S",   "E",  0,
    "Sleep",           C1, 0, OP_SLEEP,       "C",   "U",  0,
    "Stall",           C1, 0, OP_STALL,       "C",   "U",  0,
    "Unload",          C1, 0, OP_UNLOAD,      "S",   "U",  0,
    "While",           C1, 0, OP_WHILE,       "C",   "U",  CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",         C2, 0, OP_ACQUIRE,     "SW",     "X",  0,
    "Add",             C2, 0, OP_ADD,         "CCS",    "UUU",0,
    "And",             C2, 0, OP_AND,         "CCS",    "UUU",0,
    "Concatenate",     C2, 0, OP_CONCAT,      "CCS",    "UUU",0,
    "CondRefOf",       C2, 0, OP_CONDREFOF,   "SS",     "UU", 0,
    "Decrement",       C2, 0, OP_DECREMENT,   "S",      "U",  0,
    "DerefOf",         C2, 0, OP_DEREFOF,     "C",      "U",  0,
    "Divide",          C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",0,
    "FindSetLeftBit",  C2, 0, OP_FINDSETLBIT, "CS",     "UU", 0,
    "FindSetRightBit", C2, 0, OP_FINDSETRBIT, "CS",     "UU", 0,
    "FromBCD",         C2, 0, OP_FROMBCD,     "CS",     "UU", 0,
    "Increment",       C2, 0, OP_INCREMENT,   "S",      "U",  0,
    "Index",           C2, 0, OP_INDEX,       "CCS",    "UUU",0,
    "LAnd",            C2, 0, OP_LAND,        "CC",     "UU", 0,
    "LEqual",          C2, 0, OP_LEQ,         "CC",     "UU", 0,
    "LGreater",        C2, 0, OP_LG,          "CC",     "UU", 0,
    "LGreaterEqual",   C2, 0, OP_LGEQ,        "CC",     "UU", 0,
    "LLess",           C2, 0, OP_LL,          "CC",     "UU", 0,
    "LLessEqual",      C2, 0, OP_LLEQ,        "CC",     "UU", 0,
    "LNot",            C2, 0, OP_LNOT,        "C",      "U",  0,
    "LNotEqual",       C2, 0, OP_LNOTEQ,      "CC",     "UU", 0,
    "LOr",             C2, 0, OP_LOR,         "CC",     "UU", 0,
    "Match",           C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU",AF,
    "Multiply",        C2, 0, OP_MULTIPLY,    "CCS",    "UUU",0,
    "NAnd",            C2, 0, OP_NAND,        "CCS",    "UUU",0,
    "NOr",             C2, 0, OP_NOR,         "CCS",    "UUU",0,
    "Not",             C2, 0, OP_NOT,         "CS",     "UU", 0,
    "ObjectType",      C2, 0, OP_OBJTYPE,     "S",      "U",  0,
    "Or",              C2, 0, OP_OR,          "CCS",    "UUU",0,
    "RefOf",           C2, 0, OP_REFOF,       "S",      "U",  0,
    "ShiftLeft",       C2, 0, OP_SHIFTL,      "CCS",    "UUU",0,
    "ShiftRight",      C2, 0, OP_SHIFTR,      "CCS",    "UUU",0,
    "SizeOf",          C2, 0, OP_SIZEOF,      "S",      "U",  0,
    "Store",           C2, 0, OP_STORE,       "CS",     "UU", 0,
    "Subtract",        C2, 0, OP_SUBTRACT,    "CCS",    "UUU",0,
    "ToBCD",           C2, 0, OP_TOBCD,       "CS",     "UU", 0,
    "Wait",            C2, 0, OP_WAIT,        "SC",     "E",  0,
    "XOr",             C2, 0, OP_XOR,         "CCS",    "UUU",0,

    NULL,              0,  0, OP_NONE,   NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\udata.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DATA_H
#define _DATA_H

    //
    // Constants
    //

    // String constants
    #define STR_PROGDESC            "ACPI Source Language Assembler"
    #define STR_COPYRIGHT           "Copyright (c) 1996,1997 Microsoft Corporation"
    #define STR_MS                  "MSFT"

    // Misc. constants
    #define NAMESEG_BLANK           0x5f5f5f5f      // "____"
    #define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
    #define NAMESEG                 ULONG
    #define SUPERNAME               NAMESEG
    #define NSF_LOCAL_SCOPE         0x00000001


    // Implementation constants
    #define MAX_STRING_LEN          199
    #define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
    #define MAX_MSG_LEN             127
    #define MAX_ARGS                7
    #define MAX_PACKAGE_LEN         0x0fffffff

    // Term classes
    #define UTC_PNP_MACRO           0x00100000
    #define UTC_REF_OBJECT          0x00200000
    #define UTC_FIELD_MACRO         0x00400000
    #define UTC_DATA_OBJECT         0x00800000
    #define UTC_NAMED_OBJECT        0x01000000
    #define UTC_NAMESPACE_MODIFIER  0x02000000
    #define UTC_OPCODE_TYPE1        0x04000000
    #define UTC_OPCODE_TYPE2        0x08000000
    #define UTC_CONST_NAME          0x10000000
    #define UTC_SHORT_NAME          0x20000000
    #define UTC_COMPILER_DIRECTIVE  0x40000000
    #define UTC_KEYWORD             0x80000000
    #define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 | \
                                     UTC_SHORT_NAME | UTC_CONST_NAME | \
                                     UTC_DATA_OBJECT)
    #define UTC_OPCODE_TERM         (UTC_CONST_NAME | UTC_SHORT_NAME | \
                                     UTC_DATA_OBJECT | UTC_NAMED_OBJECT | \
                                     UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 | \
                                     UTC_NAMESPACE_MODIFIER)

    // Term flags
    #define TF_ACTION_FLIST         0x00000001
    #define TF_ACTION_VLIST         0x00000002
    #define TF_PACKAGE_LEN          0x00000004
    #define TF_CHANGE_CHILDSCOPE    0x00000008
    #define TF_DELAY_UNASM          0x00000010
    #define TF_FIELD_MACRO          UTC_FIELD_MACRO
    #define TF_DATA_OBJECT          UTC_DATA_OBJECT
    #define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
    #define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
    #define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
    #define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
    #define TF_CONST_NAME           UTC_CONST_NAME
    #define TF_SHORT_NAME           UTC_SHORT_NAME
    #define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
    #define TF_KEYWORD              UTC_KEYWORD
    #define TF_PNP_MACRO            UTC_PNP_MACRO
    #define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
    #define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
    #define TF_DATA_LIST            0x00010000
    #define TF_FIELD_LIST           0x00020000
    #define TF_BYTE_LIST            0x00040000
    #define TF_DWORD_LIST           0x00080000
    #define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                     UTC_CONST_NAME)
    #define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                     TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                     TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                     TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                     TF_DATA_LIST | TF_PACKAGE_LIST | \
                                     TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                     TF_DWORD_LIST)

    // Code flags
    #define CF_MISSING_ARG          0x00000001
    #define CF_PARSING_FIXEDLIST    0x00000002
    #define CF_PARSING_VARLIST      0x00000004

    // NS flags
    #define NSF_EXIST_OK            0x00010000
    #define NSF_EXIST_ERR           0x00020000

    // Data types
    #define CODETYPE_UNKNOWN        0
    #define CODETYPE_ASLTERM        1
    #define CODETYPE_NAME           2
    #define CODETYPE_DATAOBJ        3
    #define CODETYPE_FIELDOBJ       4
    #define CODETYPE_INTEGER        5
    #define CODETYPE_STRING         6
    #define CODETYPE_KEYWORD        7
    #define CODETYPE_USERTERM       8
    #define CODETYPE_QWORD          9

    // NameSpace object types
    #define NSTYPE_UNKNOWN          'U'
    #define NSTYPE_SCOPE            'S'
    #define NSTYPE_FIELDUNIT        'F'
    #define NSTYPE_DEVICE           'D'
    #define NSTYPE_EVENT            'E'
    #define NSTYPE_METHOD           'M'
    #define NSTYPE_MUTEX            'X'
    #define NSTYPE_OPREGION         'O'
    #define NSTYPE_POWERRES         'P'
    #define NSTYPE_PROCESSOR        'C'
    #define NSTYPE_THERMALZONE      'T'
    #define NSTYPE_OBJALIAS         'A'
    #define NSTYPE_BUFFFIELD        'B'

    #define OBJTYPE_PRIVATE         0xf0
    #define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
    #define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)

    // Opcode classes
    #define OPCLASS_INVALID         0
    #define OPCLASS_DATA_OBJ        1
    #define OPCLASS_NAME_OBJ        2
    #define OPCLASS_CONST_OBJ       3
    #define OPCLASS_CODE_OBJ        4
    #define OPCLASS_ARG_OBJ         5
    #define OPCLASS_LOCAL_OBJ       6

    //dwfData flags
    #define DATAF_BUFF_ALIAS        0x00000001
    #define DATAF_GLOBAL_LOCK       0x00000002

    //dwDataType values
    #define OBJTYPE_UNKNOWN         0x00
    #define OBJTYPE_INTDATA         0x01
    #define OBJTYPE_STRDATA         0x02
    #define OBJTYPE_BUFFDATA        0x03
    #define OBJTYPE_PKGDATA         0x04
    #define OBJTYPE_FIELDUNIT       0x05
    #define OBJTYPE_DEVICE          0x06
    #define OBJTYPE_EVENT           0x07
    #define OBJTYPE_METHOD          0x08
    #define OBJTYPE_MUTEX           0x09
    #define OBJTYPE_OPREGION        0x0a
    #define OBJTYPE_POWERRES        0x0b
    #define OBJTYPE_PROCESSOR       0x0c
    #define OBJTYPE_THERMALZONE     0x0d
    #define OBJTYPE_BUFFFIELD       0x0e
    #define OBJTYPE_DDBHANDLE       0x0f

    //These are internal object types (not to be exported to the ASL code)
    #define OBJTYPE_INTERNAL        0x80

    //Predefined data values (dwDataValue)
    #define DATAVALUE_ZERO          0
    #define DATAVALUE_ONE           1
    #define DATAVALUE_ONES          0xffffffff

    //
    // Macros
    //
    #define MEMALLOC(n)           malloc(n)
    #define MEMFREE(p)            free(p)

    //
    // Type definitions
    //
    typedef int (LOCAL *PFNTERM)(PUCHAR, BOOL);

    typedef struct _aslterm
    {
        PUCHAR  ID;
        ULONG   TermClass;
        ULONG   TermData;
        ULONG   OpCode;
        PUCHAR  UnAsmArgTypes;
        PUCHAR  ArgActions;
        ULONG   Flags;
    } ASLTERM, *PASLTERM;

    typedef struct _opmap
    {
        UCHAR   ExtendedOpCode;
        UCHAR   OpCodeClass;
    } OPMAP, *POPMAP;

    extern ASLTERM  TermTable[];
    extern UCHAR    OpClassTable[];
    extern OPMAP    ExOpClassTable[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\udebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

    #ifdef DBG

        #define ENTER(x)    DebugEnterProcedure x
        #define EXIT(x)     DebugExitProcedure x
        #define INFO(x)     DebugPrintProcedure x

        VOID
        DebugEnterProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

        VOID
        DebugExitProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

        VOID
        DebugPrintProcedure(
            ULONG   VerbosityLevel,
            PCCHAR  Format,
            ...
            );

    #else

        #define ENTER(x)
        #define EXIT(x)
        #define INFO(x)

    #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\uasmdata.c ===
/*** uasmdata.c - Unassembler data
 *
 *  This module contains data declaration of the unassembler
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

#ifdef DEBUGGER

int giLevel = 0;
ULONG_PTR guipbOpXlate = 0;
PNSOBJ gpnsCurUnAsmScope = NULL;

#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define CC      TF_CHANGE_CHILDSCOPE    //change to child scope
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      UTC_COMPILER_DIRECTIVE
#define FM      UTC_FIELD_MACRO
#define CN	UTC_CONST_NAME
#define SN      UTC_SHORT_NAME
#define NS      UTC_NAMESPACE_MODIFIER
#define DO      UTC_DATA_OBJECT
#define KW      UTC_KEYWORD
#define NO      UTC_NAMED_OBJECT
#define C1      UTC_OPCODE_TYPE1
#define C2      UTC_OPCODE_TYPE2
#define RO      UTC_REF_OBJECT
#define PM      UTC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

/*** Field flags
 */

#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define AQW     (ACCTYPE_QWORD |  (ACCTYPE_MASK << 8))
#define ABFR    (ACCTYPE_BUFFER |  (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

/*** AccessAttribute
 */

#define SMBQ    0x02
#define SMBS    0x04
#define SMBB    0x06
#define SMBW    0x08
#define SMBK    0x0a
#define SMBP    0x0c
#define SMBC    0x0d

/*** Operation region space
 */

#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

/*** Method flags
 */

#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

/*** Match operation values
 */

#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  CD, 0, OP_NONE, NULL, NULL, OL|CL|LL|AF|AV,
    "Include",          CD, 0, OP_NONE, NULL, NULL, AF,
    "External",         CD, 0, OP_NONE, NULL, "uX", AF,

    // Short Objects
    "Zero",             CN, 0, OP_ZERO,     NULL, NULL, 0,
    "One",              CN, 0, OP_ONE,      NULL, NULL, 0,
    "Ones",             CN, 0, OP_ONES,     NULL, NULL, 0,
    "Revision",         CN, 0, OP_REVISION, NULL, NULL, 0,
    "Arg0",             SN, 0, OP_ARG0,     NULL, NULL, 0,
    "Arg1",             SN, 0, OP_ARG1,     NULL, NULL, 0,
    "Arg2",             SN, 0, OP_ARG2,     NULL, NULL, 0,
    "Arg3",             SN, 0, OP_ARG3,     NULL, NULL, 0,
    "Arg4",             SN, 0, OP_ARG4,     NULL, NULL, 0,
    "Arg5",             SN, 0, OP_ARG5,     NULL, NULL, 0,
    "Arg6",             SN, 0, OP_ARG6,     NULL, NULL, 0,
    "Local0",           SN, 0, OP_LOCAL0,   NULL, NULL, 0,
    "Local1",           SN, 0, OP_LOCAL1,   NULL, NULL, 0,
    "Local2",           SN, 0, OP_LOCAL2,   NULL, NULL, 0,
    "Local3",           SN, 0, OP_LOCAL3,   NULL, NULL, 0,
    "Local4",           SN, 0, OP_LOCAL4,   NULL, NULL, 0,
    "Local5",           SN, 0, OP_LOCAL5,   NULL, NULL, 0,
    "Local6",           SN, 0, OP_LOCAL6,   NULL, NULL, 0,
    "Local7",           SN, 0, OP_LOCAL7,   NULL, NULL, 0,
    "Debug",            SN, 0, OP_DEBUG,    NULL, NULL, 0,

    // Named Terms
    "Alias",            NS, 0, OP_ALIAS, "NN", "Ua", 0,
    "Name",             NS, 0, OP_NAME,  "NO", "u",  0,
    "Scope",            NS, 0, OP_SCOPE, "N",  "S",  OL|LN|CC,

    // Data Objects
    "Buffer",           DO, 0, OP_BUFFER,  "C",  "U",  DL|LN,
    "Package",          DO, 0, OP_PACKAGE, "B",  NULL, PL|LN,
    "EISAID",		DO, 0, OP_DWORD,   NULL, NULL, AF,

    // Argument Keywords
    "AnyAcc",           KW, AANY, OP_NONE, NULL, "A", 0,
    "ByteAcc",          KW, AB,   OP_NONE, NULL, "A", 0,
    "WordAcc",          KW, AW,   OP_NONE, NULL, "A", 0,
    "DWordAcc",         KW, ADW,  OP_NONE, NULL, "A", 0,
    "QWordAcc",         KW, AQW,  OP_NONE, NULL, "A", 0,
    "BufferAcc",        KW, ABFR, OP_NONE, NULL, "A", 0,

    "Lock",             KW, LK,   OP_NONE, NULL, "B", 0,
    "NoLock",           KW, NOLK, OP_NONE, NULL, "B", 0,

    "Preserve",         KW, PSRV, OP_NONE, NULL, "C", 0,
    "WriteAsOnes",      KW, WA1S, OP_NONE, NULL, "C", 0,
    "WriteAsZeros",     KW, WA0S, OP_NONE, NULL, "C", 0,

    "SystemMemory",     KW, MEM,  OP_NONE, NULL, "D", 0,
    "SystemIO",         KW, IO,   OP_NONE, NULL, "D", 0,
    "PCI_Config",       KW, CFG,  OP_NONE, NULL, "D", 0,
    "EmbeddedControl",  KW, EC,   OP_NONE, NULL, "D", 0,
    "SMBus",            KW, SMB,  OP_NONE, NULL, "D", 0,

    "Serialized",       KW, SER,  OP_NONE, NULL, "E", 0,
    "NotSerialized",    KW, NOSER,OP_NONE, NULL, "E", 0,

    "MTR",              KW, OMTR, OP_NONE, NULL, "F", 0,
    "MEQ",              KW, OMEQ, OP_NONE, NULL, "F", 0,
    "MLE",              KW, OMLE, OP_NONE, NULL, "F", 0,
    "MLT",              KW, OMLT, OP_NONE, NULL, "F", 0,
    "MGE",              KW, OMGE, OP_NONE, NULL, "F", 0,
    "MGT",              KW, OMGT, OP_NONE, NULL, "F", 0,

    "Edge",             KW, _HE,  OP_NONE, NULL, "G", 0,
    "Level",            KW, _LL,  OP_NONE, NULL, "G", 0,

    "ActiveHigh",       KW, _HE,  OP_NONE, NULL, "H", 0,
    "ActiveLow",        KW, _LL,  OP_NONE, NULL, "H", 0,

    "Shared",           KW, _SHR, OP_NONE, NULL, "I", 0,
    "Exclusive",        KW, _EXC, OP_NONE, NULL, "I", 0,

    "Compatibility",    KW, COMP, OP_NONE, NULL, "J", 0,
    "TypeA",            KW, TYPA, OP_NONE, NULL, "J", 0,
    "TypeB",            KW, TYPB, OP_NONE, NULL, "J", 0,
    "TypeF",            KW, TYPF, OP_NONE, NULL, "J", 0,

    "BusMaster",        KW, BM,   OP_NONE, NULL, "K", 0,
    "NotBusMaster",     KW, NOBM, OP_NONE, NULL, "K", 0,

    "Transfer8",        KW, X8,   OP_NONE, NULL, "L", 0,
    "Transfer8_16",     KW, X816, OP_NONE, NULL, "L", 0,
    "Transfer16",       KW, X16,  OP_NONE, NULL, "L", 0,

    "Decode16",         KW, DC16, OP_NONE, NULL, "M", 0,
    "Decode10",         KW, DC10, OP_NONE, NULL, "M", 0,

    "ReadWrite",        KW, _RW,  OP_NONE, NULL, "N", 0,
    "ReadOnly",         KW, _ROM, OP_NONE, NULL, "N", 0,

    "ResourceConsumer", KW, RCS,  OP_NONE, NULL, "O", 0,
    "ResourceProducer", KW, RPD,  OP_NONE, NULL, "O", 0,

    "SubDecode",        KW, BSD,  OP_NONE, NULL, "P", 0,
    "PosDecode",        KW, BPD,  OP_NONE, NULL, "P", 0,

    "MinFixed",         KW, MIF,  OP_NONE, NULL, "Q", 0,
    "MinNotFixed",      KW, NMIF, OP_NONE, NULL, "Q", 0,

    "MaxFixed",         KW, MAF,  OP_NONE, NULL, "R", 0,
    "MaxNotFixed",      KW, NMAF, OP_NONE, NULL, "R", 0,

    "Cacheable",        KW, CACH, OP_NONE, NULL, "S", 0,
    "WriteCombining",   KW, WRCB, OP_NONE, NULL, "S", 0,
    "Prefetchable",     KW, PREF, OP_NONE, NULL, "S", 0,
    "NonCacheable",     KW, NCAC, OP_NONE, NULL, "S", 0,

    "ISAOnlyRanges",    KW, ISA,  OP_NONE, NULL, "T", 0,
    "NonISAOnlyRanges", KW, NISA, OP_NONE, NULL, "T", 0,
    "EntireRange",      KW, ERNG, OP_NONE, NULL, "T", 0,

    "ExtEdge",          KW, $EDG, OP_NONE, NULL, "U", 0,
    "ExtLevel",         KW, $LVL, OP_NONE, NULL, "U", 0,

    "ExtActiveHigh",    KW, $HGH, OP_NONE, NULL, "V", 0,
    "ExtActiveLow",     KW, $LOW, OP_NONE, NULL, "V", 0,

    "ExtShared",        KW, $SHR, OP_NONE, NULL, "W", 0,
    "ExtExclusive",     KW, $EXC, OP_NONE, NULL, "W", 0,

    "UnknownObj",       KW, UNK,  OP_NONE, NULL, "X", 0,
    "IntObj",           KW, INT,  OP_NONE, NULL, "X", 0,
    "StrObj",           KW, STR,  OP_NONE, NULL, "X", 0,
    "BuffObj",          KW, BUF,  OP_NONE, NULL, "X", 0,
    "PkgObj",           KW, PKG,  OP_NONE, NULL, "X", 0,
    "FieldUnitObj",     KW, FDU,  OP_NONE, NULL, "X", 0,
    "DeviceObj",        KW, DEV,  OP_NONE, NULL, "X", 0,
    "EventObj",         KW, EVT,  OP_NONE, NULL, "X", 0,
    "MethodObj",        KW, MET,  OP_NONE, NULL, "X", 0,
    "MutexObj",         KW, MUT,  OP_NONE, NULL, "X", 0,
    "OpRegionObj",      KW, OPR,  OP_NONE, NULL, "X", 0,
    "PowerResObj",      KW, PWR,  OP_NONE, NULL, "X", 0,
    "ThermalZoneObj",   KW, THM,  OP_NONE, NULL, "X", 0,
    "BuffFieldObj",     KW, BFD,  OP_NONE, NULL, "X", 0,
    "DDBHandleObj",     KW, DDB,  OP_NONE, NULL, "X", 0,

    "SMBQuick",            KW, SMBQ, OP_NONE, NULL, "Y", 0,
    "SMBSendReceive",      KW, SMBS, OP_NONE, NULL, "Y", 0,
    "SMBByte",             KW, SMBB, OP_NONE, NULL, "Y", 0,
    "SMBWord",             KW, SMBW, OP_NONE, NULL, "Y", 0,
    "SMBBlock",            KW, SMBK, OP_NONE, NULL, "Y", 0,
    "SMBProcessCall",      KW, SMBP, OP_NONE, NULL, "Y", 0,
    "SMBBlockProcessCall", KW, SMBC, OP_NONE, NULL, "Y", 0,

    // Field Macros
    "Offset",           FM, 0, OP_NONE, NULL, NULL, 0,
    "AccessAs",         FM, 0, 0x01,    NULL, "A",  AF,

    // Named Object Creators
    "BankField",        NO, 0, OP_BANKFIELD,   "NNCKkk","OFUABC", FL|FM|LN|AF,
    "CreateBitField",   NO, 0, OP_BITFIELD,    "CCN",   "UUb",    0,
    "CreateByteField",  NO, 0, OP_BYTEFIELD,   "CCN",   "UUb",    0,
    "CreateDWordField", NO, 0, OP_DWORDFIELD,  "CCN",   "UUb",    0,
    "CreateField",      NO, 0, OP_CREATEFIELD, "CCCN",  "UUUb",   0,
    "CreateWordField",  NO, 0, OP_WORDFIELD,   "CCN",   "UUb",    0,
    "Device",           NO, 0, OP_DEVICE,      "N",     "d",      OL|LN|CC,
    "Event",            NO, 0, OP_EVENT,       "N",     "e",      0,
    "Field",            NO, 0, OP_FIELD,       "NKkk",  "OABC",   FL|FM|LN|AF,
    "IndexField",       NO, 0, OP_IDXFIELD,    "NNKkk", "FFABC",  FL|FM|LN|AF,
    "Method",           NO, 0, OP_METHOD,      "NKk",   "m!E",    CL|OL|LN|AF|CC,
    "Mutex",            NO, 0, OP_MUTEX,       "NB",    "x",      0,
    "OperationRegion",  NO, 0, OP_OPREGION,    "NKCC",  "oDUU",   AF,
    "PowerResource",    NO, 0, OP_POWERRES,    "NBW",   "p",      OL|LN|CC,
    "Processor",        NO, 0, OP_PROCESSOR,   "NBDB",  "c",      OL|LN|CC,
    "ThermalZone",      NO, 0, OP_THERMALZONE, "N",     "t",      OL|LN|CC,

    // Type 1 Opcode Terms
    "Break",            C1, 0, OP_BREAK,      NULL,  NULL,  0,
    "BreakPoint",       C1, 0, OP_BREAKPOINT, NULL,  NULL,  0,
    "Else",             C1, 0, OP_ELSE,       NULL,  NULL,  AF|CL|OL|LN,
    "Fatal",            C1, 0, OP_FATAL,      "BDC", "  U", 0,
    "If",               C1, 0, OP_IF,         "C",   "U",   CL|OL|LN,
    "Load",             C1, 0, OP_LOAD,       "NS",  "UU",  0,
    "Noop",             C1, 0, OP_NOP,        NULL,  NULL,  0,
    "Notify",           C1, 0, OP_NOTIFY,     "SC",  "UU",  0,
    "Release",          C1, 0, OP_RELEASE,    "S",   "X",   0,
    "Reset",            C1, 0, OP_RESET,      "S",   "E",   0,
    "Return",           C1, 0, OP_RETURN,     "C",   "U",   0,
    "Signal",           C1, 0, OP_SIGNAL,     "S",   "E",   0,
    "Sleep",            C1, 0, OP_SLEEP,      "C",   "U",   0,
    "Stall",            C1, 0, OP_STALL,      "C",   "U",   0,
    "Unload",           C1, 0, OP_UNLOAD,     "S",   "U",   0,
    "While",            C1, 0, OP_WHILE,      "C",   "U",   CL|OL|LN,

    // Type 2 Opcode Terms
    "Acquire",          C2, 0, OP_ACQUIRE,     "SW",     "X",      0,
    "Add",              C2, 0, OP_ADD,         "CCS",    "UUU",    0,
    "And",              C2, 0, OP_AND,         "CCS",    "UUU",    0,
    "Concatenate",      C2, 0, OP_CONCAT,      "CCS",    "UUU",    0,
    "CondRefOf",        C2, 0, OP_CONDREFOF,   "SS",     "UU",     0,
    "Decrement",        C2, 0, OP_DECREMENT,   "S",      "U",      0,
    "DerefOf",		C2, 0, OP_DEREFOF,     "C",      "U",      0,
    "Divide",           C2, 0, OP_DIVIDE,      "CCSS",   "UUUU",   0,
    "FindSetLeftBit",   C2, 0, OP_FINDSETLBIT, "CS",     "UU",     0,
    "FindSetRightBit",  C2, 0, OP_FINDSETRBIT, "CS",     "UU",     0,
    "FromBCD",          C2, 0, OP_FROMBCD,     "CS",     "UU",     0,
    "Increment",        C2, 0, OP_INCREMENT,   "S",      "U",      0,
    "Index",            RO|C2, 0, OP_INDEX,    "CCS",    "UUU",    0,
    "LAnd",             C2, 0, OP_LAND,        "CC",     "UU",     0,
    "LEqual",           C2, 0, OP_LEQ,         "CC",     "UU",     0,
    "LGreater",         C2, 0, OP_LG,          "CC",     "UU",     0,
    "LGreaterEqual",    C2, 0, OP_LGEQ,        "CC",     "UU",     0,
    "LLess",            C2, 0, OP_LL,          "CC",     "UU",     0,
    "LLessEqual",       C2, 0, OP_LLEQ,        "CC",     "UU",     0,
    "LNot",             C2, 0, OP_LNOT,        "C",      "U",      0,
    "LNotEqual",        C2, 0, OP_LNOTEQ,      "CC",     "UU",     0,
    "LOr",              C2, 0, OP_LOR,         "CC",     "UU",     0,
    "Match",            C2, 0, OP_MATCH,       "CKCKCC", "UFUFUU", AF,
    "Multiply",         C2, 0, OP_MULTIPLY,    "CCS",    "UUU",    0,
    "NAnd",             C2, 0, OP_NAND,        "CCS",    "UUU",    0,
    "NOr",              C2, 0, OP_NOR,         "CCS",    "UUU",    0,
    "Not",              C2, 0, OP_NOT,         "CS",     "UU",     0,
    "ObjectType",       C2, 0, OP_OBJTYPE,     "S",      "U",      0,
    "Or",               C2, 0, OP_OR,          "CCS",    "UUU",    0,
    "RefOf",            C2, 0, OP_REFOF,       "S",      "U",      0,
    "ShiftLeft",        C2, 0, OP_SHIFTL,      "CCS",    "UUU",    0,
    "ShiftRight",       C2, 0, OP_SHIFTR,      "CCS",    "UUU",    0,
    "SizeOf",           C2, 0, OP_SIZEOF,      "S",      "U",      0,
    "Store",            C2, 0, OP_STORE,       "CS",     "UU",     0,
    "Subtract",         C2, 0, OP_SUBTRACT,    "CCS",    "UUU",    0,
    "ToBCD",            C2, 0, OP_TOBCD,       "CS",     "UU",     0,
    "Wait",             C2, 0, OP_WAIT,        "SC",     "E",      0,
    "XOr",              C2, 0, OP_XOR,         "CCS",    "UUU",    0,

    NULL,               0,  0, OP_NONE, NULL, NULL, 0
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};

#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\ulist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.c

Abstract:

    List Entry manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

VOID
EXPORT
ListRemoveEntry(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove an Entry from the list

Arguments:

    List        - Entry to be removed
    ListHead    - List to be removed from

Return Value:

    None

--*/
{
    ASSERT(ListHead);

    ASSERT(List != NULL);
    if (List->plistNext == List) {

        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(List == *ListHead);
        *ListHead = NULL;

    } else {

        if (List == *ListHead) {

            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *ListHead = (*ListHead)->plistNext;

        }
        List->plistNext->plistPrev = List->plistPrev;
        List->plistPrev->plistNext = List->plistNext;

    }

}

PLIST
EXPORT
ListRemoveHead(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the head entry of the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    list = *ListHead;
    if ( list != NULL) {

        ListRemoveEntry(list, ListHead);

    }
    return list;

}

PLIST
EXPORT
ListRemoveTail(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the tail entry from the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    if (*ListHead == NULL) {

        list = NULL;

    } else {

        //
        // List is not empty, so find the tail.
        //
        list = (*ListHead)->plistPrev;
        ListRemoveEntry(list, ListHead);

    }
    return list;

}

VOID
EXPORT
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the head of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    ListInsertTail(List, ListHead);
    *ListHead = List;
}

VOID
EXPORT
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the tail of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    if (*ListHead == NULL) {

        //
        // List is empty, so this becomes the head.
        //
        *ListHead = List;
        List->plistPrev = List->plistNext = List;

    } else {

        List->plistNext = *ListHead;
        List->plistPrev = (*ListHead)->plistPrev;
        (*ListHead)->plistPrev->plistNext = List;
        (*ListHead)->plistPrev = List;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\ulist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.h

Abstract:

    List Entry Manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _LIST_H_
#define _LIST_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\unamespac.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.h

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _NAMESPAC_H_
#define _NAMESPAC_H_

    extern PNSOBJ   RootNameSpaceObject;
    extern PNSOBJ   CurrentScopeNameSpaceObject;
    extern PNSOBJ   CurrentOwnerNameSpaceObject;

    NTSTATUS
    CreateNameSpaceObject(
        PUCHAR  ObjectName,
        PNSOBJ  ObjectScope,
        PNSOBJ  ObjectOwner,
        PNSOBJ  *Object,
        ULONG   Flags
        );


    NTSTATUS
    CreateObject(
        PUCHAR  ObjectName,
        UCHAR   ObjectType,
        PNSOBJ  *Object
        );

    NTSTATUS
    GetNameSpaceObject(
        PUCHAR  ObjectPath,
        PNSOBJ  ScopeObject,
        PNSOBJ  *NameObject,
        ULONG   Flags
        );

    PUCHAR
    GetObjectTypeName(
        ULONG   ObjectType
        );

    PUCHAR
    LocalGetObjectPath(
        PNSOBJ  NameObject
        );

    PUCHAR
    RemoteGetObjectPath(
        ULONG_PTR   ObjectAddress
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\uparsearg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.c

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#include "pch.h"

VOID
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    This routine parses program path and module name

Arguments:

    ProgramName - The Argv[0] from main()
    ProgramInfo - Program Information structure

Return Value:

    None

--*/
{
    PUCHAR   ptr;

    ProgramInfo->ProgPath = _strlwr(ProgramName);
    ptr = strrchr( ProgramName, '\\' );
    if (ptr != NULL) {

        *ptr = '\0';
        ProgramInfo->ProgName = ptr + 1;

    } else {

        ProgramInfo->ProgName = ProgramName;

    }

    ptr = strchr(ProgramInfo->ProgName, '.');
    if (ptr != NULL) {

        *ptr = '\0';

    }
}

ULONG
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse command line switches

Arguments:

    ArgumentCount   - Pointer to the number of arguments
    ArgumentList    - Pointer to the pointer to the list of arguments
    ArgumentArray   - How to parse the arguments
    ProgramInfo     - Program Specific structure

Return Value:

    ULONG   - Success = ARGERR_NONE

--*/
{
    PUCHAR  argument;
    ULONG   status = ARGERR_NONE;

    if (ProgramInfo->SwitchChars == NULL) {

        ProgramInfo->SwitchChars = DEF_SWITCHCHARS;

    }
    if (ProgramInfo->Separators == NULL) {

        ProgramInfo->Separators = DEF_SEPARATORS;

    }

    for (; *ArgumentCount; (*ArgumentCount)--, (*ArgumentList)++)
    {
        argument = **ArgumentList;

        if (strchr(ProgramInfo->SwitchChars, *argument)) {

            argument++;
            status = ParseArgSwitch(
                &argument,
                ArgumentArray,
                ProgramInfo
                );
            if (status != ARGERR_NONE) {

                PrintError( status, argument, ProgramInfo );
                break;

            }

        } else {

            break;

        }

    }

    return status;
}

ULONG
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse a command line switch

Arguments

    Argument        - Pointer to argument
    ArgumentArray   - How to handle the argument
    ProgramInfo     - Program Information Structure

Return Value:

    ULONG

--*/
{
    BOOL        found = FALSE;
    PARGTYPE    tableEntry;
    PUCHAR      argumentEnd;
    ULONG       length = 0;
    ULONG       status = ARGERR_NONE;

    tableEntry = ArgumentArray;
    while (tableEntry->ArgID[0]) {

        length = strlen(tableEntry->ArgID);
        if (tableEntry->ParseFlags & PF_NOI) {

            found = (strncmp(tableEntry->ArgID, *Argument, length) == 0);

        } else {

            found = (_strnicmp(tableEntry->ArgID, *Argument, length) == 0);

        }

        if (found) {

            break;
        }
        tableEntry++;

    }

    if (found) {

        *Argument += length;
        switch (tableEntry->ArgType) {
            case AT_STRING:
            case AT_NUM:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }
                if (tableEntry->ArgType == AT_STRING) {

                    *(UCHAR **)tableEntry->ArgData = *Argument;

                } else {

                    *(ULONG *)tableEntry->ArgData = (ULONG)
                        strtoul(*Argument, &argumentEnd, tableEntry->ArgParam);
                    if (*Argument == argumentEnd) {

                        status = ARGERR_INVALID_NUM;
                        break;

                    }
                    *Argument = argumentEnd;

                }
                if (tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);

                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (tableEntry->ArgType == AT_ENABLE) {

                    *(ULONG *)tableEntry->ArgData |= tableEntry->ArgParam;

                } else {

                    *(ULONG *)tableEntry->ArgData &= ~tableEntry->ArgParam;

                }

                if ( tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);
                    if (status == ARGERR_NONE) {

                        break;

                    }

                }

                if (**Argument) {

                    if (strchr(ProgramInfo->SwitchChars, **Argument)) {

                        (*Argument)++;

                    }
                    status = ParseArgSwitch(
                        Argument,
                        ArgumentArray,
                        ProgramInfo
                        );

                }
                break;

            case AT_ACTION:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }

#pragma warning(disable: 4055)
                status = (*(PFNARG)tableEntry->ArgData)(Argument, tableEntry);
#pragma warning(default: 4055)

                break;

        }

    } else {

        status = ARGERR_UNKNOWN_SWITCH;

    }
    return status;
}

VOID
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Print Appropriate Error Message according to error code

Arguments:

    ErrorCode   - The error which occured
    Argument    - Argument in Error
    ProgramInfo - Program info structure

Return Value:

    VOID

--*/
{
    switch (ErrorCode) {
        case ARGERR_UNKNOWN_SWITCH:
            fprintf(
               stderr,
               "%s: unknown switch \"%s\"\n",
               ProgramInfo->ProgName,
               Argument
               );
            break;

        case ARGERR_NO_SEPARATOR:
            fprintf(
                stderr,
                "%s: separator missing after the switch char '%c'\n",
                ProgramInfo->ProgName,
                *(Argument-1)
                );
            break;

        case ARGERR_INVALID_NUM:
            fprintf(
                stderr,
                "%s: invalid numeric switch \"%s\"\n",
                ProgramInfo->ProgName,
                Argument
                );
            break;

        case ARGERR_INVALID_TAIL:
            fprintf(
                 stderr,
                 "%s: invalid argument tail \"%s\"\n",
                 ProgramInfo->ProgName,
                 Argument
                 );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\unamespac.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.c

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

PNSOBJ  RootNameSpaceObject;
PNSOBJ  CurrentScopeNameSpaceObject;
PNSOBJ  CurrentOwnerNameSpaceObject;

NTSTATUS
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine creates a name space object under the current scope

Arguments:

    ObjectName  - Name Path String
    ObjectScope - Scope to start the search from (NULL == Root)
    ObjectOwner - The object which owns this one
    Object      - Where to store the point to the object that we just created
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        3,
        "CreateNameSpaceObject(%s,Scope=%s,Owner=%p,Object=%p,"
        "Flag=%08lx)\n",
        ObjectName,
        (ObjectScope ? LocalGetObjectPath( ObjectScope ) : "ROOT"),
        ObjectOwner,
        Object,
        Flags
        ) );

    if (ObjectScope == NULL) {

        ObjectScope = RootNameSpaceObject;

    }

    status = GetNameSpaceObject(
        ObjectName,
        ObjectScope,
        &localObject,
        NSF_LOCAL_SCOPE
        );
    if (NT_SUCCESS(status)) {

        if (!(Flags & NSF_EXIST_OK)) {

            status = STATUS_OBJECT_NAME_COLLISION;

        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        status = STATUS_SUCCESS;

        //
        // Are we creating root?
        //
        if (strcmp(ObjectName,"\\") == 0) {

            ASSERT( RootNameSpaceObject == NULL );
            ASSERT( ObjectOwner == NULL );

            localObject = MEMALLOC( sizeof(NSOBJ) );
            if (localObject == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                memset( localObject, 0, sizeof(NSOBJ) );
                localObject->dwSig = SIG_NSOBJ;
                localObject->dwNameSeg = NAMESEG_ROOT;
                RootNameSpaceObject = localObject;

            }

        } else {

            PUCHAR  nameEnd;
            PNSOBJ  objectParent;

            nameEnd = strrchr(ObjectName, '.');
            if (nameEnd != NULL) {

                *nameEnd = '\0';
                nameEnd++;

                status = GetNameSpaceObject(
                    ObjectName,
                    ObjectScope,
                    &objectParent,
                    NSF_LOCAL_SCOPE
                    );

            } else if (*ObjectName == '\\') {

                nameEnd = &ObjectName[1];
                ASSERT( RootNameSpaceObject != NULL );
                objectParent = RootNameSpaceObject;

            } else if (*ObjectName == '^') {

                nameEnd = ObjectName;
                objectParent = ObjectScope;
                while ( (*nameEnd == '^') && (objectParent != NULL)) {

                    objectParent = objectParent->pnsParent;
                    nameEnd++;

                }

            } else {

                ASSERT( ObjectScope );
                nameEnd = ObjectName;
                objectParent = ObjectScope;

            }


            if (status == STATUS_SUCCESS) {

                ULONG   length = strlen(nameEnd);

                localObject = MEMALLOC( sizeof(NSOBJ) );

                if (localObject == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else if ( (*nameEnd != '\0') && (length > sizeof(NAMESEG))) {

                    status = STATUS_OBJECT_NAME_INVALID;
                    MEMFREE( localObject );

                } else {

                    memset( localObject, 0, sizeof(NSOBJ) );
                    localObject->dwSig = SIG_NSOBJ;
                    localObject->dwNameSeg = NAMESEG_BLANK;
                    memcpy( &(localObject->dwNameSeg), nameEnd, length );
                    localObject->hOwner = ObjectOwner;
                    localObject->pnsParent = objectParent;

                    ListInsertTail(
                        &(localObject->list),
                        (PPLIST) &(objectParent->pnsFirstChild)
                        );

                }

            }

        }

    }


    if (NT_SUCCESS(status) && Object != NULL) {

        *Object = localObject;

    }

    EXIT( (
        3,
        "CreateNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );

    return status;
}

NTSTATUS
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    )
/*++

Routine Description:

    Creates a NameSpace Object for the term

Arguments:

    ObjectName  - The name object object
    ObjectType  - The type of object to create
    Object      - Where to store a pointer to the created object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        2,
        "CreateObject(%s,Type=%02x,Object=%p)\n",
        ObjectName,
        ObjectType,
        Object
        ) );

    status = CreateNameSpaceObject(
        ObjectName,
        CurrentScopeNameSpaceObject,
        CurrentOwnerNameSpaceObject,
        &localObject,
        NSF_EXIST_OK
        );
    if (NT_SUCCESS(status)) {

        switch (ObjectType) {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                localObject->ObjData.dwDataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                localObject->ObjData.dwDataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                localObject->ObjData.dwDataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                localObject->ObjData.dwDataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                localObject->ObjData.dwDataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                localObject->ObjData.dwDataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                localObject->ObjData.dwDataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                localObject->ObjData.dwDataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                localObject->ObjData.dwDataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                localObject->ObjData.dwDataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                localObject->ObjData.dwDataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        if (Object != NULL) {

            *Object = localObject;

        }


    }


    EXIT( (
        2,
        "CreateObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );
    return status;
}       //CreateObject

NTSTATUS
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine searches the namespace until it finds a matching object

Arguments:

    ObjectPath  - String with the Name to search for
    ScopeObject - Scope to start search at (NULL == ROOT)
    NameObject  - Where to store the object, if found
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      subPath;

    ENTER( (
        3,
        "GetNameSpaceObject(%s,Scope=%s,Object=%p,Flags=%08lx\n",
        ObjectPath,
        (ScopeObject ? LocalGetObjectPath( ScopeObject ) : "ROOT"),
        NameObject,
        Flags
        ) );
    if (ScopeObject == NULL) {

        ScopeObject = RootNameSpaceObject;

    }


    if (*ObjectPath == '\\') {

        subPath = &ObjectPath[1];
        ScopeObject = RootNameSpaceObject;

    } else {

        subPath = ObjectPath;
        while ( (*subPath == '^') && (ScopeObject != NULL)) {

            subPath++;
            ScopeObject = ScopeObject->pnsParent;

        }

    }

    *NameObject = ScopeObject;
    if (ScopeObject == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else if (*subPath != '\0') {

        BOOL    searchUp;
        PNSOBJ  tempObject;

        searchUp = (BOOL) ( !(Flags & NSF_LOCAL_SCOPE) &&
            (ObjectPath[0] != '\\') &&
            (ObjectPath[0] != '^') &&
            (strlen(ObjectPath) <= sizeof(NAMESEG)) );
        while (1) {

            do {

                tempObject = ScopeObject->pnsFirstChild;
                if (tempObject == NULL) {

                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    INFO( (5, "GetNameSpaceObject - %s has no children\n",
                           LocalGetObjectPath( tempObject ) ) );

                } else {

                    BOOL    found;
                    PUCHAR  bufferEnd;
                    ULONG   length;
                    NAMESEG dwNameSeg;

                    bufferEnd = strchr( subPath, '.' );
                    if (bufferEnd != NULL) {

                        length = (ULONG)(bufferEnd - subPath);

                    } else {

                        length = strlen(subPath);

                    }


                    if (length > sizeof(NAMESEG)) {

                        status = STATUS_OBJECT_NAME_INVALID;
                        found = FALSE;

                    } else {

                        dwNameSeg = NAMESEG_BLANK;
                        memcpy( &dwNameSeg, subPath, length );

                        INFO( (5, "GetNameSpaceObject - Looking for %*s\n",
                               length, subPath) );

                        //
                        // search all sibling fors a matching nameSeg
                        //
                        found = FALSE;
                        do {

                            INFO( (5, "GetNameSpaceObject - look at %s\n",
                                   LocalGetObjectPath( tempObject ) ) );
                            if (tempObject->dwNameSeg == dwNameSeg) {

                                ScopeObject = tempObject;
                                found = TRUE;
                                break;

                            }

                            tempObject = (PNSOBJ) tempObject->list.plistNext;

                        } while (tempObject != tempObject->pnsParent->pnsFirstChild );

                    }


                    if (status == STATUS_SUCCESS) {

                        if (!found) {

                            status = STATUS_OBJECT_NAME_NOT_FOUND;

                        } else {

                            subPath += length;
                            if (*subPath == '.') {

                                subPath++;

                            } else if (*subPath == '\0') {

                                *NameObject = ScopeObject;
                                break;

                            }

                        }

                    }

                }

            } while ( status == STATUS_SUCCESS );

            if (status == STATUS_OBJECT_NAME_NOT_FOUND && searchUp &&
                ScopeObject != NULL && ScopeObject->pnsParent != NULL) {

                INFO( (5, "GetNameSpaceObject - Changing Scope to %s\n",
                       LocalGetObjectPath( ScopeObject->pnsParent ) ) );
                ScopeObject = ScopeObject->pnsParent;
                status = STATUS_SUCCESS;

            } else {

                break;

            }

        }

    }


    if (status != STATUS_SUCCESS) {

        *NameObject = NULL;

    }


    EXIT( (
        3,
        "GetNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        *NameObject
        ) );
    return status;

}

PUCHAR
GetObjectTypeName(
    ULONG   ObjectType
    )
/*++

Routine Description:

    Returns a string which corresponds to the type object the object

Arugment:

    ObjectType  - The type that we wish to know about

Return Value:

    Globally Available String

--*/
{
    PUCHAR  type = NULL;
    ULONG   i;
    static struct {
        ULONG   ObjectType;
        PUCHAR  ObjectTypeName;
    } ObjectTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER( (4, "GetObjectTypeName(Type=%02x)\n", ObjectType ) );

    for (i = 0; ObjectTypeTable[i].ObjectTypeName != NULL; i++) {

        if (ObjectType == ObjectTypeTable[i].ObjectType) {

            type = ObjectTypeTable[i].ObjectTypeName;
            break;

        }

    }

    EXIT( (4, "GetObjectTypeName=%s\n", type ? type : "NULL" ) );
    return type;
}

PUCHAR
LocalGetObjectPath(
    PNSOBJ  NameObject
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    ULONG           i;

    ENTER( (6, "LocalGetObjectPath(Object=%p)\n", NameObject ) );

    if (NameObject != NULL) {

        if (NameObject->pnsParent == NULL) {

            strcpy(namePath, "\\");

        } else {

            LocalGetObjectPath(NameObject->pnsParent);
            if (NameObject->pnsParent->pnsParent != NULL) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&NameObject->dwNameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (6, "LocalGetObjectPath=%s\n", namePath ) );
    return namePath;
}

PUCHAR
RemoteGetObjectPath(
    ULONG_PTR   ObjectAddress
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    NSOBJ           nameObject;
    ULONG           i;

    ENTER( (6, "RemoteGetObjectPath(Object=%p)\n", ObjectAddress ) );

    if (ObjectAddress != 0 && ReadMemory( ObjectAddress, &nameObject, sizeof(nameObject), NULL) ) {

        if (nameObject.pnsParent == NULL) {

            strcpy(namePath, "\\");

        } else {

            RemoteGetObjectPath( (ULONG_PTR) nameObject.pnsParent);
            if (strlen(namePath) > 1) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&nameObject.dwNameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (6, "RemoteGetObjectPath=%s\n", namePath ) );
    return namePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\uparsearg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.h

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#ifndef _PARSEARG_H_
#define _PARSEARG_H_

    //
    // Error Codes
    //
    #define ARGERR_NONE             0
    #define ARGERR_UNKNOWN_SWITCH   1
    #define ARGERR_NO_SEPARATOR     2
    #define ARGERR_INVALID_NUM      3
    #define ARGERR_INVALID_TAIL     4

    //
    // Parsing options
    //
    #define DEF_SWITCHCHARS         "/-"
    #define DEF_SEPARATORS          ":="

    //
    // Argument types
    //
    #define AT_STRING       1
    #define AT_NUM          2
    #define AT_ENABLE       3
    #define AT_DISABLE      4
    #define AT_ACTION       5

    //
    // Parse flags
    //
    #define PF_NOI          0x0001  //No-Ignore-Case
    #define PF_SEPARATOR    0x0002  //parse for separator

    //
    // Type definitions
    //
    typedef struct _ARGTYPE ARGTYPE, *PARGTYPE;
    typedef int (*PFNARG)(char **, PARGTYPE);
    struct _ARGTYPE {
        UCHAR       *ArgID;         // argument ID string
        ULONG       ArgType;        // see argument types defined above
        ULONG       ParseFlags;     // see parse flags defined above
        VOID        *ArgData;       // ARG_STRING: (char **) - ptr to string ptr
                                    // ARG_NUM: (int *) - ptr to integer number
                                    // ARG_ENABLE: (unsigned *) - ptr to flags
                                    // ARG_DISABLE: (unsigned *) - ptr to flags
                                    // ARG_ACTION: ptr to function
        ULONG       ArgParam;       // ARG_STRING: none
                                    // ARG_NUM: base
                                    // ARG_ENABLE: flag bit mask
                                    // ARG_DISABLE: flag bit mask
                                    // ARG_ACTION: none
        PFNARG      ArgVerify;      // pointer to argument verification function
                                    // this will be ignored for ARG_ACTION
    };

    typedef struct _PROGINFO {
        UCHAR *SwitchChars;         // if null, DEF_SWITCHCHARS is used
        UCHAR *Separators;          // if null, DEF_SEPARATORS is used
        UCHAR *ProgPath;            // ParseProgInfo set this ptr to prog. path
        UCHAR *ProgName;            // ParseProgInfo set this ptr to prog. name
    } PROGINFO;
    typedef PROGINFO *PPROGINFO;

    ULONG
    ParseArgSwitch(
        PUCHAR      *Argument,
        PARGTYPE    ArgumentArray,
        PPROGINFO   ProgramInfo
        );

    VOID
    ParseProgramInfo(
        PUCHAR      ProgramName,
        PPROGINFO   ProgramInfo
        );

    ULONG
    ParseSwitches(
        PULONG      ArgumentCount,
        PUCHAR      **ArgumentList,
        PARGTYPE    ArgumentArray,
        PPROGINFO   ProgramInfo
        );

    VOID
    PrintError(
        ULONG       ErrorCode,
        PUCHAR      Argument,
        PPROGINFO   ProgramInfo
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\unasm.c ===
/*** unasm.c - Unassemble AML back to ASL
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created:    10/01/97
 *
 *  MODIFICATION HISTORY
 */

#include "pch.h"

//Local function prototype
VOID LOCAL Indent(PUCHAR pbOp, int iLevel);
UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable);
PASLTERM LOCAL FindOpTerm(ULONG dwOpcode);
PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData);
LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp);
LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ pns, char c);
LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen);
LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp);
LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ pns);
LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp);
LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd);
LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos);

/***LP  UnAsmScope - Unassemble a scope
 *
 *  ENTRY
 *      ppbOp -> Current Opcode pointer
 *      pbEnd -> end of scope
 *      uipbOp - Op address
 *      pnsScope - Scope object
 *      iLevel - level of indentation
 *      icLines - 1: unasm one line; 0: unasm all; -1: internal
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, ULONG_PTR uipbOp,
                      PNSOBJ pnsScope, int iLevel, int icLines)
{
    LONG rc = UNASMERR_NONE;
    int icLinesLeft = icLines;

    if (uipbOp != 0)
    {
        guipbOpXlate = uipbOp - (ULONG_PTR)(*ppbOp);
    }

    if (pnsScope != NULL)
    {
        gpnsCurUnAsmScope = pnsScope;
    }

    if (iLevel != -1)
    {
        giLevel = iLevel;
    }

    if (icLines < 0)
    {
        Indent(*ppbOp, giLevel);
        PRINTF("{");
        giLevel++;
    }
    else if (icLines == 0)
    {
        icLinesLeft = -1;
    }

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((rc = UnAsmOpcode(ppbOp)) == UNASMERR_NONE)
        {
            if (icLinesLeft < 0)
            {
                continue;
            }

            if (--icLinesLeft == 0)
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    if ((rc == UNASMERR_NONE) && (icLines < 0))
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmScope

/***LP  Indent - Print indent level
 *
 *  ENTRY
 *      pbOp -> opcode
 *      iLevel - indent level
 *
 *  EXIT
 *      None
 */

VOID LOCAL Indent(PUCHAR pbOp, int iLevel)
{
    int i;

    PRINTF("\n%08x: ", pbOp + guipbOpXlate);
    for (i = 0; i < iLevel; ++i)
    {
        PRINTF("| ");
    }
}       //Indent

/***LP  FindOpClass - Find opcode class of extended opcode
 *
 *  ENTRY
 *      bOp - opcode
 *      pOpTable -> opcode table
 *
 *  EXIT-SUCCESS
 *      returns opcode class
 *  EXIT-FAILURE
 *      returns OPCLASS_INVALID
 */

UCHAR LOCAL FindOpClass(UCHAR bOp, POPMAP pOpTable)
{
    UCHAR bOpClass = OPCLASS_INVALID;

    while (pOpTable->bOpClass != 0)
    {
        if (bOp == pOpTable->bExOp)
        {
            bOpClass = pOpTable->bOpClass;
            break;
        }
        else
        {
            pOpTable++;
        }
    }

    return bOpClass;
}       //FindOpClass

/***LP  FindOpTerm - Find opcode in TermTable
 *
 *  ENTRY
 *      dwOpcode - opcode
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindOpTerm(ULONG dwOpcode)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwOpcode == dwOpcode) &&
            (TermTable[i].dwfTermClass &
             (UTC_CONST_NAME | UTC_SHORT_NAME | UTC_NAMESPACE_MODIFIER |
              UTC_DATA_OBJECT | UTC_NAMED_OBJECT | UTC_OPCODE_TYPE1 |
              UTC_OPCODE_TYPE2)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindOpTerm

/***LP  FindKeywordTerm - Find keyword in TermTable
 *
 *  ENTRY
 *      cKWGroup - keyword group
 *      bData - data to match keyword
 *
 *  EXIT-SUCCESS
 *      returns TermTable entry pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PASLTERM LOCAL FindKeywordTerm(char cKWGroup, UCHAR bData)
{
    PASLTERM pterm = NULL;
    int i;

    for (i = 0; TermTable[i].pszID != NULL; ++i)
    {
        if ((TermTable[i].dwfTermClass == UTC_KEYWORD) &&
            (TermTable[i].pszArgActions[0] == cKWGroup) &&
            ((bData & (UCHAR)(TermTable[i].dwTermData >> 8)) ==
             (UCHAR)(TermTable[i].dwTermData & 0xff)))
        {
            break;
        }
    }

    if (TermTable[i].pszID != NULL)
    {
        pterm = &TermTable[i];
    }

    return pterm;
}       //FindKeywordTerm

/***LP  UnAsmOpcode - Unassemble an Opcode
 *
 *  ENTRY
 *      ppbOp -> Opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmOpcode(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwOpcode;
    UCHAR bOp;
    PASLTERM pterm;
    char szUnAsmArgTypes[MAX_ARGS + 1];
    int i;

    if (**ppbOp == OP_EXT_PREFIX)
    {
        (*ppbOp)++;
        dwOpcode = (((ULONG)**ppbOp) << 8) | OP_EXT_PREFIX;
        bOp = FindOpClass(**ppbOp, ExOpClassTable);
    }
    else
    {
        dwOpcode = (ULONG)(**ppbOp);
        bOp = OpClassTable[**ppbOp];
    }

    switch (bOp)
    {
        case OPCLASS_DATA_OBJ:
            rc = UnAsmDataObj(ppbOp);
            break;

        case OPCLASS_NAME_OBJ:
        {
            NSOBJ NSObj = {0};

            if (((rc = UnAsmNameObj(ppbOp, &NSObj, NSTYPE_UNKNOWN)) ==
                 UNASMERR_NONE) &&
                (NSObj.ObjData.dwDataType == OBJTYPE_METHOD))
            {
                PMETHODOBJ pm = (PMETHODOBJ)GetObjBuff(&NSObj.ObjData);
                int iNumArgs;

                if (pm != NULL)
                {
                    iNumArgs = pm->bMethodFlags & METHOD_NUMARG_MASK;

                    for (i = 0; i < iNumArgs; ++i)
                    {
                        szUnAsmArgTypes[i] = 'C';
                    }
                    szUnAsmArgTypes[i] = '\0';
                    rc = UnAsmArgs(szUnAsmArgTypes, NULL, ppbOp, NULL);
                    LocalFree(pm);
                }
            }
            break;
        }
        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:
            if ((pterm = FindOpTerm(dwOpcode)) == NULL)
            {
                DBG_ERROR(("UnAsmOpcode: invalid opcode 0x%x", dwOpcode));
                rc = UNASMERR_FATAL;
            }
            else
            {
                (*ppbOp)++;
                rc = UnAsmTermObj(pterm, ppbOp);
            }
            break;

        default:
            DBG_ERROR(("UnAsmOpcode: invalid opcode class %d", bOp));
            rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmOpcode

/***LP  UnAsmDataObj - Unassemble data object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataObj(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    UCHAR bOp = **ppbOp;
    PSZ psz;

    (*ppbOp)++;
    switch (bOp)
    {
        case OP_BYTE:
            PRINTF("0x%x", **ppbOp);
            *ppbOp += sizeof(UCHAR);
            break;

        case OP_WORD:
            PRINTF("0x%x", *((PUSHORT)*ppbOp));
            *ppbOp += sizeof(USHORT);
            break;

        case OP_DWORD:
            PRINTF("0x%x", *((PULONG)*ppbOp));
            *ppbOp += sizeof(ULONG);
            break;

        case OP_STRING:
            PRINTF("\"");
            for (psz = (PSZ)*ppbOp; *psz != '\0'; psz++)
            {
                if (*psz == '\\')
                {
                    PRINTF("\\");
                }
                PRINTF("%c", *psz);
            }
            PRINTF("\"");
            *ppbOp += STRLEN((PSZ)*ppbOp) + 1;
            break;

        default:
            DBG_ERROR(("UnAsmDataObj: unexpected opcode 0x%x", bOp));
            rc = UNASMERR_INVALID_OPCODE;
    }

    return rc;
}       //UnAsmDataObj

/***LP  UnAsmNameObj - Unassemble name object
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pns -> to hold object found or created
 *      c - object type
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameObj(PUCHAR *ppbOp, PNSOBJ pns, char c)
{
    LONG rc = UNASMERR_NONE;
    char szName[MAX_NAME_LEN + 1];
    int iLen = 0;

    szName[0] = '\0';
    if (**ppbOp == OP_ROOT_PREFIX)
    {
        szName[iLen] = '\\';
        iLen++;
        (*ppbOp)++;
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }
    else if (**ppbOp == OP_PARENT_PREFIX)
    {
        szName[iLen] = '^';
        iLen++;
        (*ppbOp)++;
        while ((**ppbOp == OP_PARENT_PREFIX) && (iLen < MAX_NAME_LEN))
        {
            szName[iLen] = '^';
            iLen++;
            (*ppbOp)++;
        }

        if (**ppbOp == OP_PARENT_PREFIX)
        {
            DBG_ERROR(("UnAsmNameObj: name too long - \"%s\"", szName));
            rc = UNASMERR_FATAL;
        }
        else
        {
            rc = UnAsmNameTail(ppbOp, szName, iLen);
        }
    }
    else
    {
        rc = UnAsmNameTail(ppbOp, szName, iLen);
    }

    if (rc == UNASMERR_NONE)
    {
        ULONG_PTR uipns = 0;
        NSOBJ NSObj;

        PRINTF("%s", szName);

        rc = GetNSObj(szName, gpnsCurUnAsmScope, &uipns, &NSObj, 0);

        if (rc == UNASMERR_NONE)
        {
            if (pns != NULL)
            {
                MEMCPY(pns, &NSObj, sizeof(NSObj));
            }

            if ((c == NSTYPE_SCOPE) && (uipns != 0))
            {
                gpnsCurUnAsmScope = pns;
            }
        }
        else
        {
            rc = UNASMERR_NONE;
        }
    }

    return rc;
}       //UnAsmNameObj

/***LP  UnAsmNameTail - Parse AML name tail
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pszBuff -> to hold parsed name
 *      iLen - index to tail of pszBuff
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmNameTail(PUCHAR *ppbOp, PSZ pszBuff, int iLen)
{
    LONG rc = UNASMERR_NONE;
    int icNameSegs = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**ppbOp == '\0')
    {
        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_MULTI_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = (int)**ppbOp;
        (*ppbOp)++;
    }
    else if (**ppbOp == OP_DUAL_NAME_PREFIX)
    {
        (*ppbOp)++;
        icNameSegs = 2;
    }
    else
        icNameSegs = 1;

    while ((icNameSegs > 0) && (iLen + sizeof(NAMESEG) < MAX_NAME_LEN))
    {
        STRCPYN(&pszBuff[iLen], (PSZ)(*ppbOp), sizeof(NAMESEG));
        iLen += sizeof(NAMESEG);
        *ppbOp += sizeof(NAMESEG);
        icNameSegs--;
        if ((icNameSegs > 0) && (iLen + 1 < MAX_NAME_LEN))
        {
            pszBuff[iLen] = '.';
            iLen++;
        }
    }

    if (icNameSegs > 0)
    {
        DBG_ERROR(("UnAsmNameTail: name too long - %s", pszBuff));
        rc = UNASMERR_FATAL;
    }
    else
    {
        pszBuff[iLen] = '\0';
    }

    return rc;
}       //UnAsmNameTail

/***LP  UnAsmTermObj - Unassemble term object
 *
 *  ENTRY
 *      pterm -> term table entry
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmTermObj(PASLTERM pterm, PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;
    PUCHAR pbEnd = NULL;
    PNSOBJ pnsScopeSave = gpnsCurUnAsmScope;
    NSOBJ NSObj = {0};

    PRINTF("%s", pterm->pszID);

    if (pterm->dwfTerm & TF_PACKAGE_LEN)
    {
        ParsePackageLen(ppbOp, &pbEnd);
    }

    if (pterm->pszUnAsmArgTypes != NULL)
    {
        rc = UnAsmArgs(pterm->pszUnAsmArgTypes, pterm->pszArgActions, ppbOp,
                       &NSObj);
    }

    if (rc == UNASMERR_NONE)
    {
        if (pterm->dwfTerm & TF_DATA_LIST)
        {
            rc = UnAsmDataList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LIST)
        {
            rc = UnAsmPkgList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_FIELD_LIST)
        {
            rc = UnAsmFieldList(ppbOp, pbEnd);
        }
        else if (pterm->dwfTerm & TF_PACKAGE_LEN)
        {
            if ((pterm->dwfTerm & TF_CHANGE_CHILDSCOPE) &&
                (NSObj.ObjData.dwDataType != 0))
            {
                gpnsCurUnAsmScope = &NSObj;
            }

            rc = UnAsmScope(ppbOp, pbEnd, 0, NULL, -1, -1);
        }
    }
    gpnsCurUnAsmScope = pnsScopeSave;

    return rc;
}       //UnAsmTermObj

/***LP  UnAsmArgs - Unassemble arguments
 *
 *  ENTRY
 *      pszUnArgTypes -> UnAsm ArgTypes string
 *      pszArgActions -> Arg Action types
 *      ppbOp -> opcode pointer
 *      pns -> to hold created object
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmArgs(PSZ pszUnAsmArgTypes, PSZ pszArgActions, PUCHAR *ppbOp,
                     PNSOBJ pns)
{
    LONG rc = UNASMERR_NONE;
    static UCHAR bArgData = 0;
    int iNumArgs, i;
    PASLTERM pterm;

    iNumArgs = STRLEN(pszUnAsmArgTypes);
    PRINTF("(");

    for (i = 0; i < iNumArgs; ++i)
    {
        if (i != 0)
        {
            PRINTF(", ");
        }

        switch (pszUnAsmArgTypes[i])
        {
            case 'N':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmNameObj(ppbOp, pns, pszArgActions[i]);
                break;

            case 'O':
                if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
                    (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
                {
                    pterm = FindOpTerm((ULONG)(**ppbOp));
                    ASSERT(pterm != NULL);
                    (*ppbOp)++;
                    rc = UnAsmTermObj(pterm, ppbOp);
                }
                else
                {
                    rc = UnAsmDataObj(ppbOp);
                }
                break;

            case 'C':
                rc = UnAsmOpcode(ppbOp);
                break;

            case 'B':
                PRINTF("0x%x", **ppbOp);
                *ppbOp += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':
                if (pszUnAsmArgTypes[i] == 'K')
                {
                    bArgData = **ppbOp;
                }

                if ((pszArgActions != NULL) && (pszArgActions[i] == '!'))
                {
                    PRINTF("0x%x", **ppbOp & 0x07);
                }
                else
                {
                    pterm = FindKeywordTerm(pszArgActions[i], bArgData);
                    ASSERT(pterm != NULL);
                    PRINTF("%s", pterm->pszID);
                }

                if (pszUnAsmArgTypes[i] == 'K')
                {
                    *ppbOp += sizeof(UCHAR);
                }
                break;

            case 'W':
                PRINTF("0x%x", *((PUSHORT)*ppbOp));
                *ppbOp += sizeof(USHORT);
                break;

            case 'D':
                PRINTF("0x%x", *((PULONG)*ppbOp));
                *ppbOp += sizeof(ULONG);
                break;

            case 'S':
                ASSERT(pszArgActions != NULL);
                rc = UnAsmSuperName(ppbOp);
                break;

            default:
                DBG_ERROR(("UnAsmOpcode: invalid ArgType '%c'",
                           pszUnAsmArgTypes[i]));
                rc = UNASMERR_FATAL;
        }
    }

    PRINTF(")");

    return rc;
}       //UnAsmArgs

/***LP  UnAsmSuperName - Unassemble supername
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmSuperName(PUCHAR *ppbOp)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0)
    {
        (*ppbOp)++;
    }
    else if ((**ppbOp == OP_EXT_PREFIX) && (*(*ppbOp + 1) == EXOP_DEBUG))
    {
        PRINTF("Debug");
        *ppbOp += 2;
    }
    else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
    {
        rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
    }
    else if ((**ppbOp == OP_INDEX) ||
             (OpClassTable[**ppbOp] == OPCLASS_ARG_OBJ) ||
             (OpClassTable[**ppbOp] == OPCLASS_LOCAL_OBJ))
    {
        rc = UnAsmOpcode(ppbOp);
    }
    else
    {
        DBG_ERROR(("UnAsmSuperName: invalid SuperName - 0x%02x", **ppbOp));
        rc = UNASMERR_FATAL;
    }

    return rc;
}       //UnAsmSuperName

/***LP  UnAsmDataList - Unassemble data list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmDataList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    int i;

    Indent(*ppbOp, giLevel);
    PRINTF("{");

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, 0);
        PRINTF("0x%02x", **ppbOp);

        (*ppbOp)++;
        for (i = 1; (*ppbOp < pbEnd) && (i < 8); ++i)
        {
            PRINTF(", 0x%02x", **ppbOp);
            (*ppbOp)++;
        }

        if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    Indent(*ppbOp, giLevel);
    PRINTF("}");

    return rc;
}       //UnAsmDataList

/***LP  UnAsmPkgList - Unassemble package list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmPkgList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    PASLTERM pterm;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);

        if ((**ppbOp == OP_BUFFER) || (**ppbOp == OP_PACKAGE) ||
            (OpClassTable[**ppbOp] == OPCLASS_CONST_OBJ))
        {
            pterm = FindOpTerm((ULONG)(**ppbOp));
            ASSERT(pterm != NULL);
            (*ppbOp)++;
            rc = UnAsmTermObj(pterm, ppbOp);
        }
        else if (OpClassTable[**ppbOp] == OPCLASS_NAME_OBJ)
        {
            rc = UnAsmNameObj(ppbOp, NULL, NSTYPE_UNKNOWN);
        }
        else
        {
            rc = UnAsmDataObj(ppbOp);
        }

        if (rc != UNASMERR_NONE)
        {
            break;
        }
        else if (*ppbOp < pbEnd)
        {
            PRINTF(",");
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmPkgList

/***LP  UnAsmFieldList - Unassemble field list
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pbEnd -> end of list
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmFieldList(PUCHAR *ppbOp, PUCHAR pbEnd)
{
    LONG rc = UNASMERR_NONE;
    ULONG dwBitPos = 0;

    Indent(*ppbOp, giLevel);
    PRINTF("{");
    giLevel++;

    while (*ppbOp < pbEnd)
    {
        Indent(*ppbOp, giLevel);
        if ((rc = UnAsmField(ppbOp, &dwBitPos)) == UNASMERR_NONE)
        {
            if (*ppbOp < pbEnd)
            {
                PRINTF(",");
            }
        }
        else
        {
            break;
        }
    }

    if (rc == UNASMERR_NONE)
    {
        giLevel--;
        Indent(*ppbOp, giLevel);
        PRINTF("}");
    }

    return rc;
}       //UnAsmFieldList

/***LP  UnAsmField - Unassemble field
 *
 *  ENTRY
 *      ppbOp -> opcode pointer
 *      pdwBitPos -> to hold cumulative bit position
 *
 *  EXIT-SUCCESS
 *      returns UNASMERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

LONG LOCAL UnAsmField(PUCHAR *ppbOp, PULONG pdwBitPos)
{
    LONG rc = UNASMERR_NONE;

    if (**ppbOp == 0x01)
    {
        PASLTERM pterm = NULL;

        (*ppbOp)++;
        pterm = FindKeywordTerm('A', **ppbOp);
        if (pterm != NULL) {

            PRINTF("AccessAs(%s, 0x%x)", pterm->pszID, *(*ppbOp + 1));

        }
        *ppbOp += 2;
    }
    else
    {
        char szNameSeg[sizeof(NAMESEG) + 1];
        ULONG dwcbBits;

        if (**ppbOp == 0)
        {
            szNameSeg[0] = '\0';
            (*ppbOp)++;
        }
        else
        {
            STRCPYN(szNameSeg, (PSZ)*ppbOp, sizeof(NAMESEG));
            szNameSeg[4] = '\0';
            *ppbOp += sizeof(NAMESEG);
        }

        dwcbBits = ParsePackageLen(ppbOp, NULL);
        if (szNameSeg[0] == '\0')
        {
            if ((dwcbBits > 32) && (((*pdwBitPos + dwcbBits) % 8) == 0))
            {
                PRINTF("Offset(0x%x)", (*pdwBitPos + dwcbBits)/8);
            }
            else
            {
                PRINTF(", %d", dwcbBits);
            }
        }
        else
        {
            PRINTF("%s, %d", szNameSeg, dwcbBits);
        }

        *pdwBitPos += dwcbBits;
    }

    return rc;
}       //UnAsmField
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\kdext\unasm.h ===
/*** unasm.h - Unassembler Private Definitions
 *
 *  Copyright (c) 1996,1998 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     03/24/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _UNASM_H
#define _UNASM_H

#ifdef DEBUGGER

/*** Constants
 */

// Implementation constants
#define MAX_ARGS                7

// Error codes
#define UNASMERR_NONE           0
#define UNASMERR_FATAL          -1
#define UNASMERR_INVALID_OPCODE -2
#define UNASMERR_ABORT          -3

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

// Term classes
#define UTC_PNP_MACRO           0x00100000
#define UTC_REF_OBJECT          0x00200000
#define UTC_FIELD_MACRO         0x00400000
#define UTC_DATA_OBJECT         0x00800000
#define UTC_NAMED_OBJECT        0x01000000
#define UTC_NAMESPACE_MODIFIER  0x02000000
#define UTC_OPCODE_TYPE1        0x04000000
#define UTC_OPCODE_TYPE2        0x08000000
#define UTC_CONST_NAME          0x10000000
#define UTC_SHORT_NAME          0x20000000
#define UTC_COMPILER_DIRECTIVE  0x40000000
#define UTC_KEYWORD             0x80000000
#define UTC_OPCODE              (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2 |  \
                                 UTC_SHORT_NAME | UTC_CONST_NAME |      \
                                 UTC_DATA_OBJECT)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHANGE_CHILDSCOPE    0x00000008
#define TF_FIELD_MACRO          UTC_FIELD_MACRO
#define TF_DATA_OBJECT          UTC_DATA_OBJECT
#define TF_NAMED_OBJECT         UTC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   UTC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         UTC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         UTC_OPCODE_TYPE2
#define TF_CONST_NAME           UTC_CONST_NAME
#define TF_SHORT_NAME           UTC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   UTC_COMPILER_DIRECTIVE
#define TF_KEYWORD              UTC_KEYWORD
#define TF_PNP_MACRO            UTC_PNP_MACRO
#define TF_OBJECT_LIST          (UTC_NAMED_OBJECT | UTC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (UTC_OPCODE_TYPE1 | UTC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (UTC_DATA_OBJECT | UTC_SHORT_NAME | \
                                 UTC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

/*** Type definitions
 */

typedef ULONG NAMESEG;
typedef int (LOCAL *PFNTERM)(PTOKEN, BOOL);

typedef struct _aslterm
{
    PSZ     pszID;
    ULONG   dwfTermClass;
    ULONG   dwTermData;
    ULONG   dwOpcode;
    PSZ     pszUnAsmArgTypes;
    PSZ     pszArgActions;
    ULONG   dwfTerm;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   bExOp;
    UCHAR   bOpClass;
} OPMAP, *POPMAP;

// Data prototype
extern int giLevel;
extern ULONG_PTR guipbOpXlate;
extern PNSOBJ gpnsCurUnAsmScope;
extern ASLTERM TermTable[];
extern UCHAR OpClassTable[256];
extern OPMAP ExOpClassTable[];

// Exported functions
LONG LOCAL UnAsmScope(PUCHAR *ppbOp, PUCHAR pbEnd, ULONG_PTR uipbOp,
                      PNSOBJ pnsScope, int iLevel, int icLines);

#endif  //ifdef DEBUGGER

#endif  //ifndef _UNASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\ntsdext\acpintsd.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <heap.h>
#include <atom.h>
#include <stktrace.h>
#include <winsock2.h>

#include <ntcsrsrv.h>
#include "unasm.h"

#define move(dst, src)\
try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\ntsdext\acpintsd.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    acpintsd.c

Abstract:

    ACPI-Specific NTSD Extensions

Environment:

    Win32

Revision History:

--*/

#include "acpintsd.h"

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

PUCHAR  ScTableName[] = {
    "ParseFunctionHandler",
    "ParseArgument",
    "ParseArgumentObject",
    "ParseBuffer",
    "ParseByte",
    "ParseCodeObject",
    "ParseConstObject",
    "ParseData",
    "ParseDelimiter",
    "ParseDword",
    "ParseField",
    "ParseLocalObject",
    "ParseName",
    "ParseNameObject",
    "ParseOpcode",
    "ParsePackage",
    "ParsePop",
    "ParsePush",
    "ParseSuperName",
    "ParseTrailingArgument",
    "ParseTrailingBuffer",
    "ParseTrailingPackage",
    "ParseVariableObject",
    "ParseWord"
};

VOID
dumpParseStack(
    DWORD   AddrStack
    )
/*++

Routine Description:

    This dumps the parse stack

Arguments:

    AddrStack: Address of the stack to dump

Return Value:

    None

--*/
{
    BOOL            b;
    STRING_STACK    tempStack;
    PSTRING_STACK   stack;
    ULONG           index;

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        &tempStack,
        sizeof(STRING_STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTRING_STACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STRING_STACK) + tempStack.StackSize - 1
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        stack,
        sizeof(STRING_STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dprintf(
        "ParseStack: Size 0x%x Top: 0x%x\n",
        tempStack.StackSize,
        tempStack.TopOfStack
        );
    if (tempStack.TopOfStack == 0) {

        dprintf("Stack is empty\n");
        return;

    }

    //
    // Walk the stack
    //
    for (index = tempStack.TopOfStack - 1; ; index--) {

        dprintf("[%2d] %s\n", index, ScTableName[ stack->Stack[index] ] );
        if (index == 0) {

            break;

        }

    }

    //
    // Free the stack
    //
    LocalFree( stack );

}

VOID
dumpStringStack(
    DWORD   AddrStack
    )
/*++

Routine Description:

    This dumps the parse stack

Arguments:

    AddrStack: Address of the stack to dump

Return Value:

    None

--*/
{
    BOOL            b;
    STRING_STACK    tempStack;
    PSTRING_STACK   stack;
    ULONG           index;

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        &tempStack,
        sizeof(STRING_STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTRING_STACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STRING_STACK) + tempStack.StackSize
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) AddrStack,
        stack,
        sizeof(STRING_STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dprintf(
        "StringStack: Size 0x%x Top: 0x%x\nString: '%s'\n",
        tempStack.StackSize,
        tempStack.TopOfStack,
        stack->Stack
        );

    //
    // Free the stack
    //
    LocalFree( stack );

}

VOID
dumpScope(
    PSCOPE  Scope
    )
/*++

Routine Description:

    Dumps a scope, as used in the ACPI unasm.lib

Arguments:

    Scope - LocalCopy of the scope

Return Value:

    None

--*/
{
    BOOL    b;
    AMLTERM amlTerm;
    UCHAR   buffer[64];

    dprintf("%8x %8x %8x %8x %2x %2x %2x %1d %8x",
        Scope->CurrentByte,
        Scope->TermByte,
        Scope->LastByte,
        Scope->StringStack,
        Scope->Context1,
        Scope->Context2,
        Scope->Flags,
        Scope->IndentLevel,
        Scope->AmlTerm
        );

    b = ReadMemory(
        Scope->AmlTerm,
        &amlTerm,
        sizeof(AMLTERM),
        NULL
        );
    if (!b) {

        dprintf("\n");
        return;

    } else {

        dprintf(" %4x %4x\n",
            amlTerm.OpCode,
            amlTerm.OpCodeFlags
            );

        b = ReadMemory(
            amlTerm.TermName,
            buffer,
            64,
            NULL
            );
        if (b) {

            dprintf("  %-60s\n", buffer );

        }

    }

}

VOID
dumpScopeHeader(
    BOOL    Verbose
    )
/*++

Routine Description:

    Dumps the header for a scope stack dump

Arguments:

    Verbose: wether or not to include the field for stack level

Return Value:

    None

--*/
{
    if (Verbose) {

        dprintf("Level ");

    }

    dprintf(" Current    First     Last  S.Stack C1 C2 Fl I AML Term OpCd Flag\n" );

}

DECLARE_API( sscope )
/*++

Routine Description:

    Dumps one of the stacks used by the ACPI Unassembler

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None

--*/
{
    BOOL    b;
    DWORD   addrStack;
    DWORD   i;
    DWORD   offset;
    DWORD   top;
    STACK   tempStack;
    PSTACK  stack;
    PSCOPE  scope;

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // stack to dump
    //
    addrStack = GetExpression( lpArgumentString );
    if ( !addrStack) {

        return;

    }

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) addrStack,
        &tempStack,
        sizeof(STACK),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Allocate memory for the entire stack
    //
    stack = (PSTACK) LocalAlloc(
        LMEM_ZEROINIT,
        sizeof(STACK) + tempStack.StackSize - 1
        );
    if (!stack) {

        return;

    }

    //
    // Read the entire stack
    //
    b = ReadMemory(
        (LPVOID) addrStack,
        stack,
        sizeof(STACK) + tempStack.StackSize - 1,
        NULL
        );
    if (!b) {

        LocalFree( stack );
        return;

    }

    //
    // Show the user something
    //
    dumpScopeHeader( TRUE );

    //
    // Loop on each of the scopes
    //
    for (top = (stack->TopOfStack / stack->StackElementSize) - 1;;top--) {

        scope = (PSCOPE) &(stack->Stack[ top * stack->StackElementSize ] );
        dprintf("[%2d]: ", top );
        dumpScope(scope);

        if (top == 0) {

            dumpParseStack( (DWORD) scope->ParseStack );
            dumpStringStack( (DWORD) scope->StringStack );
            break;

        }

    }

    //
    // Done
    //
    LocalFree( stack );
}

DECLARE_API( amlterm )
{
    BOOL    b;
    DWORD   addrTerm;
    DWORD   offset;
    AMLTERM amlTerm;
    UCHAR   nameBuff[17];
    UCHAR   symbolBuff[128];

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // term to dump
    //
    addrTerm = GetExpression( lpArgumentString );
    if ( !addrTerm ) {

        return;

    }

    //
    // Read the term into memory
    //
    b = ReadMemory(
        (LPVOID) addrTerm,
        &amlTerm,
        sizeof(AMLTERM),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Begin to print things
    //
    dprintf("AMLTERM: %x\n", addrTerm);

    //
    // Read the name of the term into memory
    //
    nameBuff[16] = '\0';
    b = ReadMemory(
        (LPVOID) amlTerm.TermName,
        nameBuff,
        16,
        NULL
        );
    dprintf("Name: %-16s  ",( !b  ? "<Cannot Read Name>" : nameBuff) );

    //
    // Handle the symbol term
    //
    if (amlTerm.FunctionHandler != NULL) {

        //
        // Read the symbol of the term
        //
        GetSymbol( (LPVOID) amlTerm.FunctionHandler, symbolBuff, &offset );
        dprintf("    Handler: %-30s\n", symbolBuff );

    } else {

        dprintf("\n");

    }

    //
    // Display the opcode
    //
    if ( amlTerm.OpCode > 0xFF) {

        dprintf(
            "Opcode: %2x %2x",
            (amlTerm.OpCode & 0xff),
            (amlTerm.OpCode >> 8)
            );

    } else {

        dprintf("Opcode: %2x   ", amlTerm.OpCode );

    }

    //
    // Display the Argument Types
    //
    RtlZeroMemory( nameBuff, 17 );
    if (amlTerm.ArgumentTypes) {

        b = ReadMemory(
            (LPVOID) amlTerm.ArgumentTypes,
            nameBuff,
            16,
            NULL
            );
        dprintf("   Args: %-4s", (!b ? "????" : nameBuff ) );

    } else {

        dprintf("   Args: %-4s", "None");

    }

    //
    // Display the flags
    //
    switch( (amlTerm.OpCodeFlags & 0xF) ) {
        case 0: dprintf("  Flags:   NORMAL  "); break;
        case 1: dprintf("  Flags:   VARIABLE"); break;
        case 2: dprintf("  Flags:   ARG     "); break;
        case 3: dprintf("  Flags:   LOCAL   "); break;
        case 4: dprintf("  Flags:   CONSTANT"); break;
        case 5: dprintf("  Flags:   NAME    "); break;
        case 6: dprintf("  Flags:   DATA    "); break;
        case 7: dprintf("  Flags:   DEBUG   "); break;
        case 8: dprintf("  Flags:   REF     "); break;
        default: dprintf("  Flags:   UNKNOWN "); break;
    }

    //
    // Display the term group
    //
    switch(amlTerm.TermGroup & 0xF) {
        case 1: dprintf("  Group: NAMESPACE\n"); break;
        case 2: dprintf("  Group: NAMED OBJECT\n"); break;
        case 3: dprintf("  Group: TYPE 1\n"); break;
        case 4: dprintf("  Group: TYPE 2\n"); break;
        case 5: dprintf("  Group: OTHER\n"); break;
        default: dprintf("  Group: UNKNOWN\n"); break;

    }

}

DECLARE_API( scope )
{

    BOOL    b;
    DWORD   addrScope;
    SCOPE   scope;

    INIT_API();

    //
    // Evaluate the argument string to get the address of the
    // stack to dump
    //
    addrScope = GetExpression( lpArgumentString );
    if ( !addrScope) {

        return;

    }

    //
    // Read the stack header into memory
    //
    b = ReadMemory(
        (LPVOID) addrScope,
        &scope,
        sizeof(scope),
        NULL
        );
    if (!b) {

        return;

    }

    //
    // Dump the string to the user
    //
    dumpScopeHeader(FALSE);
    dumpScope( &scope );
}

DECLARE_API( pstack )
{
    DWORD   addrStack;

    INIT_API();

    addrStack = GetExpression( lpArgumentString );
    if (!addrStack) {

        return;

    }

    dumpParseStack( addrStack );
}

DECLARE_API( sstack )
{
    DWORD   addrStack;

    INIT_API();

    addrStack = GetExpression( lpArgumentString );
    if (!addrStack) {

        return;

    }

    dumpStringStack( addrStack );
}

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {

        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;

    }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hkey
            ) == NO_ERROR
       ) {

        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(
                hkey,
                "CurrentType",
                NULL,
                &dwType,
                szCurrentType,
                &cb ) != 0
            ) {

            szCurrentType[0] = '\0';

        }

    }
    RegCloseKey(hkey);

    if (VersionInformation.szCSDVersion[0]) {

        sprintf(
            szCSDString,
            ": %s",
            VersionInformation.szCSDVersion
            );

    } else {

        szCSDString[0] = '\0';

    }

    dprintf(
        "Version %d.%d (Build %d%s) %s\n",
        VersionInformation.dwMajorVersion,
        VersionInformation.dwMinorVersion,
        VersionInformation.dwBuildNumber,
        szCSDString,
        szCurrentType
        );
    return;
}

DECLARE_API( help )
{
    INIT_API();

    dprintf("!version               - Dump System Version and Build Number\n");
    dprintf("!sscope                - Dump an UnASM Scope Stack\n");
    dprintf("!scope                 - Dump an UnASM Scope\n");
    dprintf("!pstack                - Dump an UnASM Parse Stack\n");
    dprintf("!sstack                - Dump an UnASM String STack\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\client\spctl.c ===
#include <windows.h>
#include <devioctl.h>
#include <spsimioct.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

typedef struct {
    WCHAR *szName;
} MANAGED_DEVICE, *PMANAGED_DEVICE;

PMANAGED_DEVICE g_pManagedDevices;
ULONG g_nDevices;

VOID Usage()
{
    _tprintf(TEXT("usage: spctl command args...\n"));
    _tprintf(TEXT("  commands are:\n"));
    _tprintf(TEXT("       notify devnum code\n"));
    _tprintf(TEXT("       setsta devnum value\n"));
    _tprintf(TEXT("       insert [devnum | * ]\n"));
    _tprintf(TEXT("       eject [devnum | * ]\n"));
    _tprintf(TEXT("       <nothing> - prints device status\n"));
}

DWORD
Notify(
    HANDLE hSpSim,
    DWORD Device,
    BYTE NotifyValue
    )
{
    SPSIM_NOTIFY_DEVICE notify;
    BOOL bResult;
    DWORD dwReturned;

    notify.Device = Device;
    notify.NotifyValue = NotifyValue;
    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_NOTIFY_DEVICE,
                              &notify,
                              sizeof(notify),
                              NULL,
                              0,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {

        _tprintf(TEXT("unable to notify device %u: %u\n"), Device, GetLastError());
        return GetLastError();
    }
    return 0;
}
DWORD
SetSta(
    HANDLE hSpSim,
    DWORD Device,
    BYTE StaValue
    )
{
    SPSIM_ACCESS_STA access;
    BOOL bResult;
    DWORD dwReturned;

    access.Device = Device;
    access.StaValue = StaValue;
    access.WriteOperation = TRUE;
    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_ACCESS_STA,
                              &access,
                              sizeof(access),
                              NULL,
                              0,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {
        _tprintf(TEXT("unable to set operation region's sta value for device %u: %u\n"), Device, GetLastError());
        return GetLastError();
    }
    return 0;
}
DWORD
GetManagedDevices(
    HANDLE hSpSim,
    DWORD Count
    )
{
    PSPSIM_DEVICE_NAME name;
    BOOL bResult;
    DWORD dwReturned, bufferSize, dwError, i;

    g_nDevices = Count;
    g_pManagedDevices = LocalAlloc(LPTR,
                                   g_nDevices * sizeof(MANAGED_DEVICE));
    if (g_pManagedDevices == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    bufferSize = sizeof(SPSIM_DEVICE_NAME) + sizeof(WCHAR) * 1024;
    name = LocalAlloc(LPTR, bufferSize);
    if (name == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for (i = 0; i < g_nDevices; i++) {
        name->Device = i;
        bResult = DeviceIoControl(hSpSim,
                                  IOCTL_SPSIM_GET_DEVICE_NAME,
                                  name,
                                  bufferSize,
                                  name,
                                  bufferSize,
                                  &dwReturned,
                                  NULL
                                  );
        if (!bResult) {
            return GetLastError();
        }
        g_pManagedDevices[i].szName = _wcsdup(name->DeviceName);
    }

    return 0;
}

void __cdecl
_tmain(INT argx, TCHAR *argv[]) {
    HANDLE hSpSim;
    PSPSIM_MANAGED_DEVICES managed;
    PVOID newmem;
    BOOL bResult;
    DWORD dwReturned, bufferSize, dwError;
    DWORD Device;
    BYTE NotifyCode, StaValue;
    
    managed = LocalAlloc(LPTR, sizeof(SPSIM_MANAGED_DEVICES));
    if (managed == NULL) {
        _tprintf(TEXT("out of memory\n"));
        return;
    }
    bufferSize = sizeof(SPSIM_MANAGED_DEVICES);

    //
    // Need to get the interface in a more portable way.
    //
    hSpSim = CreateFile(TEXT("\\\\.\\ACPI#SPSIMUL#2&daba3ff&0#{bdde6934-529d-4183-a952-adffb0dbb3dd}"), 
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
                       );
    if (hSpSim == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("Could not open handle to device.\n GetLastError()==%x\n"), 
                 GetLastError());
        return;
    }

retry:

    bResult = DeviceIoControl(hSpSim,
                              IOCTL_SPSIM_GET_MANAGED_DEVICES,
                              NULL,
                              0,
                              managed,
                              bufferSize,
                              &dwReturned,
                              NULL
                              );
    if (!bResult) {
        dwError = GetLastError();
        if (dwError == ERROR_MORE_DATA) {
            bufferSize = sizeof(SPSIM_MANAGED_DEVICES) +
                managed->Count * sizeof(UCHAR);
            newmem = LocalReAlloc(managed, bufferSize, LMEM_MOVEABLE);
            if (newmem == NULL) {
                _tprintf(TEXT("unable to realloc memory\n"));
                LocalFree(managed);
                return;
            }
            managed = newmem;
            goto retry;
        }
    } else {
        dwError = GetManagedDevices(hSpSim, managed->Count);
        if (dwError) {
            _tprintf("Couldn't get info on managed devices: %u\n", dwError);
            LocalFree(managed);
            return;
        }
    }

    if (argx == 1) {
        for (Device = 0; Device < g_nDevices; Device++) {
            _tprintf(TEXT("\tDev %u : %_STA is 0x%x Name %ws\n"), Device, managed->StaValues[Device], g_pManagedDevices[Device].szName);
        }
    }
    else if (argx == 4) {
        Device = _ttol(argv[2]);
        if (!_tcsicmp(argv[1], "notify")) {
            NotifyCode = (BYTE) _ttol(argv[3]);

            Notify(hSpSim, Device, NotifyCode);
        } else if (!_tcsicmp(argv[1], "setsta")) {

            StaValue = (BYTE) _ttol(argv[3]);

            SetSta(hSpSim, Device, StaValue);
        } else {
            Usage();
        }            
    } else if (argx == 3) {
        if (!_tcsicmp(argv[1], "insert")) {
            if (*argv[2] == '*') {

                for (Device = 0; Device < g_nDevices; Device++) {
                    SetSta(hSpSim, Device, 0xf);
                    Notify(hSpSim, Device, 1);
                }
            } else {
                Device = _ttol(argv[2]);

                SetSta(hSpSim, Device, 0xf);
                Notify(hSpSim, Device, 1);
            }
        } else if (!_tcsicmp(argv[1], "eject")) {
            if (*argv[2] == '*') {

                for (Device = 0; Device < g_nDevices; Device++) {
                    Notify(hSpSim, Device, 3);
                }
            } else {
                Device = _ttol(argv[2]);

                Notify(hSpSim, Device, 3);
            }
        } else {
            Usage();
        }
    } else {
        Usage();
    }

    CloseHandle(hSpSim);
    LocalFree(managed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\debug.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _SPSIM_STRING_MAP {
    ULONG Id;
    PCHAR String;
} SPSIM_STRING_MAP, *PSPSIM_STRING_MAP;

//
// Debug globals
//

extern LONG SpSimDebug;
extern SPSIM_STRING_MAP SpSimDbgPnpIrpStringMap[];
extern SPSIM_STRING_MAP SpSimDbgPoIrpStringMap[];
extern SPSIM_STRING_MAP SpSimDbgDeviceRelationStringMap[];
extern SPSIM_STRING_MAP SpSimDbgSystemPowerStringMap[];
extern SPSIM_STRING_MAP SpSimDbgDevicePowerStringMap[];
extern PSPSIM_STRING_MAP SpSimDbgStatusStringMap;

//
// Debug prototypes
//

VOID
SpSimDbgInitialize(
    VOID
    );

VOID
SpSimDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    );

PCHAR
SpSimDbgLookupString(
    IN PSPSIM_STRING_MAP Map,
    IN ULONG Id
    );

VOID
SpSimDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
SpSimDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    );

PUCHAR
SpSimDbgCmResourceTypeToText(
    UCHAR Type
    );


//
// Debug macros
//

#define DEBUG_PRINT(Level, Msg)                                             \
    if (Level <= SpSimDebug) DbgPrint Msg

#define DEBUG_MSG(Level, Msg)                                               \
    if (Level <= SpSimDebug) { DbgPrint("SpSim: "); DbgPrint Msg; }

#define ASSERT_SPSIM_DEVICE(DeviceObject)                                      \
    ASSERT(((PSPSIM_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == SpSimFunctionalDeviceObject                                 \
          ||                                                                \
           ((PSPSIM_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == SpSimPhysicalDeviceObject)


#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : SpSimDbgLookupString(SpSimDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    SpSimDbgLookupString(SpSimDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    SpSimDbgLookupString(SpSimDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    SpSimDbgLookupString(SpSimDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    SpSimDbgLookupString(SpSimDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    SpSimDbgLookupString(SpSimDbgDevicePowerStringMap, (_State))



#else

#define DEBUG_PRINT(Level, Msg) 
#define DEBUG_MSG(Level, Msg)
#define ASSERT_SPSIM_DEVICE(DeviceObject)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\debug.c ===
/*++      

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "SpSim.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

LONG SpSimDebug = -1;

PSPSIM_STRING_MAP SpSimDbgStatusStringMap = (PSPSIM_STRING_MAP) ntstatusSymbolicNames;

SPSIM_STRING_MAP SpSimDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    END_STRING_MAP
};


SPSIM_STRING_MAP SpSimDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



SPSIM_STRING_MAP SpSimDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

SPSIM_STRING_MAP SpSimDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

SPSIM_STRING_MAP SpSimDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCHAR
SpSimDbgLookupString(
    IN PSPSIM_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PSPSIM_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}

VOID
SpSimDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    )

/*++

Routine Description:

    Prints a registry style REG_MULTI_SZ
    
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    MultiSz - The string to print

Return Value:

    None
            
--*/

{
    PWSTR current = MultiSz;

    if (DebugLevel <= SpSimDebug) {

        if (MultiSz) {
        
            while(*current) {
        
                DbgPrint("%S", current);
                
                current += wcslen(current) + 1; // include the NULL
        
                DbgPrint(*current ? ", " : "\n");
        
            }
        } else {
            DbgPrint("*** None ***\n");
        }
    }
}

//
// Printing resource descriptors and resource lists (stolen from PCI)
//

PUCHAR
SpSimDbgCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

VOID
SpSimDbgPrintIoResource(
    IN LONG Level,
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= SpSimDebug) {
    
        t = SpSimDbgCmResourceTypeToText(D->Type);
        DbgPrint("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
        DbgPrint("        Option           = 0x%x\n", D->Option);
        DbgPrint("        Type             = %d (%s)\n", D->Type, t);
        DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
        DbgPrint("        Flags            = 0x%04X\n", D->Flags);
    
        for ( i = 0; i < 6 ; i+=3 ) {
            DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                     i,
                     D->u.DevicePrivate.Data[i],
                     D->u.DevicePrivate.Data[i+1],
                     D->u.DevicePrivate.Data[i+2]);
        }
    }
}


VOID
SpSimDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;


    if (Level <= SpSimDebug) {
    
        if (IoResReqList) {
            
            numlists = IoResReqList->AlternativeLists;
            list     = IoResReqList->List;
        
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     AlternativeLists     %d\n", numlists                   );
        
            while (numlists--) {
        
                PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
                ULONG                   count    = list->Count;
        
                DbgPrint("\n     List[%d].Count = %d\n", numlists, count);
                while (count--) {
                    SpSimDbgPrintIoResource(Level, resource++);
                }
        
                list = (PIO_RESOURCE_LIST)resource;
            }
            DbgPrint("\n");
        } else {
            
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     *** EMPTY ***\n");
        }
    }
}


VOID
SpSimDbgPrintPartialResource(
    IN LONG Level,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= SpSimDebug) {

        if (D) {
        
            t = SpSimDbgCmResourceTypeToText(D->Type);
            DbgPrint("     Partial Resource Descriptor @0x%x\n", D);
            DbgPrint("        Type             = %d (%s)\n", D->Type, t);
            DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
            DbgPrint("        Flags            = 0x%04X\n", D->Flags);
            
            for ( i = 0; i < 3 ; i+=3 ) {
                DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                         i,
                         D->u.DevicePrivate.Data[i],
                         D->u.DevicePrivate.Data[i+1],
                         D->u.DevicePrivate.Data[i+2]);
            }

        } else {
        
            DbgPrint("     Partial Resource Descriptor EMPTY!!\n");
        }
    }
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
SpSimNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PCHAR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}


VOID
SpSimDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (Level <= SpSimDebug) {
    

        if (ResourceList) {
        
            numlists = ResourceList->Count;
            full     = ResourceList->List;
        
            DbgPrint("  CM_RESOURCE_LIST (List Count = %d)\n",
                     numlists);
        
            while (numlists--) {
                PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
                ULONG                     count   = partial->Count;
        
                descriptor = partial->PartialDescriptors;
                while (count--) {
                    SpSimDbgPrintPartialResource(Level, descriptor);
                    descriptor = SpSimNextPartialDescriptor(descriptor);
                }
        
                full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
            }
            DbgPrint("\n");
        
        } else {
        
            DbgPrint("  CM_RESOURCE_LIST EMPTY!!!\n");
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\dispatch.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module provides the functions which dispatch IRPs to FDOs and PDOs.

Author:

    Adam Glass

Revision History:

--*/


#include "SpSim.h"
#include "spsimioct.h"

const GUID SPSIM_CTL = {0xbdde6934, 0x529d, 0x4183, 0xa9, 0x52, 0xad,
                        0xff, 0xb0, 0xdb, 0xb3, 0xdd};

NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, SpSimAddDevice)
#pragma alloc_text(PAGE, SpSimDispatchPnp)
#endif

NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it and attaches it to the top of the stack.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;
    PSPSIM_EXTENSION extension;

    ASSERT(DriverObject == SpSimDriverObject);

    PAGED_CODE();

    //
    // Create our FDO
    //

    status = SpSimCreateFdo(&fdo);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    extension = fdo->DeviceExtension;

    extension->PhysicalDeviceObject = PhysicalDeviceObject;

    //
    // Attach to the stack
    //
    
    extension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                    fdo,
                                    PhysicalDeviceObject
                                    );

    if (!extension->AttachedDevice) {

        //
        // Could not attach
        //

        status = STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    status = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                       &SPSIM_CTL,
                                       NULL,
                                       &extension->SymbolicLinkName);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    DEBUG_MSG(1, ("Completed AddDevice for PDO 0x%08x\n", PhysicalDeviceObject));

    return STATUS_SUCCESS;

cleanup:

    if (fdo) {
        IoDeleteDevice(fdo);
    }

    return status;
}

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for this driver.  It dispatches to
    the appropriate fdo/pdo routine.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PSPSIM_EXTENSION spsim;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    spsim = (PSPSIM_EXTENSION)  DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    return SpSimDispatchPnpFdo(DeviceObject,
                               spsim,
                               irpStack,
                               Irp
                               );
}

NTSTATUS
SpSimOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

#if 0
NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for this driver.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PSpSim_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    ASSERT_SpSim_DEVICE(DeviceObject);

    //
    // Find out who we are and what we need to do
    //

    common = (PSpSim_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    if (IS_FDO(common)) {
        return SpSimDispatchPowerFdo(DeviceObject,
                                  (SPSIM_EXTENSION) common,
                                  irpStack,
                                  Irp);
    } else {
        return SpSimDispatchPowerPdo(DeviceObject,
                                  (PSpSim_CHILD_EXTENSION) common,
                                  irpStack,
                                  Irp);
    }
}

#endif

NTSTATUS
SpSimIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++

Routine Description:

    This function handles the unsupported IRPs for both SpSim PDOs and FDOs

    This is NOT paged because is can be called from SpSimDispatchPower which can
    be called at DISPATCH_LEVEL

Arguments:

    Irp - Points to the IRP associated with this request.

    Extension - Points to the device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    STATUS_NOT_SUPPORTED

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Extension);
    UNREFERENCED_PARAMETER(IrpStack);

    DEBUG_MSG(1, ("Skipping upsupported IRP\n"));

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\method.c ===
#include "spsim.h"
#include "spsimioct.h"

NTSTATUS
SpSimNotifyDeviceIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PACPI_EVAL_INPUT_BUFFER_COMPLEX input;
    PSPSIM_NOTIFY_DEVICE notify;
    NTSTATUS status;
    ULONG size;

    PAGED_CODE();

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SPSIM_NOTIFY_DEVICE)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    notify = Irp->AssociatedIrp.SystemBuffer;

    if ((notify->Device >= SpSim->StaCount) || (notify->Device > 255)) {
        return STATUS_INVALID_PARAMETER;
    }

    size = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
        sizeof(ACPI_METHOD_ARGUMENT) * (2 - ANYSIZE_ARRAY);
    input = ExAllocatePool(PagedPool, size);
    if (input == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(input, size);
    input->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    input->MethodNameAsUlong = SPSIM_NOTIFY_DEVICE_METHOD;
    input->Size = size;
    input->ArgumentCount = 2;
    input->Argument[0].Type = input->Argument[1].Type =
        ACPI_METHOD_ARGUMENT_INTEGER;
    input->Argument[0].DataLength = input->Argument[1].DataLength =
        sizeof(ULONG);
    input->Argument[0].Argument = notify->Device;
    input->Argument[1].Argument = notify->NotifyValue;
    status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                            IOCTL_ACPI_EVAL_METHOD,
                            input,
                            size,
                            NULL,
                            0
                            );
    ExFreePool(input);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\memory.c ===
#include "spsim.h"

#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"

typedef struct {
    ULONGLONG         Base;
    ULONGLONG         Length;
    ULONGLONG         Type;
} ACPI_E820_ENTRY, *PACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONGLONG           Count;
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE, *PACPI_BIOS_MULTI_NODE;

typedef enum {
    AcpiAddressRangeMemory = 1,
    AcpiAddressRangeReserved,
    AcpiAddressRangeACPI,
    AcpiAddressRangeNVS,
    AcpiAddressRangeMaximum,
} ACPI_BIOS_E820_TYPE, *PACPI_BIOS_E820_TYPE;

NTSTATUS
SpSimGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool(NonPagedPool,
                                keyValueLength);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}
// insert pragmas here

NTSTATUS
SpSimRetrieveE820Data(
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com.

Arguments:

   AcpiMulti - ...

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        DbgPrint("AcpiBios:Can not open MultifunctionAdapter registry key.\n");
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            DbgPrint("AcpiBios: ACPI BIOS MultifunctionAdapter registry key not found.\n");
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = SpSimGetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //

        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = SpSimGetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                        ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE)
                   ExAllocatePool(NonPagedPool,
                                  multiNodeSize);
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}

VOID
SpSimFillMemoryDescs(
    PACPI_BIOS_MULTI_NODE E820Data,
    ULONGLONG memUnit,
    PMEM_REGION_DESCRIPTOR MemRegions
    )
{
    ULONG i, descCount;

#undef min
#define min(a,b) (a < b ? a : b)

    descCount = 0;
    for (i = 0; i < E820Data->Count; i++) {
        if (E820Data->E820Entry[i].Type != AcpiAddressRangeMemory) {
            continue;
        }
        if (E820Data->E820Entry[i].Length > memUnit) {
            ULONGLONG remains, base, extra;
            
            extra = E820Data->E820Entry[i].Length & (PAGE_SIZE - 1);
            remains = E820Data->E820Entry[i].Length - extra;
            base = (E820Data->E820Entry[i].Base + (PAGE_SIZE - 1)) &
                ~(PAGE_SIZE - 1);

            while (remains) {
                MemRegions[descCount].Addr = (ULONG) base;
                MemRegions[descCount].Length = (ULONG) min(remains, memUnit);
                descCount++;
                base += min(remains, memUnit);
                remains -= min(remains, memUnit);
            }
        } else {
            MemRegions[descCount].Addr = (ULONG) E820Data->E820Entry[i].Base;
            MemRegions[descCount].Length = (ULONG) E820Data->E820Entry[i].Length;

            descCount++;
        }
    }
}
ULONG
SpSimCalculateMemoryDescCount(
    PACPI_BIOS_MULTI_NODE E820Data,
    ULONGLONG memUnit
    )
{
    ULONG i, descCount;

    descCount = 0;
    for (i = 0; i < E820Data->Count; i++) {
        if (E820Data->E820Entry[i].Type != AcpiAddressRangeMemory) {
            continue;
        }
        ASSERT((0xFFFFFFFF00000000 & E820Data->E820Entry[i].Base) == 0);

        if (E820Data->E820Entry[i].Length > memUnit) {
            
            descCount += (ULONG) (E820Data->E820Entry[i].Length / memUnit);
            if ((E820Data->E820Entry[i].Length % memUnit) != 0) {
                descCount++;
            }
        } else {
            descCount++;
        }
    }
    return descCount;
}


NTSTATUS
SpSimCreateMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    PACPI_BIOS_MULTI_NODE E820Data;
    ULONG i, descCount, memUnit = MIN_LARGE_DESC;
    NTSTATUS status;

    status = SpSimRetrieveE820Data(&E820Data);
    if (!NT_SUCCESS(status)) {
        SpSim->MemOpRegionValues = NULL;
        return status;
    }

    ASSERT(E820Data);

    descCount = descCount = SpSimCalculateMemoryDescCount(E820Data, memUnit);
    while (descCount > (MAX_MEMORY_OBJ * MAX_MEMORY_DESC_PER_OBJ)) {
        memUnit = memUnit << 1;
        descCount = SpSimCalculateMemoryDescCount(E820Data, memUnit);
    }

    SpSim->MemOpRegionValues =
        ExAllocatePool(NonPagedPool,
                       sizeof(MEM_REGION_DESCRIPTOR) * descCount);
    if (SpSim->MemOpRegionValues == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto out;
    }
    RtlZeroMemory(SpSim->MemOpRegionValues,
                  sizeof(MEM_REGION_DESCRIPTOR) * descCount);

    SpSimFillMemoryDescs(E820Data, memUnit, SpSim->MemOpRegionValues);

    SpSim->MemCount = descCount;

 out:
    ExFreePool(E820Data);
    if (!NT_SUCCESS(status)) {
        if (SpSim->MemOpRegionValues) {
            ExFreePool(SpSim->MemOpRegionValues);
            SpSim->MemOpRegionValues = NULL;
        }
        SpSim->MemCount = 0;
    }
    return status;
}

VOID
SpSimDeleteMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    if (SpSim->MemOpRegionValues) {
        ExFreePool(SpSim->MemOpRegionValues);
        SpSim->MemOpRegionValues = NULL;
    }
}

NTSTATUS
SpSimMemOpRegionReadWrite(
    PSPSIM_EXTENSION SpSim,
    ULONG AccessType,
    ULONG Offset,
    ULONG Size,
    PUCHAR Data
    )
{
    ULONG i, limit;
    PUCHAR current;

    ASSERT((Offset & 3) == 0);
    ASSERT((Size & 3) == 0);

    if (SpSim->MemOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    limit = sizeof(MEM_REGION_DESCRIPTOR)*SpSim->MemCount;

    // We're going to define this op region to return all zeros if you
    // access beyond that which we've been able to initialize using
    // the E820 data.

    if (Offset >= limit) {
        RtlZeroMemory(Data, Size);
        return STATUS_SUCCESS;
    }

    if (Offset + Size > limit) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(Offset < limit);

    /// XXX if the asserts hold then this should get fixed.

    current = ((PUCHAR) (SpSim->MemOpRegionValues)) + Offset;

    if (AccessType & ACPI_OPREGION_WRITE) {
        for (i = 0 ; i < Size; i++) {
            *current++ = *Data++;
        }
    } else {
        for (i = 0 ; i < Size; i++) {
            *Data++ = *current++;
        }
    }
    return STATUS_SUCCESS;
}
    

NTSTATUS
EXPORT
SpSimMemOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

	 This routine handles requests to service the 
	 SPSIM operation region contained within this driver

Arguments:

	 AccessType          - Read or Write data
	 OpRegion            - Operation region object
	 Address             - Address within the EC address space
	 Size                - Number of bytes to transfer
	 Data                - Data buffer to transfer to/from
	 Context             - SpSim
	 CompletionHandler   - AMLI handler to call when operation is complete
	 CompletionContext   - Context to pass to the AMLI handler

Return Value:

	 Status

--*/
{
    NTSTATUS status;

    status = SpSimMemOpRegionReadWrite((PSPSIM_EXTENSION) Context,
                                       AccessType,
                                       Address,
                                       Size,
                                       (PUCHAR)Data);
    return status;
}
NTSTATUS
SpSimInstallMemOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	This calls the ACPI driver to install itself as the op region
	handler for the Mem region.  It also allocates the memory for the
	opregion itself.

Arguments:

	pSpSimData      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS                                status;

    status=RegisterOpRegionHandler (
        SpSim->AttachedDevice,
        ACPI_OPREGION_ACCESS_AS_COOKED,
        MEM_OPREGION,
        SpSimMemOpRegionHandler,
        SpSim,
        0,
        &SpSim->MemOpRegion
        );

    //
    // Check the status code
    //
    if(!NT_SUCCESS(status)) {
        SpSim->MemOpRegion = NULL;
        DbgPrint("Not successful in installing:=%x\n", status);
        return status;
    }

    // XXXX

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimRemoveMemOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	Uninstalls itself as the opregion handler.  

Arguments:

	SpSim      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS status;
    PIRP irp;

    if (SpSim->MemOpRegion != NULL) {
        status = DeRegisterOpRegionHandler (
            SpSim->AttachedDevice,
            SpSim->MemOpRegion
            );
        SpSim->MemOpRegion = NULL;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\init.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the initialization and unload functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "SpSim.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SpSimUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SpSimUnload)
#endif

PDRIVER_OBJECT SpSimDriverObject;

NTSTATUS
SpSimDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles irps like IRP_MJ_DEVICE_CONTROL, which we don't support.
    This handler will complete the irp (if PDO) or pass it (if FDO).

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PSPSIM_EXTENSION spsim;
    PDEVICE_OBJECT attachedDevice;

    PAGED_CODE();

    spsim = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(spsim->AttachedDevice, Irp);
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    
    This is the entry point to SpSim.SYS and performs initialization.
    
Arguments:

    DriverObject - The system owned driver object for SpSim
    
    RegistryPath - The path to SpSim's service entry
    
Return Value:

    STATUS_SUCCESS

--*/
{

    DriverObject->DriverExtension->AddDevice = SpSimAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SpSimOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SpSimOpenClose;
    DriverObject->MajorFunction[IRP_MJ_PNP] = SpSimDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = SpSimDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SpSimDevControl;
    DriverObject->DriverUnload = SpSimUnload;

    //
    // Remember the driver object
    //

    SpSimDriverObject = DriverObject;

    DEBUG_MSG(1, ("Completed DriverEntry for Driver 0x%08x\n", DriverObject));
    
    return STATUS_SUCCESS;
}

VOID
SpSimUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for SpSim
    
Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();
    
    DEBUG_MSG(1, ("Completed Unload for Driver 0x%08x\n", DriverObject));
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\fdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module provides the functions which answer IRPs to functional devices.

Author:

    (Derived from MF)

Revision History:

--*/

#include "SpSim.h"
#include "spsimioct.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
SpSimXxxFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction FDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    SpSim - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/


NTSTATUS
SpSimDeferProcessingFdo(
    IN PSPSIM_EXTENSION SpSim,
    IN OUT PIRP Irp
    );

NTSTATUS
SpSimStartFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimStartFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpSimQueryStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimCancelStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimQueryRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimCancelRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, SpSimCancelRemoveFdo)
#pragma alloc_text(PAGE, SpSimCancelStopFdo)
#pragma alloc_text(PAGE, SpSimCreateFdo)
#pragma alloc_text(PAGE, SpSimDeferProcessingFdo)
#pragma alloc_text(PAGE, SpSimDispatchPnpFdo)
#pragma alloc_text(PAGE, SpSimPassIrp)
#pragma alloc_text(PAGE, SpSimQueryRemoveFdo)
#pragma alloc_text(PAGE, SpSimQueryStopFdo)
#pragma alloc_text(PAGE, SpSimRemoveFdo)
#pragma alloc_text(PAGE, SpSimStartFdo)
#pragma alloc_text(PAGE, SpSimQueryCapabilitiesFdo)
#pragma alloc_text(PAGE, SpSimSurpriseRemoveFdo)
#endif


PSPSIM_DISPATCH SpSimPnpDispatchTableFdo[] = {
    SpSimStartFdo,                     // IRP_MN_START_DEVICE
    SpSimQueryRemoveFdo,               // IRP_MN_QUERY_REMOVE_DEVICE
    SpSimRemoveFdo,                    // IRP_MN_REMOVE_DEVICE
    SpSimCancelRemoveFdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
    SpSimPassIrp,                      // IRP_MN_STOP_DEVICE
    SpSimQueryStopFdo,                 // IRP_MN_QUERY_STOP_DEVICE
    SpSimCancelStopFdo,                // IRP_MN_CANCEL_STOP_DEVICE
    SpSimPassIrp,                      // IRP_MN_QUERY_DEVICE_RELATIONS
    SpSimPassIrp,                      // IRP_MN_QUERY_INTERFACE
    SpSimQueryCapabilitiesFdo,         // IRP_MN_QUERY_CAPABILITIES
    SpSimPassIrp,                      // IRP_MN_QUERY_RESOURCES
    SpSimPassIrp,                      // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    SpSimPassIrp,                      // IRP_MN_QUERY_DEVICE_TEXT
    SpSimPassIrp,                      // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    SpSimPassIrp,                      // Unused
    SpSimPassIrp,                      // IRP_MN_READ_CONFIG
    SpSimPassIrp,                      // IRP_MN_WRITE_CONFIG
    SpSimPassIrp,                      // IRP_MN_EJECT
    SpSimPassIrp,                      // IRP_MN_SET_LOCK
    SpSimPassIrp,                      // IRP_MN_QUERY_ID
    SpSimPassIrp,                      // IRP_MN_QUERY_PNP_DEVICE_STATE
    SpSimPassIrp,                      // IRP_MN_QUERY_BUS_INFORMATION
    SpSimPassIrp,                      // IRP_MN_DEVICE_USAGE_NOTIFICATION
    SpSimSurpriseRemoveFdo,            // IRP_MN_SURPRISE_REMOVAL
};

NTSTATUS
SpSimCreateFdo(
    OUT PDEVICE_OBJECT *Fdo
    )
/*++

Routine Description:

    This function creates a new FDO and initializes it.

Arguments:

    Fdo - Pointer to where the FDO should be returned

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    NTSTATUS status;
    PSPSIM_EXTENSION extension;

    PAGED_CODE();

    ASSERT((sizeof(SpSimPnpDispatchTableFdo) / sizeof(PSPSIM_DISPATCH)) - 1
           == IRP_MN_PNP_MAXIMUM_FUNCTION);

#if 0
    ASSERT((sizeof(SpSimPoDispatchTableFdo) / sizeof(PSPSIM_DISPATCH)) -1
       == IRP_MN_PO_MAXIMUM_FUNCTION);
#endif

    *Fdo = NULL;

    status = IoCreateDevice(SpSimDriverObject,
                            sizeof(SPSIM_EXTENSION),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            Fdo
                           );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Initialize the extension
    //

    extension = (PSPSIM_EXTENSION) (*Fdo)->DeviceExtension;

    extension->Self = *Fdo;

    IoInitializeRemoveLock(&extension->RemoveLock, 0, 1, 20);

    extension->PowerState = PowerDeviceD3;

    DEBUG_MSG(1, ("Created FDO @ 0x%08x\n", *Fdo));

    return status;

cleanup:

    if (*Fdo) {
        IoDeleteDevice(*Fdo);
    }

    return status;

}

VOID
SpSimDeleteFdo(
    IN PDEVICE_OBJECT Fdo
    )
{
    PSPSIM_EXTENSION SpSim = Fdo->DeviceExtension;

    if (SpSim->DeviceState & SPSIM_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(SpSim->DeviceState & SPSIM_DEVICE_DELETED));
        return;
    }

    SpSim->DeviceState = SPSIM_DEVICE_DELETED;

    SpSimDeleteStaOpRegion(SpSim);

    SpSimDeleteMemOpRegion(SpSim);

    RtlFreeUnicodeString(&SpSim->SymbolicLinkName);

    //
    // Free up any memory we have allocated
    //

    IoDeleteDevice(Fdo);

    DEBUG_MSG(1, ("Deleted FDO @ 0x%08x\n", Fdo));

}

NTSTATUS
SpSimPassIrp(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(SpSim->AttachedDevice, Irp);
}

NTSTATUS
SpSimDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    SpSim - FDO extension

    IrpStack - Current stack location
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    IoAcquireRemoveLock(&SpSim->RemoveLock, (PVOID) Irp);

    isRemoveDevice = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = SpSimPassIrp(Irp, SpSim, IrpStack);

    } else {

        status =
            SpSimPnpDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          SpSim,
                                                          IrpStack
                                                          );
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&SpSim->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
SpSimPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SpSimDeferProcessingFdo(
    IN PSPSIM_EXTENSION SpSim,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    SpSim - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           SpSimPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(SpSim->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
SpSimStartFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION location;
    POWER_STATE power;

    PWSTR string;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    power.DeviceState = PowerDeviceD0;
    PoSetPowerState(SpSim->Self, DevicePowerState, power);
    SpSim->PowerState = PowerDeviceD0;

    status = SpSimCreateStaOpRegion(SpSim);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = SpSimCreateMemOpRegion(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = SpSimInstallStaOpRegionHandler(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = SpSimInstallMemOpRegionHandler(SpSim);
    if (!NT_SUCCESS(status)) {
        SpSimDeleteStaOpRegion(SpSim);
        goto cleanup;
    }

    status = IoSetDeviceInterfaceState(&SpSim->SymbolicLinkName, TRUE);

cleanup:

    Irp->IoStatus.Status = status;
    if (!NT_SUCCESS(status)) {
        SpSimRemoveStaOpRegionHandler(SpSim);
        SpSimDeleteStaOpRegion(SpSim);
        SpSimRemoveMemOpRegionHandler(SpSim);
        SpSimDeleteMemOpRegion(SpSim);
    } else {
        //
        // We are now started!
        //
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;    
}

NTSTATUS
SpSimQueryStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
SpSimCancelStopFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimQueryRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return SpSimPassIrp(Irp, SpSim, IrpStack);
}

NTSTATUS
SpSimRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    POWER_STATE power;

    power.DeviceState = PowerDeviceD3;
    PoSetPowerState(SpSim->Self, DevicePowerState, power);
    SpSim->PowerState = PowerDeviceD3;

    (VOID) IoSetDeviceInterfaceState(&SpSim->SymbolicLinkName, FALSE);

    SpSimRemoveStaOpRegionHandler(SpSim);
    SpSimRemoveMemOpRegionHandler(SpSim);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = SpSimPassIrp(Irp, SpSim, IrpStack);
    ASSERT(status == STATUS_SUCCESS);

    IoReleaseRemoveLockAndWait(&SpSim->RemoveLock, (PVOID) Irp);

    //
    // Detach and delete myself
    //

    IoDetachDevice(SpSim->AttachedDevice);
    SpSim->AttachedDevice = NULL;

    SpSimDeleteFdo(SpSim->Self);

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    for (i = 0; i < PowerSystemMaximum; i++) {
        SpSim->DeviceStateMapping[i] =
            IrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    SpSim->DeviceState |= SPSIM_DEVICE_SURPRISE_REMOVED;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return SpSimPassIrp(Irp, SpSim, IrpStack);
}

NTSTATUS
SpSimCancelRemoveFdo(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = SpSimDeferProcessingFdo(SpSim, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run
    
    InputBuffer - arguments to the IOCTL
    
    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL
    
    OnputBufferLength - the size in bytes of the OutputBuffer
    
Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT targetDevice = NULL;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get the top of the stack to send the IRP to
    //

    targetDevice = IoGetAttachedDeviceReference(Device);

    if (!targetDevice) {
        status = STATUS_INVALID_PARAMETER;
	goto exit;
    }

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        targetDevice,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    if (targetDevice) {    
        ObDereferenceObject(targetDevice);
    }

    return status;

}

NTSTATUS                           
SpSimDevControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

	DeviceIoControl handler.  It can handle both IOCTL_MEC_BIOS_OP_ACCESS and IOCTL_MEC_LOCAL_OP_ACCESS
	calls.  
	For example purposes this handles running ACPI methods in the bios.

Arguments:

	DeviceObject    - Pointer to class device object.
	Irp             - Pointer to the request packet.

Return Value:

	ntStatus

--*/
{
    PIO_STACK_LOCATION  CurrentIrpStack;
    PSPSIM_EXTENSION spsim = (PSPSIM_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status;

    if (Irp == NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (!(CurrentIrpStack=IoGetCurrentIrpStackLocation(Irp))) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_2;
        IoCompleteRequest(Irp, 0);
        return STATUS_INVALID_PARAMETER_2;
    }

    switch(CurrentIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SPSIM_GET_MANAGED_DEVICES:
        status = SpSimGetManagedDevicesIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_ACCESS_STA:
        status = SpSimAccessStaIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_NOTIFY_DEVICE:
        status = SpSimNotifyDeviceIoctl(spsim, Irp, CurrentIrpStack);
        break;
    case IOCTL_SPSIM_GET_DEVICE_NAME:
        status = SpSimGetDeviceName(spsim, Irp, CurrentIrpStack);
        break;
    default:
        status = SpSimPassIrp(Irp, spsim, CurrentIrpStack);
        return status;
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
SpSimPowerCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PSPSIM_EXTENSION deviceExtension;
    PIRP Irp;
    NTSTATUS status;

    Irp = Context;
    deviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

NTSTATUS
SpSimPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID NotUsed
    )
/*++

Routine Description:

   The completion routine for Power

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PSPSIM_EXTENSION deviceExtension;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        SYSTEM_POWER_STATE system =
            irpStack->Parameters.Power.State.SystemState;
        POWER_STATE power;

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            power.DeviceState = deviceExtension->DeviceStateMapping[system];

            PoRequestPowerIrp(DeviceObject,
                              irpStack->MinorFunction,
                              power,
                              SpSimPowerCallback,
                              Irp, 
                              NULL);
            return STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            status = Irp->IoStatus.Status;
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    } else {
        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            PoSetPowerState(DeviceObject, DevicePowerState,
                            irpStack->Parameters.Power.State);
            deviceExtension->PowerState =
                irpStack->Parameters.Power.State.DeviceState;
        }
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSPSIM_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    if (status == STATUS_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   SpSimPowerCompletion,
                                   NULL,   //Context
                                   TRUE,   //InvokeOnSuccess
                                   TRUE,  //InvokeOnError
                                   TRUE   //InvokeOnCancel
                                   );
            return PoCallDriver(deviceExtension->AttachedDevice, Irp);
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return status;
        }
    } else {
        switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpStack->Parameters.Power.State.DeviceState >
                deviceExtension->PowerState) {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       SpSimPowerCompletion,
                                       NULL,   //Context
                                       TRUE,   //InvokeOnSuccess
                                       TRUE,  //InvokeOnError
                                       TRUE   //InvokeOnCancel
                                       );
                break;
            } else {
                PoSetPowerState(DeviceObject, DevicePowerState,
                                irpStack->Parameters.Power.State);
                deviceExtension->PowerState =
                    irpStack->Parameters.Power.State.DeviceState;
                // 
                // Fall through ...
                //
            }
        case IRP_MN_QUERY_POWER:
            //
            // Fall through as the bus driver will mark this
            // STATUS_SUCCESS and complete it, if it gets that far.
            //
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            break;
        }
        status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\inc\spsimioct.h ===
DEFINE_GUID(SPSIM_CTL, 0xbdde6934, 0x529d, 0x4183, 0xa9, 0x52, 0xad,
            0xff, 0xb0, 0xdb, 0xb3, 0xdd);

typedef struct _SPSIM_ACCESS_STA {
    BOOLEAN WriteOperation;
    ULONG Device;
    UCHAR StaValue;
} SPSIM_ACCESS_STA, *PSPSIM_ACCESS_STA;

typedef struct _SPSIM_NOTIFY_DEVICE {
    ULONG Device;
    UCHAR NotifyValue;
} SPSIM_NOTIFY_DEVICE, *PSPSIM_NOTIFY_DEVICE;

typedef struct _SPSIM_DEVICE_NAME {
    ULONG   Device;
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} SPSIM_DEVICE_NAME, *PSPSIM_DEVICE_NAME;

typedef struct _SPSIM_MANAGED_DEVICES {
    ULONG Count;
    UCHAR StaValues[1]; 
} SPSIM_MANAGED_DEVICES, *PSPSIM_MANAGED_DEVICES;

#define IOCTL_SPSIM_ACCESS_STA       CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCC,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_NOTIFY_DEVICE    CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCD,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_GET_DEVICE_NAME      CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCE,METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPSIM_GET_MANAGED_DEVICES CTL_CODE(FILE_DEVICE_CONTROLLER,0x0CCF,METHOD_BUFFERED, FILE_READ_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\sta.c ===
#include "spsim.h"
#include "spsimioct.h"

NTSTATUS
SpSimCreateStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
/*++

Description:

    Retrieves information to construct the STA array that tells us
    what devices we control the _STA on

Arguments:

    SpSim - device extension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG i;
    PACPI_METHOD_ARGUMENT argument;    
    //
    // Allocate a buffer big enough for all possible slots
    //

    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER);

    PAGED_CODE();

    output = ExAllocatePool(PagedPool, outputSize);

    if (!output) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send a IOCTL to ACPI to request evaluate the
    // SPSIM_STA_NAMES_METHOD under this object if present.
    //

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = SPSIM_STA_NAMES_METHOD;

    status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                            IOCTL_ACPI_EVAL_METHOD,
                            &input,
                            sizeof(ACPI_EVAL_INPUT_BUFFER),
                            output,
                            outputSize
                            );
    if (status == STATUS_BUFFER_OVERFLOW) {
        outputSize = output->Length;
        ExFreePool(output);
        output = ExAllocatePool(PagedPool, outputSize);

        if (!output) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        status = SpSimSendIoctl(SpSim->PhysicalDeviceObject,
                                IOCTL_ACPI_EVAL_METHOD,
                                &input,
                                sizeof(ACPI_EVAL_INPUT_BUFFER),
                                output,
                                outputSize
                                );
    }

    if (NT_SUCCESS(status)) {
        argument = output->Argument;
        for (i = 0; i < output->Count; i++) {
            if (argument->Type != ACPI_METHOD_ARGUMENT_STRING) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        }
        SpSim->StaOpRegionValues = ExAllocatePool(NonPagedPool,
                                                  sizeof(UCHAR) * output->Count);
        if (SpSim->StaOpRegionValues == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            SpSim->StaNames = output;
            SpSim->StaCount = output->Count;
            RtlZeroMemory(SpSim->StaOpRegionValues,
                          sizeof(UCHAR) * SpSim->StaCount);
        }
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(output);
        SpSim->StaOpRegionValues = NULL;
        SpSim->StaNames = NULL;
        SpSim->StaCount = 0;
    }

    return status;
}

VOID
SpSimDeleteStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    )
{
    if (SpSim->StaNames) {
        ExFreePool(SpSim->StaNames);
        SpSim->StaNames = NULL;
    }

    if (SpSim->StaOpRegionValues) {
        ExFreePool(SpSim->StaOpRegionValues);
        SpSim->StaOpRegionValues = NULL;
    }
}
NTSTATUS
SpSimGetDeviceName(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PSPSIM_DEVICE_NAME name;
    PACPI_METHOD_ARGUMENT argument;
    PUCHAR source;
    PWCHAR dest;
    ULONG remainingBuffer, i, nameSize;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    name = Irp->AssociatedIrp.SystemBuffer;

    if (name->Device >= SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(SPSIM_DEVICE_NAME)) {
        return STATUS_INVALID_PARAMETER;
    }

    argument = SpSim->StaNames->Argument;
    i = 0;
    while (i != name->Device) {
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        i++;
    }
    
    nameSize = argument->DataLength * sizeof(WCHAR);
    name->DeviceNameLength = argument->DataLength;

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < (sizeof(SPSIM_DEVICE_NAME) + (nameSize - sizeof(WCHAR)))) {
        Irp->IoStatus.Information = sizeof(SPSIM_DEVICE_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    source = argument->Data;
    dest = name->DeviceName;
    while(*source) {
        *dest++ = (WCHAR) *source++;
    }
    *dest = UNICODE_NULL;
    Irp->IoStatus.Information = sizeof(SPSIM_DEVICE_NAME) - sizeof(WCHAR) +
        nameSize;
    return STATUS_SUCCESS;
}
NTSTATUS
SpSimGetManagedDevicesIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PACPI_METHOD_ARGUMENT argument;    
    PSPSIM_MANAGED_DEVICES managed;
    ULONG i, outputSize;
    PUCHAR current;
    NTSTATUS status;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SPSIM_MANAGED_DEVICES)) {
        return STATUS_INVALID_PARAMETER;
    }

    managed = Irp->AssociatedIrp.SystemBuffer;
    managed->Count = SpSim->StaCount;

    outputSize = (sizeof(SPSIM_MANAGED_DEVICES) - sizeof(UCHAR)) +
        SpSim->StaCount * sizeof(UCHAR);

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < outputSize) {
        Irp->IoStatus.Information = sizeof(SPSIM_MANAGED_DEVICES);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(managed->StaValues,
                  SpSim->StaOpRegionValues,
                  SpSim->StaCount);
    
    Irp->IoStatus.Information = outputSize;
    return STATUS_SUCCESS;
}

NTSTATUS
SpSimStaOpRegionReadWrite(
    PSPSIM_EXTENSION SpSim,
    ULONG AccessType,
    ULONG Offset,
    ULONG Size,
    PUCHAR Data
    )
{
    ULONG i;
    PUCHAR current;

    if (SpSim->StaOpRegionValues == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Offset >= SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Offset + Size > SpSim->StaCount) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(Offset < SpSim->StaCount);

    current = SpSim->StaOpRegionValues + Offset;

    if (AccessType & ACPI_OPREGION_WRITE) {
        for (i = 0 ; i < Size; i++) {
            *current++ = *Data++;
        }
    } else {
        for (i = 0 ; i < Size; i++) {
            *Data++ = *current++;
        }
    }
    return STATUS_SUCCESS;
}
    

NTSTATUS
EXPORT
SpSimStaOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    )
/*++

Routine Description:

	 This routine handles requests to service the 
	 SPSIM operation region contained within this driver

Arguments:

	 AccessType          - Read or Write data
	 OpRegion            - Operation region object
	 Address             - Address within the EC address space
	 Size                - Number of bytes to transfer
	 Data                - Data buffer to transfer to/from
	 Context             - SpSim
	 CompletionHandler   - AMLI handler to call when operation is complete
	 CompletionContext   - Context to pass to the AMLI handler

Return Value:

	 Status

--*/
{
    NTSTATUS status;

    status = SpSimStaOpRegionReadWrite((PSPSIM_EXTENSION) Context,
                                       AccessType,
                                       Address,
                                       Size,
                                       (PUCHAR)Data);
    return status;
}

NTSTATUS
SpSimInstallStaOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	This calls the ACPI driver to install itself as the op region
	handler for the STA region.  It also allocates the memory for the
	opregion itself.

Arguments:

	pSpSimData      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS                                status;

    status=RegisterOpRegionHandler (
        SpSim->AttachedDevice,
        ACPI_OPREGION_ACCESS_AS_COOKED,
        STA_OPREGION,
        SpSimStaOpRegionHandler,
        SpSim,
        0,
        &SpSim->StaOpRegion
        );

    //
    // Check the status code
    //
    if(!NT_SUCCESS(status)) {
        SpSim->StaOpRegion = NULL;
        DbgPrint("Not successful in installing:=%x\n", status);
        return status;
    }

    // XXXX

    return STATUS_SUCCESS;
}

NTSTATUS
SpSimRemoveStaOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    )
/*++

Routine Description:

	Uninstalls itself as the opregion handler.  

Arguments:

	SpSim      - Pointer to the SpSim extension

Return Value:

	Status

--*/
{
    NTSTATUS status;
    PIRP irp;

    if (SpSim->StaOpRegion != NULL) {
        status = DeRegisterOpRegionHandler (
            SpSim->AttachedDevice,
            SpSim->StaOpRegion
            );
        SpSim->StaOpRegion = NULL;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
SpSimAccessStaIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    )
{
    PSPSIM_ACCESS_STA access;
    NTSTATUS status;
    ULONG accessType;

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SpSim->StaNames == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SPSIM_ACCESS_STA)) {
        return STATUS_INVALID_PARAMETER;
    }

    access = Irp->AssociatedIrp.SystemBuffer;
    accessType = access->WriteOperation ? ACPI_OPREGION_WRITE :
        ACPI_OPREGION_READ;
    status = SpSimStaOpRegionReadWrite(SpSim,
                                       accessType,
                                       access->Device,
                                       sizeof(UCHAR),
                                       &access->StaValue);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(SPSIM_ACCESS_STA);
    } else {
        Irp->IoStatus.Information = 0;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\spsim\driver\spsim.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    local.h

Abstract:

    This header declares the stuctures and function prototypes shared between
    the various modules.

Author:

    Adam Glass

Revision History:

--*/


#if !defined(_SPSIM_H_)
#define _SPSIM_H_

#include <wdm.h>
#include <acpiioct.h>
#include <acpimsft.h>
#include "oprghdlr.h"
#include "debug.h"

//
// --- Constants ---
//

//
// These must be updated if any new PNP or PO irps are added
//

// XXX fix
#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_SURPRISE_REMOVAL
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Device state flags
//

#define SPSIM_DEVICE_STARTED               0x00000001
#define SPSIM_DEVICE_REMOVED               0x00000002
#define SPSIM_DEVICE_ENUMERATED            0x00000004
#define SPSIM_DEVICE_REMOVE_PENDING        0x00000008 /* DEPRECATED */
#define SPSIM_DEVICE_STOP_PENDING          0x00000010 /* DEPRECATED */
#define SPSIM_DEVICE_DELETED               0x00000080
#define SPSIM_DEVICE_SURPRISE_REMOVED      0x00000100

//
// --- Type definitions ---
//

typedef
NTSTATUS
(*PSPSIM_DISPATCH)(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

typedef struct {
    ULONG Addr;
    ULONG Length;
} MEM_REGION_DESCRIPTOR, *PMEM_REGION_DESCRIPTOR;
    
typedef struct  {

    //
    // Flags to indicate the device's current state (use SPSIM_DEVICE_*)
    //
    ULONG DeviceState;

    //
    // The power state of the device
    //
    DEVICE_POWER_STATE PowerState;
    DEVICE_POWER_STATE DeviceStateMapping[PowerSystemMaximum];

    //
    // Backpointer to the device object of whom we are the extension
    //
    PDEVICE_OBJECT Self;

    //
    // The PDO for the multi-function device
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The next device in the stack who we should send our IRPs down to
    //
    PDEVICE_OBJECT AttachedDevice;

    PVOID StaOpRegion;
    ULONG StaCount;
    ACPI_EVAL_OUTPUT_BUFFER *StaNames;
    PUCHAR StaOpRegionValues;

    PVOID MemOpRegion;
    ULONG MemCount;
    PMEM_REGION_DESCRIPTOR MemOpRegionValues;

    UNICODE_STRING SymbolicLinkName;

    //
    // Remove lock.  Used to prevent the FDO from being removed while
    // other operations are digging around in the extension.
    //

    IO_REMOVE_LOCK RemoveLock;

} SPSIM_EXTENSION, *PSPSIM_EXTENSION;


//
// --- Globals ---
//

extern PDRIVER_OBJECT SpSimDriverObject;

NTSTATUS
SpSimCreateFdo(
    PDEVICE_OBJECT *Fdo
    );

NTSTATUS
SpSimDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
SpSimDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPSIM_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );


NTSTATUS
SpSimAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
SpSimDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS                           
SpSimDevControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimInstallStaOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimRemoveStaOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimInstallMemOpRegionHandler(
    IN OUT    PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimRemoveMemOpRegionHandler (
    IN OUT PSPSIM_EXTENSION SpSim
    );

#define SPSIM_STA_NAMES_METHOD (ULONG)'MANS'
#define SPSIM_NOTIFY_DEVICE_METHOD (ULONG)'DFON'

NTSTATUS
SpSimCreateStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

VOID
SpSimDeleteStaOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimCreateMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

VOID
SpSimDeleteMemOpRegion(
    IN PSPSIM_EXTENSION SpSim
    );

NTSTATUS
SpSimSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSTATUS
EXPORT
SpSimStaOpRegionHandler (
    ULONG                   AccessType,
    PVOID                   OpRegion,
    ULONG                   Address,
    ULONG                   Size,
    PULONG                  Data,
    ULONG_PTR               Context,
    PACPI_OPREGION_CALLBACK CompletionHandler,
    PVOID                   CompletionContext
    );

NTSTATUS
SpSimOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSimGetManagedDevicesIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimAccessStaIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimGetDeviceName(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimNotifyDeviceIoctl(
    PSPSIM_EXTENSION SpSim,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
SpSimPassIrp(
    IN PIRP Irp,
    IN PSPSIM_EXTENSION SpSim,
    IN PIO_STACK_LOCATION IrpStack
    );

#define STA_OPREGION 0x99
#define MEM_OPREGION 0x9A
#define MAX_MEMORY_OBJ 8
#define MAX_MEMORY_DESC_PER_OBJ 1

#define MIN_LARGE_DESC 32*1024*1024

#endif // !defined(_SPSIM_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\function.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    function.h

Abstract:

    Functions which are OpCode specific

Author:

    Stephane Plante

Environment:


    Any

Revision History:

--*/

#ifndef _FUNCTION_H_
#define _FUNCTION_H_

    NTSTATUS
    FunctionField(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    FunctionScope(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    FunctionTest(
        IN  PSTACK  *Stack
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\data.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data file for AML

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// Name Space Modifiers
//
UNASM_AMLTERM
    atAlias = {
        "Alias",            OP_ALIAS,       "NN",     TC_NAMESPACE_MODIFIER, OF_NORMAL_OBJECT,                      NULL
        },
    atName = {
        "Name",             OP_NAME,        "NO",     TC_NAMESPACE_MODIFIER, OF_NORMAL_OBJECT,                      NULL
        },
    atScope = {
        "Scope",            OP_SCOPE,       "N",      TC_NAMESPACE_MODIFIER, OF_VARIABLE_LIST,                      FunctionScope
        };

//
// Named Object Creators
//
UNASM_AMLTERM
    atBankField = {
        "BankField",        OP_BANKFIELD,   "NNCB",   TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atDevice = {
        "Device",           OP_DEVICE,      "N",      TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atEvent = {
        "Event",            OP_EVENT,       "N",      TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atField = {
        "Field",            OP_FIELD,       "NB",     TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atIndexField = {
        "IndexField",       OP_IDXFIELD,    "NNB",    TC_NAMED_OBJECT,       OF_VARIABLE_LIST|OF_UNASM_FIELDLIST,   FunctionField
        },
    atMethod = {
        "Method",           OP_METHOD,      "NB",     TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atMutex = {
        "Mutex",            OP_MUTEX,       "NB",     TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atOpRegion = {
        "OperationRegion",  OP_OPREGION,    "NBCC",   TC_NAMED_OBJECT,       OF_NORMAL_OBJECT,                      NULL
        },
    atPowerRes = {
        "PowerResource",    OP_POWERRES,    "NBW",    TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        },
    atProcessor = {
        "Processor",        OP_PROCESSOR,   "NBDB",   TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      NULL
        },
    atThermalZone = {
        "ThermalZone",      OP_THERMALZONE, "N",      TC_NAMED_OBJECT,       OF_VARIABLE_LIST,                      FunctionScope
        };

    //
    // Type 1 Opcodes
    //
UNASM_AMLTERM
    atBreak = {
        "Break",            OP_BREAK,       NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atBreakPoint = {
        "BreakPoint",       OP_BREAKPOINT,  NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atBitField = {
        "CreateBitField",   OP_BITFIELD,    "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atByteField = {
        "CreateByteField",  OP_BYTEFIELD,   "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atDWordField = {
        "CreateDWordField", OP_DWORDFIELD,  "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atCreateField = {
        "CreateField",      OP_CREATEFIELD, "CCCN",   TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atWordField = {
        "CreateWordField",  OP_WORDFIELD,   "CCN",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atCondRefOf = {
        "CondRefOf",        OP_CONDREFOF,   "SS",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atElse = {
        "Else",             OP_ELSE,        NULL,     TC_OPCODE_TYPE1,       OF_VARIABLE_LIST|OF_PROCESS_UNASM,     FunctionScope
        },
    atFatal = {
        "Fatal",            OP_FATAL,       "BDC",    TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atIf = {
        "If",               OP_IF,          "C",      TC_OPCODE_TYPE1,       OF_VARIABLE_LIST|OF_PROCESS_UNASM,     FunctionScope
        },
    atLoad = {
        "Load",             OP_LOAD,        "NS",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atNOP = {
        "NoOp",             OP_NOP,         NULL,     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atNotify = {
        "Notify",           OP_NOTIFY,      "SC",     TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atRelease = {
        "Release",          OP_RELEASE,     "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atReset = {
        "Reset",            OP_RESET,       "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atReturn = {
        "Return",           OP_RETURN,      "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atSignal = {
        "Signal",           OP_SIGNAL,      "S",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atSleep = {
        "Sleep",            OP_SLEEP,       "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atStall = {
        "Stall",            OP_STALL,       "C",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atUnload = {
        "Unload",           OP_UNLOAD,      "N",      TC_OPCODE_TYPE1,       OF_NORMAL_OBJECT,                      NULL
        },
    atWhile = {
        "While",            OP_WHILE,       "C",      TC_OPCODE_TYPE1,       OF_VARIABLE_LIST,                      FunctionScope
        };

    //
    // Type 2 Opcodes
    //
UNASM_AMLTERM
    atAcquire = {
        "Acquire",          OP_ACQUIRE,     "SW",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atAdd = {
        "Add",              OP_ADD,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atAnd = {
        "And",              OP_AND,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atConcat = {
        "Concatenate",      OP_CONCAT,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDecrement = {
        "Decrement",        OP_DECREMENT,   "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDerefOf = {
        "DerefOf",          OP_DEREFOF,     "C",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atDivide = {
        "Divide",           OP_DIVIDE,      "CCSS",   TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFindSetLBit = {
        "FindSetLeftBit",   OP_FINDSETLBIT, "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFindSetRBit = {
        "FindSetRightBit",  OP_FINDSETRBIT, "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atFromBCD = {
        "FromBCD",          OP_FROMBCD,     "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atIncrement = {
        "Increment",        OP_INCREMENT,   "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atIndex = {
        "Index",            OP_INDEX,       "CCS",    TC_OPCODE_TYPE2,       OF_REF_OBJECT,                         NULL
        },
    atLAnd = {
        "LAnd",             OP_LAND,        "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLEq = {
        "LEqual",           OP_LEQ,         "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLG = {
        "LGreater",         OP_LG,          "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLL = {
        "LLess",            OP_LL,          "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLNot = {
        "LNot",             OP_LNOT,        "C",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atLOr = {
        "LOr",              OP_LOR,         "CC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atMatch = {
        "Match",            OP_MATCH,       "CCCCCC", TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atMultiply = {
        "Multiply",         OP_MULTIPLY,    "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNAnd = {
        "NAnd",             OP_NAND,        "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNOr = {
        "NOr",              OP_NOR,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atNot = {
        "Not",              OP_NOT,         "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atObjType = {
        "ObjectType",       OP_OBJTYPE,     "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atOr = {
        "Or",               OP_OR,          "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atRefOf = {
        "RefOf",            OP_REFOF,       "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atShiftLeft = {
        "ShiftLeft",        OP_SHIFTL,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atShiftRight = {
        "ShiftRight",       OP_SHIFTR,      "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atSizeOf = {
        "SizeOf",           OP_SIZEOF,      "S",      TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atStore = {
        "Store",            OP_STORE,       "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atSubtract = {
        "Subtract",         OP_SUBTRACT,    "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atToBCD = {
        "ToBCD",            OP_TOBCD,       "CS",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atWait = {
        "Wait",             OP_WAIT,        "SC",     TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        },
    atXOr = {
        "XOr",              OP_XOR,         "CCS",    TC_OPCODE_TYPE2,       OF_NORMAL_OBJECT,                      NULL
        };

    //
    // Misc. Opcodes
    //
UNASM_AMLTERM
    atNameObj = {
        "NameObj",          OP_NONE,        NULL,     TC_OTHER,              OF_NAME_OBJECT,                        NULL
        },
    atDataObj = {
        "DataObj",          OP_NONE,        NULL,     TC_OTHER,              OF_DATA_OBJECT,                        NULL
        },
    atConstObj = {
        "ConstObj",         OP_NONE,        NULL,     TC_OTHER,              OF_CONST_OBJECT,                       NULL
        },
    atArgObj = {
        "ArgObj",           OP_NONE,        NULL,     TC_OTHER,              OF_ARG_OBJECT,                         NULL
        },
    atLocalObj = {
        "LocalObj",         OP_NONE,        NULL,     TC_OTHER,              OF_LOCAL_OBJECT,                       NULL
        },
    atDebugObj = {
        "Debug",            OP_DEBUG,       NULL,     TC_OTHER,              OF_DEBUG_OBJECT,                       NULL
        };

PUNASM_AMLTERM OpcodeTable[256] =
{ //0x00                0x01                0x02                0x03
    &atConstObj,        &atConstObj,        NULL,               NULL,
  //0x04                0x05                0x06                0x07
    NULL,               NULL,               &atAlias,           NULL,
  //0x08                0x09                0x0a                0x0b
    &atName,            NULL,               &atDataObj,         &atDataObj,
  //0x0c                0x0d                0x0e                0x0f
    &atDataObj,         &atDataObj,         NULL,               NULL,
  //0x10                0x11                0x12                0x13
    &atScope,           &atDataObj,         &atDataObj,         NULL,
  //0x14                0x15                0x16                0x17
    &atMethod,          NULL,               NULL,               NULL,
  //0x18                0x19                0x1a                0x1b
    NULL,               NULL,               NULL,               NULL,
  //0x1c                0x1d                0x1e                0x1f
    NULL,               NULL,               NULL,               NULL,
  //0x20                0x21                0x22                0x23
    NULL,               NULL,               NULL,               NULL,
  //0x24                0x25                0x26                0x27
    NULL,               NULL,               NULL,               NULL,
  //0x28                0x29                0x2a                0x2b
    NULL,               NULL,               NULL,               NULL,
  //0x2c                0x2d                0x2e                0x2f
    NULL,               NULL,               &atNameObj,         &atNameObj,
  //0x30                0x31                0x32                0x33
    NULL,               NULL,               NULL,               NULL,
  //0x34                0x35                0x36                0x37
    NULL,               NULL,               NULL,               NULL,
  //0x38                0x39                0x3a                0x3b
    NULL,               NULL,               NULL,               NULL,
  //0x3c                0x3d                0x3e                0x3f
    NULL,               NULL,               NULL,               NULL,
  //0x40                0x41                0x42                0x43
    NULL,               &atNameObj,         &atNameObj,         &atNameObj,
  //0x44                0x45                0x46                0x47
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x48                0x49                0x4a                0x4b
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x4c                0x4d                0x4e                0x4f
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x50                0x51                0x52                0x53
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x54                0x55                0x56                0x57
    &atNameObj,         &atNameObj,         &atNameObj,         &atNameObj,
  //0x58                0x59                0x5a                0x5b
    &atNameObj,         &atNameObj,         &atNameObj,         NULL,
  //0x5c                0x5d                0x5e                0x5f
    &atNameObj,         NULL,               &atNameObj,         &atNameObj,
  //0x60                0x61                0x62                0x63
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x64                0x65                0x66                0x67
    &atLocalObj,        &atLocalObj,        &atLocalObj,        &atLocalObj,
  //0x68                0x69                0x6a                0x6b
    &atArgObj,          &atArgObj,          &atArgObj,          &atArgObj,
  //0x6c                0x6d                0x6e                0x6f
    &atArgObj,          &atArgObj,          &atArgObj,          NULL,
  //0x70                0x71                0x72                0x73
    &atStore,           &atRefOf,           &atAdd,             &atConcat,
  //0x74                0x75                0x76                0x77
    &atSubtract,        &atIncrement,       &atDecrement,       &atMultiply,
  //0x78                0x79                0x7a                0x7b
    &atDivide,          &atShiftLeft,       &atShiftRight,      &atAnd,
  //0x7c                0x7d                0x7e                0x7f
    &atNAnd,            &atOr,              &atNOr,             &atXOr,
  //0x80                0x81                0x82                0x83
    &atNot,             &atFindSetLBit,     &atFindSetRBit,     &atDerefOf,
  //0x84                0x85                0x86                0x87
    NULL,               NULL,               &atNotify,          &atSizeOf,
  //0x88                0x89                0x8a                0x8b
    &atIndex,           &atMatch,           &atDWordField,      &atWordField,
  //0x8c                0x8d                0x8e                0x8f
    &atByteField,       &atBitField,        &atObjType,         NULL,
  //0x90                0x91                0x92                0x93
    &atLAnd,            &atLOr,             &atLNot,            &atLEq,
  //0x94                0x95                0x96                0x97
    &atLG,              &atLL,              NULL,               NULL,
  //0x98                0x99                0x9a                0x9b
    NULL,               NULL,               NULL,               NULL,
  //0x9c                0x9d                0x9e                0x9f
    NULL,               NULL,               NULL,               NULL,
  //0xa0                0xa1                0xa2                0xa3
    &atIf,              &atElse,            &atWhile,           &atNOP,
  //0xa4                0xa5                0xa6                0xa7
    &atReturn,          &atBreak,           NULL,               NULL,
  //0xa8                0xa9                0xaa                0xab
    NULL,               NULL,               NULL,               NULL,
  //0xac                0xad                0xae                0xaf
    NULL,               NULL,               NULL,               NULL,
  //0xb0                0xb1                0xb2                0xb3
    NULL,               NULL,               NULL,               NULL,
  //0xb4                0xb5                0xb6                0xb7
    NULL,               NULL,               NULL,               NULL,
  //0xb8                0xb9                0xba                0xbb
    NULL,               NULL,               NULL,               NULL,
  //0xbc                0xbd                0xbe                0xbf
    NULL,               NULL,               NULL,               NULL,
  //0xc0                0xc1                0xc2                0xc3
    NULL,               NULL,               NULL,               NULL,
  //0xc4                0xc5                0xc6                0xc7
    NULL,               NULL,               NULL,               NULL,
  //0xc8                0xc9                0xca                0xcb
    NULL,               NULL,               NULL,               NULL,
  //0xcc                0xcd                0xce                0xcf
    &atBreakPoint,      NULL,               NULL,               NULL,
  //0xd0                0xd1                0xd2                0xd3
    NULL,               NULL,               NULL,               NULL,
  //0xd4                0xd5                0xd6                0xd7
    NULL,               NULL,               NULL,               NULL,
  //0xd8                0xd9                0xda                0xdb
    NULL,               NULL,               NULL,               NULL,
  //0xdc                0xdd                0xde                0xdf
    NULL,               NULL,               NULL,               NULL,
  //0xe0                0xe1                0xe2                0xe3
    NULL,               NULL,               NULL,               NULL,
  //0xe4                0xe5                0xe6                0xe7
    NULL,               NULL,               NULL,               NULL,
  //0xe8                0xe9                0xea                0xeb
    NULL,               NULL,               NULL,               NULL,
  //0xec                0xed                0xee                0xef
    NULL,               NULL,               NULL,               NULL,
  //0xf0                0xf1                0xf2                0xf3
    NULL,               NULL,               NULL,               NULL,
  //0xf4                0xf5                0xf6                0xf7
    NULL,               NULL,               NULL,               NULL,
  //0xf8                0xf9                0xfa                0xfb
    NULL,               NULL,               NULL,               NULL,
  //0xfc                0xfd                0xfe                0xff
    NULL,               NULL,               NULL,               &atConstObj
};

UNASM_OPCODEMAP ExOpcodeTable[] =
{
    EXOP_MUTEX,         &atMutex,
    EXOP_EVENT,         &atEvent,
    EXOP_CONDREFOF,     &atCondRefOf,
    EXOP_CREATEFIELD,   &atCreateField,
    EXOP_LOAD,          &atLoad,
    EXOP_STALL,         &atStall,
    EXOP_SLEEP,         &atSleep,
    EXOP_ACQUIRE,       &atAcquire,
    EXOP_SIGNAL,        &atSignal,
    EXOP_WAIT,          &atWait,
    EXOP_RESET,         &atReset,
    EXOP_RELEASE,       &atRelease,
    EXOP_FROMBCD,       &atFromBCD,
    EXOP_TOBCD,         &atToBCD,
    EXOP_UNLOAD,        &atUnload,
    EXOP_REVISION,      &atConstObj,
    EXOP_DEBUG,         &atDebugObj,
    EXOP_FATAL,         &atFatal,
    EXOP_OPREGION,      &atOpRegion,
    EXOP_FIELD,         &atField,
    EXOP_DEVICE,        &atDevice,
    EXOP_PROCESSOR,     &atProcessor,
    EXOP_POWERRES,      &atPowerRes,
    EXOP_THERMALZONE,   &atThermalZone,
    EXOP_IDXFIELD,      &atIndexField,
    EXOP_BANKFIELD,     &atBankField,
    0,                  NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\parser.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parser.h

Abstract:

    The header for the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _PARSER_H_
#define _PARSER_H_

    NTSTATUS
    ParseArgument(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseArgumentObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseBuffer(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseByte(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseCodeObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseConstObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseData(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseDelimiter(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseDWord(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseField(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseFunctionHandler(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseLocalObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseName(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseNameObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseOpcode(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePackage(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePop(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParsePush(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseScope(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseSuperName(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingArgument(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingBuffer(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseTrailingPackage(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseVariableObject(
        IN  PSTACK  *Stack
        );

    NTSTATUS
    ParseWord(
        IN  PSTACK  *Stack
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\function.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    function.c

Abstract:

    Functions which are OpCode specific

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

NTSTATUS
FunctionField(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML term 'IfElse'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    //
    // Step 1: Push a new scope
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS( status )) {

        return status;

    }

    //
    // Step 2: Find the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 3: Program the parameters for the new scope
    //
    localScope->IndentLevel += 2;

    //
    // Step 4: Remember to pop this scope
    //
    action = SC_PARSE_POP;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Schedule a call to the field handler
    //
    action = SC_PARSE_FIELD;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 6:
    //
    return STATUS_SUCCESS;
}

NTSTATUS
FunctionScope(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML Term 'Scope'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Push a new scope
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS( status )) {

        return status;

    }

    //
    // Step 2: Find the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 3: Program the parameters for the new scope
    //
    localScope->IndentLevel += 2;

    //
    // Step 4: Remember to pop this scope
    //
    action = SC_PARSE_POP;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Next action is to parse an opcode...
    //
    action = SC_PARSE_OPCODE;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
FunctionTest(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function is the handler for the AML Term 'Scope'

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    return FunctionScope( Stack );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\external.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    external.h

Abstract:

    This contains the protypes for the functions which
    are outside of the current library

Author:

    Stephane Plante

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _EXTERNAL_H_
#define _EXTERNAL_H_

    extern
    PVOID
    MEMORY_ALLOCATE(
        ULONG   Num
        );

    extern
    VOID
    MEMORY_COPY(
        PVOID   Dest,
        PVOID   Src,
        ULONG   Length
        );

    extern
    VOID
    MEMORY_FREE(
        PVOID   Dest
        );
    
    extern
    VOID
    MEMORY_SET(
        PVOID   Src,
        UCHAR   Value,
        ULONG   Length
        );

    extern
    VOID
    MEMORY_ZERO(
        PVOID   Src,
        ULONG   Length
        );

    extern
    VOID
    PRINTF(
        PUCHAR  String,
        ...
        );

    extern
    ULONG
    STRING_LENGTH(
        PUCHAR  String
        );

    extern
    VOID
    STRING_PRINT(
        PUCHAR  Buffer,
        PUCHAR  String,
        ...
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\data.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Data file for AML

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _DATA_H_
#define _DATA_H_

    #define STACK_GROWTH_RATE   8
    #define STACK_SIGNATURE     '_SGP'

    #define STRING_GROWTH_RATE  32
    #define STRING_SIGNATURE    ')SGP'

    //
    // This is the size of an individual name segment
    //
    #define NAMESEG  ULONG

    //
    // This is for the ArgumentType Table
    //
    #define ARGTYPE_NAME            'N'
    #define ARGTYPE_DATAOBJECT      'O'
    #define ARGTYPE_DWORD           'D'
    #define ARGTYPE_WORD            'W'
    #define ARGTYPE_BYTE            'B'
    #define ARGTYPE_SUPERNAME       'S'
    #define ARGTYPE_OPCODE          'C'

    //
    // This is for the term group table
    //
    #define TC_NAMESPACE_MODIFIER   0x01
    #define TC_NAMED_OBJECT         0x02
    #define TC_OPCODE_TYPE1         0x03
    #define TC_OPCODE_TYPE2         0x04
    #define TC_OTHER                0x05

    //
    // Opcode Flag table
    //
    #define OF_NORMAL_OBJECT        0x00000000
    #define OF_VARIABLE_LIST        0x00000001
    #define OF_ARG_OBJECT           0x00000002
    #define OF_LOCAL_OBJECT         0x00000003
    #define OF_CONST_OBJECT         0x00000004
    #define OF_NAME_OBJECT          0x00000005
    #define OF_DATA_OBJECT          0x00000006
    #define OF_DEBUG_OBJECT         0x00000007
    #define OF_REF_OBJECT           0x00000008
    #define OF_PROCESS_UNASM        0x00000000
    #define OF_UNASM_FIELDLIST      0x00000000

    //
    // Scope Flags
    //
    #define SC_FLAG_NESTED          0x00000001

    //
    // These are the various values allowed for the states
    //
    #define SC_FUNCTION_HANDLER         0x00
    #define SC_PARSE_ARGUMENT           0x01
    #define SC_PARSE_ARGUMENT_OBJECT    0x02
    #define SC_PARSE_BUFFER             0x03
    #define SC_PARSE_BYTE               0x04
    #define SC_PARSE_CODE_OBJECT        0x05
    #define SC_PARSE_CONST_OBJECT       0x06
    #define SC_PARSE_DATA               0x07
    #define SC_PARSE_DELIMITER          0x08
    #define SC_PARSE_DWORD              0x09
    #define SC_PARSE_FIELD              0x0A
    #define SC_PARSE_LOCAL_OBJECT       0x0B
    #define SC_PARSE_NAME               0x0C
    #define SC_PARSE_NAME_OBJECT        0x0D
    #define SC_PARSE_OPCODE             0x0E
    #define SC_PARSE_PACKAGE            0x0F
    #define SC_PARSE_POP                0x10
    #define SC_PARSE_PUSH               0x11
    #define SC_PARSE_SUPER_NAME         0x12
    #define SC_PARSE_TRAILING_ARGUMENT  0x13
    #define SC_PARSE_TRAILING_BUFFER    0x14
    #define SC_PARSE_TRAILING_PACKAGE   0x15
    #define SC_PARSE_VARIABLE_OBJECT    0x16
    #define SC_PARSE_WORD               0x17
    #define SC_MAX_TABLE                0x18


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\parser.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parser.c

Abstract:

    The aml parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// This is a dispatch table
//
typedef NTSTATUS (*PARSE_STATE_FUNCTION) (PSTACK *Stack);
PARSE_STATE_FUNCTION ScopeStates[] = {
    ParseFunctionHandler,
    ParseArgument,
    ParseArgumentObject,
    ParseBuffer,
    ParseByte,
    ParseCodeObject,
    ParseConstObject,
    ParseData,
    ParseDelimiter,
    ParseDWord,
    ParseField,
    ParseLocalObject,
    ParseName,
    ParseNameObject,
    ParseOpcode,
    ParsePackage,
    ParsePop,
    ParsePush,
    ParseSuperName,
    ParseTrailingArgument,
    ParseTrailingBuffer,
    ParseTrailingPackage,
    ParseVariableObject,
    ParseWord
    };

NTSTATUS
ParseArgument(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine parses the arguments to a function

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_AMLTERM        amlTerm;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Get the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we still need to process arguments?
    //
    amlTerm = localScope->AmlTerm;
    if ( localScope->Context1 == 0) {

        UCHAR   actionList[2] = {
                    SC_PARSE_ARGUMENT,
                    SC_PARSE_DELIMITER
                    };
        ULONG   i;

        //
        // Step 2.1.1: Push an opening "(" onto the stack
        //
        StringStackPush( &(rootScope->StringStack), 1, "(" );

        //
        // Step 2.1.2: Make sure to call the thing to handle the trailing
        // argument
        //
        action = SC_PARSE_TRAILING_ARGUMENT;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 2.1.3: This is the first that we have seen of the argument
        // Determine the number of bytes to process
        //
        localScope->Context2 = STRING_LENGTH( amlTerm->ArgumentTypes );

        //
        // Step 2.1.4: Setup the stack with the appropriate number of
        // calls to this function.
        //
        if (localScope->Context2 >= 2) {

            for (i = 0; i < localScope->Context2 - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }

    } else if ( localScope->Context1 >= localScope->Context2 ) {

        //
        // Step 2.2.1: BAD!!
        //
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 3: Handle the current argument
    //
    switch( amlTerm->ArgumentTypes[ localScope->Context1 ] ) {
    case ARGTYPE_NAME:

        action = SC_PARSE_NAME;
        break;

    case ARGTYPE_DATAOBJECT:

        action = SC_PARSE_DATA;
        break;

    case ARGTYPE_WORD:

        action = SC_PARSE_WORD;
        break;

    case ARGTYPE_DWORD:

        action = SC_PARSE_DWORD;
        break;

    case ARGTYPE_BYTE:

        action = SC_PARSE_BYTE;
        break;

    case ARGTYPE_SUPERNAME:

        action = SC_PARSE_SUPER_NAME;
        break;

    case ARGTYPE_OPCODE: {

        UCHAR   actionList[2] = {
            SC_PARSE_POP,
            SC_PARSE_OPCODE
        };

        //
        // Step 3.1: Increment the argument count
        //
        localScope->Context1++;

        //
        // Step 3.2: Set up what wee need next
        //
        StringStackPush( &(rootScope->ParseStack), 2, actionList );

        //
        // Step 3.3: Push a new scope
        //
        status = ParsePush( Stack );
        if (!NT_SUCCESS(status) ) {

            return status;

        }

        //
        // Step 3.4: Make sure to note that we are now nesting things
        //
        status = StackTop( Stack, &localScope );
        if (!NT_SUCCESS( status ) ) {

            return status;

        }
        localScope->Flags |= SC_FLAG_NESTED;

        //
        // Step 3.5: Done
        //
        return STATUS_SUCCESS;

    }
    default:

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Push the action onto the stack and setup for the next call
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );
    localScope->Context1++;

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseArgumentObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses and executes the ArgX instruction

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    CHAR            i;
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    UCHAR           buffer[5];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Find the string stack to use
    //
    stringStack = &(rootScope->StringStack);

    //
    // Step 3: Determine which argument we are looking at
    //
    i = *(localScope->CurrentByte) - OP_ARG0;
    if (i < 0 || i > 7) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Show the argument number to the user
    //
    STRING_PRINT( buffer, "Arg%1d", i );
    StringStackPush( stringStack, 4, buffer );

    //
    // Step 5: Setup for next state
    //
    localScope->CurrentByte++;

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseBuffer(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles buffers

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS;

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       actionList[2] = { SC_PARSE_BYTE, SC_PARSE_TRAILING_BUFFER };
    ULONG       numBytes;
    ULONG       i;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Determine the number of bytes that we have
    //
    numBytes = localScope->LastByte - localScope->CurrentByte + 1;
    if (numBytes) {

        //
        // Step 3: Push the leading delimiter
        //
        StringStackPush( &(rootScope->StringStack), 2, " {" );

        //
        // Step 4: This handles the last byte in the stream. We assume that
        // we have at least one byte otherwise we would not be here
        //
        StringStackPush( &(rootScope->ParseStack), 1, &(actionList[1]) );

        //
        // Make sure that we process the right number of bytes
        //
        actionList[1] = SC_PARSE_DELIMITER;
        if (numBytes > 1) {

            for (i = 0; i < numBytes - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }
        StringStackPush( &(rootScope->ParseStack),1, actionList );

    }

    //
    // Step 4: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseByte(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles bytes

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[6];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%02x", *(localScope->CurrentByte) );

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 1;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseCodeObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses code

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    UCHAR           action;
    ULONG           i;
    ULONG           len;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Grab the scope that we will process
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Push a token onto the string stack to present the term
    // name
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localScope->AmlTerm->TermName ),
        localScope->AmlTerm->TermName
        );

    //
    // Step 3: This is guaranteed to be called after all arguments are
    // parsed
    //
    action = SC_FUNCTION_HANDLER;
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 4: Determine if we have any arguments
    //
    if (localScope->AmlTerm->ArgumentTypes != NULL) {

        //
        // Step 4.1.1: Parse the Arguments
        //
        action = SC_PARSE_ARGUMENT;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 4.1.2: Make sure to start the argument index at zero
        //
        localScope->Context1 = localScope->Context2 = 0;

    }

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseConstObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This parses constants

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Find the string stack to use
    //
    stringStack = &(rootScope->StringStack);

    //
    // Step 3: Action depends on what the current byte value is:
    //
    switch ( *(localScope->CurrentByte) ) {
    case OP_ZERO:

        StringStackPush( stringStack, 4, "Zero" );
        break;

    case OP_ONE:

        StringStackPush( stringStack, 3, "One" );
        break;

    case OP_ONES:

        StringStackPush( stringStack, 4, "Ones" );
        break;

    case OP_REVISION:

        StringStackPush( stringStack, 8, "Revision" );
        break;

    default:

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Step 4: Done with the current byte
    //
    localScope->CurrentByte++;

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseData(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles data arguments

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;
    UCHAR           currentDataType;
    ULONG           i;
    ULONG           num;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Grab the current byte and decide what type of
    // data we are looking at based on that value
    //
    currentDataType = *(localScope->CurrentByte);
    localScope->CurrentByte++;
    switch( currentDataType ) {
    case OP_BYTE:

        action = SC_PARSE_BYTE;
        break;

    case OP_WORD:

        action = SC_PARSE_WORD;
        break;

    case OP_DWORD:

        action = SC_PARSE_DWORD;
        break;

    case OP_STRING:

        //
        // Step 2.2.1: Determine how long the string is
        //
        num = STRING_LENGTH( localScope->CurrentByte );

        //
        // Step 2.2.2: Push that number of bytes onto the string stack
        //
        StringStackPush( &(rootScope->StringStack), 1, "\"" );
        StringStackPush(
             &(rootScope->StringStack),
             num,
             localScope->CurrentByte
             );
        StringStackPush( &(rootScope->StringStack), 1, "\"" );

        //
        // Step 2.2.3: Update the current byte pointer and prepare for
        // next instructions
        //
        localScope->CurrentByte += (num + 1);

        //
        // Step 2.2.4: we don't have a next step, so we just return here
        //
        return STATUS_SUCCESS;

    case OP_BUFFER: {

        //
        // Step 2.1.1: This is an array of actions that we are about to
        // undertake. This reduces the number of calls to StringStackPush
        //
        UCHAR   actionList[4] = {
            SC_PARSE_POP,
            SC_PARSE_BUFFER,
            SC_PARSE_OPCODE,
            SC_PARSE_VARIABLE_OBJECT
        };

        //
        // Step 2.1.2: Push this array onto the stack
        //
        StringStackPush( &(rootScope->ParseStack), 4, actionList );

        //
        // Step 2.1.3: Display a name
        //
        StringStackPush( &(rootScope->StringStack), 7, "Buffer=");

        //
        // Step 2.1.3: Done
        //
        return STATUS_SUCCESS;

    }
    case OP_PACKAGE: {

        //
        // Step 2.3.1: Array of instructions to execute
        //
        UCHAR   actionList[3] = {
            SC_PARSE_POP,
            SC_PARSE_PACKAGE,
            SC_PARSE_VARIABLE_OBJECT
        };

        //
        // Step 2.3.2: Push those instructions onto the stack
        StringStackPush( &(rootScope->ParseStack), 3, actionList );

        //
        //
        // Step 2.3.3: Done
        //
        return STATUS_SUCCESS;

    }
    default:

        localScope->CurrentByte--;
        return STATUS_ILLEGAL_INSTRUCTION;

    }  // switch

    //
    // Step 3: Push action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action);

    //
    // Step 4: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseDelimiter(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is between elements. It is responsible for adding commas
    on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "," );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseDWord(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles double words

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[12];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%08x", *((PULONG)localScope->CurrentByte));

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 4;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseField(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This is the code that actually parses a field

Arguments:

    The current thread's stack

Return Value:

    None:

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;
    UCHAR       followBits;
    UCHAR       i;
    UCHAR       buffer