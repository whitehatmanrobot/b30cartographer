his,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL __RPC_FAR *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced2_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
    /* [out] */ QWORD __RPC_FAR *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_OpenStream_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced3_INTERFACE_DEFINED__
#define __IWMReaderAdvanced3_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100")
    IWMReaderAdvanced3 : public IWMReaderAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StopNetStreaming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtPosition( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopNetStreaming )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtPosition )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced3Vtbl;

    interface IWMReaderAdvanced3
    {
        CONST_VTBL struct IWMReaderAdvanced3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced3_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced3_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced3_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced3_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced3_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced3_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced3_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced3_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced3_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced3_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced3_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced3_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced3_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced3_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced3_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced3_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced3_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced3_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced3_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced3_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced3_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced3_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced3_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced3_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced3_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced3_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced3_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced3_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced3_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced3_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced3_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced3_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced3_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)


#define IWMReaderAdvanced3_StopNetStreaming(This)	\
    (This)->lpVtbl -> StopNetStreaming(This)

#define IWMReaderAdvanced3_StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StopNetStreaming_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced3_StopNetStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StartAtPosition_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ void __RPC_FAR *pvOffsetStart,
    /* [in] */ void __RPC_FAR *pvDuration,
    /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced3_StartAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStreamEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutputEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TryOutputProps )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSample )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTime )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSelection )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStream )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutput )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD __RPC_FAR *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireLicense )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Individualize )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelIndividualization )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD __RPC_FAR *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [out][in] */ DWORD __RPC_FAR *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszHostName,
    /* [out][in] */ DWORD __RPC_FAR *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
    /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD __RPC_FAR *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD __RPC_FAR *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD __RPC_FAR *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KillTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD __RPC_FAR *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void __RPC_FAR *pvParam,
    /* [out] */ DWORD __RPC_FAR *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer __RPC_FAR * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer __RPC_FAR * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BackupLicenses )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseBackup )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup __RPC_FAR * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreLicenses )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseRestore )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore __RPC_FAR * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD __RPC_FAR *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByIndex )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByName )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllProps )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD __RPC_FAR *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD __RPC_FAR *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo2_INTERFACE_DEFINED__
#define __IWMCodecInfo2_INTERFACE_DEFINED__

/* interface IWMCodecInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA65E273-B686-4056-91EC-DD768D4DF710")
    IWMCodecInfo2 : public IWMCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecName( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatDesc( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecName )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatDesc )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc);
        
        END_INTERFACE
    } IWMCodecInfo2Vtbl;

    interface IWMCodecInfo2
    {
        CONST_VTBL struct IWMCodecInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo2_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo2_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo2_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)


#define IWMCodecInfo2_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)

#define IWMCodecInfo2_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecName_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ WCHAR __RPC_FAR *wszName,
    /* [out] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMCodecInfo2_GetCodecName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecFormatDesc_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
    /* [out] */ WCHAR __RPC_FAR *wszDesc,
    /* [out][in] */ DWORD __RPC_FAR *pcchDesc);


void __RPC_STUB IWMCodecInfo2_GetCodecFormatDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmspacket.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmspacket.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmspacket_h__
#define __wmspacket_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSPacket_FWD_DEFINED__
#define __IWMSPacket_FWD_DEFINED__
typedef interface IWMSPacket IWMSPacket;
#endif 	/* __IWMSPacket_FWD_DEFINED__ */


#ifndef __IWMSPacketListCallback_FWD_DEFINED__
#define __IWMSPacketListCallback_FWD_DEFINED__
typedef interface IWMSPacketListCallback IWMSPacketListCallback;
#endif 	/* __IWMSPacketListCallback_FWD_DEFINED__ */


#ifndef __IWMSPacketList_FWD_DEFINED__
#define __IWMSPacketList_FWD_DEFINED__
typedef interface IWMSPacketList IWMSPacketList;
#endif 	/* __IWMSPacketList_FWD_DEFINED__ */


#ifndef __IWMSPacketParser_FWD_DEFINED__
#define __IWMSPacketParser_FWD_DEFINED__
typedef interface IWMSPacketParser IWMSPacketParser;
#endif 	/* __IWMSPacketParser_FWD_DEFINED__ */


#ifndef __IWMSStreamSignalHandler_FWD_DEFINED__
#define __IWMSStreamSignalHandler_FWD_DEFINED__
typedef interface IWMSStreamSignalHandler IWMSStreamSignalHandler;
#endif 	/* __IWMSStreamSignalHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "WMSBuffer.h"
#include "WMSContext.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmspacket_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from wmspacket.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSPacket, 0x3309C901,0x10A4,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSPacketList, 0x3309C902,0x10A4,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSPacketParser, 0x8b59f7e1, 0x5411, 0x11d2, 0x9e, 0xff, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSPacketListCallback, 0x49c2a6f1, 0x64b8, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSStreamSignalHandler, 0x7B10F261,0x26AA,0x11d2,0x9E,0xF2,0x00,0x60,0x97,0xD2,0xD7,0xCF );
typedef /* [public] */ 
enum WMS_PACKET_ATTRIBUTES
    {	WMS_PACKET_PACKET_NUM	= 0,
	WMS_PACKET_NUM_BUFFERS	= WMS_PACKET_PACKET_NUM + 1,
	WMS_PACKET_LENGTH	= WMS_PACKET_NUM_BUFFERS + 1,
	WMS_PACKET_SEND_TIME_HI	= WMS_PACKET_LENGTH + 1,
	WMS_PACKET_SEND_TIME	= WMS_PACKET_SEND_TIME_HI + 1,
	WMS_PACKET_STREAM_NUM	= WMS_PACKET_SEND_TIME + 1,
	WMS_PACKET_FLAGS	= WMS_PACKET_STREAM_NUM + 1,
	WMS_PACKET_NET_SEQUENCE_NUMBER	= WMS_PACKET_FLAGS + 1,
	WMS_PACKET_PRESENT_TIME_HI	= WMS_PACKET_NET_SEQUENCE_NUMBER + 1,
	WMS_PACKET_PRESENT_TIME	= WMS_PACKET_PRESENT_TIME_HI + 1,
	WMS_PACKET_RECV_TIME	= WMS_PACKET_PRESENT_TIME + 1,
	WMS_PACKET_NUM_NACKS	= WMS_PACKET_RECV_TIME + 1,
	WMS_PACKET_DURATION	= WMS_PACKET_NUM_NACKS + 1,
	WMS_PACKET_ERASURES_DETECTED	= WMS_PACKET_DURATION + 1,
	WMS_PACKET_SEND_TIME_ADJUSTMENT	= WMS_PACKET_ERASURES_DETECTED + 1,
	WMS_PACKET_PACKETIZED_HDRLEN	= WMS_PACKET_SEND_TIME_ADJUSTMENT + 1,
	WMS_LAST_PACKET_ATTRIBUTE	= WMS_PACKET_PACKETIZED_HDRLEN
    } 	WMS_PACKET_ATTRIBUTES;

typedef /* [public] */ 
enum WMS_PACKET_FLAG_TYPES
    {	WMS_KEY_FRAME_PACKET	= 0x1,
	WMS_RETRANSMITTED_PACKET	= 0x2,
	WMS_PACKET_REPORTED	= 0x4,
	WMS_PACKET_PACKETIZED	= 0x8,
	WMS_RECOVERED_PACKET	= 0x10,
	WMS_FEC_PACKET	= 0x20,
	WMS_FEC_ENCODED_PACKET	= 0x40,
	WMS_PACKET_BURST_FLAG	= 0x80,
	WMS_PACKET_FIRST_PAYLOAD_FLAG	= 0x100
    } 	WMS_PACKET_FLAG_TYPES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_ATTRIBUTES
    {	WMS_PACKET_LIST_FLAGS	= 0,
	WMS_STREAM_SIGNAL	= 1,
	WMS_PACKET_LIST_GENID	= 2,
	WMS_PACKET_LIST_SEND_TIME	= 3,
	WMS_PACKET_LIST_SEND_TIME_HI	= 4,
	WMS_PACKET_LIST_PLAYLIST_GEN_ID	= 5,
	WMS_LAST_PACKET_LIST_ATTRIBUTE	= WMS_PACKET_LIST_PLAYLIST_GEN_ID
    } 	WMS_PACKET_LIST_ATTRIBUTES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_FLAG_TYPES
    {	WMS_PACKET_LIST_NEEDS_FIXUP	= 0x1,
	WMS_PACKET_LIST_UDP_RESEND	= 0x2,
	WMS_PACKET_LIST_PRESTUFF	= 0x4,
	WMS_PACKET_LIST_PLAYLIST_CHANGE_RECEDING	= 0x8
    } 	WMS_PACKET_LIST_FLAG_TYPES;

typedef /* [public] */ 
enum WMS_PACKET_LIST_EX_FLAGS
    {	WMS_NO_ADDREF	= 0x80000000,
	WMS_PACKET_NO_ADDREF	= 0x80000000,
	WMS_PACKET_NO_RELEASE	= 0x40000000,
	WMS_PLIST_BUFFER_NO_ADDREF	= 0x80000000,
	WMS_PLIST_BUFFER_NO_RELEASE	= 0x40000000,
	WMS_PLIST_NO_ADDREF	= 0x80000000
    } 	WMS_PACKET_LIST_EX_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_BUFFER_FLAGS
    {	WMS_INSERT_BUFFER_AT_END	= 0xffffffff
    } 	WMS_PACKET_BUFFER_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_BUFFER_EX_FLAGS
    {	WMS_BUFFER_NO_ADDREF	= 0x80000000,
	WMS_BUFFER_NO_RELEASE	= 0x40000000,
	WMS_BUFFER_NO_REFCOUNT	= 0x20000000,
	WMS_BUFFER_COMBINE	= 0x10000000
    } 	WMS_PACKET_BUFFER_EX_FLAGS;

typedef /* [public] */ 
enum WMS_PACKET_STATUS_FLAGS
    {	WMS_START_NEXT_READ	= 0x1,
	WMS_WRITE_COMPLETED	= 0x2,
	WMS_REQUEST_BUFFER	= 0x4,
	WMS_HEADER_BUFFER	= 0x8
    } 	WMS_PACKET_STATUS_FLAGS;

typedef /* [public] */ 
enum WMS_PARSER_FLAG_TYPES
    {	WMS_PARSER_PRESERVE_PADDING	= 0x1
    } 	WMS_PARSER_FLAG_TYPES;

typedef unsigned __int64 QWORD;






extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0000_v0_0_s_ifspec;

#ifndef __IWMSPacket_INTERFACE_DEFINED__
#define __IWMSPacket_INTERFACE_DEFINED__

/* interface IWMSPacket */
/* [helpstring][version][uuid][unique][object] */ 

typedef /* [public][public] */ struct __MIDL_IWMSPacket_0001
    {
    INSSBuffer *pBuffer;
    DWORD dwBufferOffset;
    DWORD dwBufferLen;
    WORD wFlags;
    } 	WMSBUFFERDESC;


EXTERN_C const IID IID_IWMSPacket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3309C901-10A4-11d2-9EEE-006097D2D7CF")
    IWMSPacket : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAllBuffers( 
            /* [in] */ DWORD dwMaxNumBuffers,
            /* [out] */ WMSBUFFERDESC *pDesc,
            /* [out] */ DWORD *pdwNumBuffers,
            /* [in] */ DWORD dwExFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ DWORD dwBufferNum,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [out] */ DWORD *pdwBufferOffset,
            /* [out] */ DWORD *pdwBufferLen,
            /* [out] */ WORD *pwFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertBuffer( 
            /* [in] */ DWORD dwBufferNum,
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ DWORD dwBufferOffset,
            /* [in] */ DWORD dwBufferLen,
            /* [in] */ WORD wFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveBuffer( 
            /* [in] */ DWORD dwBufferNum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAllBuffers( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ DWORD *pdwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeCount( 
            /* [out] */ DWORD *pdwAttrs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyAttributes( 
            /* [in] */ IWMSPacket *pDest,
            /* [defaultvalue][in] */ DWORD *pdwAttrNames = 0,
            /* [defaultvalue][in] */ DWORD dwNumAttr = 0,
            /* [defaultvalue][in] */ BOOL fCopyExtAttr = FALSE) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendHeader( 
            /* [in] */ IWMSBufferAllocator *pAlloc,
            /* [in] */ DWORD dwHeaderLen,
            /* [in] */ BYTE *pbHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInHeader( 
            /* [in] */ DWORD cbOffset,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD cbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacket * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacket * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAllBuffers )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwMaxNumBuffers,
            /* [out] */ WMSBUFFERDESC *pDesc,
            /* [out] */ DWORD *pdwNumBuffers,
            /* [in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [out] */ DWORD *pdwBufferOffset,
            /* [out] */ DWORD *pdwBufferLen,
            /* [out] */ WORD *pwFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum,
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ DWORD dwBufferOffset,
            /* [in] */ DWORD dwBufferLen,
            /* [in] */ WORD wFlags,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveBuffer )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwBufferNum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAllBuffers )( 
            IWMSPacket * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ DWORD *pdwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeByIndex )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetExtendedAttribute )( 
            IWMSPacket * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeCount )( 
            IWMSPacket * This,
            /* [out] */ DWORD *pdwAttrs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyAttributes )( 
            IWMSPacket * This,
            /* [in] */ IWMSPacket *pDest,
            /* [defaultvalue][in] */ DWORD *pdwAttrNames,
            /* [defaultvalue][in] */ DWORD dwNumAttr,
            /* [defaultvalue][in] */ BOOL fCopyExtAttr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppendHeader )( 
            IWMSPacket * This,
            /* [in] */ IWMSBufferAllocator *pAlloc,
            /* [in] */ DWORD dwHeaderLen,
            /* [in] */ BYTE *pbHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInHeader )( 
            IWMSPacket * This,
            /* [in] */ DWORD cbOffset,
            /* [in] */ BYTE *pbData,
            /* [in] */ DWORD cbData);
        
        END_INTERFACE
    } IWMSPacketVtbl;

    interface IWMSPacket
    {
        CONST_VTBL struct IWMSPacketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacket_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPacket_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPacket_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPacket_GetAllBuffers(This,dwMaxNumBuffers,pDesc,pdwNumBuffers,dwExFlags)	\
    (This)->lpVtbl -> GetAllBuffers(This,dwMaxNumBuffers,pDesc,pdwNumBuffers,dwExFlags)

#define IWMSPacket_GetBuffer(This,dwBufferNum,ppBuffer,pdwBufferOffset,pdwBufferLen,pwFlags,dwExFlags)	\
    (This)->lpVtbl -> GetBuffer(This,dwBufferNum,ppBuffer,pdwBufferOffset,pdwBufferLen,pwFlags,dwExFlags)

#define IWMSPacket_InsertBuffer(This,dwBufferNum,pBuffer,dwBufferOffset,dwBufferLen,wFlags,dwExFlags)	\
    (This)->lpVtbl -> InsertBuffer(This,dwBufferNum,pBuffer,dwBufferOffset,dwBufferLen,wFlags,dwExFlags)

#define IWMSPacket_RemoveBuffer(This,dwBufferNum)	\
    (This)->lpVtbl -> RemoveBuffer(This,dwBufferNum)

#define IWMSPacket_RemoveAllBuffers(This)	\
    (This)->lpVtbl -> RemoveAllBuffers(This)

#define IWMSPacket_GetAttribute(This,dwValueName,pdwValue)	\
    (This)->lpVtbl -> GetAttribute(This,dwValueName,pdwValue)

#define IWMSPacket_SetAttribute(This,dwValueName,dwValue)	\
    (This)->lpVtbl -> SetAttribute(This,dwValueName,dwValue)

#define IWMSPacket_GetExtendedAttribute(This,dwValueName,pVariantValue)	\
    (This)->lpVtbl -> GetExtendedAttribute(This,dwValueName,pVariantValue)

#define IWMSPacket_GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)	\
    (This)->lpVtbl -> GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)

#define IWMSPacket_SetExtendedAttribute(This,dwValueName,VariantValue)	\
    (This)->lpVtbl -> SetExtendedAttribute(This,dwValueName,VariantValue)

#define IWMSPacket_GetExtendedAttributeCount(This,pdwAttrs)	\
    (This)->lpVtbl -> GetExtendedAttributeCount(This,pdwAttrs)

#define IWMSPacket_CopyAttributes(This,pDest,pdwAttrNames,dwNumAttr,fCopyExtAttr)	\
    (This)->lpVtbl -> CopyAttributes(This,pDest,pdwAttrNames,dwNumAttr,fCopyExtAttr)

#define IWMSPacket_AppendHeader(This,pAlloc,dwHeaderLen,pbHeader)	\
    (This)->lpVtbl -> AppendHeader(This,pAlloc,dwHeaderLen,pbHeader)

#define IWMSPacket_SetInHeader(This,cbOffset,pbData,cbData)	\
    (This)->lpVtbl -> SetInHeader(This,cbOffset,pbData,cbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetAllBuffers_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwMaxNumBuffers,
    /* [out] */ WMSBUFFERDESC *pDesc,
    /* [out] */ DWORD *pdwNumBuffers,
    /* [in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacket_GetAllBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetBuffer_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwBufferNum,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [out] */ DWORD *pdwBufferOffset,
    /* [out] */ DWORD *pdwBufferLen,
    /* [out] */ WORD *pwFlags,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacket_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_InsertBuffer_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwBufferNum,
    /* [in] */ INSSBuffer *pBuffer,
    /* [in] */ DWORD dwBufferOffset,
    /* [in] */ DWORD dwBufferLen,
    /* [in] */ WORD wFlags,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacket_InsertBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_RemoveBuffer_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwBufferNum);


void __RPC_STUB IWMSPacket_RemoveBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_RemoveAllBuffers_Proxy( 
    IWMSPacket * This);


void __RPC_STUB IWMSPacket_RemoveAllBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetAttribute_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwValueName,
    /* [out] */ DWORD *pdwValue);


void __RPC_STUB IWMSPacket_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_SetAttribute_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwValueName,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IWMSPacket_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetExtendedAttribute_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwValueName,
    /* [out] */ VARIANT *pVariantValue);


void __RPC_STUB IWMSPacket_GetExtendedAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetExtendedAttributeByIndex_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ DWORD *pdwValueName,
    /* [out] */ VARIANT *pVariantValue);


void __RPC_STUB IWMSPacket_GetExtendedAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_SetExtendedAttribute_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD dwValueName,
    /* [in] */ VARIANT VariantValue);


void __RPC_STUB IWMSPacket_SetExtendedAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_GetExtendedAttributeCount_Proxy( 
    IWMSPacket * This,
    /* [out] */ DWORD *pdwAttrs);


void __RPC_STUB IWMSPacket_GetExtendedAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_CopyAttributes_Proxy( 
    IWMSPacket * This,
    /* [in] */ IWMSPacket *pDest,
    /* [defaultvalue][in] */ DWORD *pdwAttrNames,
    /* [defaultvalue][in] */ DWORD dwNumAttr,
    /* [defaultvalue][in] */ BOOL fCopyExtAttr);


void __RPC_STUB IWMSPacket_CopyAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_AppendHeader_Proxy( 
    IWMSPacket * This,
    /* [in] */ IWMSBufferAllocator *pAlloc,
    /* [in] */ DWORD dwHeaderLen,
    /* [in] */ BYTE *pbHeader);


void __RPC_STUB IWMSPacket_AppendHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacket_SetInHeader_Proxy( 
    IWMSPacket * This,
    /* [in] */ DWORD cbOffset,
    /* [in] */ BYTE *pbData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IWMSPacket_SetInHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPacket_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketListCallback_INTERFACE_DEFINED__
#define __IWMSPacketListCallback_INTERFACE_DEFINED__

/* interface IWMSPacketListCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPacketListCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49C2A6F1-64B8-11d2-9F0E-006097D2D7CF")
    IWMSPacketListCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnReportPacketListStatus( 
            /* [in] */ IWMSPacketList *pBuffer,
            /* [in] */ DWORD dwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketListCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketListCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketListCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketListCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnReportPacketListStatus )( 
            IWMSPacketListCallback * This,
            /* [in] */ IWMSPacketList *pBuffer,
            /* [in] */ DWORD dwStatus);
        
        END_INTERFACE
    } IWMSPacketListCallbackVtbl;

    interface IWMSPacketListCallback
    {
        CONST_VTBL struct IWMSPacketListCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketListCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPacketListCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPacketListCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPacketListCallback_OnReportPacketListStatus(This,pBuffer,dwStatus)	\
    (This)->lpVtbl -> OnReportPacketListStatus(This,pBuffer,dwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketListCallback_OnReportPacketListStatus_Proxy( 
    IWMSPacketListCallback * This,
    /* [in] */ IWMSPacketList *pBuffer,
    /* [in] */ DWORD dwStatus);


void __RPC_STUB IWMSPacketListCallback_OnReportPacketListStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPacketListCallback_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketList_INTERFACE_DEFINED__
#define __IWMSPacketList_INTERFACE_DEFINED__

/* interface IWMSPacketList */
/* [helpstring][version][uuid][unique][object] */ 

typedef /* [public][public] */ struct __MIDL_IWMSPacketList_0001
    {
    IWMSPacket *pPacket;
    struct 
        {
        DWORD dwPacketNum;
        DWORD dwPacketNumBuffers;
        DWORD dwPacketLength;
        DWORD dwPacketSendTimeHi;
        DWORD dwPacketSendTime;
        DWORD dwPacketStreamNum;
        DWORD dwPacketFlags;
        DWORD dwPacketNetSequenceNum;
        } 	Attrs;
    } 	WMSPACKETDESC;


EXTERN_C const IID IID_IWMSPacketList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3309C902-10A4-11d2-9EEE-006097D2D7CF")
    IWMSPacketList : public IWMSBufferAllocator
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacketCount( 
            /* [out] */ DWORD *pdwNumPackets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacket( 
            /* [in] */ DWORD dwPacketNum,
            /* [out] */ IWMSPacket **ppPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAllPackets( 
            /* [in] */ DWORD dwFirstPacket,
            /* [in] */ DWORD dwMaxNumPackets,
            /* [out] */ WMSPACKETDESC *pPacketDesc,
            /* [out] */ IWMSPacket **ppPacket,
            /* [out] */ DWORD *pdwDescNum,
            /* [in] */ DWORD dwExFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertPacket( 
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendPacket( 
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePacket( 
            /* [in] */ DWORD dwPacketNum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAllPackets( 
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD *pdwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamSignalParam( 
            /* [out] */ VARIANT *pParameter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStreamSignalParam( 
            /* [in] */ VARIANT *pParameter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPacketParser( 
            /* [out] */ IWMSPacketParser **ppSource,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPacketParser( 
            /* [in] */ IWMSPacketParser *pSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ INSSBuffer **ppBuffer,
            /* [defaultvalue][in] */ DWORD dwExFlags = 0) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBuffer( 
            /* [in] */ INSSBuffer *pBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCompletionCallback( 
            /* [in] */ IWMSPacketListCallback *pCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCompletionCallback( 
            /* [out] */ IWMSPacketListCallback **ppCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExtendedAttribute( 
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedAttributeCount( 
            /* [out] */ DWORD *pdwAttrs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ DWORD dwStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClonePacketList( 
            /* [out] */ IWMSPacketList **ppClonedPacketList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocPacket( 
            /* [out] */ IWMSPacket **ppPacket) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketList * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocateBuffer )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocatePageSizeBuffer )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacketCount )( 
            IWMSPacketList * This,
            /* [out] */ DWORD *pdwNumPackets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum,
            /* [out] */ IWMSPacket **ppPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAllPackets )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwFirstPacket,
            /* [in] */ DWORD dwMaxNumPackets,
            /* [out] */ WMSPACKETDESC *pPacketDesc,
            /* [out] */ IWMSPacket **ppPacket,
            /* [out] */ DWORD *pdwDescNum,
            /* [in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertPacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppendPacket )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacket *pPacket,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePacket )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwPacketNum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAllPackets )( 
            IWMSPacketList * This,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD *pdwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ DWORD dwValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStreamSignalParam )( 
            IWMSPacketList * This,
            /* [out] */ VARIANT *pParameter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStreamSignalParam )( 
            IWMSPacketList * This,
            /* [in] */ VARIANT *pParameter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPacketParser )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketParser **ppSource,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPacketParser )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacketParser *pSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IWMSPacketList * This,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [defaultvalue][in] */ DWORD dwExFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetBuffer )( 
            IWMSPacketList * This,
            /* [in] */ INSSBuffer *pBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCompletionCallback )( 
            IWMSPacketList * This,
            /* [in] */ IWMSPacketListCallback *pCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCompletionCallback )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketListCallback **ppCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeByIndex )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwValueName,
            /* [out] */ VARIANT *pVariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetExtendedAttribute )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwValueName,
            /* [in] */ VARIANT VariantValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedAttributeCount )( 
            IWMSPacketList * This,
            /* [out] */ DWORD *pdwAttrs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            IWMSPacketList * This,
            /* [in] */ DWORD dwStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClonePacketList )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacketList **ppClonedPacketList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocPacket )( 
            IWMSPacketList * This,
            /* [out] */ IWMSPacket **ppPacket);
        
        END_INTERFACE
    } IWMSPacketListVtbl;

    interface IWMSPacketList
    {
        CONST_VTBL struct IWMSPacketListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPacketList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPacketList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPacketList_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSPacketList_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)


#define IWMSPacketList_GetPacketCount(This,pdwNumPackets)	\
    (This)->lpVtbl -> GetPacketCount(This,pdwNumPackets)

#define IWMSPacketList_GetPacket(This,dwPacketNum,ppPacket,dwExFlags)	\
    (This)->lpVtbl -> GetPacket(This,dwPacketNum,ppPacket,dwExFlags)

#define IWMSPacketList_GetAllPackets(This,dwFirstPacket,dwMaxNumPackets,pPacketDesc,ppPacket,pdwDescNum,dwExFlags)	\
    (This)->lpVtbl -> GetAllPackets(This,dwFirstPacket,dwMaxNumPackets,pPacketDesc,ppPacket,pdwDescNum,dwExFlags)

#define IWMSPacketList_InsertPacket(This,dwPacketNum,pPacket,dwExFlags)	\
    (This)->lpVtbl -> InsertPacket(This,dwPacketNum,pPacket,dwExFlags)

#define IWMSPacketList_AppendPacket(This,pPacket,dwExFlags)	\
    (This)->lpVtbl -> AppendPacket(This,pPacket,dwExFlags)

#define IWMSPacketList_RemovePacket(This,dwPacketNum)	\
    (This)->lpVtbl -> RemovePacket(This,dwPacketNum)

#define IWMSPacketList_RemoveAllPackets(This,dwExFlags)	\
    (This)->lpVtbl -> RemoveAllPackets(This,dwExFlags)

#define IWMSPacketList_GetAttribute(This,dwValueName,pdwValue)	\
    (This)->lpVtbl -> GetAttribute(This,dwValueName,pdwValue)

#define IWMSPacketList_SetAttribute(This,dwValueName,dwValue)	\
    (This)->lpVtbl -> SetAttribute(This,dwValueName,dwValue)

#define IWMSPacketList_GetStreamSignalParam(This,pParameter)	\
    (This)->lpVtbl -> GetStreamSignalParam(This,pParameter)

#define IWMSPacketList_SetStreamSignalParam(This,pParameter)	\
    (This)->lpVtbl -> SetStreamSignalParam(This,pParameter)

#define IWMSPacketList_GetPacketParser(This,ppSource,dwExFlags)	\
    (This)->lpVtbl -> GetPacketParser(This,ppSource,dwExFlags)

#define IWMSPacketList_SetPacketParser(This,pSource)	\
    (This)->lpVtbl -> SetPacketParser(This,pSource)

#define IWMSPacketList_GetBuffer(This,ppBuffer,dwExFlags)	\
    (This)->lpVtbl -> GetBuffer(This,ppBuffer,dwExFlags)

#define IWMSPacketList_SetBuffer(This,pBuffer)	\
    (This)->lpVtbl -> SetBuffer(This,pBuffer)

#define IWMSPacketList_SetCompletionCallback(This,pCallback)	\
    (This)->lpVtbl -> SetCompletionCallback(This,pCallback)

#define IWMSPacketList_GetCompletionCallback(This,ppCallback)	\
    (This)->lpVtbl -> GetCompletionCallback(This,ppCallback)

#define IWMSPacketList_GetExtendedAttribute(This,dwValueName,pVariantValue)	\
    (This)->lpVtbl -> GetExtendedAttribute(This,dwValueName,pVariantValue)

#define IWMSPacketList_GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)	\
    (This)->lpVtbl -> GetExtendedAttributeByIndex(This,dwIndex,pdwValueName,pVariantValue)

#define IWMSPacketList_SetExtendedAttribute(This,dwValueName,VariantValue)	\
    (This)->lpVtbl -> SetExtendedAttribute(This,dwValueName,VariantValue)

#define IWMSPacketList_GetExtendedAttributeCount(This,pdwAttrs)	\
    (This)->lpVtbl -> GetExtendedAttributeCount(This,pdwAttrs)

#define IWMSPacketList_ReportStatus(This,dwStatus)	\
    (This)->lpVtbl -> ReportStatus(This,dwStatus)

#define IWMSPacketList_ClonePacketList(This,ppClonedPacketList)	\
    (This)->lpVtbl -> ClonePacketList(This,ppClonedPacketList)

#define IWMSPacketList_AllocPacket(This,ppPacket)	\
    (This)->lpVtbl -> AllocPacket(This,ppPacket)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetPacketCount_Proxy( 
    IWMSPacketList * This,
    /* [out] */ DWORD *pdwNumPackets);


void __RPC_STUB IWMSPacketList_GetPacketCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetPacket_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwPacketNum,
    /* [out] */ IWMSPacket **ppPacket,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_GetPacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetAllPackets_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwFirstPacket,
    /* [in] */ DWORD dwMaxNumPackets,
    /* [out] */ WMSPACKETDESC *pPacketDesc,
    /* [out] */ IWMSPacket **ppPacket,
    /* [out] */ DWORD *pdwDescNum,
    /* [in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_GetAllPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_InsertPacket_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwPacketNum,
    /* [in] */ IWMSPacket *pPacket,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_InsertPacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_AppendPacket_Proxy( 
    IWMSPacketList * This,
    /* [in] */ IWMSPacket *pPacket,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_AppendPacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_RemovePacket_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwPacketNum);


void __RPC_STUB IWMSPacketList_RemovePacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_RemoveAllPackets_Proxy( 
    IWMSPacketList * This,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_RemoveAllPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetAttribute_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwValueName,
    /* [in] */ DWORD *pdwValue);


void __RPC_STUB IWMSPacketList_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetAttribute_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwValueName,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IWMSPacketList_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetStreamSignalParam_Proxy( 
    IWMSPacketList * This,
    /* [out] */ VARIANT *pParameter);


void __RPC_STUB IWMSPacketList_GetStreamSignalParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetStreamSignalParam_Proxy( 
    IWMSPacketList * This,
    /* [in] */ VARIANT *pParameter);


void __RPC_STUB IWMSPacketList_SetStreamSignalParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetPacketParser_Proxy( 
    IWMSPacketList * This,
    /* [out] */ IWMSPacketParser **ppSource,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_GetPacketParser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetPacketParser_Proxy( 
    IWMSPacketList * This,
    /* [in] */ IWMSPacketParser *pSource);


void __RPC_STUB IWMSPacketList_SetPacketParser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetBuffer_Proxy( 
    IWMSPacketList * This,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [defaultvalue][in] */ DWORD dwExFlags);


void __RPC_STUB IWMSPacketList_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetBuffer_Proxy( 
    IWMSPacketList * This,
    /* [in] */ INSSBuffer *pBuffer);


void __RPC_STUB IWMSPacketList_SetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetCompletionCallback_Proxy( 
    IWMSPacketList * This,
    /* [in] */ IWMSPacketListCallback *pCallback);


void __RPC_STUB IWMSPacketList_SetCompletionCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetCompletionCallback_Proxy( 
    IWMSPacketList * This,
    /* [out] */ IWMSPacketListCallback **ppCallback);


void __RPC_STUB IWMSPacketList_GetCompletionCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetExtendedAttribute_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwValueName,
    /* [out] */ VARIANT *pVariantValue);


void __RPC_STUB IWMSPacketList_GetExtendedAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetExtendedAttributeByIndex_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ DWORD *pdwValueName,
    /* [out] */ VARIANT *pVariantValue);


void __RPC_STUB IWMSPacketList_GetExtendedAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_SetExtendedAttribute_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwValueName,
    /* [in] */ VARIANT VariantValue);


void __RPC_STUB IWMSPacketList_SetExtendedAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_GetExtendedAttributeCount_Proxy( 
    IWMSPacketList * This,
    /* [out] */ DWORD *pdwAttrs);


void __RPC_STUB IWMSPacketList_GetExtendedAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_ReportStatus_Proxy( 
    IWMSPacketList * This,
    /* [in] */ DWORD dwStatus);


void __RPC_STUB IWMSPacketList_ReportStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_ClonePacketList_Proxy( 
    IWMSPacketList * This,
    /* [out] */ IWMSPacketList **ppClonedPacketList);


void __RPC_STUB IWMSPacketList_ClonePacketList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketList_AllocPacket_Proxy( 
    IWMSPacketList * This,
    /* [out] */ IWMSPacket **ppPacket);


void __RPC_STUB IWMSPacketList_AllocPacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPacketList_INTERFACE_DEFINED__ */


#ifndef __IWMSPacketParser_INTERFACE_DEFINED__
#define __IWMSPacketParser_INTERFACE_DEFINED__

/* interface IWMSPacketParser */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPacketParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B59F7E1-5411-11d2-9EFF-006097D2D7CF")
    IWMSPacketParser : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdatePacket( 
            /* [in] */ IWMSPacket *pPacket) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CombinePackets( 
            /* [in] */ DWORD dwNumInputPackets,
            /* [in] */ IWMSPacket **pInputPacketArray,
            /* [in] */ IWMSPacketList *pPacketList,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPacketParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPacketParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPacketParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPacketParser * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdatePacket )( 
            IWMSPacketParser * This,
            /* [in] */ IWMSPacket *pPacket);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CombinePackets )( 
            IWMSPacketParser * This,
            /* [in] */ DWORD dwNumInputPackets,
            /* [in] */ IWMSPacket **pInputPacketArray,
            /* [in] */ IWMSPacketList *pPacketList,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IWMSPacketParserVtbl;

    interface IWMSPacketParser
    {
        CONST_VTBL struct IWMSPacketParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPacketParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPacketParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPacketParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPacketParser_UpdatePacket(This,pPacket)	\
    (This)->lpVtbl -> UpdatePacket(This,pPacket)

#define IWMSPacketParser_CombinePackets(This,dwNumInputPackets,pInputPacketArray,pPacketList,dwFlags)	\
    (This)->lpVtbl -> CombinePackets(This,dwNumInputPackets,pInputPacketArray,pPacketList,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketParser_UpdatePacket_Proxy( 
    IWMSPacketParser * This,
    /* [in] */ IWMSPacket *pPacket);


void __RPC_STUB IWMSPacketParser_UpdatePacket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPacketParser_CombinePackets_Proxy( 
    IWMSPacketParser * This,
    /* [in] */ DWORD dwNumInputPackets,
    /* [in] */ IWMSPacket **pInputPacketArray,
    /* [in] */ IWMSPacketList *pPacketList,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMSPacketParser_CombinePackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPacketParser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmspacket_0126 */
/* [local] */ 

typedef /* [public] */ 
enum WMS_STREAM_SIGNAL_TYPE
    {	WMS_NO_STREAM_CHANGE	= 0,
	WMS_STREAM_ERROR	= WMS_NO_STREAM_CHANGE + 1,
	WMS_STREAM_ERROR_HANDLED_BY_PLAYLIST	= WMS_STREAM_ERROR + 1,
	WMS_PLAYLIST_CHANGED	= WMS_STREAM_ERROR_HANDLED_BY_PLAYLIST + 1,
	WMS_END_OF_STREAM	= WMS_PLAYLIST_CHANGED + 1,
	WMS_PLAYLIST_STREAM_QUEUED	= WMS_END_OF_STREAM + 1,
	WMS_BEGIN_NO_DATA_PERIOD	= WMS_PLAYLIST_STREAM_QUEUED + 1,
	WMS_PLAYLIST_EVENT	= WMS_BEGIN_NO_DATA_PERIOD + 1,
	WMS_PLAYLIST_CUE_EVENT	= WMS_PLAYLIST_EVENT + 1,
	WMS_PLAYLIST_UNCUE_EVENT	= WMS_PLAYLIST_CUE_EVENT + 1,
	WMS_PLAYLIST_BEGIN_ELEMENT_EVENT	= WMS_PLAYLIST_UNCUE_EVENT + 1,
	WMS_PLAYLIST_END_ELEMENT_EVENT	= WMS_PLAYLIST_BEGIN_ELEMENT_EVENT + 1,
	WMS_STREAM_SWITCH_DONE	= WMS_PLAYLIST_END_ELEMENT_EVENT + 1,
	WMS_RESET_TO_REAL_TIME	= WMS_STREAM_SWITCH_DONE + 1,
	WMS_DATA_LOSS_DETECTED	= WMS_RESET_TO_REAL_TIME + 1,
	WMS_REUSE_ACCEL_PARAMS	= WMS_DATA_LOSS_DETECTED + 1
    } 	WMS_STREAM_SIGNAL_TYPE;

typedef /* [public] */ 
enum WMS_STREAM_SIGNAL_EOS_TYPE
    {	WMS_STREAM_SIGNAL_EOS_RESERVED	= 1,
	WMS_STREAM_SIGNAL_EOS_RECEDING	= 2
    } 	WMS_STREAM_SIGNAL_EOS_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmspacket_0126_v0_0_s_ifspec;

#ifndef __IWMSStreamSignalHandler_INTERFACE_DEFINED__
#define __IWMSStreamSignalHandler_INTERFACE_DEFINED__

/* interface IWMSStreamSignalHandler */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSStreamSignalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B10F261-26AA-11d2-9EF2-006097D2D7CF")
    IWMSStreamSignalHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStreamSignal( 
            /* [in] */ DWORD dwSignalType,
            /* [in] */ VARIANT *pSignalParameter,
            /* [in] */ IWMSContext *pPresentation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSStreamSignalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSStreamSignalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSStreamSignalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSStreamSignalHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStreamSignal )( 
            IWMSStreamSignalHandler * This,
            /* [in] */ DWORD dwSignalType,
            /* [in] */ VARIANT *pSignalParameter,
            /* [in] */ IWMSContext *pPresentation);
        
        END_INTERFACE
    } IWMSStreamSignalHandlerVtbl;

    interface IWMSStreamSignalHandler
    {
        CONST_VTBL struct IWMSStreamSignalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSStreamSignalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSStreamSignalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSStreamSignalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSStreamSignalHandler_OnStreamSignal(This,dwSignalType,pSignalParameter,pPresentation)	\
    (This)->lpVtbl -> OnStreamSignal(This,dwSignalType,pSignalParameter,pPresentation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSStreamSignalHandler_OnStreamSignal_Proxy( 
    IWMSStreamSignalHandler * This,
    /* [in] */ DWORD dwSignalType,
    /* [in] */ VARIANT *pSignalParameter,
    /* [in] */ IWMSContext *pPresentation);


void __RPC_STUB IWMSStreamSignalHandler_OnStreamSignal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSStreamSignalHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsplaylistparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmsplaylistparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsplaylistparser_h__
#define __wmsplaylistparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSPlaylistParser_FWD_DEFINED__
#define __IWMSPlaylistParser_FWD_DEFINED__
typedef interface IWMSPlaylistParser IWMSPlaylistParser;
#endif 	/* __IWMSPlaylistParser_FWD_DEFINED__ */


#ifndef __IWMSPlaylistParserCallback_FWD_DEFINED__
#define __IWMSPlaylistParserCallback_FWD_DEFINED__
typedef interface IWMSPlaylistParserCallback IWMSPlaylistParserCallback;
#endif 	/* __IWMSPlaylistParserCallback_FWD_DEFINED__ */


#ifndef __IWMSPlaylistParserPlugin_FWD_DEFINED__
#define __IWMSPlaylistParserPlugin_FWD_DEFINED__
typedef interface IWMSPlaylistParserPlugin IWMSPlaylistParserPlugin;
#endif 	/* __IWMSPlaylistParserPlugin_FWD_DEFINED__ */


#ifndef __IWMSPlaylistParserPluginCallback_FWD_DEFINED__
#define __IWMSPlaylistParserPluginCallback_FWD_DEFINED__
typedef interface IWMSPlaylistParserPluginCallback IWMSPlaylistParserPluginCallback;
#endif 	/* __IWMSPlaylistParserPluginCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "xmldom.h"
#include "nsscore.h"
#include "wmsbuffer.h"
#include "dataContainer.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsplaylistparser_0000 */
/* [local] */ 

//*****************************************************************************
//
//  Microsoft Windows Media
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  Automatically generated by Midl from WMSPlaylistParser.idl
//
//  DO NOT EDIT THIS FILE.
//
//*****************************************************************************


EXTERN_GUID( IID_IWMSPlaylistParser, 0xee1f2ec, 0x48ef, 0x11d2, 0x9e, 0xff, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSPlaylistParserCallback, 0xee1f2ed, 0x48ef, 0x11d2, 0x9e, 0xff, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSPlaylistParserPlugin, 0xfa8764c1, 0x90a2, 0x11d2, 0x9f, 0x22, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );
EXTERN_GUID( IID_IWMSPlaylistParserPluginCallback, 0xfa8764c2, 0x90a2, 0x11d2, 0x9f, 0x22, 0x0, 0x60, 0x97, 0xd2, 0xd7, 0xcf );


extern RPC_IF_HANDLE __MIDL_itf_wmsplaylistparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsplaylistparser_0000_v0_0_s_ifspec;

#ifndef __IWMSPlaylistParser_INTERFACE_DEFINED__
#define __IWMSPlaylistParser_INTERFACE_DEFINED__

/* interface IWMSPlaylistParser */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPlaylistParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EE1F2EC-48EF-11d2-9EFF-006097D2D7CF")
    IWMSPlaylistParser : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReadPlaylist( 
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WritePlaylist( 
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReadPlaylistFromDirectory( 
            /* [in] */ IWMSDirectory *pDirectory,
            /* [in] */ LPWSTR pszwFilePattern,
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlaylistParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlaylistParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlaylistParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlaylistParser * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadPlaylist )( 
            IWMSPlaylistParser * This,
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WritePlaylist )( 
            IWMSPlaylistParser * This,
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadPlaylistFromDirectory )( 
            IWMSPlaylistParser * This,
            /* [in] */ IWMSDirectory *pDirectory,
            /* [in] */ LPWSTR pszwFilePattern,
            /* [in] */ IXMLDOMDocument *pPlaylist,
            /* [in] */ IWMSPlaylistParserCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSPlaylistParserVtbl;

    interface IWMSPlaylistParser
    {
        CONST_VTBL struct IWMSPlaylistParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlaylistParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlaylistParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlaylistParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlaylistParser_ReadPlaylist(This,pBuffer,pPlaylist,pCallback,qwContext)	\
    (This)->lpVtbl -> ReadPlaylist(This,pBuffer,pPlaylist,pCallback,qwContext)

#define IWMSPlaylistParser_WritePlaylist(This,pPlaylist,pCallback,qwContext)	\
    (This)->lpVtbl -> WritePlaylist(This,pPlaylist,pCallback,qwContext)

#define IWMSPlaylistParser_ReadPlaylistFromDirectory(This,pDirectory,pszwFilePattern,pPlaylist,pCallback,qwContext)	\
    (This)->lpVtbl -> ReadPlaylistFromDirectory(This,pDirectory,pszwFilePattern,pPlaylist,pCallback,qwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParser_ReadPlaylist_Proxy( 
    IWMSPlaylistParser * This,
    /* [in] */ INSSBuffer *pBuffer,
    /* [in] */ IXMLDOMDocument *pPlaylist,
    /* [in] */ IWMSPlaylistParserCallback *pCallback,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParser_ReadPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParser_WritePlaylist_Proxy( 
    IWMSPlaylistParser * This,
    /* [in] */ IXMLDOMDocument *pPlaylist,
    /* [in] */ IWMSPlaylistParserCallback *pCallback,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParser_WritePlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParser_ReadPlaylistFromDirectory_Proxy( 
    IWMSPlaylistParser * This,
    /* [in] */ IWMSDirectory *pDirectory,
    /* [in] */ LPWSTR pszwFilePattern,
    /* [in] */ IXMLDOMDocument *pPlaylist,
    /* [in] */ IWMSPlaylistParserCallback *pCallback,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParser_ReadPlaylistFromDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlaylistParser_INTERFACE_DEFINED__ */


#ifndef __IWMSPlaylistParserCallback_INTERFACE_DEFINED__
#define __IWMSPlaylistParserCallback_INTERFACE_DEFINED__

/* interface IWMSPlaylistParserCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPlaylistParserCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EE1F2ED-48EF-11d2-9EFF-006097D2D7CF")
    IWMSPlaylistParserCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnReadPlaylist( 
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnWritePlaylist( 
            /* [in] */ HRESULT hr,
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlaylistParserCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlaylistParserCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlaylistParserCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlaylistParserCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnReadPlaylist )( 
            IWMSPlaylistParserCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ QWORD qwContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnWritePlaylist )( 
            IWMSPlaylistParserCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ INSSBuffer *pBuffer,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSPlaylistParserCallbackVtbl;

    interface IWMSPlaylistParserCallback
    {
        CONST_VTBL struct IWMSPlaylistParserCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlaylistParserCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlaylistParserCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlaylistParserCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlaylistParserCallback_OnReadPlaylist(This,hr,qwContext)	\
    (This)->lpVtbl -> OnReadPlaylist(This,hr,qwContext)

#define IWMSPlaylistParserCallback_OnWritePlaylist(This,hr,pBuffer,qwContext)	\
    (This)->lpVtbl -> OnWritePlaylist(This,hr,pBuffer,qwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParserCallback_OnReadPlaylist_Proxy( 
    IWMSPlaylistParserCallback * This,
    /* [in] */ HRESULT hr,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParserCallback_OnReadPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParserCallback_OnWritePlaylist_Proxy( 
    IWMSPlaylistParserCallback * This,
    /* [in] */ HRESULT hr,
    /* [in] */ INSSBuffer *pBuffer,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParserCallback_OnWritePlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlaylistParserCallback_INTERFACE_DEFINED__ */


#ifndef __IWMSPlaylistParserPlugin_INTERFACE_DEFINED__
#define __IWMSPlaylistParserPlugin_INTERFACE_DEFINED__

/* interface IWMSPlaylistParserPlugin */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPlaylistParserPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA8764C1-90A2-11d2-9F22-006097D2D7CF")
    IWMSPlaylistParserPlugin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePlaylistParser( 
            /* [in] */ IWMSCommandContext *pCommandContext,
            /* [in] */ IWMSContext *pUser,
            /* [in] */ IWMSContext *pPresentation,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMSClassObject *pFactory,
            /* [in] */ IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ IWMSPlaylistParserPluginCallback *pCallback,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlaylistParserPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlaylistParserPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlaylistParserPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlaylistParserPlugin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePlaylistParser )( 
            IWMSPlaylistParserPlugin * This,
            /* [in] */ IWMSCommandContext *pCommandContext,
            /* [in] */ IWMSContext *pUser,
            /* [in] */ IWMSContext *pPresentation,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMSClassObject *pFactory,
            /* [in] */ IWMSBufferAllocator *pBufferAllocator,
            /* [in] */ IWMSPlaylistParserPluginCallback *pCallback,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSPlaylistParserPluginVtbl;

    interface IWMSPlaylistParserPlugin
    {
        CONST_VTBL struct IWMSPlaylistParserPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlaylistParserPlugin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlaylistParserPlugin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlaylistParserPlugin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlaylistParserPlugin_CreatePlaylistParser(This,pCommandContext,pUser,pPresentation,dwFlags,pFactory,pBufferAllocator,pCallback,qwContext)	\
    (This)->lpVtbl -> CreatePlaylistParser(This,pCommandContext,pUser,pPresentation,dwFlags,pFactory,pBufferAllocator,pCallback,qwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParserPlugin_CreatePlaylistParser_Proxy( 
    IWMSPlaylistParserPlugin * This,
    /* [in] */ IWMSCommandContext *pCommandContext,
    /* [in] */ IWMSContext *pUser,
    /* [in] */ IWMSContext *pPresentation,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMSClassObject *pFactory,
    /* [in] */ IWMSBufferAllocator *pBufferAllocator,
    /* [in] */ IWMSPlaylistParserPluginCallback *pCallback,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParserPlugin_CreatePlaylistParser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlaylistParserPlugin_INTERFACE_DEFINED__ */


#ifndef __IWMSPlaylistParserPluginCallback_INTERFACE_DEFINED__
#define __IWMSPlaylistParserPluginCallback_INTERFACE_DEFINED__

/* interface IWMSPlaylistParserPluginCallback */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSPlaylistParserPluginCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA8764C2-90A2-11d2-9F22-006097D2D7CF")
    IWMSPlaylistParserPluginCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnCreatePlaylistParser( 
            /* [in] */ HRESULT hr,
            /* [in] */ IWMSPlaylistParser *pParser,
            /* [in] */ QWORD qwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlaylistParserPluginCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlaylistParserPluginCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlaylistParserPluginCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlaylistParserPluginCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnCreatePlaylistParser )( 
            IWMSPlaylistParserPluginCallback * This,
            /* [in] */ HRESULT hr,
            /* [in] */ IWMSPlaylistParser *pParser,
            /* [in] */ QWORD qwContext);
        
        END_INTERFACE
    } IWMSPlaylistParserPluginCallbackVtbl;

    interface IWMSPlaylistParserPluginCallback
    {
        CONST_VTBL struct IWMSPlaylistParserPluginCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlaylistParserPluginCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlaylistParserPluginCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlaylistParserPluginCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlaylistParserPluginCallback_OnCreatePlaylistParser(This,hr,pParser,qwContext)	\
    (This)->lpVtbl -> OnCreatePlaylistParser(This,hr,pParser,qwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSPlaylistParserPluginCallback_OnCreatePlaylistParser_Proxy( 
    IWMSPlaylistParserPluginCallback * This,
    /* [in] */ HRESULT hr,
    /* [in] */ IWMSPlaylistParser *pParser,
    /* [in] */ QWORD qwContext);


void __RPC_STUB IWMSPlaylistParserPluginCallback_OnCreatePlaylistParser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlaylistParserPluginCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsxmldomextensions.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmsxmldomextensions.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsxmldomextensions_h__
#define __wmsxmldomextensions_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSActiveStream_FWD_DEFINED__
#define __IWMSActiveStream_FWD_DEFINED__
typedef interface IWMSActiveStream IWMSActiveStream;
#endif 	/* __IWMSActiveStream_FWD_DEFINED__ */


#ifndef __IWMSActiveStreams_FWD_DEFINED__
#define __IWMSActiveStreams_FWD_DEFINED__
typedef interface IWMSActiveStreams IWMSActiveStreams;
#endif 	/* __IWMSActiveStreams_FWD_DEFINED__ */


#ifndef __IWMSActiveMedia_FWD_DEFINED__
#define __IWMSActiveMedia_FWD_DEFINED__
typedef interface IWMSActiveMedia IWMSActiveMedia;
#endif 	/* __IWMSActiveMedia_FWD_DEFINED__ */


#ifndef __IWMSPlaylist_FWD_DEFINED__
#define __IWMSPlaylist_FWD_DEFINED__
typedef interface IWMSPlaylist IWMSPlaylist;
#endif 	/* __IWMSPlaylist_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "xmldom.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsxmldomextensions_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from wmsXMLDOMExtensions.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#pragma once
#ifndef __WMS_XML_DOM_EXTENSIONS_IDL__
#define __WMS_XML_DOM_EXTENSIONS_IDL__
#include <WMSDefs.h>


extern RPC_IF_HANDLE __MIDL_itf_wmsxmldomextensions_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsxmldomextensions_0000_v0_0_s_ifspec;

#ifndef __IWMSActiveStream_INTERFACE_DEFINED__
#define __IWMSActiveStream_INTERFACE_DEFINED__

/* interface IWMSActiveStream */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("9D6A9BE7-B08C-48a8-9755-ACBC5E79973A") 
enum WMS_ACTIVE_STREAM_TYPE
    {	WMS_STREAM_TYPE_VIDEO	= 0,
	WMS_STREAM_TYPE_AUDIO	= 1,
	WMS_STREAM_TYPE_OTHER	= 2
    } 	WMS_ACTIVE_STREAM_TYPE;


EXTERN_C const IID IID_IWMSActiveStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("165FC383-B494-4465-AD08-4A73CEDF8791")
    IWMSActiveStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ WMS_ACTIVE_STREAM_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSActiveStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSActiveStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSActiveStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSActiveStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSActiveStream * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSActiveStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSActiveStream * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSActiveStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSActiveStream * This,
            /* [retval][out] */ WMS_ACTIVE_STREAM_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSActiveStream * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IWMSActiveStream * This,
            /* [retval][out] */ long *pVal);
        
        END_INTERFACE
    } IWMSActiveStreamVtbl;

    interface IWMSActiveStream
    {
        CONST_VTBL struct IWMSActiveStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSActiveStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSActiveStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSActiveStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSActiveStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSActiveStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSActiveStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSActiveStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSActiveStream_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IWMSActiveStream_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSActiveStream_get_BitRate(This,pVal)	\
    (This)->lpVtbl -> get_BitRate(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStream_get_Type_Proxy( 
    IWMSActiveStream * This,
    /* [retval][out] */ WMS_ACTIVE_STREAM_TYPE *pVal);


void __RPC_STUB IWMSActiveStream_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStream_get_Name_Proxy( 
    IWMSActiveStream * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSActiveStream_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStream_get_BitRate_Proxy( 
    IWMSActiveStream * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSActiveStream_get_BitRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSActiveStream_INTERFACE_DEFINED__ */


#ifndef __IWMSActiveStreams_INTERFACE_DEFINED__
#define __IWMSActiveStreams_INTERFACE_DEFINED__

/* interface IWMSActiveStreams */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSActiveStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F248EA2-C018-466c-9AD7-2086CFB9A5D3")
    IWMSActiveStreams : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSActiveStream **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSActiveStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSActiveStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSActiveStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSActiveStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSActiveStreams * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSActiveStreams * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSActiveStreams * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSActiveStreams * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSActiveStreams * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSActiveStream **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSActiveStreams * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSActiveStreams * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSActiveStreams * This,
            /* [retval][out] */ IUnknown **pVal);
        
        END_INTERFACE
    } IWMSActiveStreamsVtbl;

    interface IWMSActiveStreams
    {
        CONST_VTBL struct IWMSActiveStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSActiveStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSActiveStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSActiveStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSActiveStreams_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSActiveStreams_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSActiveStreams_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSActiveStreams_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSActiveStreams_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSActiveStreams_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSActiveStreams_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSActiveStreams_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStreams_get_Item_Proxy( 
    IWMSActiveStreams * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSActiveStream **pVal);


void __RPC_STUB IWMSActiveStreams_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStreams_get_Count_Proxy( 
    IWMSActiveStreams * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSActiveStreams_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStreams_get_length_Proxy( 
    IWMSActiveStreams * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSActiveStreams_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveStreams_get__NewEnum_Proxy( 
    IWMSActiveStreams * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSActiveStreams_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSActiveStreams_INTERFACE_DEFINED__ */


#ifndef __IWMSActiveMedia_INTERFACE_DEFINED__
#define __IWMSActiveMedia_INTERFACE_DEFINED__

/* interface IWMSActiveMedia */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSActiveMedia;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D07EE1C-798F-4a28-85FA-230664650B7C")
    IWMSActiveMedia : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalPackets( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Live( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Streams( 
            /* [retval][out] */ IWMSActiveStreams **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ BSTR *pProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSActiveMediaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSActiveMedia * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSActiveMedia * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSActiveMedia * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSActiveMedia * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSActiveMedia * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSActiveMedia * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSActiveMedia * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IWMSActiveMedia * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalPackets )( 
            IWMSActiveMedia * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Live )( 
            IWMSActiveMedia * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Streams )( 
            IWMSActiveMedia * This,
            /* [retval][out] */ IWMSActiveStreams **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IWMSActiveMedia * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ BSTR *pProperty);
        
        END_INTERFACE
    } IWMSActiveMediaVtbl;

    interface IWMSActiveMedia
    {
        CONST_VTBL struct IWMSActiveMediaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSActiveMedia_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSActiveMedia_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSActiveMedia_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSActiveMedia_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSActiveMedia_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSActiveMedia_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSActiveMedia_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSActiveMedia_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IWMSActiveMedia_get_TotalPackets(This,pVal)	\
    (This)->lpVtbl -> get_TotalPackets(This,pVal)

#define IWMSActiveMedia_get_Live(This,pVal)	\
    (This)->lpVtbl -> get_Live(This,pVal)

#define IWMSActiveMedia_get_Streams(This,pVal)	\
    (This)->lpVtbl -> get_Streams(This,pVal)

#define IWMSActiveMedia_GetProperty(This,bstrName,bstrLanguage,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,bstrName,bstrLanguage,pProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveMedia_get_Duration_Proxy( 
    IWMSActiveMedia * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSActiveMedia_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveMedia_get_TotalPackets_Proxy( 
    IWMSActiveMedia * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSActiveMedia_get_TotalPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveMedia_get_Live_Proxy( 
    IWMSActiveMedia * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSActiveMedia_get_Live_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSActiveMedia_get_Streams_Proxy( 
    IWMSActiveMedia * This,
    /* [retval][out] */ IWMSActiveStreams **pVal);


void __RPC_STUB IWMSActiveMedia_get_Streams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSActiveMedia_GetProperty_Proxy( 
    IWMSActiveMedia * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrLanguage,
    /* [retval][out] */ BSTR *pProperty);


void __RPC_STUB IWMSActiveMedia_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSActiveMedia_INTERFACE_DEFINED__ */


#ifndef __IWMSPlaylist_INTERFACE_DEFINED__
#define __IWMSPlaylist_INTERFACE_DEFINED__

/* interface IWMSPlaylist */
/* [helpstring][uuid][unique][nonextensible][dual][object] */ 


EXTERN_C const IID IID_IWMSPlaylist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EE1F2E7-48EF-11d2-9EFF-006097D2D7CF")
    IWMSPlaylist : public IXMLDOMDocument
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPlaylistEntry( 
            /* [retval][out] */ IXMLDOMElement **ppPlaylistEntry) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPlaylistEntry( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerEntry( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ IXMLDOMElement **ppCallerPlaylistEntry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsStreamCued( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedSimpleTime( 
            /* [retval][out] */ long *pSimpleTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMediaInformation( 
            /* [retval][out] */ IWMSActiveMedia **ppMediaInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ BSTR bstrEventName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CueStream( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UncueStream( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NestedPlaylist( 
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ IWMSPlaylist **ppPlaylist) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlaylistVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlaylist * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlaylist * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlaylist * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPlaylist * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPlaylist * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPlaylist * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPlaylist * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IWMSPlaylist * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IWMSPlaylist * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IWMSPlaylist * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IWMSPlaylist * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IWMSPlaylist * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IWMSPlaylist * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMDocumentType **documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_implementation )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMImplementation **impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_documentElement )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMElement **DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentElement )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDocumentFragment )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createTextNode )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createComment )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createCDATASection )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessingInstruction )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createAttribute )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createEntityReference )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createNode )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nodeFromID )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *load )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IWMSPlaylist * This,
            /* [out][retval] */ long *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parseError )( 
            IWMSPlaylist * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IWMSPlaylist * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT_BOOL *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IWMSPlaylist * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *loadXML )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *save )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT desination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnParse )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT_BOOL *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnParse )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resolveExternals )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT_BOOL *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resolveExternals )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preserveWhiteSpace )( 
            IWMSPlaylist * This,
            /* [out][retval] */ VARIANT_BOOL *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_preserveWhiteSpace )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ondataavailable )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ontransformnode )( 
            IWMSPlaylist * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPlaylistEntry )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IXMLDOMElement **ppPlaylistEntry);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPlaylistEntry )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerEntry )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ IXMLDOMElement **ppCallerPlaylistEntry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsStreamCued )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedSimpleTime )( 
            IWMSPlaylist * This,
            /* [retval][out] */ long *pSimpleTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMediaInformation )( 
            IWMSPlaylist * This,
            /* [retval][out] */ IWMSActiveMedia **ppMediaInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FireEvent )( 
            IWMSPlaylist * This,
            /* [in] */ BSTR bstrEventName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CueStream )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UncueStream )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NestedPlaylist )( 
            IWMSPlaylist * This,
            /* [in] */ IXMLDOMElement *pPlaylistEntry,
            /* [retval][out] */ IWMSPlaylist **ppPlaylist);
        
        END_INTERFACE
    } IWMSPlaylistVtbl;

    interface IWMSPlaylist
    {
        CONST_VTBL struct IWMSPlaylistVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlaylist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlaylist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlaylist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlaylist_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPlaylist_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPlaylist_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPlaylist_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPlaylist_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IWMSPlaylist_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IWMSPlaylist_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IWMSPlaylist_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IWMSPlaylist_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IWMSPlaylist_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IWMSPlaylist_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IWMSPlaylist_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IWMSPlaylist_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IWMSPlaylist_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IWMSPlaylist_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IWMSPlaylist_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IWMSPlaylist_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IWMSPlaylist_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IWMSPlaylist_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IWMSPlaylist_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IWMSPlaylist_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IWMSPlaylist_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IWMSPlaylist_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IWMSPlaylist_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IWMSPlaylist_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IWMSPlaylist_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IWMSPlaylist_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IWMSPlaylist_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IWMSPlaylist_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IWMSPlaylist_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IWMSPlaylist_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IWMSPlaylist_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IWMSPlaylist_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IWMSPlaylist_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IWMSPlaylist_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IWMSPlaylist_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IWMSPlaylist_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IWMSPlaylist_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IWMSPlaylist_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IWMSPlaylist_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IWMSPlaylist_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IWMSPlaylist_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IWMSPlaylist_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IWMSPlaylist_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IWMSPlaylist_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IWMSPlaylist_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IWMSPlaylist_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IWMSPlaylist_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IWMSPlaylist_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IWMSPlaylist_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IWMSPlaylist_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IWMSPlaylist_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IWMSPlaylist_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IWMSPlaylist_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IWMSPlaylist_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IWMSPlaylist_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IWMSPlaylist_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IWMSPlaylist_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IWMSPlaylist_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IWMSPlaylist_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IWMSPlaylist_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IWMSPlaylist_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IWMSPlaylist_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IWMSPlaylist_save(This,desination)	\
    (This)->lpVtbl -> save(This,desination)

#define IWMSPlaylist_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IWMSPlaylist_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IWMSPlaylist_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IWMSPlaylist_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IWMSPlaylist_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IWMSPlaylist_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IWMSPlaylist_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IWMSPlaylist_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IWMSPlaylist_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)


#define IWMSPlaylist_get_CurrentPlaylistEntry(This,ppPlaylistEntry)	\
    (This)->lpVtbl -> get_CurrentPlaylistEntry(This,ppPlaylistEntry)

#define IWMSPlaylist_put_CurrentPlaylistEntry(This,pPlaylistEntry)	\
    (This)->lpVtbl -> put_CurrentPlaylistEntry(This,pPlaylistEntry)

#define IWMSPlaylist_get_CallerEntry(This,pPlaylistEntry,ppCallerPlaylistEntry)	\
    (This)->lpVtbl -> get_CallerEntry(This,pPlaylistEntry,ppCallerPlaylistEntry)

#define IWMSPlaylist_get_IsStreamCued(This,pPlaylistEntry,pVal)	\
    (This)->lpVtbl -> get_IsStreamCued(This,pPlaylistEntry,pVal)

#define IWMSPlaylist_get_ElapsedSimpleTime(This,pSimpleTime)	\
    (This)->lpVtbl -> get_ElapsedSimpleTime(This,pSimpleTime)

#define IWMSPlaylist_get_CurrentMediaInformation(This,ppMediaInfo)	\
    (This)->lpVtbl -> get_CurrentMediaInformation(This,ppMediaInfo)

#define IWMSPlaylist_FireEvent(This,bstrEventName)	\
    (This)->lpVtbl -> FireEvent(This,bstrEventName)

#define IWMSPlaylist_CueStream(This,pPlaylistEntry)	\
    (This)->lpVtbl -> CueStream(This,pPlaylistEntry)

#define IWMSPlaylist_UncueStream(This,pPlaylistEntry)	\
    (This)->lpVtbl -> UncueStream(This,pPlaylistEntry)

#define IWMSPlaylist_get_NestedPlaylist(This,pPlaylistEntry,ppPlaylist)	\
    (This)->lpVtbl -> get_NestedPlaylist(This,pPlaylistEntry,ppPlaylist)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_CurrentPlaylistEntry_Proxy( 
    IWMSPlaylist * This,
    /* [retval][out] */ IXMLDOMElement **ppPlaylistEntry);


void __RPC_STUB IWMSPlaylist_get_CurrentPlaylistEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_put_CurrentPlaylistEntry_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry);


void __RPC_STUB IWMSPlaylist_put_CurrentPlaylistEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_CallerEntry_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry,
    /* [retval][out] */ IXMLDOMElement **ppCallerPlaylistEntry);


void __RPC_STUB IWMSPlaylist_get_CallerEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_IsStreamCued_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPlaylist_get_IsStreamCued_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_ElapsedSimpleTime_Proxy( 
    IWMSPlaylist * This,
    /* [retval][out] */ long *pSimpleTime);


void __RPC_STUB IWMSPlaylist_get_ElapsedSimpleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_CurrentMediaInformation_Proxy( 
    IWMSPlaylist * This,
    /* [retval][out] */ IWMSActiveMedia **ppMediaInfo);


void __RPC_STUB IWMSPlaylist_get_CurrentMediaInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_FireEvent_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ BSTR bstrEventName);


void __RPC_STUB IWMSPlaylist_FireEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_CueStream_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry);


void __RPC_STUB IWMSPlaylist_CueStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_UncueStream_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry);


void __RPC_STUB IWMSPlaylist_UncueStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlaylist_get_NestedPlaylist_Proxy( 
    IWMSPlaylist * This,
    /* [in] */ IXMLDOMElement *pPlaylistEntry,
    /* [retval][out] */ IWMSPlaylist **ppPlaylist);


void __RPC_STUB IWMSPlaylist_get_NestedPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlaylist_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsxmldomextensions_0140 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_wmsxmldomextensions_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsxmldomextensions_0140_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsserver.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmsserver.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsserver_h__
#define __wmsserver_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSRootDirectories_FWD_DEFINED__
#define __IWMSRootDirectories_FWD_DEFINED__
typedef interface IWMSRootDirectories IWMSRootDirectories;
#endif 	/* __IWMSRootDirectories_FWD_DEFINED__ */


#ifndef __IWMSDiagnosticEvent_FWD_DEFINED__
#define __IWMSDiagnosticEvent_FWD_DEFINED__
typedef interface IWMSDiagnosticEvent IWMSDiagnosticEvent;
#endif 	/* __IWMSDiagnosticEvent_FWD_DEFINED__ */


#ifndef __IWMSDiagnosticEvents_FWD_DEFINED__
#define __IWMSDiagnosticEvents_FWD_DEFINED__
typedef interface IWMSDiagnosticEvents IWMSDiagnosticEvents;
#endif 	/* __IWMSDiagnosticEvents_FWD_DEFINED__ */


#ifndef __IWMSFileDescription_FWD_DEFINED__
#define __IWMSFileDescription_FWD_DEFINED__
typedef interface IWMSFileDescription IWMSFileDescription;
#endif 	/* __IWMSFileDescription_FWD_DEFINED__ */


#ifndef __IWMSFileDescriptions_FWD_DEFINED__
#define __IWMSFileDescriptions_FWD_DEFINED__
typedef interface IWMSFileDescriptions IWMSFileDescriptions;
#endif 	/* __IWMSFileDescriptions_FWD_DEFINED__ */


#ifndef __IWMSAvailableIPAddresses_FWD_DEFINED__
#define __IWMSAvailableIPAddresses_FWD_DEFINED__
typedef interface IWMSAvailableIPAddresses IWMSAvailableIPAddresses;
#endif 	/* __IWMSAvailableIPAddresses_FWD_DEFINED__ */


#ifndef __IWMSPlugins_FWD_DEFINED__
#define __IWMSPlugins_FWD_DEFINED__
typedef interface IWMSPlugins IWMSPlugins;
#endif 	/* __IWMSPlugins_FWD_DEFINED__ */


#ifndef __IWMSCacheItem_FWD_DEFINED__
#define __IWMSCacheItem_FWD_DEFINED__
typedef interface IWMSCacheItem IWMSCacheItem;
#endif 	/* __IWMSCacheItem_FWD_DEFINED__ */


#ifndef __IWMSCacheItems_FWD_DEFINED__
#define __IWMSCacheItems_FWD_DEFINED__
typedef interface IWMSCacheItems IWMSCacheItems;
#endif 	/* __IWMSCacheItems_FWD_DEFINED__ */


#ifndef __IWMSCacheProxyPlugin_FWD_DEFINED__
#define __IWMSCacheProxyPlugin_FWD_DEFINED__
typedef interface IWMSCacheProxyPlugin IWMSCacheProxyPlugin;
#endif 	/* __IWMSCacheProxyPlugin_FWD_DEFINED__ */


#ifndef __IWMSOutgoingDistributionConnection_FWD_DEFINED__
#define __IWMSOutgoingDistributionConnection_FWD_DEFINED__
typedef interface IWMSOutgoingDistributionConnection IWMSOutgoingDistributionConnection;
#endif 	/* __IWMSOutgoingDistributionConnection_FWD_DEFINED__ */


#ifndef __IWMSOutgoingDistributionConnections_FWD_DEFINED__
#define __IWMSOutgoingDistributionConnections_FWD_DEFINED__
typedef interface IWMSOutgoingDistributionConnections IWMSOutgoingDistributionConnections;
#endif 	/* __IWMSOutgoingDistributionConnections_FWD_DEFINED__ */


#ifndef __IWMSPlayer_FWD_DEFINED__
#define __IWMSPlayer_FWD_DEFINED__
typedef interface IWMSPlayer IWMSPlayer;
#endif 	/* __IWMSPlayer_FWD_DEFINED__ */


#ifndef __IWMSPlayers_FWD_DEFINED__
#define __IWMSPlayers_FWD_DEFINED__
typedef interface IWMSPlayers IWMSPlayers;
#endif 	/* __IWMSPlayers_FWD_DEFINED__ */


#ifndef __IWMSPublishingPointCurrentCounters_FWD_DEFINED__
#define __IWMSPublishingPointCurrentCounters_FWD_DEFINED__
typedef interface IWMSPublishingPointCurrentCounters IWMSPublishingPointCurrentCounters;
#endif 	/* __IWMSPublishingPointCurrentCounters_FWD_DEFINED__ */


#ifndef __IWMSPublishingPointPeakCounters_FWD_DEFINED__
#define __IWMSPublishingPointPeakCounters_FWD_DEFINED__
typedef interface IWMSPublishingPointPeakCounters IWMSPublishingPointPeakCounters;
#endif 	/* __IWMSPublishingPointPeakCounters_FWD_DEFINED__ */


#ifndef __IWMSPublishingPointLimits_FWD_DEFINED__
#define __IWMSPublishingPointLimits_FWD_DEFINED__
typedef interface IWMSPublishingPointLimits IWMSPublishingPointLimits;
#endif 	/* __IWMSPublishingPointLimits_FWD_DEFINED__ */


#ifndef __IWMSPublishingPointTotalCounters_FWD_DEFINED__
#define __IWMSPublishingPointTotalCounters_FWD_DEFINED__
typedef interface IWMSPublishingPointTotalCounters IWMSPublishingPointTotalCounters;
#endif 	/* __IWMSPublishingPointTotalCounters_FWD_DEFINED__ */


#ifndef __IWMSServerTotalCounters_FWD_DEFINED__
#define __IWMSServerTotalCounters_FWD_DEFINED__
typedef interface IWMSServerTotalCounters IWMSServerTotalCounters;
#endif 	/* __IWMSServerTotalCounters_FWD_DEFINED__ */


#ifndef __IWMSPublishingPoint_FWD_DEFINED__
#define __IWMSPublishingPoint_FWD_DEFINED__
typedef interface IWMSPublishingPoint IWMSPublishingPoint;
#endif 	/* __IWMSPublishingPoint_FWD_DEFINED__ */


#ifndef __IWMSOnDemandPublishingPoint_FWD_DEFINED__
#define __IWMSOnDemandPublishingPoint_FWD_DEFINED__
typedef interface IWMSOnDemandPublishingPoint IWMSOnDemandPublishingPoint;
#endif 	/* __IWMSOnDemandPublishingPoint_FWD_DEFINED__ */


#ifndef __IWMSAnnouncementStreamFormats_FWD_DEFINED__
#define __IWMSAnnouncementStreamFormats_FWD_DEFINED__
typedef interface IWMSAnnouncementStreamFormats IWMSAnnouncementStreamFormats;
#endif 	/* __IWMSAnnouncementStreamFormats_FWD_DEFINED__ */


#ifndef __IWMSBroadcastPublishingPoint_FWD_DEFINED__
#define __IWMSBroadcastPublishingPoint_FWD_DEFINED__
typedef interface IWMSBroadcastPublishingPoint IWMSBroadcastPublishingPoint;
#endif 	/* __IWMSBroadcastPublishingPoint_FWD_DEFINED__ */


#ifndef __IWMSPublishingPoints_FWD_DEFINED__
#define __IWMSPublishingPoints_FWD_DEFINED__
typedef interface IWMSPublishingPoints IWMSPublishingPoints;
#endif 	/* __IWMSPublishingPoints_FWD_DEFINED__ */


#ifndef __IWMSServerCurrentCounters_FWD_DEFINED__
#define __IWMSServerCurrentCounters_FWD_DEFINED__
typedef interface IWMSServerCurrentCounters IWMSServerCurrentCounters;
#endif 	/* __IWMSServerCurrentCounters_FWD_DEFINED__ */


#ifndef __IWMSServerPeakCounters_FWD_DEFINED__
#define __IWMSServerPeakCounters_FWD_DEFINED__
typedef interface IWMSServerPeakCounters IWMSServerPeakCounters;
#endif 	/* __IWMSServerPeakCounters_FWD_DEFINED__ */


#ifndef __IWMSServerLimits_FWD_DEFINED__
#define __IWMSServerLimits_FWD_DEFINED__
typedef interface IWMSServerLimits IWMSServerLimits;
#endif 	/* __IWMSServerLimits_FWD_DEFINED__ */


#ifndef __IWMSServer_FWD_DEFINED__
#define __IWMSServer_FWD_DEFINED__
typedef interface IWMSServer IWMSServer;
#endif 	/* __IWMSServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "xmldom.h"
#include "WMSNamedValues.h"
#include "WMSPlugin.h"
#include "wmsXMLDOMExtensions.h"
#include "streamcache.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsserver_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  Automatically generated by Midl from WMSServer.idl 
//
// DO NOT EDIT THIS FILE.
//
//--------------------------------------------------------------------------
#pragma once
#ifndef __wmsserver_iid
#define __wmsserver_iid
EXTERN_GUID( CLSID_WMSServerMainImpl,    0x1E62CD49,0x3961,0x11D2,0x9E,0xFC,0x00,0x60,0x97,0xD2,0xD7,0xCF  );
#include <WMSDefs.h>


extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0000_v0_0_s_ifspec;

#ifndef __IWMSRootDirectories_INTERFACE_DEFINED__
#define __IWMSRootDirectories_INTERFACE_DEFINED__

/* interface IWMSRootDirectories */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSRootDirectories;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFC750A9-F846-48be-87AE-79F851C9CD92")
    IWMSRootDirectories : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSRootDirectoriesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSRootDirectories * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSRootDirectories * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSRootDirectories * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSRootDirectories * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSRootDirectories * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSRootDirectories * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSRootDirectories * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSRootDirectories * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSRootDirectories * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSRootDirectories * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSRootDirectories * This,
            /* [retval][out] */ IUnknown **pVal);
        
        END_INTERFACE
    } IWMSRootDirectoriesVtbl;

    interface IWMSRootDirectories
    {
        CONST_VTBL struct IWMSRootDirectoriesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSRootDirectories_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSRootDirectories_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSRootDirectories_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSRootDirectories_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSRootDirectories_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSRootDirectories_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSRootDirectories_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSRootDirectories_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSRootDirectories_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSRootDirectories_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSRootDirectories_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSRootDirectories_get_Item_Proxy( 
    IWMSRootDirectories * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSRootDirectories_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSRootDirectories_get_Count_Proxy( 
    IWMSRootDirectories * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSRootDirectories_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSRootDirectories_get_length_Proxy( 
    IWMSRootDirectories * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSRootDirectories_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSRootDirectories_get__NewEnum_Proxy( 
    IWMSRootDirectories * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSRootDirectories_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSRootDirectories_INTERFACE_DEFINED__ */


#ifndef __IWMSDiagnosticEvent_INTERFACE_DEFINED__
#define __IWMSDiagnosticEvent_INTERFACE_DEFINED__

/* interface IWMSDiagnosticEvent */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("5AC19D63-6057-4431-BE7E-2153FDF91397") 
enum WMS_DIAGNOSTIC_EVENT
    {	WMS_DIAGNOSTIC_EVENT_LIMIT_HIT	= 0,
	WMS_DIAGNOSTIC_EVENT_PLUGIN_EVENT_LOG_ERROR	= 1,
	WMS_DIAGNOSTIC_EVENT_PLUGIN_EVENT_LOG_WARNING	= 2,
	WMS_DIAGNOSTIC_EVENT_SERVER_EVENT_LOG_ERROR	= 3,
	WMS_DIAGNOSTIC_EVENT_SERVER_EVENT_LOG_WARNING	= 4
    } 	WMS_DIAGNOSTIC_EVENT;


EXTERN_C const IID IID_IWMSDiagnosticEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AC19D62-6057-4431-BE7E-2153FDF91397")
    IWMSDiagnosticEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ WMS_DIAGNOSTIC_EVENT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublishingPointName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Time( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfOccurrences( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdditionalInfo( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDiagnosticEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDiagnosticEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDiagnosticEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDiagnosticEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSDiagnosticEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSDiagnosticEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSDiagnosticEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSDiagnosticEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ WMS_DIAGNOSTIC_EVENT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublishingPointName )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Time )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfOccurrences )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdditionalInfo )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IWMSDiagnosticEvent * This,
            /* [retval][out] */ long *pVal);
        
        END_INTERFACE
    } IWMSDiagnosticEventVtbl;

    interface IWMSDiagnosticEvent
    {
        CONST_VTBL struct IWMSDiagnosticEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDiagnosticEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSDiagnosticEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSDiagnosticEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSDiagnosticEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSDiagnosticEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSDiagnosticEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSDiagnosticEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSDiagnosticEvent_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSDiagnosticEvent_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IWMSDiagnosticEvent_get_PublishingPointName(This,pVal)	\
    (This)->lpVtbl -> get_PublishingPointName(This,pVal)

#define IWMSDiagnosticEvent_get_Time(This,pVal)	\
    (This)->lpVtbl -> get_Time(This,pVal)

#define IWMSDiagnosticEvent_get_NumberOfOccurrences(This,pVal)	\
    (This)->lpVtbl -> get_NumberOfOccurrences(This,pVal)

#define IWMSDiagnosticEvent_get_AdditionalInfo(This,pVal)	\
    (This)->lpVtbl -> get_AdditionalInfo(This,pVal)

#define IWMSDiagnosticEvent_get_ErrorCode(This,pVal)	\
    (This)->lpVtbl -> get_ErrorCode(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_Name_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_Type_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ WMS_DIAGNOSTIC_EVENT *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_PublishingPointName_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_PublishingPointName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_Time_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_Time_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_NumberOfOccurrences_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_NumberOfOccurrences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_AdditionalInfo_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_AdditionalInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvent_get_ErrorCode_Proxy( 
    IWMSDiagnosticEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSDiagnosticEvent_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSDiagnosticEvent_INTERFACE_DEFINED__ */


#ifndef __IWMSDiagnosticEvents_INTERFACE_DEFINED__
#define __IWMSDiagnosticEvents_INTERFACE_DEFINED__

/* interface IWMSDiagnosticEvents */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSDiagnosticEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AC19D61-6057-4431-BE7E-2153FDF91397")
    IWMSDiagnosticEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSDiagnosticEvent **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSDiagnosticEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSDiagnosticEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSDiagnosticEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSDiagnosticEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSDiagnosticEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSDiagnosticEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSDiagnosticEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSDiagnosticEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSDiagnosticEvents * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSDiagnosticEvent **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSDiagnosticEvents * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSDiagnosticEvents * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSDiagnosticEvents * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWMSDiagnosticEvents * This);
        
        END_INTERFACE
    } IWMSDiagnosticEventsVtbl;

    interface IWMSDiagnosticEvents
    {
        CONST_VTBL struct IWMSDiagnosticEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSDiagnosticEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSDiagnosticEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSDiagnosticEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSDiagnosticEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSDiagnosticEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSDiagnosticEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSDiagnosticEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSDiagnosticEvents_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSDiagnosticEvents_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSDiagnosticEvents_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSDiagnosticEvents_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSDiagnosticEvents_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvents_get_Item_Proxy( 
    IWMSDiagnosticEvents * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSDiagnosticEvent **pVal);


void __RPC_STUB IWMSDiagnosticEvents_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvents_get_Count_Proxy( 
    IWMSDiagnosticEvents * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSDiagnosticEvents_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvents_get_length_Proxy( 
    IWMSDiagnosticEvents * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSDiagnosticEvents_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvents_get__NewEnum_Proxy( 
    IWMSDiagnosticEvents * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSDiagnosticEvents_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSDiagnosticEvents_RemoveAll_Proxy( 
    IWMSDiagnosticEvents * This);


void __RPC_STUB IWMSDiagnosticEvents_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSDiagnosticEvents_INTERFACE_DEFINED__ */


#ifndef __IWMSFileDescription_INTERFACE_DEFINED__
#define __IWMSFileDescription_INTERFACE_DEFINED__

/* interface IWMSFileDescription */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("4124B8B4-BCE4-41c8-B49A-DA98C1401D3B") 
enum WMS_FILE_TYPE
    {	WMS_FILE_UNSPECIFIED	= 0,
	WMS_FILE_DIRECTORY	= 1,
	WMS_FILE_MEDIA	= 2,
	WMS_FILE_PLAYLIST	= 3,
	WMS_FILE_STREAM_FORMAT	= 4,
	WMS_FILE_REMOTE_FILE	= 5
    } 	WMS_FILE_TYPE;


EXTERN_C const IID IID_IWMSFileDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4124B8B3-BCE4-41c8-B49A-DA98C1401D3B")
    IWMSFileDescription : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ WMS_FILE_TYPE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSFileDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSFileDescription * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSFileDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSFileDescription * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSFileDescription * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSFileDescription * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSFileDescription * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSFileDescription * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSFileDescription * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSFileDescription * This,
            /* [retval][out] */ WMS_FILE_TYPE *pVal);
        
        END_INTERFACE
    } IWMSFileDescriptionVtbl;

    interface IWMSFileDescription
    {
        CONST_VTBL struct IWMSFileDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSFileDescription_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSFileDescription_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSFileDescription_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSFileDescription_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSFileDescription_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSFileDescription_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSFileDescription_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSFileDescription_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSFileDescription_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescription_get_Name_Proxy( 
    IWMSFileDescription * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSFileDescription_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescription_get_Type_Proxy( 
    IWMSFileDescription * This,
    /* [retval][out] */ WMS_FILE_TYPE *pVal);


void __RPC_STUB IWMSFileDescription_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSFileDescription_INTERFACE_DEFINED__ */


#ifndef __IWMSFileDescriptions_INTERFACE_DEFINED__
#define __IWMSFileDescriptions_INTERFACE_DEFINED__

/* interface IWMSFileDescriptions */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSFileDescriptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4124B8B2-BCE4-41c8-B49A-DA98C1401D3B")
    IWMSFileDescriptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSFileDescription **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ const VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDataSourceDirectory( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSFileDescriptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSFileDescriptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSFileDescriptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSFileDescriptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSFileDescriptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSFileDescriptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSFileDescriptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSFileDescriptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSFileDescriptions * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSFileDescription **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSFileDescriptions * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSFileDescriptions * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSFileDescriptions * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWMSFileDescriptions * This,
            /* [in] */ const VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDataSourceDirectory )( 
            IWMSFileDescriptions * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } IWMSFileDescriptionsVtbl;

    interface IWMSFileDescriptions
    {
        CONST_VTBL struct IWMSFileDescriptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSFileDescriptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSFileDescriptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSFileDescriptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSFileDescriptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSFileDescriptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSFileDescriptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSFileDescriptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSFileDescriptions_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSFileDescriptions_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSFileDescriptions_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSFileDescriptions_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSFileDescriptions_Delete(This,varIndex)	\
    (This)->lpVtbl -> Delete(This,varIndex)

#define IWMSFileDescriptions_CreateDataSourceDirectory(This,bstrName)	\
    (This)->lpVtbl -> CreateDataSourceDirectory(This,bstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_get_Item_Proxy( 
    IWMSFileDescriptions * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSFileDescription **pVal);


void __RPC_STUB IWMSFileDescriptions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_get_Count_Proxy( 
    IWMSFileDescriptions * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSFileDescriptions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_get_length_Proxy( 
    IWMSFileDescriptions * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSFileDescriptions_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_get__NewEnum_Proxy( 
    IWMSFileDescriptions * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSFileDescriptions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_Delete_Proxy( 
    IWMSFileDescriptions * This,
    /* [in] */ const VARIANT varIndex);


void __RPC_STUB IWMSFileDescriptions_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSFileDescriptions_CreateDataSourceDirectory_Proxy( 
    IWMSFileDescriptions * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IWMSFileDescriptions_CreateDataSourceDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSFileDescriptions_INTERFACE_DEFINED__ */


#ifndef __IWMSAvailableIPAddresses_INTERFACE_DEFINED__
#define __IWMSAvailableIPAddresses_INTERFACE_DEFINED__

/* interface IWMSAvailableIPAddresses */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSAvailableIPAddresses;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3FC1A813-759F-4441-BA48-21889EC8AC20")
    IWMSAvailableIPAddresses : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSAvailableIPAddressesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSAvailableIPAddresses * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSAvailableIPAddresses * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSAvailableIPAddresses * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSAvailableIPAddresses * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSAvailableIPAddresses * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSAvailableIPAddresses * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSAvailableIPAddresses * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSAvailableIPAddresses * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSAvailableIPAddresses * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSAvailableIPAddresses * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSAvailableIPAddresses * This,
            /* [retval][out] */ IUnknown **pVal);
        
        END_INTERFACE
    } IWMSAvailableIPAddressesVtbl;

    interface IWMSAvailableIPAddresses
    {
        CONST_VTBL struct IWMSAvailableIPAddressesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSAvailableIPAddresses_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSAvailableIPAddresses_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSAvailableIPAddresses_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSAvailableIPAddresses_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSAvailableIPAddresses_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSAvailableIPAddresses_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSAvailableIPAddresses_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSAvailableIPAddresses_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSAvailableIPAddresses_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSAvailableIPAddresses_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSAvailableIPAddresses_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAvailableIPAddresses_get_Item_Proxy( 
    IWMSAvailableIPAddresses * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSAvailableIPAddresses_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAvailableIPAddresses_get_Count_Proxy( 
    IWMSAvailableIPAddresses * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSAvailableIPAddresses_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAvailableIPAddresses_get_length_Proxy( 
    IWMSAvailableIPAddresses * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSAvailableIPAddresses_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAvailableIPAddresses_get__NewEnum_Proxy( 
    IWMSAvailableIPAddresses * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSAvailableIPAddresses_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSAvailableIPAddresses_INTERFACE_DEFINED__ */


#ifndef __IWMSPlugins_INTERFACE_DEFINED__
#define __IWMSPlugins_INTERFACE_DEFINED__

/* interface IWMSPlugins */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPlugins;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("517758ec-603c-4b98-82c1-4b2fa7787166")
    IWMSPlugins : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPlugin **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ BSTR bstrDestName,
            /* [in] */ IWMSPlugin *pSrcPlugin,
            /* [retval][out] */ IWMSPlugin **pDestPlugin) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPluginsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlugins * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlugins * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlugins * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPlugins * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPlugins * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPlugins * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPlugins * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSPlugins * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPlugin **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSPlugins * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSPlugins * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSPlugins * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSPlugins * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWMSPlugins * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWMSPlugins * This,
            /* [in] */ BSTR bstrDestName,
            /* [in] */ IWMSPlugin *pSrcPlugin,
            /* [retval][out] */ IWMSPlugin **pDestPlugin);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IWMSPlugins * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IWMSPluginsVtbl;

    interface IWMSPlugins
    {
        CONST_VTBL struct IWMSPluginsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlugins_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlugins_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlugins_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlugins_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPlugins_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPlugins_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPlugins_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPlugins_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSPlugins_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSPlugins_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSPlugins_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSPlugins_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define IWMSPlugins_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWMSPlugins_Clone(This,bstrDestName,pSrcPlugin,pDestPlugin)	\
    (This)->lpVtbl -> Clone(This,bstrDestName,pSrcPlugin,pDestPlugin)

#define IWMSPlugins_get_Category(This,pVal)	\
    (This)->lpVtbl -> get_Category(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_get_Item_Proxy( 
    IWMSPlugins * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSPlugin **pVal);


void __RPC_STUB IWMSPlugins_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_get_Count_Proxy( 
    IWMSPlugins * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlugins_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_get_length_Proxy( 
    IWMSPlugins * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlugins_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_get__NewEnum_Proxy( 
    IWMSPlugins * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSPlugins_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_Remove_Proxy( 
    IWMSPlugins * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSPlugins_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_Refresh_Proxy( 
    IWMSPlugins * This);


void __RPC_STUB IWMSPlugins_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_Clone_Proxy( 
    IWMSPlugins * This,
    /* [in] */ BSTR bstrDestName,
    /* [in] */ IWMSPlugin *pSrcPlugin,
    /* [retval][out] */ IWMSPlugin **pDestPlugin);


void __RPC_STUB IWMSPlugins_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugins_get_Category_Proxy( 
    IWMSPlugins * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlugins_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlugins_INTERFACE_DEFINED__ */


#ifndef __IWMSCacheItem_INTERFACE_DEFINED__
#define __IWMSCacheItem_INTERFACE_DEFINED__

/* interface IWMSCacheItem */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("517758e8-603c-4b98-82c1-4b2fa7787166")
    IWMSCacheItem : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OriginUrl( 
            /* [retval][out] */ BSTR *pOriginUrl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContentSize( 
            /* [retval][out] */ VARIANT *pContentSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSCacheItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSCacheItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSCacheItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSCacheItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OriginUrl )( 
            IWMSCacheItem * This,
            /* [retval][out] */ BSTR *pOriginUrl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentSize )( 
            IWMSCacheItem * This,
            /* [retval][out] */ VARIANT *pContentSize);
        
        END_INTERFACE
    } IWMSCacheItemVtbl;

    interface IWMSCacheItem
    {
        CONST_VTBL struct IWMSCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSCacheItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSCacheItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSCacheItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSCacheItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSCacheItem_get_OriginUrl(This,pOriginUrl)	\
    (This)->lpVtbl -> get_OriginUrl(This,pOriginUrl)

#define IWMSCacheItem_get_ContentSize(This,pContentSize)	\
    (This)->lpVtbl -> get_ContentSize(This,pContentSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItem_get_OriginUrl_Proxy( 
    IWMSCacheItem * This,
    /* [retval][out] */ BSTR *pOriginUrl);


void __RPC_STUB IWMSCacheItem_get_OriginUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItem_get_ContentSize_Proxy( 
    IWMSCacheItem * This,
    /* [retval][out] */ VARIANT *pContentSize);


void __RPC_STUB IWMSCacheItem_get_ContentSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSCacheItem_INTERFACE_DEFINED__ */


#ifndef __IWMSCacheItems_INTERFACE_DEFINED__
#define __IWMSCacheItems_INTERFACE_DEFINED__

/* interface IWMSCacheItems */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSCacheItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("517758e9-603c-4b98-82c1-4b2fa7787166")
    IWMSCacheItems : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSCacheItem **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSCacheItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSCacheItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSCacheItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSCacheItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSCacheItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSCacheItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSCacheItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSCacheItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSCacheItems * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSCacheItem **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSCacheItems * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSCacheItems * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSCacheItems * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWMSCacheItems * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteAll )( 
            IWMSCacheItems * This);
        
        END_INTERFACE
    } IWMSCacheItemsVtbl;

    interface IWMSCacheItems
    {
        CONST_VTBL struct IWMSCacheItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSCacheItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSCacheItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSCacheItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSCacheItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSCacheItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSCacheItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSCacheItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSCacheItems_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSCacheItems_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSCacheItems_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSCacheItems_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSCacheItems_Delete(This,varIndex)	\
    (This)->lpVtbl -> Delete(This,varIndex)

#define IWMSCacheItems_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_get_Item_Proxy( 
    IWMSCacheItems * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSCacheItem **pVal);


void __RPC_STUB IWMSCacheItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_get_Count_Proxy( 
    IWMSCacheItems * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSCacheItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_get_length_Proxy( 
    IWMSCacheItems * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSCacheItems_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_get__NewEnum_Proxy( 
    IWMSCacheItems * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSCacheItems_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_Delete_Proxy( 
    IWMSCacheItems * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSCacheItems_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSCacheItems_DeleteAll_Proxy( 
    IWMSCacheItems * This);


void __RPC_STUB IWMSCacheItems_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSCacheItems_INTERFACE_DEFINED__ */


#ifndef __IWMSCacheProxyPlugin_INTERFACE_DEFINED__
#define __IWMSCacheProxyPlugin_INTERFACE_DEFINED__

/* interface IWMSCacheProxyPlugin */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSCacheProxyPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("517758eb-603c-4b98-82c1-4b2fa7787166")
    IWMSCacheProxyPlugin : public IWMSPlugin
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PreStuff( 
            /* [in] */ BSTR OriginURL,
            /* [defaultvalue][in] */ BSTR SourcePath = L"",
            /* [defaultvalue][in] */ long lExpiration = -1,
            /* [defaultvalue][in] */ long lBandwidth = 0,
            /* [defaultvalue][in] */ long lRemoteEventFlags = 0) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheItems( 
            /* [retval][out] */ IWMSCacheItems **ppVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSCacheProxyPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSCacheProxyPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSCacheProxyPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSCacheProxyPlugin * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ BSTR pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CustomInterface )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ IDispatch **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadType )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoadType )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorText )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionOrder )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionOrder )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportStatus )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ WMS_PLUGIN_SUPPORT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PreStuff )( 
            IWMSCacheProxyPlugin * This,
            /* [in] */ BSTR OriginURL,
            /* [defaultvalue][in] */ BSTR SourcePath,
            /* [defaultvalue][in] */ long lExpiration,
            /* [defaultvalue][in] */ long lBandwidth,
            /* [defaultvalue][in] */ long lRemoteEventFlags);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheItems )( 
            IWMSCacheProxyPlugin * This,
            /* [retval][out] */ IWMSCacheItems **ppVal);
        
        END_INTERFACE
    } IWMSCacheProxyPluginVtbl;

    interface IWMSCacheProxyPlugin
    {
        CONST_VTBL struct IWMSCacheProxyPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSCacheProxyPlugin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSCacheProxyPlugin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSCacheProxyPlugin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSCacheProxyPlugin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSCacheProxyPlugin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSCacheProxyPlugin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSCacheProxyPlugin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSCacheProxyPlugin_put_Name(This,pVal)	\
    (This)->lpVtbl -> put_Name(This,pVal)

#define IWMSCacheProxyPlugin_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSCacheProxyPlugin_get_Enabled(This,pVal)	\
    (This)->lpVtbl -> get_Enabled(This,pVal)

#define IWMSCacheProxyPlugin_put_Enabled(This,newVal)	\
    (This)->lpVtbl -> put_Enabled(This,newVal)

#define IWMSCacheProxyPlugin_get_CLSID(This,pVal)	\
    (This)->lpVtbl -> get_CLSID(This,pVal)

#define IWMSCacheProxyPlugin_get_CustomInterface(This,ppVal)	\
    (This)->lpVtbl -> get_CustomInterface(This,ppVal)

#define IWMSCacheProxyPlugin_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSCacheProxyPlugin_get_ErrorCode(This,pVal)	\
    (This)->lpVtbl -> get_ErrorCode(This,pVal)

#define IWMSCacheProxyPlugin_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSCacheProxyPlugin_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#define IWMSCacheProxyPlugin_get_LoadType(This,pVal)	\
    (This)->lpVtbl -> get_LoadType(This,pVal)

#define IWMSCacheProxyPlugin_put_LoadType(This,val)	\
    (This)->lpVtbl -> put_LoadType(This,val)

#define IWMSCacheProxyPlugin_get_ErrorText(This,pVal)	\
    (This)->lpVtbl -> get_ErrorText(This,pVal)

#define IWMSCacheProxyPlugin_get_SelectionOrder(This,pVal)	\
    (This)->lpVtbl -> get_SelectionOrder(This,pVal)

#define IWMSCacheProxyPlugin_put_SelectionOrder(This,lVal)	\
    (This)->lpVtbl -> put_SelectionOrder(This,lVal)

#define IWMSCacheProxyPlugin_get_SupportStatus(This,pVal)	\
    (This)->lpVtbl -> get_SupportStatus(This,pVal)

#define IWMSCacheProxyPlugin_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)


#define IWMSCacheProxyPlugin_PreStuff(This,OriginURL,SourcePath,lExpiration,lBandwidth,lRemoteEventFlags)	\
    (This)->lpVtbl -> PreStuff(This,OriginURL,SourcePath,lExpiration,lBandwidth,lRemoteEventFlags)

#define IWMSCacheProxyPlugin_get_CacheItems(This,ppVal)	\
    (This)->lpVtbl -> get_CacheItems(This,ppVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSCacheProxyPlugin_PreStuff_Proxy( 
    IWMSCacheProxyPlugin * This,
    /* [in] */ BSTR OriginURL,
    /* [defaultvalue][in] */ BSTR SourcePath,
    /* [defaultvalue][in] */ long lExpiration,
    /* [defaultvalue][in] */ long lBandwidth,
    /* [defaultvalue][in] */ long lRemoteEventFlags);


void __RPC_STUB IWMSCacheProxyPlugin_PreStuff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSCacheProxyPlugin_get_CacheItems_Proxy( 
    IWMSCacheProxyPlugin * This,
    /* [retval][out] */ IWMSCacheItems **ppVal);


void __RPC_STUB IWMSCacheProxyPlugin_get_CacheItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSCacheProxyPlugin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsserver_0192 */
/* [local] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("60f2ee55-dcaa-4cb6-a6d2-12bc23ac9df0") 
enum WMS_CLIENT_STATUS
    {	WMS_CLIENT_DISCONNECTED	= 0,
	WMS_CLIENT_IDLE	= 0x1,
	WMS_CLIENT_OPEN	= 0x2,
	WMS_CLIENT_STREAMING	= 0x3
    } 	WMS_CLIENT_STATUS;



extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0192_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0192_v0_0_s_ifspec;

#ifndef __IWMSOutgoingDistributionConnection_INTERFACE_DEFINED__
#define __IWMSOutgoingDistributionConnection_INTERFACE_DEFINED__

/* interface IWMSOutgoingDistributionConnection */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSOutgoingDistributionConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60f2ee54-dcaa-4cb6-a6d2-12bc23ac9df0")
    IWMSOutgoingDistributionConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedPlaylist( 
            /* [retval][out] */ IWMSPlaylist **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResolvedURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ WMS_CLIENT_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WrapperPlaylist( 
            /* [retval][out] */ IWMSPlaylist **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSOutgoingDistributionConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSOutgoingDistributionConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSOutgoingDistributionConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSOutgoingDistributionConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSOutgoingDistributionConnection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSOutgoingDistributionConnection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSOutgoingDistributionConnection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSOutgoingDistributionConnection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAddress )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedPlaylist )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ IWMSPlaylist **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedURL )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResolvedURL )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ WMS_CLIENT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPlaylist )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ IWMSPlaylist **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            IWMSOutgoingDistributionConnection * This,
            /* [retval][out] */ long *pVal);
        
        END_INTERFACE
    } IWMSOutgoingDistributionConnectionVtbl;

    interface IWMSOutgoingDistributionConnection
    {
        CONST_VTBL struct IWMSOutgoingDistributionConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSOutgoingDistributionConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSOutgoingDistributionConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSOutgoingDistributionConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSOutgoingDistributionConnection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSOutgoingDistributionConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSOutgoingDistributionConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSOutgoingDistributionConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSOutgoingDistributionConnection_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IWMSOutgoingDistributionConnection_get_NetworkAddress(This,pVal)	\
    (This)->lpVtbl -> get_NetworkAddress(This,pVal)

#define IWMSOutgoingDistributionConnection_get_RequestedPlaylist(This,pVal)	\
    (This)->lpVtbl -> get_RequestedPlaylist(This,pVal)

#define IWMSOutgoingDistributionConnection_get_RequestedURL(This,pVal)	\
    (This)->lpVtbl -> get_RequestedURL(This,pVal)

#define IWMSOutgoingDistributionConnection_get_ResolvedURL(This,pVal)	\
    (This)->lpVtbl -> get_ResolvedURL(This,pVal)

#define IWMSOutgoingDistributionConnection_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSOutgoingDistributionConnection_get_UserName(This,pVal)	\
    (This)->lpVtbl -> get_UserName(This,pVal)

#define IWMSOutgoingDistributionConnection_get_WrapperPlaylist(This,pVal)	\
    (This)->lpVtbl -> get_WrapperPlaylist(This,pVal)

#define IWMSOutgoingDistributionConnection_get_Port(This,pVal)	\
    (This)->lpVtbl -> get_Port(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_ID_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_NetworkAddress_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_NetworkAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_RequestedPlaylist_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ IWMSPlaylist **pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_RequestedPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_RequestedURL_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_RequestedURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_ResolvedURL_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_ResolvedURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_Status_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ WMS_CLIENT_STATUS *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_UserName_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_WrapperPlaylist_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ IWMSPlaylist **pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_WrapperPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnection_get_Port_Proxy( 
    IWMSOutgoingDistributionConnection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnection_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSOutgoingDistributionConnection_INTERFACE_DEFINED__ */


#ifndef __IWMSOutgoingDistributionConnections_INTERFACE_DEFINED__
#define __IWMSOutgoingDistributionConnections_INTERFACE_DEFINED__

/* interface IWMSOutgoingDistributionConnections */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSOutgoingDistributionConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60f2ee53-dcaa-4cb6-a6d2-12bc23ac9df0")
    IWMSOutgoingDistributionConnections : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSOutgoingDistributionConnection **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSOutgoingDistributionConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSOutgoingDistributionConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSOutgoingDistributionConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSOutgoingDistributionConnections * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSOutgoingDistributionConnection **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSOutgoingDistributionConnections * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSOutgoingDistributionConnections * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSOutgoingDistributionConnections * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWMSOutgoingDistributionConnections * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSOutgoingDistributionConnections * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWMSOutgoingDistributionConnections * This);
        
        END_INTERFACE
    } IWMSOutgoingDistributionConnectionsVtbl;

    interface IWMSOutgoingDistributionConnections
    {
        CONST_VTBL struct IWMSOutgoingDistributionConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSOutgoingDistributionConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSOutgoingDistributionConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSOutgoingDistributionConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSOutgoingDistributionConnections_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSOutgoingDistributionConnections_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSOutgoingDistributionConnections_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSOutgoingDistributionConnections_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSOutgoingDistributionConnections_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSOutgoingDistributionConnections_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSOutgoingDistributionConnections_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSOutgoingDistributionConnections_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSOutgoingDistributionConnections_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWMSOutgoingDistributionConnections_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define IWMSOutgoingDistributionConnections_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_get_Item_Proxy( 
    IWMSOutgoingDistributionConnections * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSOutgoingDistributionConnection **pVal);


void __RPC_STUB IWMSOutgoingDistributionConnections_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_get_Count_Proxy( 
    IWMSOutgoingDistributionConnections * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnections_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_get_length_Proxy( 
    IWMSOutgoingDistributionConnections * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSOutgoingDistributionConnections_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_get__NewEnum_Proxy( 
    IWMSOutgoingDistributionConnections * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSOutgoingDistributionConnections_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_Refresh_Proxy( 
    IWMSOutgoingDistributionConnections * This);


void __RPC_STUB IWMSOutgoingDistributionConnections_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_Remove_Proxy( 
    IWMSOutgoingDistributionConnections * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSOutgoingDistributionConnections_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSOutgoingDistributionConnections_RemoveAll_Proxy( 
    IWMSOutgoingDistributionConnections * This);


void __RPC_STUB IWMSOutgoingDistributionConnections_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSOutgoingDistributionConnections_INTERFACE_DEFINED__ */


#ifndef __IWMSPlayer_INTERFACE_DEFINED__
#define __IWMSPlayer_INTERFACE_DEFINED__

/* interface IWMSPlayer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18812736-4BEC-11D2-BF25-00805FBE84A6")
    IWMSPlayer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedPlaylist( 
            /* [retval][out] */ IWMSPlaylist **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResolvedURL( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ WMS_CLIENT_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WrapperPlaylist( 
            /* [retval][out] */ IWMSPlaylist **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlayer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlayer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlayer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPlayer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPlayer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPlayer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPlayer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSPlayer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAddress )( 
            IWMSPlayer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedPlaylist )( 
            IWMSPlayer * This,
            /* [retval][out] */ IWMSPlaylist **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedURL )( 
            IWMSPlayer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResolvedURL )( 
            IWMSPlayer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSPlayer * This,
            /* [retval][out] */ WMS_CLIENT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IWMSPlayer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPlaylist )( 
            IWMSPlayer * This,
            /* [retval][out] */ IWMSPlaylist **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            IWMSPlayer * This,
            /* [retval][out] */ long *pVal);
        
        END_INTERFACE
    } IWMSPlayerVtbl;

    interface IWMSPlayer
    {
        CONST_VTBL struct IWMSPlayerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlayer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlayer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlayer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlayer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPlayer_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IWMSPlayer_get_NetworkAddress(This,pVal)	\
    (This)->lpVtbl -> get_NetworkAddress(This,pVal)

#define IWMSPlayer_get_RequestedPlaylist(This,pVal)	\
    (This)->lpVtbl -> get_RequestedPlaylist(This,pVal)

#define IWMSPlayer_get_RequestedURL(This,pVal)	\
    (This)->lpVtbl -> get_RequestedURL(This,pVal)

#define IWMSPlayer_get_ResolvedURL(This,pVal)	\
    (This)->lpVtbl -> get_ResolvedURL(This,pVal)

#define IWMSPlayer_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSPlayer_get_UserName(This,pVal)	\
    (This)->lpVtbl -> get_UserName(This,pVal)

#define IWMSPlayer_get_WrapperPlaylist(This,pVal)	\
    (This)->lpVtbl -> get_WrapperPlaylist(This,pVal)

#define IWMSPlayer_get_Port(This,pVal)	\
    (This)->lpVtbl -> get_Port(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_ID_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlayer_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_NetworkAddress_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlayer_get_NetworkAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_RequestedPlaylist_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ IWMSPlaylist **pVal);


void __RPC_STUB IWMSPlayer_get_RequestedPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_RequestedURL_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlayer_get_RequestedURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_ResolvedURL_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlayer_get_ResolvedURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_Status_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ WMS_CLIENT_STATUS *pVal);


void __RPC_STUB IWMSPlayer_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_UserName_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlayer_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_WrapperPlaylist_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ IWMSPlaylist **pVal);


void __RPC_STUB IWMSPlayer_get_WrapperPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayer_get_Port_Proxy( 
    IWMSPlayer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlayer_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlayer_INTERFACE_DEFINED__ */


#ifndef __IWMSPlayers_INTERFACE_DEFINED__
#define __IWMSPlayers_INTERFACE_DEFINED__

/* interface IWMSPlayers */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPlayers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18812738-4BEC-11D2-BF25-00805FBE84A6")
    IWMSPlayers : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPlayer **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPlayersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlayers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlayers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlayers * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPlayers * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPlayers * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPlayers * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPlayers * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSPlayers * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPlayer **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSPlayers * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSPlayers * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSPlayers * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWMSPlayers * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSPlayers * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWMSPlayers * This);
        
        END_INTERFACE
    } IWMSPlayersVtbl;

    interface IWMSPlayers
    {
        CONST_VTBL struct IWMSPlayersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlayers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlayers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlayers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlayers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPlayers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPlayers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPlayers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPlayers_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSPlayers_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSPlayers_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSPlayers_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSPlayers_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWMSPlayers_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define IWMSPlayers_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_get_Item_Proxy( 
    IWMSPlayers * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSPlayer **pVal);


void __RPC_STUB IWMSPlayers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_get_Count_Proxy( 
    IWMSPlayers * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlayers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_get_length_Proxy( 
    IWMSPlayers * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlayers_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_get__NewEnum_Proxy( 
    IWMSPlayers * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSPlayers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_Refresh_Proxy( 
    IWMSPlayers * This);


void __RPC_STUB IWMSPlayers_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_Remove_Proxy( 
    IWMSPlayers * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSPlayers_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPlayers_RemoveAll_Proxy( 
    IWMSPlayers * This);


void __RPC_STUB IWMSPlayers_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlayers_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPointCurrentCounters_INTERFACE_DEFINED__
#define __IWMSPublishingPointCurrentCounters_INTERFACE_DEFINED__

/* interface IWMSPublishingPointCurrentCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPublishingPointCurrentCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("638DFA30-1054-48bd-B030-C3DA1FC18154")
    IWMSPublishingPointCurrentCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingHTTPPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingMMSPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingRTSPPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointCurrentCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPointCurrentCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPointCurrentCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingHTTPPlayers )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingMMSPlayers )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingRTSPPlayers )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSPublishingPointCurrentCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSPublishingPointCurrentCountersVtbl;

    interface IWMSPublishingPointCurrentCounters
    {
        CONST_VTBL struct IWMSPublishingPointCurrentCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPointCurrentCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPointCurrentCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPointCurrentCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPointCurrentCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPointCurrentCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPointCurrentCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPointCurrentCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPointCurrentCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_StreamingHTTPPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingHTTPPlayers(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_StreamingMMSPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingMMSPlayers(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_StreamingRTSPPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingRTSPPlayers(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSPublishingPointCurrentCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_ConnectedPlayers_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_StreamingHTTPPlayers_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_StreamingHTTPPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_StreamingMMSPlayers_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_StreamingMMSPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_OutgoingDistributionAllocatedBandwidth_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_OutgoingDistributionAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_PlayerAllocatedBandwidth_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_PlayerAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_StreamingRTSPPlayers_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_StreamingRTSPPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_StreamingPlayers_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointCurrentCounters_get_AllCounters_Proxy( 
    IWMSPublishingPointCurrentCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSPublishingPointCurrentCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPointCurrentCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPointPeakCounters_INTERFACE_DEFINED__
#define __IWMSPublishingPointPeakCounters_INTERFACE_DEFINED__

/* interface IWMSPublishingPointPeakCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPublishingPointPeakCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43B20CC5-CA36-4e7b-ADAF-C9C60D00BB0E")
    IWMSPublishingPointPeakCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountersStartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointPeakCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPointPeakCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPointPeakCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPointPeakCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPointPeakCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPointPeakCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPointPeakCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPointPeakCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSPublishingPointPeakCounters * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSPublishingPointPeakCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSPublishingPointPeakCountersVtbl;

    interface IWMSPublishingPointPeakCounters
    {
        CONST_VTBL struct IWMSPublishingPointPeakCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPointPeakCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPointPeakCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPointPeakCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPointPeakCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPointPeakCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPointPeakCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPointPeakCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPointPeakCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSPublishingPointPeakCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSPublishingPointPeakCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal)

#define IWMSPublishingPointPeakCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal)

#define IWMSPublishingPointPeakCounters_get_CountersStartTime(This,pVal)	\
    (This)->lpVtbl -> get_CountersStartTime(This,pVal)

#define IWMSPublishingPointPeakCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSPublishingPointPeakCounters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMSPublishingPointPeakCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_ConnectedPlayers_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_OutgoingDistributionAllocatedBandwidth_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_OutgoingDistributionAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_PlayerAllocatedBandwidth_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_PlayerAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_CountersStartTime_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_CountersStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_StreamingPlayers_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_Reset_Proxy( 
    IWMSPublishingPointPeakCounters * This);


void __RPC_STUB IWMSPublishingPointPeakCounters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointPeakCounters_get_AllCounters_Proxy( 
    IWMSPublishingPointPeakCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSPublishingPointPeakCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPointPeakCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPointLimits_INTERFACE_DEFINED__
#define __IWMSPublishingPointLimits_INTERFACE_DEFINED__

/* interface IWMSPublishingPointLimits */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPublishingPointLimits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CD5BC19-35FD-4501-A953-FEB57AAE9C13")
    IWMSPublishingPointLimits : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectedPlayers( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionConnections( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerOutgoingDistributionConnectionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerOutgoingDistributionConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerPlayerConnectionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerPlayerConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerCacheDeliveryRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerCacheDeliveryRate( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FECPacketSpan( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FECPacketSpan( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerPlayerRapidStartBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerPlayerRapidStartBandwidth( 
            /* [in] */ long Val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointLimitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPointLimits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPointLimits * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPointLimits * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectedPlayers )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionConnections )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerPlayerConnectionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerPlayerConnectionBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerCacheDeliveryRate )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerCacheDeliveryRate )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FECPacketSpan )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FECPacketSpan )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerPlayerRapidStartBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerPlayerRapidStartBandwidth )( 
            IWMSPublishingPointLimits * This,
            /* [in] */ long Val);
        
        END_INTERFACE
    } IWMSPublishingPointLimitsVtbl;

    interface IWMSPublishingPointLimits
    {
        CONST_VTBL struct IWMSPublishingPointLimitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPointLimits_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPointLimits_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPointLimits_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPointLimits_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPointLimits_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPointLimits_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPointLimits_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPointLimits_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSPublishingPointLimits_put_ConnectedPlayers(This,Val)	\
    (This)->lpVtbl -> put_ConnectedPlayers(This,Val)

#define IWMSPublishingPointLimits_get_OutgoingDistributionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionBandwidth(This,pVal)

#define IWMSPublishingPointLimits_put_OutgoingDistributionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_OutgoingDistributionBandwidth(This,Val)

#define IWMSPublishingPointLimits_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSPublishingPointLimits_put_OutgoingDistributionConnections(This,Val)	\
    (This)->lpVtbl -> put_OutgoingDistributionConnections(This,Val)

#define IWMSPublishingPointLimits_get_PerOutgoingDistributionConnectionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PerOutgoingDistributionConnectionBandwidth(This,pVal)

#define IWMSPublishingPointLimits_put_PerOutgoingDistributionConnectionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PerOutgoingDistributionConnectionBandwidth(This,Val)

#define IWMSPublishingPointLimits_get_PlayerBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerBandwidth(This,pVal)

#define IWMSPublishingPointLimits_put_PlayerBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PlayerBandwidth(This,Val)

#define IWMSPublishingPointLimits_get_PerPlayerConnectionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PerPlayerConnectionBandwidth(This,pVal)

#define IWMSPublishingPointLimits_put_PerPlayerConnectionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PerPlayerConnectionBandwidth(This,Val)

#define IWMSPublishingPointLimits_get_PlayerCacheDeliveryRate(This,pVal)	\
    (This)->lpVtbl -> get_PlayerCacheDeliveryRate(This,pVal)

#define IWMSPublishingPointLimits_put_PlayerCacheDeliveryRate(This,Val)	\
    (This)->lpVtbl -> put_PlayerCacheDeliveryRate(This,Val)

#define IWMSPublishingPointLimits_get_FECPacketSpan(This,pVal)	\
    (This)->lpVtbl -> get_FECPacketSpan(This,pVal)

#define IWMSPublishingPointLimits_put_FECPacketSpan(This,Val)	\
    (This)->lpVtbl -> put_FECPacketSpan(This,Val)

#define IWMSPublishingPointLimits_get_PerPlayerRapidStartBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PerPlayerRapidStartBandwidth(This,pVal)

#define IWMSPublishingPointLimits_put_PerPlayerRapidStartBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PerPlayerRapidStartBandwidth(This,Val)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_ConnectedPlayers_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_ConnectedPlayers_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_OutgoingDistributionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_OutgoingDistributionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_OutgoingDistributionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_OutgoingDistributionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_PerOutgoingDistributionConnectionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_PerOutgoingDistributionConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_PerOutgoingDistributionConnectionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_PerOutgoingDistributionConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_PlayerBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_PlayerBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_PlayerBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_PlayerBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_PerPlayerConnectionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_PerPlayerConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_PerPlayerConnectionBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_PerPlayerConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_PlayerCacheDeliveryRate_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_PlayerCacheDeliveryRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_PlayerCacheDeliveryRate_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_PlayerCacheDeliveryRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_FECPacketSpan_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_FECPacketSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_FECPacketSpan_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_FECPacketSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_get_PerPlayerRapidStartBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointLimits_get_PerPlayerRapidStartBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointLimits_put_PerPlayerRapidStartBandwidth_Proxy( 
    IWMSPublishingPointLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSPublishingPointLimits_put_PerPlayerRapidStartBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPointLimits_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPointTotalCounters_INTERFACE_DEFINED__
#define __IWMSPublishingPointTotalCounters_INTERFACE_DEFINED__

/* interface IWMSPublishingPointTotalCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSPublishingPointTotalCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("240D0C87-309A-4126-BF14-B52A622E95A9")
    IWMSPublishingPointTotalCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateReads( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionBytesSent( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerBytesSent( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountersStartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamDenials( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamErrors( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamTerminations( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileBytesRead( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Advertisements( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointTotalCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPointTotalCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPointTotalCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPointTotalCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPointTotalCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPointTotalCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPointTotalCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPointTotalCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateReads )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionBytesSent )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerBytesSent )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamDenials )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamErrors )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamTerminations )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileBytesRead )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Advertisements )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSPublishingPointTotalCounters * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSPublishingPointTotalCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSPublishingPointTotalCountersVtbl;

    interface IWMSPublishingPointTotalCounters
    {
        CONST_VTBL struct IWMSPublishingPointTotalCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPointTotalCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPointTotalCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPointTotalCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPointTotalCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPointTotalCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPointTotalCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPointTotalCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPointTotalCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSPublishingPointTotalCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSPublishingPointTotalCounters_get_LateReads(This,pVal)	\
    (This)->lpVtbl -> get_LateReads(This,pVal)

#define IWMSPublishingPointTotalCounters_get_OutgoingDistributionBytesSent(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionBytesSent(This,pVal)

#define IWMSPublishingPointTotalCounters_get_PlayerBytesSent(This,pVal)	\
    (This)->lpVtbl -> get_PlayerBytesSent(This,pVal)

#define IWMSPublishingPointTotalCounters_get_CountersStartTime(This,pVal)	\
    (This)->lpVtbl -> get_CountersStartTime(This,pVal)

#define IWMSPublishingPointTotalCounters_get_StreamDenials(This,pVal)	\
    (This)->lpVtbl -> get_StreamDenials(This,pVal)

#define IWMSPublishingPointTotalCounters_get_StreamErrors(This,pVal)	\
    (This)->lpVtbl -> get_StreamErrors(This,pVal)

#define IWMSPublishingPointTotalCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSPublishingPointTotalCounters_get_StreamTerminations(This,pVal)	\
    (This)->lpVtbl -> get_StreamTerminations(This,pVal)

#define IWMSPublishingPointTotalCounters_get_FileBytesRead(This,pVal)	\
    (This)->lpVtbl -> get_FileBytesRead(This,pVal)

#define IWMSPublishingPointTotalCounters_get_Advertisements(This,pVal)	\
    (This)->lpVtbl -> get_Advertisements(This,pVal)

#define IWMSPublishingPointTotalCounters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMSPublishingPointTotalCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_ConnectedPlayers_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_LateReads_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_LateReads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_OutgoingDistributionBytesSent_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_OutgoingDistributionBytesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_PlayerBytesSent_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_PlayerBytesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_CountersStartTime_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_CountersStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_StreamDenials_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_StreamDenials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_StreamErrors_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_StreamErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_StreamingPlayers_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_StreamTerminations_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_StreamTerminations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_FileBytesRead_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_FileBytesRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_Advertisements_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_Advertisements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_Reset_Proxy( 
    IWMSPublishingPointTotalCounters * This);


void __RPC_STUB IWMSPublishingPointTotalCounters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPointTotalCounters_get_AllCounters_Proxy( 
    IWMSPublishingPointTotalCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSPublishingPointTotalCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPointTotalCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSServerTotalCounters_INTERFACE_DEFINED__
#define __IWMSServerTotalCounters_INTERFACE_DEFINED__

/* interface IWMSServerTotalCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerTotalCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DAA2A1BB-BC91-438d-BF33-BDE11D2348D5")
    IWMSServerTotalCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateReads( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionBytesSent( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerBytesSent( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountersStartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamDenials( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamErrors( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamTerminations( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendRequests( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendsSent( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateSends( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Advertisements( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerTotalCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerTotalCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerTotalCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerTotalCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerTotalCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerTotalCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerTotalCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerTotalCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateReads )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionBytesSent )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerBytesSent )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamDenials )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamErrors )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamTerminations )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendRequests )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendsSent )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateSends )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Advertisements )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSServerTotalCounters * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerTotalCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSServerTotalCountersVtbl;

    interface IWMSServerTotalCounters
    {
        CONST_VTBL struct IWMSServerTotalCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerTotalCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSServerTotalCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSServerTotalCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSServerTotalCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSServerTotalCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSServerTotalCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSServerTotalCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSServerTotalCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSServerTotalCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSServerTotalCounters_get_LateReads(This,pVal)	\
    (This)->lpVtbl -> get_LateReads(This,pVal)

#define IWMSServerTotalCounters_get_OutgoingDistributionBytesSent(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionBytesSent(This,pVal)

#define IWMSServerTotalCounters_get_PlayerBytesSent(This,pVal)	\
    (This)->lpVtbl -> get_PlayerBytesSent(This,pVal)

#define IWMSServerTotalCounters_get_CountersStartTime(This,pVal)	\
    (This)->lpVtbl -> get_CountersStartTime(This,pVal)

#define IWMSServerTotalCounters_get_StreamDenials(This,pVal)	\
    (This)->lpVtbl -> get_StreamDenials(This,pVal)

#define IWMSServerTotalCounters_get_StreamErrors(This,pVal)	\
    (This)->lpVtbl -> get_StreamErrors(This,pVal)

#define IWMSServerTotalCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSServerTotalCounters_get_StreamTerminations(This,pVal)	\
    (This)->lpVtbl -> get_StreamTerminations(This,pVal)

#define IWMSServerTotalCounters_get_UDPResendRequests(This,pVal)	\
    (This)->lpVtbl -> get_UDPResendRequests(This,pVal)

#define IWMSServerTotalCounters_get_UDPResendsSent(This,pVal)	\
    (This)->lpVtbl -> get_UDPResendsSent(This,pVal)

#define IWMSServerTotalCounters_get_LateSends(This,pVal)	\
    (This)->lpVtbl -> get_LateSends(This,pVal)

#define IWMSServerTotalCounters_get_Advertisements(This,pVal)	\
    (This)->lpVtbl -> get_Advertisements(This,pVal)

#define IWMSServerTotalCounters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMSServerTotalCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_ConnectedPlayers_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_LateReads_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_LateReads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_OutgoingDistributionBytesSent_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_OutgoingDistributionBytesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_PlayerBytesSent_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_PlayerBytesSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_CountersStartTime_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_CountersStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_StreamDenials_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_StreamDenials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_StreamErrors_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_StreamErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_StreamingPlayers_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_StreamTerminations_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_StreamTerminations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_UDPResendRequests_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_UDPResendRequests_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_UDPResendsSent_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_UDPResendsSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_LateSends_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_LateSends_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_Advertisements_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerTotalCounters_get_Advertisements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_Reset_Proxy( 
    IWMSServerTotalCounters * This);


void __RPC_STUB IWMSServerTotalCounters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerTotalCounters_get_AllCounters_Proxy( 
    IWMSServerTotalCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSServerTotalCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSServerTotalCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPoint_INTERFACE_DEFINED__
#define __IWMSPublishingPoint_INTERFACE_DEFINED__

/* interface IWMSPublishingPoint */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0EC-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_PUBLISHING_POINT_TYPE
    {	WMS_PUBLISHING_POINT_TYPE_ON_DEMAND	= 1,
	WMS_PUBLISHING_POINT_TYPE_BROADCAST	= 2,
	WMS_PUBLISHING_POINT_TYPE_CACHE_PROXY_ON_DEMAND	= 3,
	WMS_PUBLISHING_POINT_TYPE_CACHE_PROXY_BROADCAST	= 4
    } 	WMS_PUBLISHING_POINT_TYPE;

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0EF-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_PUBLISHING_POINT_STATUS
    {	WMS_PUBLISHING_POINT_RUNNING	= 0,
	WMS_PUBLISHING_POINT_ERROR	= 0x1,
	WMS_PUBLISHING_POINT_ERROR_CRITICAL	= 0x2
    } 	WMS_PUBLISHING_POINT_STATUS;


EXTERN_C const IID IID_IWMSPublishingPoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1881273F-4BEC-11D2-BF25-00805FBE84A6")
    IWMSPublishingPoint : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowClientsToConnect( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowClientsToConnect( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCounters( 
            /* [retval][out] */ IWMSPublishingPointCurrentCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventHandlers( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Limits( 
            /* [retval][out] */ IWMSPublishingPointLimits **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileDescriptions( 
            /* [defaultvalue][in] */ BSTR RelativePath,
            /* [retval][out] */ IWMSFileDescriptions **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MonikerName( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PeakCounters( 
            /* [retval][out] */ IWMSPublishingPointPeakCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Players( 
            /* [retval][out] */ IWMSPlayers **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IWMSNamedValues **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCounters( 
            /* [retval][out] */ IWMSPublishingPointTotalCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ WMS_PUBLISHING_POINT_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WrapperPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WrapperPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authenticators( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ WMS_PUBLISHING_POINT_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableWrapperPath( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableWrapperPath( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamFilters( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DistributionUserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDistributionUserNamePassword( 
            /* [string][in] */ wchar_t *newUserName,
            /* [string][in] */ wchar_t *newUserPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheProxyExpiration( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CacheProxyExpiration( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDistributionPasswordSet( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPlayerSideDiskCaching( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPlayerSideDiskCaching( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableFEC( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableFEC( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPoint * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPoint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPoint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSPublishingPoint * This,
            /* [defaultvalue][in] */ BSTR RelativePath,
            /* [retval][out] */ IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IWMSPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPath )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WrapperPath )( 
            IWMSPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableWrapperPath )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableWrapperPath )( 
            IWMSPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DistributionUserName )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDistributionUserNamePassword )( 
            IWMSPublishingPoint * This,
            /* [string][in] */ wchar_t *newUserName,
            /* [string][in] */ wchar_t *newUserPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxyExpiration )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CacheProxyExpiration )( 
            IWMSPublishingPoint * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDistributionPasswordSet )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayerSideDiskCaching )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayerSideDiskCaching )( 
            IWMSPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFEC )( 
            IWMSPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFEC )( 
            IWMSPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IWMSPublishingPointVtbl;

    interface IWMSPublishingPoint
    {
        CONST_VTBL struct IWMSPublishingPointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPoint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPoint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPoint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPoint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPoint_get_AllowClientsToConnect(This,pVal)	\
    (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal)

#define IWMSPublishingPoint_put_AllowClientsToConnect(This,newVal)	\
    (This)->lpVtbl -> put_AllowClientsToConnect(This,newVal)

#define IWMSPublishingPoint_get_CurrentCounters(This,pVal)	\
    (This)->lpVtbl -> get_CurrentCounters(This,pVal)

#define IWMSPublishingPoint_get_EventHandlers(This,pVal)	\
    (This)->lpVtbl -> get_EventHandlers(This,pVal)

#define IWMSPublishingPoint_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IWMSPublishingPoint_get_Limits(This,pVal)	\
    (This)->lpVtbl -> get_Limits(This,pVal)

#define IWMSPublishingPoint_get_FileDescriptions(This,RelativePath,pVal)	\
    (This)->lpVtbl -> get_FileDescriptions(This,RelativePath,pVal)

#define IWMSPublishingPoint_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)

#define IWMSPublishingPoint_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSPublishingPoint_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IWMSPublishingPoint_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSPublishingPoint_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IWMSPublishingPoint_put_Path(This,newVal)	\
    (This)->lpVtbl -> put_Path(This,newVal)

#define IWMSPublishingPoint_get_PeakCounters(This,pVal)	\
    (This)->lpVtbl -> get_PeakCounters(This,pVal)

#define IWMSPublishingPoint_get_Players(This,pVal)	\
    (This)->lpVtbl -> get_Players(This,pVal)

#define IWMSPublishingPoint_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSPublishingPoint_get_TotalCounters(This,pVal)	\
    (This)->lpVtbl -> get_TotalCounters(This,pVal)

#define IWMSPublishingPoint_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IWMSPublishingPoint_get_WrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_WrapperPath(This,pVal)

#define IWMSPublishingPoint_put_WrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_WrapperPath(This,newVal)

#define IWMSPublishingPoint_get_Authenticators(This,pVal)	\
    (This)->lpVtbl -> get_Authenticators(This,pVal)

#define IWMSPublishingPoint_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSPublishingPoint_get_EnableWrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_EnableWrapperPath(This,pVal)

#define IWMSPublishingPoint_put_EnableWrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_EnableWrapperPath(This,newVal)

#define IWMSPublishingPoint_get_StreamFilters(This,pVal)	\
    (This)->lpVtbl -> get_StreamFilters(This,pVal)

#define IWMSPublishingPoint_get_DistributionUserName(This,pVal)	\
    (This)->lpVtbl -> get_DistributionUserName(This,pVal)

#define IWMSPublishingPoint_SetDistributionUserNamePassword(This,newUserName,newUserPassword)	\
    (This)->lpVtbl -> SetDistributionUserNamePassword(This,newUserName,newUserPassword)

#define IWMSPublishingPoint_get_CacheProxyExpiration(This,pVal)	\
    (This)->lpVtbl -> get_CacheProxyExpiration(This,pVal)

#define IWMSPublishingPoint_put_CacheProxyExpiration(This,newVal)	\
    (This)->lpVtbl -> put_CacheProxyExpiration(This,newVal)

#define IWMSPublishingPoint_get_IsDistributionPasswordSet(This,pVal)	\
    (This)->lpVtbl -> get_IsDistributionPasswordSet(This,pVal)

#define IWMSPublishingPoint_get_AllowPlayerSideDiskCaching(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayerSideDiskCaching(This,pVal)

#define IWMSPublishingPoint_put_AllowPlayerSideDiskCaching(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayerSideDiskCaching(This,newVal)

#define IWMSPublishingPoint_get_EnableFEC(This,pVal)	\
    (This)->lpVtbl -> get_EnableFEC(This,pVal)

#define IWMSPublishingPoint_put_EnableFEC(This,newVal)	\
    (This)->lpVtbl -> put_EnableFEC(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_AllowClientsToConnect_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPublishingPoint_get_AllowClientsToConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_AllowClientsToConnect_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSPublishingPoint_put_AllowClientsToConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_CurrentCounters_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPublishingPointCurrentCounters **pVal);


void __RPC_STUB IWMSPublishingPoint_get_CurrentCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_EventHandlers_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSPublishingPoint_get_EventHandlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_ID_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPublishingPoint_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Limits_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPublishingPointLimits **pVal);


void __RPC_STUB IWMSPublishingPoint_get_Limits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_FileDescriptions_Proxy( 
    IWMSPublishingPoint * This,
    /* [defaultvalue][in] */ BSTR RelativePath,
    /* [retval][out] */ IWMSFileDescriptions **pVal);


void __RPC_STUB IWMSPublishingPoint_get_FileDescriptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_MonikerName_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IWMSPublishingPoint_get_MonikerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Name_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPublishingPoint_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_Name_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMSPublishingPoint_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_OutgoingDistributionConnections_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);


void __RPC_STUB IWMSPublishingPoint_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Path_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPublishingPoint_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_Path_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMSPublishingPoint_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_PeakCounters_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPublishingPointPeakCounters **pVal);


void __RPC_STUB IWMSPublishingPoint_get_PeakCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Players_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPlayers **pVal);


void __RPC_STUB IWMSPublishingPoint_get_Players_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Properties_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSNamedValues **pVal);


void __RPC_STUB IWMSPublishingPoint_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_TotalCounters_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPublishingPointTotalCounters **pVal);


void __RPC_STUB IWMSPublishingPoint_get_TotalCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Type_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ WMS_PUBLISHING_POINT_TYPE *pVal);


void __RPC_STUB IWMSPublishingPoint_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_WrapperPath_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPublishingPoint_get_WrapperPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_WrapperPath_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMSPublishingPoint_put_WrapperPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Authenticators_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSPublishingPoint_get_Authenticators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_Status_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ WMS_PUBLISHING_POINT_STATUS *pVal);


void __RPC_STUB IWMSPublishingPoint_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_EnableWrapperPath_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPublishingPoint_get_EnableWrapperPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_EnableWrapperPath_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSPublishingPoint_put_EnableWrapperPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_StreamFilters_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSPublishingPoint_get_StreamFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_DistributionUserName_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPublishingPoint_get_DistributionUserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_SetDistributionUserNamePassword_Proxy( 
    IWMSPublishingPoint * This,
    /* [string][in] */ wchar_t *newUserName,
    /* [string][in] */ wchar_t *newUserPassword);


void __RPC_STUB IWMSPublishingPoint_SetDistributionUserNamePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_CacheProxyExpiration_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPoint_get_CacheProxyExpiration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_CacheProxyExpiration_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ long newVal);


void __RPC_STUB IWMSPublishingPoint_put_CacheProxyExpiration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_IsDistributionPasswordSet_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPublishingPoint_get_IsDistributionPasswordSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_AllowPlayerSideDiskCaching_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPublishingPoint_get_AllowPlayerSideDiskCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_AllowPlayerSideDiskCaching_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSPublishingPoint_put_AllowPlayerSideDiskCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_get_EnableFEC_Proxy( 
    IWMSPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPublishingPoint_get_EnableFEC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoint_put_EnableFEC_Proxy( 
    IWMSPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSPublishingPoint_put_EnableFEC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPoint_INTERFACE_DEFINED__ */


#ifndef __IWMSOnDemandPublishingPoint_INTERFACE_DEFINED__
#define __IWMSOnDemandPublishingPoint_INTERFACE_DEFINED__

/* interface IWMSOnDemandPublishingPoint */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSOnDemandPublishingPoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ca388b3-eaee-492f-a8d6-8758efc72d76")
    IWMSOnDemandPublishingPoint : public IWMSPublishingPoint
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContentCaching( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContentCaching( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportXML( 
            /* [in] */ BSTR bstrXMLFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableClientWildcardDirectoryAccess( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableClientWildcardDirectoryAccess( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableDownload( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableDownload( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownloadBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DownloadBandwidth( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSOnDemandPublishingPointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSOnDemandPublishingPoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSOnDemandPublishingPoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSOnDemandPublishingPoint * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSOnDemandPublishingPoint * This,
            /* [defaultvalue][in] */ BSTR RelativePath,
            /* [retval][out] */ IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPath )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WrapperPath )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableWrapperPath )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableWrapperPath )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DistributionUserName )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDistributionUserNamePassword )( 
            IWMSOnDemandPublishingPoint * This,
            /* [string][in] */ wchar_t *newUserName,
            /* [string][in] */ wchar_t *newUserPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxyExpiration )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CacheProxyExpiration )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDistributionPasswordSet )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayerSideDiskCaching )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayerSideDiskCaching )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFEC )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFEC )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContentCaching )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContentCaching )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportXML )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ BSTR bstrXMLFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableClientWildcardDirectoryAccess )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableClientWildcardDirectoryAccess )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableDownload )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableDownload )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DownloadBandwidth )( 
            IWMSOnDemandPublishingPoint * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DownloadBandwidth )( 
            IWMSOnDemandPublishingPoint * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IWMSOnDemandPublishingPointVtbl;

    interface IWMSOnDemandPublishingPoint
    {
        CONST_VTBL struct IWMSOnDemandPublishingPointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSOnDemandPublishingPoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSOnDemandPublishingPoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSOnDemandPublishingPoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSOnDemandPublishingPoint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSOnDemandPublishingPoint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSOnDemandPublishingPoint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSOnDemandPublishingPoint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSOnDemandPublishingPoint_get_AllowClientsToConnect(This,pVal)	\
    (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal)

#define IWMSOnDemandPublishingPoint_put_AllowClientsToConnect(This,newVal)	\
    (This)->lpVtbl -> put_AllowClientsToConnect(This,newVal)

#define IWMSOnDemandPublishingPoint_get_CurrentCounters(This,pVal)	\
    (This)->lpVtbl -> get_CurrentCounters(This,pVal)

#define IWMSOnDemandPublishingPoint_get_EventHandlers(This,pVal)	\
    (This)->lpVtbl -> get_EventHandlers(This,pVal)

#define IWMSOnDemandPublishingPoint_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Limits(This,pVal)	\
    (This)->lpVtbl -> get_Limits(This,pVal)

#define IWMSOnDemandPublishingPoint_get_FileDescriptions(This,RelativePath,pVal)	\
    (This)->lpVtbl -> get_FileDescriptions(This,RelativePath,pVal)

#define IWMSOnDemandPublishingPoint_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)

#define IWMSOnDemandPublishingPoint_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSOnDemandPublishingPoint_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IWMSOnDemandPublishingPoint_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IWMSOnDemandPublishingPoint_put_Path(This,newVal)	\
    (This)->lpVtbl -> put_Path(This,newVal)

#define IWMSOnDemandPublishingPoint_get_PeakCounters(This,pVal)	\
    (This)->lpVtbl -> get_PeakCounters(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Players(This,pVal)	\
    (This)->lpVtbl -> get_Players(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSOnDemandPublishingPoint_get_TotalCounters(This,pVal)	\
    (This)->lpVtbl -> get_TotalCounters(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IWMSOnDemandPublishingPoint_get_WrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_WrapperPath(This,pVal)

#define IWMSOnDemandPublishingPoint_put_WrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_WrapperPath(This,newVal)

#define IWMSOnDemandPublishingPoint_get_Authenticators(This,pVal)	\
    (This)->lpVtbl -> get_Authenticators(This,pVal)

#define IWMSOnDemandPublishingPoint_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSOnDemandPublishingPoint_get_EnableWrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_EnableWrapperPath(This,pVal)

#define IWMSOnDemandPublishingPoint_put_EnableWrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_EnableWrapperPath(This,newVal)

#define IWMSOnDemandPublishingPoint_get_StreamFilters(This,pVal)	\
    (This)->lpVtbl -> get_StreamFilters(This,pVal)

#define IWMSOnDemandPublishingPoint_get_DistributionUserName(This,pVal)	\
    (This)->lpVtbl -> get_DistributionUserName(This,pVal)

#define IWMSOnDemandPublishingPoint_SetDistributionUserNamePassword(This,newUserName,newUserPassword)	\
    (This)->lpVtbl -> SetDistributionUserNamePassword(This,newUserName,newUserPassword)

#define IWMSOnDemandPublishingPoint_get_CacheProxyExpiration(This,pVal)	\
    (This)->lpVtbl -> get_CacheProxyExpiration(This,pVal)

#define IWMSOnDemandPublishingPoint_put_CacheProxyExpiration(This,newVal)	\
    (This)->lpVtbl -> put_CacheProxyExpiration(This,newVal)

#define IWMSOnDemandPublishingPoint_get_IsDistributionPasswordSet(This,pVal)	\
    (This)->lpVtbl -> get_IsDistributionPasswordSet(This,pVal)

#define IWMSOnDemandPublishingPoint_get_AllowPlayerSideDiskCaching(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayerSideDiskCaching(This,pVal)

#define IWMSOnDemandPublishingPoint_put_AllowPlayerSideDiskCaching(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayerSideDiskCaching(This,newVal)

#define IWMSOnDemandPublishingPoint_get_EnableFEC(This,pVal)	\
    (This)->lpVtbl -> get_EnableFEC(This,pVal)

#define IWMSOnDemandPublishingPoint_put_EnableFEC(This,newVal)	\
    (This)->lpVtbl -> put_EnableFEC(This,newVal)


#define IWMSOnDemandPublishingPoint_get_AllowContentCaching(This,pVal)	\
    (This)->lpVtbl -> get_AllowContentCaching(This,pVal)

#define IWMSOnDemandPublishingPoint_put_AllowContentCaching(This,newVal)	\
    (This)->lpVtbl -> put_AllowContentCaching(This,newVal)

#define IWMSOnDemandPublishingPoint_ExportXML(This,bstrXMLFileName)	\
    (This)->lpVtbl -> ExportXML(This,bstrXMLFileName)

#define IWMSOnDemandPublishingPoint_get_EnableClientWildcardDirectoryAccess(This,pVal)	\
    (This)->lpVtbl -> get_EnableClientWildcardDirectoryAccess(This,pVal)

#define IWMSOnDemandPublishingPoint_put_EnableClientWildcardDirectoryAccess(This,newVal)	\
    (This)->lpVtbl -> put_EnableClientWildcardDirectoryAccess(This,newVal)

#define IWMSOnDemandPublishingPoint_get_EnableDownload(This,pVal)	\
    (This)->lpVtbl -> get_EnableDownload(This,pVal)

#define IWMSOnDemandPublishingPoint_put_EnableDownload(This,newVal)	\
    (This)->lpVtbl -> put_EnableDownload(This,newVal)

#define IWMSOnDemandPublishingPoint_get_DownloadBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_DownloadBandwidth(This,pVal)

#define IWMSOnDemandPublishingPoint_put_DownloadBandwidth(This,newVal)	\
    (This)->lpVtbl -> put_DownloadBandwidth(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_get_AllowContentCaching_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_get_AllowContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_put_AllowContentCaching_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_put_AllowContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_ExportXML_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [in] */ BSTR bstrXMLFileName);


void __RPC_STUB IWMSOnDemandPublishingPoint_ExportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_get_EnableClientWildcardDirectoryAccess_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_get_EnableClientWildcardDirectoryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_put_EnableClientWildcardDirectoryAccess_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_put_EnableClientWildcardDirectoryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_get_EnableDownload_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_get_EnableDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_put_EnableDownload_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_put_EnableDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_get_DownloadBandwidth_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_get_DownloadBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSOnDemandPublishingPoint_put_DownloadBandwidth_Proxy( 
    IWMSOnDemandPublishingPoint * This,
    /* [in] */ long newVal);


void __RPC_STUB IWMSOnDemandPublishingPoint_put_DownloadBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSOnDemandPublishingPoint_INTERFACE_DEFINED__ */


#ifndef __IWMSAnnouncementStreamFormats_INTERFACE_DEFINED__
#define __IWMSAnnouncementStreamFormats_INTERFACE_DEFINED__

/* interface IWMSAnnouncementStreamFormats */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSAnnouncementStreamFormats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DDB8E9-05A3-4666-9E20-550F94581B06")
    IWMSAnnouncementStreamFormats : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ VARIANT varStreamFormat) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSAnnouncementStreamFormatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSAnnouncementStreamFormats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSAnnouncementStreamFormats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSAnnouncementStreamFormats * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSAnnouncementStreamFormats * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSAnnouncementStreamFormats * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSAnnouncementStreamFormats * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ VARIANT varStreamFormat);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSAnnouncementStreamFormats * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWMSAnnouncementStreamFormats * This);
        
        END_INTERFACE
    } IWMSAnnouncementStreamFormatsVtbl;

    interface IWMSAnnouncementStreamFormats
    {
        CONST_VTBL struct IWMSAnnouncementStreamFormatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSAnnouncementStreamFormats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSAnnouncementStreamFormats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSAnnouncementStreamFormats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSAnnouncementStreamFormats_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSAnnouncementStreamFormats_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSAnnouncementStreamFormats_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSAnnouncementStreamFormats_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSAnnouncementStreamFormats_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSAnnouncementStreamFormats_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSAnnouncementStreamFormats_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSAnnouncementStreamFormats_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSAnnouncementStreamFormats_Add(This,varStreamFormat)	\
    (This)->lpVtbl -> Add(This,varStreamFormat)

#define IWMSAnnouncementStreamFormats_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define IWMSAnnouncementStreamFormats_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_get_Item_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSAnnouncementStreamFormats_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_get_Count_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSAnnouncementStreamFormats_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_get_length_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSAnnouncementStreamFormats_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_get__NewEnum_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSAnnouncementStreamFormats_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_Add_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [in] */ VARIANT varStreamFormat);


void __RPC_STUB IWMSAnnouncementStreamFormats_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_Remove_Proxy( 
    IWMSAnnouncementStreamFormats * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSAnnouncementStreamFormats_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSAnnouncementStreamFormats_RemoveAll_Proxy( 
    IWMSAnnouncementStreamFormats * This);


void __RPC_STUB IWMSAnnouncementStreamFormats_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSAnnouncementStreamFormats_INTERFACE_DEFINED__ */


#ifndef __IWMSBroadcastPublishingPoint_INTERFACE_DEFINED__
#define __IWMSBroadcastPublishingPoint_INTERFACE_DEFINED__

/* interface IWMSBroadcastPublishingPoint */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0ED-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_BROADCAST_PUBLISHING_POINT_STATUS
    {	WMS_BROADCAST_PUBLISHING_POINT_STOPPED	= 0,
	WMS_BROADCAST_PUBLISHING_POINT_STARTED_WITHOUT_DATA	= 0x1,
	WMS_BROADCAST_PUBLISHING_POINT_STARTED	= 0x2,
	WMS_BROADCAST_PUBLISHING_POINT_ARCHIVING	= 0x4,
	WMS_BROADCAST_PUBLISHING_POINT_CHANGE_IN_PROGRESS	= 0x8
    } 	WMS_BROADCAST_PUBLISHING_POINT_STATUS;

typedef /* [uuid][public] */  DECLSPEC_UUID("62D6D99D-EB48-4e9e-97DB-C2C09EAADAD4") 
enum WMS_BUFFER_SETTING
    {	WMS_BUFFER_SETTING_UNSPECIFIED	= 0,
	WMS_BUFFER_SETTING_MINIMIZE_STARTUP_LATENCY	= 0x1,
	WMS_BUFFER_SETTING_MINIMIZE_PROPAGATION_LATENCY	= 0x2,
	WMS_NUM_BUFFER_SETTING	= 0x3
    } 	WMS_BUFFER_SETTING;


EXTERN_C const IID IID_IWMSBroadcastPublishingPoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ca388b4-eaee-492f-a8d6-8758efc72d76")
    IWMSBroadcastPublishingPoint : public IWMSPublishingPoint
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowStreamSplitting( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowStreamSplitting( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowClientToStartAndStop( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowClientToStartAndStop( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BroadcastDataSinks( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SharedPlaylist( 
            /* [retval][out] */ IWMSPlaylist **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartWithoutData( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartArchive( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BroadcastStatus( 
            /* [retval][out] */ WMS_BROADCAST_PUBLISHING_POINT_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopArchive( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportXML( 
            /* [in] */ BSTR bstrXMLFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UpTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AnnouncementStreamFormats( 
            /* [retval][out] */ IWMSAnnouncementStreamFormats **ppFileNames) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Announce( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AnnounceToNSCFile( 
            /* [in] */ BSTR bstrDestinationFileName,
            /* [defaultvalue][in] */ VARIANT_BOOL fOverwriteFlag = FALSE) = 0;
        
        virtual /* [helpstring][id][restricted] */ HRESULT STDMETHODCALLTYPE AnnounceToNSCStream( 
            /* [retval][out] */ IUnknown **ppNSCAnnounceStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BufferSetting( 
            /* [retval][out] */ WMS_BUFFER_SETTING *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BufferSetting( 
            /* [in] */ WMS_BUFFER_SETTING newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBroadcastPublishingPointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSBroadcastPublishingPoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSBroadcastPublishingPoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSBroadcastPublishingPoint * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSBroadcastPublishingPoint * This,
            /* [defaultvalue][in] */ BSTR RelativePath,
            /* [retval][out] */ IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Path )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPublishingPointTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WrapperPath )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WrapperPath )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ WMS_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableWrapperPath )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableWrapperPath )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DistributionUserName )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDistributionUserNamePassword )( 
            IWMSBroadcastPublishingPoint * This,
            /* [string][in] */ wchar_t *newUserName,
            /* [string][in] */ wchar_t *newUserPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxyExpiration )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CacheProxyExpiration )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDistributionPasswordSet )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPlayerSideDiskCaching )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPlayerSideDiskCaching )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFEC )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFEC )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowStreamSplitting )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowStreamSplitting )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientToStartAndStop )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientToStartAndStop )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BroadcastDataSinks )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharedPlaylist )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSPlaylist **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartWithoutData )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartArchive )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BroadcastStatus )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ WMS_BROADCAST_PUBLISHING_POINT_STATUS *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopArchive )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportXML )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ BSTR bstrXMLFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpTime )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AnnouncementStreamFormats )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IWMSAnnouncementStreamFormats **ppFileNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Announce )( 
            IWMSBroadcastPublishingPoint * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AnnounceToNSCFile )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ BSTR bstrDestinationFileName,
            /* [defaultvalue][in] */ VARIANT_BOOL fOverwriteFlag);
        
        /* [helpstring][id][restricted] */ HRESULT ( STDMETHODCALLTYPE *AnnounceToNSCStream )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ IUnknown **ppNSCAnnounceStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferSetting )( 
            IWMSBroadcastPublishingPoint * This,
            /* [retval][out] */ WMS_BUFFER_SETTING *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferSetting )( 
            IWMSBroadcastPublishingPoint * This,
            /* [in] */ WMS_BUFFER_SETTING newVal);
        
        END_INTERFACE
    } IWMSBroadcastPublishingPointVtbl;

    interface IWMSBroadcastPublishingPoint
    {
        CONST_VTBL struct IWMSBroadcastPublishingPointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBroadcastPublishingPoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBroadcastPublishingPoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBroadcastPublishingPoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBroadcastPublishingPoint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSBroadcastPublishingPoint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSBroadcastPublishingPoint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSBroadcastPublishingPoint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSBroadcastPublishingPoint_get_AllowClientsToConnect(This,pVal)	\
    (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal)

#define IWMSBroadcastPublishingPoint_put_AllowClientsToConnect(This,newVal)	\
    (This)->lpVtbl -> put_AllowClientsToConnect(This,newVal)

#define IWMSBroadcastPublishingPoint_get_CurrentCounters(This,pVal)	\
    (This)->lpVtbl -> get_CurrentCounters(This,pVal)

#define IWMSBroadcastPublishingPoint_get_EventHandlers(This,pVal)	\
    (This)->lpVtbl -> get_EventHandlers(This,pVal)

#define IWMSBroadcastPublishingPoint_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Limits(This,pVal)	\
    (This)->lpVtbl -> get_Limits(This,pVal)

#define IWMSBroadcastPublishingPoint_get_FileDescriptions(This,RelativePath,pVal)	\
    (This)->lpVtbl -> get_FileDescriptions(This,RelativePath,pVal)

#define IWMSBroadcastPublishingPoint_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)

#define IWMSBroadcastPublishingPoint_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSBroadcastPublishingPoint_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IWMSBroadcastPublishingPoint_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IWMSBroadcastPublishingPoint_put_Path(This,newVal)	\
    (This)->lpVtbl -> put_Path(This,newVal)

#define IWMSBroadcastPublishingPoint_get_PeakCounters(This,pVal)	\
    (This)->lpVtbl -> get_PeakCounters(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Players(This,pVal)	\
    (This)->lpVtbl -> get_Players(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSBroadcastPublishingPoint_get_TotalCounters(This,pVal)	\
    (This)->lpVtbl -> get_TotalCounters(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IWMSBroadcastPublishingPoint_get_WrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_WrapperPath(This,pVal)

#define IWMSBroadcastPublishingPoint_put_WrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_WrapperPath(This,newVal)

#define IWMSBroadcastPublishingPoint_get_Authenticators(This,pVal)	\
    (This)->lpVtbl -> get_Authenticators(This,pVal)

#define IWMSBroadcastPublishingPoint_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSBroadcastPublishingPoint_get_EnableWrapperPath(This,pVal)	\
    (This)->lpVtbl -> get_EnableWrapperPath(This,pVal)

#define IWMSBroadcastPublishingPoint_put_EnableWrapperPath(This,newVal)	\
    (This)->lpVtbl -> put_EnableWrapperPath(This,newVal)

#define IWMSBroadcastPublishingPoint_get_StreamFilters(This,pVal)	\
    (This)->lpVtbl -> get_StreamFilters(This,pVal)

#define IWMSBroadcastPublishingPoint_get_DistributionUserName(This,pVal)	\
    (This)->lpVtbl -> get_DistributionUserName(This,pVal)

#define IWMSBroadcastPublishingPoint_SetDistributionUserNamePassword(This,newUserName,newUserPassword)	\
    (This)->lpVtbl -> SetDistributionUserNamePassword(This,newUserName,newUserPassword)

#define IWMSBroadcastPublishingPoint_get_CacheProxyExpiration(This,pVal)	\
    (This)->lpVtbl -> get_CacheProxyExpiration(This,pVal)

#define IWMSBroadcastPublishingPoint_put_CacheProxyExpiration(This,newVal)	\
    (This)->lpVtbl -> put_CacheProxyExpiration(This,newVal)

#define IWMSBroadcastPublishingPoint_get_IsDistributionPasswordSet(This,pVal)	\
    (This)->lpVtbl -> get_IsDistributionPasswordSet(This,pVal)

#define IWMSBroadcastPublishingPoint_get_AllowPlayerSideDiskCaching(This,pVal)	\
    (This)->lpVtbl -> get_AllowPlayerSideDiskCaching(This,pVal)

#define IWMSBroadcastPublishingPoint_put_AllowPlayerSideDiskCaching(This,newVal)	\
    (This)->lpVtbl -> put_AllowPlayerSideDiskCaching(This,newVal)

#define IWMSBroadcastPublishingPoint_get_EnableFEC(This,pVal)	\
    (This)->lpVtbl -> get_EnableFEC(This,pVal)

#define IWMSBroadcastPublishingPoint_put_EnableFEC(This,newVal)	\
    (This)->lpVtbl -> put_EnableFEC(This,newVal)


#define IWMSBroadcastPublishingPoint_get_AllowStreamSplitting(This,pVal)	\
    (This)->lpVtbl -> get_AllowStreamSplitting(This,pVal)

#define IWMSBroadcastPublishingPoint_put_AllowStreamSplitting(This,newVal)	\
    (This)->lpVtbl -> put_AllowStreamSplitting(This,newVal)

#define IWMSBroadcastPublishingPoint_get_AllowClientToStartAndStop(This,pVal)	\
    (This)->lpVtbl -> get_AllowClientToStartAndStop(This,pVal)

#define IWMSBroadcastPublishingPoint_put_AllowClientToStartAndStop(This,newVal)	\
    (This)->lpVtbl -> put_AllowClientToStartAndStop(This,newVal)

#define IWMSBroadcastPublishingPoint_get_BroadcastDataSinks(This,pVal)	\
    (This)->lpVtbl -> get_BroadcastDataSinks(This,pVal)

#define IWMSBroadcastPublishingPoint_get_SharedPlaylist(This,pVal)	\
    (This)->lpVtbl -> get_SharedPlaylist(This,pVal)

#define IWMSBroadcastPublishingPoint_StartWithoutData(This)	\
    (This)->lpVtbl -> StartWithoutData(This)

#define IWMSBroadcastPublishingPoint_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IWMSBroadcastPublishingPoint_StartArchive(This)	\
    (This)->lpVtbl -> StartArchive(This)

#define IWMSBroadcastPublishingPoint_get_BroadcastStatus(This,pVal)	\
    (This)->lpVtbl -> get_BroadcastStatus(This,pVal)

#define IWMSBroadcastPublishingPoint_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMSBroadcastPublishingPoint_StopArchive(This)	\
    (This)->lpVtbl -> StopArchive(This)

#define IWMSBroadcastPublishingPoint_ExportXML(This,bstrXMLFileName)	\
    (This)->lpVtbl -> ExportXML(This,bstrXMLFileName)

#define IWMSBroadcastPublishingPoint_get_UpTime(This,pVal)	\
    (This)->lpVtbl -> get_UpTime(This,pVal)

#define IWMSBroadcastPublishingPoint_get_AnnouncementStreamFormats(This,ppFileNames)	\
    (This)->lpVtbl -> get_AnnouncementStreamFormats(This,ppFileNames)

#define IWMSBroadcastPublishingPoint_Announce(This)	\
    (This)->lpVtbl -> Announce(This)

#define IWMSBroadcastPublishingPoint_AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag)	\
    (This)->lpVtbl -> AnnounceToNSCFile(This,bstrDestinationFileName,fOverwriteFlag)

#define IWMSBroadcastPublishingPoint_AnnounceToNSCStream(This,ppNSCAnnounceStream)	\
    (This)->lpVtbl -> AnnounceToNSCStream(This,ppNSCAnnounceStream)

#define IWMSBroadcastPublishingPoint_get_BufferSetting(This,pVal)	\
    (This)->lpVtbl -> get_BufferSetting(This,pVal)

#define IWMSBroadcastPublishingPoint_put_BufferSetting(This,newVal)	\
    (This)->lpVtbl -> put_BufferSetting(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_AllowStreamSplitting_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_AllowStreamSplitting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_put_AllowStreamSplitting_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_put_AllowStreamSplitting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_AllowClientToStartAndStop_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_AllowClientToStartAndStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_put_AllowClientToStartAndStop_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_put_AllowClientToStartAndStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_BroadcastDataSinks_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_BroadcastDataSinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_SharedPlaylist_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ IWMSPlaylist **pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_SharedPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_StartWithoutData_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_StartWithoutData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_Start_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_StartArchive_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_StartArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_BroadcastStatus_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ WMS_BROADCAST_PUBLISHING_POINT_STATUS *pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_BroadcastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_Stop_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_StopArchive_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_StopArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_ExportXML_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [in] */ BSTR bstrXMLFileName);


void __RPC_STUB IWMSBroadcastPublishingPoint_ExportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_UpTime_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_UpTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_AnnouncementStreamFormats_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ IWMSAnnouncementStreamFormats **ppFileNames);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_AnnouncementStreamFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_Announce_Proxy( 
    IWMSBroadcastPublishingPoint * This);


void __RPC_STUB IWMSBroadcastPublishingPoint_Announce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_AnnounceToNSCFile_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [in] */ BSTR bstrDestinationFileName,
    /* [defaultvalue][in] */ VARIANT_BOOL fOverwriteFlag);


void __RPC_STUB IWMSBroadcastPublishingPoint_AnnounceToNSCFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][restricted] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_AnnounceToNSCStream_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ IUnknown **ppNSCAnnounceStream);


void __RPC_STUB IWMSBroadcastPublishingPoint_AnnounceToNSCStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_get_BufferSetting_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [retval][out] */ WMS_BUFFER_SETTING *pVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_get_BufferSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSBroadcastPublishingPoint_put_BufferSetting_Proxy( 
    IWMSBroadcastPublishingPoint * This,
    /* [in] */ WMS_BUFFER_SETTING newVal);


void __RPC_STUB IWMSBroadcastPublishingPoint_put_BufferSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBroadcastPublishingPoint_INTERFACE_DEFINED__ */


#ifndef __IWMSPublishingPoints_INTERFACE_DEFINED__
#define __IWMSPublishingPoints_INTERFACE_DEFINED__

/* interface IWMSPublishingPoints */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("6ca388b5-eaee-492f-a8d6-8758efc72d76") 
enum WMS_PUBLISHING_POINT_CATEGORY
    {	WMS_PUBLISHING_POINT_ON_DEMAND	= 1,
	WMS_PUBLISHING_POINT_BROADCAST	= 2
    } 	WMS_PUBLISHING_POINT_CATEGORY;


EXTERN_C const IID IID_IWMSPublishingPoints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1881274D-4BEC-11D2-BF25-00805FBE84A6")
    IWMSPublishingPoints : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPublishingPoint **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ WMS_PUBLISHING_POINT_CATEGORY Category,
            /* [in] */ BSTR Path,
            /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT varIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ BSTR DestName,
            /* [in] */ IWMSPublishingPoint *pSrcPubPt,
            /* [retval][out] */ IWMSPublishingPoint **ppDestPubPt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportXML( 
            /* [in] */ BSTR bstrNewPubPtName,
            /* [in] */ BSTR bstrXMLFileName,
            /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPublishingPointsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPublishingPoints * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPublishingPoints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPublishingPoints * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPublishingPoints * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPublishingPoints * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPublishingPoints * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPublishingPoints * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IWMSPublishingPoints * This,
            /* [in] */ const VARIANT varIndex,
            /* [retval][out] */ IWMSPublishingPoint **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ long *pVal);
        
        /* [hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IWMSPublishingPoints * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWMSPublishingPoints * This,
            /* [in] */ BSTR Name,
            /* [in] */ WMS_PUBLISHING_POINT_CATEGORY Category,
            /* [in] */ BSTR Path,
            /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMSPublishingPoints * This,
            /* [in] */ VARIANT varIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWMSPublishingPoints * This,
            /* [in] */ BSTR DestName,
            /* [in] */ IWMSPublishingPoint *pSrcPubPt,
            /* [retval][out] */ IWMSPublishingPoint **ppDestPubPt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportXML )( 
            IWMSPublishingPoints * This,
            /* [in] */ BSTR bstrNewPubPtName,
            /* [in] */ BSTR bstrXMLFileName,
            /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt);
        
        END_INTERFACE
    } IWMSPublishingPointsVtbl;

    interface IWMSPublishingPoints
    {
        CONST_VTBL struct IWMSPublishingPointsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPublishingPoints_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPublishingPoints_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPublishingPoints_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPublishingPoints_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPublishingPoints_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPublishingPoints_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPublishingPoints_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPublishingPoints_get_Item(This,varIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,varIndex,pVal)

#define IWMSPublishingPoints_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IWMSPublishingPoints_get_length(This,pVal)	\
    (This)->lpVtbl -> get_length(This,pVal)

#define IWMSPublishingPoints_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IWMSPublishingPoints_Add(This,Name,Category,Path,ppNewPubPt)	\
    (This)->lpVtbl -> Add(This,Name,Category,Path,ppNewPubPt)

#define IWMSPublishingPoints_Remove(This,varIndex)	\
    (This)->lpVtbl -> Remove(This,varIndex)

#define IWMSPublishingPoints_Clone(This,DestName,pSrcPubPt,ppDestPubPt)	\
    (This)->lpVtbl -> Clone(This,DestName,pSrcPubPt,ppDestPubPt)

#define IWMSPublishingPoints_ImportXML(This,bstrNewPubPtName,bstrXMLFileName,ppNewPubPt)	\
    (This)->lpVtbl -> ImportXML(This,bstrNewPubPtName,bstrXMLFileName,ppNewPubPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_get_Item_Proxy( 
    IWMSPublishingPoints * This,
    /* [in] */ const VARIANT varIndex,
    /* [retval][out] */ IWMSPublishingPoint **pVal);


void __RPC_STUB IWMSPublishingPoints_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_get_Count_Proxy( 
    IWMSPublishingPoints * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPoints_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_get_length_Proxy( 
    IWMSPublishingPoints * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPublishingPoints_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_get__NewEnum_Proxy( 
    IWMSPublishingPoints * This,
    /* [retval][out] */ IUnknown **pVal);


void __RPC_STUB IWMSPublishingPoints_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_Add_Proxy( 
    IWMSPublishingPoints * This,
    /* [in] */ BSTR Name,
    /* [in] */ WMS_PUBLISHING_POINT_CATEGORY Category,
    /* [in] */ BSTR Path,
    /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt);


void __RPC_STUB IWMSPublishingPoints_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_Remove_Proxy( 
    IWMSPublishingPoints * This,
    /* [in] */ VARIANT varIndex);


void __RPC_STUB IWMSPublishingPoints_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_Clone_Proxy( 
    IWMSPublishingPoints * This,
    /* [in] */ BSTR DestName,
    /* [in] */ IWMSPublishingPoint *pSrcPubPt,
    /* [retval][out] */ IWMSPublishingPoint **ppDestPubPt);


void __RPC_STUB IWMSPublishingPoints_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSPublishingPoints_ImportXML_Proxy( 
    IWMSPublishingPoints * This,
    /* [in] */ BSTR bstrNewPubPtName,
    /* [in] */ BSTR bstrXMLFileName,
    /* [retval][out] */ IWMSPublishingPoint **ppNewPubPt);


void __RPC_STUB IWMSPublishingPoints_ImportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPublishingPoints_INTERFACE_DEFINED__ */


#ifndef __IWMSServerCurrentCounters_INTERFACE_DEFINED__
#define __IWMSServerCurrentCounters_INTERFACE_DEFINED__

/* interface IWMSServerCurrentCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerCurrentCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18FA53CD-8EB9-4b5f-B750-659D9B96DB9F")
    IWMSServerCurrentCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionQueue( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileReadRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingHTTPPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateReadRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingMMSPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionSendRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerSendRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingRTSPPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamErrorRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheDownloads( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LateSendRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendRequestsRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDPResendsSentRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerCurrentCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerCurrentCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerCurrentCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerCurrentCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerCurrentCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionQueue )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileReadRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingHTTPPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateReadRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingMMSPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingRTSPPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamErrorRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheDownloads )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LateSendRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendRequestsRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDPResendsSentRate )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingBandwidth )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerCurrentCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSServerCurrentCountersVtbl;

    interface IWMSServerCurrentCounters
    {
        CONST_VTBL struct IWMSServerCurrentCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerCurrentCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSServerCurrentCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSServerCurrentCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSServerCurrentCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSServerCurrentCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSServerCurrentCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSServerCurrentCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSServerCurrentCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSServerCurrentCounters_get_ConnectionQueue(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionQueue(This,pVal)

#define IWMSServerCurrentCounters_get_ConnectionRate(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionRate(This,pVal)

#define IWMSServerCurrentCounters_get_FileReadRate(This,pVal)	\
    (This)->lpVtbl -> get_FileReadRate(This,pVal)

#define IWMSServerCurrentCounters_get_StreamingHTTPPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingHTTPPlayers(This,pVal)

#define IWMSServerCurrentCounters_get_LateReadRate(This,pVal)	\
    (This)->lpVtbl -> get_LateReadRate(This,pVal)

#define IWMSServerCurrentCounters_get_StreamingMMSPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingMMSPlayers(This,pVal)

#define IWMSServerCurrentCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal)

#define IWMSServerCurrentCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSServerCurrentCounters_get_OutgoingDistributionSendRate(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal)

#define IWMSServerCurrentCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal)

#define IWMSServerCurrentCounters_get_PlayerSendRate(This,pVal)	\
    (This)->lpVtbl -> get_PlayerSendRate(This,pVal)

#define IWMSServerCurrentCounters_get_StreamingRTSPPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingRTSPPlayers(This,pVal)

#define IWMSServerCurrentCounters_get_StreamErrorRate(This,pVal)	\
    (This)->lpVtbl -> get_StreamErrorRate(This,pVal)

#define IWMSServerCurrentCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSServerCurrentCounters_get_CacheDownloads(This,pVal)	\
    (This)->lpVtbl -> get_CacheDownloads(This,pVal)

#define IWMSServerCurrentCounters_get_LateSendRate(This,pVal)	\
    (This)->lpVtbl -> get_LateSendRate(This,pVal)

#define IWMSServerCurrentCounters_get_UDPResendRequestsRate(This,pVal)	\
    (This)->lpVtbl -> get_UDPResendRequestsRate(This,pVal)

#define IWMSServerCurrentCounters_get_UDPResendsSentRate(This,pVal)	\
    (This)->lpVtbl -> get_UDPResendsSentRate(This,pVal)

#define IWMSServerCurrentCounters_get_IncomingBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_IncomingBandwidth(This,pVal)

#define IWMSServerCurrentCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_ConnectedPlayers_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_ConnectionQueue_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_ConnectionQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_ConnectionRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_ConnectionRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_FileReadRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_FileReadRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_StreamingHTTPPlayers_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_StreamingHTTPPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_LateReadRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_LateReadRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_StreamingMMSPlayers_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_StreamingMMSPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_OutgoingDistributionAllocatedBandwidth_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_OutgoingDistributionAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_OutgoingDistributionSendRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_OutgoingDistributionSendRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_PlayerAllocatedBandwidth_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_PlayerAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_PlayerSendRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_PlayerSendRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_StreamingRTSPPlayers_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_StreamingRTSPPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_StreamErrorRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_StreamErrorRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_StreamingPlayers_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_CacheDownloads_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_CacheDownloads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_LateSendRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_LateSendRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_UDPResendRequestsRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_UDPResendRequestsRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_UDPResendsSentRate_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_UDPResendsSentRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_IncomingBandwidth_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerCurrentCounters_get_IncomingBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerCurrentCounters_get_AllCounters_Proxy( 
    IWMSServerCurrentCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSServerCurrentCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSServerCurrentCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSServerPeakCounters_INTERFACE_DEFINED__
#define __IWMSServerPeakCounters_INTERFACE_DEFINED__

/* interface IWMSServerPeakCounters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerPeakCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66F2D385-7081-40b9-863C-AFA4E5612CD3")
    IWMSServerPeakCounters : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerSendRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAllocatedBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionSendRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountersStartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamingPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllCounters( 
            /* [retval][out] */ SAFEARRAY * *ppsaCounters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerPeakCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerPeakCounters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerPeakCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerPeakCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerPeakCounters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerPeakCounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerPeakCounters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerPeakCounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionAllocatedBandwidth )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerSendRate )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAllocatedBandwidth )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionSendRate )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountersStartTime )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamingPlayers )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMSServerPeakCounters * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllCounters )( 
            IWMSServerPeakCounters * This,
            /* [retval][out] */ SAFEARRAY * *ppsaCounters);
        
        END_INTERFACE
    } IWMSServerPeakCountersVtbl;

    interface IWMSServerPeakCounters
    {
        CONST_VTBL struct IWMSServerPeakCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerPeakCounters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSServerPeakCounters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSServerPeakCounters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSServerPeakCounters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSServerPeakCounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSServerPeakCounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSServerPeakCounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSServerPeakCounters_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSServerPeakCounters_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSServerPeakCounters_get_OutgoingDistributionAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionAllocatedBandwidth(This,pVal)

#define IWMSServerPeakCounters_get_PlayerSendRate(This,pVal)	\
    (This)->lpVtbl -> get_PlayerSendRate(This,pVal)

#define IWMSServerPeakCounters_get_PlayerAllocatedBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerAllocatedBandwidth(This,pVal)

#define IWMSServerPeakCounters_get_OutgoingDistributionSendRate(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionSendRate(This,pVal)

#define IWMSServerPeakCounters_get_CountersStartTime(This,pVal)	\
    (This)->lpVtbl -> get_CountersStartTime(This,pVal)

#define IWMSServerPeakCounters_get_StreamingPlayers(This,pVal)	\
    (This)->lpVtbl -> get_StreamingPlayers(This,pVal)

#define IWMSServerPeakCounters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMSServerPeakCounters_get_AllCounters(This,ppsaCounters)	\
    (This)->lpVtbl -> get_AllCounters(This,ppsaCounters)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_ConnectedPlayers_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_OutgoingDistributionConnections_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_OutgoingDistributionAllocatedBandwidth_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_OutgoingDistributionAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_PlayerSendRate_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_PlayerSendRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_PlayerAllocatedBandwidth_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_PlayerAllocatedBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_OutgoingDistributionSendRate_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_OutgoingDistributionSendRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_CountersStartTime_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_CountersStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_StreamingPlayers_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerPeakCounters_get_StreamingPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_Reset_Proxy( 
    IWMSServerPeakCounters * This);


void __RPC_STUB IWMSServerPeakCounters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerPeakCounters_get_AllCounters_Proxy( 
    IWMSServerPeakCounters * This,
    /* [retval][out] */ SAFEARRAY * *ppsaCounters);


void __RPC_STUB IWMSServerPeakCounters_get_AllCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSServerPeakCounters_INTERFACE_DEFINED__ */


#ifndef __IWMSServerLimits_INTERFACE_DEFINED__
#define __IWMSServerLimits_INTERFACE_DEFINED__

/* interface IWMSServerLimits */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMSServerLimits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D06CCFBB-994D-45f8-886E-81E9B7FAEDF1")
    IWMSServerLimits : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPlayers( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectedPlayers( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionRate( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionRate( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutgoingDistributionConnections( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerOutgoingDistributionConnectionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerOutgoingDistributionConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerInactivityTimeout( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerInactivityTimeout( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerPlayerConnectionBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerPlayerConnectionBandwidth( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerAcknowledgementTimeout( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayerAcknowledgementTimeout( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilizationDuringConnection( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CPUUtilizationDuringConnection( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiagnosticEvents( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiagnosticEvents( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingBandwidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IncomingBandwidth( 
            /* [in] */ long Val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerLimitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServerLimits * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServerLimits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServerLimits * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServerLimits * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServerLimits * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServerLimits * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServerLimits * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPlayers )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectedPlayers )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionRate )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectionRate )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutgoingDistributionConnections )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerOutgoingDistributionConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerInactivityTimeout )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerInactivityTimeout )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerPlayerConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerPlayerConnectionBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerAcknowledgementTimeout )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayerAcknowledgementTimeout )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilizationDuringConnection )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CPUUtilizationDuringConnection )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticEvents )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiagnosticEvents )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingBandwidth )( 
            IWMSServerLimits * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncomingBandwidth )( 
            IWMSServerLimits * This,
            /* [in] */ long Val);
        
        END_INTERFACE
    } IWMSServerLimitsVtbl;

    interface IWMSServerLimits
    {
        CONST_VTBL struct IWMSServerLimitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServerLimits_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSServerLimits_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSServerLimits_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSServerLimits_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSServerLimits_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSServerLimits_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSServerLimits_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSServerLimits_get_ConnectedPlayers(This,pVal)	\
    (This)->lpVtbl -> get_ConnectedPlayers(This,pVal)

#define IWMSServerLimits_put_ConnectedPlayers(This,Val)	\
    (This)->lpVtbl -> put_ConnectedPlayers(This,Val)

#define IWMSServerLimits_get_ConnectionRate(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionRate(This,pVal)

#define IWMSServerLimits_put_ConnectionRate(This,Val)	\
    (This)->lpVtbl -> put_ConnectionRate(This,Val)

#define IWMSServerLimits_get_OutgoingDistributionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionBandwidth(This,pVal)

#define IWMSServerLimits_put_OutgoingDistributionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_OutgoingDistributionBandwidth(This,Val)

#define IWMSServerLimits_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSServerLimits_put_OutgoingDistributionConnections(This,Val)	\
    (This)->lpVtbl -> put_OutgoingDistributionConnections(This,Val)

#define IWMSServerLimits_get_PerOutgoingDistributionConnectionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PerOutgoingDistributionConnectionBandwidth(This,pVal)

#define IWMSServerLimits_put_PerOutgoingDistributionConnectionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PerOutgoingDistributionConnectionBandwidth(This,Val)

#define IWMSServerLimits_get_PlayerBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PlayerBandwidth(This,pVal)

#define IWMSServerLimits_put_PlayerBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PlayerBandwidth(This,Val)

#define IWMSServerLimits_get_PlayerInactivityTimeout(This,pVal)	\
    (This)->lpVtbl -> get_PlayerInactivityTimeout(This,pVal)

#define IWMSServerLimits_put_PlayerInactivityTimeout(This,Val)	\
    (This)->lpVtbl -> put_PlayerInactivityTimeout(This,Val)

#define IWMSServerLimits_get_PerPlayerConnectionBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_PerPlayerConnectionBandwidth(This,pVal)

#define IWMSServerLimits_put_PerPlayerConnectionBandwidth(This,Val)	\
    (This)->lpVtbl -> put_PerPlayerConnectionBandwidth(This,Val)

#define IWMSServerLimits_get_PlayerAcknowledgementTimeout(This,pVal)	\
    (This)->lpVtbl -> get_PlayerAcknowledgementTimeout(This,pVal)

#define IWMSServerLimits_put_PlayerAcknowledgementTimeout(This,Val)	\
    (This)->lpVtbl -> put_PlayerAcknowledgementTimeout(This,Val)

#define IWMSServerLimits_get_CPUUtilizationDuringConnection(This,pVal)	\
    (This)->lpVtbl -> get_CPUUtilizationDuringConnection(This,pVal)

#define IWMSServerLimits_put_CPUUtilizationDuringConnection(This,Val)	\
    (This)->lpVtbl -> put_CPUUtilizationDuringConnection(This,Val)

#define IWMSServerLimits_get_DiagnosticEvents(This,pVal)	\
    (This)->lpVtbl -> get_DiagnosticEvents(This,pVal)

#define IWMSServerLimits_put_DiagnosticEvents(This,Val)	\
    (This)->lpVtbl -> put_DiagnosticEvents(This,Val)

#define IWMSServerLimits_get_IncomingBandwidth(This,pVal)	\
    (This)->lpVtbl -> get_IncomingBandwidth(This,pVal)

#define IWMSServerLimits_put_IncomingBandwidth(This,Val)	\
    (This)->lpVtbl -> put_IncomingBandwidth(This,Val)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_ConnectedPlayers_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_ConnectedPlayers_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_ConnectedPlayers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_ConnectionRate_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_ConnectionRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_ConnectionRate_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_ConnectionRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_OutgoingDistributionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_OutgoingDistributionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_OutgoingDistributionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_OutgoingDistributionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_OutgoingDistributionConnections_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_OutgoingDistributionConnections_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_PerOutgoingDistributionConnectionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_PerOutgoingDistributionConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_PerOutgoingDistributionConnectionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_PerOutgoingDistributionConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_PlayerBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_PlayerBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_PlayerBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_PlayerBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_PlayerInactivityTimeout_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_PlayerInactivityTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_PlayerInactivityTimeout_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_PlayerInactivityTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_PerPlayerConnectionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_PerPlayerConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_PerPlayerConnectionBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_PerPlayerConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_PlayerAcknowledgementTimeout_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_PlayerAcknowledgementTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_PlayerAcknowledgementTimeout_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_PlayerAcknowledgementTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_CPUUtilizationDuringConnection_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_CPUUtilizationDuringConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_CPUUtilizationDuringConnection_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_CPUUtilizationDuringConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_DiagnosticEvents_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_DiagnosticEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_DiagnosticEvents_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_DiagnosticEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_get_IncomingBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServerLimits_get_IncomingBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServerLimits_put_IncomingBandwidth_Proxy( 
    IWMSServerLimits * This,
    /* [in] */ long Val);


void __RPC_STUB IWMSServerLimits_put_IncomingBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSServerLimits_INTERFACE_DEFINED__ */


#ifndef __IWMSServer_INTERFACE_DEFINED__
#define __IWMSServer_INTERFACE_DEFINED__

/* interface IWMSServer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0EE-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_SERVER_STATUS
    {	WMS_SERVER_RUNNING	= 0,
	WMS_SERVER_ERROR	= 0x1,
	WMS_SERVER_ERROR_CRITICAL	= 0x2
    } 	WMS_SERVER_STATUS;

typedef /* [uuid][public] */  DECLSPEC_UUID("49A0F530-F475-45a6-99C5-E52382685BA8") 
enum WMS_OS_PRODUCT_TYPE
    {	WMS_OS_PRODUCT_SERVER	= 0x1,
	WMS_OS_PRODUCT_ADVANCED	= 0x2
    } 	WMS_OS_PRODUCT_TYPE;


EXTERN_C const IID IID_IWMSServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("845FB958-4279-11D2-BF23-00805FBE84A6")
    IWMSServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowClientsToConnect( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowClientsToConnect( 
            /* [in] */ VARIANT_BOOL val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authenticators( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CacheProxy( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ControlProtocols( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCounters( 
            /* [retval][out] */ IWMSServerCurrentCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataSources( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventHandlers( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Limits( 
            /* [retval][out] */ IWMSServerLimits **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileDescriptions( 
            /* [in] */ BSTR Path,
            /* [defaultvalue][in] */ WMS_FILE_TYPE Type,
            /* [retval][out] */ IWMSFileDescriptions **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaParsers( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MonikerName( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PeakCounters( 
            /* [retval][out] */ IWMSServerPeakCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlaylistParsers( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IWMSNamedValues **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublishingPoints( 
            /* [retval][out] */ IWMSPublishingPoints **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCounters( 
            /* [retval][out] */ IWMSServerTotalCounters **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UnicastDataSinks( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Players( 
            /* [retval][out] */ IWMSPlayers **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ WMS_SERVER_STATUS *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePlaylist( 
            /* [retval][out] */ IXMLDOMDocument **ppPlaylist) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingDistributionConnections( 
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CPUUtilization( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportXML( 
            /* [in] */ BSTR bstrXMLFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamFilters( 
            /* [retval][out] */ IWMSPlugins **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPluginLoadType( 
            /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultPluginLoadType( 
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableIPAddresses( 
            /* [retval][out] */ IWMSAvailableIPAddresses **ppIPAddrList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RootDirectories( 
            /* [retval][out] */ IWMSRootDirectories **ppRootDirectories) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiagnosticEvents( 
            /* [retval][out] */ IWMSDiagnosticEvents **ppDiagEvents) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableReverseProxyMode( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableReverseProxyMode( 
            /* [in] */ VARIANT_BOOL val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileType( 
            /* [in] */ BSTR path,
            /* [retval][out] */ WMS_FILE_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DownloadContent( 
            /* [in] */ BSTR SourceUrl,
            /* [in] */ BSTR DestinationUrl,
            /* [defaultvalue][in] */ long lContentSizeLow = -1,
            /* [defaultvalue][in] */ long lContentSizeHigh = -1,
            /* [defaultvalue][in] */ long lBitRate = 0) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OSProductType( 
            /* [retval][out] */ WMS_OS_PRODUCT_TYPE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowClientsToConnect )( 
            IWMSServer * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowClientsToConnect )( 
            IWMSServer * This,
            /* [in] */ VARIANT_BOOL val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticators )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CacheProxy )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlProtocols )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCounters )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSServerCurrentCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSources )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventHandlers )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Limits )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSServerLimits **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileDescriptions )( 
            IWMSServer * This,
            /* [in] */ BSTR Path,
            /* [defaultvalue][in] */ WMS_FILE_TYPE Type,
            /* [retval][out] */ IWMSFileDescriptions **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaParsers )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSServer * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeakCounters )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSServerPeakCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlaylistParsers )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublishingPoints )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPublishingPoints **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCounters )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSServerTotalCounters **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastDataSinks )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Players )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlayers **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSServer * This,
            /* [retval][out] */ WMS_SERVER_STATUS *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePlaylist )( 
            IWMSServer * This,
            /* [retval][out] */ IXMLDOMDocument **ppPlaylist);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IWMSServer * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingDistributionConnections )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPUUtilization )( 
            IWMSServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportXML )( 
            IWMSServer * This,
            /* [in] */ BSTR bstrXMLFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamFilters )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSPlugins **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMSServer * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPluginLoadType )( 
            IWMSServer * This,
            /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPluginLoadType )( 
            IWMSServer * This,
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableIPAddresses )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSAvailableIPAddresses **ppIPAddrList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootDirectories )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSRootDirectories **ppRootDirectories);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticEvents )( 
            IWMSServer * This,
            /* [retval][out] */ IWMSDiagnosticEvents **ppDiagEvents);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableReverseProxyMode )( 
            IWMSServer * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableReverseProxyMode )( 
            IWMSServer * This,
            /* [in] */ VARIANT_BOOL val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileType )( 
            IWMSServer * This,
            /* [in] */ BSTR path,
            /* [retval][out] */ WMS_FILE_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPath )( 
            IWMSServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPath )( 
            IWMSServer * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DownloadContent )( 
            IWMSServer * This,
            /* [in] */ BSTR SourceUrl,
            /* [in] */ BSTR DestinationUrl,
            /* [defaultvalue][in] */ long lContentSizeLow,
            /* [defaultvalue][in] */ long lContentSizeHigh,
            /* [defaultvalue][in] */ long lBitRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSProductType )( 
            IWMSServer * This,
            /* [retval][out] */ WMS_OS_PRODUCT_TYPE *pVal);
        
        END_INTERFACE
    } IWMSServerVtbl;

    interface IWMSServer
    {
        CONST_VTBL struct IWMSServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSServer_get_AllowClientsToConnect(This,pVal)	\
    (This)->lpVtbl -> get_AllowClientsToConnect(This,pVal)

#define IWMSServer_put_AllowClientsToConnect(This,val)	\
    (This)->lpVtbl -> put_AllowClientsToConnect(This,val)

#define IWMSServer_get_Authenticators(This,pVal)	\
    (This)->lpVtbl -> get_Authenticators(This,pVal)

#define IWMSServer_get_CacheProxy(This,pVal)	\
    (This)->lpVtbl -> get_CacheProxy(This,pVal)

#define IWMSServer_get_ControlProtocols(This,pVal)	\
    (This)->lpVtbl -> get_ControlProtocols(This,pVal)

#define IWMSServer_get_CurrentCounters(This,pVal)	\
    (This)->lpVtbl -> get_CurrentCounters(This,pVal)

#define IWMSServer_get_DataSources(This,pVal)	\
    (This)->lpVtbl -> get_DataSources(This,pVal)

#define IWMSServer_get_EventHandlers(This,pVal)	\
    (This)->lpVtbl -> get_EventHandlers(This,pVal)

#define IWMSServer_get_Limits(This,pVal)	\
    (This)->lpVtbl -> get_Limits(This,pVal)

#define IWMSServer_get_FileDescriptions(This,Path,Type,pVal)	\
    (This)->lpVtbl -> get_FileDescriptions(This,Path,Type,pVal)

#define IWMSServer_get_MediaParsers(This,pVal)	\
    (This)->lpVtbl -> get_MediaParsers(This,pVal)

#define IWMSServer_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)

#define IWMSServer_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSServer_get_PeakCounters(This,pVal)	\
    (This)->lpVtbl -> get_PeakCounters(This,pVal)

#define IWMSServer_get_PlaylistParsers(This,pVal)	\
    (This)->lpVtbl -> get_PlaylistParsers(This,pVal)

#define IWMSServer_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSServer_get_PublishingPoints(This,pVal)	\
    (This)->lpVtbl -> get_PublishingPoints(This,pVal)

#define IWMSServer_get_TotalCounters(This,pVal)	\
    (This)->lpVtbl -> get_TotalCounters(This,pVal)

#define IWMSServer_get_UnicastDataSinks(This,pVal)	\
    (This)->lpVtbl -> get_UnicastDataSinks(This,pVal)

#define IWMSServer_get_Players(This,pVal)	\
    (This)->lpVtbl -> get_Players(This,pVal)

#define IWMSServer_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSServer_CreatePlaylist(This,ppPlaylist)	\
    (This)->lpVtbl -> CreatePlaylist(This,ppPlaylist)

#define IWMSServer_get_StartTime(This,pVal)	\
    (This)->lpVtbl -> get_StartTime(This,pVal)

#define IWMSServer_get_OutgoingDistributionConnections(This,pVal)	\
    (This)->lpVtbl -> get_OutgoingDistributionConnections(This,pVal)

#define IWMSServer_get_CPUUtilization(This,pVal)	\
    (This)->lpVtbl -> get_CPUUtilization(This,pVal)

#define IWMSServer_ExportXML(This,bstrXMLFileName)	\
    (This)->lpVtbl -> ExportXML(This,bstrXMLFileName)

#define IWMSServer_get_StreamFilters(This,pVal)	\
    (This)->lpVtbl -> get_StreamFilters(This,pVal)

#define IWMSServer_get_Version(This,pbstrVal)	\
    (This)->lpVtbl -> get_Version(This,pbstrVal)

#define IWMSServer_get_DefaultPluginLoadType(This,pVal)	\
    (This)->lpVtbl -> get_DefaultPluginLoadType(This,pVal)

#define IWMSServer_put_DefaultPluginLoadType(This,val)	\
    (This)->lpVtbl -> put_DefaultPluginLoadType(This,val)

#define IWMSServer_get_AvailableIPAddresses(This,ppIPAddrList)	\
    (This)->lpVtbl -> get_AvailableIPAddresses(This,ppIPAddrList)

#define IWMSServer_get_RootDirectories(This,ppRootDirectories)	\
    (This)->lpVtbl -> get_RootDirectories(This,ppRootDirectories)

#define IWMSServer_get_DiagnosticEvents(This,ppDiagEvents)	\
    (This)->lpVtbl -> get_DiagnosticEvents(This,ppDiagEvents)

#define IWMSServer_get_EnableReverseProxyMode(This,pVal)	\
    (This)->lpVtbl -> get_EnableReverseProxyMode(This,pVal)

#define IWMSServer_put_EnableReverseProxyMode(This,val)	\
    (This)->lpVtbl -> put_EnableReverseProxyMode(This,val)

#define IWMSServer_get_FileType(This,path,pVal)	\
    (This)->lpVtbl -> get_FileType(This,path,pVal)

#define IWMSServer_get_DefaultPath(This,pVal)	\
    (This)->lpVtbl -> get_DefaultPath(This,pVal)

#define IWMSServer_put_DefaultPath(This,newVal)	\
    (This)->lpVtbl -> put_DefaultPath(This,newVal)

#define IWMSServer_DownloadContent(This,SourceUrl,DestinationUrl,lContentSizeLow,lContentSizeHigh,lBitRate)	\
    (This)->lpVtbl -> DownloadContent(This,SourceUrl,DestinationUrl,lContentSizeLow,lContentSizeHigh,lBitRate)

#define IWMSServer_get_OSProductType(This,pVal)	\
    (This)->lpVtbl -> get_OSProductType(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_AllowClientsToConnect_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSServer_get_AllowClientsToConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServer_put_AllowClientsToConnect_Proxy( 
    IWMSServer * This,
    /* [in] */ VARIANT_BOOL val);


void __RPC_STUB IWMSServer_put_AllowClientsToConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Authenticators_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_Authenticators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_CacheProxy_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_CacheProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_ControlProtocols_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_ControlProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_CurrentCounters_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSServerCurrentCounters **pVal);


void __RPC_STUB IWMSServer_get_CurrentCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_DataSources_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_DataSources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_EventHandlers_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_EventHandlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Limits_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSServerLimits **pVal);


void __RPC_STUB IWMSServer_get_Limits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_FileDescriptions_Proxy( 
    IWMSServer * This,
    /* [in] */ BSTR Path,
    /* [defaultvalue][in] */ WMS_FILE_TYPE Type,
    /* [retval][out] */ IWMSFileDescriptions **pVal);


void __RPC_STUB IWMSServer_get_FileDescriptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_MediaParsers_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_MediaParsers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_MonikerName_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IWMSServer_get_MonikerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Name_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSServer_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_PeakCounters_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSServerPeakCounters **pVal);


void __RPC_STUB IWMSServer_get_PeakCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_PlaylistParsers_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_PlaylistParsers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Properties_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSNamedValues **pVal);


void __RPC_STUB IWMSServer_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_PublishingPoints_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPublishingPoints **pVal);


void __RPC_STUB IWMSServer_get_PublishingPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_TotalCounters_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSServerTotalCounters **pVal);


void __RPC_STUB IWMSServer_get_TotalCounters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_UnicastDataSinks_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_UnicastDataSinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Players_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlayers **pVal);


void __RPC_STUB IWMSServer_get_Players_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Status_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ WMS_SERVER_STATUS *pVal);


void __RPC_STUB IWMSServer_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSServer_CreatePlaylist_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IXMLDOMDocument **ppPlaylist);


void __RPC_STUB IWMSServer_CreatePlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_StartTime_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IWMSServer_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_OutgoingDistributionConnections_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSOutgoingDistributionConnections **pVal);


void __RPC_STUB IWMSServer_get_OutgoingDistributionConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_CPUUtilization_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSServer_get_CPUUtilization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSServer_ExportXML_Proxy( 
    IWMSServer * This,
    /* [in] */ BSTR bstrXMLFileName);


void __RPC_STUB IWMSServer_ExportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_StreamFilters_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSPlugins **pVal);


void __RPC_STUB IWMSServer_get_StreamFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_Version_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IWMSServer_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_DefaultPluginLoadType_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal);


void __RPC_STUB IWMSServer_get_DefaultPluginLoadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServer_put_DefaultPluginLoadType_Proxy( 
    IWMSServer * This,
    /* [in] */ WMS_PLUGIN_LOAD_TYPE val);


void __RPC_STUB IWMSServer_put_DefaultPluginLoadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_AvailableIPAddresses_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSAvailableIPAddresses **ppIPAddrList);


void __RPC_STUB IWMSServer_get_AvailableIPAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_RootDirectories_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSRootDirectories **ppRootDirectories);


void __RPC_STUB IWMSServer_get_RootDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_DiagnosticEvents_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ IWMSDiagnosticEvents **ppDiagEvents);


void __RPC_STUB IWMSServer_get_DiagnosticEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_EnableReverseProxyMode_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSServer_get_EnableReverseProxyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServer_put_EnableReverseProxyMode_Proxy( 
    IWMSServer * This,
    /* [in] */ VARIANT_BOOL val);


void __RPC_STUB IWMSServer_put_EnableReverseProxyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_FileType_Proxy( 
    IWMSServer * This,
    /* [in] */ BSTR path,
    /* [retval][out] */ WMS_FILE_TYPE *pVal);


void __RPC_STUB IWMSServer_get_FileType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_DefaultPath_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSServer_get_DefaultPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSServer_put_DefaultPath_Proxy( 
    IWMSServer * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWMSServer_put_DefaultPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWMSServer_DownloadContent_Proxy( 
    IWMSServer * This,
    /* [in] */ BSTR SourceUrl,
    /* [in] */ BSTR DestinationUrl,
    /* [defaultvalue][in] */ long lContentSizeLow,
    /* [defaultvalue][in] */ long lContentSizeHigh,
    /* [defaultvalue][in] */ long lBitRate);


void __RPC_STUB IWMSServer_DownloadContent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSServer_get_OSProductType_Proxy( 
    IWMSServer * This,
    /* [retval][out] */ WMS_OS_PRODUCT_TYPE *pVal);


void __RPC_STUB IWMSServer_get_OSProductType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSServer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmsserver_0210 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0210_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsserver_0210_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsproxy.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmsproxy.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsproxy_h__
#define __wmsproxy_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSProxyContext_FWD_DEFINED__
#define __IWMSProxyContext_FWD_DEFINED__
typedef interface IWMSProxyContext IWMSProxyContext;
#endif 	/* __IWMSProxyContext_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "wmscontext.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsproxy_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from wmsproxy.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

EXTERN_GUID( IID_IWMSProxyContext,        0x2E34AB85,0x0D3D,0x11d2,0x9E,0xEE,0x00,0x60,0x97,0xD2,0xD7,0xCF );


extern RPC_IF_HANDLE __MIDL_itf_wmsproxy_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsproxy_0000_v0_0_s_ifspec;

#ifndef __IWMSProxyContext_INTERFACE_DEFINED__
#define __IWMSProxyContext_INTERFACE_DEFINED__

/* interface IWMSProxyContext */
/* [helpstring][version][uuid][unique][object] */ 


EXTERN_C const IID IID_IWMSProxyContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E34AB85-0D3D-11d2-9EEE-006097D2D7CF")
    IWMSProxyContext : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindProxyForURL( 
            /* [in] */ IWMSContext *pUserContext,
            /* [in] */ BSTR bstrUrl,
            /* [out] */ BSTR *pbstrProxyServer,
            /* [out] */ DWORD *pdwProxyPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCredentials( 
            /* [in] */ IWMSContext *pUserContext,
            /* [in] */ BSTR bstrRealm,
            /* [in] */ BSTR bstrUrl,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ BSTR *pbstrPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSProxyContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSProxyContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSProxyContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSProxyContext * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindProxyForURL )( 
            IWMSProxyContext * This,
            /* [in] */ IWMSContext *pUserContext,
            /* [in] */ BSTR bstrUrl,
            /* [out] */ BSTR *pbstrProxyServer,
            /* [out] */ DWORD *pdwProxyPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCredentials )( 
            IWMSProxyContext * This,
            /* [in] */ IWMSContext *pUserContext,
            /* [in] */ BSTR bstrRealm,
            /* [in] */ BSTR bstrUrl,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ BSTR *pbstrPassword);
        
        END_INTERFACE
    } IWMSProxyContextVtbl;

    interface IWMSProxyContext
    {
        CONST_VTBL struct IWMSProxyContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSProxyContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSProxyContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSProxyContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSProxyContext_FindProxyForURL(This,pUserContext,bstrUrl,pbstrProxyServer,pdwProxyPort)	\
    (This)->lpVtbl -> FindProxyForURL(This,pUserContext,bstrUrl,pbstrProxyServer,pdwProxyPort)

#define IWMSProxyContext_GetCredentials(This,pUserContext,bstrRealm,bstrUrl,pbstrName,pbstrPassword)	\
    (This)->lpVtbl -> GetCredentials(This,pUserContext,bstrRealm,bstrUrl,pbstrName,pbstrPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSProxyContext_FindProxyForURL_Proxy( 
    IWMSProxyContext * This,
    /* [in] */ IWMSContext *pUserContext,
    /* [in] */ BSTR bstrUrl,
    /* [out] */ BSTR *pbstrProxyServer,
    /* [out] */ DWORD *pdwProxyPort);


void __RPC_STUB IWMSProxyContext_FindProxyForURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMSProxyContext_GetCredentials_Proxy( 
    IWMSProxyContext * This,
    /* [in] */ IWMSContext *pUserContext,
    /* [in] */ BSTR bstrRealm,
    /* [in] */ BSTR bstrUrl,
    /* [out] */ BSTR *pbstrName,
    /* [out] */ BSTR *pbstrPassword);


void __RPC_STUB IWMSProxyContext_GetCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSProxyContext_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsplugin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wmsplugin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsplugin_h__
#define __wmsplugin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSPlugin_FWD_DEFINED__
#define __IWMSPlugin_FWD_DEFINED__
typedef interface IWMSPlugin IWMSPlugin;
#endif 	/* __IWMSPlugin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "WMSNamedValues.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsplugin_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from wmsplugin.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
typedef /* [uuid][public] */  DECLSPEC_UUID("56209C38-39FA-432a-8068-307B7BAE01B8") 
enum WMS_PLUGIN_LOAD_TYPE
    {	WMS_PLUGIN_LOAD_TYPE_UNSPECIFIED	= 0,
	WMS_PLUGIN_LOAD_TYPE_IN_PROC	= 1,
	WMS_PLUGIN_LOAD_TYPE_OUT_OF_PROC	= 2,
	WMS_NUM_PLUGIN_LOAD_TYPE	= 3
    } 	WMS_PLUGIN_LOAD_TYPE;

typedef /* [uuid][public] */  DECLSPEC_UUID("56209C39-39FA-432a-8068-307B7BAE01B8") 
enum WMS_PLUGIN_UNSUPPORTED_LOAD_TYPE
    {	WMS_PLUGIN_UNSUPPORTED_LOAD_TYPE_NONE	= 0,
	WMS_PLUGIN_UNSUPPORTED_LOAD_TYPE_IN_PROC	= 1,
	WMS_PLUGIN_UNSUPPORTED_LOAD_TYPE_OUT_OF_PROC	= 2
    } 	WMS_PLUGIN_UNSUPPORTED_LOAD_TYPE;

typedef /* [uuid][public] */  DECLSPEC_UUID("8AC2B32C-A223-4134-8DCF-6673C95CE924") 
enum WMS_PLUGIN_SUPPORT_TYPE
    {	WMS_PLUGIN_SUPPORT_IS_SUPPORTED	= 0,
	WMS_PLUGIN_SUPPORT_REQUIRES_ADVANCED_SERVER	= 1
    } 	WMS_PLUGIN_SUPPORT_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wmsplugin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsplugin_0000_v0_0_s_ifspec;

#ifndef __IWMSPlugin_INTERFACE_DEFINED__
#define __IWMSPlugin_INTERFACE_DEFINED__

/* interface IWMSPlugin */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 

typedef /* [uuid][public] */  DECLSPEC_UUID("3E52E0E2-72A7-11D2-BF2F-00805FBE84A6") 
enum WMS_PLUGIN_STATUS
    {	WMS_PLUGIN_NONE	= 0,
	WMS_PLUGIN_ERROR	= 0x1,
	WMS_PLUGIN_LOADED	= 0x2,
	WMS_PLUGIN_ENABLED	= 0x4,
	WMS_PLUGIN_LOADED_IN_PROC	= 0x8,
	WMS_PLUGIN_LOADED_OUT_OF_PROC	= 0x10,
	WMS_PLUGIN_REMOVE_ON_SERVICE_RESTART	= 0x20
    } 	WMS_PLUGIN_STATUS;


EXTERN_C const IID IID_IWMSPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("517758ed-603c-4b98-82c1-4b2fa7787166")
    IWMSPlugin : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CLSID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CustomInterface( 
            /* [retval][out] */ IDispatch **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IWMSNamedValues **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoadType( 
            /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoadType( 
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorText( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SelectionOrder( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SelectionOrder( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportStatus( 
            /* [retval][out] */ WMS_PLUGIN_SUPPORT_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MonikerName( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMSPlugin * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMSPlugin * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMSPlugin * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMSPlugin * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IWMSPlugin * This,
            /* [in] */ BSTR pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IWMSPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IWMSPlugin * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IWMSPlugin * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            IWMSPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CustomInterface )( 
            IWMSPlugin * This,
            /* [retval][out] */ IDispatch **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWMSPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IWMSPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IWMSPlugin * This,
            /* [retval][out] */ IWMSNamedValues **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IWMSPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadType )( 
            IWMSPlugin * This,
            /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoadType )( 
            IWMSPlugin * This,
            /* [in] */ WMS_PLUGIN_LOAD_TYPE val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorText )( 
            IWMSPlugin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionOrder )( 
            IWMSPlugin * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionOrder )( 
            IWMSPlugin * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportStatus )( 
            IWMSPlugin * This,
            /* [retval][out] */ WMS_PLUGIN_SUPPORT_TYPE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MonikerName )( 
            IWMSPlugin * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        END_INTERFACE
    } IWMSPluginVtbl;

    interface IWMSPlugin
    {
        CONST_VTBL struct IWMSPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSPlugin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSPlugin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSPlugin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSPlugin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWMSPlugin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWMSPlugin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWMSPlugin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWMSPlugin_put_Name(This,pVal)	\
    (This)->lpVtbl -> put_Name(This,pVal)

#define IWMSPlugin_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IWMSPlugin_get_Enabled(This,pVal)	\
    (This)->lpVtbl -> get_Enabled(This,pVal)

#define IWMSPlugin_put_Enabled(This,newVal)	\
    (This)->lpVtbl -> put_Enabled(This,newVal)

#define IWMSPlugin_get_CLSID(This,pVal)	\
    (This)->lpVtbl -> get_CLSID(This,pVal)

#define IWMSPlugin_get_CustomInterface(This,ppVal)	\
    (This)->lpVtbl -> get_CustomInterface(This,ppVal)

#define IWMSPlugin_get_Status(This,pVal)	\
    (This)->lpVtbl -> get_Status(This,pVal)

#define IWMSPlugin_get_ErrorCode(This,pVal)	\
    (This)->lpVtbl -> get_ErrorCode(This,pVal)

#define IWMSPlugin_get_Properties(This,pVal)	\
    (This)->lpVtbl -> get_Properties(This,pVal)

#define IWMSPlugin_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#define IWMSPlugin_get_LoadType(This,pVal)	\
    (This)->lpVtbl -> get_LoadType(This,pVal)

#define IWMSPlugin_put_LoadType(This,val)	\
    (This)->lpVtbl -> put_LoadType(This,val)

#define IWMSPlugin_get_ErrorText(This,pVal)	\
    (This)->lpVtbl -> get_ErrorText(This,pVal)

#define IWMSPlugin_get_SelectionOrder(This,pVal)	\
    (This)->lpVtbl -> get_SelectionOrder(This,pVal)

#define IWMSPlugin_put_SelectionOrder(This,lVal)	\
    (This)->lpVtbl -> put_SelectionOrder(This,lVal)

#define IWMSPlugin_get_SupportStatus(This,pVal)	\
    (This)->lpVtbl -> get_SupportStatus(This,pVal)

#define IWMSPlugin_get_MonikerName(This,pbstrVal)	\
    (This)->lpVtbl -> get_MonikerName(This,pbstrVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_put_Name_Proxy( 
    IWMSPlugin * This,
    /* [in] */ BSTR pVal);


void __RPC_STUB IWMSPlugin_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_Name_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlugin_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_Enabled_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IWMSPlugin_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_put_Enabled_Proxy( 
    IWMSPlugin * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IWMSPlugin_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_CLSID_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlugin_get_CLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_CustomInterface_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ IDispatch **ppVal);


void __RPC_STUB IWMSPlugin_get_CustomInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_Status_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlugin_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_ErrorCode_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlugin_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_Properties_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ IWMSNamedValues **pVal);


void __RPC_STUB IWMSPlugin_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_Version_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlugin_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_LoadType_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ WMS_PLUGIN_LOAD_TYPE *pVal);


void __RPC_STUB IWMSPlugin_get_LoadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_put_LoadType_Proxy( 
    IWMSPlugin * This,
    /* [in] */ WMS_PLUGIN_LOAD_TYPE val);


void __RPC_STUB IWMSPlugin_put_LoadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_ErrorText_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IWMSPlugin_get_ErrorText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_SelectionOrder_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IWMSPlugin_get_SelectionOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_put_SelectionOrder_Proxy( 
    IWMSPlugin * This,
    /* [in] */ long lVal);


void __RPC_STUB IWMSPlugin_put_SelectionOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_SupportStatus_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ WMS_PLUGIN_SUPPORT_TYPE *pVal);


void __RPC_STUB IWMSPlugin_get_SupportStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWMSPlugin_get_MonikerName_Proxy( 
    IWMSPlugin * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IWMSPlugin_get_MonikerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSPlugin_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wownt16.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt16.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 16-bit thunking code.

--*/

#ifndef _WOWNT16_
#define _WOWNT16_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// GetVDMPointer32W will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer. The upper 16 bits
// of the address are treated according to the value passed in
// fMode: if fMode = 1, then the hiword of vp is used as a
// protected mode selector. Otherwise it is used as a real mode
// segment value.
// The lower 16 bits are treated as the offset.
//
// The return value is 0 if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause 0 to be returned when the
// limit is exceeded by the supplied offset.
//

DWORD FAR PASCAL GetVDMPointer32W(LPVOID vp, UINT fMode);


//
// Win32 module management.
//
// The following routines accept parameters that correspond directly
// to the respective Win32 API function calls that they invoke. Refer
// to the Win32 reference documentation for more detail.

DWORD FAR PASCAL LoadLibraryEx32W(LPCSTR lpszLibFile, DWORD hFile, DWORD dwFlags);
DWORD FAR PASCAL GetProcAddress32W(DWORD hModule, LPCSTR lpszProc);
DWORD FAR PASCAL FreeLibrary32W(DWORD hLibModule);

//
// Generic Thunk Routine:
//
//   CallProc32W
//
// Transitions to 32 bits and calls specified routine
//
// This routine can pass a variable number of arguments, up to 32, to the
// target 32-bit routine. These arguments are given to CallProc32W following
// the 3 required parameters.
//
//   DWORD cParams          - Number of optional DWORD parameters (0-32)
//
//   LPVOID fAddressConvert - Bit Field, for 16:16 address Convertion. The
//                            optional parameters can be automatically converted
//                            from a 16:16 address format to flat by specifying
//                            a 1 bit in the corresponding position in this mask.
//                            eg (bit 1 means convert parameter 1 from 16:16
//                              to flat address before calling routine)
//
//   DWORD lpProcAddress   -  32 bit native address to call (use LoadLibraryEx32W
//                            and GetProcAddress32W to get this address).
//
// Returns:
//   What ever the API returned on 32 bit side in AX:DX
//
// Error Returns:
//   AX = 0, more than 32 parameters.
//
//
// The function prototype must be declared by the application source code
// in the following format:
//
// DWORD FAR PASCAL CallProc32W( DWORD p1, ... , DWORD lpProcAddress,
//                                        DWORD fAddressConvert, DWORD cParams);
//
// where the value in cParams must match the actual number of optional
// parameters (p1-pn) given AND the "DWORD p1, ..." must be replaced by
// the correct number of parameters being passed.  For example, passing 3
// parameter would simply require the removal of the ... and it insertion of
// "DWORD p2, DWORD p3" instead.  The fAddressConvert parameter uses bit 1
// for the last parameter (p3 in our example), with bit 2 for the next to last,
// etc.
//
// Generic Thunk Routine:
//
//   CallProcEx32W
//
// Transitions to 32 bits and calls specified routine
//
// Similar to the CallProc32W function, the CallProcEx32W is an equivalent
// function that is C calling convention and allows easier and more flexible
// prototyping.  See the prototype below.  The fAddressConvert parameter uses
// bit 1 for the 1st parameter, bit 2 for the 2nd parameter, etc.
//
// Both CallProc32W and CallProcEx32W accept a flag OR'd with the parameter
// count to indicate the calling convention of the function in 32 bits.
// For example, to call a cdecl function in 32-bits with 1 parameter, it would
// look like this:
//
// dwResult = CallProcEx32W( CPEX_DEST_CDECL | 1, 0, dwfn32, p1 );
//

DWORD FAR CDECL CallProcEx32W( DWORD, DWORD, DWORD, ... );

#define CPEX_DEST_STDCALL   0x00000000L
#define CPEX_DEST_CDECL     0x80000000L

#ifdef __cplusplus
}
#endif

#endif /* !_WOWNT16_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wmsysprf.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsysprf.prx
//
//  Description: This file contains the GUIDs of the system profiles.
//
//============================================================================

///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );

///////////////////////////////////////////////////////////////////////////////

/* F55EA573-4C02-42b5-9026-A8260C438A9F */
EXTERN_GUID( WMProfile_V70_225VideoPDA, 
             0xf55ea573,
             0x4c02,
             0x42b5,
             0x90, 0x26, 0xa8, 0x26, 0xc, 0x43, 0x8a, 0x9f );

///////////////////////////////////////////////////////////////////////////////

/* 0F472967-E3C6-4797-9694-F0304C5E2F17 */
EXTERN_GUID( WMProfile_V70_150VideoPDA, 
             0xf472967,
             0xe3c6,
             0x4797,
             0x96, 0x94, 0xf0, 0x30, 0x4c, 0x5e, 0x2f, 0x17 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wownt32.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-1999, Microsoft Corporation

Module Name:

    wownt32.h

Abstract:

    Procedure declarations for functions in WOW32.DLL callable by
    3rd-party 32-bit thunking code.

--*/

#ifndef _WOWNT32_
#define _WOWNT32_

#if defined(_MSC_VER)
#if _MSC_VER > 1000
#pragma once
#endif
#endif

//
// 16:16 -> 0:32 Pointer translation.
//
// WOWGetVDMPointer will convert the passed in 16-bit address
// to the equivalent 32-bit flat pointer.  If fProtectedMode
// is TRUE, the function treats the upper 16 bits as a selector
// in the local descriptor table.  If fProtectedMode is FALSE,
// the upper 16 bits are treated as a real-mode segment value.
// In either case the lower 16 bits are treated as the offset.
//
// The return value is NULL if the selector is invalid.
//
// NOTE:  Limit checking is not performed in the retail build
// of Windows NT.  It is performed in the checked (debug) build
// of WOW32.DLL, which will cause NULL to be returned when the
// limit is exceeded by the supplied offset.
//

LPVOID WINAPI WOWGetVDMPointer(DWORD vp, DWORD dwBytes,
                               BOOL fProtectedMode);

//
// The following two functions are here for compatibility with
// Windows 95.  On Win95, the global heap can be rearranged,
// invalidating flat pointers returned by WOWGetVDMPointer, while
// a thunk is executing.  On Windows NT, the 16-bit VDM is completely
// halted while a thunk executes, so the only way the heap will
// be rearranged is if a callback is made to Win16 code.
//
// The Win95 versions of these functions call GlobalFix to
// lock down a segment's flat address, and GlobalUnfix to
// release the segment.
//
// The Windows NT implementations of these functions do *not*
// call GlobalFix/GlobalUnfix on the segment, because there
// will not be any heap motion unless a callback occurs.
// If your thunk does callback to the 16-bit side, be sure
// to discard flat pointers and call WOWGetVDMPointer again
// to be sure the flat address is correct.
//

LPVOID WINAPI WOWGetVDMPointerFix(DWORD vp, DWORD dwBytes,
                                  BOOL fProtectedMode);
VOID WINAPI WOWGetVDMPointerUnfix(DWORD vp);


//
// Win16 memory management.
//
// These functions can be used to manage memory in the Win16
// heap.  The following four functions are identical to their
// Win16 counterparts, except that they are called from Win32
// code.
//

WORD  WINAPI WOWGlobalAlloc16(WORD wFlags, DWORD cb);
WORD  WINAPI WOWGlobalFree16(WORD hMem);
DWORD WINAPI WOWGlobalLock16(WORD hMem);
BOOL  WINAPI WOWGlobalUnlock16(WORD hMem);

//
// The following three functions combine two common operations in
// one switch to 16-bit mode.
//

DWORD WINAPI WOWGlobalAllocLock16(WORD wFlags, DWORD cb, WORD *phMem);
WORD  WINAPI WOWGlobalUnlockFree16(DWORD vpMem);
DWORD WINAPI WOWGlobalLockSize16(WORD hMem, PDWORD pcb);

//
// Yielding the Win16 nonpreemptive scheduler
//
// The following two functions are provided for Win32 code called
// via Generic Thunks which needs to yield the Win16 scheduler so
// that tasks in that VDM can execute while the thunk waits for
// something to complete.  These two functions are functionally
// identical to calling back to 16-bit code which calls Yield or
// DirectedYield.
//

VOID WINAPI WOWYield16(VOID);
VOID WINAPI WOWDirectedYield16(WORD htask16);


//
// 16 <--> 32 Handle mapping functions.
//
// NOTE:  While some of these functions perform trivial
// conversions, these functions must be used to maintain
// compatibility with future versions of Windows NT which
// may require different handle mapping.
//

typedef enum _WOW_HANDLE_TYPE { /* WOW */
    WOW_TYPE_HWND,
    WOW_TYPE_HMENU,
    WOW_TYPE_HDWP,
    WOW_TYPE_HDROP,
    WOW_TYPE_HDC,
    WOW_TYPE_HFONT,
    WOW_TYPE_HMETAFILE,
    WOW_TYPE_HRGN,
    WOW_TYPE_HBITMAP,
    WOW_TYPE_HBRUSH,
    WOW_TYPE_HPALETTE,
    WOW_TYPE_HPEN,
    WOW_TYPE_HACCEL,
    WOW_TYPE_HTASK,
    WOW_TYPE_FULLHWND
} WOW_HANDLE_TYPE;

HANDLE WINAPI WOWHandle32 (WORD, WOW_HANDLE_TYPE);
WORD WINAPI WOWHandle16 (HANDLE, WOW_HANDLE_TYPE);

#define HWND_32(h16)      ((HWND)      (WOWHandle32(h16, WOW_TYPE_HWND)))
#define HMENU_32(h16)     ((HMENU)     (WOWHandle32(h16, WOW_TYPE_HMENU)))
#define HDWP_32(h16)      ((HDWP)      (WOWHandle32(h16, WOW_TYPE_HDWP)))
#define HDROP_32(h16)     ((HDROP)     (WOWHandle32(h16, WOW_TYPE_HDROP)))
#define HDC_32(h16)       ((HDC)       (WOWHandle32(h16, WOW_TYPE_HDC)))
#define HFONT_32(h16)     ((HFONT)     (WOWHandle32(h16, WOW_TYPE_HFONT)))
#define HMETAFILE_32(h16) ((HMETAFILE) (WOWHandle32(h16, WOW_TYPE_HMETAFILE)))
#define HRGN_32(h16)      ((HRGN)      (WOWHandle32(h16, WOW_TYPE_HRGN)))
#define HBITMAP_32(h16)   ((HBITMAP)   (WOWHandle32(h16, WOW_TYPE_HBITMAP)))
#define HBRUSH_32(h16)    ((HBRUSH)    (WOWHandle32(h16, WOW_TYPE_HBRUSH)))
#define HPALETTE_32(h16)  ((HPALETTE)  (WOWHandle32(h16, WOW_TYPE_HPALETTE)))
#define HPEN_32(h16)      ((HPEN)      (WOWHandle32(h16, WOW_TYPE_HPEN)))
#define HACCEL_32(h16)	  ((HACCEL)    (WOWHandle32(h16, WOW_TYPE_HACCEL)))
#define HTASK_32(h16)	  ((DWORD)     (WOWHandle32(h16, WOW_TYPE_HTASK)))
#define FULLHWND_32(h16)  ((HWND)      (WOWHandle32(h16, WOW_TYPE_FULLHWND)))

#define HWND_16(h32)      (WOWHandle16(h32, WOW_TYPE_HWND))
#define HMENU_16(h32)     (WOWHandle16(h32, WOW_TYPE_HMENU))
#define HDWP_16(h32)      (WOWHandle16(h32, WOW_TYPE_HDWP))
#define HDROP_16(h32)     (WOWHandle16(h32, WOW_TYPE_HDROP))
#define HDC_16(h32)       (WOWHandle16(h32, WOW_TYPE_HDC))
#define HFONT_16(h32)     (WOWHandle16(h32, WOW_TYPE_HFONT))
#define HMETAFILE_16(h32) (WOWHandle16(h32, WOW_TYPE_HMETAFILE))
#define HRGN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HRGN))
#define HBITMAP_16(h32)   (WOWHandle16(h32, WOW_TYPE_HBITMAP))
#define HBRUSH_16(h32)    (WOWHandle16(h32, WOW_TYPE_HBRUSH))
#define HPALETTE_16(h32)  (WOWHandle16(h32, WOW_TYPE_HPALETTE))
#define HPEN_16(h32)      (WOWHandle16(h32, WOW_TYPE_HPEN))
#define HACCEL_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HACCEL))
#define HTASK_16(h32)	  (WOWHandle16(h32, WOW_TYPE_HTASK))

//
// Generic Callbacks.
//
// WOWCallback16 can be used in Win32 code called
// from 16-bit (such as by using Generic Thunks) to call back to
// the 16-bit side.  The function called must be declared similarly
// to the following:
//
// LONG FAR PASCAL CallbackRoutine(DWORD dwParam);
//
// If you are passing a pointer, declare the parameter as such:
//
// LONG FAR PASCAL CallbackRoutine(VOID FAR *vp);
//
// NOTE: If you are passing a pointer, you'll need to get the
// pointer using WOWGlobalAlloc16 or WOWGlobalAllocLock16
//
// If the function called returns a WORD instead of a DWORD, the
// upper 16 bits of the return value is undefined.  Similarly, if
// the function called has no return value, the entire return value
// is undefined.
//
// WOWCallback16Ex allows any combination of arguments up to
// WCB16_MAX_CBARGS bytes total to be passed to the 16-bit routine.
// cbArgs is used to properly clean up the 16-bit stack after calling
// the routine.  Regardless of the value of cbArgs, WCB16_MAX_CBARGS
// bytes will always be copied from pArgs to the 16-bit stack.  If
// pArgs is less than WCB16_MAX_CBARGS bytes from the end of a page,
// and the next page is inaccessible, WOWCallback16Ex will incur an
// access violation.
//
// If cbArgs is larger than the WCB16_MAX_ARGS which the running
// system supports, the function returns FALSE and GetLastError
// returns ERROR_INVALID_PARAMETER.  Otherwise the function
// returns TRUE and the DWORD pointed to by pdwRetCode contains
// the return code from the callback routine.  If the callback
// routine returns a WORD, the HIWORD of the return code is
// undefined and should be ignored using LOWORD(dwRetCode).
//
// WOWCallback16Ex can call routines using the PASCAL and CDECL
// calling conventions.  The default is to use the PASCAL
// calling convention.  To use CDECL, pass WCB16_CDECL in the
// dwFlags parameter.
//
// The arguments pointed to by pArgs must be in the correct
// order for the callback routine's calling convention.
// To call the PASCAL routine SetWindowText,
//
// LONG FAR PASCAL SetWindowText(HWND hwnd, LPCSTR lpsz);
//
// pArgs would point to an array of words:
//
// WORD SetWindowTextArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz), hwnd};
//
// In other words, the arguments are placed in the array in reverse
// order with the least significant word first for DWORDs and offset
// first for FAR pointers.
//
// To call the CDECL routine wsprintf, for example
//
// LPSTR lpszFormat = "%d %s";
// int _cdecl wsprintf(lpsz, lpszFormat, nValue. lpszString);
//
// pArgs would point to the array:
//
// WORD wsprintfArgs[] = {OFFSETOF(lpsz), SELECTOROF(lpsz),
//                        OFFSETOF(lpszFormat), SELECTOROF(lpszFormat),
//                        nValue,
//                        OFFSETOF(lpszString), SELECTOROF(lpszString)};
//
// In other words, the arguments are placed in the array in the order
// listed in the function prototype with the least significant word
// first for DWORDs and offset first for FAR pointers.
//

DWORD WINAPI WOWCallback16(DWORD vpfn16, DWORD dwParam);

#define WCB16_MAX_CBARGS (16)

#define WCB16_PASCAL     (0x0)
#define WCB16_CDECL      (0x1)

BOOL WINAPI WOWCallback16Ex(
                DWORD  vpfn16,
                DWORD  dwFlags,
                DWORD  cbArgs,
                PVOID  pArgs,
                PDWORD pdwRetCode
                );

#endif /* !_WOWNT32_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ws2spi.h ===
/* WS2SPI.H -- definitions to be used with the WinSock service provider.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * This header file corresponds to version 2.2.x of the WinSock SPI
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCK2SPI_
#define _WINSOCK2SPI_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Ensure structures are packed consistently.
 */

#if !defined(_WIN64)
#include <pshpack4.h>
#endif

/*
 * Pull in WINSOCK2.H if necessary
 */

#ifndef _WINSOCK2API_
#include <winsock2.h>
#endif /* _WINSOCK2API_ */

#define WSPDESCRIPTION_LEN 255

#define WSS_OPERATION_IN_PROGRESS 0x00000103L

typedef struct WSPData {
    WORD         wVersion;
    WORD         wHighVersion;
    WCHAR        szDescription[WSPDESCRIPTION_LEN+1];
} WSPDATA, FAR * LPWSPDATA;

typedef struct _WSATHREADID {
    HANDLE      ThreadHandle;
    DWORD_PTR    Reserved;
} WSATHREADID, FAR * LPWSATHREADID;

/*
 * SPI function linkage.
 */

#define WSPAPI WSAAPI


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Pointer to a blocking callback. A pointer to a blocking callback is
 * returned from the WPUQueryBlockingCallback() upcall. Note that this
 * function's signature is not identical to an application's blocking
 * hook function.
 */

typedef
BOOL
(CALLBACK FAR * LPBLOCKINGCALLBACK)(
    DWORD_PTR dwContext
    );

/*
 * Pointer to a user APC function. This is used as a parameter to the
 * WPUQueueUserApc() upcall. Note that this function's signature is not
 * identical to an application's completion routine.
 */

typedef
VOID
(CALLBACK FAR * LPWSAUSERAPC)(
    DWORD_PTR dwContext
    );

/*
 * Pointers to the individual entries in a service provider's proc table.
 */

typedef
SOCKET
(WSPAPI * LPWSPACCEPT)(
    SOCKET s,
    struct sockaddr FAR * addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD_PTR dwCallbackData,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPADDRESSTOSTRING)(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPASYNCSELECT)(
    SOCKET s,
    HWND hWnd,
    unsigned int wMsg,
    long lEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPBIND)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCANCELBLOCKINGCALL)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLEANUP)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLOSESOCKET)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCONNECT)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPDUPLICATESOCKET)(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPENUMNETWORKEVENTS)(
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPEVENTSELECT)(
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETOVERLAPPEDRESULT)(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETPEERNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    LPINT optlen,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETQOSBYNAME)(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPIOCTL)(
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPJOINLEAF)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPLISTEN)(
    SOCKET s,
    int backlog,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECV)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVDISCONNECT)(
    SOCKET s,
    LPWSABUF lpInboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVFROM)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSELECT)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR * exceptfds,
    const struct timeval FAR * timeout,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSEND)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDDISCONNECT)(
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDTO)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSHUTDOWN)(
    SOCKET s,
    int how,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPSOCKET)(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPSTRINGTOADDRESS)(
    LPWSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength,
    LPINT lpErrno
    );

/*
 * A service provider proc table. This structure is returned by value
 * from the service provider's WSPStartup() entrypoint.
 */

typedef struct _WSPPROC_TABLE {

    LPWSPACCEPT              lpWSPAccept;
    LPWSPADDRESSTOSTRING     lpWSPAddressToString;
    LPWSPASYNCSELECT         lpWSPAsyncSelect;
    LPWSPBIND                lpWSPBind;
    LPWSPCANCELBLOCKINGCALL  lpWSPCancelBlockingCall;
    LPWSPCLEANUP             lpWSPCleanup;
    LPWSPCLOSESOCKET         lpWSPCloseSocket;
    LPWSPCONNECT             lpWSPConnect;
    LPWSPDUPLICATESOCKET     lpWSPDuplicateSocket;
    LPWSPENUMNETWORKEVENTS   lpWSPEnumNetworkEvents;
    LPWSPEVENTSELECT         lpWSPEventSelect;
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    LPWSPGETPEERNAME         lpWSPGetPeerName;
    LPWSPGETSOCKNAME         lpWSPGetSockName;
    LPWSPGETSOCKOPT          lpWSPGetSockOpt;
    LPWSPGETQOSBYNAME        lpWSPGetQOSByName;
    LPWSPIOCTL               lpWSPIoctl;
    LPWSPJOINLEAF            lpWSPJoinLeaf;
    LPWSPLISTEN              lpWSPListen;
    LPWSPRECV                lpWSPRecv;
    LPWSPRECVDISCONNECT      lpWSPRecvDisconnect;
    LPWSPRECVFROM            lpWSPRecvFrom;
    LPWSPSELECT              lpWSPSelect;
    LPWSPSEND                lpWSPSend;
    LPWSPSENDDISCONNECT      lpWSPSendDisconnect;
    LPWSPSENDTO              lpWSPSendTo;
    LPWSPSETSOCKOPT          lpWSPSetSockOpt;
    LPWSPSHUTDOWN            lpWSPShutdown;
    LPWSPSOCKET              lpWSPSocket;
    LPWSPSTRINGTOADDRESS     lpWSPStringToAddress;

} WSPPROC_TABLE, FAR * LPWSPPROC_TABLE;

/*
 * Pointers to the individual entries in the upcall table.
 */

typedef
BOOL
(WSPAPI * LPWPUCLOSEEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSESOCKETHANDLE)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
WSAEVENT
(WSPAPI * LPWPUCREATEEVENT)(
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUCREATESOCKETHANDLE)(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUFDISSET)(
    SOCKET s,
    fd_set FAR * fdset
    );

typedef
int
(WSPAPI * LPWPUGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUMODIFYIFSHANDLE)(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUPOSTMESSAGE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

typedef
int
(WSPAPI * LPWPUQUERYBLOCKINGCALLBACK)(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUERYSOCKETHANDLECONTEXT)(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUEUEAPC)(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPURESETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUSETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUOPENCURRENTTHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSETHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );


// Available only directly from ws2_32.dll
typedef
int
(WSPAPI * LPWPUCOMPLETEOVERLAPPEDREQUEST) (
    IN SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
);

/*
 * The upcall table. This structure is passed by value to the service
 * provider's WSPStartup() entrypoint.
 */

typedef struct _WSPUPCALLTABLE {

    LPWPUCLOSEEVENT               lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE        lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT              lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE       lpWPUCreateSocketHandle;
    LPWPUFDISSET                  lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH          lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE          lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE              lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK    lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC                 lpWPUQueueApc;
    LPWPURESETEVENT               lpWPUResetEvent;
    LPWPUSETEVENT                 lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD        lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD              lpWPUCloseThread;

} WSPUPCALLTABLE, FAR * LPWSPUPCALLTABLE;

/*
 *  WinSock 2 SPI socket function prototypes
 */

int
WSPAPI
WSPStartup(
    IN WORD wVersionRequested,
    OUT LPWSPDATA lpWSPData,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN WSPUPCALLTABLE UpcallTable,
    OUT LPWSPPROC_TABLE lpProcTable
    );

typedef
int
(WSPAPI * LPWSPSTARTUP)(
    WORD wVersionRequested,
    LPWSPDATA lpWSPData,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    WSPUPCALLTABLE UpcallTable,
    LPWSPPROC_TABLE lpProcTable
    );

/*
 * Installation and configuration entrypoints.
 */

int
WSPAPI
WSCEnumProtocols(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCENUMPROTOCOLS)(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT lpErrno
    );

#if defined(_WIN64)
/*
 * 64-bit architectures capable of running 32-bit code have
 * separate 64-bit and 32-bit catalogs.  API with '32' prefix
 * allow 32 bit catalog manipulations by 64 bit process.
 */
int
WSPAPI
WSCEnumProtocols32(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    );
#endif

int
WSPAPI
WSCDeinstallProvider(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCDEINSTALLPROVIDER)(
    LPGUID lpProviderId,
    LPINT lpErrno
    );

#if defined(_WIN64)
int
WSPAPI
WSCDeinstallProvider32(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    );
#endif

int
WSPAPI
WSCInstallProvider(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCINSTALLPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

#if defined(_WIN64)
/*
 * This API manipulates 64-bit and 32-bit catalogs simulteneously.
 * It is needed to guarantee the same catalog IDs for provider catalog
 * entries in both 64-bit and 32-bit catalogs.
 */
int
WSPAPI
WSCInstallProvider64_32(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );
#endif

int
WSPAPI
WSCGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

#if defined(_WIN64)
int
WSPAPI
WSCGetProviderPath32(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );
#endif

int
WSPAPI
WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCUPDATEPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

#if defined(_WIN64)
int
WSPAPI
WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );
#endif

int
WSPAPI
WSCInstallQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName,
    IN  LPQOS           Qos
    );

typedef
int
(WSPAPI * LPWSCINSTALLQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName,
    LPQOS           Qos
    );

int
WSPAPI
WSCRemoveQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName
    );

typedef
int
(WSPAPI * LPWSCREMOVEQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName
    );

/*
 *  The following upcall function prototypes are only used by WinSock 2 DLL and
 *  should not be used by any service providers.
 */

BOOL
WSPAPI
WPUCloseEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUCloseSocketHandle(
    IN SOCKET s,
    OUT LPINT lpErrno
    );

WSAEVENT
WSPAPI
WPUCreateEvent(
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUCreateSocketHandle(
    IN DWORD dwCatalogEntryId,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUFDIsSet(
    IN SOCKET s,
    IN fd_set FAR * fdset
    );

int
WSPAPI
WPUGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUModifyIFSHandle(
    IN DWORD dwCatalogEntryId,
    IN SOCKET ProposedHandle,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUPostMessage(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

int
WSPAPI
WPUQueryBlockingCallback(
    IN DWORD dwCatalogEntryId,
    OUT LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    OUT PDWORD_PTR lpdwContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUQuerySocketHandleContext(
    IN SOCKET s,
    OUT PDWORD_PTR lpContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUQueueApc(
    IN LPWSATHREADID lpThreadId,
    IN LPWSAUSERAPC lpfnUserApc,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUResetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUSetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
);

int
WSPAPI
WPUOpenCurrentThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

int
WSPAPI
WPUCloseThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

/*
 * Installing and uninstalling name space providers.
 */

/*
 * SPI and API for enumerating name space providers are
 * currently equivalent since there is no concept of a hidden
 * name space provider
 */
#define WSCEnumNameSpaceProviders WSAEnumNameSpaceProvidersW
#define LPFN_WSCENUMNAMESPACEPROVIDERS LPFN_WSAENUMNAMESPACEPROVIDERSW

#if defined(_WIN64)
INT
WSAAPI
WSCEnumNameSpaceProviders32(
    IN OUT LPDWORD              lpdwBufferLength,
    OUT    LPWSANAMESPACE_INFOW lpnspBuffer
    );
#endif


INT
WSPAPI
WSCInstallNameSpace (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCINSTALLNAMESPACE)(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId
    );

#if defined(_WIN64)
INT
WSPAPI
WSCInstallNameSpace32 (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    );
#endif

INT
WSPAPI
WSCUnInstallNameSpace (
    IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCUNINSTALLNAMESPACE)(
    LPGUID lpProviderId
    );

#if defined(_WIN64)
INT
WSPAPI
WSCUnInstallNameSpace32 (
    IN LPGUID lpProviderId
    );
#endif

INT
WSPAPI
WSCEnableNSProvider (
    IN LPGUID lpProviderId,
    IN BOOL fEnable
    );

typedef
INT
(WSPAPI * LPWSCENABLENSPROVIDER)(
    LPGUID lpProviderId,
    BOOL fEnable
    );

#if defined(_WIN64)
INT
WSPAPI
WSCEnableNSProvider32 (
    IN LPGUID lpProviderId,
    IN BOOL fEnable
    );
#endif


/*
 * Pointers to the individual entries in the namespace proc table.
 */

typedef
INT
(WSAAPI * LPNSPCLEANUP)(
    LPGUID lpProviderId
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEBEGIN)(
    LPGUID lpProviderId,
    LPWSAQUERYSETW lpqsRestrictions,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICENEXT)(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETW lpqsResults
    );

typedef
INT
(WSAAPI * LPNSPIOCTL)(
    HANDLE          hLookup,
    DWORD           dwControlCode,
    LPVOID          lpvInBuffer,
    DWORD           cbInBuffer,
    LPVOID          lpvOutBuffer,
    DWORD           cbOutBuffer,
    LPDWORD         lpcbBytesReturned,
    LPWSACOMPLETION lpCompletion,
    LPWSATHREADID   lpThreadId
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEEND)(
    HANDLE hLookup
    );

typedef
INT
(WSAAPI * LPNSPSETSERVICE)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    LPWSAQUERYSETW lpqsRegInfo,
    WSAESETSERVICEOP essOperation,
    DWORD dwControlFlags
    );

typedef
INT
(WSAAPI * LPNSPINSTALLSERVICECLASS)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

typedef
INT
(WSAAPI * LPNSPREMOVESERVICECLASS)(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId
    );

typedef
INT
(WSAAPI * LPNSPGETSERVICECLASSINFO)(
    LPGUID lpProviderId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

/*
 * The name space service provider procedure table.
 */

typedef struct _NSP_ROUTINE {

    /* Structure version information: */
    DWORD           cbSize;
    DWORD           dwMajorVersion;
    DWORD           dwMinorVersion;

    /* Procedure-pointer table: */

    LPNSPCLEANUP             NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN  NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT   NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND    NSPLookupServiceEnd;
    LPNSPSETSERVICE          NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS  NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;

    // These APIs were added later, so must appear here
    // to keep the pointers in the structure in order.
    // Namespaces unaware of these APIs will set cbSize
    // to match the size of FIELD_OFFSET(NSP_ROUTINE, NSPIoctl).
    LPNSPIOCTL               NSPIoctl;

} NSP_ROUTINE, FAR * LPNSP_ROUTINE;

/*
 * Startup procedures.
 */

INT
WSAAPI
NSPStartup(
    LPGUID lpProviderId,
    LPNSP_ROUTINE lpnspRoutines
    );

typedef
INT
(WSAAPI * LPNSPSTARTUP)(
    LPGUID lpProviderId,
    LPNSP_ROUTINE lpnspRoutines
    );


#ifdef __cplusplus
}
#endif

#if !defined(_WIN64)
#include <poppack.h>
#endif

#endif  /* _WINSOCK2SPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ws2atm.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

	ws2atm.h

Abstract:

	Winsock 2 ATM Annex definitions.

Revision History:

Notes:

--*/

#ifndef _WS2ATM_H_
#define _WS2ATM_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#define ATMPROTO_AALUSER           0x00   /* User-defined AAL */
#define ATMPROTO_AAL1              0x01   /* AAL 1 */
#define ATMPROTO_AAL2              0x02   /* AAL 2 */
#define ATMPROTO_AAL34             0x03   /* AAL 3/4 */
#define ATMPROTO_AAL5              0x05   /* AAL 5 */

#define SAP_FIELD_ABSENT           0xFFFFFFFE
#define SAP_FIELD_ANY              0xFFFFFFFF
#define SAP_FIELD_ANY_AESA_SEL     0xFFFFFFFA
#define SAP_FIELD_ANY_AESA_REST    0xFFFFFFFB

/*
 *  values used for AddressType in struct ATM_ADDRESS
 */
#define ATM_E164               0x01   /* E.164 addressing scheme */
#define ATM_NSAP               0x02   /* NSAP-style ATM Endsystem Address scheme */
#define ATM_AESA               0x02   /* NSAP-style ATM Endsystem Address scheme */

#define ATM_ADDR_SIZE          20
typedef struct {
    DWORD AddressType;                /* E.164 or NSAP-style ATM Endsystem Address */
    DWORD NumofDigits;                /* number of digits; */
    UCHAR Addr[ATM_ADDR_SIZE];        /* IA5 digits for E164, BCD encoding for NSAP */
                                      /* format as defined in the ATM Forum UNI 3.1 */
} ATM_ADDRESS;

/*
 *  values used for Layer2Protocol in B-LLI
 */
#define BLLI_L2_ISO_1745           0x01   /* Basic mode ISO 1745                      */
#define BLLI_L2_Q921               0x02   /* CCITT Rec. Q.921                         */
#define BLLI_L2_X25L               0x06   /* CCITT Rec. X.25, link layer              */
#define BLLI_L2_X25M               0x07   /* CCITT Rec. X.25, multilink               */
#define BLLI_L2_ELAPB              0x08   /* Extended LAPB; for half duplex operation */
#define BLLI_L2_HDLC_ARM           0x09   /* HDLC ARM (ISO 4335)                      */
#define BLLI_L2_HDLC_NRM           0x0A   /* HDLC NRM (ISO 4335)                      */
#define BLLI_L2_HDLC_ABM           0x0B   /* HDLC ABM (ISO 4335)                      */
#define BLLI_L2_LLC                0x0C   /* LAN logical link control (ISO 8802/2)    */
#define BLLI_L2_X75                0x0D   /* CCITT Rec. X.75, single link procedure   */
#define BLLI_L2_Q922               0x0E   /* CCITT Rec. Q.922                         */
#define BLLI_L2_USER_SPECIFIED     0x10   /* User Specified                           */
#define BLLI_L2_ISO_7776           0x11   /* ISO 7776 DTE-DTE operation               */

/*
 *  values used for Layer3Protocol in B-LLI
 */
#define BLLI_L3_X25                0x06   /* CCITT Rec. X.25, packet layer            */
#define BLLI_L3_ISO_8208           0x07   /* ISO/IEC 8208 (X.25 packet layer for DTE  */
#define BLLI_L3_X223               0x08   /* X.223/ISO 8878                           */
#define BLLI_L3_SIO_8473           0x09   /* ISO/IEC 8473 (OSI connectionless)        */
#define BLLI_L3_T70                0x0A   /* CCITT Rec. T.70 min. network layer       */
#define BLLI_L3_ISO_TR9577         0x0B   /* ISO/IEC TR 9577 Network Layer Protocol ID*/
#define BLLI_L3_USER_SPECIFIED     0x10   /* User Specified                           */

/*
 *  values used for Layer3IPI in B-LLI
 */
#define BLLI_L3_IPI_SNAP           0x80   /* IEEE 802.1 SNAP identifier               */
#define BLLI_L3_IPI_IP             0xCC   /* Internet Protocol (IP) identifier        */

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI;

/*
 *  values used for the HighLayerInfoType field in ATM_BHLI
 */
#define BHLI_ISO                   0x00   /* ISO                                 */
#define BHLI_UserSpecific          0x01   /* User Specific                       */
#define BHLI_HighLayerProfile      0x02   /* High layer profile (only in UNI3.0) */
#define BHLI_VendorSpecificAppId   0x03   /* Vendor-Specific Application ID      */

typedef struct {
    DWORD HighLayerInfoType;          /* High Layer Information Type      */
    DWORD HighLayerInfoLength;        /* number of bytes in HighLayerInfo */
    UCHAR HighLayerInfo[8];           /* the value dependent on the       */
                                      /*   HighLayerInfoType field        */
} ATM_BHLI;

typedef struct sockaddr_atm {
    u_short satm_family;              /* address family should be AF_ATM  */
    ATM_ADDRESS satm_number;          /* ATM address                      */
    ATM_BLLI satm_blli;               /* B-LLI                            */
    ATM_BHLI satm_bhli;               /* B-HLI                            */
} sockaddr_atm, SOCKADDR_ATM, *PSOCKADDR_ATM, *LPSOCKADDR_ATM;

typedef enum {
    IE_AALParameters,
    IE_TrafficDescriptor,
    IE_BroadbandBearerCapability,
    IE_BHLI,
    IE_BLLI,
    IE_CalledPartyNumber,
    IE_CalledPartySubaddress,
    IE_CallingPartyNumber,
    IE_CallingPartySubaddress,
    IE_Cause,
    IE_QOSClass,
    IE_TransitNetworkSelection,
} Q2931_IE_TYPE;

typedef struct {
    Q2931_IE_TYPE IEType;
    ULONG         IELength;
    UCHAR         IE[1];
} Q2931_IE;

/*
 *  manifest constants for the AALType field in struct AAL_PARAMETERS_IE
 */
typedef enum {
    AALTYPE_5     = 5,   /* AAL 5 */
    AALTYPE_USER  = 16,  /* user-defined AAL */
} AAL_TYPE;

/*
 *  values used for the Mode field in struct AAL5_PARAMETERS
 */
#define AAL5_MODE_MESSAGE           0x01
#define AAL5_MODE_STREAMING         0x02

/*
 *  values used for the SSCSType field in struct AAL5_PARAMETERS
 */
#define AAL5_SSCS_NULL              0x00
#define AAL5_SSCS_SSCOP_ASSURED     0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED 0x02
#define AAL5_SSCS_FRAME_RELAY       0x04

typedef struct {
    ULONG ForwardMaxCPCSSDUSize;
    ULONG BackwardMaxCPCSSDUSize;
    UCHAR Mode;                        /* only available in UNI 3.0 */
    UCHAR SSCSType;
} AAL5_PARAMETERS;

typedef struct {
    ULONG UserDefined;
} AALUSER_PARAMETERS;

typedef struct {
    AAL_TYPE AALType;
    union {
        AAL5_PARAMETERS     AAL5Parameters;
        AALUSER_PARAMETERS  AALUserParameters;
    } AALSpecificParameters;
} AAL_PARAMETERS_IE;

typedef struct {
    ULONG PeakCellRate_CLP0;
    ULONG PeakCellRate_CLP01;
    ULONG SustainableCellRate_CLP0;
    ULONG SustainableCellRate_CLP01;
    ULONG MaxBurstSize_CLP0;
    ULONG MaxBurstSize_CLP01;
    BOOL  Tagging;
} ATM_TD;

typedef struct {
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL   BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE;

/*
 *  values used for the BearerClass field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define BCOB_A                   0x01   /* Bearer class A                      */
#define BCOB_C                   0x03   /* Bearer class C                      */
#define BCOB_X                   0x10   /* Bearer class X                      */

/*
 *  values used for the TrafficType field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TT_NOIND                 0x00   /* No indication of traffic type       */
#define TT_CBR                   0x04   /* Constant bit rate                   */
#define TT_VBR                   0x08   /* Variable bit rate                   */

/*
 *  values used for the TimingRequirements field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TR_NOIND                 0x00   /* No timing requirement indication    */
#define TR_END_TO_END            0x01   /* End-to-end timing required          */
#define TR_NO_END_TO_END         0x02   /* End-to-end timing not required      */

/*
 *  values used for the ClippingSusceptability field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define CLIP_NOT                 0x00   /* Not susceptible to clipping         */
#define CLIP_SUS                 0x20   /* Susceptible to clipping             */

/*
 *  values used for the UserPlaneConnectionConfig field in
 *  struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define UP_P2P                   0x00   /* Point-to-point connection           */
#define UP_P2MP                  0x01   /* Point-to-multipoint connection      */

typedef struct {
    UCHAR BearerClass;
    UCHAR TrafficType;
    UCHAR TimingRequirements;
    UCHAR ClippingSusceptability;
    UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef ATM_BHLI ATM_BHLI_IE;

/*
 *  values used for the Layer2Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L2_MODE_NORMAL         0x40
#define BLLI_L2_MODE_EXT            0x80

/*
 *  values used for the Layer3Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L3_MODE_NORMAL         0x40
#define BLLI_L3_MODE_EXT            0x80

/*
 *  values used for the Layer3DefaultPacketSize field in struct ATM_BLLI_IE
 */
#define BLLI_L3_PACKET_16           0x04
#define BLLI_L3_PACKET_32           0x05
#define BLLI_L3_PACKET_64           0x06
#define BLLI_L3_PACKET_128          0x07
#define BLLI_L3_PACKET_256          0x08
#define BLLI_L3_PACKET_512          0x09
#define BLLI_L3_PACKET_1024         0x0A
#define BLLI_L3_PACKET_2048         0x0B
#define BLLI_L3_PACKET_4096         0x0C

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    UCHAR Layer2Mode;
    UCHAR Layer2WindowSize;
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    UCHAR Layer3Mode;
    UCHAR Layer3DefaultPacketSize;
    UCHAR Layer3PacketWindowSize;
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Presentation_Indication field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define PI_ALLOWED                  0x00
#define PI_RESTRICTED               0x40
#define PI_NUMBER_NOT_AVAILABLE     0x80

/*
 *  values used for the Screening_Indicator field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define SI_USER_NOT_SCREENED        0x00
#define SI_USER_PASSED              0x01
#define SI_USER_FAILED              0x02
#define SI_NETWORK                  0x03

typedef struct {
    ATM_ADDRESS ATM_Number;
    UCHAR       Presentation_Indication;
    UCHAR       Screening_Indicator;
} ATM_CALLING_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Location field in struct ATM_CAUSE_IE
 */
#define CAUSE_LOC_USER                      0x00
#define CAUSE_LOC_PRIVATE_LOCAL             0x01
#define CAUSE_LOC_PUBLIC_LOCAL              0x02
#define CAUSE_LOC_TRANSIT_NETWORK           0x03
#define CAUSE_LOC_PUBLIC_REMOTE             0x04
#define CAUSE_LOC_PRIVATE_REMOTE            0x05
#define CAUSE_LOC_INTERNATIONAL_NETWORK     0x07
#define CAUSE_LOC_BEYOND_INTERWORKING       0x0A

/*
 *  values used for the Cause field in struct ATM_CAUSE_IE
 */
#define CAUSE_UNALLOCATED_NUMBER                0x01
#define CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK       0x02
#define CAUSE_NO_ROUTE_TO_DESTINATION           0x03
#define CAUSE_VPI_VCI_UNACCEPTABLE              0x0A
#define CAUSE_NORMAL_CALL_CLEARING              0x10
#define CAUSE_USER_BUSY                         0x11
#define CAUSE_NO_USER_RESPONDING                0x12
#define CAUSE_CALL_REJECTED                     0x15
#define CAUSE_NUMBER_CHANGED                    0x16
#define CAUSE_USER_REJECTS_CLIR                 0x17
#define CAUSE_DESTINATION_OUT_OF_ORDER          0x1B
#define CAUSE_INVALID_NUMBER_FORMAT             0x1C
#define CAUSE_STATUS_ENQUIRY_RESPONSE           0x1E
#define CAUSE_NORMAL_UNSPECIFIED                0x1F
#define CAUSE_VPI_VCI_UNAVAILABLE               0x23
#define CAUSE_NETWORK_OUT_OF_ORDER              0x26
#define CAUSE_TEMPORARY_FAILURE                 0x29
#define CAUSE_ACCESS_INFORMAION_DISCARDED       0x2B
#define CAUSE_NO_VPI_VCI_AVAILABLE              0x2D
#define CAUSE_RESOURCE_UNAVAILABLE              0x2F
#define CAUSE_QOS_UNAVAILABLE                   0x31
#define CAUSE_USER_CELL_RATE_UNAVAILABLE        0x33
#define CAUSE_BEARER_CAPABILITY_UNAUTHORIZED    0x39
#define CAUSE_BEARER_CAPABILITY_UNAVAILABLE     0x3A
#define CAUSE_OPTION_UNAVAILABLE                0x3F
#define CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED   0x41
#define CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS    0x49
#define CAUSE_INVALID_CALL_REFERENCE            0x51
#define CAUSE_CHANNEL_NONEXISTENT               0x52
#define CAUSE_INCOMPATIBLE_DESTINATION          0x58
#define CAUSE_INVALID_ENDPOINT_REFERENCE        0x59
#define CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define CAUSE_TOO_MANY_PENDING_ADD_PARTY        0x5C
#define CAUSE_AAL_PARAMETERS_UNSUPPORTED        0x5D
#define CAUSE_MANDATORY_IE_MISSING              0x60
#define CAUSE_UNIMPLEMENTED_MESSAGE_TYPE        0x61
#define CAUSE_UNIMPLEMENTED_IE                  0x63
#define CAUSE_INVALID_IE_CONTENTS               0x64
#define CAUSE_INVALID_STATE_FOR_MESSAGE         0x65
#define CAUSE_RECOVERY_ON_TIMEOUT               0x66
#define CAUSE_INCORRECT_MESSAGE_LENGTH          0x68
#define CAUSE_PROTOCOL_ERROR                    0x6F

/*
 *  values used for the Condition portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_COND_UNKNOWN                  0x00
#define CAUSE_COND_PERMANENT                0x01
#define CAUSE_COND_TRANSIENT                0x02

/*
 *  values used for the Rejection Reason portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_REASON_USER                   0x00
#define CAUSE_REASON_IE_MISSING             0x04
#define CAUSE_REASON_IE_INSUFFICIENT        0x08

/*
 *  values used for the P-U flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_PU_PROVIDER                   0x00
#define CAUSE_PU_USER                       0x08

/*
 *  values used for the N-A flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_NA_NORMAL                     0x00
#define CAUSE_NA_ABNORMAL                   0x04

typedef struct {
    UCHAR Location;
    UCHAR Cause;
    UCHAR DiagnosticsLength;
    UCHAR Diagnostics[4];
} ATM_CAUSE_IE;

/*
 *  values used for the QOSClassForward and QOSClassBackward
 *  field in struct ATM_QOS_CLASS_IE
 */
#define QOS_CLASS0                  0x00
#define QOS_CLASS1                  0x01
#define QOS_CLASS2                  0x02
#define QOS_CLASS3                  0x03
#define QOS_CLASS4                  0x04

typedef struct {
    UCHAR QOSClassForward;
    UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE;

/*
 *  values used for the TypeOfNetworkId field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_TYPE_NATIONAL           0x40

/*
 *  values used for the NetworkIdPlan field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_PLAN_CARRIER_ID_CODE    0x01

typedef struct {
    UCHAR TypeOfNetworkId;
    UCHAR NetworkIdPlan;
    UCHAR NetworkIdLength;
    UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE;

/*
 *  ATM specific Ioctl codes
 */
#define SIO_GET_NUMBER_OF_ATM_DEVICES   0x50160001
#define SIO_GET_ATM_ADDRESS             0xd0160002
#define SIO_ASSOCIATE_PVC               0x90160003
#define SIO_GET_ATM_CONNECTION_ID       0x50160004

/* ATM Connection Identifier */

typedef struct {
    DWORD  DeviceNumber;
    DWORD  VPI;
    DWORD  VCI;
} ATM_CONNECTION_ID;

/*
 * Input buffer format for SIO_ASSOCIATE_PVC
 */

typedef struct {
   ATM_CONNECTION_ID   PvcConnectionId;
   QOS                 PvcQos;
} ATM_PVC_PARAMS;

#include <poppack.h>

#endif   /* _WS2ATM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wshisotp.h ===
/* File: .streams.include.src/mod  wshisotp.h            Version: Initial */
/*
 *   wshisotp.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for ISO TP4.  This file contains all
 *   standardized ISO TP4 information.  Include this header file after
 *   winsock.h.
 *
 *   The information contained in this header file was originally
 *   created by Alcatel TITN Inc.
 */

#ifndef _WSHISOTP_
#define _WSHISOTP_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Protocol values for ISO transport protocols.
 */

#define ISOPROTO_TP0       25      /* connection orientated transport protocol */
#define ISOPROTO_TP1       26      /* not implemented */
#define ISOPROTO_TP2       27      /* not implemented */
#define ISOPROTO_TP3       28      /* not implemented */
#define ISOPROTO_TP4       29      /* connection orientated transport protocol */
#define ISOPROTO_TP        ISOPROTO_TP4
#define ISOPROTO_CLTP      30      /* connectionless transport */
#define ISOPROTO_CLNP      31      /* connectionless internetworking protocol */
#define ISOPROTO_X25       32      /* cons */
#define ISOPROTO_INACT_NL  33      /* inactive network layer */
#define ISOPROTO_ESIS      34      /* ES-IS protocol */
#define ISOPROTO_INTRAISIS 35      /* IS-IS protocol */

#define IPPROTO_RAW        255     /* raw clnp */
#define IPPROTO_MAX        256

/*
 *   The maximum size of the tranport address (tp_addr field of a
 *   sockaddr_tp structure) is 64.
 */

#define ISO_MAX_ADDR_LENGTH 64

/*
 *   There are two types of ISO addresses, hierarchical and
 *   non-hierarchical.  For hierarchical addresses, the tp_addr
 *   field contains both the transport selector and the network
 *   address.  For non-hierarchical addresses, tp_addr contains only
 *   the transport address, which must be translated by the ISO TP4
 *   transport provider into the transport selector and network address.
 */

#define ISO_HIERARCHICAL            0
#define ISO_NON_HIERARCHICAL        1

/*
 *   The format of the address structure (sockaddr) to pass to Windows
 *   Sockets APIs.
 *
 */

typedef struct sockaddr_tp {
   u_short tp_family;          /* Always AF_ISO */
   u_short tp_addr_type;       /* ISO_HIERARCHICAL or ISO_NON_HIERARCHICAL
*/
   u_short tp_taddr_len;       /* Length of transport address, <= 52 */
   u_short tp_tsel_len;        /* Length of transport selector, <= 32 */
                               /* 0 if ISO_NON_HIERARCHICAL */
   u_char tp_addr[ISO_MAX_ADDR_LENGTH];
} SOCKADDR_TP, *PSOCKADDR_TP, *LPSOCKADDR_TP;

#define ISO_SET_TP_ADDR(sa_tp, port, portlen, node, nodelen)              \
            (sa_tp)->tp_family = AF_ISO;                         \
            (sa_tp)->tp_addr_type = ISO_HIERARCHICAL;            \
            (sa_tp)->tp_tsel_len = (portlen);              \
            (sa_tp)->tp_taddr_len = (portlen) + (nodelen); \
            memcpy(&(sa_tp)->tp_addr, (port), (portlen)); \
            memcpy(&(sa_tp)->tp_addr[portlen], (node), (nodelen));


/*
 *   Expedited Data Usage Negotiation option.
 *   Default when the option is not present is be EXP_DATA_USE
 *   as per ISO 8073
 */

#define ISO_EXP_DATA_USE  00    /* Use of Expedited Data */
#define ISO_EXP_DATA_NUSE 01    /* Non-use of Expedited Data */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ws2bth.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

        ws2bth.h

Abstract:

        Winsock 2 Bluetooth Annex definitions.
        
Notes:

        Change BT_* to BTH_*        

--*/

#ifndef __WS2BTH__H
#define __WS2BTH__H

#include <bthdef.h>

#include <pshpack1.h>

#define BT_PORT_ANY        -1
#define BT_PORT_MIN        0x1
#define BT_PORT_MAX        0xffff
#define BT_PORT_DYN_FIRST  0x1001

//
// These three definitions are duplicated in winsock2.h to reserve ordinals
//
#ifndef AF_BTH
#define AF_BTH  32
#endif
#ifndef PF_BTH
#define PF_BTH  AF_BTH
#endif
#ifndef NS_BTH
#define NS_BTH  16
#endif

typedef struct _SOCKADDR_BTH
{
    USHORT      addressFamily;  // Always AF_BTH
    BTH_ADDR    btAddr;         // Bluetooth device address
    GUID        serviceClassId; // [OPTIONAL] system will query SDP for port
    ULONG       port;           // RFCOMM channel or L2CAP PSM
} SOCKADDR_BTH, *PSOCKADDR_BTH;


DEFINE_GUID(SVCID_BTH_PROVIDER, 0x6aa63e0, 0x7d60, 0x41ff, 0xaf, 0xb2, 0x3e, 0xe6, 0xd2, 0xd9, 0x39, 0x2d);
#define BTH_ADDR_STRING_SIZE        12  // max size from WSAAddressToString

//
// Bluetooth protocol #s are assigned according to the Bluetooth
// Assigned Numbers portion of the Bluetooth Specification
//
#define BTHPROTO_RFCOMM  0x0003
#define BTHPROTO_L2CAP   0x0100

#define SOL_RFCOMM  BTHPROTO_RFCOMM
#define SOL_L2CAP   BTHPROTO_L2CAP
#define SOL_SDP     0x0101

//
// SOCKET OPTIONS
//
#define SO_BTH_AUTHENTICATE 0x80000001  // optlen=sizeof(ULONG), optval = &(ULONG)TRUE/FALSE 
#define SO_BTH_ENCRYPT      0x00000002  // optlen=sizeof(ULONG), optval = &(ULONG)TRUE/FALSE
#define SO_BTH_MTU          0x80000007  // optlen=sizeof(ULONG), optval = &mtu
#define SO_BTH_MTU_MAX      0x80000008  // optlen=sizeof(ULONG), optval = &max. mtu
#define SO_BTH_MTU_MIN      0x8000000a  // optlen=sizeof(ULONG), optval = &min. mtu

//
// Socket option parameters
//
#define RFCOMM_MAX_MTU      0x0000029a  // L2CAP MTU (672) - RFCOMM header size (6)
#define RFCOMM_MIN_MTU      0x00000017  // RFCOMM spec sec 5.3 table 5.1

//
// NAME SERVICE PROVIDER DEFINITIONS
// For calling WSASetService
// and WSALookupServiceBegin, WSALookupServiceNext, WSALookupServiceEnd
// with Bluetooth-specific extensions
//
#define BTH_SDP_VERSION         1

//
// [OPTIONAL] passed in BLOB member of WSAQUERYSET
// QUERYSET and its lpBlob member are copied & converted
// to unicode in the system for non-unicode applications.  
// However, nothing is copied back upon return.  In 
// order for the system to return data such as pRecordHandle, 
// it much have an extra level of indirection from lpBlob 
//
typedef struct _BTH_SET_SERVICE {

        //
        // This version number will change when/if the binary format of
        // SDP records change, affecting the format of pRecord.
        // Set to BTH_SDP_VERSION by client, and returned by system
        //
        PULONG pSdpVersion;

        //
        // Handle to SDP record.  When BTH_SET_SERVICE structure is later 
        // passed to WSASetService RNRSERVICE_DELETE, this handle identifies the
        // record to delete.
        //
        HANDLE *pRecordHandle;
                        
        // 
        // COD_SERVICE_* bit(s) associated with this SDP record, which will be
        // advertised when the local radio is found during device inquiry.
        // When the last SDP record associated with a bit is deleted, that
        // service bit is no longer reported in repsonse to inquiries 
        //
        ULONG fCodService;    // COD_SERVICE_* bits

        ULONG Reserved[5];    // Reserved by system.  Must be zero.                
        ULONG ulRecordLength; // length of pRecord which follows
        UCHAR pRecord[1];     // SDP record as defined by bluetooth spec
        
} BTH_SET_SERVICE, *PBTH_SET_SERVICE;

//
// Default device inquiry duration in seconds
//
// The application thread will be blocked in WSALookupServiceBegin
// for the duration of the device inquiry, so this value needs to
// be balanced against the chance that a device that is actually
// present might not being found by Bluetooth in this time
//
// Paging improvements post-1.1 will cause devices to be 
// found generally uniformly in the 0-6 sec timeperiod
//
#define SDP_DEFAULT_INQUIRY_SECONDS         6
#define SDP_MAX_INQUIRY_SECONDS             60

//
// Default maximum number of devices to search for
//
#define SDP_DEFAULT_INQUIRY_MAX_RESPONSES   255

#define SDP_SERVICE_SEARCH_REQUEST           1
#define SDP_SERVICE_ATTRIBUTE_REQUEST        2
#define SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST 3

//
// [OPTIONAL] input restrictions on device inquiry
// Passed in BLOB of LUP_CONTAINERS (device) search
//
typedef struct _BTH_QUERY_DEVICE {
    ULONG   LAP;                    // reserved: must be 0 (GIAC inquiry only)
    UCHAR   length;                 // requested length of inquiry (seconds)       
} BTH_QUERY_DEVICE, *PBTH_QUERY_DEVICE;

//
// [OPTIONAL] Restrictions on searching for a particular service
// Passed in BLOB of !LUP_CONTAINERS (service) search
//
typedef struct _BTH_QUERY_SERVICE {
	ULONG                   type;           // one of SDP_SERVICE_*
	ULONG                   serviceHandle;
	SdpQueryUuid            uuids[MAX_UUIDS_IN_QUERY];
	ULONG                   numRange;
	SdpAttributeRange       pRange[1];
} BTH_QUERY_SERVICE, *PBTH_QUERY_SERVICE;

//
// BTHNS_RESULT_*
//
// Bluetooth specific flags returned from WSALookupServiceNext 
// in WSAQUERYSET.dwOutputFlags in response to device inquiry
//

//
// Local device is paired with remote device
//
#define BTHNS_RESULT_DEVICE_CONNECTED      0x00010000
#define BTHNS_RESULT_DEVICE_REMEMBERED     0x00020000
#define BTHNS_RESULT_DEVICE_AUTHENTICATED  0x00040000

//
// SOCKET IOCTLs
//

#define SIO_RFCOMM_SEND_COMMAND        _WSAIORW (IOC_VENDOR, 101)
#define SIO_RFCOMM_WAIT_COMMAND        _WSAIORW (IOC_VENDOR, 102)

//
// These IOCTLs are for test/validation/conformance and may only be
// present in debug/checked builds of the system
//
#define SIO_BTH_PING                      _WSAIORW (IOC_VENDOR, 8)
#define SIO_BTH_INFO                      _WSAIORW (IOC_VENDOR, 9)
#define SIO_RFCOMM_SESSION_FLOW_OFF       _WSAIORW (IOC_VENDOR, 103)
#define SIO_RFCOMM_TEST                   _WSAIORW (IOC_VENDOR, 104)
#define SIO_RFCOMM_USECFC                 _WSAIORW (IOC_VENDOR, 105)

//
// SOCKET IOCTL DEFINITIONS
//

#ifndef BIT
#define BIT(b)   (1<<(b))
#endif

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.7
//
typedef struct _RFCOMM_MSC_DATA {
    UCHAR       Signals;

        #define MSC_EA_BIT      EA_BIT
        #define MSC_FC_BIT      BIT(1)      // Flow control, clear if we can receive
        #define MSC_RTC_BIT     BIT(2)      // Ready to communicate, set when ready
        #define MSC_RTR_BIT     BIT(3)      // Ready to receive, set when ready
        #define MSC_RESERVED (BIT(4)|BIT(5))// Reserved by spec, must be 0
        #define MSC_IC_BIT      BIT(6)      // Incoming call
        #define MSC_DV_BIT      BIT(7)      // Data valid

    UCHAR       Break;

        #define MSC_BREAK_BIT   BIT(1)      // Set if sending break
        #define MSC_SET_BREAK_LENGTH(b, l)  ((b) = ((b)&0x3) | (((l)&0xf) << 4))

} RFCOMM_MSC_DATA, *PRFCOMM_MSC_DATA;

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.10
//
typedef struct _RFCOMM_RLS_DATA {

    UCHAR       LineStatus;

        #define RLS_ERROR           0x01
        #define RLS_OVERRUN         0x02
        #define RLS_PARITY          0x04
        #define RLS_FRAMING         0x08

} RFCOMM_RLS_DATA, *PRFCOMM_RLS_DATA;

//
// Structure definition from Bluetooth RFCOMM spec, TS 07.10 5.4.6.3.9
//
typedef struct _RFCOMM_RPN_DATA {
    UCHAR       Baud;

        #define RPN_BAUD_2400       0
        #define RPN_BAUD_4800       1
        #define RPN_BAUD_7200       2
        #define RPN_BAUD_9600       3
        #define RPN_BAUD_19200      4
        #define RPN_BAUD_38400      5
        #define RPN_BAUD_57600      6
        #define RPN_BAUD_115200     7
        #define RPN_BAUD_230400     8

    UCHAR       Data;

        #define RPN_DATA_5          0x0
        #define RPN_DATA_6          0x1
        #define RPN_DATA_7          0x2
        #define RPN_DATA_8          0x3

        #define RPN_STOP_1          0x0
        #define RPN_STOP_1_5        0x4

        #define RPN_PARITY_NONE     0x00
        #define RPN_PARITY_ODD      0x08
        #define RPN_PARITY_EVEN     0x18
        #define RPN_PARITY_MARK     0x28
        #define RPN_PARITY_SPACE    0x38

    UCHAR       FlowControl;

        #define RPN_FLOW_X_IN       0x01
        #define RPN_FLOW_X_OUT      0x02
        #define RPN_FLOW_RTR_IN     0x04
        #define RPN_FLOW_RTR_OUT    0x08
        #define RPN_FLOW_RTC_IN     0x10
        #define RPN_FLOW_RTC_OUT    0x20

    UCHAR       XonChar;
    UCHAR       XoffChar;
    UCHAR       ParameterMask1;

        #define RPN_PARAM_BAUD      0x01
        #define RPN_PARAM_DATA      0x02
        #define RPN_PARAM_STOP      0x04
        #define RPN_PARAM_PARITY    0x08
        #define RPN_PARAM_P_TYPE    0x10
        #define RPN_PARAM_XON       0x20
        #define RPN_PARAM_XOFF      0x40

    UCHAR       ParameterMask2;

        #define RPN_PARAM_X_IN      0x01
        #define RPN_PARAM_X_OUT     0x02
        #define RPN_PARAM_RTR_IN    0x04
        #define RPN_PARAM_RTR_OUT   0x08
        #define RPN_PARAM_RTC_IN    0x10
        #define RPN_PARAM_RTC_OUT   0x20

} RFCOMM_RPN_DATA, *PRFCOMM_RPN_DATA;

#define RFCOMM_CMD_NONE             0
#define RFCOMM_CMD_MSC              1
#define RFCOMM_CMD_RLS              2
#define RFCOMM_CMD_RPN              3
#define RFCOMM_CMD_RPN_REQUEST      4
#define RFCOMM_CMD_RPN_RESPONSE     5

typedef struct _RFCOMM_COMMAND
{
    ULONG       CmdType;          // one of RFCOMM_CMD_*
    union
    {
        RFCOMM_MSC_DATA    MSC;
        RFCOMM_RLS_DATA    RLS;
        RFCOMM_RPN_DATA    RPN;
    } Data;
} RFCOMM_COMMAND, *PRFCOMM_COMMAND;

//
// These structures are for test/validation/conformance and may only be
// present in debug/checked builds of the system
//
typedef struct _BTH_PING_REQ {
    BTH_ADDR  btAddr;
    UCHAR    dataLen;
    UCHAR    data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_REQ, *PBTH_PING_REQ;

typedef struct _BTH_PING_RSP {
    UCHAR    dataLen;
    UCHAR    data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_RSP, *PBTH_PING_RSP;

typedef struct _BTH_INFO_REQ {
    BTH_ADDR  btAddr;
    USHORT   infoType;
} BTH_INFO_REQ, *PBTH_INFO_REQ;

typedef struct _BTH_INFO_RSP {
    USHORT  result;
    UCHAR   dataLen;
    union {
        USHORT  connectionlessMTU;
        UCHAR   data[MAX_L2CAP_INFO_DATA_LENGTH];
    };
} BTH_INFO_RSP, *PBTH_INFO_RSP;

//
// WinCE compatible struct names
//
typedef struct _BTH_SET_SERVICE BTHNS_SETBLOB, *PBTHNS_SETBLOB;
typedef struct _BTH_QUERY_DEVICE BTHNS_INQUIRYBLOB, *PBTHNS_INQUIRYBLOB;
typedef struct _BTH_QUERY_SERVICE BTHNS_RESTRICTIONBLOB, *PBTHNS_RESTRICTIONBLOB;

#include <poppack.h>

#endif // __WS2BTH__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\ws2tcpip.h ===
/*
**  WS2TCPIP.H - WinSock2 Extension for TCP/IP protocols
**
**  This file contains TCP/IP specific information for use
**  by WinSock2 compatible applications.
**
** Copyright (c) Microsoft Corporation. All rights reserved.
**
**  To provide the backward compatibility, all the TCP/IP
**  specific definitions that were included in the WINSOCK.H
**   file are now included in WINSOCK2.H file. WS2TCPIP.H
**  file includes only the definitions  introduced in the
**  "WinSock 2 Protocol-Specific Annex" document.
**
**  Rev 0.3 Nov 13, 1995
**      Rev 0.4 Dec 15, 1996
*/

#ifndef _WS2TCPIP_H_
#define _WS2TCPIP_H_

#if _MSC_VER > 1000
#pragma once
#endif

/* Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP */

struct ip_mreq {
    struct in_addr imr_multiaddr;   /* IP multicast address of group */
    struct in_addr imr_interface;   /* local IP address of interface */
};

/* Argument structure for IP_ADD_SOURCE_MEMBERSHIP, IP_DROP_SOURCE_MEMBERSHIP,
 * IP_BLOCK_SOURCE, and IP_UNBLOCK_SOURCE
 */

struct ip_mreq_source {
    struct in_addr imr_multiaddr;   /* IP multicast address of group */
    struct in_addr imr_sourceaddr;  /* IP address of source          */
    struct in_addr imr_interface;   /* local IP address of interface */
};

/* Argument structure for SIO_{GET,SET}_MULTICAST_FILTER */

struct ip_msfilter {
    struct in_addr imsf_multiaddr;  /* IP multicast address of group */
    struct in_addr imsf_interface;  /* local IP address of interface */
    u_long         imsf_fmode;      /* filter mode - INCLUDE or EXCLUDE */
    u_long         imsf_numsrc;     /* number of sources in src_list */
    struct in_addr imsf_slist[1];
};

#define IP_MSFILTER_SIZE(numsrc) \
    (sizeof(struct ip_msfilter)-sizeof(struct in_addr) + (numsrc)*sizeof(struct in_addr))

#define MCAST_INCLUDE 0
#define MCAST_EXCLUDE 1

/* TCP/IP specific Ioctl codes */

#define SIO_GET_INTERFACE_LIST  _IOR('t', 127, u_long)
/* New IOCTL with address size independent address array */
#define SIO_GET_INTERFACE_LIST_EX  _IOR('t', 126, u_long)
#define SIO_SET_MULTICAST_FILTER   _IOW('t', 125, u_long)
#define SIO_GET_MULTICAST_FILTER   _IOW('t', 124 | IOC_IN, u_long)

/* Option to use with [gs]etsockopt at the IPPROTO_IP level */

#define IP_OPTIONS      1 /* set/get IP options */
#define IP_HDRINCL      2 /* header is included with data */
#define IP_TOS          3 /* IP type of service and preced*/
#define IP_TTL          4 /* IP time to live */
#define IP_MULTICAST_IF     9 /* set/get IP multicast i/f  */
#define IP_MULTICAST_TTL       10 /* set/get IP multicast ttl */
#define IP_MULTICAST_LOOP      11 /*set/get IP multicast loopback */
#define IP_ADD_MEMBERSHIP      12 /* add an IP group membership */
#define IP_DROP_MEMBERSHIP     13/* drop an IP group membership */
#define IP_DONTFRAGMENT     14 /* don't fragment IP datagrams */
#define IP_ADD_SOURCE_MEMBERSHIP  15 /* join IP group/source */
#define IP_DROP_SOURCE_MEMBERSHIP 16 /* leave IP group/source */
#define IP_BLOCK_SOURCE           17 /* block IP group/source */
#define IP_UNBLOCK_SOURCE         18 /* unblock IP group/source */
#define IP_PKTINFO                19 /* receive packet information for ipv4*/
#define IP_RECEIVE_BROADCAST      22 /* allow/block broadcast reception */

/* Option to use with [gs]etsockopt at the IPPROTO_IPV6 level */

#define IPV6_HDRINCL            2  /* Header is included with data */
#define IPV6_UNICAST_HOPS       4  /* Set/get IP unicast hop limit */
#define IPV6_MULTICAST_IF       9  /* Set/get IP multicast interface */
#define IPV6_MULTICAST_HOPS     10 /* Set/get IP multicast ttl */
#define IPV6_MULTICAST_LOOP     11 /* Set/get IP multicast loopback */
#define IPV6_ADD_MEMBERSHIP     12 /* Add an IP group membership */
#define IPV6_DROP_MEMBERSHIP    13 /* Drop an IP group membership */
#define IPV6_JOIN_GROUP         IPV6_ADD_MEMBERSHIP
#define IPV6_LEAVE_GROUP        IPV6_DROP_MEMBERSHIP
#define IPV6_PKTINFO            19 /* Receive packet information for ipv6 */
#define IPV6_HOPLIMIT           21 /* Receive packet hop limit */
#define IPV6_PROTECTION_LEVEL   23 /* Set/get IPv6 protection level */

/* Values of IPV6_PROTECTION_LEVEL */

#define PROTECTION_LEVEL_UNRESTRICTED  10  /* For peer-to-peer apps */
#define PROTECTION_LEVEL_DEFAULT       20  /* Default level         */
#define PROTECTION_LEVEL_RESTRICTED    30  /* For Intranet apps     */

/* Option to use with [gs]etsockopt at the IPPROTO_UDP level */

#define UDP_NOCHECKSUM  1
#define UDP_CHECKSUM_COVERAGE   20  /* Set/get UDP-Lite checksum coverage */

/* Option to use with [gs]etsockopt at the IPPROTO_TCP level */

#define  TCP_EXPEDITED_1122 0x0002


/* IPv6 definitions */

#ifndef s6_addr

struct in6_addr {
    union {
        u_char Byte[16];
        u_short Word[8];
    } u;
};

#define in_addr6 in6_addr

/*
** Defines to match RFC 2553.
*/
#define _S6_un     u
#define _S6_u8     Byte
#define s6_addr    _S6_un._S6_u8

/*
** Defines for our implementation.
*/
#define s6_bytes   u.Byte
#define s6_words   u.Word

#endif

/* Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP */

typedef struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;  /* IPv6 multicast address */
    unsigned int    ipv6mr_interface;  /* Interface index */
} IPV6_MREQ;


/* Old IPv6 socket address structure (retained for sockaddr_gen definition below) */

struct sockaddr_in6_old {
    short   sin6_family;        /* AF_INET6 */
    u_short sin6_port;          /* Transport level port number */
    u_long  sin6_flowinfo;      /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
};

/* IPv6 socket address structure, RFC 2553 */

struct sockaddr_in6 {
    short   sin6_family;        /* AF_INET6 */
    u_short sin6_port;          /* Transport level port number */
    u_long  sin6_flowinfo;      /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
    u_long sin6_scope_id;       /* set of interfaces for a scope */
};


typedef struct in6_addr IN6_ADDR;
typedef struct in6_addr *PIN6_ADDR;
typedef struct in6_addr FAR *LPIN6_ADDR;

typedef struct sockaddr_in6 SOCKADDR_IN6;
typedef struct sockaddr_in6 *PSOCKADDR_IN6;
typedef struct sockaddr_in6 FAR *LPSOCKADDR_IN6;

/* Macro that works for both IPv4 and IPv6 */
#define SS_PORT(ssp) (((struct sockaddr_in*)(ssp))->sin_port)

#define IN6ADDR_ANY_INIT        { 0 }
#define IN6ADDR_LOOPBACK_INIT   { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }

#ifdef  __cplusplus
extern "C" {
#endif

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;

#ifdef  __cplusplus
}
#endif

#ifdef _MSC_VER
#define WS2TCPIP_INLINE __inline
#else
#define WS2TCPIP_INLINE extern inline /* GNU style */
#endif

WS2TCPIP_INLINE int
IN6_ADDR_EQUAL(const struct in6_addr *a, const struct in6_addr *b)
{
    return (memcmp(a, b, sizeof(struct in6_addr)) == 0);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *a)
{
    return ((a->s6_words[0] == 0) &&
            (a->s6_words[1] == 0) &&
            (a->s6_words[2] == 0) &&
            (a->s6_words[3] == 0) &&
            (a->s6_words[4] == 0) &&
            (a->s6_words[5] == 0) &&
            (a->s6_words[6] == 0) &&
            (a->s6_words[7] == 0));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_LOOPBACK(const struct in6_addr *a)
{
    return ((a->s6_words[0] == 0) &&
            (a->s6_words[1] == 0) &&
            (a->s6_words[2] == 0) &&
            (a->s6_words[3] == 0) &&
            (a->s6_words[4] == 0) &&
            (a->s6_words[5] == 0) &&
            (a->s6_words[6] == 0) &&
            (a->s6_words[7] == 0x0100));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MULTICAST(const struct in6_addr *a)
{
    return (a->s6_bytes[0] == 0xff);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *a)
{
    return ((a->s6_bytes[0] == 0xfe) &&
            ((a->s6_bytes[1] & 0xc0) == 0x80));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_SITELOCAL(const struct in6_addr *a)
{
    return ((a->s6_bytes[0] == 0xfe) &&
            ((a->s6_bytes[1] & 0xc0) == 0xc0));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_V4MAPPED(const struct in6_addr *a)
{
    return ((a->s6_words[0] == 0) &&
            (a->s6_words[1] == 0) &&
            (a->s6_words[2] == 0) &&
            (a->s6_words[3] == 0) &&
            (a->s6_words[4] == 0) &&
            (a->s6_words[5] == 0xffff));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_V4COMPAT(const struct in6_addr *a)
{
    return ((a->s6_words[0] == 0) &&
            (a->s6_words[1] == 0) &&
            (a->s6_words[2] == 0) &&
            (a->s6_words[3] == 0) &&
            (a->s6_words[4] == 0) &&
            (a->s6_words[5] == 0) &&
            !((a->s6_words[6] == 0) &&
              (a->s6_addr[14] == 0) &&
             ((a->s6_addr[15] == 0) || (a->s6_addr[15] == 1))));
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *a)
{
    return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf) == 1);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *a)
{
    return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf) == 2);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *a)
{
    return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf) == 5);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *a)
{
    return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf) == 8);
}

WS2TCPIP_INLINE int
IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *a)
{
    return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf) == 0xe);
}

WS2TCPIP_INLINE int
IN6ADDR_ISANY(const struct sockaddr_in6 *a)
{
    return ((a->sin6_family == AF_INET6) &&
            IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr));
}

WS2TCPIP_INLINE int
IN6ADDR_ISLOOPBACK(const struct sockaddr_in6 *a)
{
    return ((a->sin6_family == AF_INET6) &&
            IN6_IS_ADDR_LOOPBACK(&a->sin6_addr));
}

WS2TCPIP_INLINE void
IN6_SET_ADDR_UNSPECIFIED(struct in6_addr *a)
{
    memset(a->s6_bytes, 0, sizeof(struct in6_addr));
}

WS2TCPIP_INLINE void
IN6_SET_ADDR_LOOPBACK(struct in6_addr *a)
{
    memset(a->s6_bytes, 0, sizeof(struct in6_addr));
    a->s6_bytes[15] = 1;
}

WS2TCPIP_INLINE void
IN6ADDR_SETANY(struct sockaddr_in6 *a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

WS2TCPIP_INLINE void
IN6ADDR_SETLOOPBACK(struct sockaddr_in6 *a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

typedef union sockaddr_gen{
        struct sockaddr Address;
        struct sockaddr_in  AddressIn;
        struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

/* Structure to keep interface specific information */

typedef struct _INTERFACE_INFO
{
    u_long      iiFlags;        /* Interface flags */
    sockaddr_gen    iiAddress;      /* Interface address */
    sockaddr_gen    iiBroadcastAddress;     /* Broadcast address */
    sockaddr_gen    iiNetmask;      /* Network mask */
} INTERFACE_INFO, FAR * LPINTERFACE_INFO;

/* New structure that does not have dependency on the address size */
typedef struct _INTERFACE_INFO_EX
{
    u_long      iiFlags;        /* Interface flags */
    SOCKET_ADDRESS  iiAddress;          /* Interface address */
    SOCKET_ADDRESS  iiBroadcastAddress; /* Broadcast address */
    SOCKET_ADDRESS  iiNetmask;          /* Network mask */
} INTERFACE_INFO_EX, FAR * LPINTERFACE_INFO_EX;

/* Possible flags for the  iiFlags - bitmask  */

#define IFF_UP      0x00000001 /* Interface is up */
#define IFF_BROADCAST   0x00000002 /* Broadcast is  supported */
#define IFF_LOOPBACK    0x00000004 /* this is loopback interface */
#define IFF_POINTTOPOINT 0x00000008 /*this is point-to-point interface*/
#define IFF_MULTICAST   0x00000010 /* multicast is supported */


// structure for IP_PKTINFO option
//
typedef struct in_pktinfo {
    IN_ADDR ipi_addr; // destination IPv4 address
    UINT    ipi_ifindex; // received interface index
} IN_PKTINFO;

C_ASSERT(sizeof(IN_PKTINFO) == 8);

// structure for IPV6_PKTINFO option
//
typedef struct in6_pktinfo {
    IN6_ADDR ipi6_addr; // destination IPv6 address
    UINT     ipi6_ifindex; // received interface index
} IN6_PKTINFO;

C_ASSERT(sizeof(IN6_PKTINFO) == 20);

/* Error codes from getaddrinfo() */

#define EAI_AGAIN       WSATRY_AGAIN
#define EAI_BADFLAGS    WSAEINVAL
#define EAI_FAIL        WSANO_RECOVERY
#define EAI_FAMILY      WSAEAFNOSUPPORT
#define EAI_MEMORY      WSA_NOT_ENOUGH_MEMORY
//#define EAI_NODATA      WSANO_DATA
#define EAI_NONAME      WSAHOST_NOT_FOUND
#define EAI_SERVICE     WSATYPE_NOT_FOUND
#define EAI_SOCKTYPE    WSAESOCKTNOSUPPORT

//
//  DCR_FIX:  EAI_NODATA remove or fix
//
//  EAI_NODATA was removed from rfc2553bis
//  need to find out from the authors why and
//  determine the error for "no records of this type"
//  temporarily, we'll keep #define to avoid changing
//  code that could change back;  use NONAME
//

#define EAI_NODATA      EAI_NONAME


/* Structure used in getaddrinfo() call */

typedef struct addrinfo
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char *              ai_canonname;   // Canonical name for nodename
    struct sockaddr *   ai_addr;        // Binary address
    struct addrinfo *   ai_next;        // Next structure in linked list
}
ADDRINFOA, *PADDRINFOA;

typedef struct addrinfoW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    struct sockaddr *   ai_addr;        // Binary address
    struct addrinfoW *  ai_next;        // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;

//  Switchable definition for GetAddrInfo()

#ifdef UNICODE
typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
#else
typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
#endif

//  RFC standard definition for getaddrinfo()

typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;



/* Flags used in "hints" argument to getaddrinfo() */

#define AI_PASSIVE     0x1  /* Socket address will be used in bind() call */
#define AI_CANONNAME   0x2  /* Return canonical name in first ai_canonname */
#define AI_NUMERICHOST 0x4  /* Nodename must be a numeric address string */

#ifdef __cplusplus
extern "C" {
#endif

WINSOCK_API_LINKAGE
int
WSAAPI
getaddrinfo(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
int
WSAAPI
GetAddrInfoW(
    IN      PCWSTR              pNodeName,
    IN      PCWSTR              pServiceName,
    IN      const ADDRINFOW *   pHints,
    OUT     PADDRINFOW *        ppResult
    );

#define GetAddrInfoA    getaddrinfo

#ifdef UNICODE
#define GetAddrInfo     GetAddrInfoW
#else
#define GetAddrInfo     GetAddrInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETADDRINFO)(
    IN  const char FAR * nodename,
    IN  const char FAR * servname,
    IN  const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

typedef
int
(WSAAPI * LPFN_GETADDRINFOW)(
    IN      PCWSTR              pNodeName,
    IN      PCWSTR              pServiceName,
    IN      const ADDRINFOW *   pHints,
    OUT     PADDRINFOW *        ppResult
    );

#define LPFN_GETADDRINFOA      LPFN_GETADDRINFO

#ifdef UNICODE
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
#else
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
#endif
#endif


WINSOCK_API_LINKAGE
void
WSAAPI
freeaddrinfo(
    IN  LPADDRINFO      pAddrInfo
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
void
WSAAPI
FreeAddrInfoW(
    IN  PADDRINFOW      pAddrInfo
    );

#define FreeAddrInfoA   freeaddrinfo

#ifdef UNICODE
#define FreeAddrInfo    FreeAddrInfoW
#else
#define FreeAddrInfo    FreeAddrInfoA
#endif
#endif


#if INCL_WINSOCK_API_TYPEDEFS
typedef
void
(WSAAPI * LPFN_FREEADDRINFO)(
    IN struct addrinfo FAR * ai
    );
typedef
void
(WSAAPI * LPFN_FREEADDRINFOW)(
    IN  PADDRINFOW * pAddrInfo
    );

#define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO

#ifdef UNICODE
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
#else
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
#endif
#endif


typedef int socklen_t;

WINSOCK_API_LINKAGE
int
WSAAPI
getnameinfo(
    IN  const struct sockaddr FAR * sa,
    IN  socklen_t       salen,
    OUT char FAR *      host,
    IN  DWORD           hostlen,
    OUT char FAR *      serv,
    IN  DWORD           servlen,
    IN  int             flags
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
INT
WSAAPI
GetNameInfoW(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PWCHAR              pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PWCHAR              pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    );

#define GetNameInfoA    getnameinfo

#ifdef UNICODE
#define GetNameInfo     GetNameInfoW
#else
#define GetNameInfo     GetNameInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETNAMEINFO)(
    IN  const struct sockaddr FAR * sa,
    IN  socklen_t       salen,
    OUT char FAR *      host,
    IN  DWORD           hostlen,
    OUT char FAR *      serv,
    IN  DWORD           servlen,
    IN  int             flags
    );

typedef
INT
(WSAAPI * LPFN_GETNAMEINFOW)(
    IN      const SOCKADDR *    pSockaddr,
    IN      socklen_t           SockaddrLength,
    OUT     PWCHAR              pNodeBuffer,
    IN      DWORD               NodeBufferSize,
    OUT     PWCHAR              pServiceBuffer,
    IN      DWORD               ServiceBufferSize,
    IN      INT                 Flags
    );

#define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO

#ifdef UNICODE
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
#else
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
#endif
#endif



#if INCL_WINSOCK_API_PROTOTYPES
#ifdef UNICODE
#define gai_strerror   gai_strerrorW
#else
#define gai_strerror   gai_strerrorA
#endif  /* UNICODE */

// WARNING: The gai_strerror inline functions below use static buffers,
// and hence are not thread-safe.  We'll use buffers long enough to hold
// 1k characters.  Any system error messages longer than this will be
// returned as empty strings.  However 1k should work for the error codes
// used by getaddrinfo().
#define GAI_STRERROR_BUFFER_SIZE 1024

WS2TCPIP_INLINE
char *
gai_strerrorA(
    IN int ecode)
{
    DWORD dwMsgLen;
    static char buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}

WS2TCPIP_INLINE
WCHAR *
gai_strerrorW(
    IN int ecode
    )
{
    DWORD dwMsgLen;
    static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPWSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}
#endif /* INCL_WINSOCK_API_PROTOTYPES */




#define NI_MAXHOST  1025  /* Max size of a fully-qualified domain name */
#define NI_MAXSERV    32  /* Max size of a service name */

//
// Maximum length of address literals (potentially including a port number)
// generated by any address-to-string conversion routine.  This length can 
// be used when declaring buffers used with getnameinfo, WSAAddressToString, 
// inet_ntoa, etc.  We just provide one define, rather than one per api, 
// to avoid confusion.
//
// The totals are derived from the following data:
//  15: IPv4 address
//  45: IPv6 address including embedded IPv4 address
//  11: Scope Id
//   2: Brackets around IPv6 address when port is present
//   6: Port (including colon)
//   1: Terminating null byte
//
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65

/* Flags for getnameinfo() */

#define NI_NOFQDN       0x01  /* Only return nodename portion for local hosts */
#define NI_NUMERICHOST  0x02  /* Return numeric form of the host's address */
#define NI_NAMEREQD     0x04  /* Error if the host's name not in DNS */
#define NI_NUMERICSERV  0x08  /* Return numeric form of the service (port #) */
#define NI_DGRAM        0x10  /* Service is a datagram service */

#ifdef __cplusplus
}
#endif

//
// Unless the build environment is explicitly targeting only
// platforms that include built-in getaddrinfo() support, include
// the backwards-compatibility version of the relevant APIs.
//
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT <= 0x0500)
#include <wspiapi.h>
#endif

#endif  /* _WS2TCPIP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wnapidec.inc ===
' ------------------------------------------------------------------------
'     WNAPIDEC.INC -- Windows 3.0 API Declarations for 32-bit FastTest
'
'              Copyright (C) 1991-1992 Microsoft Corporation
'
'  The following are provided for sample purposes only.  You should only
'  copy the ones you use into your code in order to save code space and
'  parse time.
'
'  You have a royalty-free right to use, modify, reproduce and distribute
'  this file (and/or any modified version) in any way you find useful,
'  provided that you agree Microsoft has no warranty, obligation or
'  liability for its contents.  Refer to the Microsoft Windows Programmer's
'  Reference for further information.
'
' ------------------------------------------------------------------------
'$define _WNAPIDEC          ' Define this so other includes don't redefine
                            ' stuff defined in this include file

'$ifndef _WINUSER

' Definitions stolen from WINUSER.INC
'-----------------------------------------------------------------------------
Type RECT
    wleft As Integer
    top As Integer
    wright As Integer
    bottom As Integer
End Type

Type POINT
    x As Integer
    y As Integer
End Type

Declare Function FindWindow          Lib "User32" ALIAS "FindWindowA" (lpClassName As Any, lpWindowName As Any) As Integer
Declare Function GetActiveWindow     Lib "User32" ALIAS "GetActiveWindow" () As Integer
Declare Sub      GetClientRect       Lib "User32" ALIAS "GetClientRect" (hWnd%, lpRect As RECT)
Declare Function GetDesktopWindow    Lib "User32" ALIAS "GetDesktopWindow" () As Integer
Declare Function GetFocus            Lib "User32" ALIAS "GetFocus" () As Integer
Declare Function GetForegroundWindow Lib "User32" ALIAS "GetForegroundWindow" () As Integer
Declare Function GetSystemMetrics    Lib "User32" ALIAS "GetSystemMetrics" (nIndex%) As Integer
Declare Function GetWindowLong       Lib "User32" ALIAS "GetWindowLongA" (hWnd%,  nIndex%) As Long
Declare Sub      GetWindowRect       Lib "User32" ALIAS "GetWindowRect" (hWnd%, lpRect As RECT)
Declare Function GetWindowText       Lib "User32" ALIAS "GetWindowTextA" (hWnd%,  lpString$,  nMaxCount%) As Integer
Declare Function IsZoomed            Lib "User32" ALIAS "IsZoomed" (hWnd%) As Integer
Declare Function MessageBox          Lib "User32" ALIAS "MessageBoxA" (hWndParent%,  lpText$,  lpCaption$,  wType%) As Integer
Declare Function SendMessage         Lib "User32" ALIAS "SendMessageA" (hWnd%,  wMsg%,  wParam%, lParam As Any) As Long
Declare Function SetActiveWindow     Lib "User32" ALIAS "SetActiveWindow" (hWnd%) As Integer
Declare Function SetFocus            Lib "User32" ALIAS "SetFocus" (hWnd%) As Integer
Declare Function SetForegroundWindow Lib "User32" ALIAS "SetForegroundWindow" (hWnd%) As Integer
Declare Function SetWindowPos        Lib "User32" ALIAS "SetWindowPos" (h%, ha%, x%, y%, cx%, cy%, f%) As Integer
Declare Function ShowWindow          Lib "User32" ALIAS "ShowWindow" (hWnd%,  nCmdShow%) As Integer


'  ShowWindow() Commands
Const SW_HIDE = 0
Const SW_SHOWNORMAL = 1
Const SW_NORMAL = 1
Const SW_SHOWMINIMIZED = 2
Const SW_SHOWMAXIMIZED = 3
Const SW_MAXIMIZE = 3
Const SW_SHOWNOACTIVATE = 4
Const SW_SHOW = 5
Const SW_MINIMIZE = 6
Const SW_SHOWMINNOACTIVE = 7
Const SW_SHOWNA = 8
Const SW_RESTORE = 9

'  Window Styles
Const WS_MINIMIZE = &H20000000
Const WS_MAXIMIZE = &H1000000


'  Window field offsets for GetWindowLong()
Const GWL_WNDPROC = (-4)
Const GWL_STYLE = (-16)
Const GWL_EXSTYLE = (-20)

'$endif

'$ifndef _WINKERN

' Definitions stolen from WINKERN.INC
'-----------------------------------------------------------------------------
Declare Function WinExec           Lib "Kernel32" ALIAS "WinExec" (lpCmdLine$, nCmdShow%) As Integer

'$endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsipx.h ===
/*
 *   wsipx.h
 *
 *   Microsoft Windows
 *   Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for IPX/SPX.  This file contains all
 *   standardized IPX/SPX information.  Include this header file after
 *   winsock.h.
 *
 *   To open an IPX socket, call socket() with an address family of
 *   AF_IPX, a socket type of SOCK_DGRAM, and protocol NSPROTO_IPX.
 *   Note that the protocol value must be specified, it cannot be 0.
 *   All IPX packets are sent with the packet type field of the IPX
 *   header set to 0.
 *
 *   To open an SPX or SPXII socket, call socket() with an address
 *   family of AF_IPX, socket type of SOCK_SEQPACKET or SOCK_STREAM,
 *   and protocol of NSPROTO_SPX or NSPROTO_SPXII.  If SOCK_SEQPACKET
 *   is specified, then the end of message bit is respected, and
 *   recv() calls are not completed until a packet is received with
 *   the end of message bit set.  If SOCK_STREAM is specified, then
 *   the end of message bit is not respected, and recv() completes
 *   as soon as any data is received, regardless of the setting of the
 *   end of message bit.  Send coalescing is never performed, and sends
 *   smaller than a single packet are always sent with the end of
 *   message bit set.  Sends larger than a single packet are packetized
 *   with the end of message bit set on only the last packet of the
 *   send.
 *
 */

#ifndef _WSIPX_
#define _WSIPX_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for IPX and SPX.
 *
 */

typedef struct sockaddr_ipx {
    short sa_family;
    char  sa_netnum[4];
    char  sa_nodenum[6];
    unsigned short sa_socket;
} SOCKADDR_IPX, *PSOCKADDR_IPX,FAR *LPSOCKADDR_IPX;

/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 *
 */

#define NSPROTO_IPX      1000
#define NSPROTO_SPX      1256
#define NSPROTO_SPXII    1257

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wspgm.h ===
/*	
**	wspgm.h - winsock extension for PGM Reliable Transport
**
**	This file contains PGM specific information for use by WinSock2 compatible
**  applications that need Reliable Multicast Transport.
**
**  Copyright (c) 1995-2000  Microsoft Corporation
**
**	Created: Mar 12, 2000
**
*/

#ifndef _WSPGM_H_
#define _WSPGM_H_


#define IPPROTO_RM      113

//
// options for setsockopt, getsockopt
//
#define RM_OPTIONSBASE      1000

// Set/Query rate (Kb/Sec) + window size (Kb and/or MSec) -- described by RM_SEND_WINDOW below
#define RM_RATE_WINDOW_SIZE             (RM_OPTIONSBASE + 1)

// Set the size of the next message -- (ULONG)
#define RM_SET_MESSAGE_BOUNDARY         (RM_OPTIONSBASE + 2)

// flush the entire data (window) right now
#define RM_FLUSHCACHE                   (RM_OPTIONSBASE + 3)

// receiver side: discard the partial message and start over
#define RM_FLUSHMESSAGE                 (RM_OPTIONSBASE + 4)

// get sender statistics
#define RM_SENDER_STATISTICS            (RM_OPTIONSBASE + 5)

// allow a late-joiner to NAK any packet upto the lowest sequence Id
#define RM_LATEJOIN                     (RM_OPTIONSBASE + 6)

// set IP multicast outgoing interface
#define RM_SET_SEND_IF                  (RM_OPTIONSBASE + 7)

// add IP multicast incoming interface
#define RM_ADD_RECEIVE_IF               (RM_OPTIONSBASE + 8)

// delete IP multicast incoming interface
#define RM_DEL_RECEIVE_IF               (RM_OPTIONSBASE + 9)

// Set/Query the Window's Advance rate (has to be less that MAX_WINDOW_INCREMENT_PERCENTAGE)
#define RM_SEND_WINDOW_ADV_RATE         (RM_OPTIONSBASE + 10)


#define     SENDER_DEFAULT_RATE_KB_PER_SEC           56             // 56 Kb/Sec
#define     SENDER_DEFAULT_WINDOW_SIZE_BYTES         10 *1000*1000  // 10 Megs
#define     SENDER_MAX_WINDOW_SIZE_BYTES            100*1000*1000   // 100 Megs

#define     SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE     15             // 15%
#define     MAX_WINDOW_INCREMENT_PERCENTAGE          25             // 25%

#define     SENDER_DEFAULT_LATE_JOINER_PERCENTAGE    50             // 50%
#define     SENDER_MAX_LATE_JOINER_PERCENTAGE        75             // 75%

typedef struct _RM_SEND_WINDOW
{
    ULONG   RateKbPerSec;       // Send rate
    ULONG   WindowSizeInMSecs;
    ULONG   WindowSizeInBytes;
} RM_SEND_WINDOW;

typedef struct _RM_SENDER_STATS
{
    ULONGLONG   DataBytesSent;          // # client data bytes sent out so far
    ULONGLONG   TotalBytesSent;         // SPM, OData and RData bytes
    ULONGLONG   NaksReceived;           // # NAKs received so far
    ULONGLONG   NaksReceivedTooLate;    // # NAKs recvd after window advanced
    ULONGLONG   NumOutstandingNaks;     // # NAKs yet to be responded to
    ULONGLONG   NumNaksAfterRData;      // # NAKs yet to be responded to
    ULONGLONG   RepairPacketsSent;      // # Repairs (RDATA) sent so far
//    ULONGLONG   NumMessagesDropped;   // # partial messages dropped
    ULONGLONG   TrailingEdgeSeqId;      // smallest (oldest) Sequence Id in the window
    ULONGLONG   LeadingEdgeSeqId;       // largest (newest) Sequence Id in the window
} RM_SENDER_STATS;


//
// Pgm options
//
#endif  /* _WSPGM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsipv6ok.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wsipv6ok.h
    
Abstract:

    This module contains defines used to flag usage of IPv6 incompatible
    defines, stuctures and functions.  They cause *cryptic* compile time
    error messages to be generated.  Currently, this header is only
    included from winsock2.h.

    NOTE: The compile time flag, IPV6STRICT, must be defined.

--*/

#ifndef _WSIPV6OK_
#define _WSIPV6OK_

#pragma once

#ifdef IPV6STRICT

//
// prevent substitutions in these headers by including them first.
//
#include <ws2tcpip.h>
#include <wspiapi.h>

#undef AF_INET
#define AF_INET AF_INET_IPV6INCOMPATIBLE
#undef PF_INET
#define PF_INET PF_INET_IPV6INCOMPATIBLE
#undef in_addr
#define in_addr in_addr_IPV6INCOMPATIBLE
#undef IN_ADDR
#define IN_ADDR IN_ADDR_IPV6INCOMPATIBLE
#undef PIN_ADDR
#define PIN_ADDR PIN_ADDR_IPV6INCOMPATIBLE
#undef LPIN_ADDR
#define LPIN_ADDR LPIN_ADDR_IPV6INCOMPATIBLE
#undef IPAddr
#define IPAddr IPAddr_IPV6INCOMPATIBLE
#undef sockaddr_in
#define sockaddr_in sockaddr_in_IPV6INCOMPATIBLE
#undef SOCKADDR_IN
#define SOCKADDR_IN SOCKADDR_IN_IPV6INCOMPATIBLE
#undef PSOCKADDR_IN
#define PSOCKADDR_IN PSOCKADDR_IN_IPV6INCOMPATIBLE
#undef LPSOCKADDR_IN
#define LPSOCKADDR_IN LPSOCKADDR_IN_IPV6INCOMPATIBLE
#undef INADDR_ANY
#define INADDR_ANY INADDR_ANY_IPV6INCOMPATIBLE
#undef INADDR_LOOPBACK
#define INADDR_LOOPBACK INADDR_LOOPBACK_IPV6INCOMPATIBLE
#undef IPPROTO_IP
#define IPPROTO_IP IPPROTO_IP_IPV6INCOMPATIBLE
#undef IP_MULTICAST_IF
#define IP_MULTICAST_IF IP_MULTICAST_IF_IPV6INCOMPATIBLE
#undef IP_MULTICAST_TTL
#define IP_MULTICAST_TTL IP_MULTICAST_TTL_IPV6INCOMPATIBLE
#undef IP_MULTICAST_LOOP
#define IP_MULTICAST_LOOP IP_MULTICAST_LOOP_IPV6INCOMPATIBLE
#undef IP_ADD_MEMBERSHIP
#define IP_ADD_MEMBERSHIP IP_ADD_MEMBERSHIP_IPV6INCOMPATIBLE
#undef IP_DROP_MEMBERSHIP
#define IP_DROP_MEMBERSHIP IP_DROP_MEMBERSHIP_IPV6INCOMPATIBLE
#undef ip_mreq
#define ip_mreq ip_mreq_IPV6INCOMPATIBLE
#undef gethostbyname
#define gethostbyname(a) gethostbyname_IPV6INCOMPATIBLE
#undef hostent
#define hostent hostent_IPV6INCOMPATIBLE
#undef HOSTENT
#define HOSTENT HOSTENT_IPV6INCOMPATIBLE
#undef PHOSTENT
#define PHOSTENT PHOSTENT_IPV6INCOMPATIBLE
#undef LPHOSTENT
#define LPHOSTENT LPHOSTENT_IPV6INCOMPATIBLE
#undef inet_addr
#define inet_addr(a) inet_addr_IPV6INCOMPATIBLE
#undef gethostbyaddr
#define gethostbyaddr(a,b,c) gethostbyaddr_IPV6INCOMPATIBLE
#undef inet_ntoa
#define inet_ntoa(a) inet_ntoa_IPV6INCOMPATIBLE
#undef IN_MULTICAST
#define IN_MULTICAST(a) IN_MULTICAST_IPV6INCOMPATIBLE
#undef IN_CLASSD
#define IN_CLASSD(a) IN_CLASSD_IPV6INCOMPATIBLE
#undef IP_TTL
#define IP_TTL IP_TTL_IPV6INCOMPATIBLE
#undef IN_CLASSA
#define IN_CLASSA(a) IN_CLASSA_IPV6INCOMPATIBLE
#undef IN_CLASSB
#define IN_CLASSB(a) IN_CLASSB_IPV6INCOMPATIBLE
#undef IN_CLASSC
#define IN_CLASSC(a) IN_CLASSC_IPV6INCOMPATIBLE
#undef INADDR_BROADCAST
#define INADDR_BROADCAST(a) INADDR_BROADCAST_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByAddr
#define WSAAsyncGetHostByAddr(a,b,c,d,e,f,g) WSAAsyncGetHostByAddr_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByName
#define WSAAsyncGetHostByName(a,b,c,d,e) WSAAsyncGetHostByName_IPV6INCOMPATIBLE

#endif // IPV6STRICT

#endif // _WSIPV6OK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsiperr.h ===
// =--------------------------------------------------------------------------=
//  WSIPErr.mc
// =--------------------------------------------------------------------------=
//  (C) Copyright 2000-2001 Microsoft Corporation.  All Rights Reserved.
// =--------------------------------------------------------------------------=

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __WSIPErr_H__
#define __WSIPErr_H__

///FACILITY_CATEGORY
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x41
#define FACILITY_STACK                   0x200
#define FACILITY_SIP_MESSAGE             0x42
#define FACILITY_REGISTRAR               0x100
#define FACILITY_PROXY                   0x300
#define FACILITY_PROCESSING              0x43
#define FACILITY_LKRHASH                 0x500
#define FACILITY_EXTENSIONMODULE_ROUTING 0x45
#define FACILITY_EXTENSIONMODULE_OUT     0x46
#define FACILITY_EXTENSIONMODULE_IN      0x44
#define FACILITY_EVENTLOG                0x400
#define FACILITY_CATEGORY                0x0


//
// Define the severity codes
//


//
// MessageId: CATEGORY_CONTROLLER
//
// MessageText:
//
//  WinSIP
//
#define CATEGORY_CONTROLLER              0x00000001L

//
// MessageId: CATEGORY_STACK
//
// MessageText:
//
//  Stack
//
#define CATEGORY_STACK                   0x00000002L

//
// MessageId: CATEGORY_ERR_AUTH
//
// MessageText:
//
//  Authentication
//
#define CATEGORY_ERR_AUTH                0x00000003L

//
// MessageId: CATEGORY_LAST
//
// MessageText:
//
//  RTC Server
//
#define CATEGORY_LAST                    0x00000004L

///FACILITY_SYSTEM
//
// MessageId: SIPPROXY_E_NOTINITIALIZED
//
// MessageText:
//
//  The proxy stack is not initialized.
//
#define SIPPROXY_E_NOTINITIALIZED        0xC0410001L

//
// MessageId: SIPPROXY_E_NOTSTOPPED
//
// MessageText:
//
//  The proxy stack should be stopped first.
//
#define SIPPROXY_E_NOTSTOPPED            0xC0410002L

///FACILITY_STACK
//
// MessageId: SIPPROXY_E_NO_CONTEXT
//
// MessageText:
//
//  There is no context associated with this extension module and this session type.
//
#define SIPPROXY_E_NO_CONTEXT            0xC2000001L

//
// MessageId: SIPPROXY_E_NO_MATCH
//
// MessageText:
//
//  There is no match for the URI supplied.
//
#define SIPPROXY_E_NO_MATCH              0xC2000002L

///FACILITY_REGISTRAR
//
// MessageId: REGISTRAR_USER_NOT_FOUND
//
// MessageText:
//
//  No matching contact entries were found for the given user.
//
#define REGISTRAR_USER_NOT_FOUND         0xC1000001L

//
// MessageId: REGISTRAR_DOMAIN_NOT_SUPPORTED
//
// MessageText:
//
//  Registrar does not support the user's domain.
//
#define REGISTRAR_DOMAIN_NOT_SUPPORTED   0xC1000002L

///FACILITY_PROXY
//
// MessageId: PROXY_REQUEST_REPLIED
//
// MessageText:
//
//  Request message is going to be replied.
//
#define PROXY_REQUEST_REPLIED            0x43000001L

///FACILITY_PROCESSING
//
// MessageId: SIP_S_AUTH_DISABLED
//
// MessageText:
//
//  Authentication module is disabled
//
#define SIP_S_AUTH_DISABLED              0x40430001L

//
// MessageId: SIP_S_AUTH_AUTHENTICATED
//
// MessageText:
//
//  Authentication process succeeded
//
#define SIP_S_AUTH_AUTHENTICATED         0x40430002L

//
// MessageId: SIP_E_AUTH_INVALIDSTATE
//
// MessageText:
//
//  Invalid state for the authentication module
//
#define SIP_E_AUTH_INVALIDSTATE          0xC0430003L

//
// MessageId: SIP_E_AUTH_UNAUTHORIZED
//
// MessageText:
//
//  Unauthorized message
//
#define SIP_E_AUTH_UNAUTHORIZED          0xC0430004L

//
// MessageId: SIP_E_AUTH_INVALIDUSERNAME
//
// MessageText:
//
//  No user name in the authentication header
//
#define SIP_E_AUTH_INVALIDUSERNAME       0xC0430005L

//
// MessageId: SIP_E_AUTH_INVALIDPROTOCOL
//
// MessageText:
//
//  The security protocol is invalid
//
#define SIP_E_AUTH_INVALIDPROTOCOL       0xC0430006L

//
// MessageId: SIP_E_AUTH_PKGDISABLED
//
// MessageText:
//
//  The security package is disabled
//
#define SIP_E_AUTH_PKGDISABLED           0xC0430007L

//
// MessageId: SIP_E_AUTH_SYSTEMERROR
//
// MessageText:
//
//  Internal system error
//
#define SIP_E_AUTH_SYSTEMERROR           0xC0430008L

//
// MessageId: SIP_E_AUTH_SIGNFAILED
//
// MessageText:
//
//  The signing process failed
//
#define SIP_E_AUTH_SIGNFAILED            0xC0430009L

//
// MessageId: SIP_E_AUTH_INVALIDSIGNATURE
//
// MessageText:
//
//  The message has an invalid signature
//
#define SIP_E_AUTH_INVALIDSIGNATURE      0xC043000AL

//
// MessageId: SIP_E_AUTH_INVALIDSIPUSER
//
// MessageText:
//
//  Invalid SIP user in the From field
//
#define SIP_E_AUTH_INVALIDSIPUSER        0xC043000BL

//
// MessageId: SIPPROXY_E_NOCONTROL
//
// MessageText:
//
//  The extension module does not hold the control of this object.
//
#define SIPPROXY_E_NOCONTROL             0xC043000CL

//
// MessageId: SIPPROXY_E_REFUSED
//
// MessageText:
//
//  The operation requested has been refused.
//
#define SIPPROXY_E_REFUSED               0xC043000DL

//
// MessageId: SIPPROXY_E_INTERNAL_LOOP_DETECTED
//
// MessageText:
//
//  An internal loop has been detected in routing the request.
//
#define SIPPROXY_E_INTERNAL_LOOP_DETECTED 0xC043000EL

//
// MessageId: SIPPROXY_E_ROUTE_PRESENT
//
// MessageText:
//
//  The request-uri cannot be changed since we are routing according to route header.
//
#define SIPPROXY_E_ROUTE_PRESENT         0xC043000FL

//
// MessageId: SIPPROXY_E_EVENT_REVOKED
//
// MessageText:
//
//  The event has been revoked by the proxy engine.
//
#define SIPPROXY_E_EVENT_REVOKED         0xC0430010L

//
// MessageId: SIPPROXY_E_WRONG_EVENT
//
// MessageText:
//
//  Information requested is not provided with the event of this type.
//
#define SIPPROXY_E_WRONG_EVENT           0xC0430011L

//
// MessageId: SIPPROXY_E_FAILPARSING
//
// MessageText:
//
//  The parsing failed.
//
#define SIPPROXY_E_FAILPARSING           0xC0430012L

//
// MessageId: SIPPROXY_E_HEADER_NOT_FOUND
//
// MessageText:
//
//  The header is not found.
//
#define SIPPROXY_E_HEADER_NOT_FOUND      0xC0430013L

//
// MessageId: SIPPROXY_E_FIELD_NOT_EXIST
//
// MessageText:
//
//  There is no such field in the object.
//
#define SIPPROXY_E_FIELD_NOT_EXIST       0xC0430014L

//
// MessageId: SIPPROXY_E_DNS_QUERY_FAILED
//
// MessageText:
//
//  There is no such field in the object.
//
#define SIPPROXY_E_DNS_QUERY_FAILED      0xC0430015L

//
// MessageId: SIPPROXY_E_PROXY_STOPPING
//
// MessageText:
//
//  The operation requested has been refused because the proxy is stopping.
//
#define SIPPROXY_E_PROXY_STOPPING        0xC0430016L

#endif // #ifndef __WSIPErr_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsnwlink.h ===
/*
 *   wsnwlink.h
 *
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *   Microsoft-specific extensions to the Windows NT IPX/SPX Windows
 *   Sockets interface.  These extensions are provided for use as
 *   necessary for compatibility with existing applications.  They are
 *   otherwise not recommended for use, as they are only guaranteed to
 *   work *   over the Microsoft IPX/SPX stack.  An application which
 *   uses these *   extensions may not work over other IPX/SPX
 *   implementations.  Include this header file after winsock.h and
 *   wsipx.h.
 *
 *   To open an IPX socket where a particular packet type is sent in
 *   the IPX header, specify NSPROTO_IPX + n as the protocol parameter
 *   of the socket() API.  For example, to open an IPX socket that
 *   sets the packet type to 34, use the following socket() call:
 *
 *       s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX + 34);
 *
 *   Below are socket option that may be set or retrieved by specifying
 *   the appropriate manifest in the "optname" parameter of getsockopt()
 *   or setsockopt().  Use NSPROTO_IPX as the "level" argument for the
 *   call.
 *
 */

#ifndef _WSNWLINK_
#define _WSNWLINK_

#if _MSC_VER > 1000
#pragma once
#endif


/*
 *   Set/get the IPX packet type.  The value specified in the
 *   optval argument will be set as the packet type on every IPX
 *   packet sent from this socket.  The optval parameter of
 *   getsockopt()/setsockopt() points to an int.
 *
 */

#define IPX_PTYPE               0x4000


/*
 *   Set/get the receive filter packet type.  Only IPX packets with
 *   a packet type equal to the value specified in the optval
 *   argument will be returned; packets with a packet type that
 *   does not match are discarded.  optval points to an int.
 *
 */

#define IPX_FILTERPTYPE         0x4001


/*
 *   Stop filtering on packet type set with IPX_FILTERPTYPE.
 *
 */

#define IPX_STOPFILTERPTYPE     0x4003


/*
 *   Set/get the value of the datastream field in the SPX header on
 *   every packet sent.  optval points to an int.
 *
 */

#define IPX_DSTYPE              0x4002


/*
 *   Enable extended addressing.  On sends, adds the element
 *   "unsigned char sa_ptype" to the SOCKADDR_IPX structure,
 *   making the total length 15 bytes.  On receives, add both
 *   the sa_ptype and "unsigned char sa_flags" to the SOCKADDR_IPX
 *   structure, making the total length 16 bytes.  The current
 *   bits defined in sa_flags are:
 *
 *   0x01 - the received frame was sent as a broadcast
 *   0x02 - the received frame was sent from this machine
 *
 *   optval points to a BOOL.
 *
 */

#define IPX_EXTENDED_ADDRESS    0x4004


/*
 *   Send protocol header up on all receive packets.  optval points
 *   to a BOOL.
 *
 */

#define IPX_RECVHDR             0x4005


/*
 *   Get the maximum data size that can be sent.  Not valid with
 *   setsockopt().  optval points to an int where the value is
 *   returned.
 *
 */

#define IPX_MAXSIZE             0x4006


/*
 *   Query information about a specific adapter that IPX is bound
 *   to.  In a system with n adapters they are numbered 0 through n-1.
 *   Callers can issue the IPX_MAX_ADAPTER_NUM getsockopt() to find
 *   out the number of adapters present, or call IPX_ADDRESS with
 *   increasing values of adapternum until it fails.  Not valid
 *   with setsockopt().  optval points to an instance of the
 *   IPX_ADDRESS_DATA structure with the adapternum filled in.
 *
 */

#define IPX_ADDRESS             0x4007

typedef struct _IPX_ADDRESS_DATA {
    INT   adapternum;  /* input: 0-based adapter number */
    UCHAR netnum[4];   /* output: IPX network number */
    UCHAR nodenum[6];  /* output: IPX node address */
    BOOLEAN wan;       /* output: TRUE = adapter is on a wan link */
    BOOLEAN status;    /* output: TRUE = wan link is up (or adapter is not wan) */
    INT   maxpkt;      /* output: max packet size, not including IPX header */
    ULONG linkspeed;   /* output: link speed in 100 bytes/sec (i.e. 96 == 9600 bps) */
} IPX_ADDRESS_DATA, *PIPX_ADDRESS_DATA;


/*
 *   Query information about a specific IPX network number.  If the
 *   network is in IPX's cache it will return the information directly,
 *   otherwise it will issue RIP requests to find it.  Not valid with
 *   setsockopt().  optval points to an instance of the IPX_NETNUM_DATA
 *   structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO          0x4008

typedef struct _IPX_NETNUM_DATA {
    UCHAR  netnum[4];  /* input: IPX network number */
    USHORT hopcount;   /* output: hop count to this network, in machine order */
    USHORT netdelay;   /* output: tick count to this network, in machine order */
    INT    cardnum;    /* output: 0-based adapter number used to route to this net;
                       /*         can be used as adapternum input to IPX_ADDRESS */
    UCHAR  router[6];  /* output: MAC address of the next hop router, zeroed if
                       /*         the network is directly attached */
} IPX_NETNUM_DATA, *PIPX_NETNUM_DATA;


/*
 *   Like IPX_GETNETINFO except it *does not* issue RIP requests. If the
 *   network is in IPX's cache it will return the information, otherwise
 *   it will fail (see also IPX_RERIPNETNUMBER which *always* forces a
 *   re-RIP). Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_GETNETINFO_NORIP    0x4009


/*
 *   Get information on a connected SPX socket.  optval points
 *   to an instance of the IPX_SPXCONNSTATUS_DATA structure.
 *
 *   All numbers are in Novell (high-low) order.
 *
 */

#define IPX_SPXGETCONNECTIONSTATUS 0x400B

typedef struct _IPX_SPXCONNSTATUS_DATA {
    UCHAR  ConnectionState;
    UCHAR  WatchDogActive;
    USHORT LocalConnectionId;
    USHORT RemoteConnectionId;
    USHORT LocalSequenceNumber;
    USHORT LocalAckNumber;
    USHORT LocalAllocNumber;
    USHORT RemoteAckNumber;
    USHORT RemoteAllocNumber;
    USHORT LocalSocket;
    UCHAR  ImmediateAddress[6];
    UCHAR  RemoteNetwork[4];
    UCHAR  RemoteNode[6];
    USHORT RemoteSocket;
    USHORT RetransmissionCount;
    USHORT EstimatedRoundTripDelay; /* In milliseconds */
    USHORT RetransmittedPackets;
    USHORT SuppressedPacket;
} IPX_SPXCONNSTATUS_DATA, *PIPX_SPXCONNSTATUS_DATA;


/*
 *   Get notification when the status of an adapter that IPX is
 *   bound to changes.  Typically this will happen when a wan line
 *   goes up or down.  Not valid with setsockopt().  optval points
 *   to a buffer which contains an IPX_ADDRESS_DATA structure
 *   followed immediately by a HANDLE to an unsignaled event.
 *
 *   When the getsockopt() query is submitted, it will complete
 *   successfully.  However, the IPX_ADDRESS_DATA pointed to by
 *   optval will not be updated at that point.  Instead the
 *   request is queued internally inside the transport.
 *
 *   When the status of an adapter changes, IPX will locate a
 *   queued getsockopt() query and fill in all the fields in the
 *   IPX_ADDRESS_DATA structure.  It will then signal the event
 *   pointed to by the HANDLE in the optval buffer.  This handle
 *   should be obtained before calling getsockopt() by calling
 *   CreateEvent().  If multiple getsockopts() are submitted at
 *   once, different events must be used.
 *
 *   The event is used because the call needs to be asynchronous
 *   but currently getsockopt() does not support this.
 *
 *   WARNING: In the current implementation, the transport will
 *   only signal one queued query for each status change.  Therefore
 *   only one service which uses this query should be running at
 *   once.
 *
 */

#define IPX_ADDRESS_NOTIFY      0x400C


/*
 *   Get the maximum number of adapters present.  If this call returns
 *   n then the adapters are numbered 0 through n-1.  Not valid
 *   with setsockopt().  optval points to an int where the value
 *   is returned.
 *
 */

#define IPX_MAX_ADAPTER_NUM     0x400D


/*
 *   Like IPX_GETNETINFO except it forces IPX to re-RIP even if the
 *   network is in its cache (but not if it is directly attached to).
 *   Not valid with setsockopt().  optval points to an instance of
 *   the IPX_NETNUM_DATA structure with the netnum filled in.
 *
 */

#define IPX_RERIPNETNUMBER      0x400E


/*
 *   A hint that broadcast packets may be received.  The default is
 *   TRUE.  Applications that do not need to receive broadcast packets
 *   should set this sockopt to FALSE which may cause better system
 *   performance (note that it does not necessarily cause broadcasts
 *   to be filtered for the application).  Not valid with getsockopt().
 *   optval points to a BOOL.
 *
 */

#define IPX_RECEIVE_BROADCAST   0x400F


/*
 *   On SPX connections, don't delay before sending ack.  Applications
 *   that do not tend to have back-and-forth traffic over SPX should
 *   set this; it will increase the number of acks sent but will remove
 *   delays in sending acks.  optval points to a BOOL.
 *
 */

#define IPX_IMMEDIATESPXACK     0x4010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wspiapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:
    wspiapi.h

Abstract:
    The file contains protocol independent API functions.

Revision History:
    Wed Jul 12 10:50:31 2000, Created

--*/

#ifndef _WSPIAPI_H_
#define _WSPIAPI_H_

#include <stdio.h>              // sprintf()
#include <stdlib.h>             // calloc(), strtoul()
#include <malloc.h>             // calloc()
#include <string.h>             // strlen(), strcmp(), strstr()

#define WspiapiMalloc(tSize)    calloc(1, (tSize))
#define WspiapiFree(p)          free(p)
#define WspiapiSwap(a, b, c)    { (c) = (a); (a) = (b); (b) = (c); }
#define getaddrinfo             WspiapiGetAddrInfo
#define getnameinfo             WspiapiGetNameInfo
#define freeaddrinfo            WspiapiFreeAddrInfo

typedef int (WINAPI *WSPIAPI_PGETADDRINFO) (
    IN  const char                      *nodename,
    IN  const char                      *servname,
    IN  const struct addrinfo           *hints,
    OUT struct addrinfo                 **res);

typedef int (WINAPI *WSPIAPI_PGETNAMEINFO) (
    IN  const struct sockaddr           *sa,
    IN  socklen_t                       salen,
    OUT char                            *host,
    IN  size_t                          hostlen,
    OUT char                            *serv,
    IN  size_t                          servlen,
    IN  int                             flags);

typedef void (WINAPI *WSPIAPI_PFREEADDRINFO) (
    IN  struct addrinfo                 *ai);



#ifdef __cplusplus
extern "C" {
#endif
    
////////////////////////////////////////////////////////////
// v4 only versions of getaddrinfo and friends.
// NOTE: gai_strerror is inlined in ws2tcpip.h
////////////////////////////////////////////////////////////

_inline    
char *
WINAPI
WspiapiStrdup (
	IN  const char *                    pszString)
/*++

Routine Description
    allocates enough storage via calloc() for a copy of the string,
    copies the string into the new memory, and returns a pointer to it.

Arguments
    pszString       string to copy into new memory

Return Value
    a pointer to the newly allocated storage with the string in it.
    NULL if enough memory could not be allocated, or string was NULL.

--*/    
{
    char    *pszMemory;

    if (!pszString)
        return(NULL);

    pszMemory = (char *) WspiapiMalloc(strlen(pszString) + 1);
    if (!pszMemory)
        return(NULL);

    return(strcpy(pszMemory, pszString));
}

    
    
__inline
BOOL
WINAPI
WspiapiParseV4Address (
    IN  const char *                    pszAddress,
    OUT PDWORD                          pdwAddress)
/*++

Routine Description
    get the IPv4 address (in network byte order) from its string
    representation.  the syntax should be a.b.c.d.
    
Arguments
    pszArgument         string representation of the IPv4 address
    ptAddress           pointer to the resulting IPv4 address

Return Value
    Returns FALSE if there is an error, TRUE for success.
    
--*/
{
    DWORD       dwAddress   = 0;
    const char  *pcNext     = NULL;
    int         iCount      = 0;

    // ensure there are 3 '.' (periods)
    for (pcNext = pszAddress; *pcNext != '\0'; pcNext++)
        if (*pcNext == '.')
            iCount++;
    if (iCount != 3)
        return FALSE;

    // return an error if dwAddress is INADDR_NONE (255.255.255.255)
    // since this is never a valid argument to getaddrinfo.
    dwAddress = inet_addr(pszAddress);
    if (dwAddress == INADDR_NONE)
        return FALSE;

    *pdwAddress = dwAddress;
    return TRUE;
}



__inline
struct addrinfo *
WINAPI
WspiapiNewAddrInfo (
    IN  int                             iSocketType,
    IN  int                             iProtocol,
    IN  WORD                            wPort,
    IN  DWORD                           dwAddress)
/*++

Routine Description
    allocate an addrinfo structure and populate fields.
    IPv4 specific internal function, not exported.
    
Arguments
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    dwAddress           IPv4 address (in network order).
    
Return Value
    returns an addrinfo struct, or NULL if out of memory.

--*/    
{
    struct addrinfo     *ptNew;
    struct sockaddr_in  *ptAddress;

    // allocate a new addrinfo structure.
    ptNew       =
        (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
    if (!ptNew)
        return NULL;

    ptAddress   =
        (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
    if (!ptAddress)
    {
        WspiapiFree(ptNew);
        return NULL;
    }
    ptAddress->sin_family       = AF_INET;
    ptAddress->sin_port         = wPort;
    ptAddress->sin_addr.s_addr  = dwAddress;
    
    // fill in the fields...
    ptNew->ai_family            = PF_INET;
    ptNew->ai_socktype          = iSocketType;
    ptNew->ai_protocol          = iProtocol;
    ptNew->ai_addrlen           = sizeof(struct sockaddr_in);
    ptNew->ai_addr              = (struct sockaddr *) ptAddress;

    return ptNew;
}



__inline
int
WINAPI
WspiapiQueryDNS(
    IN  const char                      *pszNodeName,
    IN  int                             iSocketType,
    IN  int                             iProtocol,  
    IN  WORD                            wPort,      
    OUT char                            pszAlias[NI_MAXHOST],
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    helper routine for WspiapiLookupNode.
    performs name resolution by querying the DNS for A records.
    *pptResult would need to be freed if an error is returned.
    
Arguments
    pszNodeName         name of node to resolve.
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    pszAlias            where to return the alias.  must be of size NI_MAXHOST.
    pptResult           where to return the result.
    
Return Value
    Returns 0 on success, an EAI_* style error value otherwise.

--*/    
{
    struct addrinfo **pptNext   = pptResult;
    struct hostent  *ptHost     = NULL;
    char            **ppAddresses;

    *pptNext    = NULL;
    pszAlias[0] = '\0';

    ptHost = gethostbyname(pszNodeName);
    if (ptHost)
    {
        if ((ptHost->h_addrtype == AF_INET)     &&
            (ptHost->h_length   == sizeof(struct in_addr)))
        {
            for (ppAddresses    = ptHost->h_addr_list;
                 *ppAddresses   != NULL;
                 ppAddresses++)
            {
                // create an addrinfo structure...
                *pptNext = WspiapiNewAddrInfo(
                    iSocketType,
                    iProtocol,
                    wPort,
                    ((struct in_addr *) *ppAddresses)->s_addr);
                if (!*pptNext)
                    return EAI_MEMORY;

                pptNext = &((*pptNext)->ai_next);
            }
        }

        // pick up the canonical name.
        strncpy(pszAlias, ptHost->h_name, NI_MAXHOST - 1);
        pszAlias[NI_MAXHOST - 1] = '\0';
        
        return 0;
    }
    
    switch (WSAGetLastError())
    {
        case WSAHOST_NOT_FOUND: return EAI_NONAME;
        case WSATRY_AGAIN:      return EAI_AGAIN;
        case WSANO_RECOVERY:    return EAI_FAIL;
        case WSANO_DATA:        return EAI_NODATA;
        default:                return EAI_NONAME;
    }
}



__inline
int
WINAPI
WspiapiLookupNode(
    IN  const char                      *pszNodeName,
    IN  int                             iSocketType,
    IN  int                             iProtocol,  
    IN  WORD                            wPort,      
    IN  BOOL                            bAI_CANONNAME,
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    resolve a nodename and return a list of addrinfo structures.
    IPv4 specific internal function, not exported.
    *pptResult would need to be freed if an error is returned.
    
    NOTE: if bAI_CANONNAME is true, the canonical name should be
          returned in the first addrinfo structure.
    
Arguments
    pszNodeName         name of node to resolve.
    iSocketType         SOCK_*.  can be wildcarded (zero).
    iProtocol           IPPROTO_*.  can be wildcarded (zero).
    wPort               port number of service (in network order).
    bAI_CANONNAME       whether the AI_CANONNAME flag is set.
    pptResult           where to return result.
    
Return Value
    Returns 0 on success, an EAI_* style error value otherwise.

--*/
{
    int     iError              = 0;
    int     iAliasCount         = 0;

    char    szFQDN1[NI_MAXHOST] = "";
    char    szFQDN2[NI_MAXHOST] = "";
    char    *pszName            = szFQDN1;
    char    *pszAlias           = szFQDN2;
    char    *pszScratch         = NULL;
    strncpy(pszName, pszNodeName, NI_MAXHOST - 1);
    pszName[NI_MAXHOST - 1] = '\0';
    
    for (;;)
    {
        iError = WspiapiQueryDNS(pszNodeName,
                                 iSocketType,
                                 iProtocol,
                                 wPort,
                                 pszAlias,
                                 pptResult);
        if (iError)
            break;

        // if we found addresses, then we are done.
        if (*pptResult)
            break;

        // stop infinite loops due to DNS misconfiguration.  there appears
        // to be no particular recommended limit in RFCs 1034 and 1035.
        if ((!strlen(pszAlias))             ||
            (!strcmp(pszName, pszAlias))    ||
            (++iAliasCount == 16))
        {
            iError = EAI_FAIL;
            break;
        }

        // there was a new CNAME, look again.
        WspiapiSwap(pszName, pszAlias, pszScratch);
    }

    if (!iError && bAI_CANONNAME)
    {
        (*pptResult)->ai_canonname = WspiapiStrdup(pszAlias);
        if (!(*pptResult)->ai_canonname)
            iError = EAI_MEMORY;
    }

    return iError;
}



__inline
int
WINAPI
WspiapiClone (
    IN  WORD                            wPort,      
    IN  struct addrinfo                 *ptResult)
/*++

Routine Description
    clone every addrinfo structure in ptResult for the UDP service.
    ptResult would need to be freed if an error is returned.
    
Arguments
    wPort               port number of UDP service.
    ptResult            list of addrinfo structures, each
                        of whose node needs to be cloned.

Return Value
    Returns 0 on success, an EAI_MEMORY on allocation failure.

--*/
{
    struct addrinfo *ptNext = NULL;
    struct addrinfo *ptNew  = NULL;

    for (ptNext = ptResult; ptNext != NULL; )
    {
        // create an addrinfo structure...
        ptNew = WspiapiNewAddrInfo(
            SOCK_DGRAM,
            ptNext->ai_protocol,
            wPort,
            ((struct sockaddr_in *) ptNext->ai_addr)->sin_addr.s_addr);
        if (!ptNew)
            break;

        // link the cloned addrinfo
        ptNew->ai_next  = ptNext->ai_next;
        ptNext->ai_next = ptNew;
        ptNext          = ptNew->ai_next;
    }

    if (ptNext != NULL)
        return EAI_MEMORY;
    
    return 0;
}



__inline
void
WINAPI
WspiapiLegacyFreeAddrInfo (
    IN  struct addrinfo                 *ptHead)
/*++

Routine Description
    Free an addrinfo structure (or chain of structures).
    As specified in RFC 2553, Section 6.4.
    
Arguments
    ptHead              structure (chain) to free
    
--*/    
{
    struct addrinfo *ptNext;    // next strcture to free

    for (ptNext = ptHead; ptNext != NULL; ptNext = ptHead)
    {
        if (ptNext->ai_canonname)
            WspiapiFree(ptNext->ai_canonname);
        
        if (ptNext->ai_addr)
            WspiapiFree(ptNext->ai_addr);

        ptHead = ptNext->ai_next;
        WspiapiFree(ptNext);
    }
}



__inline
int
WINAPI
WspiapiLegacyGetAddrInfo(
    IN const char                       *pszNodeName,
    IN const char                       *pszServiceName,
    IN const struct addrinfo            *ptHints,
    OUT struct addrinfo                 **pptResult)
/*++

Routine Description
    Protocol-independent name-to-address translation.
    As specified in RFC 2553, Section 6.4.
    This is the hacked version that only supports IPv4.
    
Arguments
    pszNodeName         node name to lookup.
    pszServiceName      service name to lookup.
    ptHints             hints about how to process request.
    pptResult           where to return result.
    
Return Value
    returns zero if successful, an EAI_* error code if not.

--*/    
{
    int                 iError      = 0;
    int                 iFlags      = 0;
    int                 iFamily     = PF_UNSPEC;
    int                 iSocketType = 0;
    int                 iProtocol   = 0;
    WORD                wPort       = 0;
    DWORD               dwAddress   = 0;

    struct servent      *ptService  = NULL;
    char                *pc         = NULL;
    BOOL                bClone      = FALSE;
    WORD                wTcpPort    = 0;
    WORD                wUdpPort    = 0;
    
    
    // initialize pptResult with default return value.
    *pptResult  = NULL;


    ////////////////////////////////////////
    // validate arguments...
    //
    
    // both the node name and the service name can't be NULL.
    if ((!pszNodeName) && (!pszServiceName))
        return EAI_NONAME;

    // validate hints.
    if (ptHints)
    {
        // all members other than ai_flags, ai_family, ai_socktype
        // and ai_protocol must be zero or a null pointer.
        if ((ptHints->ai_addrlen    != 0)       ||
            (ptHints->ai_canonname  != NULL)    ||
            (ptHints->ai_addr       != NULL)    ||
            (ptHints->ai_next       != NULL))
        {
            return EAI_FAIL;
        }
        
        // the spec has the "bad flags" error code, so presumably we
        // should check something here.  insisting that there aren't
        // any unspecified flags set would break forward compatibility,
        // however.  so we just check for non-sensical combinations.
        //
        // we cannot come up with a canonical name given a null node name.
        iFlags      = ptHints->ai_flags;
        if ((iFlags & AI_CANONNAME) && !pszNodeName)
            return EAI_BADFLAGS;

        // we only support a limited number of protocol families.
        iFamily     = ptHints->ai_family;
        if ((iFamily != PF_UNSPEC) && (iFamily != PF_INET))
            return EAI_FAMILY;

        // we only support only these socket types.
        iSocketType = ptHints->ai_socktype;
        if ((iSocketType != 0)                  &&
            (iSocketType != SOCK_STREAM)        &&
            (iSocketType != SOCK_DGRAM)         &&
            (iSocketType != SOCK_RAW))
            return EAI_SOCKTYPE;

        // REVIEW: What if ai_socktype and ai_protocol are at odds?
        iProtocol   = ptHints->ai_protocol;
    }


    ////////////////////////////////////////
    // do service lookup...

    if (pszServiceName)
    {
        wPort = (WORD) strtoul(pszServiceName, &pc, 10);
        if (*pc == '\0')        // numeric port string
        {
            wPort = wTcpPort = wUdpPort = htons(wPort);
            if (iSocketType == 0)
            {
                bClone      = TRUE;
                iSocketType = SOCK_STREAM;
            }
        }
        else                    // non numeric port string
        {
            if ((iSocketType == 0) || (iSocketType == SOCK_DGRAM))
            {
                ptService = getservbyname(pszServiceName, "udp");
                if (ptService)
                    wPort = wUdpPort = ptService->s_port;
            }

            if ((iSocketType == 0) || (iSocketType == SOCK_STREAM))
            {
                ptService = getservbyname(pszServiceName, "tcp");
                if (ptService)
                    wPort = wTcpPort = ptService->s_port;
            }
            
            // assumes 0 is an invalid service port...
            if (wPort == 0)     // no service exists
                return (iSocketType ? EAI_SERVICE : EAI_NONAME);

            if (iSocketType == 0)
            {
                // if both tcp and udp, process tcp now & clone udp later.
                iSocketType = (wTcpPort) ? SOCK_STREAM : SOCK_DGRAM;
                bClone      = (wTcpPort && wUdpPort); 
            }
        }
    }
    


    ////////////////////////////////////////
    // do node name lookup...

    // if we weren't given a node name,
    // return the wildcard or loopback address (depending on AI_PASSIVE).
    //
    // if we have a numeric host address string,
    // return the binary address.
    //
    if ((!pszNodeName) || (WspiapiParseV4Address(pszNodeName, &dwAddress)))
    {
        if (!pszNodeName)
        {
            dwAddress = htonl((iFlags & AI_PASSIVE)
                              ? INADDR_ANY
                              : INADDR_LOOPBACK);
        }
        
        // create an addrinfo structure...
        *pptResult =
            WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, dwAddress);
        if (!(*pptResult))
            iError = EAI_MEMORY;
        
        if (!iError && pszNodeName)
        {
            // implementation specific behavior: set AI_NUMERICHOST
            // to indicate that we got a numeric host address string.
            (*pptResult)->ai_flags |= AI_NUMERICHOST;
            
            // return the numeric address string as the canonical name
            if (iFlags & AI_CANONNAME)
            {
                (*pptResult)->ai_canonname =
                    WspiapiStrdup(inet_ntoa(*((struct in_addr *) &dwAddress)));
                if (!(*pptResult)->ai_canonname)        
                    iError = EAI_MEMORY;
            }
        }
    }


    // if we do not have a numeric host address string and
    // AI_NUMERICHOST flag is set, return an error!
    else if (iFlags & AI_NUMERICHOST)
    {
        iError = EAI_NONAME;
    }
    

    // since we have a non-numeric node name,
    // we have to do a regular node name lookup.
    else
    {
        iError = WspiapiLookupNode(pszNodeName,
                                   iSocketType,
                                   iProtocol,
                                   wPort,
                                   (iFlags & AI_CANONNAME),
                                   pptResult);
    }

    if (!iError && bClone)
    {
        iError = WspiapiClone(wUdpPort, *pptResult);
    }

    if (iError)
    {
        WspiapiLegacyFreeAddrInfo(*pptResult);
        *pptResult  = NULL;        
    }

    return (iError);
}



__inline
int
WINAPI
WspiapiLegacyGetNameInfo(
    IN  const struct sockaddr           *ptSocketAddress,
    IN  socklen_t                       tSocketLength,
    OUT char                            *pszNodeName,
    IN  size_t                          tNodeLength,
    OUT char                            *pszServiceName,
    IN  size_t                          tServiceLength,
    IN  int                             iFlags)
/*++

Routine Description
    protocol-independent address-to-name translation.
    as specified in RFC 2553, Section 6.5.
    this is the hacked version that only supports IPv4.
    
Arguments
    ptSocketAddress     socket address to translate.
    tSocketLength       length of above socket address.
    pszNodeName         where to return the node name.
    tNodeLength         size of above buffer.
    pszServiceName      where to return the service name.
    tServiceLength      size of above buffer.
    iFlags              flags of type NI_*.
    
Return Value
    returns zero if successful, an EAI_* error code if not.

--*/    
{
    struct servent  *ptService;
    WORD            wPort;    
    char            szBuffer[]  = "65535";
    char            *pszService = szBuffer;

    struct hostent  *ptHost;
    struct in_addr  tAddress;
    char            *pszNode    = NULL;
    char            *pc         = NULL;
    

    // sanity check ptSocketAddress and tSocketLength.
    if ((!ptSocketAddress) || (tSocketLength < sizeof(struct sockaddr)))
        return EAI_FAIL;
    
    if (ptSocketAddress->sa_family != AF_INET)
        return EAI_FAMILY;

    if (tSocketLength < sizeof(struct sockaddr_in))
        return EAI_FAIL;
    
    if (!(pszNodeName && tNodeLength) &&
        !(pszServiceName && tServiceLength))
    {
        return EAI_NONAME;    
    }

    // the draft has the "bad flags" error code, so presumably we
    // should check something here.  insisting that there aren't
    // any unspecified flags set would break forward compatibility,
    // however.  so we just check for non-sensical combinations.
    if ((iFlags & NI_NUMERICHOST) && (iFlags & NI_NAMEREQD))
    {                                                                       
        return EAI_BADFLAGS;
    }
        
    // translate the port to a service name (if requested).
    if (pszServiceName && tServiceLength)
    {
        wPort = ((struct sockaddr_in *) ptSocketAddress)->sin_port;
        
        if (iFlags & NI_NUMERICSERV)
        {
            // return numeric form of the address.
            sprintf(szBuffer, "%u", ntohs(wPort));
        }
        else
        {
            // return service name corresponding to port.
            ptService = getservbyport(wPort,
                                      (iFlags & NI_DGRAM) ? "udp" : NULL);
            if (ptService && ptService->s_name)
            {
                // lookup successful.
                pszService = ptService->s_name;
            }
            else
            {
                // DRAFT: return numeric form of the port!
                sprintf(szBuffer, "%u", ntohs(wPort));
            }
        }
        
        
        if (tServiceLength > strlen(pszService))
            strcpy(pszServiceName, pszService);
        else
            return EAI_FAIL;
    }

    
    // translate the address to a node name (if requested).
    if (pszNodeName && tNodeLength)
    {    
        // this is the IPv4-only version, so we have an IPv4 address.
        tAddress = ((struct sockaddr_in *) ptSocketAddress)->sin_addr;

        if (iFlags & NI_NUMERICHOST)
        {
            // return numeric form of the address.
            pszNode  = inet_ntoa(tAddress);
        }
        else
        {
            // return node name corresponding to address.
            ptHost = gethostbyaddr((char *) &tAddress,
                                   sizeof(struct in_addr),
                                   AF_INET);
            if (ptHost && ptHost->h_name)
            {
                // DNS lookup successful.
                // stop copying at a "." if NI_NOFQDN is specified.
                pszNode = ptHost->h_name;
                if ((iFlags & NI_NOFQDN) &&
                    ((pc = strchr(pszNode, '.')) != NULL))
                    *pc = '\0';
            }
            else
            {
                // DNS lookup failed.  return numeric form of the address.
                if (iFlags & NI_NAMEREQD)
                {
                    switch (WSAGetLastError())
                    {
                        case WSAHOST_NOT_FOUND: return EAI_NONAME;
                        case WSATRY_AGAIN:      return EAI_AGAIN;
                        case WSANO_RECOVERY:    return EAI_FAIL;
                        default:                return EAI_NONAME;
                    }
                }
                else
                    pszNode  = inet_ntoa(tAddress);
            }
        }

        if (tNodeLength > strlen(pszNode))
            strcpy(pszNodeName, pszNode);
        else
            return EAI_FAIL;
    }

    return 0;
}



typedef struct 
{
    char const          *pszName;
    FARPROC             pfAddress;
} WSPIAPI_FUNCTION;

#define WSPIAPI_FUNCTION_ARRAY                                  \
{                                                               \
    "getaddrinfo",      (FARPROC) WspiapiLegacyGetAddrInfo,     \
    "getnameinfo",      (FARPROC) WspiapiLegacyGetNameInfo,     \
    "freeaddrinfo",     (FARPROC) WspiapiLegacyFreeAddrInfo,    \
}



__inline
FARPROC
WINAPI
WspiapiLoad(
    IN  WORD                            wFunction)
/*++

Routine Description
    try to locate the address family independent name resolution routines
    (i.e. getaddrinfo, getnameinfo, freeaddrinfo, gai_strerror).
    
Locks
    this function call is not synchronized.  hence the library containing
    the routines might be loaded multiple times.  another option is to
    synchronize through a spin lock using a static local variable and the
    InterlockedExchange operation.  

    
Arguments
    wFunction           ordinal # of the function to get the pointer to
                        0   getaddrinfo
                        1   getnameinfo
                        2   freeaddrinfo
    
Return Value
    address of the library/legacy routine

--*/
{
    HMODULE                 hLibrary        = NULL;

    // these static variables store state across calls, across threads.
    static BOOL             bInitialized    = FALSE;
    static WSPIAPI_FUNCTION rgtGlobal[]     = WSPIAPI_FUNCTION_ARRAY;
    static const int        iNumGlobal      = (sizeof(rgtGlobal) /
                                               sizeof(WSPIAPI_FUNCTION));
    
    // we overwrite rgtGlobal only if all routines exist in library.
    WSPIAPI_FUNCTION        rgtLocal[]      = WSPIAPI_FUNCTION_ARRAY;
    FARPROC                 fScratch        = NULL;
    int                     i               = 0;
    
    
    if (bInitialized)           // WspiapiLoad has already been called once
        return (rgtGlobal[wFunction].pfAddress);

    for (;;)                    // breakout loop
    {
        CHAR SystemDir[MAX_PATH + 1];
        CHAR Path[MAX_PATH + 8];

        if (GetSystemDirectoryA(SystemDir, MAX_PATH) == 0) 
        {
            break;
        }

        // in Whistler and beyond...
        // the routines are present in the WinSock 2 library (ws2_32.dll).
        // printf("Looking in ws2_32 for getaddrinfo...\n");
        strcpy(Path, SystemDir);
        strcat(Path, "\\ws2_32");
        hLibrary = LoadLibraryA(Path);
        if (hLibrary != NULL)
        {
            fScratch = GetProcAddress(hLibrary, "getaddrinfo");
            if (fScratch == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
            }
        }
        if (hLibrary != NULL)
            break;
        

        // in the IPv6 Technology Preview...        
        // the routines are present in the IPv6 WinSock library (wship6.dll).
        // printf("Looking in wship6 for getaddrinfo...\n");
        strcpy(Path, SystemDir);
        strcat(Path, "\\wship6");
        hLibrary = LoadLibraryA(Path);
        if (hLibrary != NULL)
        {
            fScratch = GetProcAddress(hLibrary, "getaddrinfo");
            if (fScratch == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
            }
        }

        break;
    }


    if (hLibrary != NULL)
    {
        // use routines from this library...
        // since getaddrinfo is here, we expect all routines to be here,
        // but will fall back to IPv4-only if any of them is missing.
        for (i = 0; i < iNumGlobal; i++)
        {
            rgtLocal[i].pfAddress
                = GetProcAddress(hLibrary, rgtLocal[i].pszName);
            if (rgtLocal[i].pfAddress == NULL)
            {
                FreeLibrary(hLibrary);
                hLibrary = NULL;
                break;
            }
        }

        if (hLibrary != NULL)
        {
            // printf("found!\n");
            for (i = 0; i < iNumGlobal; i++)
                rgtGlobal[i].pfAddress = rgtLocal[i].pfAddress;
        }
    }
    
    bInitialized = TRUE;
    return (rgtGlobal[wFunction].pfAddress);
}



__inline
int
WINAPI
WspiapiGetAddrInfo(
    IN const char                       *nodename,
    IN const char                       *servname,
    IN const struct addrinfo            *hints,
    OUT struct addrinfo                 **res)
{
    int                             iError;
    static WSPIAPI_PGETADDRINFO     pfGetAddrInfo   = NULL;
    
    if (!pfGetAddrInfo)
        pfGetAddrInfo   = (WSPIAPI_PGETADDRINFO) WspiapiLoad(0);

    iError = (*pfGetAddrInfo)(nodename, servname, hints, res);
    WSASetLastError(iError);
    return iError;
}



__inline
int
WINAPI
WspiapiGetNameInfo (
    IN  const struct sockaddr           *sa,
    IN  socklen_t                       salen,
    OUT char                            *host,
    IN  size_t                          hostlen,
    OUT char                            *serv,
    IN  size_t                          servlen,
    IN  int                             flags)
{
    int                             iError;
    static WSPIAPI_PGETNAMEINFO     pfGetNameInfo   = NULL;
    
    if (!pfGetNameInfo)
        pfGetNameInfo   = (WSPIAPI_PGETNAMEINFO) WspiapiLoad(1);

    iError = (*pfGetNameInfo)(sa, salen, host, hostlen, serv, servlen, flags);
    WSASetLastError(iError);
    return iError;
}



__inline
void
WINAPI
WspiapiFreeAddrInfo (
    IN  struct addrinfo                 *ai)
{
    static WSPIAPI_PFREEADDRINFO    pfFreeAddrInfo   = NULL;

    if (!pfFreeAddrInfo)
        pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);
    (*pfFreeAddrInfo)(ai);
}

#ifdef  __cplusplus
}
#endif

#endif // _WSPIAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsnetbs.h ===
/*
 *   wsnetbs.h
 *   Copyright (c) 1994-1999, Microsoft Corp. All rights reserved.
 *
 *   Windows Sockets include file for NETBIOS.  This file contains all
 *   standardized NETBIOS information.  Include this header file after
 *   winsock.h.
 *
 */

#ifndef _WSNETBS_
#define _WSNETBS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *   This is the structure of the SOCKADDR structure for NETBIOS.
 *
 */

#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb {
    short   snb_family;
    u_short snb_type;
    char    snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB, *PSOCKADDR_NB,FAR *LPSOCKADDR_NB;

/*
 * Bit values for the snb_type field of SOCKADDR_NB.
 *
 */

#define NETBIOS_UNIQUE_NAME         (0x0000)
#define NETBIOS_GROUP_NAME          (0x0001)
#define NETBIOS_TYPE_QUICK_UNIQUE   (0x0002)
#define NETBIOS_TYPE_QUICK_GROUP    (0x0003)

/*
 * A macro convenient for setting up NETBIOS SOCKADDRs.
 *
 */

#define SET_NETBIOS_SOCKADDR(_snb,_type,_name,_port)                          \
    {                                                                         \
        int _i;                                                               \
        (_snb)->snb_family = AF_NETBIOS;                                      \
        (_snb)->snb_type = (_type);                                           \
        for (_i=0; _i<NETBIOS_NAME_LENGTH-1; _i++) {                          \
            (_snb)->snb_name[_i] = ' ';                                       \
        }                                                                     \
        for (_i=0; *((_name)+_i) != '\0' && _i<NETBIOS_NAME_LENGTH-1; _i++) { \
            (_snb)->snb_name[_i] = *((_name)+_i);                             \
        }                                                                     \
        (_snb)->snb_name[NETBIOS_NAME_LENGTH-1] = (_port);                    \
    }

/*
 *   To open a NetBIOS socket, call the socket() function as follows:
 *
 *       s = socket( AF_NETBIOS, {SOCK_SEQPACKET|SOCK_DGRAM}, -Lana );
 *
 *   where Lana is the NetBIOS Lana number of interest.  For example, to
 *   open a socket for Lana 2, specify -2 as the "protocol" parameter
 *   to the socket() function.
 *
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsrm.h ===
/*	
**	wsrm.h - winsock extension for Reliable Multicast (RMCast) Transport
**
**	This file contains PGM specific information for use by WinSock2 compatible
**  applications that need Reliable Multicast Transport.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**	Created: Mar 12, 2000
**
*/

#ifndef _WSRM_H_
#define _WSRM_H_


#define IPPROTO_RM      113
#define MAX_MCAST_TTL   255

//
// options for setsockopt, getsockopt
//
#define RM_OPTIONSBASE      1000

// Set/Query rate (Kb/Sec) + window size (Kb and/or MSec) -- described by RM_SEND_WINDOW below
#define RM_RATE_WINDOW_SIZE             (RM_OPTIONSBASE + 1)

// Set the size of the next message -- (ULONG)
#define RM_SET_MESSAGE_BOUNDARY         (RM_OPTIONSBASE + 2)

// flush the entire data (window) right now -- not implemented
#define RM_FLUSHCACHE                   (RM_OPTIONSBASE + 3)

// Set or Query the window advance method on the sender -- methods enumerated in eWINDOW_ADVANCE_METHOD
#define RM_SENDER_WINDOW_ADVANCE_METHOD (RM_OPTIONSBASE + 4)

// get sender statistics
#define RM_SENDER_STATISTICS            (RM_OPTIONSBASE + 5)

// allow a late-joiner to NAK any packet upto the lowest sequence Id
#define RM_LATEJOIN                     (RM_OPTIONSBASE + 6)

// set IP multicast outgoing interface
#define RM_SET_SEND_IF                  (RM_OPTIONSBASE + 7)

// add IP multicast incoming interface
#define RM_ADD_RECEIVE_IF               (RM_OPTIONSBASE + 8)

// delete IP multicast incoming interface
#define RM_DEL_RECEIVE_IF               (RM_OPTIONSBASE + 9)

// Set/Query the Window's Advance rate (has to be less that MAX_WINDOW_INCREMENT_PERCENTAGE)
#define RM_SEND_WINDOW_ADV_RATE         (RM_OPTIONSBASE + 10)

// Instruct to use parity-based forward error correction schemes
#define RM_USE_FEC                      (RM_OPTIONSBASE + 11)

// Set the Ttl of the MCast packets -- (ULONG)
#define RM_SET_MCAST_TTL                (RM_OPTIONSBASE + 12)

// get receiver statistics
#define RM_RECEIVER_STATISTICS          (RM_OPTIONSBASE + 13)

// get receiver statistics
#define RM_HIGH_SPEED_INTRANET_OPT      (RM_OPTIONSBASE + 14)

//==============================================================
//
// Definitions
//
#define     SENDER_DEFAULT_RATE_KBITS_PER_SEC        56             // 56 Kbits/Sec
#define     SENDER_DEFAULT_WINDOW_SIZE_BYTES         10 *1000*1000  // 10 Megs

#define     SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE     15             // 15%
#define     MAX_WINDOW_INCREMENT_PERCENTAGE          25             // 25%

#define     SENDER_DEFAULT_LATE_JOINER_PERCENTAGE    0              // 0%
#define     SENDER_MAX_LATE_JOINER_PERCENTAGE        75             // 75%

#define     BITS_PER_BYTE                             8
#define     LOG2_BITS_PER_BYTE                        3

enum eWINDOW_ADVANCE_METHOD
{
    E_WINDOW_ADVANCE_BY_TIME = 1,       // Default mode
    E_WINDOW_USE_AS_DATA_CACHE
};

//==============================================================
//
// Structures
//
typedef struct _RM_SEND_WINDOW
{
    ULONG   RateKbitsPerSec;            // Send rate
    ULONG   WindowSizeInMSecs;
    ULONG   WindowSizeInBytes;
} RM_SEND_WINDOW;

typedef struct _RM_SENDER_STATS
{
    ULONGLONG   DataBytesSent;          // # client data bytes sent out so far
    ULONGLONG   TotalBytesSent;         // SPM, OData and RData bytes
    ULONGLONG   NaksReceived;           // # NAKs received so far
    ULONGLONG   NaksReceivedTooLate;    // # NAKs recvd after window advanced
    ULONGLONG   NumOutstandingNaks;     // # NAKs yet to be responded to
    ULONGLONG   NumNaksAfterRData;      // # NAKs yet to be responded to
    ULONGLONG   RepairPacketsSent;      // # Repairs (RDATA) sent so far
    ULONGLONG   BufferSpaceAvailable;   // # partial messages dropped
    ULONGLONG   TrailingEdgeSeqId;      // smallest (oldest) Sequence Id in the window
    ULONGLONG   LeadingEdgeSeqId;       // largest (newest) Sequence Id in the window
    ULONGLONG   RateKBitsPerSecOverall; // Internally calculated send-rate from the beginning
    ULONGLONG   RateKBitsPerSecLast;    // Send-rate calculated every INTERNAL_RATE_CALCULATION_FREQUENCY
    ULONGLONG   TotalODataPacketsSent;  // # ODATA packets sent so far
} RM_SENDER_STATS;


typedef struct _RM_RECEIVER_STATS
{
    ULONGLONG   NumODataPacketsReceived;// # OData sequences received
    ULONGLONG   NumRDataPacketsReceived;// # RData sequences received
    ULONGLONG   NumDuplicateDataPackets;// # RData sequences received

    ULONGLONG   DataBytesReceived;      // # client data bytes received out so far
    ULONGLONG   TotalBytesReceived;     // SPM, OData and RData bytes
    ULONGLONG   RateKBitsPerSecOverall; // Internally calculated Receive-rate from the beginning
    ULONGLONG   RateKBitsPerSecLast;    // Receive-rate calculated every INTERNAL_RATE_CALCULATION_FREQUENCY

    ULONGLONG   TrailingEdgeSeqId;      // smallest (oldest) Sequence Id in the window
    ULONGLONG   LeadingEdgeSeqId;       // largest (newest) Sequence Id in the window
    ULONGLONG   AverageSequencesInWindow;
    ULONGLONG   MinSequencesInWindow;
    ULONGLONG   MaxSequencesInWindow;

    ULONGLONG   FirstNakSequenceNumber; // # First Outstanding Nak
    ULONGLONG   NumPendingNaks;         // # Sequences waiting for Ncfs
    ULONGLONG   NumOutstandingNaks;     // # Sequences for which Ncfs have been received, but no data
    ULONGLONG   NumDataPacketsBuffered; // # Data packets currently buffered by transport
    ULONGLONG   TotalSelectiveNaksSent; // # Selective NAKs sent so far
    ULONGLONG   TotalParityNaksSent;    // # Parity NAKs sent so far
} RM_RECEIVER_STATS;


typedef struct _RM_FEC_INFO
{
    USHORT              FECBlockSize;
    USHORT              FECProActivePackets;
    UCHAR               FECGroupSize;
    BOOLEAN             fFECOnDemandParityEnabled;
} RM_FEC_INFO;

#endif  /* _WSRM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wsvns.h ===
/*******************************************************************************
 *
 *   wsvns.h
 *
 *  Copyright (C) Microsoft Corporation, 1992-1999.
 *
 *   Windows Sockets include file for VINES IP.  This file contains all
 *   standardized VINES IP information.  Include this header file after
 *   winsock.h.
 *
 *   To open an VINES IP socket, call socket() with an address family of
 *   AF_BAN, a socket type of SOCK_DGRAM, SOCK_STREAM, or SOCK_SEQPACKET,
 *   and protocol of 0.
 *
 ******************************************************************************/

#ifndef _WSVNS_
#define _WSVNS_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Socket address, VINES IP style.  Address fields and port field are defined
 * as a sequence of bytes.  This is done because they are byte ordered
 * BIG ENDIAN, ala most significant byte first.
 */
typedef struct sockaddr_vns {
    u_short sin_family;			// = AF_BAN
    u_char  net_address[4];		// network address
    u_char  subnet_addr[2];		// subnet address
    u_char  port[2];			// msb=port[0], lsb=port[1]
    u_char  hops;			// # hops for broadcasts
    u_char  filler[5];			// filler, zeros
} SOCKADDR_VNS, *PSOCKADDR_VNS, FAR *LPSOCKADDR_VNS;

#define VNSPROTO_IPC		1
#define VNSPROTO_RELIABLE_IPC	2
#define VNSPROTO_SPP		3


#endif _WSVNS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wx86ofl.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wx86ofl.h

Abstract:

    Wx86 On-The-Fly declarations/definitions.

Revision History:

    06-Jun-1998 CBiks   Created

--*/

#ifndef WX86OFL_INCLUDED
#define WX86OFL_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef WX86

#include <unknwn.h>

#ifdef __cplusplus
extern "C" {
#endif

// Each successful call to Wx86Load must be matched with a call to
// Wx86Unload()

BOOL Wx86Load();
void Wx86Unload();

// The following functions require wx86.dll to have been loaded

UINT Wx86Callback(PROC pfnCallBack, HWND hwnd, UINT uMsg, LPARAM lParam);

PVOID Wx86ThunkProc(PVOID pvAddress, PVOID pvCBDispatch, BOOL  fNativeToX86 );

PVOID Wx86DualThunkProc(PVOID pvAddress, PVOID pvCBDispatch, BOOL  fNativeToX86 );

ULONG Wx86EmulateX86(PVOID pvAddress, ULONG  nParameters, PULONG Parameters);

ULONGLONG Wx86EmulateX86GetQWord(PVOID pvAddress, ULONG  nParameters,
                                 PULONG Parameters);

IUnknown* Wx86ThunkInterface(IUnknown *punk, IID *piid,
                             BOOLEAN fOutParameter, BOOLEAN fNativeToX86);

void Wx86CheckFreeTempProxy(IUnknown *punk);

IUnknown* Wx86ResolveProxy(IUnknown *punk, BOOLEAN fNativeToX86);

HRESULT Wx86DllGetClassObjectThunk(IID *piid, LPVOID *ppv, HRESULT hr,
                                   BOOLEAN fNativetoX86);

ULONG Wx86ProxyAddRef(IUnknown* punk);

ULONG Wx86ProxyRelease(IUnknown* punk);


// Wx86LoadX86Dll is retained for backward compatibility

HMODULE Wx86LoadX86Dll(LPCWSTR lpLibFileName, DWORD dwFlags);

BOOL Wx86FreeX86Dll(HMODULE hMod);

// Wx86LoadX86Library is ifdef'd for UNICODE and non-UNICODE. This has been
// added for compatibility with other Win32 functions as well as the functions
// below. We cannot reuse the name Wx86LoadX86Dll because it is already defined
// in wx86dll.h and will require cleaning up the code of all apps that use that
// function
//
// At some point, this should be cleaned up and wx86dll.h should be eliminated.
// A clean build will be required then.

HMODULE Wx86LoadX86LibraryA(LPCSTR lpLibFileName, DWORD dwFlags);
#define Wx86LoadX86LibraryW Wx86LoadX86Dll

#ifdef UNICODE
#define Wx86LoadX86Library  Wx86LoadX86LibraryW
#else
#define Wx86LoadX86Library  Wx86LoadX86LibraryA
#endif // !UNICODE


#define Wx86FreeX86Library Wx86FreeX86Dll

//
// The following functions do not require wx86.dll to be loaded
//

//
// GetModuleHandle returns 0 if a native apps calls it with an x86 dll name.
// This function will return the x86 dll's module handle.

HMODULE Wx86GetX86ModuleHandleA(LPCSTR szDll);
HMODULE Wx86GetX86ModuleHandleW(LPCWSTR szDll);

#ifdef UNICODE
#define Wx86GetX86ModuleHandle  Wx86GetX86ModuleHandleW
#else
#define Wx86GetX86ModuleHandle  Wx86GetX86ModuleHandleA
#endif // !UNICODE

UINT Wx86GetX86SystemDirectoryA(LPSTR lpBuffer, UINT nSize);
UINT Wx86GetX86SystemDirectoryW(LPWSTR lpBuffer, UINT nSize);

#ifdef UNICODE
#define Wx86GetX86SystemDirectory  Wx86GetX86SystemDirectoryW
#else
#define Wx86GetX86SystemDirectory  Wx86GetX86SystemDirectoryA
#endif // !UNICODE

BOOL Wx86SuppressHardErrors(BOOL bSuppressHardErrors);

BOOL Wx86IsCallThunked(VOID);


BOOL Wx86UseKnownWx86Dll(BOOL bUseKnownWx86Dll);

//
// Helper functions for Wx86 plugin providers
//

typedef
BOOLEAN
(*WX86ENUMEXPORTCALLBACK)(
    PVOID DllBase,      // same as DllBase above
    PVOID Context,      // same as Context above
    PCHAR ExportName,   // Name of Export (NULL if noname)
    ULONG Ordinal       // Ordinal of Export
    );

BOOL
Wx86EnumExports(
    IN PVOID DllBase,
    IN PVOID Context,
    IN WX86ENUMEXPORTCALLBACK CallBackRtn
    );

//
// Registry thunking APIs
//

LONG
Wx86RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG
Wx86RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG
Wx86RegDeleteKeyA(
    HKEY hKey,
    LPCSTR lpKeyName
    );

LONG
Wx86RegDeleteKeyW(
    HKEY hKey,
    LPCWSTR lpKeyName
    );

LONG
Wx86RegEnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );

LONG
Wx86RegEnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

LONG
Wx86RegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
Wx86RegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
Wx86RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
Wx86RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
Wx86RegQueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );

LONG
Wx86RegQueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    );

LONG
Wx86RegQueryValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegQueryValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegSetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
Wx86RegSetValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
Wx86RegDeleteValueA(
    HKEY hKey,
    LPCSTR lpValueName
    );

LONG
Wx86RegDeleteValueW(
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG
Wx86RegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
Wx86RegQueryMultipleValuesA(
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

LONG
Wx86RegQueryMultipleValuesW(
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

LONG
Wx86RegCloseKey(
    HKEY hKey
    );

#if defined(UNICODE)

#define Wx86RegCreateKey            Wx86RegCreateKeyA
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExA
#define Wx86RegDeleteKey            Wx86RegDeleteKeyA
#define Wx86RegEnumKey              Wx86RegEnumKeyA
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExA
#define Wx86RegOpenKey              Wx86RegOpenKeyA
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExA
#define Wx86RegQueryValue           Wx86RegQueryValueA
#define Wx86RegQueryValueEx         Wx86RegQueryValueExA
#define Wx86RegSetValue             Wx86RegSetValueA
#define Wx86RegSetValueEx           Wx86RegSetValueExA
#define Wx86RegDeleteValue          Wx86RegDeleteValueA
#define Wx86RegEnumValue            Wx86RegEnumValueA
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesA

#else

#define Wx86RegCreateKey            Wx86RegCreateKeyW
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExW
#define Wx86RegDeleteKey            Wx86RegDeleteKeyW
#define Wx86RegEnumKey              Wx86RegEnumKeyW
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExW
#define Wx86RegOpenKey              Wx86RegOpenKeyW
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExW
#define Wx86RegQueryValue           Wx86RegQueryValueW
#define Wx86RegQueryValueEx         Wx86RegQueryValueExW
#define Wx86RegSetValue             Wx86RegSetValueW
#define Wx86RegSetValueEx           Wx86RegSetValueExW
#define Wx86RegDeleteValue          Wx86RegDeleteValueW
#define Wx86RegEnumValue            Wx86RegEnumValueW
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesW

#endif


#ifdef __cplusplus
};
#endif

#endif // WX86

#endif // WX86OFL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wx86dll.h ===
/************************************************************************
*                                                                       *
*   wx86dll.h -- This module defines Wx86 APIs for x86 emulation        *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _WX86DLL_
#define _WX86DLL_

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_WX86DLLAPI_)
#define WX86DLLAPI DECLSPEC_IMPORT
#else
#define WX86DLLAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _BopInstr {
    BYTE    Instr1;         // 0xc4c4 - the x86 BOP instruction
    BYTE    Instr2;
    BYTE    BopNum;
    BYTE    Flags;
    USHORT  ApiNum;
    BYTE    RetSize;
    BYTE    ArgSize;
} BOPINSTR;
typedef UNALIGNED BOPINSTR * PBOPINSTR;


typedef
BOOL
(*WX86OFLYINITIALIZE_ROUTINE)(
    VOID
    );

WX86DLLAPI
BOOL
Wx86OFlyInitialize(
    VOID
    );

WX86DLLAPI
HMODULE
Wx86LoadX86Dll(
    LPCWSTR lpLibFileName,
    DWORD   dwFlags
    );

typedef
HMODULE
(*WX86LOADX86DLL_ROUTINE)(
  LPCWSTR lpLibFileName,
  DWORD   dwFlags
  );

WX86DLLAPI
HMODULE
Wx86GetX86DllHandle(
    LPCWSTR lpLibFileName
    );

typedef
HMODULE
(*WX86GETX86DLLHANDLE_ROUTINE)(
  LPCWSTR lpLibFileName
  );

WX86DLLAPI
BOOL
Wx86FreeX86Dll(
    HMODULE hMod
    );

typedef
BOOL
(*WX86FREEX86Dll_ROUTINE)(
    HMODULE hMod
    );

WX86DLLAPI
BOOL
Wx86Compact(
    VOID
    );

typedef
BOOL
(*WX86COMPACT_ROUTINE)(
    VOID
    );

WX86DLLAPI
PVOID
Wx86ThunkProc(
    PVOID pvAddress,
    PVOID pvCBDispatch,
    BOOL  fNativeToX86
    );

WX86DLLAPI
PVOID
Wx86DualThunkProc(
    PVOID pvAddress,
    PVOID pvCBDispatch,
    BOOL  fNativeToX86
    );

typedef
PVOID
(*WX86THUNKPROC_ROUTINE)(
  PVOID pvAddress,
  PVOID pvCBDispatch,
  BOOL  fNativeToX86
  );

typedef
ULONG
(*X86TONATIVETHUNKPROC)(
    PVOID  pvNativeAddress,
    PULONG pBaseArgs,
    PULONG pArgCount
    );

WX86DLLAPI
ULONG
Wx86ThunkEmulateX86(
    ULONG  nParameters,
    PULONG Parameters
    );

typedef
ULONG
(*WX86THUNKEMULATEX86)(
    ULONG  nParameters,
    PULONG Parameters
    );

WX86DLLAPI
ULONG
Wx86EmulateX86(
    PVOID  StartAddress,
    ULONG  nParameters,
    PULONG Parameters
    );

typedef
ULONG
(*WX86EMULATEX86)(
    PVOID  StartAddress,
    ULONG  nParameters,
    PULONG Parameters
    );

WX86DLLAPI
IUnknown *
Wx86ThunkInterface(
    IUnknown *punk,
    IID *piid,
    BOOLEAN fOutParameter,
    BOOLEAN fNativeToX86
    );

typedef
IUnknown *
(*WX86THUNKINTERFACE)(
    IUnknown *punk,
    IID *piid,
    BOOL  fOutParameter,
    BOOL  fNativeToX86
    );

WX86DLLAPI
void
Wx86CheckFreeTempProxy(
    IUnknown *punk
    );

typedef
void
(*WX86CHECKFREETEMPPROXY)(
    IUnknown *punk
    );

WX86DLLAPI
IUnknown *
Wx86ResolveProxy(
    IUnknown *punk,
    BOOLEAN fNativeToX86);

typedef
IUnknown *
(*WX86RESOLVEPROXY)(
    IUnknown *punk,
    BOOLEAN fNativeToX86);

WX86DLLAPI
ULONG
Wx86ProxyAddRef(IUnknown* punk);

typedef
ULONG
(*WX86PROXYADDREF)(
    IUnknown *punk);


WX86DLLAPI
ULONG
Wx86ProxyRelease(IUnknown* punk);

typedef
ULONG
(*WX86PROXYRELEASE)(
    IUnknown *punk);

WX86DLLAPI
HRESULT
Wx86DllGetClassObjectThunk(
    IID *piid,
    LPVOID *ppv,
    HRESULT hr,
    BOOLEAN fNativetoX86);

typedef
HRESULT
(*WX86DLLGETCLASSOBJECTTHUNK)(
    IID *piid,
    LPVOID *ppv,
    HRESULT hr,
    BOOLEAN fNativetoX86);

WX86DLLAPI
PVOID *
Wx86InitializeOle(
    VOID
    );

typedef
PVOID *
(*W86INITIALIZEOLE)(
    VOID
    );

WX86DLLAPI
void
Wx86DeinitializeOle(
    VOID
    );

VOID
WX86DEINITIALIZEOLE(
    VOID
    );


WX86DLLAPI
LONG
Wx86RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

WX86DLLAPI
LONG
Wx86RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

WX86DLLAPI
LONG
Wx86RegDeleteKeyA(
    HKEY hKey,
    LPCSTR lpKeyName
    );

WX86DLLAPI
LONG
Wx86RegDeleteKeyW(
    HKEY hKey,
    LPCWSTR lpKeyName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

WX86DLLAPI
LONG
Wx86RegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

WX86DLLAPI
LONG
Wx86RegQueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegSetValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

WX86DLLAPI
LONG
Wx86RegDeleteValueA(
    HKEY hKey,
    LPCSTR lpValueName
    );

WX86DLLAPI
LONG
Wx86RegDeleteValueW(
    HKEY hKey,
    LPCWSTR lpValueName
    );

WX86DLLAPI
LONG
Wx86RegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

WX86DLLAPI
LONG
Wx86RegQueryMultipleValuesA(
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

WX86DLLAPI
LONG
Wx86RegQueryMultipleValuesW(
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

WX86DLLAPI
LONG
Wx86RegCloseKey(
    HKEY hKey
    );

#ifdef UNICODE

#define Wx86RegCreateKey            Wx86RegCreateKeyA
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExA
#define Wx86RegDeleteKey            Wx86RegDeleteKeyA
#define Wx86RegEnumKey              Wx86RegEnumKeyA
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExA
#define Wx86RegOpenKey              Wx86RegOpenKeyA
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExA
#define Wx86RegQueryValue           Wx86RegQueryValueA
#define Wx86RegQueryValueEx         Wx86RegQueryValueExA
#define Wx86RegSetValue             Wx86RegSetValueA
#define Wx86RegSetValueEx           Wx86RegSetValueExA
#define Wx86RegDeleteValue          Wx86RegDeleteValueA
#define Wx86RegEnumValue            Wx86RegEnumValueA
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesA

#else

#define Wx86RegCreateKey            Wx86RegCreateKeyW
#define Wx86RegCreateKeyEx          Wx86RegCreateKeyExW
#define Wx86RegDeleteKey            Wx86RegDeleteKeyW
#define Wx86RegEnumKey              Wx86RegEnumKeyW
#define Wx86RegEnumKeyEx            Wx86RegEnumKeyExW
#define Wx86RegOpenKey              Wx86RegOpenKeyW
#define Wx86RegOpenKeyEx            Wx86RegOpenKeyExW
#define Wx86RegQueryValue           Wx86RegQueryValueW
#define Wx86RegQueryValueEx         Wx86RegQueryValueExW
#define Wx86RegSetValue             Wx86RegSetValueW
#define Wx86RegSetValueEx           Wx86RegSetValueExW
#define Wx86RegDeleteValue          Wx86RegDeleteValueW
#define Wx86RegEnumValue            Wx86RegEnumValueW
#define Wx86RegQueryMultipleValues  Wx86RegQueryMultipleValuesW

#endif

#ifdef __cplusplus
}
#endif


#endif // _WX86DLL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtsapi32.h ===
/*********************************************************************
*
* WTSAPI32.H
*
*   Windows Terminal Server public APIs
*
*   Copyright (c) 1997-2001 Microsoft Corporation
*
**********************************************************************/

#ifndef _INC_WTSAPI
#define _INC_WTSAPI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*===================================================================
==   Defines
=====================================================================*/

/*
 *  Specifies the current server
 */
#define WTS_CURRENT_SERVER         ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_HANDLE  ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_NAME    (NULL)

/*
 *  Specifies the current session (SessionId)
 */
#define WTS_CURRENT_SESSION ((DWORD)-1)

/*
 *  Possible pResponse values from WTSSendMessage()
 */
#ifndef IDTIMEOUT
#define IDTIMEOUT 32000
#endif
#ifndef IDASYNC
#define IDASYNC   32001
#endif

/*
 *  Shutdown flags
 */
#define WTS_WSD_LOGOFF      0x00000001  // log off all users except
                                        // current user; deletes
                                        // WinStations (a reboot is
                                        // required to recreate the
                                        // WinStations)
#define WTS_WSD_SHUTDOWN    0x00000002  // shutdown system
#define WTS_WSD_REBOOT      0x00000004  // shutdown and reboot
#define WTS_WSD_POWEROFF    0x00000008  // shutdown and power off (on
                                        // machines that support power
                                        // off through software)
#define WTS_WSD_FASTREBOOT  0x00000010  // reboot without logging users
                                        // off or shutting down


/*===================================================================
==   WTS_CONNECTSTATE_CLASS - Session connect state
=====================================================================*/

typedef enum _WTS_CONNECTSTATE_CLASS {
    WTSActive,              // User logged on to WinStation
    WTSConnected,           // WinStation connected to client
    WTSConnectQuery,        // In the process of connecting to client
    WTSShadow,              // Shadowing another WinStation
    WTSDisconnected,        // WinStation logged on without client
    WTSIdle,                // Waiting for client to connect
    WTSListen,              // WinStation is listening for connection
    WTSReset,               // WinStation is being reset
    WTSDown,                // WinStation is down due to error
    WTSInit,                // WinStation in initialization
} WTS_CONNECTSTATE_CLASS;


/*=====================================================================
==   WTS_SERVER_INFO - returned by WTSEnumerateServers (version 1)
=====================================================================*/

/*
 *  WTSEnumerateServers() returns two variables: pServerInfo and Count.
 *  The latter is the number of WTS_SERVER_INFO structures contained in
 *  the former.  In order to read each server, iterate i from 0 to
 *  Count-1 and reference the server name as
 *  pServerInfo[i].pServerName; for example:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      _tprintf( TEXT("%s "), pServerInfo[i].pServerName );
 *  }
 *
 *  The memory returned looks like the following.  P is a pServerInfo
 *  pointer, and D is the string data for that pServerInfo:
 *
 *  P1 P2 P3 P4 ... Pn D1 D2 D3 D4 ... Dn
 *
 *  This makes it easier to iterate the servers, using code similar to
 *  the above.
 */

typedef struct _WTS_SERVER_INFOW {
    LPWSTR pServerName;    // server name
} WTS_SERVER_INFOW, * PWTS_SERVER_INFOW;

typedef struct _WTS_SERVER_INFOA {
    LPSTR pServerName;     // server name
} WTS_SERVER_INFOA, * PWTS_SERVER_INFOA;

#ifdef UNICODE
#define WTS_SERVER_INFO  WTS_SERVER_INFOW
#define PWTS_SERVER_INFO PWTS_SERVER_INFOW
#else
#define WTS_SERVER_INFO  WTS_SERVER_INFOA
#define PWTS_SERVER_INFO PWTS_SERVER_INFOA
#endif


/*=====================================================================
==   WTS_SESSION_INFO - returned by WTSEnumerateSessions (version 1)
=====================================================================*/

/*
 *  WTSEnumerateSessions() returns data in a similar format to the above
 *  WTSEnumerateServers().  It returns two variables: pSessionInfo and
 *  Count.  The latter is the number of WTS_SESSION_INFO structures
 *  contained in the former.  Iteration is similar, except that there
 *  are three parts to each entry, so it would look like this:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      _tprintf( TEXT("%-5u  %-20s  %u\n"),
                  pSessionInfo[i].SessionId,
 *                pSessionInfo[i].pWinStationName,
 *                pSessionInfo[i].State );
 *  }
 *
 *  The memory returned is also segmented as the above, with all the
 *  structures allocated at the start and the string data at the end.
 *  We'll use S for the SessionId, P for the pWinStationName pointer
 *  and D for the string data, and C for the connect State:
 *
 *  S1 P1 C1 S2 P2 C2 S3 P3 C3 S4 P4 C4 ... Sn Pn Cn D1 D2 D3 D4 ... Dn
 *
 *  As above, this makes it easier to iterate the sessions.
 */

typedef struct _WTS_SESSION_INFOW {
    DWORD SessionId;             // session id
    LPWSTR pWinStationName;      // name of WinStation this session is
                                 // connected to
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
} WTS_SESSION_INFOW, * PWTS_SESSION_INFOW;

typedef struct _WTS_SESSION_INFOA {
    DWORD SessionId;             // session id
    LPSTR pWinStationName;       // name of WinStation this session is
                                 // connected to
    WTS_CONNECTSTATE_CLASS State; // connection state (see enum)
} WTS_SESSION_INFOA, * PWTS_SESSION_INFOA;


#ifdef UNICODE
#define WTS_SESSION_INFO  WTS_SESSION_INFOW
#define PWTS_SESSION_INFO PWTS_SESSION_INFOW
#else
#define WTS_SESSION_INFO  WTS_SESSION_INFOA
#define PWTS_SESSION_INFO PWTS_SESSION_INFOA
#endif


/*=====================================================================
==   WTS_PROCESS_INFO - returned by WTSEnumerateProcesses (version 1)
=====================================================================*/

/*
 *  WTSEnumerateProcesses() also returns data similar to
 *  WTSEnumerateServers().  It returns two variables: pProcessInfo and
 *  Count.  The latter is the number of WTS_PROCESS_INFO structures
 *  contained in the former.  Iteration is similar, except that there
 *  are four parts to each entry, so it would look like this:
 *
 *  for ( i=0; i < Count; i++ ) {
 *      GetUserNameFromSid( pProcessInfo[i].pUserSid, UserName,
 *                          sizeof(UserName) );
 *      _tprintf( TEXT("%-5u  %-20s  %-5u  %s\n"),
 *              pProcessInfo[i].SessionId,
 *              UserName,
 *              pProcessInfo[i].ProcessId,
 *              pProcessInfo[i].pProcessName );
 *  }
 *
 *  The memory returned is also segmented as the above, with all the
 *  structures allocated at the start and the string data at the end.
 *  We'll use S for the SessionId, R for the ProcessId, P for the
 *  pProcessName pointer and D for the string data, and U for pUserSid:
 *
 *  S1 R1 P1 U1 S2 R2 P2 U2 S3 R3 P3 U3 ... Sn Rn Pn Un D1 D2 D3 ... Dn
 *
 *  As above, this makes it easier to iterate the processes.
 */

typedef struct _WTS_PROCESS_INFOW {
    DWORD SessionId;     // session id
    DWORD ProcessId;     // process id
    LPWSTR pProcessName; // name of process
    PSID pUserSid;       // user's SID
} WTS_PROCESS_INFOW, * PWTS_PROCESS_INFOW;

typedef struct _WTS_PROCESS_INFOA {
    DWORD SessionId;     // session id
    DWORD ProcessId;     // process id
    LPSTR pProcessName;  // name of process
    PSID pUserSid;       // user's SID
} WTS_PROCESS_INFOA, * PWTS_PROCESS_INFOA;

#ifdef UNICODE
#define WTS_PROCESS_INFO  WTS_PROCESS_INFOW
#define PWTS_PROCESS_INFO PWTS_PROCESS_INFOW
#else
#define WTS_PROCESS_INFO  WTS_PROCESS_INFOA
#define PWTS_PROCESS_INFO PWTS_PROCESS_INFOA
#endif


/*=====================================================================
==   WTS_INFO_CLASS - WTSQuerySessionInformation
==    (See additional typedefs for more info on structures)
=====================================================================*/

#define WTS_PROTOCOL_TYPE_CONSOLE         0    // Console
#define WTS_PROTOCOL_TYPE_ICA             1    // ICA Protocol
#define WTS_PROTOCOL_TYPE_RDP             2    // RDP Protocol

typedef enum _WTS_INFO_CLASS {
    WTSInitialProgram,
    WTSApplicationName,
    WTSWorkingDirectory,
    WTSOEMId,
    WTSSessionId,
    WTSUserName,
    WTSWinStationName,
    WTSDomainName,
    WTSConnectState,
    WTSClientBuildNumber,
    WTSClientName,
    WTSClientDirectory,
    WTSClientProductId,
    WTSClientHardwareId,
    WTSClientAddress,
    WTSClientDisplay,
    WTSClientProtocolType,
} WTS_INFO_CLASS;


/*=====================================================================
==   WTSQuerySessionInformation - (WTSClientAddress)
=====================================================================*/

typedef struct _WTS_CLIENT_ADDRESS {
    DWORD AddressFamily;  // AF_INET, AF_IPX, AF_NETBIOS, AF_UNSPEC
    BYTE  Address[20];    // client network address
} WTS_CLIENT_ADDRESS, * PWTS_CLIENT_ADDRESS;


/*=====================================================================
==   WTSQuerySessionInformation - (WTSClientDisplay)
=====================================================================*/

typedef struct _WTS_CLIENT_DISPLAY {
    DWORD HorizontalResolution; // horizontal dimensions, in pixels
    DWORD VerticalResolution;   // vertical dimensions, in pixels
    DWORD ColorDepth;           // 1=16, 2=256, 4=64K, 8=16M
} WTS_CLIENT_DISPLAY, * PWTS_CLIENT_DISPLAY;


/*=====================================================================
==   WTS_CONFIG_CLASS - WTSQueryUserConfig/WTSSetUserConfig
=====================================================================*/


typedef enum _WTS_CONFIG_CLASS {
    //Initial program settings
    WTSUserConfigInitialProgram,            // string returned/expected
    WTSUserConfigWorkingDirectory,          // string returned/expected
    WTSUserConfigfInheritInitialProgram,    // DWORD returned/expected
    //
    WTSUserConfigfAllowLogonTerminalServer,     //DWORD returned/expected
    //Timeout settings
    WTSUserConfigTimeoutSettingsConnections,    //DWORD returned/expected
    WTSUserConfigTimeoutSettingsDisconnections, //DWORD returned/expected
    WTSUserConfigTimeoutSettingsIdle,           //DWORD returned/expected
    //Client device settings
    WTSUserConfigfDeviceClientDrives,       //DWORD returned/expected
    WTSUserConfigfDeviceClientPrinters,         //DWORD returned/expected
    WTSUserConfigfDeviceClientDefaultPrinter,   //DWORD returned/expected
    //Connection settings
    WTSUserConfigBrokenTimeoutSettings,         //DWORD returned/expected
    WTSUserConfigReconnectSettings,             //DWORD returned/expected
    //Modem settings
    WTSUserConfigModemCallbackSettings,         //DWORD returned/expected
    WTSUserConfigModemCallbackPhoneNumber,      // string returned/expected
    //Shadow settings
    WTSUserConfigShadowingSettings,             //DWORD returned/expected
    //User Profile settings
    WTSUserConfigTerminalServerProfilePath,     // string returned/expected
    //Terminal Server home directory
    WTSUserConfigTerminalServerHomeDir,       // string returned/expected
    WTSUserConfigTerminalServerHomeDirDrive,    // string returned/expected
    WTSUserConfigfTerminalServerRemoteHomeDir,  // DWORD 0:LOCAL 1:REMOTE

} WTS_CONFIG_CLASS;


/*=====================================================================
==   WTS_EVENT - Event flags for WTSWaitSystemEvent
=====================================================================*/

#define WTS_EVENT_NONE         0x00000000 // return no event
#define WTS_EVENT_CREATE       0x00000001 // new WinStation created
#define WTS_EVENT_DELETE       0x00000002 // existing WinStation deleted
#define WTS_EVENT_RENAME       0x00000004 // existing WinStation renamed
#define WTS_EVENT_CONNECT      0x00000008 // WinStation connect to client
#define WTS_EVENT_DISCONNECT   0x00000010 // WinStation logged on without
                                          //     client
#define WTS_EVENT_LOGON        0x00000020 // user logged on to existing
                                          //     WinStation
#define WTS_EVENT_LOGOFF       0x00000040 // user logged off from
                                          //     existing WinStation
#define WTS_EVENT_STATECHANGE  0x00000080 // WinStation state change
#define WTS_EVENT_LICENSE      0x00000100 // license state change
#define WTS_EVENT_ALL          0x7fffffff // wait for all event types
#define WTS_EVENT_FLUSH        0x80000000 // unblock all waiters

/*=====================================================================
==   WTS_VIRTUAL_CLASS - WTSVirtualChannelQuery
=====================================================================*/
typedef enum _WTS_VIRTUAL_CLASS {
    WTSVirtualClientData,  // Virtual channel client module data
                           //     (C2H data)
    WTSVirtualFileHandle
} WTS_VIRTUAL_CLASS;


/*=====================================================================
==   Windows Terminal Server public APIs
=====================================================================*/

BOOL
WINAPI
WTSEnumerateServersW(
    IN LPWSTR pDomainName,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SERVER_INFOW * ppServerInfo,
    OUT DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateServersA(
    IN LPSTR pDomainName,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SERVER_INFOA * ppServerInfo,
    OUT DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateServers WTSEnumerateServersW
#else
#define WTSEnumerateServers WTSEnumerateServersA
#endif

/*------------------------------------------------*/

HANDLE
WINAPI
WTSOpenServerW(
    IN LPWSTR pServerName
    );

HANDLE
WINAPI
WTSOpenServerA(
    IN LPSTR pServerName
    );

#ifdef UNICODE
#define WTSOpenServer WTSOpenServerW
#else
#define WTSOpenServer WTSOpenServerA
#endif

/*------------------------------------------------*/

VOID
WINAPI
WTSCloseServer(
    IN HANDLE hServer
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSEnumerateSessionsW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOW * ppSessionInfo,
    OUT DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateSessionsA(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOA * ppSessionInfo,
    OUT DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateSessions WTSEnumerateSessionsW
#else
#define WTSEnumerateSessions WTSEnumerateSessionsA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSEnumerateProcessesW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_PROCESS_INFOW * ppProcessInfo,
    OUT DWORD * pCount
    );

BOOL
WINAPI
WTSEnumerateProcessesA(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_PROCESS_INFOA * ppProcessInfo,
    OUT DWORD * pCount
    );

#ifdef UNICODE
#define WTSEnumerateProcesses WTSEnumerateProcessesW
#else
#define WTSEnumerateProcesses WTSEnumerateProcessesA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSTerminateProcess(
    IN HANDLE hServer,
    IN DWORD ProcessId,
    IN DWORD ExitCode
    );


/*------------------------------------------------*/

BOOL
WINAPI
WTSQuerySessionInformationW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

BOOL
WINAPI
WTSQuerySessionInformationA(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

#ifdef UNICODE
#define WTSQuerySessionInformation WTSQuerySessionInformationW
#else
#define WTSQuerySessionInformation WTSQuerySessionInformationA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSQueryUserConfigW(
    IN LPWSTR pServerName,
    IN LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

BOOL
WINAPI
WTSQueryUserConfigA(
    IN LPSTR pServerName,
    IN LPSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    OUT LPSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

#ifdef UNICODE
#define WTSQueryUserConfig WTSQueryUserConfigW
#else
#define WTSQueryUserConfig WTSQueryUserConfigA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSSetUserConfigW(
    IN LPWSTR pServerName,
    IN LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    IN LPWSTR pBuffer,
    IN DWORD DataLength
    );

BOOL
WINAPI
WTSSetUserConfigA(
    IN LPSTR pServerName,
    IN LPSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    IN LPSTR pBuffer,
    IN DWORD DataLength
    );

#ifdef UNICODE
#define WTSSetUserConfig WTSSetUserConfigW
#else
#define WTSSetUserConfig WTSSetUserConfigA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSSendMessageW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN LPWSTR pTitle,
    IN DWORD TitleLength,
    IN LPWSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    OUT DWORD * pResponse,
    IN BOOL bWait
    );

BOOL
WINAPI
WTSSendMessageA(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN LPSTR pTitle,
    IN DWORD TitleLength,
    IN LPSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    OUT DWORD * pResponse,
    IN BOOL bWait
    );

#ifdef UNICODE
#define WTSSendMessage WTSSendMessageW
#else
#define WTSSendMessage WTSSendMessageA
#endif

/*------------------------------------------------*/

BOOL
WINAPI
WTSDisconnectSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSLogoffSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSShutdownSystem(
    IN HANDLE hServer,
    IN DWORD ShutdownFlag
    );

/*------------------------------------------------*/

BOOL
WINAPI
WTSWaitSystemEvent(
    IN HANDLE hServer,
    IN DWORD EventMask,
    OUT DWORD * pEventFlags
    );

/*------------------------------------------------*/

HANDLE
WINAPI
WTSVirtualChannelOpen(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN LPSTR pVirtualName   /* ascii name */
    );

BOOL
WINAPI
WTSVirtualChannelClose(
    IN HANDLE hChannelHandle
    );

BOOL
WINAPI
WTSVirtualChannelRead(
    IN HANDLE hChannelHandle,
    IN ULONG TimeOut,
    OUT PCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesRead
    );

BOOL
WINAPI
WTSVirtualChannelWrite(
    IN HANDLE hChannelHandle,
    IN PCHAR Buffer,
    IN ULONG Length,
    OUT PULONG pBytesWritten
    );

BOOL
WINAPI
WTSVirtualChannelPurgeInput(
    IN HANDLE hChannelHandle
    );

BOOL
WINAPI
WTSVirtualChannelPurgeOutput(
    IN HANDLE hChannelHandle
    );


BOOL
WINAPI
WTSVirtualChannelQuery(
    IN HANDLE hChannelHandle,
    IN WTS_VIRTUAL_CLASS,
    OUT PVOID *ppBuffer,
    OUT DWORD *pBytesReturned
    );

/*------------------------------------------------*/


VOID
WINAPI
WTSFreeMemory(
    IN PVOID pMemory
    );

/* Flags for Console Notification */

#define NOTIFY_FOR_ALL_SESSIONS     1
#define NOTIFY_FOR_THIS_SESSION     0


BOOL WINAPI
WTSRegisterSessionNotification(
    HWND hWnd,
    DWORD dwFlags
    );

BOOL WINAPI
WTSUnRegisterSessionNotification(
    HWND hWnd
    );

BOOL WINAPI
WTSQueryUserToken(
    ULONG SessionId, 
    PHANDLE phToken
    );


#ifdef __cplusplus
}
#endif

#endif  /* !_INC_WTSAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xaddroot.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0352 */
/* Compiler settings for xaddroot.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xaddroot_h__
#define __xaddroot_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __Icaddroot_FWD_DEFINED__
#define __Icaddroot_FWD_DEFINED__
typedef interface Icaddroot Icaddroot;
#endif 	/* __Icaddroot_FWD_DEFINED__ */


#ifndef __caddroot_FWD_DEFINED__
#define __caddroot_FWD_DEFINED__

#ifdef __cplusplus
typedef class caddroot caddroot;
#else
typedef struct caddroot caddroot;
#endif /* __cplusplus */

#endif 	/* __caddroot_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __Icaddroot_INTERFACE_DEFINED__
#define __Icaddroot_INTERFACE_DEFINED__

/* interface Icaddroot */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_Icaddroot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D80F65F-7404-44A2-99DA-E595796110E6")
    Icaddroot : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddRoots( 
            BSTR wszCTL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCA( 
            BSTR wszX509) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IcaddrootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Icaddroot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Icaddroot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Icaddroot * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Icaddroot * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Icaddroot * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Icaddroot * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Icaddroot * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *AddRoots )( 
            Icaddroot * This,
            BSTR wszCTL);
        
        HRESULT ( STDMETHODCALLTYPE *AddCA )( 
            Icaddroot * This,
            BSTR wszX509);
        
        END_INTERFACE
    } IcaddrootVtbl;

    interface Icaddroot
    {
        CONST_VTBL struct IcaddrootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Icaddroot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Icaddroot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Icaddroot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Icaddroot_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Icaddroot_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Icaddroot_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Icaddroot_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Icaddroot_AddRoots(This,wszCTL)	\
    (This)->lpVtbl -> AddRoots(This,wszCTL)

#define Icaddroot_AddCA(This,wszX509)	\
    (This)->lpVtbl -> AddCA(This,wszX509)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE Icaddroot_AddRoots_Proxy( 
    Icaddroot * This,
    BSTR wszCTL);


void __RPC_STUB Icaddroot_AddRoots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE Icaddroot_AddCA_Proxy( 
    Icaddroot * This,
    BSTR wszX509);


void __RPC_STUB Icaddroot_AddCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Icaddroot_INTERFACE_DEFINED__ */



#ifndef __XADDROOTLib_LIBRARY_DEFINED__
#define __XADDROOTLib_LIBRARY_DEFINED__

/* library XADDROOTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XADDROOTLib;

EXTERN_C const CLSID CLSID_caddroot;

#ifdef __cplusplus

class DECLSPEC_UUID("C1422F20-C082-469D-B0B1-AD60CDBDC466")
caddroot;
#endif
#endif /* __XADDROOTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __wtypes_h__
#define __wtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "basetsd.h"
#include "guiddef.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wtypes_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_s_ifspec;

#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

/* interface IWinTypes */
/* [auto_handle][unique][version][uuid] */ 

typedef struct tagRemHGLOBAL
    {
    long fNullHGlobal;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHGLOBAL;

typedef struct tagRemHMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHMETAFILEPICT;

typedef struct tagRemHENHMETAFILE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHENHMETAFILE;

typedef struct tagRemHBITMAP
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHBITMAP;

typedef struct tagRemHPALETTE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHPALETTE;

typedef struct tagRemBRUSH
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    } 	RemHBRUSH;

#if !defined(_WIN32) && !defined(_MPPC_)
// The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef byte BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
typedef unsigned int UINT;

typedef int INT;

typedef long BOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
typedef UINT_PTR WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
typedef LONG_PTR LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
typedef LONG_PTR LRESULT;

#endif // !_LRESULT_DEFINED
typedef void *HANDLE;

typedef void *HMODULE;

typedef void *HINSTANCE;

typedef void *HRGN;

typedef void *HTASK;

typedef void *HKEY;

typedef void *HDESK;

typedef void *HMF;

typedef void *HEMF;

typedef void *HPEN;

typedef void *HRSRC;

typedef void *HSTR;

typedef void *HWINSTA;

typedef void *HKL;

typedef void *HGDIOBJ;

typedef HANDLE HDWP;

#ifndef _HFILE_DEFINED
#define _HFILE_DEFINED
typedef INT HFILE;

#endif // !_HFILE_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
typedef char CHAR;

typedef /* [string] */ CHAR *LPSTR;

typedef /* [string] */ const CHAR *LPCSTR;

#ifndef _WCHAR_DEFINED
#define _WCHAR_DEFINED
typedef wchar_t WCHAR;

typedef WCHAR TCHAR;

#endif // !_WCHAR_DEFINED
typedef /* [string] */ WCHAR *LPWSTR;

typedef /* [string] */ TCHAR *LPTSTR;

typedef /* [string] */ const WCHAR *LPCWSTR;

typedef /* [string] */ const TCHAR *LPCTSTR;

#ifndef _COLORREF_DEFINED
#define _COLORREF_DEFINED
typedef DWORD COLORREF;

#endif // !_COLORREF_DEFINED
#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
typedef DWORD *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED
typedef HANDLE *LPHANDLE;

typedef struct _RECTL
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    } 	RECTL;

typedef struct _RECTL *PRECTL;

typedef struct _RECTL *LPRECTL;

typedef struct tagPOINT
    {
    LONG x;
    LONG y;
    } 	POINT;

typedef struct tagPOINT *PPOINT;

typedef struct tagPOINT *LPPOINT;

typedef struct _POINTL
    {
    LONG x;
    LONG y;
    } 	POINTL;

typedef struct _POINTL *PPOINTL;

#ifndef WIN16
typedef struct tagSIZE
    {
    LONG cx;
    LONG cy;
    } 	SIZE;

typedef struct tagSIZE *PSIZE;

typedef struct tagSIZE *LPSIZE;

#else // WIN16
typedef struct tagSIZE
{
    INT cx;
    INT cy;
} SIZE, *PSIZE, *LPSIZE;
#endif // WIN16
typedef struct tagSIZEL
    {
    LONG cx;
    LONG cy;
    } 	SIZEL;

typedef struct tagSIZEL *PSIZEL;

typedef struct tagSIZEL *LPSIZEL;

#endif  //WINAPI
#endif  //!WIN32 && !MPPC
#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED
typedef struct tagPALETTEENTRY
    {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
    } 	PALETTEENTRY;

typedef struct tagPALETTEENTRY *PPALETTEENTRY;

typedef struct tagPALETTEENTRY *LPPALETTEENTRY;

#endif // !_PALETTEENTRY_DEFINED
#ifndef _LOGPALETTE_DEFINED
#define _LOGPALETTE_DEFINED
typedef struct tagLOGPALETTE
    {
    WORD palVersion;
    WORD palNumEntries;
    /* [size_is] */ PALETTEENTRY palPalEntry[ 1 ];
    } 	LOGPALETTE;

typedef struct tagLOGPALETTE *PLOGPALETTE;

typedef struct tagLOGPALETTE *LPLOGPALETTE;

#endif // !_LOGPALETTE_DEFINED
#if defined(_WIN32) && !defined(OLE2ANSI)
typedef WCHAR OLECHAR;

typedef /* [string] */ OLECHAR *LPOLESTR;

typedef /* [string] */ const OLECHAR *LPCOLESTR;

#define OLESTR(str) L##str

#else

typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif
#ifndef _WINDEF_
typedef const RECTL *LPCRECTL;

typedef void *PVOID;

typedef void *LPVOID;

typedef float FLOAT;

typedef struct tagRECT
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    } 	RECT;

typedef struct tagRECT *PRECT;

typedef struct tagRECT *LPRECT;

typedef const RECT *LPCRECT;

#endif  //_WINDEF_
typedef unsigned char UCHAR;

typedef short SHORT;

typedef unsigned short USHORT;

typedef DWORD ULONG;

typedef double DOUBLE;

#ifndef _DWORDLONG_
typedef unsigned __int64 DWORDLONG;

typedef DWORDLONG *PDWORDLONG;

#endif // !_DWORDLONG_
#ifndef _ULONGLONG_
typedef __int64 LONGLONG;

typedef unsigned __int64 ULONGLONG;

typedef LONGLONG *PLONGLONG;

typedef ULONGLONG *PULONGLONG;

#endif // _ULONGLONG_
#if 0
typedef struct _LARGE_INTEGER
    {
    LONGLONG QuadPart;
    } 	LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER
    {
    ULONGLONG QuadPart;
    } 	ULARGE_INTEGER;

#endif // 0
#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    } 	FILETIME;

typedef struct _FILETIME *PFILETIME;

typedef struct _FILETIME *LPFILETIME;

#endif // !_FILETIME
#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_
typedef struct _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    } 	SYSTEMTIME;

typedef struct _SYSTEMTIME *PSYSTEMTIME;

typedef struct _SYSTEMTIME *LPSYSTEMTIME;

#endif // !_SYSTEMTIME
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    } 	SECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES *PSECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;

#endif // !_SECURITY_ATTRIBUTES_
#ifndef SECURITY_DESCRIPTOR_REVISION
typedef USHORT SECURITY_DESCRIPTOR_CONTROL;

typedef USHORT *PSECURITY_DESCRIPTOR_CONTROL;

typedef PVOID PSID;

typedef struct _ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
    } 	ACL;

typedef ACL *PACL;

typedef struct _SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
    } 	SECURITY_DESCRIPTOR;

typedef struct _SECURITY_DESCRIPTOR *PISECURITY_DESCRIPTOR;

#endif // !SECURITY_DESCRIPTOR_REVISION
#endif //_WINBASE_
typedef struct _COAUTHIDENTITY
    {
    /* [size_is] */ USHORT *User;
    ULONG UserLength;
    /* [size_is] */ USHORT *Domain;
    ULONG DomainLength;
    /* [size_is] */ USHORT *Password;
    ULONG PasswordLength;
    ULONG Flags;
    } 	COAUTHIDENTITY;

typedef struct _COAUTHINFO
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY *pAuthIdentityData;
    DWORD dwCapabilities;
    } 	COAUTHINFO;

typedef LONG SCODE;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED
typedef SCODE *PSCODE;

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
typedef struct _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    } 	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if 0
typedef GUID *REFGUID;

typedef IID *REFIID;

typedef CLSID *REFCLSID;

typedef FMTID *REFFMTID;

#endif // 0
typedef 
enum tagMEMCTX
    {	MEMCTX_TASK	= 1,
	MEMCTX_SHARED	= 2,
	MEMCTX_MACSYSTEM	= 3,
	MEMCTX_UNKNOWN	= -1,
	MEMCTX_SAME	= -2
    } 	MEMCTX;

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 0x1
#define ROTFLAGS_ALLOWANYCLIENT 0x2
#endif // !_ROTFLAGS_DEFINED
#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif // !_ROT_COMPARE_MAX_DEFINED
typedef 
enum tagCLSCTX
    {	CLSCTX_INPROC_SERVER	= 0x1,
	CLSCTX_INPROC_HANDLER	= 0x2,
	CLSCTX_LOCAL_SERVER	= 0x4,
	CLSCTX_INPROC_SERVER16	= 0x8,
	CLSCTX_REMOTE_SERVER	= 0x10,
	CLSCTX_INPROC_HANDLER16	= 0x20,
	CLSCTX_RESERVED1	= 0x40,
	CLSCTX_RESERVED2	= 0x80,
	CLSCTX_RESERVED3	= 0x100,
	CLSCTX_RESERVED4	= 0x200,
	CLSCTX_NO_CODE_DOWNLOAD	= 0x400,
	CLSCTX_RESERVED5	= 0x800,
	CLSCTX_NO_CUSTOM_MARSHAL	= 0x1000,
	CLSCTX_ENABLE_CODE_DOWNLOAD	= 0x2000,
	CLSCTX_NO_FAILURE_LOG	= 0x4000,
	CLSCTX_DISABLE_AAA	= 0x8000,
	CLSCTX_ENABLE_AAA	= 0x10000,
	CLSCTX_FROM_DEFAULT_CONTEXT	= 0x20000
    } 	CLSCTX;

typedef 
enum tagMSHLFLAGS
    {	MSHLFLAGS_NORMAL	= 0,
	MSHLFLAGS_TABLESTRONG	= 1,
	MSHLFLAGS_TABLEWEAK	= 2,
	MSHLFLAGS_NOPING	= 4,
	MSHLFLAGS_RESERVED1	= 8,
	MSHLFLAGS_RESERVED2	= 16,
	MSHLFLAGS_RESERVED3	= 32,
	MSHLFLAGS_RESERVED4	= 64
    } 	MSHLFLAGS;

typedef 
enum tagMSHCTX
    {	MSHCTX_LOCAL	= 0,
	MSHCTX_NOSHAREDMEM	= 1,
	MSHCTX_DIFFERENTMACHINE	= 2,
	MSHCTX_INPROC	= 3,
	MSHCTX_CROSSCTX	= 4
    } 	MSHCTX;

typedef 
enum tagDVASPECT
    {	DVASPECT_CONTENT	= 1,
	DVASPECT_THUMBNAIL	= 2,
	DVASPECT_ICON	= 4,
	DVASPECT_DOCPRINT	= 8
    } 	DVASPECT;

typedef 
enum tagSTGC
    {	STGC_DEFAULT	= 0,
	STGC_OVERWRITE	= 1,
	STGC_ONLYIFCURRENT	= 2,
	STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE	= 4,
	STGC_CONSOLIDATE	= 8
    } 	STGC;

typedef 
enum tagSTGMOVE
    {	STGMOVE_MOVE	= 0,
	STGMOVE_COPY	= 1,
	STGMOVE_SHALLOWCOPY	= 2
    } 	STGMOVE;

typedef 
enum tagSTATFLAG
    {	STATFLAG_DEFAULT	= 0,
	STATFLAG_NONAME	= 1,
	STATFLAG_NOOPEN	= 2
    } 	STATFLAG;

typedef /* [context_handle] */ void *HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
typedef DWORD LCID;

#endif // !_LCID_DEFINED
#ifndef _LANGID_DEFINED
#define _LANGID_DEFINED
typedef USHORT LANGID;

#endif // !_LANGID_DEFINED
typedef struct _BYTE_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ byte abData[ 1 ];
    } 	BYTE_BLOB;

typedef /* [unique] */ BYTE_BLOB *UP_BYTE_BLOB;

typedef struct _WORD_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ unsigned short asData[ 1 ];
    } 	WORD_BLOB;

typedef /* [unique] */ WORD_BLOB *UP_WORD_BLOB;

typedef struct _DWORD_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ unsigned long alData[ 1 ];
    } 	DWORD_BLOB;

typedef /* [unique] */ DWORD_BLOB *UP_DWORD_BLOB;

typedef struct _FLAGGED_BYTE_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    /* [size_is] */ byte abData[ 1 ];
    } 	FLAGGED_BYTE_BLOB;

typedef /* [unique] */ FLAGGED_BYTE_BLOB *UP_FLAGGED_BYTE_BLOB;

typedef struct _FLAGGED_WORD_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    /* [size_is] */ unsigned short asData[ 1 ];
    } 	FLAGGED_WORD_BLOB;

typedef /* [unique] */ FLAGGED_WORD_BLOB *UP_FLAGGED_WORD_BLOB;

typedef struct _BYTE_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ byte *pData;
    } 	BYTE_SIZEDARR;

typedef struct _SHORT_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ unsigned short *pData;
    } 	WORD_SIZEDARR;

typedef struct _LONG_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ unsigned long *pData;
    } 	DWORD_SIZEDARR;

typedef struct _HYPER_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ hyper *pData;
    } 	HYPER_SIZEDARR;

#define	WDT_INPROC_CALL	( 0x48746457 )

#define	WDT_REMOTE_CALL	( 0x52746457 )

#define	WDT_INPROC64_CALL	( 0x50746457 )

typedef struct _userCLIPFORMAT
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0001
        {
        /* [case()] */ DWORD dwValue;
        /* [case()][string] */ wchar_t *pwszName;
        } 	u;
    } 	userCLIPFORMAT;

typedef /* [unique] */ userCLIPFORMAT *wireCLIPFORMAT;

typedef /* [wire_marshal] */ WORD CLIPFORMAT;

typedef struct _GDI_NONREMOTE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0002
        {
        /* [case()] */ long hInproc;
        /* [case()] */ DWORD_BLOB *hRemote;
        } 	u;
    } 	GDI_NONREMOTE;

typedef struct _userHGLOBAL
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0003
        {
        /* [case()] */ long hInproc;
        /* [case()] */ FLAGGED_BYTE_BLOB *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHGLOBAL;

typedef /* [unique] */ userHGLOBAL *wireHGLOBAL;

typedef struct _userHMETAFILE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0004
        {
        /* [case()] */ long hInproc;
        /* [case()] */ BYTE_BLOB *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHMETAFILE;

typedef struct _remoteMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    userHMETAFILE *hMF;
    } 	remoteMETAFILEPICT;

typedef struct _userHMETAFILEPICT
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0005
        {
        /* [case()] */ long hInproc;
        /* [case()] */ remoteMETAFILEPICT *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHMETAFILEPICT;

typedef struct _userHENHMETAFILE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0006
        {
        /* [case()] */ long hInproc;
        /* [case()] */ BYTE_BLOB *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHENHMETAFILE;

typedef struct _userBITMAP
    {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    ULONG cbSize;
    /* [size_is] */ byte pBuffer[ 1 ];
    } 	userBITMAP;

typedef struct _userHBITMAP
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0007
        {
        /* [case()] */ long hInproc;
        /* [case()] */ userBITMAP *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHBITMAP;

typedef struct _userHPALETTE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0008
        {
        /* [case()] */ long hInproc;
        /* [case()] */ LOGPALETTE *hRemote;
        /* [case()] */ __int64 hInproc64;
        } 	u;
    } 	userHPALETTE;

typedef struct _RemotableHandle
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0009
        {
        /* [case()] */ long hInproc;
        /* [case()] */ long hRemote;
        } 	u;
    } 	RemotableHandle;

typedef /* [unique] */ RemotableHandle *wireHWND;

typedef /* [unique] */ RemotableHandle *wireHMENU;

typedef /* [unique] */ RemotableHandle *wireHACCEL;

typedef /* [unique] */ RemotableHandle *wireHBRUSH;

typedef /* [unique] */ RemotableHandle *wireHFONT;

typedef /* [unique] */ RemotableHandle *wireHDC;

typedef /* [unique] */ RemotableHandle *wireHICON;

#if 0
typedef /* [wire_marshal] */ void *HWND;

typedef /* [wire_marshal] */ void *HMENU;

typedef /* [wire_marshal] */ void *HACCEL;

typedef /* [wire_marshal] */ void *HBRUSH;

typedef /* [wire_marshal] */ void *HFONT;

typedef /* [wire_marshal] */ void *HDC;

typedef /* [wire_marshal] */ void *HICON;

#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
typedef HICON HCURSOR;

#endif // !_HCURSOR_DEFINED
#endif //0
#ifndef _TEXTMETRIC_DEFINED
#define _TEXTMETRIC_DEFINED
typedef struct tagTEXTMETRICW
    {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    } 	TEXTMETRICW;

typedef struct tagTEXTMETRICW *PTEXTMETRICW;

typedef struct tagTEXTMETRICW *LPTEXTMETRICW;

#endif // !_TEXTMETRIC_DEFINED
#ifndef _WIN32           // The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
typedef struct tagMSG
    {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
    } 	MSG;

typedef struct tagMSG *PMSG;

typedef struct tagMSG *NPMSG;

typedef struct tagMSG *LPMSG;

#endif // _WIN32
#endif // WINAPI
typedef /* [unique] */ userHBITMAP *wireHBITMAP;

typedef /* [unique] */ userHPALETTE *wireHPALETTE;

typedef /* [unique] */ userHENHMETAFILE *wireHENHMETAFILE;

typedef /* [unique] */ userHMETAFILE *wireHMETAFILE;

typedef /* [unique] */ userHMETAFILEPICT *wireHMETAFILEPICT;

#if 0
typedef /* [wire_marshal] */ void *HGLOBAL;

typedef HGLOBAL HLOCAL;

typedef /* [wire_marshal] */ void *HBITMAP;

typedef /* [wire_marshal] */ void *HPALETTE;

typedef /* [wire_marshal] */ void *HENHMETAFILE;

typedef /* [wire_marshal] */ void *HMETAFILE;

#endif //0
typedef /* [wire_marshal] */ void *HMETAFILEPICT;



extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#endif /* __IWinTypes_INTERFACE_DEFINED__ */

/* interface __MIDL_itf_wtypes_0003 */
/* [local] */ 

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
/* the following isn't the real definition of CY, but it is */
/* what RPC knows how to remote */
typedef struct tagCY
    {
    LONGLONG int64;
    } 	CY;

#else /* 0 */
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 0 */
#endif /* _tagCY_DEFINED */
typedef CY *LPCY;

#if 0 /* _tagDEC_DEFINED */
/* The following isn't the real definition of Decimal type, */
/* but it is what RPC knows how to remote */
typedef struct tagDEC
    {
    USHORT wReserved;
    BYTE scale;
    BYTE sign;
    ULONG Hi32;
    ULONGLONG Lo64;
    } 	DECIMAL;

#else /* _tagDEC_DEFINED */
/* real definition that makes the C++ compiler happy */
typedef struct tagDEC {
    USHORT wReserved;
    union {
        struct {
            BYTE scale;
            BYTE sign;
        };
        USHORT signscale;
    };
    ULONG Hi32;
    union {
        struct {
#ifdef _MAC
            ULONG Mid32;
            ULONG Lo32;
#else
            ULONG Lo32;
            ULONG Mid32;
#endif
        };
        ULONGLONG Lo64;
    };
} DECIMAL;
#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) \
        {(dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0;}
#endif /* _tagDEC_DEFINED */
typedef DECIMAL *LPDECIMAL;

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif
typedef /* [unique] */ FLAGGED_WORD_BLOB *wireBSTR;

typedef /* [wire_marshal] */ OLECHAR *BSTR;

typedef BSTR *LPBSTR;

/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;

#if !__STDC__ && (_MSC_VER <= 1000)
/* For backward compatibility */
typedef VARIANT_BOOL _VARIANT_BOOL;

#else
/* ANSI C/C++ reserve bool as keyword */
#define _VARIANT_BOOL    /##/
#endif
typedef boolean BOOLEAN;

/* The BSTRBLOB structure is used by some implementations */
/* of the IPropertyStorage interface when marshaling BSTRs */
/* on systems which don't support BSTR marshaling. */
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
typedef struct tagBSTRBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE *pData;
    } 	BSTRBLOB;

typedef struct tagBSTRBLOB *LPBSTRBLOB;

#endif
#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct tagBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE *pBlobData;
    } 	BLOB;

typedef struct tagBLOB *LPBLOB;

#endif
typedef struct tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    /* [size_is] */ BYTE *pClipData;
    } 	CLIPDATA;

// Macro to calculate the size of the above pClipData
#define CBPCLIPDATA(clipdata)    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )
typedef unsigned short VARTYPE;

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T]   [S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_RECORD           [V]   [P][S]  user defined type
 *  VT_I1               [V][T][P][s]  signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2              [V][T][P][S]  unsigned short
 *  VT_UI4              [V][T][P][S]  unsigned long
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT              [V][T][P][S]  signed machine int
 *  VT_UINT             [V][T]   [S]  unsigned machine int
 *  VT_INT_PTR             [T]        signed machine register size width
 *  VT_UINT_PTR            [T]        unsigned machine register size width
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_VERSIONED_STREAM       [P]     Stream with a GUID version
 *  VT_BLOB_OBJECT            [P]     Blob contains an object 
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 *  VT_BSTR_BLOB                      Reserved for system use
 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_DECIMAL	= 14,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_RECORD	= 36,
	VT_INT_PTR	= 37,
	VT_UINT_PTR	= 38,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72,
	VT_VERSIONED_STREAM	= 73,
	VT_BSTR_BLOB	= 0xfff,
	VT_VECTOR	= 0x1000,
	VT_ARRAY	= 0x2000,
	VT_BYREF	= 0x4000,
	VT_RESERVED	= 0x8000,
	VT_ILLEGAL	= 0xffff,
	VT_ILLEGALMASKED	= 0xfff,
	VT_TYPEMASK	= 0xfff
    } ;
typedef ULONG PROPID;

#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY
    {
    UCHAR Value[ 6 ];
    } 	SID_IDENTIFIER_AUTHORITY;

typedef struct _SID_IDENTIFIER_AUTHORITY *PSID_IDENTIFIER_AUTHORITY;

#endif
#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID
    {
    BYTE Revision;
    BYTE SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	SID;

typedef struct _SID *PISID;

typedef struct _SID_AND_ATTRIBUTES
    {
    SID *Sid;
    DWORD Attributes;
    } 	SID_AND_ATTRIBUTES;

typedef struct _SID_AND_ATTRIBUTES *PSID_AND_ATTRIBUTES;

#endif
typedef struct tagCSPLATFORM
    {
    DWORD dwPlatformId;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwProcessorArch;
    } 	CSPLATFORM;

typedef struct tagQUERYCONTEXT
    {
    DWORD dwContext;
    CSPLATFORM Platform;
    LCID Locale;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    } 	QUERYCONTEXT;

typedef /* [v1_enum] */ 
enum tagTYSPEC
    {	TYSPEC_CLSID	= 0,
	TYSPEC_FILEEXT	= TYSPEC_CLSID + 1,
	TYSPEC_MIMETYPE	= TYSPEC_FILEEXT + 1,
	TYSPEC_FILENAME	= TYSPEC_MIMETYPE + 1,
	TYSPEC_PROGID	= TYSPEC_FILENAME + 1,
	TYSPEC_PACKAGENAME	= TYSPEC_PROGID + 1,
	TYSPEC_OBJECTID	= TYSPEC_PACKAGENAME + 1
    } 	TYSPEC;

typedef /* [public] */ struct __MIDL___MIDL_itf_wtypes_0003_0001
    {
    DWORD tyspec;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_wtypes_0003_0005
        {
        /* [case()] */ CLSID clsid;
        /* [case()] */ LPOLESTR pFileExt;
        /* [case()] */ LPOLESTR pMimeType;
        /* [case()] */ LPOLESTR pProgId;
        /* [case()] */ LPOLESTR pFileName;
        /* [case()] */ struct 
            {
            LPOLESTR pPackageName;
            GUID PolicyId;
            } 	ByName;
        /* [case()] */ struct 
            {
            GUID ObjectId;
            GUID PolicyId;
            } 	ByObjectId;
        } 	tagged_union;
    } 	uCLSSPEC;



extern RPC_IF_HANDLE __MIDL_itf_wtypes_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xmldom.h ===
//***************************************************************************** 
// 
// Microsoft Windows Media 
// Copyright (C) Microsoft Corporation. All rights reserved. 
//
// FileName:            xmldom.h
//
// Abstract:
//
//*****************************************************************************

#pragma once

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation
//
//  File:       XMLDom.h
//
//  Contents:
//
//--------------------------------------------------------------------------

//
// This file is needed because we need to import "xmldom.idl" in several
// of our idl files. Thus the .h files generated by MIDL includes "xmldom.h"
// But xmldom.h does not exist in the platform SDK. However, msxml.h exists
// in the SDK with all the definitions needed by xmldom.h. Thus, the work
// around is to simply create this xmldom.h file that merely includes msxml.h
//
#include "msxml.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xenroll.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for xenroll.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xenroll_h__
#define __xenroll_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICEnroll_FWD_DEFINED__
#define __ICEnroll_FWD_DEFINED__
typedef interface ICEnroll ICEnroll;
#endif 	/* __ICEnroll_FWD_DEFINED__ */


#ifndef __ICEnroll2_FWD_DEFINED__
#define __ICEnroll2_FWD_DEFINED__
typedef interface ICEnroll2 ICEnroll2;
#endif 	/* __ICEnroll2_FWD_DEFINED__ */


#ifndef __ICEnroll3_FWD_DEFINED__
#define __ICEnroll3_FWD_DEFINED__
typedef interface ICEnroll3 ICEnroll3;
#endif 	/* __ICEnroll3_FWD_DEFINED__ */


#ifndef __ICEnroll4_FWD_DEFINED__
#define __ICEnroll4_FWD_DEFINED__
typedef interface ICEnroll4 ICEnroll4;
#endif 	/* __ICEnroll4_FWD_DEFINED__ */


#ifndef __IEnroll_FWD_DEFINED__
#define __IEnroll_FWD_DEFINED__
typedef interface IEnroll IEnroll;
#endif 	/* __IEnroll_FWD_DEFINED__ */


#ifndef __IEnroll2_FWD_DEFINED__
#define __IEnroll2_FWD_DEFINED__
typedef interface IEnroll2 IEnroll2;
#endif 	/* __IEnroll2_FWD_DEFINED__ */


#ifndef __IEnroll4_FWD_DEFINED__
#define __IEnroll4_FWD_DEFINED__
typedef interface IEnroll4 IEnroll4;
#endif 	/* __IEnroll4_FWD_DEFINED__ */


#ifndef __CEnroll2_FWD_DEFINED__
#define __CEnroll2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll2 CEnroll2;
#else
typedef struct CEnroll2 CEnroll2;
#endif /* __cplusplus */

#endif 	/* __CEnroll2_FWD_DEFINED__ */


#ifndef __CEnroll_FWD_DEFINED__
#define __CEnroll_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll CEnroll;
#else
typedef struct CEnroll CEnroll;
#endif /* __cplusplus */

#endif 	/* __CEnroll_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wincrypt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ICEnroll_INTERFACE_DEFINED__
#define __ICEnroll_INTERFACE_DEFINED__

/* interface ICEnroll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43F8F288-7A20-11D0-8F06-00C04FC295E1")
    ICEnroll : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7( 
            /* [in] */ BSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10( 
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pPKCS10) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7( 
            /* [in] */ BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromPKCS7( 
            /* [in] */ BSTR wszPKCS7,
            /* [retval][out] */ BSTR *pbstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProviders( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ BSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainers( 
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfo( 
            /* [in] */ BSTR PKCS7OrPKCS10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreName( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreType( 
            /* [retval][out] */ BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreType( 
            /* [in] */ BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreName( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreType( 
            /* [retval][out] */ BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreType( 
            /* [in] */ BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreName( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreType( 
            /* [retval][out] */ BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreType( 
            /* [in] */ BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreName( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreName( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreType( 
            /* [retval][out] */ BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreType( 
            /* [in] */ BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName( 
            /* [retval][out] */ BSTR *pbstrContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerName( 
            /* [in] */ BSTR bstrContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ BSTR *pbstrProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderName( 
            /* [in] */ BSTR bstrProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [retval][out] */ LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [retval][out] */ BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [retval][out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [retval][out] */ BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [retval][out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileName( 
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileName( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileName( 
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileName( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ BSTR bstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll * This,
            /* [in] */ BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll * This,
            /* [in] */ BSTR wszPKCS7,
            /* [retval][out] */ BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll * This,
            /* [in] */ BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll * This,
            /* [retval][out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll * This,
            /* [retval][out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll * This,
            /* [in] */ BSTR bstr);
        
        END_INTERFACE
    } ICEnrollVtbl;

    interface ICEnroll
    {
        CONST_VTBL struct ICEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICEnroll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICEnroll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICEnroll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICEnroll_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)

#define ICEnroll_acceptFilePKCS7(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName)

#define ICEnroll_createPKCS10(This,DNName,Usage,pPKCS10)	\
    (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10)

#define ICEnroll_acceptPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> acceptPKCS7(This,PKCS7)

#define ICEnroll_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert)

#define ICEnroll_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName)

#define ICEnroll_enumContainers(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr)

#define ICEnroll_freeRequestInfo(This,PKCS7OrPKCS10)	\
    (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10)

#define ICEnroll_get_MyStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_MyStoreName(This,pbstrName)

#define ICEnroll_put_MyStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_MyStoreName(This,bstrName)

#define ICEnroll_get_MyStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_MyStoreType(This,pbstrType)

#define ICEnroll_put_MyStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_MyStoreType(This,bstrType)

#define ICEnroll_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define ICEnroll_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define ICEnroll_get_CAStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_CAStoreName(This,pbstrName)

#define ICEnroll_put_CAStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_CAStoreName(This,bstrName)

#define ICEnroll_get_CAStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_CAStoreType(This,pbstrType)

#define ICEnroll_put_CAStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_CAStoreType(This,bstrType)

#define ICEnroll_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define ICEnroll_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define ICEnroll_get_RootStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RootStoreName(This,pbstrName)

#define ICEnroll_put_RootStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RootStoreName(This,bstrName)

#define ICEnroll_get_RootStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RootStoreType(This,pbstrType)

#define ICEnroll_put_RootStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RootStoreType(This,bstrType)

#define ICEnroll_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define ICEnroll_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define ICEnroll_get_RequestStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RequestStoreName(This,pbstrName)

#define ICEnroll_put_RequestStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RequestStoreName(This,bstrName)

#define ICEnroll_get_RequestStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RequestStoreType(This,pbstrType)

#define ICEnroll_put_RequestStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RequestStoreType(This,bstrType)

#define ICEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define ICEnroll_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define ICEnroll_get_ContainerName(This,pbstrContainer)	\
    (This)->lpVtbl -> get_ContainerName(This,pbstrContainer)

#define ICEnroll_put_ContainerName(This,bstrContainer)	\
    (This)->lpVtbl -> put_ContainerName(This,bstrContainer)

#define ICEnroll_get_ProviderName(This,pbstrProvider)	\
    (This)->lpVtbl -> get_ProviderName(This,pbstrProvider)

#define ICEnroll_put_ProviderName(This,bstrProvider)	\
    (This)->lpVtbl -> put_ProviderName(This,bstrProvider)

#define ICEnroll_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define ICEnroll_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define ICEnroll_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define ICEnroll_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define ICEnroll_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define ICEnroll_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define ICEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define ICEnroll_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define ICEnroll_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define ICEnroll_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define ICEnroll_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define ICEnroll_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define ICEnroll_get_SPCFileName(This,pbstr)	\
    (This)->lpVtbl -> get_SPCFileName(This,pbstr)

#define ICEnroll_put_SPCFileName(This,bstr)	\
    (This)->lpVtbl -> put_SPCFileName(This,bstr)

#define ICEnroll_get_PVKFileName(This,pbstr)	\
    (This)->lpVtbl -> get_PVKFileName(This,pbstr)

#define ICEnroll_put_PVKFileName(This,bstr)	\
    (This)->lpVtbl -> put_PVKFileName(This,bstr)

#define ICEnroll_get_HashAlgorithm(This,pbstr)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,pbstr)

#define ICEnroll_put_HashAlgorithm(This,bstr)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,bstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICEnroll_createFilePKCS10_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR DNName,
    /* [in] */ BSTR Usage,
    /* [in] */ BSTR wszPKCS10FileName);


void __RPC_STUB ICEnroll_createFilePKCS10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_acceptFilePKCS7_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR wszPKCS7FileName);


void __RPC_STUB ICEnroll_acceptFilePKCS7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_createPKCS10_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR DNName,
    /* [in] */ BSTR Usage,
    /* [retval][out] */ BSTR *pPKCS10);


void __RPC_STUB ICEnroll_createPKCS10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_acceptPKCS7_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR PKCS7);


void __RPC_STUB ICEnroll_acceptPKCS7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_getCertFromPKCS7_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR wszPKCS7,
    /* [retval][out] */ BSTR *pbstrCert);


void __RPC_STUB ICEnroll_getCertFromPKCS7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_enumProviders_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG dwFlags,
    /* [retval][out] */ BSTR *pbstrProvName);


void __RPC_STUB ICEnroll_enumProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_enumContainers_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwIndex,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ICEnroll_enumContainers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll_freeRequestInfo_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR PKCS7OrPKCS10);


void __RPC_STUB ICEnroll_freeRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_MyStoreName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB ICEnroll_get_MyStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_MyStoreName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ICEnroll_put_MyStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_MyStoreType_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrType);


void __RPC_STUB ICEnroll_get_MyStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_MyStoreType_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrType);


void __RPC_STUB ICEnroll_put_MyStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_MyStoreFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_MyStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_MyStoreFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_MyStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_CAStoreName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB ICEnroll_get_CAStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_CAStoreName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ICEnroll_put_CAStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_CAStoreType_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrType);


void __RPC_STUB ICEnroll_get_CAStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_CAStoreType_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrType);


void __RPC_STUB ICEnroll_put_CAStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_CAStoreFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_CAStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_CAStoreFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_CAStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RootStoreName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB ICEnroll_get_RootStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RootStoreName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ICEnroll_put_RootStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RootStoreType_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrType);


void __RPC_STUB ICEnroll_get_RootStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RootStoreType_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrType);


void __RPC_STUB ICEnroll_put_RootStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RootStoreFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_RootStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RootStoreFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_RootStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RequestStoreName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB ICEnroll_get_RequestStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RequestStoreName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ICEnroll_put_RequestStoreName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RequestStoreType_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrType);


void __RPC_STUB ICEnroll_get_RequestStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RequestStoreType_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrType);


void __RPC_STUB ICEnroll_put_RequestStoreType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_RequestStoreFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_RequestStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_RequestStoreFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_RequestStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_ContainerName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrContainer);


void __RPC_STUB ICEnroll_get_ContainerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_ContainerName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrContainer);


void __RPC_STUB ICEnroll_put_ContainerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_ProviderName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstrProvider);


void __RPC_STUB ICEnroll_get_ProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_ProviderName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstrProvider);


void __RPC_STUB ICEnroll_put_ProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_ProviderType_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwType);


void __RPC_STUB ICEnroll_get_ProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_ProviderType_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwType);


void __RPC_STUB ICEnroll_put_ProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_KeySpec_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdw);


void __RPC_STUB ICEnroll_get_KeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_KeySpec_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dw);


void __RPC_STUB ICEnroll_put_KeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_ProviderFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_ProviderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_ProviderFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_ProviderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_UseExistingKeySet_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BOOL *fUseExistingKeys);


void __RPC_STUB ICEnroll_get_UseExistingKeySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_UseExistingKeySet_Proxy( 
    ICEnroll * This,
    /* [in] */ BOOL fUseExistingKeys);


void __RPC_STUB ICEnroll_put_UseExistingKeySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_GenKeyFlags_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ LONG *pdwFlags);


void __RPC_STUB ICEnroll_get_GenKeyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_GenKeyFlags_Proxy( 
    ICEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB ICEnroll_put_GenKeyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_DeleteRequestCert_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BOOL *fDelete);


void __RPC_STUB ICEnroll_get_DeleteRequestCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_DeleteRequestCert_Proxy( 
    ICEnroll * This,
    /* [in] */ BOOL fDelete);


void __RPC_STUB ICEnroll_put_DeleteRequestCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_WriteCertToCSP_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BOOL *fBool);


void __RPC_STUB ICEnroll_get_WriteCertToCSP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_WriteCertToCSP_Proxy( 
    ICEnroll * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB ICEnroll_put_WriteCertToCSP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_SPCFileName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ICEnroll_get_SPCFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_SPCFileName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ICEnroll_put_SPCFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_PVKFileName_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ICEnroll_get_PVKFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_PVKFileName_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ICEnroll_put_PVKFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll_get_HashAlgorithm_Proxy( 
    ICEnroll * This,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ICEnroll_get_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll_put_HashAlgorithm_Proxy( 
    ICEnroll * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ICEnroll_put_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICEnroll_INTERFACE_DEFINED__ */


#ifndef __ICEnroll2_INTERFACE_DEFINED__
#define __ICEnroll2_INTERFACE_DEFINED__

/* interface ICEnroll2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("704ca730-c90b-11d1-9bec-00c04fc295e1")
    ICEnroll2 : public ICEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequest( 
            /* [in] */ BSTR CertType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToSignature( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [retval][out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [retval][out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ BSTR wszPKCS7,
            /* [retval][out] */ BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll2 * This,
            /* [in] */ BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [retval][out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [retval][out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [in] */ BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll2 * This,
            /* [in] */ BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll2 * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        END_INTERFACE
    } ICEnroll2Vtbl;

    interface ICEnroll2
    {
        CONST_VTBL struct ICEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICEnroll2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICEnroll2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICEnroll2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICEnroll2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICEnroll2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICEnroll2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICEnroll2_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)

#define ICEnroll2_acceptFilePKCS7(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName)

#define ICEnroll2_createPKCS10(This,DNName,Usage,pPKCS10)	\
    (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10)

#define ICEnroll2_acceptPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> acceptPKCS7(This,PKCS7)

#define ICEnroll2_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert)

#define ICEnroll2_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName)

#define ICEnroll2_enumContainers(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr)

#define ICEnroll2_freeRequestInfo(This,PKCS7OrPKCS10)	\
    (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10)

#define ICEnroll2_get_MyStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_MyStoreName(This,pbstrName)

#define ICEnroll2_put_MyStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_MyStoreName(This,bstrName)

#define ICEnroll2_get_MyStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_MyStoreType(This,pbstrType)

#define ICEnroll2_put_MyStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_MyStoreType(This,bstrType)

#define ICEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define ICEnroll2_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define ICEnroll2_get_CAStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_CAStoreName(This,pbstrName)

#define ICEnroll2_put_CAStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_CAStoreName(This,bstrName)

#define ICEnroll2_get_CAStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_CAStoreType(This,pbstrType)

#define ICEnroll2_put_CAStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_CAStoreType(This,bstrType)

#define ICEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define ICEnroll2_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define ICEnroll2_get_RootStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RootStoreName(This,pbstrName)

#define ICEnroll2_put_RootStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RootStoreName(This,bstrName)

#define ICEnroll2_get_RootStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RootStoreType(This,pbstrType)

#define ICEnroll2_put_RootStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RootStoreType(This,bstrType)

#define ICEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define ICEnroll2_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define ICEnroll2_get_RequestStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RequestStoreName(This,pbstrName)

#define ICEnroll2_put_RequestStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RequestStoreName(This,bstrName)

#define ICEnroll2_get_RequestStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RequestStoreType(This,pbstrType)

#define ICEnroll2_put_RequestStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RequestStoreType(This,bstrType)

#define ICEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define ICEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define ICEnroll2_get_ContainerName(This,pbstrContainer)	\
    (This)->lpVtbl -> get_ContainerName(This,pbstrContainer)

#define ICEnroll2_put_ContainerName(This,bstrContainer)	\
    (This)->lpVtbl -> put_ContainerName(This,bstrContainer)

#define ICEnroll2_get_ProviderName(This,pbstrProvider)	\
    (This)->lpVtbl -> get_ProviderName(This,pbstrProvider)

#define ICEnroll2_put_ProviderName(This,bstrProvider)	\
    (This)->lpVtbl -> put_ProviderName(This,bstrProvider)

#define ICEnroll2_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define ICEnroll2_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define ICEnroll2_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define ICEnroll2_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define ICEnroll2_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define ICEnroll2_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define ICEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define ICEnroll2_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define ICEnroll2_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define ICEnroll2_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define ICEnroll2_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define ICEnroll2_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define ICEnroll2_get_SPCFileName(This,pbstr)	\
    (This)->lpVtbl -> get_SPCFileName(This,pbstr)

#define ICEnroll2_put_SPCFileName(This,bstr)	\
    (This)->lpVtbl -> put_SPCFileName(This,bstr)

#define ICEnroll2_get_PVKFileName(This,pbstr)	\
    (This)->lpVtbl -> get_PVKFileName(This,pbstr)

#define ICEnroll2_put_PVKFileName(This,bstr)	\
    (This)->lpVtbl -> put_PVKFileName(This,bstr)

#define ICEnroll2_get_HashAlgorithm(This,pbstr)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,pbstr)

#define ICEnroll2_put_HashAlgorithm(This,bstr)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,bstr)


#define ICEnroll2_addCertTypeToRequest(This,CertType)	\
    (This)->lpVtbl -> addCertTypeToRequest(This,CertType)

#define ICEnroll2_addNameValuePairToSignature(This,Name,Value)	\
    (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value)

#define ICEnroll2_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define ICEnroll2_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define ICEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define ICEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICEnroll2_addCertTypeToRequest_Proxy( 
    ICEnroll2 * This,
    /* [in] */ BSTR CertType);


void __RPC_STUB ICEnroll2_addCertTypeToRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll2_addNameValuePairToSignature_Proxy( 
    ICEnroll2 * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR Value);


void __RPC_STUB ICEnroll2_addNameValuePairToSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll2_get_WriteCertToUserDS_Proxy( 
    ICEnroll2 * This,
    /* [retval][out] */ BOOL *fBool);


void __RPC_STUB ICEnroll2_get_WriteCertToUserDS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll2_put_WriteCertToUserDS_Proxy( 
    ICEnroll2 * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB ICEnroll2_put_WriteCertToUserDS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll2_get_EnableT61DNEncoding_Proxy( 
    ICEnroll2 * This,
    /* [retval][out] */ BOOL *fBool);


void __RPC_STUB ICEnroll2_get_EnableT61DNEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll2_put_EnableT61DNEncoding_Proxy( 
    ICEnroll2 * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB ICEnroll2_put_EnableT61DNEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICEnroll2_INTERFACE_DEFINED__ */


#ifndef __ICEnroll3_INTERFACE_DEFINED__
#define __ICEnroll3_INTERFACE_DEFINED__

/* interface ICEnroll3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c28c2d95-b7de-11d2-a421-00c04f79fe8e")
    ICEnroll3 : public ICEnroll2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7( 
            /* [in] */ BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [retval][out] */ LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgName( 
            /* [in] */ LONG algID,
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [retval][out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ LONG *hashAlgID) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR wszPKCS7,
            /* [retval][out] */ BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll3 * This,
            /* [in] */ BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll3 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [in] */ BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll3 * This,
            /* [in] */ BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll3 * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll3 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll3 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll3 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } ICEnroll3Vtbl;

    interface ICEnroll3
    {
        CONST_VTBL struct ICEnroll3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICEnroll3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICEnroll3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICEnroll3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICEnroll3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICEnroll3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICEnroll3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICEnroll3_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)

#define ICEnroll3_acceptFilePKCS7(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName)

#define ICEnroll3_createPKCS10(This,DNName,Usage,pPKCS10)	\
    (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10)

#define ICEnroll3_acceptPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> acceptPKCS7(This,PKCS7)

#define ICEnroll3_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert)

#define ICEnroll3_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName)

#define ICEnroll3_enumContainers(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr)

#define ICEnroll3_freeRequestInfo(This,PKCS7OrPKCS10)	\
    (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10)

#define ICEnroll3_get_MyStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_MyStoreName(This,pbstrName)

#define ICEnroll3_put_MyStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_MyStoreName(This,bstrName)

#define ICEnroll3_get_MyStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_MyStoreType(This,pbstrType)

#define ICEnroll3_put_MyStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_MyStoreType(This,bstrType)

#define ICEnroll3_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define ICEnroll3_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define ICEnroll3_get_CAStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_CAStoreName(This,pbstrName)

#define ICEnroll3_put_CAStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_CAStoreName(This,bstrName)

#define ICEnroll3_get_CAStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_CAStoreType(This,pbstrType)

#define ICEnroll3_put_CAStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_CAStoreType(This,bstrType)

#define ICEnroll3_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define ICEnroll3_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define ICEnroll3_get_RootStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RootStoreName(This,pbstrName)

#define ICEnroll3_put_RootStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RootStoreName(This,bstrName)

#define ICEnroll3_get_RootStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RootStoreType(This,pbstrType)

#define ICEnroll3_put_RootStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RootStoreType(This,bstrType)

#define ICEnroll3_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define ICEnroll3_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define ICEnroll3_get_RequestStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RequestStoreName(This,pbstrName)

#define ICEnroll3_put_RequestStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RequestStoreName(This,bstrName)

#define ICEnroll3_get_RequestStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RequestStoreType(This,pbstrType)

#define ICEnroll3_put_RequestStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RequestStoreType(This,bstrType)

#define ICEnroll3_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define ICEnroll3_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define ICEnroll3_get_ContainerName(This,pbstrContainer)	\
    (This)->lpVtbl -> get_ContainerName(This,pbstrContainer)

#define ICEnroll3_put_ContainerName(This,bstrContainer)	\
    (This)->lpVtbl -> put_ContainerName(This,bstrContainer)

#define ICEnroll3_get_ProviderName(This,pbstrProvider)	\
    (This)->lpVtbl -> get_ProviderName(This,pbstrProvider)

#define ICEnroll3_put_ProviderName(This,bstrProvider)	\
    (This)->lpVtbl -> put_ProviderName(This,bstrProvider)

#define ICEnroll3_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define ICEnroll3_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define ICEnroll3_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define ICEnroll3_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define ICEnroll3_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define ICEnroll3_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define ICEnroll3_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll3_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll3_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define ICEnroll3_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define ICEnroll3_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define ICEnroll3_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define ICEnroll3_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define ICEnroll3_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define ICEnroll3_get_SPCFileName(This,pbstr)	\
    (This)->lpVtbl -> get_SPCFileName(This,pbstr)

#define ICEnroll3_put_SPCFileName(This,bstr)	\
    (This)->lpVtbl -> put_SPCFileName(This,bstr)

#define ICEnroll3_get_PVKFileName(This,pbstr)	\
    (This)->lpVtbl -> get_PVKFileName(This,pbstr)

#define ICEnroll3_put_PVKFileName(This,bstr)	\
    (This)->lpVtbl -> put_PVKFileName(This,bstr)

#define ICEnroll3_get_HashAlgorithm(This,pbstr)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,pbstr)

#define ICEnroll3_put_HashAlgorithm(This,bstr)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,bstr)


#define ICEnroll3_addCertTypeToRequest(This,CertType)	\
    (This)->lpVtbl -> addCertTypeToRequest(This,CertType)

#define ICEnroll3_addNameValuePairToSignature(This,Name,Value)	\
    (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value)

#define ICEnroll3_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define ICEnroll3_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define ICEnroll3_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define ICEnroll3_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)


#define ICEnroll3_InstallPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> InstallPKCS7(This,PKCS7)

#define ICEnroll3_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICEnroll3_GetSupportedKeySpec(This,pdwKeySpec)	\
    (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec)

#define ICEnroll3_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize)

#define ICEnroll3_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID)

#define ICEnroll3_GetAlgName(This,algID,pbstr)	\
    (This)->lpVtbl -> GetAlgName(This,algID,pbstr)

#define ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define ICEnroll3_put_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> put_HashAlgID(This,hashAlgID)

#define ICEnroll3_get_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> get_HashAlgID(This,hashAlgID)

#define ICEnroll3_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define ICEnroll3_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define ICEnroll3_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#define ICEnroll3_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICEnroll3_InstallPKCS7_Proxy( 
    ICEnroll3 * This,
    /* [in] */ BSTR PKCS7);


void __RPC_STUB ICEnroll3_InstallPKCS7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll3_Reset_Proxy( 
    ICEnroll3 * This);


void __RPC_STUB ICEnroll3_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll3_GetSupportedKeySpec_Proxy( 
    ICEnroll3 * This,
    /* [retval][out] */ LONG *pdwKeySpec);


void __RPC_STUB ICEnroll3_GetSupportedKeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll3_GetKeyLen_Proxy( 
    ICEnroll3 * This,
    /* [in] */ BOOL fMin,
    /* [in] */ BOOL fExchange,
    /* [retval][out] */ LONG *pdwKeySize);


void __RPC_STUB ICEnroll3_GetKeyLen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll3_EnumAlgs_Proxy( 
    ICEnroll3 * This,
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG algClass,
    /* [retval][out] */ LONG *pdwAlgID);


void __RPC_STUB ICEnroll3_EnumAlgs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll3_GetAlgName_Proxy( 
    ICEnroll3 * This,
    /* [in] */ LONG algID,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ICEnroll3_GetAlgName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew_Proxy( 
    ICEnroll3 * This,
    /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);


void __RPC_STUB ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew_Proxy( 
    ICEnroll3 * This,
    /* [retval][out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);


void __RPC_STUB ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll3_put_HashAlgID_Proxy( 
    ICEnroll3 * This,
    /* [in] */ LONG hashAlgID);


void __RPC_STUB ICEnroll3_put_HashAlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll3_get_HashAlgID_Proxy( 
    ICEnroll3 * This,
    /* [retval][out] */ LONG *hashAlgID);


void __RPC_STUB ICEnroll3_get_HashAlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll3_put_LimitExchangeKeyToEncipherment_Proxy( 
    ICEnroll3 * This,
    /* [in] */ BOOL fLimitExchangeKeyToEncipherment);


void __RPC_STUB ICEnroll3_put_LimitExchangeKeyToEncipherment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll3_get_LimitExchangeKeyToEncipherment_Proxy( 
    ICEnroll3 * This,
    /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);


void __RPC_STUB ICEnroll3_get_LimitExchangeKeyToEncipherment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll3_put_EnableSMIMECapabilities_Proxy( 
    ICEnroll3 * This,
    /* [in] */ BOOL fEnableSMIMECapabilities);


void __RPC_STUB ICEnroll3_put_EnableSMIMECapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll3_get_EnableSMIMECapabilities_Proxy( 
    ICEnroll3 * This,
    /* [retval][out] */ BOOL *fEnableSMIMECapabilities);


void __RPC_STUB ICEnroll3_get_EnableSMIMECapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICEnroll3_INTERFACE_DEFINED__ */


#ifndef __ICEnroll4_INTERFACE_DEFINED__
#define __ICEnroll4_INTERFACE_DEFINED__

/* interface ICEnroll4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1f1188a-2eb5-4a80-841b-7e729a356d90")
    ICEnroll4 : public ICEnroll3
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrivateKeyArchiveCertificate( 
            /* [in] */ BSTR bstrCert) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKeyArchiveCertificate( 
            /* [retval][out] */ BSTR *pbstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrint( 
            /* [in] */ BSTR bstrThumbPrint) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrint( 
            /* [retval][out] */ BSTR *pbstrThumbPrint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryToString( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strBinary,
            /* [retval][out] */ BSTR *pstrEncoded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinary( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strEncoded,
            /* [retval][out] */ BSTR *pstrBinary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strDNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pstrRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strDNName,
            /* [in] */ BSTR strUsage,
            /* [in] */ BSTR strRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponse( 
            /* [in] */ BSTR strResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponse( 
            /* [in] */ BSTR strResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromResponse( 
            /* [in] */ BSTR strResponse,
            /* [retval][out] */ BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromFileResponse( 
            /* [in] */ BSTR strResponseFileName,
            /* [retval][out] */ BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFX( 
            /* [in] */ BSTR strPassword,
            /* [retval][out] */ BSTR *pstrPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFX( 
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfo( 
            /* [in] */ LONG lRequestID,
            /* [in] */ BSTR strCADNS,
            /* [in] */ BSTR strCAName,
            /* [in] */ BSTR strFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequest( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequest( 
            /* [in] */ BSTR strThumbprint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Ex( 
            /* [in] */ BSTR PKCS7,
            /* [retval][out] */ LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequestEx( 
            /* [in] */ LONG lType,
            /* [in] */ BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderType( 
            /* [in] */ BSTR strProvName,
            /* [retval][out] */ LONG *plProvType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SignerCertificate( 
            /* [in] */ BSTR bstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ LONG *plClientId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificate( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ BSTR bstrProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetBlobProperties( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll4 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [in] */ BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR DNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR wszPKCS7,
            /* [retval][out] */ BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll4 * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll4 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrCert);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrint )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrThumbPrint);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrint )( 
            ICEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrThumbPrint);
        
        HRESULT ( STDMETHODCALLTYPE *binaryToString )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strBinary,
            /* [retval][out] */ BSTR *pstrEncoded);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinary )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strEncoded,
            /* [retval][out] */ BSTR *pstrBinary);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strName,
            /* [in] */ BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strDNName,
            /* [in] */ BSTR Usage,
            /* [retval][out] */ BSTR *pstrRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ BSTR strDNName,
            /* [in] */ BSTR strUsage,
            /* [in] */ BSTR strRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponse )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromResponse )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strResponse,
            /* [retval][out] */ BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strResponseFileName,
            /* [retval][out] */ BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *createPFX )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strPassword,
            /* [retval][out] */ BSTR *pstrPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFX )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ BSTR strCADNS,
            /* [in] */ BSTR strCAName,
            /* [in] */ BSTR strFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strThumbprint);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Ex )( 
            ICEnroll4 * This,
            /* [in] */ BSTR PKCS7,
            /* [retval][out] */ LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequestEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderType )( 
            ICEnroll4 * This,
            /* [in] */ BSTR strProvName,
            /* [retval][out] */ LONG *plProvType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            ICEnroll4 * This,
            /* [in] */ BSTR bstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            ICEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            ICEnroll4 * This,
            /* [retval][out] */ LONG *plClientId);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificate )( 
            ICEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ BSTR bstrProperty);
        
        HRESULT ( STDMETHODCALLTYPE *resetBlobProperties )( 
            ICEnroll4 * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [retval][out] */ BOOL *pfInclude);
        
        END_INTERFACE
    } ICEnroll4Vtbl;

    interface ICEnroll4
    {
        CONST_VTBL struct ICEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll4_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICEnroll4_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICEnroll4_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICEnroll4_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICEnroll4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICEnroll4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICEnroll4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICEnroll4_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)

#define ICEnroll4_acceptFilePKCS7(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName)

#define ICEnroll4_createPKCS10(This,DNName,Usage,pPKCS10)	\
    (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10)

#define ICEnroll4_acceptPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> acceptPKCS7(This,PKCS7)

#define ICEnroll4_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert)

#define ICEnroll4_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName)

#define ICEnroll4_enumContainers(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr)

#define ICEnroll4_freeRequestInfo(This,PKCS7OrPKCS10)	\
    (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10)

#define ICEnroll4_get_MyStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_MyStoreName(This,pbstrName)

#define ICEnroll4_put_MyStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_MyStoreName(This,bstrName)

#define ICEnroll4_get_MyStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_MyStoreType(This,pbstrType)

#define ICEnroll4_put_MyStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_MyStoreType(This,bstrType)

#define ICEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define ICEnroll4_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define ICEnroll4_get_CAStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_CAStoreName(This,pbstrName)

#define ICEnroll4_put_CAStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_CAStoreName(This,bstrName)

#define ICEnroll4_get_CAStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_CAStoreType(This,pbstrType)

#define ICEnroll4_put_CAStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_CAStoreType(This,bstrType)

#define ICEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define ICEnroll4_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define ICEnroll4_get_RootStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RootStoreName(This,pbstrName)

#define ICEnroll4_put_RootStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RootStoreName(This,bstrName)

#define ICEnroll4_get_RootStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RootStoreType(This,pbstrType)

#define ICEnroll4_put_RootStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RootStoreType(This,bstrType)

#define ICEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define ICEnroll4_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define ICEnroll4_get_RequestStoreName(This,pbstrName)	\
    (This)->lpVtbl -> get_RequestStoreName(This,pbstrName)

#define ICEnroll4_put_RequestStoreName(This,bstrName)	\
    (This)->lpVtbl -> put_RequestStoreName(This,bstrName)

#define ICEnroll4_get_RequestStoreType(This,pbstrType)	\
    (This)->lpVtbl -> get_RequestStoreType(This,pbstrType)

#define ICEnroll4_put_RequestStoreType(This,bstrType)	\
    (This)->lpVtbl -> put_RequestStoreType(This,bstrType)

#define ICEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define ICEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define ICEnroll4_get_ContainerName(This,pbstrContainer)	\
    (This)->lpVtbl -> get_ContainerName(This,pbstrContainer)

#define ICEnroll4_put_ContainerName(This,bstrContainer)	\
    (This)->lpVtbl -> put_ContainerName(This,bstrContainer)

#define ICEnroll4_get_ProviderName(This,pbstrProvider)	\
    (This)->lpVtbl -> get_ProviderName(This,pbstrProvider)

#define ICEnroll4_put_ProviderName(This,bstrProvider)	\
    (This)->lpVtbl -> put_ProviderName(This,bstrProvider)

#define ICEnroll4_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define ICEnroll4_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define ICEnroll4_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define ICEnroll4_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define ICEnroll4_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define ICEnroll4_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define ICEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define ICEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define ICEnroll4_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define ICEnroll4_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define ICEnroll4_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define ICEnroll4_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define ICEnroll4_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define ICEnroll4_get_SPCFileName(This,pbstr)	\
    (This)->lpVtbl -> get_SPCFileName(This,pbstr)

#define ICEnroll4_put_SPCFileName(This,bstr)	\
    (This)->lpVtbl -> put_SPCFileName(This,bstr)

#define ICEnroll4_get_PVKFileName(This,pbstr)	\
    (This)->lpVtbl -> get_PVKFileName(This,pbstr)

#define ICEnroll4_put_PVKFileName(This,bstr)	\
    (This)->lpVtbl -> put_PVKFileName(This,bstr)

#define ICEnroll4_get_HashAlgorithm(This,pbstr)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,pbstr)

#define ICEnroll4_put_HashAlgorithm(This,bstr)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,bstr)


#define ICEnroll4_addCertTypeToRequest(This,CertType)	\
    (This)->lpVtbl -> addCertTypeToRequest(This,CertType)

#define ICEnroll4_addNameValuePairToSignature(This,Name,Value)	\
    (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value)

#define ICEnroll4_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define ICEnroll4_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define ICEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define ICEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)


#define ICEnroll4_InstallPKCS7(This,PKCS7)	\
    (This)->lpVtbl -> InstallPKCS7(This,PKCS7)

#define ICEnroll4_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec)

#define ICEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize)

#define ICEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID)

#define ICEnroll4_GetAlgName(This,algID,pbstr)	\
    (This)->lpVtbl -> GetAlgName(This,algID,pbstr)

#define ICEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define ICEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define ICEnroll4_put_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> put_HashAlgID(This,hashAlgID)

#define ICEnroll4_get_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> get_HashAlgID(This,hashAlgID)

#define ICEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define ICEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define ICEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#define ICEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)


#define ICEnroll4_put_PrivateKeyArchiveCertificate(This,bstrCert)	\
    (This)->lpVtbl -> put_PrivateKeyArchiveCertificate(This,bstrCert)

#define ICEnroll4_get_PrivateKeyArchiveCertificate(This,pbstrCert)	\
    (This)->lpVtbl -> get_PrivateKeyArchiveCertificate(This,pbstrCert)

#define ICEnroll4_put_ThumbPrint(This,bstrThumbPrint)	\
    (This)->lpVtbl -> put_ThumbPrint(This,bstrThumbPrint)

#define ICEnroll4_get_ThumbPrint(This,pbstrThumbPrint)	\
    (This)->lpVtbl -> get_ThumbPrint(This,pbstrThumbPrint)

#define ICEnroll4_binaryToString(This,Flags,strBinary,pstrEncoded)	\
    (This)->lpVtbl -> binaryToString(This,Flags,strBinary,pstrEncoded)

#define ICEnroll4_stringToBinary(This,Flags,strEncoded,pstrBinary)	\
    (This)->lpVtbl -> stringToBinary(This,Flags,strEncoded,pstrBinary)

#define ICEnroll4_addExtensionToRequest(This,Flags,strName,strValue)	\
    (This)->lpVtbl -> addExtensionToRequest(This,Flags,strName,strValue)

#define ICEnroll4_addAttributeToRequest(This,Flags,strName,strValue)	\
    (This)->lpVtbl -> addAttributeToRequest(This,Flags,strName,strValue)

#define ICEnroll4_addNameValuePairToRequest(This,Flags,strName,strValue)	\
    (This)->lpVtbl -> addNameValuePairToRequest(This,Flags,strName,strValue)

#define ICEnroll4_resetExtensions(This)	\
    (This)->lpVtbl -> resetExtensions(This)

#define ICEnroll4_resetAttributes(This)	\
    (This)->lpVtbl -> resetAttributes(This)

#define ICEnroll4_createRequest(This,Flags,strDNName,Usage,pstrRequest)	\
    (This)->lpVtbl -> createRequest(This,Flags,strDNName,Usage,pstrRequest)

#define ICEnroll4_createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName)	\
    (This)->lpVtbl -> createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName)

#define ICEnroll4_acceptResponse(This,strResponse)	\
    (This)->lpVtbl -> acceptResponse(This,strResponse)

#define ICEnroll4_acceptFileResponse(This,strResponseFileName)	\
    (This)->lpVtbl -> acceptFileResponse(This,strResponseFileName)

#define ICEnroll4_getCertFromResponse(This,strResponse,pstrCert)	\
    (This)->lpVtbl -> getCertFromResponse(This,strResponse,pstrCert)

#define ICEnroll4_getCertFromFileResponse(This,strResponseFileName,pstrCert)	\
    (This)->lpVtbl -> getCertFromFileResponse(This,strResponseFileName,pstrCert)

#define ICEnroll4_createPFX(This,strPassword,pstrPFX)	\
    (This)->lpVtbl -> createPFX(This,strPassword,pstrPFX)

#define ICEnroll4_createFilePFX(This,strPassword,strPFXFileName)	\
    (This)->lpVtbl -> createFilePFX(This,strPassword,strPFXFileName)

#define ICEnroll4_setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName)	\
    (This)->lpVtbl -> setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName)

#define ICEnroll4_enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty)	\
    (This)->lpVtbl -> enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty)

#define ICEnroll4_removePendingRequest(This,strThumbprint)	\
    (This)->lpVtbl -> removePendingRequest(This,strThumbprint)

#define ICEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)

#define ICEnroll4_InstallPKCS7Ex(This,PKCS7,plCertInstalled)	\
    (This)->lpVtbl -> InstallPKCS7Ex(This,PKCS7,plCertInstalled)

#define ICEnroll4_addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    (This)->lpVtbl -> addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)

#define ICEnroll4_getProviderType(This,strProvName,plProvType)	\
    (This)->lpVtbl -> getProviderType(This,strProvName,plProvType)

#define ICEnroll4_put_SignerCertificate(This,bstrCert)	\
    (This)->lpVtbl -> put_SignerCertificate(This,bstrCert)

#define ICEnroll4_put_ClientId(This,lClientId)	\
    (This)->lpVtbl -> put_ClientId(This,lClientId)

#define ICEnroll4_get_ClientId(This,plClientId)	\
    (This)->lpVtbl -> get_ClientId(This,plClientId)

#define ICEnroll4_addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty)	\
    (This)->lpVtbl -> addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty)

#define ICEnroll4_resetBlobProperties(This)	\
    (This)->lpVtbl -> resetBlobProperties(This)

#define ICEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude)

#define ICEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll4_put_PrivateKeyArchiveCertificate_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR bstrCert);


void __RPC_STUB ICEnroll4_put_PrivateKeyArchiveCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll4_get_PrivateKeyArchiveCertificate_Proxy( 
    ICEnroll4 * This,
    /* [retval][out] */ BSTR *pbstrCert);


void __RPC_STUB ICEnroll4_get_PrivateKeyArchiveCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll4_put_ThumbPrint_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR bstrThumbPrint);


void __RPC_STUB ICEnroll4_put_ThumbPrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll4_get_ThumbPrint_Proxy( 
    ICEnroll4 * This,
    /* [retval][out] */ BSTR *pbstrThumbPrint);


void __RPC_STUB ICEnroll4_get_ThumbPrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_binaryToString_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strBinary,
    /* [retval][out] */ BSTR *pstrEncoded);


void __RPC_STUB ICEnroll4_binaryToString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_stringToBinary_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strEncoded,
    /* [retval][out] */ BSTR *pstrBinary);


void __RPC_STUB ICEnroll4_stringToBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_addExtensionToRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strName,
    /* [in] */ BSTR strValue);


void __RPC_STUB ICEnroll4_addExtensionToRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_addAttributeToRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strName,
    /* [in] */ BSTR strValue);


void __RPC_STUB ICEnroll4_addAttributeToRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_addNameValuePairToRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strName,
    /* [in] */ BSTR strValue);


void __RPC_STUB ICEnroll4_addNameValuePairToRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_resetExtensions_Proxy( 
    ICEnroll4 * This);


void __RPC_STUB ICEnroll4_resetExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_resetAttributes_Proxy( 
    ICEnroll4 * This);


void __RPC_STUB ICEnroll4_resetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_createRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strDNName,
    /* [in] */ BSTR Usage,
    /* [retval][out] */ BSTR *pstrRequest);


void __RPC_STUB ICEnroll4_createRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_createFileRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR strDNName,
    /* [in] */ BSTR strUsage,
    /* [in] */ BSTR strRequestFileName);


void __RPC_STUB ICEnroll4_createFileRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_acceptResponse_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strResponse);


void __RPC_STUB ICEnroll4_acceptResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_acceptFileResponse_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strResponseFileName);


void __RPC_STUB ICEnroll4_acceptFileResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_getCertFromResponse_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strResponse,
    /* [retval][out] */ BSTR *pstrCert);


void __RPC_STUB ICEnroll4_getCertFromResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_getCertFromFileResponse_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strResponseFileName,
    /* [retval][out] */ BSTR *pstrCert);


void __RPC_STUB ICEnroll4_getCertFromFileResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_createPFX_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strPassword,
    /* [retval][out] */ BSTR *pstrPFX);


void __RPC_STUB ICEnroll4_createPFX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_createFilePFX_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strPassword,
    /* [in] */ BSTR strPFXFileName);


void __RPC_STUB ICEnroll4_createFilePFX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_setPendingRequestInfo_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lRequestID,
    /* [in] */ BSTR strCADNS,
    /* [in] */ BSTR strCAName,
    /* [in] */ BSTR strFriendlyName);


void __RPC_STUB ICEnroll4_setPendingRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_enumPendingRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lIndex,
    /* [in] */ LONG lDesiredProperty,
    /* [retval][out] */ VARIANT *pvarProperty);


void __RPC_STUB ICEnroll4_enumPendingRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_removePendingRequest_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strThumbprint);


void __RPC_STUB ICEnroll4_removePendingRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_GetKeyLenEx_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lSizeSpec,
    /* [in] */ LONG lKeySpec,
    /* [retval][out] */ LONG *pdwKeySize);


void __RPC_STUB ICEnroll4_GetKeyLenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_InstallPKCS7Ex_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR PKCS7,
    /* [retval][out] */ LONG *plCertInstalled);


void __RPC_STUB ICEnroll4_InstallPKCS7Ex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_addCertTypeToRequestEx_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lType,
    /* [in] */ BSTR bstrOIDOrName,
    /* [in] */ LONG lMajorVersion,
    /* [in] */ BOOL fMinorVersion,
    /* [in] */ LONG lMinorVersion);


void __RPC_STUB ICEnroll4_addCertTypeToRequestEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_getProviderType_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR strProvName,
    /* [retval][out] */ LONG *plProvType);


void __RPC_STUB ICEnroll4_getProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll4_put_SignerCertificate_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BSTR bstrCert);


void __RPC_STUB ICEnroll4_put_SignerCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll4_put_ClientId_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lClientId);


void __RPC_STUB ICEnroll4_put_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll4_get_ClientId_Proxy( 
    ICEnroll4 * This,
    /* [retval][out] */ LONG *plClientId);


void __RPC_STUB ICEnroll4_get_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_addBlobPropertyToCertificate_Proxy( 
    ICEnroll4 * This,
    /* [in] */ LONG lPropertyId,
    /* [in] */ LONG lReserved,
    /* [in] */ BSTR bstrProperty);


void __RPC_STUB ICEnroll4_addBlobPropertyToCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICEnroll4_resetBlobProperties_Proxy( 
    ICEnroll4 * This);


void __RPC_STUB ICEnroll4_resetBlobProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ICEnroll4_put_IncludeSubjectKeyID_Proxy( 
    ICEnroll4 * This,
    /* [in] */ BOOL fInclude);


void __RPC_STUB ICEnroll4_put_IncludeSubjectKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE ICEnroll4_get_IncludeSubjectKeyID_Proxy( 
    ICEnroll4 * This,
    /* [retval][out] */ BOOL *pfInclude);


void __RPC_STUB ICEnroll4_get_IncludeSubjectKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICEnroll4_INTERFACE_DEFINED__ */


#ifndef __IEnroll_INTERFACE_DEFINED__
#define __IEnroll_INTERFACE_DEFINED__

/* interface IEnroll */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("acaa7838-4585-11d1-ab57-00c04fc295e1")
    IEnroll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7WStr( 
            /* [in] */ LPCWSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE getCertContextFromPKCS7( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getMyStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getCAStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getROOTHStore( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProvidersWStr( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainersWStr( 
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfoBlob( 
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerNameWStr( 
            /* [out] */ LPWSTR *szwContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerNameWStr( 
            /* [in] */ LPWSTR szwContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderNameWStr( 
            /* [out] */ LPWSTR *szwProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderNameWStr( 
            /* [in] */ LPWSTR szwProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [out] */ LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [out] */ LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [out] */ BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [out] */ BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithmWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithmWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [in] */ PCCERT_CONTEXT pCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNameValuePairToSignatureWStr( 
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtensionsToRequest( 
            /* [in] */ PCERT_EXTENSIONS pCertExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAuthenticatedAttributesToPKCS7Request( 
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePKCS7RequestFromRequest( 
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        END_INTERFACE
    } IEnrollVtbl;

    interface IEnroll
    {
        CONST_VTBL struct IEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnroll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnroll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnroll_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)

#define IEnroll_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName)

#define IEnroll_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)

#define IEnroll_acceptPKCS7Blob(This,pBlobPKCS7)	\
    (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7)

#define IEnroll_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7)

#define IEnroll_getMyStore(This)	\
    (This)->lpVtbl -> getMyStore(This)

#define IEnroll_getCAStore(This)	\
    (This)->lpVtbl -> getCAStore(This)

#define IEnroll_getROOTHStore(This)	\
    (This)->lpVtbl -> getROOTHStore(This)

#define IEnroll_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)

#define IEnroll_enumContainersWStr(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr)

#define IEnroll_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10)

#define IEnroll_get_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName)

#define IEnroll_put_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName)

#define IEnroll_get_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType)

#define IEnroll_put_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType)

#define IEnroll_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define IEnroll_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define IEnroll_get_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName)

#define IEnroll_put_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName)

#define IEnroll_get_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType)

#define IEnroll_put_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType)

#define IEnroll_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define IEnroll_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define IEnroll_get_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName)

#define IEnroll_put_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName)

#define IEnroll_get_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType)

#define IEnroll_put_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType)

#define IEnroll_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define IEnroll_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define IEnroll_get_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName)

#define IEnroll_put_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName)

#define IEnroll_get_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType)

#define IEnroll_put_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType)

#define IEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define IEnroll_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define IEnroll_get_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer)

#define IEnroll_put_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer)

#define IEnroll_get_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider)

#define IEnroll_put_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider)

#define IEnroll_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define IEnroll_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define IEnroll_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define IEnroll_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define IEnroll_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define IEnroll_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define IEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define IEnroll_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define IEnroll_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define IEnroll_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define IEnroll_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define IEnroll_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define IEnroll_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define IEnroll_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)

#define IEnroll_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define IEnroll_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define IEnroll_get_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_SPCFileNameWStr(This,szw)

#define IEnroll_put_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_SPCFileNameWStr(This,szw)

#define IEnroll_get_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_PVKFileNameWStr(This,szw)

#define IEnroll_put_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_PVKFileNameWStr(This,szw)

#define IEnroll_get_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw)

#define IEnroll_put_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw)

#define IEnroll_get_RenewalCertificate(This,ppCertContext)	\
    (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext)

#define IEnroll_put_RenewalCertificate(This,pCertContext)	\
    (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext)

#define IEnroll_AddCertTypeToRequestWStr(This,szw)	\
    (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw)

#define IEnroll_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value)

#define IEnroll_AddExtensionsToRequest(This,pCertExtensions)	\
    (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions)

#define IEnroll_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)

#define IEnroll_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnroll_createFilePKCS10WStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR Usage,
    /* [in] */ LPCWSTR wszPKCS10FileName);


void __RPC_STUB IEnroll_createFilePKCS10WStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_acceptFilePKCS7WStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPCWSTR wszPKCS7FileName);


void __RPC_STUB IEnroll_acceptFilePKCS7WStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_createPKCS10WStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPCWSTR DNName,
    /* [in] */ LPCWSTR Usage,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);


void __RPC_STUB IEnroll_createPKCS10WStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_acceptPKCS7Blob_Proxy( 
    IEnroll * This,
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);


void __RPC_STUB IEnroll_acceptPKCS7Blob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


PCCERT_CONTEXT STDMETHODCALLTYPE IEnroll_getCertContextFromPKCS7_Proxy( 
    IEnroll * This,
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);


void __RPC_STUB IEnroll_getCertContextFromPKCS7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HCERTSTORE STDMETHODCALLTYPE IEnroll_getMyStore_Proxy( 
    IEnroll * This);


void __RPC_STUB IEnroll_getMyStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HCERTSTORE STDMETHODCALLTYPE IEnroll_getCAStore_Proxy( 
    IEnroll * This);


void __RPC_STUB IEnroll_getCAStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HCERTSTORE STDMETHODCALLTYPE IEnroll_getROOTHStore_Proxy( 
    IEnroll * This);


void __RPC_STUB IEnroll_getROOTHStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_enumProvidersWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG dwFlags,
    /* [out] */ LPWSTR *pbstrProvName);


void __RPC_STUB IEnroll_enumProvidersWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_enumContainersWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwIndex,
    /* [out] */ LPWSTR *pbstr);


void __RPC_STUB IEnroll_enumContainersWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_freeRequestInfoBlob_Proxy( 
    IEnroll * This,
    /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);


void __RPC_STUB IEnroll_freeRequestInfoBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_MyStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwName);


void __RPC_STUB IEnroll_get_MyStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_MyStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwName);


void __RPC_STUB IEnroll_put_MyStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_MyStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwType);


void __RPC_STUB IEnroll_get_MyStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_MyStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwType);


void __RPC_STUB IEnroll_put_MyStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_MyStoreFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_MyStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_MyStoreFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_MyStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_CAStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwName);


void __RPC_STUB IEnroll_get_CAStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_CAStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwName);


void __RPC_STUB IEnroll_put_CAStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_CAStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwType);


void __RPC_STUB IEnroll_get_CAStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_CAStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwType);


void __RPC_STUB IEnroll_put_CAStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_CAStoreFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_CAStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_CAStoreFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_CAStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RootStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwName);


void __RPC_STUB IEnroll_get_RootStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RootStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwName);


void __RPC_STUB IEnroll_put_RootStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RootStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwType);


void __RPC_STUB IEnroll_get_RootStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RootStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwType);


void __RPC_STUB IEnroll_put_RootStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RootStoreFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_RootStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RootStoreFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_RootStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RequestStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwName);


void __RPC_STUB IEnroll_get_RequestStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RequestStoreNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwName);


void __RPC_STUB IEnroll_put_RequestStoreNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RequestStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwType);


void __RPC_STUB IEnroll_get_RequestStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RequestStoreTypeWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwType);


void __RPC_STUB IEnroll_put_RequestStoreTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RequestStoreFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_RequestStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RequestStoreFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_RequestStoreFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_ContainerNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwContainer);


void __RPC_STUB IEnroll_get_ContainerNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_ContainerNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwContainer);


void __RPC_STUB IEnroll_put_ContainerNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_ProviderNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szwProvider);


void __RPC_STUB IEnroll_get_ProviderNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_ProviderNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szwProvider);


void __RPC_STUB IEnroll_put_ProviderNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_ProviderType_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwType);


void __RPC_STUB IEnroll_get_ProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_ProviderType_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwType);


void __RPC_STUB IEnroll_put_ProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_KeySpec_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdw);


void __RPC_STUB IEnroll_get_KeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_KeySpec_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dw);


void __RPC_STUB IEnroll_put_KeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_ProviderFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_ProviderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_ProviderFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_ProviderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_UseExistingKeySet_Proxy( 
    IEnroll * This,
    /* [out] */ BOOL *fUseExistingKeys);


void __RPC_STUB IEnroll_get_UseExistingKeySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_UseExistingKeySet_Proxy( 
    IEnroll * This,
    /* [in] */ BOOL fUseExistingKeys);


void __RPC_STUB IEnroll_put_UseExistingKeySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_GenKeyFlags_Proxy( 
    IEnroll * This,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll_get_GenKeyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_GenKeyFlags_Proxy( 
    IEnroll * This,
    /* [in] */ LONG dwFlags);


void __RPC_STUB IEnroll_put_GenKeyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_DeleteRequestCert_Proxy( 
    IEnroll * This,
    /* [out] */ BOOL *fDelete);


void __RPC_STUB IEnroll_get_DeleteRequestCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_DeleteRequestCert_Proxy( 
    IEnroll * This,
    /* [in] */ BOOL fDelete);


void __RPC_STUB IEnroll_put_DeleteRequestCert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_WriteCertToUserDS_Proxy( 
    IEnroll * This,
    /* [out] */ BOOL *fBool);


void __RPC_STUB IEnroll_get_WriteCertToUserDS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_WriteCertToUserDS_Proxy( 
    IEnroll * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB IEnroll_put_WriteCertToUserDS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_EnableT61DNEncoding_Proxy( 
    IEnroll * This,
    /* [out] */ BOOL *fBool);


void __RPC_STUB IEnroll_get_EnableT61DNEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_EnableT61DNEncoding_Proxy( 
    IEnroll * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB IEnroll_put_EnableT61DNEncoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_WriteCertToCSP_Proxy( 
    IEnroll * This,
    /* [out] */ BOOL *fBool);


void __RPC_STUB IEnroll_get_WriteCertToCSP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_WriteCertToCSP_Proxy( 
    IEnroll * This,
    /* [in] */ BOOL fBool);


void __RPC_STUB IEnroll_put_WriteCertToCSP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_SPCFileNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szw);


void __RPC_STUB IEnroll_get_SPCFileNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_SPCFileNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szw);


void __RPC_STUB IEnroll_put_SPCFileNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_PVKFileNameWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szw);


void __RPC_STUB IEnroll_get_PVKFileNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_PVKFileNameWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szw);


void __RPC_STUB IEnroll_put_PVKFileNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_HashAlgorithmWStr_Proxy( 
    IEnroll * This,
    /* [out] */ LPWSTR *szw);


void __RPC_STUB IEnroll_get_HashAlgorithmWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_HashAlgorithmWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szw);


void __RPC_STUB IEnroll_put_HashAlgorithmWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll_get_RenewalCertificate_Proxy( 
    IEnroll * This,
    /* [out] */ PCCERT_CONTEXT *ppCertContext);


void __RPC_STUB IEnroll_get_RenewalCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll_put_RenewalCertificate_Proxy( 
    IEnroll * This,
    /* [in] */ PCCERT_CONTEXT pCertContext);


void __RPC_STUB IEnroll_put_RenewalCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_AddCertTypeToRequestWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR szw);


void __RPC_STUB IEnroll_AddCertTypeToRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_AddNameValuePairToSignatureWStr_Proxy( 
    IEnroll * This,
    /* [in] */ LPWSTR Name,
    /* [in] */ LPWSTR Value);


void __RPC_STUB IEnroll_AddNameValuePairToSignatureWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_AddExtensionsToRequest_Proxy( 
    IEnroll * This,
    /* [in] */ PCERT_EXTENSIONS pCertExtensions);


void __RPC_STUB IEnroll_AddExtensionsToRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_AddAuthenticatedAttributesToPKCS7Request_Proxy( 
    IEnroll * This,
    /* [in] */ PCRYPT_ATTRIBUTES pAttributes);


void __RPC_STUB IEnroll_AddAuthenticatedAttributesToPKCS7Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll_CreatePKCS7RequestFromRequest_Proxy( 
    IEnroll * This,
    /* [in] */ PCRYPT_DATA_BLOB pRequest,
    /* [in] */ PCCERT_CONTEXT pSigningCertContext,
    /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);


void __RPC_STUB IEnroll_CreatePKCS7RequestFromRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnroll_INTERFACE_DEFINED__ */


#ifndef __IEnroll2_INTERFACE_DEFINED__
#define __IEnroll2_INTERFACE_DEFINED__

/* interface IEnroll2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c080e199-b7df-11d2-a421-00c04f79fe8e")
    IEnroll2 : public IEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [out] */ LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgNameWStr( 
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ LONG *hashAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreMy( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreCA( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreROOT( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreRequest( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll2 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll2 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll2 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll2 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll2 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll2 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll2 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } IEnroll2Vtbl;

    interface IEnroll2
    {
        CONST_VTBL struct IEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnroll2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnroll2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnroll2_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)

#define IEnroll2_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName)

#define IEnroll2_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)

#define IEnroll2_acceptPKCS7Blob(This,pBlobPKCS7)	\
    (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7)

#define IEnroll2_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7)

#define IEnroll2_getMyStore(This)	\
    (This)->lpVtbl -> getMyStore(This)

#define IEnroll2_getCAStore(This)	\
    (This)->lpVtbl -> getCAStore(This)

#define IEnroll2_getROOTHStore(This)	\
    (This)->lpVtbl -> getROOTHStore(This)

#define IEnroll2_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)

#define IEnroll2_enumContainersWStr(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr)

#define IEnroll2_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10)

#define IEnroll2_get_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName)

#define IEnroll2_put_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName)

#define IEnroll2_get_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType)

#define IEnroll2_put_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType)

#define IEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define IEnroll2_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define IEnroll2_get_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName)

#define IEnroll2_put_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName)

#define IEnroll2_get_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType)

#define IEnroll2_put_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType)

#define IEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define IEnroll2_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define IEnroll2_get_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName)

#define IEnroll2_put_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName)

#define IEnroll2_get_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType)

#define IEnroll2_put_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType)

#define IEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define IEnroll2_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define IEnroll2_get_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName)

#define IEnroll2_put_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName)

#define IEnroll2_get_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType)

#define IEnroll2_put_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType)

#define IEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define IEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define IEnroll2_get_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer)

#define IEnroll2_put_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer)

#define IEnroll2_get_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider)

#define IEnroll2_put_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider)

#define IEnroll2_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define IEnroll2_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define IEnroll2_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define IEnroll2_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define IEnroll2_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define IEnroll2_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define IEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define IEnroll2_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define IEnroll2_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define IEnroll2_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define IEnroll2_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define IEnroll2_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define IEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define IEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)

#define IEnroll2_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define IEnroll2_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define IEnroll2_get_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_SPCFileNameWStr(This,szw)

#define IEnroll2_put_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_SPCFileNameWStr(This,szw)

#define IEnroll2_get_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_PVKFileNameWStr(This,szw)

#define IEnroll2_put_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_PVKFileNameWStr(This,szw)

#define IEnroll2_get_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw)

#define IEnroll2_put_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw)

#define IEnroll2_get_RenewalCertificate(This,ppCertContext)	\
    (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext)

#define IEnroll2_put_RenewalCertificate(This,pCertContext)	\
    (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext)

#define IEnroll2_AddCertTypeToRequestWStr(This,szw)	\
    (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw)

#define IEnroll2_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value)

#define IEnroll2_AddExtensionsToRequest(This,pCertExtensions)	\
    (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions)

#define IEnroll2_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)

#define IEnroll2_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)


#define IEnroll2_InstallPKCS7Blob(This,pBlobPKCS7)	\
    (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7)

#define IEnroll2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnroll2_GetSupportedKeySpec(This,pdwKeySpec)	\
    (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec)

#define IEnroll2_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize)

#define IEnroll2_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID)

#define IEnroll2_GetAlgNameWStr(This,algID,ppwsz)	\
    (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz)

#define IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define IEnroll2_put_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> put_HashAlgID(This,hashAlgID)

#define IEnroll2_get_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> get_HashAlgID(This,hashAlgID)

#define IEnroll2_SetHStoreMy(This,hStore)	\
    (This)->lpVtbl -> SetHStoreMy(This,hStore)

#define IEnroll2_SetHStoreCA(This,hStore)	\
    (This)->lpVtbl -> SetHStoreCA(This,hStore)

#define IEnroll2_SetHStoreROOT(This,hStore)	\
    (This)->lpVtbl -> SetHStoreROOT(This,hStore)

#define IEnroll2_SetHStoreRequest(This,hStore)	\
    (This)->lpVtbl -> SetHStoreRequest(This,hStore)

#define IEnroll2_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define IEnroll2_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define IEnroll2_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#define IEnroll2_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnroll2_InstallPKCS7Blob_Proxy( 
    IEnroll2 * This,
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);


void __RPC_STUB IEnroll2_InstallPKCS7Blob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_Reset_Proxy( 
    IEnroll2 * This);


void __RPC_STUB IEnroll2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_GetSupportedKeySpec_Proxy( 
    IEnroll2 * This,
    /* [out] */ LONG *pdwKeySpec);


void __RPC_STUB IEnroll2_GetSupportedKeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_GetKeyLen_Proxy( 
    IEnroll2 * This,
    /* [in] */ BOOL fMin,
    /* [in] */ BOOL fExchange,
    /* [out] */ LONG *pdwKeySize);


void __RPC_STUB IEnroll2_GetKeyLen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_EnumAlgs_Proxy( 
    IEnroll2 * This,
    /* [in] */ LONG dwIndex,
    /* [in] */ LONG algClass,
    /* [out] */ LONG *pdwAlgID);


void __RPC_STUB IEnroll2_EnumAlgs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_GetAlgNameWStr_Proxy( 
    IEnroll2 * This,
    /* [in] */ LONG algID,
    /* [out] */ LPWSTR *ppwsz);


void __RPC_STUB IEnroll2_GetAlgNameWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew_Proxy( 
    IEnroll2 * This,
    /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);


void __RPC_STUB IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew_Proxy( 
    IEnroll2 * This,
    /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);


void __RPC_STUB IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll2_put_HashAlgID_Proxy( 
    IEnroll2 * This,
    /* [in] */ LONG hashAlgID);


void __RPC_STUB IEnroll2_put_HashAlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll2_get_HashAlgID_Proxy( 
    IEnroll2 * This,
    /* [retval][out] */ LONG *hashAlgID);


void __RPC_STUB IEnroll2_get_HashAlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_SetHStoreMy_Proxy( 
    IEnroll2 * This,
    /* [in] */ HCERTSTORE hStore);


void __RPC_STUB IEnroll2_SetHStoreMy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_SetHStoreCA_Proxy( 
    IEnroll2 * This,
    /* [in] */ HCERTSTORE hStore);


void __RPC_STUB IEnroll2_SetHStoreCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_SetHStoreROOT_Proxy( 
    IEnroll2 * This,
    /* [in] */ HCERTSTORE hStore);


void __RPC_STUB IEnroll2_SetHStoreROOT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll2_SetHStoreRequest_Proxy( 
    IEnroll2 * This,
    /* [in] */ HCERTSTORE hStore);


void __RPC_STUB IEnroll2_SetHStoreRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll2_put_LimitExchangeKeyToEncipherment_Proxy( 
    IEnroll2 * This,
    /* [in] */ BOOL fLimitExchangeKeyToEncipherment);


void __RPC_STUB IEnroll2_put_LimitExchangeKeyToEncipherment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll2_get_LimitExchangeKeyToEncipherment_Proxy( 
    IEnroll2 * This,
    /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);


void __RPC_STUB IEnroll2_get_LimitExchangeKeyToEncipherment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll2_put_EnableSMIMECapabilities_Proxy( 
    IEnroll2 * This,
    /* [in] */ BOOL fEnableSMIMECapabilities);


void __RPC_STUB IEnroll2_put_EnableSMIMECapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll2_get_EnableSMIMECapabilities_Proxy( 
    IEnroll2 * This,
    /* [retval][out] */ BOOL *fEnableSMIMECapabilities);


void __RPC_STUB IEnroll2_get_EnableSMIMECapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnroll2_INTERFACE_DEFINED__ */


#ifndef __IEnroll4_INTERFACE_DEFINED__
#define __IEnroll4_INTERFACE_DEFINED__

/* interface IEnroll4 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f8053fe5-78f4-448f-a0db-41d61b73446b")
    IEnroll4 : public IEnroll2
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrintWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrintWStr( 
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateKeyArchiveCertificate( 
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE GetPrivateKeyArchiveCertificate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryBlobToString( 
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinaryBlob( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfoWStr( 
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequestWStr( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequestWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7BlobEx( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStrEx( 
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderTypeWStr( 
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificateWStr( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignerCertificate( 
            /* [in] */ PCCERT_CONTEXT pSignerCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ LONG *plClientId) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll4 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll4 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *GetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *binaryBlobToString )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinaryBlob )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *createPFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfoWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7BlobEx )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStrEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificateWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignerCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pSignerCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *plClientId);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *pfInclude);
        
        END_INTERFACE
    } IEnroll4Vtbl;

    interface IEnroll4
    {
        CONST_VTBL struct IEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll4_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnroll4_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnroll4_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnroll4_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)

#define IEnroll4_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName)

#define IEnroll4_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)

#define IEnroll4_acceptPKCS7Blob(This,pBlobPKCS7)	\
    (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7)

#define IEnroll4_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7)

#define IEnroll4_getMyStore(This)	\
    (This)->lpVtbl -> getMyStore(This)

#define IEnroll4_getCAStore(This)	\
    (This)->lpVtbl -> getCAStore(This)

#define IEnroll4_getROOTHStore(This)	\
    (This)->lpVtbl -> getROOTHStore(This)

#define IEnroll4_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)

#define IEnroll4_enumContainersWStr(This,dwIndex,pbstr)	\
    (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr)

#define IEnroll4_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10)

#define IEnroll4_get_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName)

#define IEnroll4_put_MyStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName)

#define IEnroll4_get_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType)

#define IEnroll4_put_MyStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType)

#define IEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags)

#define IEnroll4_put_MyStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags)

#define IEnroll4_get_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName)

#define IEnroll4_put_CAStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName)

#define IEnroll4_get_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType)

#define IEnroll4_put_CAStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType)

#define IEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags)

#define IEnroll4_put_CAStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags)

#define IEnroll4_get_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName)

#define IEnroll4_put_RootStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName)

#define IEnroll4_get_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType)

#define IEnroll4_put_RootStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType)

#define IEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags)

#define IEnroll4_put_RootStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags)

#define IEnroll4_get_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName)

#define IEnroll4_put_RequestStoreNameWStr(This,szwName)	\
    (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName)

#define IEnroll4_get_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType)

#define IEnroll4_put_RequestStoreTypeWStr(This,szwType)	\
    (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType)

#define IEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags)

#define IEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags)

#define IEnroll4_get_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer)

#define IEnroll4_put_ContainerNameWStr(This,szwContainer)	\
    (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer)

#define IEnroll4_get_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider)

#define IEnroll4_put_ProviderNameWStr(This,szwProvider)	\
    (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider)

#define IEnroll4_get_ProviderType(This,pdwType)	\
    (This)->lpVtbl -> get_ProviderType(This,pdwType)

#define IEnroll4_put_ProviderType(This,dwType)	\
    (This)->lpVtbl -> put_ProviderType(This,dwType)

#define IEnroll4_get_KeySpec(This,pdw)	\
    (This)->lpVtbl -> get_KeySpec(This,pdw)

#define IEnroll4_put_KeySpec(This,dw)	\
    (This)->lpVtbl -> put_KeySpec(This,dw)

#define IEnroll4_get_ProviderFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags)

#define IEnroll4_put_ProviderFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_ProviderFlags(This,dwFlags)

#define IEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys)

#define IEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags)

#define IEnroll4_put_GenKeyFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags)

#define IEnroll4_get_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete)

#define IEnroll4_put_DeleteRequestCert(This,fDelete)	\
    (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete)

#define IEnroll4_get_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool)

#define IEnroll4_put_WriteCertToUserDS(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool)

#define IEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool)

#define IEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool)

#define IEnroll4_get_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> get_WriteCertToCSP(This,fBool)

#define IEnroll4_put_WriteCertToCSP(This,fBool)	\
    (This)->lpVtbl -> put_WriteCertToCSP(This,fBool)

#define IEnroll4_get_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_SPCFileNameWStr(This,szw)

#define IEnroll4_put_SPCFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_SPCFileNameWStr(This,szw)

#define IEnroll4_get_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> get_PVKFileNameWStr(This,szw)

#define IEnroll4_put_PVKFileNameWStr(This,szw)	\
    (This)->lpVtbl -> put_PVKFileNameWStr(This,szw)

#define IEnroll4_get_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw)

#define IEnroll4_put_HashAlgorithmWStr(This,szw)	\
    (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw)

#define IEnroll4_get_RenewalCertificate(This,ppCertContext)	\
    (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext)

#define IEnroll4_put_RenewalCertificate(This,pCertContext)	\
    (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext)

#define IEnroll4_AddCertTypeToRequestWStr(This,szw)	\
    (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw)

#define IEnroll4_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value)

#define IEnroll4_AddExtensionsToRequest(This,pCertExtensions)	\
    (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions)

#define IEnroll4_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)

#define IEnroll4_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)


#define IEnroll4_InstallPKCS7Blob(This,pBlobPKCS7)	\
    (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7)

#define IEnroll4_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec)

#define IEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize)

#define IEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID)

#define IEnroll4_GetAlgNameWStr(This,algID,ppwsz)	\
    (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz)

#define IEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define IEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)

#define IEnroll4_put_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> put_HashAlgID(This,hashAlgID)

#define IEnroll4_get_HashAlgID(This,hashAlgID)	\
    (This)->lpVtbl -> get_HashAlgID(This,hashAlgID)

#define IEnroll4_SetHStoreMy(This,hStore)	\
    (This)->lpVtbl -> SetHStoreMy(This,hStore)

#define IEnroll4_SetHStoreCA(This,hStore)	\
    (This)->lpVtbl -> SetHStoreCA(This,hStore)

#define IEnroll4_SetHStoreROOT(This,hStore)	\
    (This)->lpVtbl -> SetHStoreROOT(This,hStore)

#define IEnroll4_SetHStoreRequest(This,hStore)	\
    (This)->lpVtbl -> SetHStoreRequest(This,hStore)

#define IEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define IEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)

#define IEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)

#define IEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)


#define IEnroll4_put_ThumbPrintWStr(This,thumbPrintBlob)	\
    (This)->lpVtbl -> put_ThumbPrintWStr(This,thumbPrintBlob)

#define IEnroll4_get_ThumbPrintWStr(This,thumbPrintBlob)	\
    (This)->lpVtbl -> get_ThumbPrintWStr(This,thumbPrintBlob)

#define IEnroll4_SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert)	\
    (This)->lpVtbl -> SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert)

#define IEnroll4_GetPrivateKeyArchiveCertificate(This)	\
    (This)->lpVtbl -> GetPrivateKeyArchiveCertificate(This)

#define IEnroll4_binaryBlobToString(This,Flags,pblobBinary,ppwszString)	\
    (This)->lpVtbl -> binaryBlobToString(This,Flags,pblobBinary,ppwszString)

#define IEnroll4_stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags)	\
    (This)->lpVtbl -> stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags)

#define IEnroll4_addExtensionToRequestWStr(This,Flags,pwszName,pblobValue)	\
    (This)->lpVtbl -> addExtensionToRequestWStr(This,Flags,pwszName,pblobValue)

#define IEnroll4_addAttributeToRequestWStr(This,Flags,pwszName,pblobValue)	\
    (This)->lpVtbl -> addAttributeToRequestWStr(This,Flags,pwszName,pblobValue)

#define IEnroll4_addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue)	\
    (This)->lpVtbl -> addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue)

#define IEnroll4_resetExtensions(This)	\
    (This)->lpVtbl -> resetExtensions(This)

#define IEnroll4_resetAttributes(This)	\
    (This)->lpVtbl -> resetAttributes(This)

#define IEnroll4_createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest)	\
    (This)->lpVtbl -> createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest)

#define IEnroll4_createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName)	\
    (This)->lpVtbl -> createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName)

#define IEnroll4_acceptResponseBlob(This,pblobResponse)	\
    (This)->lpVtbl -> acceptResponseBlob(This,pblobResponse)

#define IEnroll4_acceptFileResponseWStr(This,pwszResponseFileName)	\
    (This)->lpVtbl -> acceptFileResponseWStr(This,pwszResponseFileName)

#define IEnroll4_getCertContextFromResponseBlob(This,pblobResponse,ppCertContext)	\
    (This)->lpVtbl -> getCertContextFromResponseBlob(This,pblobResponse,ppCertContext)

#define IEnroll4_getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext)	\
    (This)->lpVtbl -> getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext)

#define IEnroll4_createPFXWStr(This,pwszPassword,pblobPFX)	\
    (This)->lpVtbl -> createPFXWStr(This,pwszPassword,pblobPFX)

#define IEnroll4_createFilePFXWStr(This,pwszPassword,pwszPFXFileName)	\
    (This)->lpVtbl -> createFilePFXWStr(This,pwszPassword,pwszPFXFileName)

#define IEnroll4_setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName)	\
    (This)->lpVtbl -> setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName)

#define IEnroll4_enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty)	\
    (This)->lpVtbl -> enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty)

#define IEnroll4_removePendingRequestWStr(This,thumbPrintBlob)	\
    (This)->lpVtbl -> removePendingRequestWStr(This,thumbPrintBlob)

#define IEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)

#define IEnroll4_InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled)	\
    (This)->lpVtbl -> InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled)

#define IEnroll4_AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    (This)->lpVtbl -> AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)

#define IEnroll4_getProviderTypeWStr(This,pwszProvName,plProvType)	\
    (This)->lpVtbl -> getProviderTypeWStr(This,pwszProvName,plProvType)

#define IEnroll4_addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty)	\
    (This)->lpVtbl -> addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty)

#define IEnroll4_SetSignerCertificate(This,pSignerCert)	\
    (This)->lpVtbl -> SetSignerCertificate(This,pSignerCert)

#define IEnroll4_put_ClientId(This,lClientId)	\
    (This)->lpVtbl -> put_ClientId(This,lClientId)

#define IEnroll4_get_ClientId(This,plClientId)	\
    (This)->lpVtbl -> get_ClientId(This,plClientId)

#define IEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude)

#define IEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll4_put_ThumbPrintWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);


void __RPC_STUB IEnroll4_put_ThumbPrintWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll4_get_ThumbPrintWStr_Proxy( 
    IEnroll4 * This,
    /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob);


void __RPC_STUB IEnroll4_get_ThumbPrintWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_SetPrivateKeyArchiveCertificate_Proxy( 
    IEnroll4 * This,
    /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert);


void __RPC_STUB IEnroll4_SetPrivateKeyArchiveCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


PCCERT_CONTEXT STDMETHODCALLTYPE IEnroll4_GetPrivateKeyArchiveCertificate_Proxy( 
    IEnroll4 * This);


void __RPC_STUB IEnroll4_GetPrivateKeyArchiveCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_binaryBlobToString_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
    /* [out] */ LPWSTR *ppwszString);


void __RPC_STUB IEnroll4_binaryBlobToString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_stringToBinaryBlob_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszString,
    /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
    /* [out] */ LONG *pdwSkip,
    /* [out] */ LONG *pdwFlags);


void __RPC_STUB IEnroll4_stringToBinaryBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_addExtensionToRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszName,
    /* [in] */ PCRYPT_DATA_BLOB pblobValue);


void __RPC_STUB IEnroll4_addExtensionToRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_addAttributeToRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszName,
    /* [in] */ PCRYPT_DATA_BLOB pblobValue);


void __RPC_STUB IEnroll4_addAttributeToRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_addNameValuePairToRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszName,
    /* [in] */ LPCWSTR pwszValue);


void __RPC_STUB IEnroll4_addNameValuePairToRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_resetExtensions_Proxy( 
    IEnroll4 * This);


void __RPC_STUB IEnroll4_resetExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_resetAttributes_Proxy( 
    IEnroll4 * This);


void __RPC_STUB IEnroll4_resetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_createRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszDNName,
    /* [in] */ LPCWSTR pwszUsage,
    /* [out] */ PCRYPT_DATA_BLOB pblobRequest);


void __RPC_STUB IEnroll4_createRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_createFileRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG Flags,
    /* [in] */ LPCWSTR pwszDNName,
    /* [in] */ LPCWSTR pwszUsage,
    /* [in] */ LPCWSTR pwszRequestFileName);


void __RPC_STUB IEnroll4_createFileRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_acceptResponseBlob_Proxy( 
    IEnroll4 * This,
    /* [in] */ PCRYPT_DATA_BLOB pblobResponse);


void __RPC_STUB IEnroll4_acceptResponseBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_acceptFileResponseWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LPCWSTR pwszResponseFileName);


void __RPC_STUB IEnroll4_acceptFileResponseWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_getCertContextFromResponseBlob_Proxy( 
    IEnroll4 * This,
    /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
    /* [out] */ PCCERT_CONTEXT *ppCertContext);


void __RPC_STUB IEnroll4_getCertContextFromResponseBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_getCertContextFromFileResponseWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LPCWSTR pwszResponseFileName,
    /* [out] */ PCCERT_CONTEXT *ppCertContext);


void __RPC_STUB IEnroll4_getCertContextFromFileResponseWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_createPFXWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LPCWSTR pwszPassword,
    /* [out] */ PCRYPT_DATA_BLOB pblobPFX);


void __RPC_STUB IEnroll4_createPFXWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_createFilePFXWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LPCWSTR pwszPassword,
    /* [in] */ LPCWSTR pwszPFXFileName);


void __RPC_STUB IEnroll4_createFilePFXWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_setPendingRequestInfoWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lRequestID,
    /* [in] */ LPCWSTR pwszCADNS,
    /* [in] */ LPCWSTR pwszCAName,
    /* [in] */ LPCWSTR pwszFriendlyName);


void __RPC_STUB IEnroll4_setPendingRequestInfoWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_enumPendingRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lIndex,
    /* [in] */ LONG lDesiredProperty,
    /* [out] */ LPVOID ppProperty);


void __RPC_STUB IEnroll4_enumPendingRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_removePendingRequestWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);


void __RPC_STUB IEnroll4_removePendingRequestWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_GetKeyLenEx_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lSizeSpec,
    /* [in] */ LONG lKeySpec,
    /* [retval][out] */ LONG *pdwKeySize);


void __RPC_STUB IEnroll4_GetKeyLenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_InstallPKCS7BlobEx_Proxy( 
    IEnroll4 * This,
    /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
    /* [retval][out] */ LONG *plCertInstalled);


void __RPC_STUB IEnroll4_InstallPKCS7BlobEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_AddCertTypeToRequestWStrEx_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lType,
    /* [in] */ LPCWSTR pwszOIDOrName,
    /* [in] */ LONG lMajorVersion,
    /* [in] */ BOOL fMinorVersion,
    /* [in] */ LONG lMinorVersion);


void __RPC_STUB IEnroll4_AddCertTypeToRequestWStrEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_getProviderTypeWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LPCWSTR pwszProvName,
    /* [retval][out] */ LONG *plProvType);


void __RPC_STUB IEnroll4_getProviderTypeWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_addBlobPropertyToCertificateWStr_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lPropertyId,
    /* [in] */ LONG lReserved,
    /* [in] */ PCRYPT_DATA_BLOB pBlobProperty);


void __RPC_STUB IEnroll4_addBlobPropertyToCertificateWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnroll4_SetSignerCertificate_Proxy( 
    IEnroll4 * This,
    /* [in] */ PCCERT_CONTEXT pSignerCert);


void __RPC_STUB IEnroll4_SetSignerCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll4_put_ClientId_Proxy( 
    IEnroll4 * This,
    /* [in] */ LONG lClientId);


void __RPC_STUB IEnroll4_put_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll4_get_ClientId_Proxy( 
    IEnroll4 * This,
    /* [retval][out] */ LONG *plClientId);


void __RPC_STUB IEnroll4_get_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IEnroll4_put_IncludeSubjectKeyID_Proxy( 
    IEnroll4 * This,
    /* [in] */ BOOL fInclude);


void __RPC_STUB IEnroll4_put_IncludeSubjectKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IEnroll4_get_IncludeSubjectKeyID_Proxy( 
    IEnroll4 * This,
    /* [retval][out] */ BOOL *pfInclude);


void __RPC_STUB IEnroll4_get_IncludeSubjectKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnroll4_INTERFACE_DEFINED__ */



#ifndef __XENROLLLib_LIBRARY_DEFINED__
#define __XENROLLLib_LIBRARY_DEFINED__

/* library XENROLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XENROLLLib;

EXTERN_C const CLSID CLSID_CEnroll2;

#ifdef __cplusplus

class DECLSPEC_UUID("127698e4-e730-4e5c-a2b1-21490a70c8a1")
CEnroll2;
#endif

EXTERN_C const CLSID CLSID_CEnroll;

#ifdef __cplusplus

class DECLSPEC_UUID("43F8F289-7A20-11D0-8F06-00C04FC295E1")
CEnroll;
#endif
#endif /* __XENROLLLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xenroll_0265 */
/* [local] */ 

extern "C" IEnroll * WINAPI PIEnrollGetNoCOM(void);
extern "C" IEnroll2 * WINAPI PIEnroll2GetNoCOM(void);
extern "C" IEnroll4 * WINAPI PIEnroll4GetNoCOM(void);
#define CRYPT_ENUM_ALL_PROVIDERS  0x1
#define XEPR_ENUM_FIRST        -1
#define XEPR_CADNS           0x01
#define XEPR_CANAME          0x02
#define XEPR_CAFRIENDLYNAME  0x03
#define XEPR_REQUESTID       0x04
#define XEPR_DATE            0x05
#define XEPR_TEMPLATENAME    0x06
#define XEPR_VERSION         0x07
#define XEPR_HASH            0x08
#define XEPR_V1TEMPLATENAME  0x09
#define XEPR_V2TEMPLATEOID   0x10
#define XECR_PKCS10_V2_0     0x1
#define XECR_PKCS7           0x2
#define XECR_CMC             0x3
#define XECR_PKCS10_V1_5     0x4
#define XEKL_KEYSIZE_MIN     0x1
#define XEKL_KEYSIZE_MAX     0x2
#define XEKL_KEYSIZE_INC     0x3
#define XEKL_KEYSIZE_DEFAULT 0x4
#define XEKL_KEYSPEC_KEYX    0x1
#define XEKL_KEYSPEC_SIG     0x2
#define XECT_EXTENSION_V1    0x1
#define XECT_EXTENSION_V2    0x2
#define XECP_STRING_PROPERTY 0x1
#define XECI_DISABLE     0x0
#define XECI_XENROLL     0x1
#define XECI_AUTOENROLL  0x2
#define XECI_REQWIZARD   0x3
#define XECI_CERTREQ     0x4


extern RPC_IF_HANDLE __MIDL_itf_xenroll_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xenroll_0265_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xa.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* -----------------------------------------------------------------
 * Microsoft Distributed Transaction Coordinator
 * Microsoft Corporation, 1995.
 *
 * File : xa.h 
 * 
 * Contents : This file is derived from xa.h as it appears in 
 * "Distributed Transaction Processing: The XA Specification", 
 * November 93, X/Open Company Limited.
 *
 */

/*
 * Start of xa.h header
 *
 * Define a symbol to prevent multiple inclusion of this header file
 */

#ifndef XA_H
#define XA_H
/*
 * Transaction branch identification: XID and NULLXID:
 */
#define XIDDATASIZE		128			/* size in bytes */
#define MAXGTRIDSIZE    64  		/* maximum size in bytes of gtrid */
#define MAXBQUALSIZE    64  		/* maximum size in bytes of bqual */

#ifndef _XID_T_DEFINED
#define _XID_T_DEFINED
struct xid_t
{
	long formatID;					/* format identifier */
	long gtrid_length;				/* value not to exceed 64 */
	long bqual_length;				/* value not to exceed 64 */
	char data[XIDDATASIZE];
};
#endif

typedef struct xid_t XID;
/*
 * A value of -1 in formatID means that the XID is null.
 */
/*
 * Declarations of routines by which RMs call TMs:
 */
#ifdef _TMPROTOTYPES
extern int __cdecl ax_reg(int, XID *, long);
extern int __cdecl ax_unreg(int, long);
#else /* ifndef _TMPROTOTYPES */
extern int __cdecl ax_reg();
extern int __cdecl ax_unreg();
#endif /* ifndef _TMPROTOTYPES */
/*
 * XA Switch Data Structure
 */
#define RMNAMESZ	32									/* length of resource manager name, */
														/* including the null terminator */
#define MAXINFOSIZE 256									/* maximum size in bytes of xa_info strings, */
														/* including the null terminator */

#ifndef _XA_SWITCH_T_DEFINED
#define _XA_SWITCH_T_DEFINED
struct xa_switch_t
{
  char name[RMNAMESZ];									/* name of resource manager */
  long flags;											/* resource manager specific options */
  long version;											/* must be 0 */
  int (__cdecl *xa_open_entry)(char *, int, long);		/* xa_open function pointer */
  int (__cdecl *xa_close_entry)(char *, int, long);		/* xa_close function pointer*/
  int (__cdecl *xa_start_entry)(XID *, int, long);		/* xa_start function pointer */
  int (__cdecl *xa_end_entry)(XID *, int, long);		/* xa_end function pointer */
  int (__cdecl *xa_rollback_entry)(XID *, int, long);	/* xa_rollback function pointer */
  int (__cdecl *xa_prepare_entry)(XID *, int, long);	/* xa_prepare function pointer */
  int (__cdecl *xa_commit_entry)(XID *, int, long);		/* xa_commit function pointer */
  int (__cdecl *xa_recover_entry)(XID *, long, int, long);
														/* xa_recover function pointer*/
  int (__cdecl *xa_forget_entry)(XID *, int, long);		/* xa_forget function pointer */
  int (__cdecl *xa_complete_entry)(int *, int *, int, long);
														/* xa_complete function pointer */
};

typedef struct xa_switch_t xa_switch_t;
#endif

/*
 * Flag definitions for the RM switch
 */
#define TMNOFLAGS		0x00000000L						/* no resource manager features selected */
#define TMREGISTER		0x00000001L						/* resource manager dynamically registers */
#define TMNOMIGRATE		0x00000002L						/* resource manager does not support association migration */
#define TMUSEASYNC		0x00000004L						/* resource manager supports asynchronous operations */
/*
 * Flag definitions for xa_ and ax_ routines
 */
/* use TMNOFLAGS, defined above, when not specifying other flags */
#define TMASYNC			0x80000000L						/* perform routine asynchronously */
#define TMONEPHASE		0x40000000L						/* caller is using one-phase commit optimisation */
#define TMFAIL			0x20000000L						/* dissociates caller and marks transaction branch rollback-only */
#define TMNOWAIT		0x10000000L						/* return if blocking condition exists */
#define TMRESUME		0x08000000L						/* caller is resuming association with suspended transaction branch */
#define TMSUCCESS		0x04000000L						/* dissociate caller from transaction branch */
#define TMSUSPEND		0x02000000L						/* caller is suspending, not ending, association */
#define TMSTARTRSCAN	0x01000000L						/* start a recovery scan */
#define TMENDRSCAN		0x00800000L						/* end a recovery scan */
#define TMMULTIPLE		0x00400000L						/* wait for any asynchronous operation */
#define TMJOIN			0x00200000L						/* caller is joining existing transaction branch */
#define TMMIGRATE		0x00100000L						/* caller intends to perform migration */
/*
 * ax_() return codes (transaction manager reports to resource manager)
 */
#define TM_JOIN			2								/* caller is joining existing transaction branch */
#define TM_RESUME		1								/* caller is resuming association with suspended transaction branch */
#define TM_OK			0								/* normal execution */
#define TMER_TMERR		(-1)							/* an error occurred in the transaction manager */
#define TMER_INVAL		(-2)							/* invalid arguments were given */
#define TMER_PROTO		(-3)							/* routine invoked in an improper context */
/*
 * xa_() return codes (resource manager reports to transaction manager)
 */
#define XA_RBBASE		100								/* The inclusive lower bound of the rollback codes */
#define XA_RBROLLBACK	XA_RBBASE						/* The rollback was caused by an unspecified reason */
#define XA_RBCOMMFAIL	XA_RBBASE+1						/* The rollback was caused by a communication failure */
#define XA_RBDEADLOCK	XA_RBBASE+2						/* A deadlock was detected */
#define XA_RBINTEGRITY	XA_RBBASE+3						/* A condition that violates the integrity of the resources was detected */
#define XA_RBOTHER		XA_RBBASE+4						/* The resource manager rolled back the transaction branch for a reason not on this list */
#define XA_RBPROTO		XA_RBBASE+5						/* A protocol error occurred in the resource manager */
#define XA_RBTIMEOUT	XA_RBBASE+6						/* A transaction branch took too long */
#define XA_RBTRANSIENT	XA_RBBASE+7						/* May retry the transaction branch */
#define XA_RBEND		XA_RBTRANSIENT					/* The inclusive upper bound of the rollback codes */

#define XA_NOMIGRATE	9								/* resumption must occur where suspension occurred */
#define XA_HEURHAZ		8								/* the transaction branch may have been heuristically completed */
#define XA_HEURCOM		7								/* the transaction branch has been heuristically committed */
#define XA_HEURRB		6								/* the transaction branch has been heuristically rolled back */
#define XA_HEURMIX		5								/* the transaction branch has been heuristically committed and rolled back */
#define XA_RETRY		4								/* routine returned with no effect and may be re-issued */
#define XA_RDONLY		3								/* the transaction branch was read-only and has been committed */
#define XA_OK			0								/* normal execution */
#define XAER_ASYNC		(-2)							/* asynchronous operation already outstanding */
#define XAER_RMERR		(-3)							/* a resource manager error occurred in the transaction branch */
#define XAER_NOTA		(-4)							/* the XID is not valid */
#define XAER_INVAL		(-5)							/* invalid arguments were given */
#define XAER_PROTO		(-6)							/* routine invoked in an improper context */
#define XAER_RMFAIL		(-7)							/* resource manager unavailable */
#define XAER_DUPID		(-8)							/* the XID already exists */
#define XAER_OUTSIDE	(-9)							/* resource manager doing work outside */
														/* global transaction */
/*
 * XA entry point type definitions:
 */

typedef int (__cdecl *XA_OPEN_EPT)(char *, int, long);	/* xa_open entry point */
typedef int (__cdecl *XA_CLOSE_EPT)(char *, int, long);	/* xa_close entry point*/
typedef int (__cdecl *XA_START_EPT)(XID *, int, long);	/* xa_start entry point */
typedef int (__cdecl *XA_END_EPT)(XID *, int, long);	/* xa_end entry point */
typedef int (__cdecl *XA_ROLLBACK_EPT)(XID *, int, long);
														/* xa_rollback entry point */
typedef int (__cdecl *XA_PREPARE_EPT)(XID *, int, long);/* xa_prepare entry point */
typedef int (__cdecl *XA_COMMIT_EPT)(XID *, int, long);	/* xa_commit entry point */
typedef int (__cdecl *XA_RECOVER_EPT)(XID *, long, int, long);
														/* xa_recover entry point*/
typedef int (__cdecl *XA_FORGET_EPT)(XID *, int, long);	/* xa_forget entry point */
typedef int (__cdecl *XA_COMPLETE_EPT)(int *, int *, int, long);
														/* xa_complete entry point */

#endif /* ifndef XA_H */
/*
 * End of xa.h header
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xmldomdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xmldsodid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN

#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1

//;begin_internal
#endif // __XMLDSODID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xmlparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLParser2_FWD_DEFINED__
#define __IXMLParser2_FWD_DEFINED__
typedef interface IXMLParser2 IXMLParser2;
#endif 	/* __IXMLParser2_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


#ifndef __XMLParser26_FWD_DEFINED__
#define __XMLParser26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser26 XMLParser26;
#else
typedef struct XMLParser26 XMLParser26;
#endif /* __cplusplus */

#endif 	/* __XMLParser26_FWD_DEFINED__ */


#ifndef __XMLParser30_FWD_DEFINED__
#define __XMLParser30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser30 XMLParser30;
#else
typedef struct XMLParser30 XMLParser30;
#endif /* __cplusplus */

#endif 	/* __XMLParser30_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    } 	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    } 	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_ENDOFPE	= XML_E_WHITESPACEORQUESTIONMARK + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_MISSINGNAME	= XML_E_RESOURCE + 1,
	XML_E_LASTERROR	= XML_E_MISSINGNAME + 1
    } 	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    } 	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 0x1,
	XMLFLAG_SHORTENDTAGS	= 0x2,
	XMLFLAG_CASEINSENSITIVE	= 0x4,
	XMLFLAG_NONAMESPACES	= 0x8,
	XMLFLAG_NOWHITESPACE	= 0x10,
	XMLFLAG_IE4QUIRKS	= 0x20,
	XMLFLAG_NODTDNODES	= 0x40,
	XMLFLAG_IE4COMPATIBILITY	= 0xff,
	XMLFLAG_IGNORESXMLDECL	= 0x100,
	XMLFLAG_SAX	= 0x200,
	XMLFLAG_NORMALIZELB	= 0x400,
	XMLFLAG_IGNOREENCODING	= 0x800,
	XMLFLAG_USEWINHTTP	= 0x1000,
	XMLFLAG_RUNBUFFERONLY	= 0x2000,
	XMLFLAG_LAZYRESYNC	= 0x4000,
	XMLFLAG_IGNOREILLEGALCHARS	= 0x10000,
	XMLFLAG_IE5COMPATIBILITY	= 0xf0100
    } 	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    } 	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    } 	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory **ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLNodeSource * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLNodeSource * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLNodeSource * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLNodeSource * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource * This,
    /* [in] */ IXMLNodeFactory *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ IXMLNodeFactory **ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ const WCHAR **ppwcBuf,
    /* [out] */ ULONG *pulLen,
    /* [out] */ ULONG *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ BSTR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ const WCHAR **ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLParser * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLParser * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLParser * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLParser * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IXMLParser * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXMLParser * This,
            /* [in] */ IUnknown *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *PushData )( 
            IXMLParser * This,
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDTD )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ParseEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IXMLParser * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetParserState )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IXMLParser * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecureBaseURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecureBaseURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser * This,
    /* [in] */ IUnknown *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser * This,
    /* [in] */ const char *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser * This,
    /* [in] */ PVOID *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser * This,
    /* [out] */ const WCHAR **ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLParser2_INTERFACE_DEFINED__
#define __IXMLParser2_INTERFACE_DEFINED__

/* interface IXMLParser2 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50fb5b1a-a75c-4ff4-86b2-14c62189e2cc")
    IXMLParser2 : public IXMLParser
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaxXmlSize( 
            /* [in] */ ULONG MaxSizeCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxXmlSize( 
            /* [out] */ ULONG *MaxSizeCch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLParser2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLParser2 * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLParser2 * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLParser2 * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLParser2 * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetURL )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IXMLParser2 * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXMLParser2 * This,
            /* [in] */ IUnknown *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *PushData )( 
            IXMLParser2 * This,
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDTD )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ParseEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IXMLParser2 * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IXMLParser2 * This,
            /* [in] */ PVOID *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IXMLParser2 * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetParserState )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IXMLParser2 * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecureBaseURL )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecureBaseURL )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxXmlSize )( 
            IXMLParser2 * This,
            /* [in] */ ULONG MaxSizeCch);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxXmlSize )( 
            IXMLParser2 * This,
            /* [out] */ ULONG *MaxSizeCch);
        
        END_INTERFACE
    } IXMLParser2Vtbl;

    interface IXMLParser2
    {
        CONST_VTBL struct IXMLParser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser2_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser2_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser2_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser2_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser2_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser2_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser2_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser2_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser2_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser2_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser2_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser2_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser2_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser2_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser2_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser2_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser2_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser2_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser2_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser2_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser2_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser2_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser2_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser2_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser2_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser2_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser2_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)


#define IXMLParser2_SetMaxXmlSize(This,MaxSizeCch)	\
    (This)->lpVtbl -> SetMaxXmlSize(This,MaxSizeCch)

#define IXMLParser2_GetMaxXmlSize(This,MaxSizeCch)	\
    (This)->lpVtbl -> GetMaxXmlSize(This,MaxSizeCch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser2_SetMaxXmlSize_Proxy( 
    IXMLParser2 * This,
    /* [in] */ ULONG MaxSizeCch);


void __RPC_STUB IXMLParser2_SetMaxXmlSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser2_GetMaxXmlSize_Proxy( 
    IXMLParser2 * This,
    /* [out] */ ULONG *MaxSizeCch);


void __RPC_STUB IXMLParser2_GetMaxXmlSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser2_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE *BeginChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EndChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNode )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODE_INFO *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO **apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO **apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f19-c551-11d3-89b9-0000f81fe221")
XMLParser;
#endif

EXTERN_C const CLSID CLSID_XMLParser26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f20-c551-11d3-89b9-0000f81fe221")
XMLParser26;
#endif

EXTERN_C const CLSID CLSID_XMLParser30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f31-c551-11d3-89b9-0000f81fe221")
XMLParser30;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xmltrnsf.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for xmltrnsf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xmltrnsf_h__
#define __xmltrnsf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


#ifndef __WmiXMLTransformer_FWD_DEFINED__
#define __WmiXMLTransformer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WmiXMLTransformer WmiXMLTransformer;
#else
typedef struct WmiXMLTransformer WmiXMLTransformer;
#endif /* __cplusplus */

#endif 	/* __WmiXMLTransformer_FWD_DEFINED__ */


#ifndef __ISWbemXMLDocumentSet_FWD_DEFINED__
#define __ISWbemXMLDocumentSet_FWD_DEFINED__
typedef interface ISWbemXMLDocumentSet ISWbemXMLDocumentSet;
#endif 	/* __ISWbemXMLDocumentSet_FWD_DEFINED__ */


#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


/* header files for imported files */
#include "msxml.h"
#include "wbemdisp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WmiXMLTransformer_LIBRARY_DEFINED__
#define __WmiXMLTransformer_LIBRARY_DEFINED__

/* library WmiXMLTransformer */
/* [helpstring][version][lcid][uuid] */ 


typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("28D1EEA5-D41E-46c2-B42D-6CE0B9B4D7A7") 
enum WmiXMLEncoding
    {	wmiXML_CIM_DTD_2_0	= 0,
	wmiXML_WMI_DTD_2_0	= 0x1,
	wmiXML_WMI_DTD_WHISTLER	= 0x2
    } 	WmiXMLEncoding;

typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("598BCA7A-E40E-4265-8517-C9A86E2FC07E") 
enum WmiXMLCompilationTypeEnum
    {	WmiXMLCompilationWellFormCheck	= 0,
	WmiXMLCompilationValidityCheck	= 0x1,
	WmiXMLCompilationFullCompileAndLoad	= 0x2
    } 	WmiXMLCompilationTypeEnum;


EXTERN_C const IID LIBID_WmiXMLTransformer;

#ifndef __IWmiXMLTransformer_INTERFACE_DEFINED__
#define __IWmiXMLTransformer_INTERFACE_DEFINED__

/* interface IWmiXMLTransformer */
/* [helpstring][oleautomation][nonextensible][hidden][dual][uuid][local][object] */ 


EXTERN_C const IID IID_IWmiXMLTransformer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB624102-3145-4daf-B0EA-FF5A31178600")
    IWmiXMLTransformer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLEncodingType( 
            /* [out][retval] */ WmiXMLEncoding *piEncoding) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLEncodingType( 
            /* [in] */ WmiXMLEncoding iEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QualifierFilter( 
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_QualifierFilter( 
            /* [in] */ VARIANT_BOOL bQualifierFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassOriginFilter( 
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ClassOriginFilter( 
            /* [in] */ VARIANT_BOOL bClassOriginFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [out][retval] */ BSTR *strUser) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_User( 
            /* [in] */ BSTR strUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [out][retval] */ BSTR *strPassword) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authority( 
            /* [out][retval] */ BSTR *strAuthority) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Authority( 
            /* [in] */ BSTR strAuthority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImpersonationLevel( 
            /* [out][retval] */ DWORD *pdwImpersonationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ImpersonationLevel( 
            /* [in] */ DWORD dwImpersonationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticationLevel( 
            /* [out][retval] */ DWORD *pdwAuthenticationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AuthenticationLevel( 
            /* [in] */ DWORD dwAuthenticationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locale( 
            /* [out][retval] */ BSTR *strLocale) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Locale( 
            /* [in] */ BSTR strLocale) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalOnly( 
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalOnly( 
            /* [in] */ VARIANT_BOOL bLocalOnly) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClasses( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstances( 
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClassNames( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstanceNames( 
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Privileges( 
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CompilationErrors( 
            /* [retval][out] */ BSTR *pstrErrors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWmiXMLTransformerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWmiXMLTransformer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWmiXMLTransformer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWmiXMLTransformer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWmiXMLTransformer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWmiXMLTransformer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ WmiXMLEncoding *piEncoding);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [in] */ WmiXMLEncoding iEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bQualifierFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bClassOriginFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strUser);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_User )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Password )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strPassword);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Password )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authority )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strAuthority);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Authority )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strAuthority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwImpersonationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwImpersonationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwAuthenticationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwAuthenticationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locale )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strLocale);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locale )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strLocale);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bLocalOnly);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClasses )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstances )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClassNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstanceNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Compile )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Privileges )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CompilationErrors )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ BSTR *pstrErrors);
        
        END_INTERFACE
    } IWmiXMLTransformerVtbl;

    interface IWmiXMLTransformer
    {
        CONST_VTBL struct IWmiXMLTransformerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWmiXMLTransformer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWmiXMLTransformer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWmiXMLTransformer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWmiXMLTransformer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWmiXMLTransformer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWmiXMLTransformer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWmiXMLTransformer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWmiXMLTransformer_get_XMLEncodingType(This,piEncoding)	\
    (This)->lpVtbl -> get_XMLEncodingType(This,piEncoding)

#define IWmiXMLTransformer_put_XMLEncodingType(This,iEncoding)	\
    (This)->lpVtbl -> put_XMLEncodingType(This,iEncoding)

#define IWmiXMLTransformer_get_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> get_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_put_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> put_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_get_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> get_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_put_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> put_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_get_User(This,strUser)	\
    (This)->lpVtbl -> get_User(This,strUser)

#define IWmiXMLTransformer_put_User(This,strUser)	\
    (This)->lpVtbl -> put_User(This,strUser)

#define IWmiXMLTransformer_get_Password(This,strPassword)	\
    (This)->lpVtbl -> get_Password(This,strPassword)

#define IWmiXMLTransformer_put_Password(This,strPassword)	\
    (This)->lpVtbl -> put_Password(This,strPassword)

#define IWmiXMLTransformer_get_Authority(This,strAuthority)	\
    (This)->lpVtbl -> get_Authority(This,strAuthority)

#define IWmiXMLTransformer_put_Authority(This,strAuthority)	\
    (This)->lpVtbl -> put_Authority(This,strAuthority)

#define IWmiXMLTransformer_get_ImpersonationLevel(This,pdwImpersonationLevel)	\
    (This)->lpVtbl -> get_ImpersonationLevel(This,pdwImpersonationLevel)

#define IWmiXMLTransformer_put_ImpersonationLevel(This,dwImpersonationLevel)	\
    (This)->lpVtbl -> put_ImpersonationLevel(This,dwImpersonationLevel)

#define IWmiXMLTransformer_get_AuthenticationLevel(This,pdwAuthenticationLevel)	\
    (This)->lpVtbl -> get_AuthenticationLevel(This,pdwAuthenticationLevel)

#define IWmiXMLTransformer_put_AuthenticationLevel(This,dwAuthenticationLevel)	\
    (This)->lpVtbl -> put_AuthenticationLevel(This,dwAuthenticationLevel)

#define IWmiXMLTransformer_get_Locale(This,strLocale)	\
    (This)->lpVtbl -> get_Locale(This,strLocale)

#define IWmiXMLTransformer_put_Locale(This,strLocale)	\
    (This)->lpVtbl -> put_Locale(This,strLocale)

#define IWmiXMLTransformer_get_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> get_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_put_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> put_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_GetObject(This,strObjectPath,pCtx,ppXMLDocument)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,pCtx,ppXMLDocument)

#define IWmiXMLTransformer_ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)	\
    (This)->lpVtbl -> Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)

#define IWmiXMLTransformer_get_Privileges(This,objWbemPrivilegeSet)	\
    (This)->lpVtbl -> get_Privileges(This,objWbemPrivilegeSet)

#define IWmiXMLTransformer_get_CompilationErrors(This,pstrErrors)	\
    (This)->lpVtbl -> get_CompilationErrors(This,pstrErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ WmiXMLEncoding *piEncoding);


void __RPC_STUB IWmiXMLTransformer_get_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ WmiXMLEncoding iEncoding);


void __RPC_STUB IWmiXMLTransformer_put_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_get_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_put_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_get_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_put_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strUser);


void __RPC_STUB IWmiXMLTransformer_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strUser);


void __RPC_STUB IWmiXMLTransformer_put_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strPassword);


void __RPC_STUB IWmiXMLTransformer_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IWmiXMLTransformer_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strAuthority);


void __RPC_STUB IWmiXMLTransformer_get_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strAuthority);


void __RPC_STUB IWmiXMLTransformer_put_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_get_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_put_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_get_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_put_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strLocale);


void __RPC_STUB IWmiXMLTransformer_get_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strLocale);


void __RPC_STUB IWmiXMLTransformer_put_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_get_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_put_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_GetObject_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB IWmiXMLTransformer_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_ExecQuery_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ BSTR strQuery,
    /* [defaultvalue][in] */ BSTR strQueryLanguage,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClasses_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstances_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClassNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClassNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstanceNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstanceNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_Compile_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT *pvInputSource,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [in] */ WmiXMLCompilationTypeEnum iOperation,
    /* [in] */ IDispatch *pCtx,
    /* [retval][out] */ VARIANT_BOOL *pStatus);


void __RPC_STUB IWmiXMLTransformer_Compile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Privileges_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);


void __RPC_STUB IWmiXMLTransformer_get_Privileges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_CompilationErrors_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ BSTR *pstrErrors);


void __RPC_STUB IWmiXMLTransformer_get_CompilationErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWmiXMLTransformer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WmiXMLTransformer;

#ifdef __cplusplus

class DECLSPEC_UUID("A2BB0F35-458E-4075-8A4B-F92664943917")
WmiXMLTransformer;
#endif
#endif /* __WmiXMLTransformer_LIBRARY_DEFINED__ */

#ifndef __ISWbemXMLDocumentSet_INTERFACE_DEFINED__
#define __ISWbemXMLDocumentSet_INTERFACE_DEFINED__

/* interface ISWbemXMLDocumentSet */
/* [helpstring][nonextensible][hidden][dual][oleautomation][uuid][object][local] */ 


EXTERN_C const IID IID_ISWbemXMLDocumentSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E46A227-5207-4603-8440-9FCC5AF16407")
    ISWbemXMLDocumentSet : public IDispatch
    {
    public:
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextDocument( 
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SkipNextDocument( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISWbemXMLDocumentSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISWbemXMLDocumentSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISWbemXMLDocumentSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISWbemXMLDocumentSet * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ IUnknown **pUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ long *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextDocument )( 
            ISWbemXMLDocumentSet * This,
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SkipNextDocument )( 
            ISWbemXMLDocumentSet * This);
        
        END_INTERFACE
    } ISWbemXMLDocumentSetVtbl;

    interface ISWbemXMLDocumentSet
    {
        CONST_VTBL struct ISWbemXMLDocumentSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISWbemXMLDocumentSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISWbemXMLDocumentSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISWbemXMLDocumentSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISWbemXMLDocumentSet_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISWbemXMLDocumentSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISWbemXMLDocumentSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISWbemXMLDocumentSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISWbemXMLDocumentSet_get__NewEnum(This,pUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,pUnk)

#define ISWbemXMLDocumentSet_Item(This,strObjectPath,iFlags,ppXMLDocument)	\
    (This)->lpVtbl -> Item(This,strObjectPath,iFlags,ppXMLDocument)

#define ISWbemXMLDocumentSet_get_Count(This,iCount)	\
    (This)->lpVtbl -> get_Count(This,iCount)

#define ISWbemXMLDocumentSet_NextDocument(This,ppDoc)	\
    (This)->lpVtbl -> NextDocument(This,ppDoc)

#define ISWbemXMLDocumentSet_SkipNextDocument(This)	\
    (This)->lpVtbl -> SkipNextDocument(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get__NewEnum_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ IUnknown **pUnk);


void __RPC_STUB ISWbemXMLDocumentSet_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_Item_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ long iFlags,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB ISWbemXMLDocumentSet_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get_Count_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ long *iCount);


void __RPC_STUB ISWbemXMLDocumentSet_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_NextDocument_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);


void __RPC_STUB ISWbemXMLDocumentSet_NextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_SkipNextDocument_Proxy( 
    ISWbemXMLDocumentSet * This);


void __RPC_STUB ISWbemXMLDocumentSet_SkipNextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISWbemXMLDocumentSet_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xprtdefs.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================
//
// filename XPrtDefs.h (Derived from edevdefs.h)
//
// External Device (like a VCR) control interface parameter and value definitions
//
// Note:new constants added: ED_BASE+800L -> ED_BASE+811L
//
// 1-30-98:
//   New constant added for DVCR: ED_BASE+900L -> ED_BASE+1000L
// 

#ifndef __XPRTDEFS__
#define __XPRTDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of devices synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns devices normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show devices input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on devices output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// devices output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L	// never "put", only "get"
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// ord  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_MEDIA_NEO            ED_BASE+531L    // Mini digital tape for MPEG2TS signal

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L






// **************************************************
//
// New constants added for implementation of DVCR
//
// **************************************************


//
// New Device type (a DV has two subunits: camera and VCR)
//
#define ED_DEVTYPE_CAMERA          ED_BASE+900L

#define ED_DEVTYPE_TUNER           ED_BASE+901L

#define ED_DEVTYPE_DVHS            ED_BASE+902L

#define ED_DEVTYPE_UNKNOWN         ED_BASE+903L

//
// Unknownn capability 
//     Instead of return E_NOTIMPL, or S_OK with OAFALSE, it may return S_OK with _UNKNOWN
//
#define ED_CAPABILITY_UNKNOWN      ED_BASE+910L


//
// Send RAW extenal device command via Get/SetTransportBasicParameters()
//
#define ED_RAW_EXT_DEV_CMD         ED_BASE+920L


//
// MEDIUM INFO
//
#define ED_MEDIA_VHSC              ED_BASE+925L  // New media type
#define ED_MEDIA_UNKNOWN           ED_BASE+926L  // Unknown media
#define ED_MEDIA_NOT_PRESENT       ED_BASE+927L  


//
// Device Control command that can result in pending state.
//
#define ED_CONTROL_HEVENT_GET       ED_BASE+928L  // To get a sychronous event handle
#define ED_CONTROL_HEVENT_RELEASE   ED_BASE+929L  // To release sychronous event handle must match what it got

#define ED_DEV_REMOVED_HEVENT_GET       ED_BASE+960L  // To be a notify event and will be signal if device is removed.
#define ED_DEV_REMOVED_HEVENT_RELEASE   ED_BASE+961L  // Release this event handle


//
// TRANSPORT STATE
//
#define ED_NOTIFY_HEVENT_GET       ED_BASE+930L  // To get a sychronous event handle
#define ED_NOTIFY_HEVENT_RELEASE   ED_BASE+931L  // To release sychronous event handle must match what it got
#define ED_MODE_CHANGE_NOTIFY      ED_BASE+932L  // This is asynchronous operation, wait for event. 

#define	ED_MODE_PLAY_FASTEST_FWD   ED_BASE+933L
#define	ED_MODE_PLAY_SLOWEST_FWD   ED_BASE+934L
#define	ED_MODE_PLAY_FASTEST_REV   ED_BASE+935L
#define	ED_MODE_PLAY_SLOWEST_REV   ED_BASE+936L

#define ED_MODE_WIND               ED_BASE+937L  
#define ED_MODE_REW_FASTEST        ED_BASE+938L  // High speed rewind

#define	ED_MODE_REV_PLAY           ED_BASE+939L  // x1 speed reverse play



//
// TRANSPOSRTBASIC: input and output signal
//
#define	ED_TRANSBASIC_INPUT_SIGNAL      ED_BASE+940L
#define	ED_TRANSBASIC_OUTPUT_SIGNAL     ED_BASE+941L

#define	ED_TRANSBASIC_SIGNAL_525_60_SD  ED_BASE+942L
#define	ED_TRANSBASIC_SIGNAL_525_60_SDL ED_BASE+943L
#define	ED_TRANSBASIC_SIGNAL_625_50_SD  ED_BASE+944L
#define	ED_TRANSBASIC_SIGNAL_625_50_SDL ED_BASE+945L

#define	ED_TRANSBASIC_SIGNAL_625_60_HD  ED_BASE+947L
#define	ED_TRANSBASIC_SIGNAL_625_50_HD  ED_BASE+948L

#define	ED_TRANSBASIC_SIGNAL_MPEG2TS    ED_BASE+946L

#define	ED_TRANSBASIC_SIGNAL_2500_60_MPEG    ED_BASE+980L
#define	ED_TRANSBASIC_SIGNAL_1250_60_MPEG    ED_BASE+981L
#define	ED_TRANSBASIC_SIGNAL_0625_60_MPEG    ED_BASE+982L

#define	ED_TRANSBASIC_SIGNAL_2500_50_MPEG    ED_BASE+985L
#define	ED_TRANSBASIC_SIGNAL_1250_50_MPEG    ED_BASE+986L
#define	ED_TRANSBASIC_SIGNAL_0625_50_MPEG    ED_BASE+987L

#define	ED_TRANSBASIC_SIGNAL_UNKNOWN    ED_BASE+990L

//
// TIMECODE/AbsoluteTrackNumber/RealTimeCounter read/seek/write
//
#define ED_DEVCAP_TIMECODE_SEEK    ED_BASE+950L

#define ED_DEVCAP_ATN_READ		   ED_BASE+951L
#define ED_DEVCAP_ATN_SEEK	       ED_BASE+952L
#define ED_DEVCAP_ATN_WRITE	       ED_BASE+953L

#define ED_DEVCAP_RTC_READ		   ED_BASE+954L  
#define ED_DEVCAP_RTC_SEEK	       ED_BASE+955L
#define ED_DEVCAP_RTC_WRITE	       ED_BASE+956L

//
// Basic parameter
//
#define ED_TIMEREF_ATN             ED_BASE+958L


//
// GUID used to identify a class driver
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// 8C0F6AF2-0EDB-44c1-8AEB-59040BD830ED  MSTapeDeviceGUID
OUR_GUID_ENTRY(MSTapeDeviceGUID,
0x8C0F6AF2, 0x0EDB, 0x44c1, 0x8A, 0xEB, 0x59, 0x04, 0x0B, 0xD8, 0x30, 0xED)

#endif // __XPRTDEFS__

// eof XPrtDefs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\xolehlp.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1995	Microsoft Corporation.	All Rights Reserved


Filename :	xolehlp.h
			contains DTC helper APIs used by RM's and application clients
			to obtain the transaction manager
----------------------------------------------------------------------------- */

#ifndef __XOLEHLP__H__
#define __XOLEHLP__H__


/*----------------------------------------
//	Defines
//--------------------------------------*/
#define EXPORTAPI __declspec( dllexport )HRESULT

/*----------------------------------------
// Constants
//--------------------------------------*/
const DWORD		OLE_TM_CONFIG_VERSION_1		= 1;

const DWORD		OLE_TM_FLAG_NONE			= 0x00000000;
const DWORD		OLE_TM_FLAG_NODEMANDSTART	= 0x00000001;

// The following are flags used specifically for MSDTC.
const DWORD		OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS = 0x80000000;
const DWORD		OLE_TM_FLAG_INTERNAL_TO_TM	=		   0x40000000;

/*----------------------------------------
//	Structure definitions
//--------------------------------------*/
typedef struct _OLE_TM_CONFIG_PARAMS_V1
{
	DWORD		dwVersion;
	DWORD		dwcConcurrencyHint;
} OLE_TM_CONFIG_PARAMS_V1;


/*----------------------------------------
//	Function Prototypes
//--------------------------------------*/

/*----------------------------------------
//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which 
//case the MS DTC on the same host is contacted and the interface provided
//for it.
//--------------------------------------*/
EXPORTAPI __cdecl DtcGetTransactionManager( 
									/* in */ char * i_pszHost,
									/* in */ char *	i_pszTmName,
									/* in */ REFIID i_riid,
								    /* in */ DWORD i_dwReserved1,
								    /* in */ WORD i_wcbReserved2,
								    /* in */ void * i_pvReserved2,
									/* out */ void** o_ppvObject
									)	;
EXTERN_C HRESULT __cdecl DtcGetTransactionManagerC(
									/* in */ char * i_pszHost,
									/* in */ char *	i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_dwReserved1,
									/* in */ WORD i_wcbReserved2,
									/* in */ void * i_pvReserved2,
									/* out */ void ** o_ppvObject
									);

EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExA(
									/* in */ char * i_pszHost,
									/* in */ char * i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);


EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExW(
									/* in */ WCHAR * i_pwszHost,
									/* in */ WCHAR * i_pwszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);
#ifdef UNICODE
#define DtcGetTransactionManagerEx		DtcGetTransactionManagerExW
#else
#define DtcGetTransactionManagerEx		DtcGetTransactionManagerExA
#endif


#ifndef EXTERN_GUID
#define EXTERN_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) DEFINE_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)
#endif

/*----------------------------------------
// Define a CLSID that can be used to obtain a transaction manager instance via CoCreateInstance;
// this is an alternate to using DtcGetTransactionManager. 
//
// CLSID_MSDtcTransactionManager = {5B18AB61-091D-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransactionManager, 0x5b18ab61, 0x91d, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

/*----------------------------------------
// Define a CLSID that can be used with CoCreateInstance to instantiate a vanilla transaction
// object with the local transaction manager. It's equivalent to doing 
//
//  pTransactionDispenser->BeginTransaction(NULL, ISOLATIONLEVEL_UNSPECIFIED, ISOFLAG_RETAIN_DONTCARE, NULL, &ptx);
//
// CLSID_MSDtcTransaction = {39F8D76B-0928-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransaction, 0x39f8d76b, 0x928, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\zmouse.h ===
/****************************************************************************
*                                                                           *
* ZMOUSE.H -- Include file for IntelliMouse(tm) 1.0                         *
*                                                                           *
* NOTE:  Zmouse.h contains #defines required when providing IntelliMouse    *
*        wheel support for Windows95 and NT3.51.  Wheel is supported        *
*        natively in WinNT4.0, please refer to the NT4.0 SDK for more info  *
*        on providing support for IntelliMouse in NT4.0.                    *
*                                                                           *
* Copyright (c) 1983-1999, Microsoft Corp. All rights reserved.             *
*                                                                           *
\***************************************************************************/


#if _MSC_VER > 1000
#pragma once
#endif

/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#ifdef UNICODE
#define MSH_MOUSEWHEEL L"MSWHEEL_ROLLMSG"
#else
#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
#endif
   // wParam = wheel rotation expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one notch


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	   *  determining if wheel support active
	   *  determining # of Scroll Lines
***************************************************************************/

// Class name for MSWHEEL.EXE's invisible window
// use FindWindow to get hwnd to MSWHEEL
#ifdef UNICODE
#define MOUSEZ_CLASSNAME  L"MouseZ"           // wheel window class
#define MOUSEZ_TITLE      L"Magellan MSWHEEL" // wheel window title
#else
#define MOUSEZ_CLASSNAME  "MouseZ"            // wheel window class
#define MOUSEZ_TITLE      "Magellan MSWHEEL"  // wheel window title
#endif

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines
// below to get the message numbers for:
// 1) the message that can be sent to the MSWHEEL window to
//    query if wheel support is active (MSH_WHEELSUPPORT)>
// 2) the message to query for the number of scroll lines
//    (MSH_SCROLL_LINES)
//
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is not currently available.

#ifdef UNICODE
#define MSH_WHEELSUPPORT L"MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                 // to query for wheel support
#else
#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG"  // name of msg to send
                                                 // to query for wheel support
#endif

// MSH_WHEELSUPPORT
//    wParam - not used
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise


#ifdef UNICODE
#define MSH_SCROLL_LINES L"MSH_SCROLL_LINES_MSG"
#else
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"
#endif

// MSH_SCROLL_LINES
//    wParam - not used
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL  (UINT_MAX)   // signifies to scroll a page, also
                                       // defined in winuser.h in the
                                       // NT4.0 SDK
#endif

#ifndef SPI_SETWHEELSCROLLLINES
#define SPI_SETWHEELSCROLLLINES   105  // Also defined in winuser.h in the
                                       // NT4.0 SDK, please see the NT4.0 SDK
                                       // documentation for NT4.0 implementation
                                       // specifics.
                                       // For Win95 and WinNT3.51,
                                       // Mswheel broadcasts the message
                                       // WM_SETTINGCHANGE (equivalent to
                                       // WM_WININICHANGE) when the scroll
                                       // lines has changed.  Applications
                                       // will recieve the WM_SETTINGCHANGE
                                       // message with the wParam set to
                                       // SPI_SETWHEELSCROLLLINES.  When
                                       // this message is recieved the application
                                       // should query Mswheel for the new
                                       // setting.
#endif


/*********************************************************************
* INLINE FUNCTION: HwndMsWheel
* Purpose : Get a reference to MSWheel Window, the registered messages,
*           wheel support active setting, and number of scrollLines
* Params  : PUINT puiMsh_MsgMouseWheel - address of UINT to contain returned registered wheel message
*           PUINT puiMsh_Msg3DSupport - address of UINT to contain wheel support registered message
*           PUINT puiMsh_MsgScrollLines - address of UINT to contain Scroll lines registered message
*           PBOOL pf3DSupport - address of BOOL to contain returned flag for wheel support active
*           PINT  piScrollLines - address of int to contain returned scroll lines
* Returns : HWND handle to the MsWheel window
* Note    : The return value for pf3DSupport and piScrollLines is dependant
*           on the POINT32 module.  If POINT32 module is not running then
*           the values returned for these parameters will be
*           FALSE and 3, respectively.
*********************************************************************/
__inline HWND HwndMSWheel(
      PUINT puiMsh_MsgMouseWheel,
      PUINT puiMsh_Msg3DSupport,
      PUINT puiMsh_MsgScrollLines,
      PBOOL pf3DSupport,
      PINT  piScrollLines
)
{
   HWND hdlMsWheel;

   hdlMsWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);

   *puiMsh_MsgMouseWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
   *puiMsh_Msg3DSupport = RegisterWindowMessage(MSH_WHEELSUPPORT);
   *puiMsh_MsgScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);

   if (*puiMsh_Msg3DSupport)
      *pf3DSupport = (BOOL)SendMessage(hdlMsWheel, *puiMsh_Msg3DSupport, 0, 0);
   else
      *pf3DSupport = FALSE;  // default to FALSE

   if (*puiMsh_MsgScrollLines)
      *piScrollLines = (int)SendMessage(hdlMsWheel, *puiMsh_MsgScrollLines, 0, 0);
   else
      *piScrollLines = 3;  // default

   return(hdlMsWheel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlconv.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
	#error atlconv.cpp requires atlconv.h to be included first
#endif

#ifndef _ATL_NO_CONVERSIONS
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	_ASSERTE(lpa != NULL);
	_ASSERTE(lpw != NULL);
	
	if (lpw == NULL || lpa == NULL)
		return NULL;

	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	int ret = MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	if(ret == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}		
	return lpw;
}

LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	_ASSERTE(lpw != NULL);
	_ASSERTE(lpa != NULL);
	
	if (lpa == NULL || lpw == NULL)
		return NULL;

	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	int ret = WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	if(ret == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}		
	return lpa;
}

#if defined(_WINGDI_) && !defined(NOGDI)

// don't include this code when building DLL
LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA)
{
	if (lpDevModeA == NULL || lpDevModeW == NULL)
		return NULL;
	_ASSERTE(lpDevModeW != NULL);
	AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32);
	memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
		offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
	AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32);
	memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
		sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
	if (lpDevModeA->dmDriverExtra != 0)
		memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
	if (lptmA == NULL || lptmW == NULL)
		return NULL;
	_ASSERTE(lptmW != NULL);
	memcpy(lptmW, lptmA, sizeof(LONG) * 11);
	memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);
	
	if(MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}

	if(MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	if(MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	if(MultiByteToWideChar(CP_ACP, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	return lptmW;
}

LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
	if (lptmW == NULL || lptmA == NULL)
		return NULL;
	_ASSERTE(lptmA != NULL);
	memcpy(lptmA, lptmW, sizeof(LONG) * 11);
	memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);

	if(WideCharToMultiByte(CP_ACP, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	if(WideCharToMultiByte(CP_ACP, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	if(WideCharToMultiByte(CP_ACP, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	if(WideCharToMultiByte(CP_ACP, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL) == 0)
	{
		_ASSERTE(FALSE);
		return NULL;
	}
	
	return lptmA;
}

LPDEVMODEA AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW)
{
	if (lpDevModeW == NULL || lpDevModeA == NULL)
		return NULL;
	_ASSERTE(lpDevModeA != NULL);
	AtlW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, 32);
	memcpy(&lpDevModeA->dmSpecVersion, &lpDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
	AtlW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, 32);
	memcpy(&lpDevModeA->dmLogPixels, &lpDevModeW->dmLogPixels,
		sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
	if (lpDevModeW->dmDriverExtra != 0)
		memcpy(lpDevModeA+1, lpDevModeW+1, lpDevModeW->dmDriverExtra);
	lpDevModeA->dmSize = sizeof(DEVMODEA);
	return lpDevModeA;
}

#endif //_WINGDI_
#endif //!_ATL_NO_CONVERSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

// namespace and our templates don't quite work with earlier compiler
// Can turn off namespace support directly, also
#if _MSC_VER<1100
#ifndef ATL_NO_NAMESPACE
#define ATL_NO_NAMESPACE
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#if _MSC_VER<1100
#define ATL_NO_VTABLE
#else
#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <stddef.h>
#include <tchar.h>
#include <malloc.h>
#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the _ASSERTE(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif
#pragma pack(push, _ATL_PACKING)

#include <atlconv.h>

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" HRESULT __declspec(dllexport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllexport) x __stdcall
	#define ATLINLINE
#else
	#define ATLAPI HRESULT __stdcall
	#define ATLAPI_(x) x __stdcall
	#define ATLINLINE inline
#endif

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif
#endif

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(ULONG_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		IUnknown* p = NULL;
		if (pfnGetClassObject == NULL)
			return S_OK;

		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		if (p != NULL)
			p->Release();
		return hRes;
	}
};

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};

struct _ATL_MODULE
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CRITICAL_SECTION m_csTypeInfoHolder;
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	ULONG_PTR dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers
ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
	HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);

#ifndef ATL_NO_NAMESPACE
#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#ifdef _DEBUG
void _cdecl AtlTrace(LPCTSTR lpszFormat, ...);
#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE(_T("%s not implemented.\n"), funcname); return E_NOTIMPL
#else
inline void _cdecl AtlTrace(LPCTSTR , ...){}
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#endif
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

#ifndef offsetofclass
#define offsetofclass(base, derived) ((ULONG_PTR)(static_cast<base*>((derived*)8))-8)
#endif

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#undef _ATL_VER
#define _ATL_VER 0x0203 // Active Template Library version 2.03, XP Security changes

/////////////////////////////////////////////////////////////////////////////
// Error to HRESULT helpers

inline HRESULT AtlHresultFromLastError()
{
	DWORD dwErr = ::GetLastError();
	return HRESULT_FROM_WIN32(dwErr);
}

inline HRESULT AtlHresultFromWin32(DWORD nError)
{
	return( HRESULT_FROM_WIN32( nError ) );
}

inline void __declspec(noreturn) _AtlRaiseException( DWORD dwExceptionCode, DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE )
{
	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );
}

// Validation macro for OUT pointer
// Used in QI and CreateInstance
#define _ATL_VALIDATE_OUT_POINTER(x)	_ASSERTE(x != NULL);	\
	if (x == NULL)	\
		return E_POINTER;	\
	*x = NULL

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_FORCE_LIBS
	#pragma comment(lib, "kernel32.lib")
	#pragma comment(lib, "user32.lib")
	#pragma comment(lib, "ole32.lib")
	#pragma comment(lib, "oleaut32.lib")
	#pragma comment(lib, "olepro32.lib")
	#pragma comment(lib, "uuid.lib")
	#pragma comment(lib, "advapi32.lib")
#endif // _ATL_NO_FORCE_LIBS

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};


template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr() {p=NULL;}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr() {if (p) p->Release();}
	void Release() 
	{
#if 0  // Remove for now, there's instances of people using this on a class instead of just templates.
		IUnknown* pTemp = p;
#else
		T* pTemp = p;
#endif
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}	
	}
	operator T*() {return (T*)p;}
	T& operator*() {ATLASSERT(p!=NULL); return *p; }
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&() { ATLASSERT(p==NULL); return &p; }
	_NoAddRefReleaseOnCComPtr<T>* operator->()
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	
	T* operator=(T* lp){return (T*)AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
#if _MSC_VER>1020
	bool operator!(){return (p == NULL);}
#else
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
#endif
	T* p;
};

//Note: CComQIPtr<IUnknown, &IID_IUnknown> is not meaningful
//      Use CComPtr<IUnknown>
template <class T, const IID* piid>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr() {p=NULL;}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	// If you get an error that this member is already defined, you are probably
	// using a CComQIPtr<IUnknown, &IID_IUnknown>.  This is not necessary.
	// Use CComPtr<IUnknown>
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr() {if (p) p->Release();}
	void Release() 
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() {return p;}
	T& operator*() {ATLASSERT(p!=NULL); return *p; }
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&() { ATLASSERT(p==NULL); return &p; }
	_NoAddRefReleaseOnCComPtr<T>* operator->()
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}

	T* operator=(T* lp){return (T*)AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
#if _MSC_VER>1020
	bool operator!(){return (p == NULL);}
#else
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
#endif
	T* p;
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR
class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz = NULL)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	CComBSTR& operator=(const CComBSTR& src);
	CComBSTR& operator=(LPCOLESTR pSrc);
	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
#if _MSC_VER>1020
	bool operator!()
	{
		return (m_str == NULL);
	}
#else
	BOOL operator!()
	{
		return (m_str == NULL) ? TRUE : FALSE;
	}
#endif
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, (int) ocslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen);

	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
#ifndef OLE2ANSI
	/*explicit*/ CComBSTR(LPCSTR pSrc);
	/*explicit*/ CComBSTR(int nSize, LPCSTR sz = NULL);
	CComBSTR& operator=(LPCSTR pSrc);
	HRESULT Append(LPCSTR);
#endif
	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		::VariantInit(this);
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		::VariantInit(this);
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		::VariantInit(this);
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		::VariantInit(this);
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		::VariantInit(this);
		*this = lpszSrc;
	}

#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		::VariantInit(this);
		*this = lpszSrc;}
#endif

#if _MSC_VER>1020
	CComVariant(bool bSrc)
	{
		::VariantInit(this);
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}
#endif

	CComVariant(int nSrc)
	{
		::VariantInit(this);
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		::VariantInit(this);
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		::VariantInit(this);
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		::VariantInit(this);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		::VariantInit(this);
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		::VariantInit(this);
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		::VariantInit(this);
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		::VariantInit(this);
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		::VariantInit(this);
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc);
	CComVariant& operator=(LPCOLESTR lpszSrc);

#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc);
#endif

#if _MSC_VER>1020
	CComVariant& operator=(bool bSrc);
#endif
	CComVariant& operator=(int nSrc);
	CComVariant& operator=(BYTE nSrc);
	CComVariant& operator=(short nSrc);
	CComVariant& operator=(long nSrc);
	CComVariant& operator=(float fltSrc);
	CComVariant& operator=(double dblSrc);
	CComVariant& operator=(CY cySrc);

	CComVariant& operator=(IDispatch* pSrc);
	CComVariant& operator=(IUnknown* pSrc);

// Comparison Operators
public:
#if _MSC_VER>1020
	bool operator==(const VARIANT& varSrc);
	bool operator!=(const VARIANT& varSrc) {return !operator==(varSrc);}
#else
	BOOL operator==(const VARIANT& varSrc);
	BOOL operator!=(const VARIANT& varSrc) {return !operator==(varSrc);}
#endif

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc);
	HRESULT Detach(VARIANT* pDest);
	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL);
	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear();
	void InternalCopy(const VARIANT* pSrc);
};
/////////////////////////////////////////////////////////////////////////////
// GUID comparison
#if 0
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#ifdef _MAC
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

struct _AtlCreateWndData
{
	void* m_pThis;
	DWORD m_dwThreadID;
	_AtlCreateWndData* m_pNext;
};

class CComModule : public _ATL_MODULE
{
// Operations
public:
	_AtlCreateWndData* m_pCreateWndList;

	void AddCreateWndData(_AtlCreateWndData* pData, void* pObject);
	void* ExtractCreateWndData();

	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
	{
		cbSize = sizeof(_ATL_MODULE);
		m_pCreateWndList = NULL;
		return AtlModuleInit(this, p, h);
	}
	void Term()
	{
		AtlModuleTerm(this);
	}

	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock() {return CComGlobalsThreadModel::Decrement(&m_nLockCnt);}
	LONG GetLockCount() {return m_nLockCnt;}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInstResource;}
	HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib()
	{
		return AtlModuleRegisterTypeLib(this, NULL);
	}
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION_EX;
		LPCOLESTR p = NULL;
		if(lpszIndex != NULL)
		{
			p = T2COLE_EX(lpszIndex,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE			
			if(p == NULL) 
				return E_OUTOFMEMORY;
#endif			
		}

		return AtlModuleRegisterTypeLib(this, p);
	}

	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServer(this, pCLSID);
	}

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		if(lpszRes == NULL)
			return E_INVALIDARG;
		
		USES_CONVERSION_EX;			
		LPCOLESTR p = T2COLE_EX(lpszRes,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifdef _UNICODE
		if(p == NULL) 
			return E_OUTOFMEMORY;
#endif		

		return AtlModuleUpdateRegistryFromResourceD(this, p, bRegister,	pMapEntries);
	}
	HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		return AtlModuleUpdateRegistryFromResourceD(this,
			(LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
	}

	#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	#endif //_ATL_STATIC_REGISTRY

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
	{
		return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
	}
	HRESULT RevokeClassObjects()
	{
		return AtlModuleRevokeClassObjects(this);
	}

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
	{
		return AtlModuleGetClassObject(this, rclsid, riid, ppv);
	}

	// Only used in CComAutoThreadModule
	HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
	{
		return S_OK;
	}
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
	_ATL_CREATORFUNC* pfnCreateInstance;
	const IID* piid;
	HANDLE hEvent;
	LPSTREAM pStream;
	HRESULT hRes;
};

class CComApartment
{
public:
	static UINT ATL_CREATE_OBJECT;
	static DWORD WINAPI _Apartment(void* pv)
	{
		ATLASSERT(pv != NULL);
		return ((CComApartment*)pv)->Apartment();
	}
	DWORD Apartment()
	{
		CoInitialize(NULL);
		MSG msg;
		while(GetMessage(&msg, 0, 0, 0))
		{
			if (msg.message == ATL_CREATE_OBJECT)
			{
				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
				IUnknown* pUnk = NULL;
				pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
				if (SUCCEEDED(pdata->hRes))
					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
				if (SUCCEEDED(pdata->hRes))
				{
					pUnk->Release();
					ATLTRACE(_T("Object created on thread = %d\n"), GetCurrentThreadId());
				}
				SetEvent(pdata->hEvent);
			}
			DispatchMessage(&msg);
		}
		CoUninitialize();
		return 0;
	}
	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount() {return m_nLockCnt;}

	DWORD m_dwThreadID;
	HANDLE m_hThread;
	LONG m_nLockCnt;
};

class CComSimpleThreadAllocator
{
public:
	CComSimpleThreadAllocator()
	{
		m_nThread = 0;
	}
	int GetThread(CComApartment* /*pApt*/, int nThreads)
	{
		if (++m_nThread == nThreads)
			m_nThread = 0;
		return m_nThread;
	}
	int m_nThread;
};

#if _MSC_VER>1020
template <class ThreadAllocator = CComSimpleThreadAllocator>
#else
template <class ThreadAllocator>
#endif
class CComAutoThreadModule : public CComModule
{
public:
	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, int nThreads = GetDefaultThreads());
	~CComAutoThreadModule();
	HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
	LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	int m_nThreads;
	CComApartment* m_pApartments;
	ThreadAllocator m_Allocator;
	static int GetDefaultThreads()
	{
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		return si.dwNumberOfProcessors * 4;
	}
};




#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	ATLASSERT(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

#pragma pack(pop)

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
using namespace ATL;
#endif

#endif // __ATLBASE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

#define CComConnectionPointContainerImpl IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl IProvideClassInfoImpl
#define CComDualImpl IDispatchImpl

#ifdef _ATL_DEBUG_QI
HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#ifdef _ATL_DEBUG_REFCOUNT
//////////////////////////////////////////////////////////////////////////////
// CComDebugRefCount for interface level ref counting
class CComDebugRefCount
{
public:
	CComDebugRefCount()
	{
		m_nRef = 0;
	}
	~CComDebugRefCount()
	{
		_ASSERTE(m_nRef == 0);
	}
	long m_nRef;
};
#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className) \
public:\
	CComDebugRefCount _ref;\
	virtual ULONG STDMETHODCALLTYPE _DebugAddRef(void) \
	{return ((T*)this)->DebugAddRef(_ref.m_nRef, _T(#className));} \
	virtual ULONG STDMETHODCALLTYPE _DebugRelease(void) \
	{return ((T*)this)->DebugRelease(_ref.m_nRef, _T(#className));}
#else
#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
#endif // _ATL_DEBUG_REFCOUNT


HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
	HRESULT hRes = 0);

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID,
	const IID& iid = GUID_NULL, HRESULT hRes = 0,
	HINSTANCE hInst = _Module.GetResourceInstance());

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
	HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance());

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid = GUID_NULL,
	HRESULT hRes = 0);
#endif

#ifndef _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

#endif // _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <class T1>
class CComInternalCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->_InternalQueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID* ppv)
	{
		_ATL_VALIDATE_OUT_POINTER(ppv);
		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(ppv != NULL);
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		if (pv == NULL)
			hRes = T1::CreateInstance(NULL, riid, ppv);
		else
			hRes = T2::CreateInstance(pv, riid, ppv);
		return hRes;
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
	typedef CComCreator< CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD_PTR dwOffsetVar;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD_PTR dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		_ASSERTE(ppv != NULL);
		_ASSERTE(*ppv == NULL);
		
		_ASSERTE(pv != NULL);
		
		if (pv == NULL)
			return E_INVALIDARG;

		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
	}
};

#ifdef _ATL_DEBUG_QI
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(ULONG_PTR)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG_QI

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = E_FAIL; \
		__try \
		{ \
			hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		} \
		__finally \
		{ \
			p->Unlock();\
		} \
		return hRes;\
	}\
	IUnknown* GetUnknown() \
	{ _ASSERTE(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((DWORD_PTR)this+_GetEntries()->dw); } \
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \
	{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#define COM_INTERFACE_ENTRY_BREAK(x)\
	{&IID_##x, \
	NULL, \
	_Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
	{&IID_##x, \
	NULL, \
	_NoInterface},

#define COM_INTERFACE_ENTRY(x)\
	{&IID_##x, \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IMPL(x)\
	COM_INTERFACE_ENTRY_IID(IID_##x, x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
	COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&IID_##x,\
	(ULONG_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(ULONG_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(ULONG_PTR)&_CComCreatorData<\
		CComInternalCreator< CComTearOffObject< x > >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
	{&iid,\
	(ULONG_PTR)&_CComCacheData<\
		CComCreator< CComCachedTearOffObject< x > >,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
	{&iid,\
	(ULONG_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
	{NULL,\
	(ULONG_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(ULONG_PTR)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#ifdef _ATL_DEBUG_QI
#define END_COM_MAP_X() {NULL, 0, 0}}; return &_entries[1];}
#else
#define END_COM_MAP_X() {NULL, 0, 0}}; return _entries;}
#endif // _ATL_DEBUG_QI

#if 0       // remove for now - there's a lot of dirs that need to change before this can be enabled.
#ifdef _ATL_DEBUG_QI
#define END_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#else
#define END_COM_MAP() {NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#endif // _ATL_DEBUG_QI
#define END_COM_MAP_ADDREF
#else
#define END_COM_MAP() END_COM_MAP_X()
#endif

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, &class::UpdateRegistry, &class::_ClassFactoryCreatorClass::CreateInstance, &class::_CreatorClass::CreateInstance, NULL, 0, &class::GetObjectDescription },

#ifdef _ATL_DEBUG_QI
extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG_QI


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}

	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
	{
		_ASSERTE(pThis != NULL);
		// First entry in the com map should be a simple map entry
		_ASSERTE(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	#ifdef _ATL_DEBUG_QI
		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
	#endif // _ATL_DEBUG_QI
		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
	ULONG OuterAddRef()
	{
		return m_pOuterUnknown->AddRef();
	}
	ULONG OuterRelease()
	{
		return m_pOuterUnknown->Release();
	}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease()
	{
		_ASSERTE(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Break(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);
	static HRESULT WINAPI _NoInterface(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);
	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw);

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef typename _ThreadModel::AutoCriticalSection _CritSec;

	ULONG InternalAddRef()
	{
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}

#ifdef _ATL_DEBUG_REFCOUNT
	ULONG DebugAddRef(long& dw, LPCTSTR lpszClassName)
	{
		_ThreadModel::Increment(&dw);
		ATLTRACE(_T("%s %d>\n"), lpszClassName, dw);
		return AddRef();
	}
	ULONG DebugRelease(long& dw, LPCTSTR lpszClassName)
	{
		_ThreadModel::Decrement(&dw);
		ATLTRACE(_T("%s %d<\n"), lpszClassName, dw);
		return Release();
	}
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
#endif // _ATL_DEBUG_REFCOUNT

	void Lock() {m_critsec.Lock();}
	void Unlock() {m_critsec.Unlock();}
private:
	_CritSec m_critsec;
};

#if _MSC_VER>1020
template <>
#endif
class CComObjectRootEx<CComSingleThreadModel> : public CComObjectRootBase
{
public:
	typedef CComSingleThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;

	ULONG InternalAddRef()
	{
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}

#ifdef _ATL_DEBUG_REFCOUNT
	ULONG DebugAddRef(long& dw, LPCTSTR lpszClassName)
	{
		_ThreadModel::Increment(&dw);
		ATLTRACE(_T("%s %d>\n"), lpszClassName, dw);
		return AddRef();
	}
	ULONG DebugRelease(long& dw, LPCTSTR lpszClassName)
	{
		_ThreadModel::Decrement(&dw);
		ATLTRACE(_T("%s %d<\n"), lpszClassName, dw);
		return Release();
	}
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
#endif // _ATL_DEBUG_REFCOUNT

	void Lock() {}
	void Unlock() {}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
	static LPCTSTR WINAPI GetObjectDescription()\
	{\
		return _T(x);\
	}

#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : public CComObjectRootEx<ThreadModel>
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject()
	{
		m_dwRef = 1L;
		FinalRelease();
		_Module.Unlock();
	}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
	_ATL_VALIDATE_OUT_POINTER(pp);
	
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached(){m_dwRef = 1L; FinalRelease();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock() {m_dwRef = 1L; FinalRelease();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {_ASSERTE(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){_ASSERTE(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{_ASSERTE(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return OuterQueryInterface(iid, ppvObject);}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown() {return m_pOuterUnknown;}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
		public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComAggObject()
	{
		m_dwRef = 1L;
		FinalRelease();
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;

			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated

template <class contained>
class CComPolyObject :
	public IUnknown,
		public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComPolyObject(void* pv) : m_contained(pv ? pv : this)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		InternalAddRef();	
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		HRESULT hr = m_contained.FinalConstruct();
		InternalRelease();
		return hr;		
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComPolyObject()
	{
		m_dwRef = 1L;
		FinalRelease();
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
		
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : public Base
{
public:
	CComTearOffObject(void* pv)
	{
		_ASSERTE(m_pOwner == NULL);
		m_pOwner = reinterpret_cast<CComObject<Base::_OwnerClass>*>(pv);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
		m_pOwner->Release();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		return m_pOwner->QueryInterface(iid, ppvObject);
	}
};

template <class contained>
class CComCachedTearOffObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS>
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv) :
		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
	{
		_ASSERTE(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pv);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject(){m_dwRef = 1L; FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

class CComClassFactory2Base :
	public IClassFactory2,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
BEGIN_COM_MAP(CComClassFactory2Base)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : public CComClassFactory2Base, license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);

	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory

class CComClassFactoryAutoThread :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactoryAutoThread)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	STDMETHODIMP CComClassFactoryAutoThread::CreateInstance(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// cannot aggregate across apartments
			_ASSERTE(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
				hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj);
		}
		return hRes;
	}
	STDMETHODIMP CComClassFactoryAutoThread::LockServer(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : public CComClassFactory
{
public:
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			_ASSERTE(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				if (m_Obj.m_hResFinalConstruct != S_OK)
					hRes = m_Obj.m_hResFinalConstruct;
				else
					hRes = m_Obj.QueryInterface(riid, ppvObj);
			}

		}
		return hRes;
	}
	CComObjectGlobal<T> m_Obj;
};


template <class T, const CLSID* pclsid>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
		LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
#endif
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectWithSiteImpl)

	// IObjectWithSite
	//
	STDMETHOD(SetSite)(IUnknown *pUnkSite)
	{
		ATLTRACE(_T("IObjectWithSiteImpl::SetSite\n"));
		T* pT = static_cast<T*>(this);
		pT->m_spUnkSite = pUnkSite;
		return S_OK;
	}
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite)
	{
		ATLTRACE(_T("IObjectWithSiteImpl::GetSite\n"));
		T* pT = static_cast<T*>(this);
		_ASSERTE(ppvSite);
		HRESULT hRes = E_POINTER;
		if (ppvSite != NULL)
		{
			if (pT->m_spUnkSite)
				hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
			else
			{
				*ppvSite = NULL;
				hRes = E_FAIL;
			}
		}
		return hRes;
	}

	CComPtr<IUnknown> m_spUnkSite;
};

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid, const GUID* plibid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
	typedef tihclass _tihclass;
	IDispatchImpl() {_tih.AddRef();}
	~IDispatchImpl() {_tih.Release();}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{if( pctinfo == NULL ) return E_INVALIDARG; *pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor,
WORD wMinor, class tihclass>
typename IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl

template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;
	IProvideClassInfo2Impl() {_tih.AddRef();}
	~IProvideClassInfo2Impl() {_tih.Release();}

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)\
	{return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static HRESULT copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T)); return S_OK; }
	static void init(T*) {}
	static void destroy(T*) {}
};

#if _MSC_VER>1020
template<>
#endif
class _Copy<VARIANT>
{
public:
	static HRESULT copy(VARIANT* p1, VARIANT* p2) {return VariantCopy(p1, p2);}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

#if _MSC_VER>1020
template<>
#endif
class _Copy<LPOLESTR>
{
public:
	static HRESULT copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		if( (*p1) == NULL )
			return E_OUTOFMEMORY;
		ocscpy(*p1,*p2);
		return S_OK;
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

#if _MSC_VER>1020
template<>
#endif
class _Copy<OLEVERB>
{
public:
	static HRESULT copy(OLEVERB* p1, OLEVERB* p2)
	{
		*p1 = *p2;
		if( p1->lpszVerbName == NULL )
			return S_OK;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		if( p1->lpszVerbName == NULL )
			return E_OUTOFMEMORY;
		ocscpy(p1->lpszVerbName, p2->lpszVerbName);

		return S_OK;
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

#if _MSC_VER>1020
template<>
#endif
class _Copy<CONNECTDATA>
{
public:
	static HRESULT copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
		return S_OK;
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static HRESULT copy(T** p1, T** p2)
	{*p1 = *p2;if (*p1) (*p1)->AddRef(); return S_OK;}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0; m_pUnk = NULL;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	IUnknown* m_pUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
	if (m_pUnk)
		m_pUnk->Release();
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
    if (pceltFetched)
        *pceltFetched = 0;
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
    if (!celt)
        return E_INVALIDARG;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
    if (!celt)
        return E_INVALIDARG;
    ULONG nRem = (ULONG)(m_end - m_iter);
    if (celt <= nRem) {
        m_iter += celt;
        return S_OK;
    }
    m_iter = m_end;
    return S_FALSE;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		_class* p = NULL;
		ATLTRY(p = new _class)
		if (p == NULL)
		{
			*ppEnum = NULL;
			hRes = E_OUTOFMEMORY;
		}
		else
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_pUnk);
			if (FAILED(hRes))
				delete p;
			else
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
				if (FAILED(hRes))
					delete p;
			}
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		_ASSERTE(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[int(end-begin)])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_pUnk = pUnk;
	if (m_pUnk)
		m_pUnk->AddRef();
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD_PTR dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){LONG(offsetofclass(_ICPLocator<&iid>, _atl_conn_classtype)-\
	offsetofclass(IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype))},
#define END_CONNECTION_POINT_MAP() {(DWORD_PTR)-1} }; \
	if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \
	return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
	CComUnkArray()
	{
		memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
      ULONG iIndex;

      iIndex = ULONG( pp-begin() );
		return iIndex+1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
      if( dwCookie == 0 )
      {
         return( NULL );
      }

      ULONG iIndex = dwCookie-1;
      return( begin()[iIndex] );
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return &m_arr[nMaxSize];
	}
protected:
	IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(IUnknown* pUnk)
{
	for (IUnknown** pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return (DWORD)((pp-begin())+1); // return cookie
		}
	}
	// If this fires then you need a larger array
	_ASSERTE(0);
	return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(DWORD dwCookie)
{
   ULONG iIndex = dwCookie-1;
   if (iIndex >= nMaxSize)
   {
      return FALSE;
   }
   begin()[iIndex] = NULL;

   return TRUE;
}

#if _MSC_VER>1020
template<>
#endif
class CComUnkArray<1>
{
public:
	CComUnkArray()
	{
		m_arr[0] = NULL;
	}
	DWORD Add(IUnknown* pUnk)
	{
		if (m_arr[0] != NULL)
		{
			// If this fires then you need a larger array
			_ASSERTE(0);
			return 0;
		}
		m_arr[0] = pUnk;
		return 1;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != 1)
			return FALSE;
		m_arr[0] = NULL;
		return TRUE;
	}
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
        pp;
		return 1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
      if( dwCookie == 0 )
      {
         return( NULL );
      }
      return( *begin() );
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return (&m_arr[0])+1;
	}
protected:
	IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
	CComDynamicUnkArray()
	{
		m_nSize = 0;
		m_ppUnk = NULL;
	}

	~CComDynamicUnkArray()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
      ULONG iIndex;

      iIndex = ULONG( pp-begin() );
		return iIndex+1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
      if( dwCookie == 0 )
      {
         return( NULL );
      }

      ULONG iIndex = dwCookie-1;
      return begin()[iIndex];
	}
	IUnknown** begin()
	{
		return (m_nSize < 2) ? &m_pUnk : m_ppUnk;
	}
	IUnknown** end()
	{
		return (m_nSize < 2) ? (&m_pUnk)+m_nSize : &m_ppUnk[m_nSize];
	}
protected:
	union
	{
		IUnknown** m_ppUnk;
		IUnknown* m_pUnk;
	};
	int m_nSize;
};

template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator<piid>
{
public:
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
	typedef CDV _CDV;
	~IConnectionPointImpl();
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
	{
		_ATL_VALIDATE_OUT_POINTER(ppvObject);
		if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualGUID(riid, IID_IUnknown))
		{
			*ppvObject = this;
#ifdef _ATL_DEBUG_REFCOUNT
			_DebugAddRef();
#else
			AddRef();
#endif
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IConnectionPointImpl)

	STDMETHOD(GetConnectionInterface)(IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
	{
#if 0       // Turn off until END_COM_MAP can be changed
		T* pT = static_cast<T*>(this);
		// No need to check ppCPC for NULL since QI will do that for us
		return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
#else
		if (ppCPC == NULL)
			return E_POINTER;
		*ppCPC = reinterpret_cast<IConnectionPointContainer*>(
			(IConnectionPointContainerImpl<T>*)(T*)this);
        (*ppCPC)->AddRef();
		return S_OK;
#endif
	}
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
	CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
	IUnknown** pp = m_vec.begin();
	while (pp < m_vec.end())
	{
		if (*pp != NULL)
			(*pp)->Release();
		pp++;
	}
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	T* pT = (T*)this;
	IUnknown* p;
	HRESULT hRes = S_OK;
    if (pdwCookie == NULL)
		return E_POINTER;
    else
        *pdwCookie = 0;
	if (pUnkSink == NULL)
		return E_POINTER;
	IID iid;
	GetConnectionInterface(&iid);
	hRes = pUnkSink->QueryInterface(iid, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		pT->Lock();
		*pdwCookie = m_vec.Add(p);
		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
		pT->Unlock();
		if (hRes != S_OK)
			p->Release();
	}
	else if (hRes == E_NOINTERFACE)
		hRes = CONNECT_E_CANNOTCONNECT;
		
	if(FAILED(hRes))
		*pdwCookie = 0;
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(DWORD dwCookie)
{
	T* pT = (T*)this;
	pT->Lock();
	IUnknown* p = m_vec.GetUnknown(dwCookie);
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	pT->Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	T* pT = (T*)this;
	pT->Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[int(m_vec.end()-m_vec.begin())])
	if (pcd == NULL)
	{
		delete pEnum;
		pT->Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
	{
		if (*pp != NULL)
		{
			(*pp)->AddRef();
			pend->pUnk = *pp;
			pend->dwCookie = m_vec.GetCookie(pp);
			pend++;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	pT->Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl

template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IConnectionPointContainerImpl)

	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum)
	{
		if (ppEnum == NULL)
			return E_POINTER;
		*ppEnum = NULL;
		CComEnumConnectionPoints* pEnum = NULL;
		ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
		if (pEnum == NULL)
			return E_OUTOFMEMORY;

		int nCPCount;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);

		// allocate an initialize a vector of connection point object pointers
		USES_ATL_SAFE_ALLOCA;
		IConnectionPoint** ppCP = (IConnectionPoint**)_ATL_SAFE_ALLOCA(sizeof(IConnectionPoint*)*nCPCount, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (ppCP == NULL)
		{
			delete pEnum;
			return E_OUTOFMEMORY;
		}

		int i = 0;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			ppCP[i++] = (IConnectionPoint*)((ULONG_PTR)this+pEntry->dwOffset);
			pEntry++;
		}

		// copy the pointers: they will AddRef this object
		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
			(IConnectionPoint**)&ppCP[nCPCount],
			reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
		if (FAILED(hRes))
		{
			delete pEnum;
			return hRes;
		}
		hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
		if (FAILED(hRes))
			delete pEnum;
		return hRes;
	}
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP)
	{
		if (ppCP == NULL)
			return E_POINTER;
		*ppCP = NULL;
		HRESULT hRes = CONNECT_E_NOCONNECTION;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
		IID iid;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			IConnectionPoint* pCP =
				(IConnectionPoint*)((ULONG_PTR)this+pEntry->dwOffset);
			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
				InlineIsEqualGUID(riid, iid))
			{
				*ppCP = pCP;
				pCP->AddRef();
				hRes = S_OK;
				break;
			}
			pEntry++;
		}
		return hRes;
	}
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComAutoThreadModule

template <class ThreadAllocator>
inline HRESULT CComAutoThreadModule<ThreadAllocator>::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, int nThreads)
{
	m_nThreads = nThreads;
	m_pApartments = NULL;
	ATLTRY( m_pApartments = new CComApartment[m_nThreads] )
	ATLASSERT(m_pApartments != NULL);
	if( m_pApartments == NULL )
		return E_OUTOFMEMORY;
	for (int i = 0; i < nThreads; i++)
	{
		m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&m_pApartments[i], 0, &m_pApartments[i].m_dwThreadID);
		if(m_pApartments[i].m_hThread == NULL)
			return AtlHresultFromLastError();
	}
	CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
	return CComModule::Init(p, h);
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Lock()
{
	LONG l = CComModule::Lock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Lock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Unlock()
{
	LONG l = CComModule::Unlock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Unlock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
HRESULT CComAutoThreadModule<ThreadAllocator>::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj)
{
	_ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
	_AtlAptCreateObjData data;
	data.pfnCreateInstance = pFunc;
	data.piid = &riid;
	data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	data.hRes = S_OK;
	int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);

	int nIterations = 0;
	while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0
			&& ++ nIterations < 100)
	{
		Sleep(100);
	}
	
	if (nIterations < 100)
	{
		AtlWaitWithMessageLoop(data.hEvent);
	}
	else
	{
		data.hRes = AtlHresultFromLastError();
	}
	
	CloseHandle(data.hEvent);
	if (SUCCEEDED(data.hRes))
		data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
	return data.hRes;
}

template <class ThreadAllocator>
CComAutoThreadModule<ThreadAllocator>::~CComAutoThreadModule()
{
	for (int i=0; i < m_nThreads; i++)
	{
		::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0);
		::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE);
		::CloseHandle(m_pApartments[i].m_hThread);		
	}
	delete[] m_pApartments;
}


#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlapp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLAPP_H__
#define __ATLAPP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlapp.h requires atlbase.h to be included first
#endif

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMessageFilter;
class CUpdateUIObject;
class CMessageLoop;


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap for ATL 2.0/2.1

#if (_ATL_VER < 0x0300)

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLTRACE2
#define ATLTRACE2(cat, lev, msg)	ATLTRACE(msg)
#endif

#ifndef ATLINLINE
#define ATLINLINE inline
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aT);
			m_aT = NULL;
			m_nSize = 0;
			m_nAllocSize = 0;
		}
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

#endif //(_ATL_VER < 0x0300)

/////////////////////////////////////////////////////////////////////////////
// CMessageFilter - Interface for message filter support

class ATL_NO_VTABLE CMessageFilter
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CUpdateUIObject - Interface for update UI support

class ATL_NO_VTABLE CUpdateUIObject
{
public:
	virtual BOOL DoUpdate() = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CMessageLoop - message loop implementation

class CMessageLoop
{
public:
	CSimpleArray<CMessageFilter*> m_aMsgFilter;
	CSimpleArray<CUpdateUIObject*> m_aUpdateUI;
	MSG m_msg;

// Message filter operations
	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Add(pMessageFilter);
	}
	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Remove(pMessageFilter);
	}
// Update UI operations
	BOOL AddUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Add(pUpdateUI);
	}
	BOOL RemoveUpdateUI(CUpdateUIObject* pUpdateUI)
	{
		return m_aUpdateUI.Remove(pUpdateUI);
	}
// message loop
	int Run()
	{
		BOOL bDoIdle = TRUE;
		int nIdleCount = 0;
		BOOL bRet;

		for(;;)
		{
			while(!::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE) && bDoIdle)
			{
				if(!OnIdle(nIdleCount++))
					bDoIdle = FALSE;
			}

			bRet = ::GetMessage(&m_msg, NULL, 0, 0);

			if(bRet == -1)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("::GetMessage returned -1 (error)\n"));
				continue;	// error, don't process
			}
			else if(!bRet)
			{
				ATLTRACE2(atlTraceWindowing, 0, _T("CMessageLoop::Run - exiting\n"));
				break;		// WM_QUIT, exit message loop
			}

			if(!PreTranslateMessage(&m_msg))
			{
				::TranslateMessage(&m_msg);
				::DispatchMessage(&m_msg);
			}

			if(IsIdleMessage(&m_msg))
			{
				bDoIdle = TRUE;
				nIdleCount = 0;
			}
		}

		return (int)m_msg.wParam;
	}

	static BOOL IsIdleMessage(MSG* pMsg)
	{
		// These messages should NOT cause idle processing
		switch(pMsg->message)
		{
		case WM_MOUSEMOVE:
#ifndef UNDER_CE
		case WM_NCMOUSEMOVE:
#endif //!UNDER_CE
		case WM_PAINT:
		case 0x0118:	// WM_SYSTIMER (caret blink)
			return FALSE;
		}

		return TRUE;
	}

// Overrideables
	// Override to change message filtering
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		// loop backwards
		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
		{
			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
				return TRUE;
		}
		return FALSE;	// not translated
	}
	// override to change idle UI updates
	virtual BOOL OnIdle(int /*nIdleCount*/)
	{
		for(int i = 0; i < m_aUpdateUI.GetSize(); i++)
		{
			CUpdateUIObject* pUpdateUI = m_aUpdateUI[i];
			if(pUpdateUI != NULL)
				pUpdateUI->DoUpdate();
		}
		return FALSE;	// don't continue
	}
};


}; //namespace ATL

#endif // __ATLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlctl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver support

HRESULT CComDispatchDriver::GetProperty(IDispatch* pDisp, DISPID dwDispID,
	VARIANT* pVar)
{
	ATLTRACE(_T("CPropertyHelper::GetProperty\n"));
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	return pDisp->Invoke(dwDispID, IID_NULL,
			LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
			&dispparamsNoArgs, pVar, NULL, NULL);
}

HRESULT CComDispatchDriver::PutProperty(IDispatch* pDisp, DISPID dwDispID,
	VARIANT* pVar)
{
	ATLTRACE(_T("CPropertyHelper::PutProperty\n"));
	DISPPARAMS dispparams = {NULL, NULL, 1, 1};
	dispparams.rgvarg = pVar;
	DISPID dispidPut = DISPID_PROPERTYPUT;
	dispparams.rgdispidNamedArgs = &dispidPut;

	if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
		(pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
	{
		HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
			LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
			&dispparams, NULL, NULL, NULL);
		if (SUCCEEDED(hr))
			return hr;
	}

	return pDisp->Invoke(dwDispID, IID_NULL,
			LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
			&dispparams, NULL, NULL, NULL);
}

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent

HRESULT CFirePropNotifyEvent::FireOnRequestEdit(IUnknown* pUnk, DISPID dispID)
{
	CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
	if (!pCPC)
		return S_OK;
	CComPtr<IConnectionPoint> pCP;
	pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
	if (!pCP)
		return S_OK;
	CComPtr<IEnumConnections> pEnum;

	if (FAILED(pCP->EnumConnections(&pEnum)))
		return S_OK;
	CONNECTDATA cd;
	while (pEnum->Next(1, &cd, NULL) == S_OK)
	{
		if (cd.pUnk)
		{
			HRESULT hr = S_OK;
			CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
			if (pSink)
				hr = pSink->OnRequestEdit(dispID);
			cd.pUnk->Release();
			if (hr == S_FALSE)
				return S_FALSE;
		}
	}
	return S_OK;
}

HRESULT CFirePropNotifyEvent::FireOnChanged(IUnknown* pUnk, DISPID dispID)
{
	CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
	if (!pCPC)
		return S_OK;
	CComPtr<IConnectionPoint> pCP;
	pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
	if (!pCP)
		return S_OK;
	CComPtr<IEnumConnections> pEnum;

	if (FAILED(pCP->EnumConnections(&pEnum)))
		return S_OK;
	CONNECTDATA cd;
	while (pEnum->Next(1, &cd, NULL) == S_OK)
	{
		if (cd.pUnk)
		{
			CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
			if (pSink)
				pSink->OnChanged(dispID);
			cd.pUnk->Release();
		}
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Control support

HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont,
	QACONTROL *pQACtrl)
{
	_ASSERTE(pQACont != NULL);
	_ASSERTE(pQACtrl != NULL);
	_ASSERTE(pQACont->cbSize >= sizeof(QACONTAINER));
	_ASSERTE(pQACtrl->cbSize >= sizeof(QACONTROL));

	if (!pQACont || !pQACtrl)
		return E_POINTER;

	HRESULT hRes;
	memset(pQACtrl, 0, sizeof(QACONTROL));
	pQACtrl->cbSize = sizeof(QACONTROL);

	// get all interfaces we are going to need
	CComPtr<IOleObject> pOO;
	ControlQueryInterface(IID_IOleObject, (void**)&pOO);
	CComPtr<IViewObjectEx> pVOEX;
	ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
	CComPtr<IPointerInactive> pPI;
	ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
	CComPtr<IProvideClassInfo2> pPCI;
	ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);

	if (pOO == NULL || pVOEX == NULL)
		return E_FAIL;

	pOO->SetClientSite(pQACont->pClientSite);

	if (pQACont->pAdviseSink != NULL)
	{
		ATLTRACE(_T("Setting up IOleObject Advise\n"));
		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
	}

	CComPtr<IConnectionPointContainer> pCPC;
	ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	if (pQACont->pPropertyNotifySink)
	{
		ATLTRACE(_T("Setting up PropNotify CP\n"));
		CComPtr<IConnectionPoint> pCP;
		if (pCPC != NULL)
		{
			hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
			if (SUCCEEDED(hRes))
				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
		}
	}

	if (pPCI)
	{
		GUID iidDefaultSrc;
		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
			&iidDefaultSrc)))
		{
			if (pQACont->pUnkEventSink)
			{
				ATLTRACE(_T("Setting up Default Out Going Interface\n"));
				CComPtr<IConnectionPoint> pCP;
				if (pCPC != NULL)
				{
					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
					if (SUCCEEDED(hRes))
						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
				}
			}
		}
	}
	// give information to container
	if (pOO != NULL)
		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

	if (pVOEX != NULL)
		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

	if (pPI != NULL)
		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
	return S_OK;
}

HRESULT CComControlBase::IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
	LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
{
	USES_CONVERSION;
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;
		CComVariant var;

		if(pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		if (FAILED(hr))
		{
			if (hr == E_INVALIDARG)
			{
				ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
			}
			else
			{
				// Many containers return different ERROR values for Member not found
				ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
			}
			continue;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}
	}
	return S_OK;

}

HRESULT CComControlBase::IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap)
{
	if (pPropBag == NULL)
	{
		ATLTRACE(_T("PropBag pointer passed in was invalid\n"));
		return E_POINTER;
	}

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;
		CComVariant var;

		if(pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		{
			if (var.punkVal == NULL)
			{
				ATLTRACE(_T("Warning skipping empty IUnknown in Save\n"));
				continue;
			}
		}

		HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		if (FAILED(hr))
			return hr;
	}
	m_bRequiresSave = FALSE;
	return S_OK;
}

HRESULT CComControlBase::ISpecifyPropertyPages_GetPages(CAUUID* pPages,
	ATL_PROPMAP_ENTRY* pMap)
{
	_ASSERTE(pMap != NULL);
	if (pMap == NULL || pPages == NULL)
		return E_INVALIDARG;
	int nCnt = 0;
	// Get count of unique pages
	for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
			nCnt++;
	}
	pPages->pElems = NULL;
	pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
	if (pPages->pElems == NULL)
		return E_OUTOFMEMORY;
	nCnt = 0;
	for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
		{
			BOOL bMatch = FALSE;
			for (int j=0;j<nCnt;j++)
			{
				if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
				{
					bMatch = TRUE;
					break;
				}
			}
			if (!bMatch)
				pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
		}
	}
	pPages->cElems = nCnt;
	return S_OK;
}

BOOL CComControlBase::SetControlFocus(BOOL bGrab)
{
	if (m_bWndLess)
	{
		if (!m_bUIActive && bGrab)
			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
				return FALSE;

		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
	}
	else
	{
		// we've got a window.
		//
		if (m_bInPlaceActive)
		{
			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
			if (!m_bUIActive && bGrab)
				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
			else
				return (::SetFocus(hwnd) != NULL);
		}
	}
	return FALSE;
}

HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent)
{
	HRESULT hr = S_OK;
	CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
	CComQIPtr <IOleObject, &IID_IOleObject> spObj;
	CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);

	if (spSite)
	{
		hr = spSite->ShowPropertyFrame();
		if (SUCCEEDED(hr))
			return hr;
	}

	CComPtr<IUnknown> pUnk;
	hr = ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
	_ASSERTE(pUnk != NULL);
	if (pUnk == NULL)
		return hr;
	CAUUID pages;
	spPages = pUnk;
	if (spPages)
	{
		spPages->GetPages(&pages);
		spObj = pUnk;
		if (spObj)
		{
			LPOLESTR szTitle = NULL;

			spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

			hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
				1, &pUnk.p, pages.cElems, pages.pElems, LOCALE_USER_DEFAULT, 0, 0);

			CoTaskMemFree(szTitle);
		}
		else
		{
			hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
		}
	}
	else
	{
		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
	}

	return hr;
}

HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* prcPosRect)
{
	HRESULT hr;

	if (m_spClientSite == NULL)
		return S_OK;

	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	_ASSERTE(pIPO != NULL);
	if (prcPosRect != NULL)
		pIPO->SetObjectRects(prcPosRect, prcPosRect);

	if (!m_bNegotiatedWnd)
	{
		if (!m_bWindowOnly)
			// Try for windowless site
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

		if (m_spInPlaceSite)
		{
			m_bInPlaceSiteEx = TRUE;
			m_bWndLess = SUCCEEDED(m_spInPlaceSite->CanWindowlessActivate());
			m_bWasOnceWindowless = TRUE;
		}
		else
		{
			m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
			if (m_spInPlaceSite)
				m_bInPlaceSiteEx = TRUE;
			else
				hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
		}
	}

	_ASSERTE(m_spInPlaceSite);
	if (!m_spInPlaceSite)
		return E_FAIL;

	m_bNegotiatedWnd = TRUE;

	if (!m_bInPlaceActive)
	{

		BOOL bNoRedraw = FALSE;
		if (m_bWndLess)
			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
		else
		{
			if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				HRESULT hr = m_spInPlaceSite->CanInPlaceActivate();
				if (FAILED(hr))
					return hr;
				m_spInPlaceSite->OnInPlaceActivate();
			}
		}
	}

	m_bInPlaceActive = TRUE;

	// get location in the parent window,
	// as well as some information about the parent
	//
	OLEINPLACEFRAMEINFO frameInfo;
	RECT rcPos, rcClip;
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	HWND hwndParent;
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				_ASSERTE(h == m_hWndCD);
			}
		}

		pIPO->SetObjectRects(&rcPos, &rcClip);
	}

	CComPtr<IOleInPlaceActiveObject> spActiveObject;
	ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

	// Gone active by now, take care of UIACTIVATE
	if (DoesVerbUIActivate(iVerb))
	{
		if (!m_bUIActive)
		{
			m_bUIActive = TRUE;
			hr = m_spInPlaceSite->OnUIActivate();
			if (FAILED(hr))
				return hr;

			SetControlFocus(TRUE);
			// set ourselves up in the host.
			//
			if (spActiveObject)
			{
				if (spInPlaceFrame)
					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
				if (spInPlaceUIWindow)
					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
			}

			if (spInPlaceFrame)
				spInPlaceFrame->SetBorderSpace(NULL);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetBorderSpace(NULL);
		}
	}

	m_spClientSite->ShowObject();

	return S_OK;
}

HRESULT CComControlBase::IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap)
{
	_ASSERTE(pMap != NULL);
	if (pStm == NULL || pMap == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	DWORD dwVer;
	hr = pStm->Read(&dwVer, sizeof(DWORD), NULL);
	if (SUCCEEDED(hr) && dwVer <= _ATL_VER)
		hr = pStm->Read(&m_sizeExtent, sizeof(m_sizeExtent), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;
		CComVariant var;

		HRESULT hr = var.ReadFromStream(pStm);
		if (FAILED(hr))
			break;

		if(pMap[i].piidDispatch != piidOld)
		{
			if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}

HRESULT CComControlBase::IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap)
{
	_ASSERTE(pMap != NULL);
	if (pStm == NULL || pMap == NULL)
		return E_INVALIDARG;

	DWORD dw = _ATL_VER;
	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;
	hr = pStm->Write(&m_sizeExtent, sizeof(m_sizeExtent), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;
		CComVariant var;

		if(pMap[i].piidDispatch != piidOld)
		{
			if(FAILED(ControlQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}

		HRESULT hr = var.WriteToStream(pStm);
		if (FAILED(hr))
			break;
	}
	if (SUCCEEDED(hr))
		m_bRequiresSave = FALSE;

	return hr;
}

HRESULT CComControlBase::SendOnDataChange(DWORD advf)
{
	HRESULT hRes = S_OK;
	if (m_spDataAdviseHolder)
	{
		CComPtr<IDataObject> pdo;
		if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
	}
	return hRes;
}

HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
	_ASSERTE(pClientSite == NULL || m_spClientSite == NULL);
	if (pClientSite == NULL)
		return E_INVALIDARG;
	m_spClientSite = pClientSite;
	m_spAmbientDispatch.Release();
	if (m_spClientSite != NULL)
	{
		m_spClientSite->QueryInterface(IID_IDispatch,
			(void**) &m_spAmbientDispatch.p);
	}
	return S_OK;
}

HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite)
{
	_ASSERTE(ppClientSite);
	HRESULT hRes = E_POINTER;
	if (ppClientSite != NULL)
	{
		*ppClientSite = m_spClientSite;
		m_spClientSite.p->AddRef();
		hRes = S_OK;
	}
	return hRes;
}

HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	HRESULT hr = S_OK;
	if (m_spOleAdviseHolder == NULL)
		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
	if (SUCCEEDED(hr))
		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
	return hr;
}

HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption)
{
	CComPtr<IOleInPlaceObject> pIPO;
	HRESULT hr = ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	_ASSERTE(pIPO != NULL);
	if (pIPO == NULL)
		return hr;
	if (m_hWndCD)
	{
		if (m_spClientSite)
			m_spClientSite->OnShowWindow(FALSE);
	}

	if (m_bInPlaceActive)
	{
		HRESULT hr = pIPO->InPlaceDeactivate();
		if (FAILED(hr))
			return hr;
		_ASSERTE(!m_bInPlaceActive);
	}
	if (m_hWndCD)
	{
		ATLTRACE(_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	// handle the save flag.
	//
	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
	{
		if (m_spClientSite)
			m_spClientSite->SaveObject();
		SendOnSave();
	}

	m_spInPlaceSite.Release();
	m_bNegotiatedWnd = FALSE;
	m_bWndLess = FALSE;
	m_bInPlaceSiteEx = FALSE;
	m_spAdviseSink.Release();
	return S_OK;
}

HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
	CComPtr<IOleInPlaceObject> pIPO;
	HRESULT hr = ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	_ASSERTE(pIPO != NULL);
	if (pIPO == NULL)
		return hr;

	if (!m_bInPlaceActive)
		return S_OK;
	pIPO->UIDeactivate();

	m_bInPlaceActive = FALSE;

	// if we have a window, tell it to go away.
	//
	if (m_hWndCD)
	{
		ATLTRACE(_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	if (m_spInPlaceSite)
		m_spInPlaceSite->OnInPlaceDeactivate();

	return S_OK;
}

HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
	// if we're not UIActive, not much to do.
	//
	if (!m_bUIActive)
		return S_OK;

	m_bUIActive = FALSE;

	// notify frame windows, if appropriate, that we're no longer ui-active.
	//
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	OLEINPLACEFRAMEINFO frameInfo;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	RECT rcPos, rcClip;

	HWND hwndParent; 
	// This call to GetWindow is a fix for Delphi
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
		if (spInPlaceUIWindow)
			spInPlaceUIWindow->SetActiveObject(NULL, NULL);
		if (spInPlaceFrame)
			spInPlaceFrame->SetActiveObject(NULL, NULL);
	}
	// we don't need to explicitly release the focus here since somebody
	// else grabbing the focus is what is likely to cause us to get lose it
	//
	m_spInPlaceSite->OnUIDeactivate(FALSE);

	return S_OK;
}

HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
	if (prcPos == NULL || prcClip == NULL)
		return E_POINTER;

	m_rcPos = *prcPos;
	if (m_hWndCD)
	{
		// the container wants us to clip, so figure out if we really
		// need to
		//
		RECT rcIXect;
		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
		HRGN tempRgn = NULL;
		if (b && !EqualRect(&rcIXect, prcPos))
		{
			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
			tempRgn = CreateRectRgnIndirect(&rcIXect);
		}

		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

		// set our control's location, but don't change it's size at all
		// [people for whom zooming is important should set that up here]
		//
		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
		SetWindowPos(m_hWndCD, NULL, prcPos->left,
					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return S_OK;
}

HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;
	if (psizel == NULL)
		return E_POINTER;

	BOOL bSizeMatchesNatural =
		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

	if (m_bAutoSize) //object can't do any other size
		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

	BOOL bResized = FALSE;
	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
	{
		m_sizeExtent = *psizel;
		bResized = TRUE;
	}
	if (m_bResizeNatural && !bSizeMatchesNatural)
	{
		m_sizeNatural = *psizel;
		bResized = TRUE;
	}

	if (m_bRecomposeOnResize && bResized)
	{
		SendOnDataChange();
		FireViewChange();
	}
	return S_OK;
}

HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex,
	void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
	LPCRECTL prcBounds, LPCRECTL prcWBounds)
{
	ATLTRACE(_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
		dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw);
#ifdef _DEBUG
	if (prcBounds == NULL)
		ATLTRACE(_T("\tprcBounds=NULL\n"));
	else
		ATLTRACE(_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
			prcBounds->top, prcBounds->right, prcBounds->bottom);
	if (prcWBounds == NULL)
		ATLTRACE(_T("\tprcWBounds=NULL\n"));
	else
		ATLTRACE(_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif
	_ASSERTE((prcBounds != NULL) | m_bWndLess);

	if (prcBounds == NULL)
	{
		if (!m_bWndLess)
			return E_INVALIDARG;
		prcBounds = (RECTL*)&m_rcPos;
	}

	// support the aspects required for multi-pass drawing
	switch (dwDrawAspect)
	{
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			_ASSERTE(FALSE);
			return DV_E_DVASPECT;
			break;
	}

	// make sure nobody forgets to do this
	if (ptd == NULL)
		hicTargetDev = NULL;

	BOOL bOptimize = FALSE;
	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = dwDrawAspect;
	di.lindex = lindex;
	di.ptd = ptd;
	di.hicTargetDev = hicTargetDev;
	di.hdcDraw = hdcDraw;
	di.prcBounds = prcBounds;
	di.prcWBounds = prcWBounds;
	di.bOptimize = bOptimize;
	return OnDrawAdvanced(di);
}

HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn,
	STGMEDIUM *pmedium)
{
	if (pmedium == NULL || pformatetcIn == NULL)
		return E_POINTER;
	memset(pmedium, 0, sizeof(STGMEDIUM));
	ATLTRACE(_T("Format = %x\n"), pformatetcIn->cfFormat);
	ATLTRACE(_T("TYMED = %x\n"), pformatetcIn->tymed);

	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
		return DATA_E_FORMATETC;

	SIZEL sizeMetric, size;
	if (m_bDrawFromNatural)
		sizeMetric = m_sizeNatural;
	else
		sizeMetric = m_sizeExtent;
	if (!m_bDrawGetDataInHimetric)
		AtlHiMetricToPixel(&sizeMetric, &size);
	else
		size = sizeMetric;
	RECTL rectl = {0 ,0, size.cx, size.cy};

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.ptd = NULL;
	di.hicTargetDev = NULL;
	di.prcBounds = &rectl;
	di.prcWBounds = &rectl;
	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
	di.bRectInHimetric = m_bDrawGetDataInHimetric;
	// create appropriate memory metafile DC
	di.hdcDraw = CreateMetaFile(NULL);

	// create attribute DC according to pformatetcIn->ptd

	SaveDC(di.hdcDraw);
	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
	OnDrawAdvanced(di);
	RestoreDC(di.hdcDraw, -1);

	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
	if (hMF == NULL)
		return E_UNEXPECTED;

	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

	if (NULL==hMem)
	{
		DeleteMetaFile(hMF);
		return ResultFromScode(STG_E_MEDIUMFULL);
	}

	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
	pMF->hMF=hMF;
	pMF->mm=MM_ANISOTROPIC;
	pMF->xExt=sizeMetric.cx;
	pMF->yExt=sizeMetric.cy;
	GlobalUnlock(hMem);

	pmedium->tymed = TYMED_MFPICT;
	pmedium->hGlobal = hMem;
	pmedium->pUnkForRelease = NULL;

	return S_OK;

}

HRESULT CComControlBase::FireViewChange()
{
	if (m_bInPlaceActive)
	{
		// Active
		if (m_hWndCD != NULL)
			return (::InvalidateRect(m_hWndCD, NULL, TRUE)) ? S_OK : E_FAIL; // Window based
		if (m_spInPlaceSite != NULL)
			return m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
	}
	// Inactive
	SendOnViewChange(DVASPECT_CONTENT);
	return S_OK;
}

void CComControlBase::GetZoomInfo(ATL_DRAWINFO& di)
{
	const RECTL& rcPos = *di.prcBounds;
	SIZEL sizeDen;
	if (m_bDrawFromNatural)
		sizeDen = m_sizeNatural;
	else
		sizeDen = m_sizeExtent;
	if (!di.bRectInHimetric)
		AtlHiMetricToPixel(&sizeDen, &sizeDen);
	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
	di.ZoomNum.cx = sizeNum.cx;
	di.ZoomNum.cy = sizeNum.cy;
	di.ZoomDen.cx = sizeDen.cx;
	di.ZoomDen.cy = sizeDen.cy;
	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
		sizeNum.cx == 0 || sizeNum.cy == 0)
	{
		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
		di.bZoomed = FALSE;
	}
	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
		di.bZoomed = TRUE;
	else
		di.bZoomed = FALSE;
}

HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO& di)
{
	BOOL bDeleteDC = FALSE;
	if (di.hicTargetDev == NULL)
	{
		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
		bDeleteDC = (di.hicTargetDev != di.hdcDraw);
	}
	RECTL rectBoundsDP = *di.prcBounds;
	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
	if (!bMetafile)
	{
		::LPtoDP(di.hicTargetDev, (LPPOINT)&rectBoundsDP, 2);
		SaveDC(di.hdcDraw);
		SetMapMode(di.hdcDraw, MM_TEXT);
		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
		di.bOptimize = TRUE; //since we save the DC we can do this
	}
	di.prcBounds = &rectBoundsDP;
	GetZoomInfo(di);

	HRESULT hRes = OnDraw(di);
	if (bDeleteDC)
		::DeleteDC(di.hicTargetDev);
	if (!bMetafile)
		RestoreDC(di.hdcDraw, -1);
	return hRes;
}

LRESULT CComControlBase::OnPaint(UINT /* nMsg */, WPARAM /* wParam */,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
	di.prcBounds = (LPCRECTL)&rc;

	OnDrawAdvanced(di);
	::EndPaint(m_hWndCD, &ps);
	return 0;
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////

#ifndef _ATL_DLL
ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
	USES_CONVERSION;

	// cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

	if (ptd != NULL)
	{
		LPDEVMODEOLE lpDevMode;
		LPOLESTR lpszDriverName;
		LPOLESTR lpszDeviceName;
		LPOLESTR lpszPortName;

		if (ptd->tdExtDevmodeOffset == 0)
			lpDevMode = NULL;
		else
			lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

		lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
		lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
		lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

		return ::CreateDC(OLE2CT(lpszDriverName), OLE2CT(lpszDeviceName),
			OLE2CT(lpszPortName), DEVMODEOLE2T(lpDevMode));
	}
	else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
	else
		return hdc;
}

#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	_ASSERTE(hDCScreen != NULL);
    if (hDCScreen) {
    	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	    nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
    	ReleaseDC(NULL, hDCScreen);
    } else {
        nPixelsPerInchX = nPixelsPerInchY = 1;
    }

	lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
}

ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	_ASSERTE(hDCScreen != NULL);
    if (hDCScreen) {
    	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	    nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
    	ReleaseDC(NULL, hDCScreen);
    } else {
        nPixelsPerInchX = nPixelsPerInchY = 1;
    }

	lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>
#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")

ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);
ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T> class CComControl;
class CComDispatchDriver;

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;

};

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {_ASSERTE(p!=NULL); return *p; }
	IDispatch** operator&() {_ASSERTE(p==NULL); return &p; }
	IDispatch* operator->() {_ASSERTE(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		_ASSERTE(p);
		return PutProperty(p, dwDispID, pVar);
	}

	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID, VARIANT* pVar);
	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent
class CFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID);
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID);
};


//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};


typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// CComControl
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE(_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here
	// non-virtuals only please
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	void GetZoomInfo(ATL_DRAWINFO& di);
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	HRESULT SendOnDataChange(DWORD advf = 0);
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	LRESULT OnSetFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(TRUE);
		return 0;
	}

	LRESULT OnKillFocus(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite)
			spSite->OnFocus(FALSE);
		return 0;
	}
	LRESULT OnGetDlgCode(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */, BOOL& /* bHandled */)
	{
		return 0;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		if (SUCCEEDED(hRes))
			nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		if (SUCCEEDED(hRes))
			BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDisplayName)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
        if (SUCCEEDED(hRes))
        {
                if (var.vt != VT_BSTR)
                        return E_FAIL;
                bstrDisplayName = var.bstrVal;
                var.vt = VT_EMPTY;
                var.bstrVal = NULL;
        }
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		_ASSERTE((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		if (SUCCEEDED(hRes))
			ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		_ASSERTE(var.vt == VT_I4 || FAILED(hRes));
		if (SUCCEEDED(hRes))
			lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		_ASSERTE(var.vt == VT_BSTR || FAILED(hRes));
        if (SUCCEEDED(hRes))
        {
                if (var.vt != VT_BSTR)
                        return E_FAIL;
                bstrScaleUnits = var.bstrVal;
                var.vt = VT_EMPTY;
                var.bstrVal = NULL;
        }
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		_ASSERTE(var.vt == VT_I2 || FAILED(hRes));
		if (SUCCEEDED(hRes))
			nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		_ASSERTE(var.vt == VT_BOOL || FAILED(hRes));
		if (SUCCEEDED(hRes))
			bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
		_ASSERTE(var.vt == VT_INT_PTR || FAILED(hRes));
		if (SUCCEEDED(hRes))
			hPalette = reinterpret_cast<HPALETTE>(var.byref);
		return hRes;
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
		LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
		BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap);
	HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
		ATL_PROPMAP_ENTRY* pMap);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */,
		ATL_PROPMAP_ENTRY* pMap);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT /* nMsg */, WPARAM /* wParam */, LPARAM /* lParam */,
		BOOL& /* lResult */);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		long m_nBackStyle;
		long m_nBorderStyle;
		long m_nBorderWidth;
		long m_nDrawMode;
		long m_nDrawStyle;
		long m_nDrawWidth;
		long m_nFillStyle;
		long m_nAppearance;
		long m_nMousePointer;
		long m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels
};

template <class T>
class ATL_NO_VTABLE CComControl :  public CComControlBase, public CWindowImpl<T>
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}
};

// Forward declarations
//
template <class T> class IPersistImpl;
template <class T> class IPersistStreamInitImpl;
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class ISpecifyPropertyPagesImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_POINTER;
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}
};

#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL} \
		}; \
		return pPropMap; \
	}


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStreamInitImpl)

#if _MSC_VER >= 1200
#pragma warning( push )
#pragma warning( disable: 4189 )
#endif
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_POINTER;
		T* pT = static_cast<T*>(this);
		if (!pClassID)
			return E_POINTER;
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}
#if _MSC_VER >= 1200
#pragma warning( pop )
#endif
	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE(_T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE(_T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPersistStreamInitImpl::InitNew\n"));
		pT->SendOnDataChange();
		return S_OK;
	}

};


//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistStorageImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistStorageImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		if (pClassID == NULL)
			return E_POINTER;
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE(_T("IPersistStorageImpl::InitNew\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE(_T("IPersistStorageImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE(_T("IPersistStorageImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE(_T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE(_T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}

//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl
{
public:

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPersistPropertyBagImpl)

	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::GetClassID\n"));
		T* pT = static_cast<T*>(this);
		if (pClassID == NULL)
			return E_POINTER;
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	// IOleControl methods
	//
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE(_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE(_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IQuickActivateImpl)

	// IQuickActivate
	//
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleObjectImpl)

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE(_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		pT->UIDeactivate();
		if (pT->m_hWnd)
			pT->ShowWindow(SW_HIDE);
		return S_OK;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::DoVerb\n"));
		_ASSERTE(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n"));
		_ASSERTE(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n"));
		_ASSERTE(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl
{

public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (!pT->m_bDirty && bDirty)
			pT->m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE);
		pT->m_bDirty = bDirty;
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE(_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE(_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE(_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE(_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE(_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pTemp = (DLGTEMPLATE*)LockResource(hGlob);
		if (pTemp == NULL)
		{
			ATLTRACE(_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		pT->GetDialogSize(pTemp, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION_EX;

		ATLTRACE(_T("IPropertyPageImpl::Help\n"));
		
		LPCTSTR lpszFName = NULL;
		if (pszHelpDir != NULL)
		{
			lpszFName = OLE2CT_EX(pszHelpDir, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
			if (lpszFName == NULL) 
			{
				return E_OUTOFMEMORY;
			}
#endif // _UNICODE
		}
		WinHelp(pT->m_hWnd, lpszFName, HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::TranslateAccelerator\n"));
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			if (lParam == NULL)
				return 0;
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION_EX;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
		{
			LPOLESTR lpszStr = T2OLE_EX(szTemp, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE			
			if(lpszStr == NULL) 
				return NULL;
#endif // _UNICODE
			ocscpy(sz, lpszStr);
		}
		else
		{
			ATLTRACE(_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}

	void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		if (HasFont(pTemplate))
		{
			TCHAR szFace[LF_FACESIZE];
			WORD  wFontSize = 0;
			GetFont(pTemplate, szFace, &wFontSize);
			GetSizeInDialogUnits(pTemplate, pSize);
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize);
		}
		else
		{
			GetSizeInDialogUnits(pTemplate, pSize);
			LONG nDlgBaseUnits = GetDialogBaseUnits();
			pSize->cx = MulDiv(pSize->cx, LOWORD(nDlgBaseUnits), 4);
			pSize->cy = MulDiv(pSize->cy, HIWORD(nDlgBaseUnits), 8);
		}
	}

	static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel)
	{
		// Attempt to create the font to be used in the dialog box
		UINT cxSysChar, cySysChar;
		LOGFONT lf;
		HDC hDC = ::GetDC(NULL);
		int cxDlg = pSizePixel->cx;
		int cyDlg = pSizePixel->cy;

		ZeroMemory(&lf, sizeof(LOGFONT));
		lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = DEFAULT_CHARSET;
		lstrcpyn(lf.lfFaceName, pszFontFace, sizeof lf.lfFaceName / sizeof lf.lfFaceName[0]);

		HFONT hNewFont = CreateFontIndirect(&lf);
		if (hNewFont != NULL)
		{
			TEXTMETRIC  tm;
			SIZE        size;
			HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
			GetTextMetrics(hDC, &tm);
			cySysChar = tm.tmHeight + tm.tmExternalLeading;
			::GetTextExtentPoint(hDC,
				_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
				&size);
			cxSysChar = (size.cx + 26) / 52;
			SelectObject(hDC, hFontOld);
			DeleteObject(hNewFont);
		}
		else
		{
			// Could not create the font so just use the system's values
			cxSysChar = LOWORD(GetDialogBaseUnits());
			cySysChar = HIWORD(GetDialogBaseUnits());
		}
		::ReleaseDC(NULL, hDC);

		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
		pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
	}

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
	{
		USES_CONVERSION_EX;
		if (!HasFont(pTemplate) || pFontSize == NULL)
			return FALSE;

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);

		LPCTSTR szT = W2T_EX((WCHAR*)pb, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (NULL == szT)
		{
			return FALSE;
		}
		_tcsncpy(pszFace, szT, LF_FACESIZE);
		if (_tcslen(szT) >= LF_FACESIZE) 
		{	// NUL not appended
			pszFace[LF_FACESIZE-1] = _T('\0');
		}
		return TRUE;
	}

	static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPerPropertyBrowsingImpl)

	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
		{
			*pBstr = NULL;
			return S_FALSE;
		}

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
			{
				*pBstr = NULL;
				return S_FALSE;
			}
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
        if (*pBstr == NULL)
                return E_OUTOFMEMORY;
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;
			if (pMap[i].dispid == dispID)
			{
				_ASSERTE(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IViewObjectExImpl)

	// IViewObject
	//
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
					DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetExtent\n"));
		if (lpsizel == NULL)
			return E_INVALIDARG;
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		if (pdwStatus == NULL)
			return E_INVALIDARG;
		*pdwStatus =
//          VIEWSTATUS_DVASPECTOPAQUE | VIEWSTATUS_DVASPECTTRANSPARENT |
//          VIEWSTATUS_SOLIDBKGND |
			VIEWSTATUS_OPAQUE;

		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (pHitResult == NULL)
			return E_INVALIDARG;
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitRect\n"));
		if (pHitResult == NULL)
			return E_INVALIDARG;
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetNaturalExtent\n"));
		if (psizel == NULL)
			return E_INVALIDARG;
		HRESULT hRes = E_FAIL;
		if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceObjectWindowlessImpl)

	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		return (pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult)) ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceActiveObjectImpl)

	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG /* lpmsg */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		return E_NOTIMPL;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(ISpecifyPropertyPagesImpl)

	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE(_T("ISpecifyPropertyPagesImpl::GetPages\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return pT->ISpecifyPropertyPages_GetPages(pPages, pMap);
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPointerInactiveImpl)

	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IRunnableObjectImpl)

	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE(_T("IRunnableObjectImpl::GetRunningClass\n"));
		if (lpClsid == NULL)
			return E_POINTER;
		T* pT = static_cast<T*>(this);
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE(_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE(_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IDataObjectImpl)

	// IDataObject
	//
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE(_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE(_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T>
class ATL_NO_VTABLE IObjectSafetyImpl
{
public:
	IObjectSafetyImpl()
	{
		m_dwSafety = 0;
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		HRESULT hr = S_OK;
		if (riid == IID_IDispatch)
		{
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		}
		else
		{
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions = 0;
			hr = E_NOINTERFACE;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
		if (riid == IID_IDispatch)
		{
			// Store our current safety level to return in GetInterfaceSafetyOptions
			m_dwSafety = dwEnabledOptions & dwOptionSetMask;
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	DWORD m_dwSafety;
};


template <class T>
class ATL_NO_VTABLE IOleLinkImpl
{
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleLinkImpl)

	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE(_T("IOleLink::GetSourceDisplayName\n"));
		if (ppszDisplayName == NULL)
			return E_POINTER;
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE(_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};


template <class T>
class ATL_NO_VTABLE IBindStatusCallbackImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IBindStatusCallbackImpl)

	// IBindStatusCallback
	//
	STDMETHOD(OnStartBinding)(DWORD /* dwReserved */, IBinding *pBinding)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStartBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG* /* pnPriority */)
	{
		ATLTRACENOTIMPL(_T("IBindStatusCallbackImpl::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD /* reserved */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnLowResource\n"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG /* ulProgress */, ULONG /* ulProgressMax */, ULONG /* ulStatusCode */, LPCWSTR /* szStatusText */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnProgress\n"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT /* hresult */, LPCWSTR /* szError */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStopBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD* /* pgrfBINDF */, BINDINFO* /* pBindInfo */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::GetBindInfo\n"));
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnDataAvailable\n"));
		return S_OK;
	}

	STDMETHOD(OnObjectAvailable)(REFIID /* riid */, IUnknown* /* punk */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnObjectAvailable\n"));
		return S_OK;
	}
};


template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallbackImpl<T>
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl<T>)
END_COM_MAP()


	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE(_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnLowResource"));
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnProgress"));
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStopBinding\n"));
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		if (pstgmed == NULL)
			return E_INVALIDARG;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return S_FALSE;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnObjectAvailable"));
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), IID_IStream, (void**)&spStream);
				ATLTRACE(_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}

template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
        IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(LONG /*hWnd*/)
	{
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(LONG* phWnd)
	{
		T* pT = (T*) this;
		*phWnd = (LONG)(LONG_PTR)pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(long, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(long, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(long, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(long, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(long, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(long, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(long, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(long, ReadyState, nReadyState, DISPID_READYSTATE)
};

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif // __ATLCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _INC_MALLOC
#include <malloc.h>
#endif // _INC_MALLOC

#pragma pack(push,8)

namespace ATL
{
namespace _ATL_SAFE_ALLOCA_IMPL
{
// Following code is to avoid alloca causing a stack overflow.
// It is intended for use from the _ATL_SAFE_ALLOCA macros 
// or Conversion macros.
__declspec(selectany) DWORD _Atlosplatform = 0;
inline BOOL _AtlGetVersionEx()
{
	OSVERSIONINFO osi;
	memset(&osi, 0, sizeof(OSVERSIONINFO));
	osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osi);
	_Atlosplatform = osi.dwPlatformId;
	return TRUE;
}

// From VC7 CRT sources.
#define _ATL_MIN_STACK_REQ_WIN9X 0x11000
#define _ATL_MIN_STACK_REQ_WINNT 0x2000

/***
* void _resetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
* Exit:
*       Returns nonzero on success, zero on failure
*
*******************************************************************************/

inline int _Atlresetstkoflw(void)
{
	static BOOL bTemp = _AtlGetVersionEx();
	
    LPBYTE pStack, pGuard, pStackBase, pMaxGuard, pMinGuard;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;
    DWORD flNewProtect;
    DWORD flOldProtect;

    // Use _alloca() to get the current stack pointer

    pStack = (LPBYTE)_alloca(1);

    // Find the base of the stack.

    if (VirtualQuery(pStack, &mbi, sizeof mbi) == 0)
        return 0;
    pStackBase = (LPBYTE)mbi.AllocationBase;

    // Find the page just below where the stack pointer currently points.
    // This is the highest potential guard page.

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    pMaxGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize - 1))
                       - PageSize);

    // If the potential guard page is too close to the start of the stack
    // region, abandon the reset effort for lack of space.  Win9x has a
    // larger reserved stack requirement.

    pMinGuard = pStackBase + ((_Atlosplatform == VER_PLATFORM_WIN32_WINDOWS)
                              ? _ATL_MIN_STACK_REQ_WIN9X
                              : _ATL_MIN_STACK_REQ_WINNT);

    if (pMaxGuard < pMinGuard)
        return 0;

    // On a non-Win9x system, do nothing if a guard page is already present,
    // else set up the guard page to the bottom of the committed range.
    // For Win9x, just set guard page below the current stack page.

    if (_Atlosplatform != VER_PLATFORM_WIN32_WINDOWS) {

        // Find first block of committed memory in the stack region

        pGuard = pStackBase;
        do {
            if (VirtualQuery(pGuard, &mbi, sizeof mbi) == 0)
                return 0;
            pGuard = pGuard + mbi.RegionSize;
        } while ((mbi.State & MEM_COMMIT) == 0);
        pGuard = (LPBYTE)mbi.BaseAddress;

        // If first committed block is already marked as a guard page,
        // there is nothing that needs to be done, so return success.

        if (mbi.Protect & PAGE_GUARD)
            return 1;

        // Fail if the first committed block is above the highest potential
        // guard page.  Should never happen.

        if (pMaxGuard < pGuard)
            return 0;

        VirtualAlloc(pGuard, PageSize, MEM_COMMIT, PAGE_READWRITE);
    }
    else {
        pGuard = pMaxGuard;
    }

    // Enable the new guard page.

    flNewProtect = _Atlosplatform == VER_PLATFORM_WIN32_WINDOWS
                   ? PAGE_NOACCESS
                   : PAGE_READWRITE | PAGE_GUARD;

    return VirtualProtect(pGuard, PageSize, flNewProtect, &flOldProtect);
}

// Verifies if sufficient space is available on the stack.
inline bool _AtlVerifyStackAvailable(SIZE_T Size)
{
    bool bStackAvailable = true;

    __try
    {
        PVOID p = _alloca(Size);
        p;
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        bStackAvailable = false;
        _Atlresetstkoflw();
    }
    return bStackAvailable;
}

// Helper Classes to manage heap buffers for _ATL_SAFE_ALLOCA

// Default allocator used by ATL
class _CCRTAllocator
{
public :
	static void * Allocate(SIZE_T nRequestedSize)
	{
		return malloc(nRequestedSize);
	}
	static void Free(void* p)
	{
		free(p);
	}
};

template < class Allocator>
class CAtlSafeAllocBufferManager
{
private :
	struct CAtlSafeAllocBufferNode
	{
		CAtlSafeAllocBufferNode* m_pNext;
		void* GetData()
		{
			return (this + 1);
		}
	};

	CAtlSafeAllocBufferNode* m_pHead;
public :
	
	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};
	void* Allocate(SIZE_T nRequestedSize)
	{
		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));
		if (p == NULL)
			return NULL;
		
		// Add buffer to the list
		p->m_pNext = m_pHead;
		m_pHead = p;
		
		return p->GetData();
	}
	~CAtlSafeAllocBufferManager()
	{
		// Walk the list and free the buffers
		while (m_pHead != NULL)
		{
			CAtlSafeAllocBufferNode* p = m_pHead;
			m_pHead = m_pHead->m_pNext;
			Allocator::Free(p);
		}
	}
};

// Use one of the following macros before using _ATL_SAFE_ALLOCA
// EX version allows specifying a different heap allocator
#define USES_ATL_SAFE_ALLOCA_EX(x)	ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<x> _AtlSafeAllocaManager

#ifndef USES_ATL_SAFE_ALLOCA
#define USES_ATL_SAFE_ALLOCA		USES_ATL_SAFE_ALLOCA_EX(ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator)
#endif

// nRequestedSize - requested size in bytes 
// nThreshold - size in bytes beyond which memory is allocated from the heap.

// Defining _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE always allocates the size specified
// for threshold if the stack space is available irrespective of requested size.
// This available for testing purposes. It will help determine the max stack usage due to _alloca's

#ifdef _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
	(((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold) ) ?	\
		_alloca(nThreshold) :	\
		((ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold)) ? _alloca(nThreshold) : 0),	\
			_AtlSafeAllocaManager.Allocate(nRequestedSize))
#else
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
	(((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nRequestedSize) ) ?	\
		_alloca(nRequestedSize) :	\
		_AtlSafeAllocaManager.Allocate(nRequestedSize))
#endif

// Use 1024 bytes as the default threshold in ATL
#ifndef _ATL_SAFE_ALLOCA_DEF_THRESHOLD
#define _ATL_SAFE_ALLOCA_DEF_THRESHOLD	1024
#endif

}	// namespace _ATL_SAFE_ALLOCA_IMPL

}	// namespace ATL

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0
#endif

#endif // _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
	#define USES_CONVERSION_EX int _convert_ex; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex; _lpw_ex; LPCSTR _lpa_ex; _lpa_ex; USES_ATL_SAFE_ALLOCA
#else
	#define USES_CONVERSION_EX int _convert_ex = 0; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex = NULL; _lpw_ex; LPCSTR _lpa_ex = NULL; _lpa_ex; USES_ATL_SAFE_ALLOCA
#endif


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);

#ifndef ATLA2WHELPER
#define ATLA2WHELPER AtlA2WHelper
#define ATLW2AHELPER AtlW2AHelper
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		ATLA2WHELPER((LPWSTR) alloca(_convert*2), (LPCSTR)lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*2,\
		ATLW2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))

#endif // _ATL_EX_CONVERSION_MACROS_ONLY

// The call to _alloca will not cause stack overflow if _AtlVerifyStackAvailable returns TRUE.
#define A2W_EX(lpa, nThreshold) (\
	((_lpa_ex = lpa) == NULL) ? NULL : (\
		_convert_ex = (lstrlenA(_lpa_ex)+1),\
		ATLA2WHELPER(	\
			(LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex * sizeof(WCHAR), nThreshold), \
			_lpa_ex, \
			_convert_ex)))

#define W2A_EX(lpw, nThreshold) (\
	((_lpw_ex = lpw) == NULL) ? NULL : (\
		_convert_ex = (lstrlenW(_lpw_ex)+1) * sizeof(WCHAR),\
		ATLW2AHELPER(	\
			(LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, nThreshold), \
			_lpw_ex, \
			_convert_ex)))
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW_EX(lpa, nChar) ((LPCWSTR)A2W_EX(lpa, nChar))
#define W2CA_EX(lpw, nChar) ((LPCSTR)W2A_EX(lpw, nChar))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); }

	inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
	inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
	inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
	inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }	

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY	

#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline int ocslen(LPCOLESTR x) { return lstrlen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); }

	inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
	inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
	inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
	inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#else
	inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src)
	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
	//CharNextW doesn't work on Win95 so we use this

	#define T2COLE_EX(lpa, nChar) A2CW_EX(lpa, nChar)
	#define T2OLE_EX(lpa, nChar) A2W_EX(lpa, nChar)
	#define OLE2CT_EX(lpo, nChar) W2CA_EX(lpo, nChar)
	#define OLE2T_EX(lpo, nChar) W2A_EX(lpo, nChar)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#endif

#ifdef OLE2ANSI
	inline LPOLESTR A2OLE_EX(LPSTR lp, UINT) { return lp;}
	inline LPSTR OLE2A_EX(LPOLESTR lp, UINT) { return lp;}
	#define W2OLE_EX W2A_EX
	#define OLE2W_EX A2W_EX
	inline LPCOLESTR A2COLE_EX(LPCSTR lp, UINT) { return lp;}
	inline LPCSTR OLE2CA_EX(LPCOLESTR lp, UINT) { return lp;}
	#define W2COLE_EX W2CA_EX
	#define OLE2CW_EX A2CW_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
	inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
	#define W2OLE W2A
	#define OLE2W A2W
	inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
	inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
	#define W2COLE W2CA
	#define OLE2CW A2CW
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#else
	inline LPOLESTR W2OLE_EX(LPWSTR lp, UINT) { return lp; }
	inline LPWSTR OLE2W_EX(LPOLESTR lp, UINT) { return lp; }
	#define A2OLE_EX A2W_EX
	#define OLE2A_EX W2A_EX
	inline LPCOLESTR W2COLE_EX(LPCWSTR lp, UINT) { return lp; }
	inline LPCWSTR OLE2CW_EX(LPCOLESTR lp, UINT) { return lp; }
	#define A2COLE_EX A2CW_EX
	#define OLE2CA_EX W2CA_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY
	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
#endif // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#ifdef _UNICODE

	#define T2A_EX W2A_EX
	#define A2T_EX A2W_EX
	inline LPWSTR T2W_EX(LPTSTR lp, UINT) { return lp; }
	inline LPTSTR W2T_EX(LPWSTR lp, UINT) { return lp; }
	#define T2CA_EX W2CA_EX
	#define A2CT_EX A2CW_EX
	inline LPCWSTR T2CW_EX(LPCTSTR lp, UINT) { return lp; }
	inline LPCTSTR W2CT_EX(LPCWSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY	

#else
	#define T2W_EX A2W_EX
	#define W2T_EX W2A_EX
	inline LPSTR T2A_EX(LPTSTR lp, UINT) { return lp; }
	inline LPTSTR A2T_EX(LPSTR lp, UINT) { return lp; }
	#define T2CW_EX A2CW_EX
	#define W2CT_EX W2CA_EX
	inline LPCSTR T2CA_EX(LPCTSTR lp, UINT) { return lp; }
	inline LPCTSTR A2CT_EX(LPCSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#endif

inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
	if (lp == NULL || nLen == 0)
		return NULL;
	USES_CONVERSION_EX;
	BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
		nLen, NULL, NULL);
	int nAllocLen = nConvertedLen;
	if (nLen == -1)
		nAllocLen -= 1;  // Don't allocate terminating '\0'
	str = ::SysAllocStringLen(NULL, nAllocLen);
	if (str != NULL)
	{
		int nResult;
		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);
		if(nResult != nConvertedLen)
		{
			SysFreeString(str);
			return NULL;
		}
	}
	return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR

	inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
	inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
	inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR

	inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR_EX(LPCSTR lp) {return ::SysAllocString(lp);}
	inline BSTR W2BSTR_EX(LPCWSTR lp) {USES_CONVERSION_EX; return ::SysAllocString(W2COLE_EX(lp));}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
	inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
	inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));}
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#else

	inline BSTR T2BSTR_EX(LPCTSTR lp) {return A2WBSTR(lp);}
	inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY	
	inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
	inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
	inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }
#endif // _ATL_EX_CONVERSION_MACROS_ONLY		

#endif

#if defined(_WINGDI_) && !defined(NOGDI)
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA);
LPDEVMODEA AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW);
LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA pltmA);
LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW pltmW);

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

// Requires USES_CONVERSION_EX or USES_ATL_SAFE_ALLOCA macro before using the _EX versions of the macros
#define DEVMODEW2A_EX(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)_ATL_SAFE_ALLOCA(sizeof(DEVMODEA)+lpw->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpw))
#define DEVMODEA2W_EX(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)_ATL_SAFE_ALLOCA(sizeof(DEVMODEW)+lpa->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpa))
#define TEXTMETRICW2A_EX(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICA), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptmw))
#define TEXTMETRICA2W_EX(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICW), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptma))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEW2A(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef OLE2ANSI
	#define DEVMODEOLE DEVMODEA
	#define LPDEVMODEOLE LPDEVMODEA
	#define TEXTMETRICOLE TEXTMETRICA
	#define LPTEXTMETRICOLE LPTEXTMETRICA
#else
	#define DEVMODEOLE DEVMODEW
	#define LPDEVMODEOLE LPDEVMODEW
	#define TEXTMETRICOLE TEXTMETRICW
	#define LPTEXTMETRICOLE LPTEXTMETRICW
#endif

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPDEVMODEW DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRICW lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY
	
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPDEVMODE DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODE lp) { return lp; }
	inline LPTEXTMETRIC TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRIC lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; }
	inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; }
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#else
	#define DEVMODEOLE2T_EX(lpo) DEVMODEW2A_EX(lpo)
	#define DEVMODET2OLE_EX(lpa) DEVMODEA2W_EX(lpa)
	#define TEXTMETRICOLE2T_EX(lptmw) TEXTMETRICW2A_EX(lptmw)
	#define TEXTMETRICT2OLE_EX(lptma) TEXTMETRICA2W_EX(lptma)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
	#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
	#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
	#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#endif //_WINGDI_

#else //!USES_CONVERSION

// if USES_CONVERSION already defined (i.e. MFC_VER < 4.21 )
// flip this switch to avoid atlconv.cpp
#define _ATL_NO_CONVERSIONS

#endif //!USES_CONVERSION

// Define these even if MFC already included
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
#else
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);}
#endif

#pragma pack(pop)

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlframe.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLFRAME_H__
#define __ATLFRAME_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLWIN_H__
	#error atlframe.h requires atlwin.h to be included first
#endif

#if (_ATL_VER < 0x0300)
#ifndef __ATLWIN21_H__
	#error atlframe.h requires atlwin21.h to be included first when used with ATL 2.0/2.1
#endif
#endif //(_ATL_VER < 0x0300)

#include <commctrl.h>
#include <atlres.h>

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CWindow, class TWinTraits = CFrameWinTraits> class CFrameWindowImpl;
#ifndef UNDER_CE
class CMDIWindow;
template <class T, class TBase = CMDIWindow, class TWinTraits = CFrameWinTraits> class CMDIFrameWindowImpl;
template <class T, class TBase = CMDIWindow, class TWinTraits = CMDIChildWinTraits> class CMDIChildWindowImpl;
#endif //!UNDER_CE
template <class T> class COwnerDraw;
class CUpdateUIBase;
template <class T> class CUpdateUI;

/////////////////////////////////////////////////////////////////////////////
// CFrameWndClassInfo - Manages frame window Windows class information

class CFrameWndClassInfo
{
public:
#ifndef UNDER_CE
	WNDCLASSEX m_wc;
#else // CE specific
	WNDCLASS m_wc;
#endif //!UNDER_CE
	LPCTSTR m_lpszOrigName;
	WNDPROC pWndProc;
#ifndef UNDER_CE
	LPCTSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
#endif //!UNDER_CE
	ATOM m_atom;
    TCHAR m_szAutoName[sizeof("ATL:") + (sizeof(PVOID)*2)+1];
	UINT m_uCommonResourceID;

	ATOM Register(WNDPROC* pProc)
	{
		if (m_atom == 0)
		{
			::EnterCriticalSection(&_Module.m_csWindowCreate);
			if(m_atom == 0)
			{
				HINSTANCE hInst = _Module.GetModuleInstance();
				if (m_lpszOrigName != NULL)
				{
					ATLASSERT(pProc != NULL);
					LPCTSTR lpsz = m_wc.lpszClassName;
					WNDPROC proc = m_wc.lpfnWndProc;

#ifndef UNDER_CE
					WNDCLASSEX wc;
					wc.cbSize = sizeof(WNDCLASSEX);
					if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
#else // CE specific
					WNDCLASS wc;
					if(!::GetClassInfo(NULL, m_lpszOrigName, &wc))
#endif //!UNDER_CE
					{
						::LeaveCriticalSection(&_Module.m_csWindowCreate);
						return 0;
					}
#ifndef UNDER_CE
					memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
#else // CE specific
					memcpy(&m_wc, &wc, sizeof(WNDCLASS));
#endif //!UNDER_CE
					pWndProc = m_wc.lpfnWndProc;
					m_wc.lpszClassName = lpsz;
					m_wc.lpfnWndProc = proc;
				}
				else
				{
#ifndef UNDER_CE
					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
						m_lpszCursorID);
#else // CE specific
					m_wc.hCursor = NULL;
#endif //!UNDER_CE
				}

				m_wc.hInstance = hInst;
				m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
				if (m_wc.lpszClassName == NULL)
				{
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
				    wsprintf(m_szAutoName, _T("ATL:%p"), &m_wc);
#else
   				    wsprintf(m_szAutoName, _T("ATL:%8.8X"), PtrToUlong(&m_wc));
#endif
					m_wc.lpszClassName = m_szAutoName;
				}
#ifndef UNDER_CE
				WNDCLASSEX wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
				m_atom = (ATOM)::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
#else // CE specific
				WNDCLASS wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASS));
				m_atom = (ATOM)::GetClassInfo(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
#endif //!UNDER_CE

				if (m_atom == 0)
				{
					if(m_uCommonResourceID != 0)	// use it if not zero
					{
						m_wc.hIcon = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
#ifndef UNDER_CE
						m_wc.hIconSm = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
#endif //!UNDER_CE
					}
#ifndef UNDER_CE
					m_atom = ::RegisterClassEx(&m_wc);
#else // CE specific
					m_atom = ::RegisterClass(&m_wc);
#endif //!UNDER_CE
				}
			}
			::LeaveCriticalSection(&_Module.m_csWindowCreate);
		}

		if (m_lpszOrigName != NULL)
		{
			ATLASSERT(pProc != NULL);
			ATLASSERT(pWndProc != NULL);
			*pProc = pWndProc;
		}
		return m_atom;
	}
};

#ifndef UNDER_CE
#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}
#else // CE specific
#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName }, \
		NULL, NULL, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName }, \
		NULL, NULL, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ NULL, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName }, \
		OrigWndClassName, NULL, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}
#endif //!UNDER_CE

// Command Chaining Macros

#define CHAIN_COMMANDS(theChainClass) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_MEMBER(theChainMember) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT(theChainClass, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}


// Client window command chaining macro
#define CHAIN_CLIENT_COMMANDS() \
	if(uMsg == WM_COMMAND && m_hWndClient != NULL) \
		::SendMessage(m_hWndClient, uMsg, wParam, lParam);

/////////////////////////////////////////////////////////////////////////////
// CFrameWindowImpl

template <class TBase = CWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CFrameWindowImplBase : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	HWND m_hWndToolBar;
	HWND m_hWndStatusBar;
	HWND m_hWndClient;

	HACCEL m_hAccel;

	CFrameWindowImplBase() : m_hWndToolBar(NULL), m_hWndStatusBar(NULL), m_hWndClient(NULL), m_hAccel(NULL)
	{
	}

	DECLARE_FRAME_WND_CLASS(NULL, 0)

	struct _AtlToolBarData
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;
		//WORD aItems[wItemCount]

		WORD* items()
			{ return (WORD*)(this+1); }
	};

	static HWND CreateSimpleToolBarCtrl(HWND hWndParent, UINT nResourceID,
			BOOL bInitialSeparator = FALSE,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS,
			UINT nID = ATL_IDW_TOOLBAR)
	{
		HINSTANCE hInst = _Module.GetResourceInstance();
		HRSRC hRsrc = ::FindResource(hInst, MAKEINTRESOURCE(nResourceID), RT_TOOLBAR);
		if (hRsrc == NULL)
			return NULL;

		HGLOBAL hGlobal = ::LoadResource(hInst, hRsrc);
		if (hGlobal == NULL)
			return NULL;

		_AtlToolBarData* pData = (_AtlToolBarData*)::LockResource(hGlobal);
		if (pData == NULL)
			return NULL;
		ATLASSERT(pData->wVersion == 1);

		WORD* pItems = pData->items();
		int nItems = pData->wItemCount + (bInitialSeparator ? 1 : 0);
		TBBUTTON* pTBBtn = (TBBUTTON*)_alloca(nItems * sizeof(TBBUTTON));

		// set initial separator (half width)
		if(bInitialSeparator)
		{
			pTBBtn[0].iBitmap = 4;
			pTBBtn[0].idCommand = 0;
			pTBBtn[0].fsState = 0;
			pTBBtn[0].fsStyle = TBSTYLE_SEP;
			pTBBtn[0].dwData = 0;
			pTBBtn[0].iString = 0;
		}

		int nBmp = 0;
		for(int i = 0, j = bInitialSeparator ? 1 : 0; i < pData->wItemCount; i++, j++)
		{
			if(pItems[i] != 0)
			{
				pTBBtn[j].iBitmap = nBmp++;
				pTBBtn[j].idCommand = pItems[i];
				pTBBtn[j].fsState = TBSTATE_ENABLED;
				pTBBtn[j].fsStyle = TBSTYLE_BUTTON;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
			else
			{
				pTBBtn[j].iBitmap = 8;
				pTBBtn[j].idCommand = 0;
				pTBBtn[j].fsState = 0;
				pTBBtn[j].fsStyle = TBSTYLE_SEP;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
		}

		HWND hWnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0,0,100,100,
				hWndParent, (HMENU)nID, _Module.GetModuleInstance(), NULL);

		::SendMessage(hWnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L);

		TBADDBITMAP tbab;
		tbab.hInst = hInst;
		tbab.nID = nResourceID;
		::SendMessage(hWnd, TB_ADDBITMAP, nBmp, (LPARAM)&tbab);
		::SendMessage(hWnd, TB_ADDBUTTONS, nItems, (LPARAM)pTBBtn);
		::SendMessage(hWnd, TB_SETBITMAPSIZE, 0, MAKELONG(pData->wWidth, pData->wHeight));
		::SendMessage(hWnd, TB_SETBUTTONSIZE, 0, MAKELONG(pData->wWidth + 7, pData->wHeight + 7));

		return hWnd;
	}

	BOOL CreateSimpleStatusBar(LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		ATLASSERT(!::IsWindow(m_hWndStatusBar));
		m_hWndStatusBar = ::CreateStatusWindow(dwStyle, lpstrText, m_hWnd, nID);
		return (m_hWndStatusBar != NULL);
	}

	BOOL CreateSimpleStatusBar(UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		TCHAR szText[128];	// max text lentgth is 127 for status bars
		szText[0] = 0;
		::LoadString(_Module.GetResourceInstance(), nTextID, szText, 127);
		return CreateSimpleStatusBar(szText, dwStyle, nID);
	}

	void UpdateLayout()
	{
		RECT rect;
		GetClientRect(&rect);

		// resize toolbar
		if(m_hWndToolBar != NULL && ((DWORD)::GetWindowLong(m_hWndToolBar, GWL_STYLE) & WS_VISIBLE))
		{
			::SendMessage(m_hWndToolBar, WM_SIZE, 0, 0);
			RECT rectTB;
			::GetWindowRect(m_hWndToolBar, &rectTB);
			rect.top += rectTB.bottom - rectTB.top;
		}

		// resize status bar
		if(m_hWndToolBar != NULL && ((DWORD)::GetWindowLong(m_hWndStatusBar, GWL_STYLE) & WS_VISIBLE))
		{
			::SendMessage(m_hWndStatusBar, WM_SIZE, 0, 0);
			RECT rectSB;
			::GetWindowRect(m_hWndStatusBar, &rectSB);
			rect.bottom -= rectSB.bottom - rectSB.top;
		}

		// resize client window
		if(m_hWndClient != NULL)
			::SetWindowPos(m_hWndClient, NULL, rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,
				SWP_NOZORDER | SWP_NOACTIVATE);
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(m_hAccel != NULL && ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg))
			return TRUE;
		return FALSE;
	}

	typedef CFrameWindowImplBase< TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
#ifndef UNDER_CE
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
#endif //!UNDER_CE
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		NOTIFY_CODE_HANDLER(TTN_NEEDTEXT, OnToolTipText)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam != SIZE_MINIMIZED)
			UpdateLayout();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_hWndClient != NULL)	// view will paint itself instead
			return 1;

		bHandled = FALSE;
		return 0;
	}

#ifndef UNDER_CE
	LRESULT OnMenuSelect(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		bHandled = FALSE;

		if(m_hWndStatusBar == NULL)
			return 1;

		WORD wFlags = HIWORD(wParam);
		if(wFlags == 0xFFFF && lParam == NULL)	// menu closing
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, FALSE, 0L);
		else
		{
			TCHAR szBuff[256];
			szBuff[0] = 0;
			if(!(wFlags & MF_POPUP))
			{
				WORD wID = LOWORD(wParam);
				// check for special cases
				if(wID >= 0xF000 && wID < 0xF1F0)				// system menu IDs
					wID = (WORD)(((wID - 0xF000) >> 4) + ATL_IDS_SCFIRST);
				else if(wID >= ID_FILE_MRU_FIRST && wID <= ID_FILE_MRU_LAST)	// MRU items
					wID = ATL_IDS_MRU_FILE;
				else if(wID >= ATL_IDM_FIRST_MDICHILD)				// MDI child windows
					wID = ATL_IDS_MDICHILD;

				if(::LoadString(_Module.GetResourceInstance(), wID, szBuff, 255))
				{
					for(int i = 0; szBuff[i] != 0 && i < 256; i++)
					{
						if(szBuff[i] == _T('\n'))
						{
							szBuff[i] = 0;
							break;
						}
					}
				}
			}
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
			::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM)szBuff);
		}

		return 1;
	}
#endif //!UNDER_CE

	LRESULT OnSetFocus(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if(m_hWndClient != NULL && ::IsWindowVisible(m_hWndClient))
			::SetFocus(m_hWndClient);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if(!(GetStyle() & (WS_CHILD | WS_POPUP)))
			::PostQuitMessage(1);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnToolTipText(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		TOOLTIPTEXT* pTTT = (TOOLTIPTEXT*)pnmh;
		pTTT->szText[0] = 0;

		if((idCtrl != 0) && !(pTTT->uFlags & TTF_IDISHWND))
		{
			TCHAR szBuff[256];
			szBuff[0] = 0;
			if(::LoadString(_Module.GetResourceInstance(), idCtrl, szBuff, 255))
			{
				for(int i = 0; szBuff[i] != 0 && i < 256; i++)
				{
					if(szBuff[i] == _T('\n'))
					{
						lstrcpyn(pTTT->szText, &szBuff[i+1], sizeof(pTTT->szText)/sizeof(pTTT->szText[0]));
						break;
					}
				}
			}
		}

		return 0;
	}
};

template <class T, class TBase = CWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CFrameWindowImpl : public CFrameWindowImplBase< TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, RECT& Rect = CWindow::rcDefault, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, &Rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
	}
	HWND Create(HWND hWndParent = NULL, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
		static RECT rect = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
		if(lpRect == NULL)
			lpRect = &rect;

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, *lpRect, szWindowName,
			dwStyle, dwExStyle, (UINT)hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, LPRECT lpRect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 255);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMDIWindow

#ifndef UNDER_CE

class CMDIWindow : public CWindow
{
public:
	HWND m_hWndMDIClient;
	HMENU m_hMenu;

// Constructors
	CMDIWindow(HWND hWnd = NULL) : CWindow(hWnd), m_hWndMDIClient(NULL), m_hMenu(NULL) { }

	CMDIWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations
	HWND MDIGetActive(BOOL* lpbMaximized = NULL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HWND)::SendMessage(m_hWndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)lpbMaximized);
	}

	void MDIActivate(HWND hWndChildToActivate)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToActivate));
		::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChildToActivate, 0);
	}

	void MDINext(HWND hWndChild, BOOL bPrevious = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(hWndChild == NULL || ::IsWindow(hWndChild));
		::SendMessage(m_hWndMDIClient, WM_MDINEXT, (WPARAM)hWndChild, (LPARAM)bPrevious);
	}

	void MDIMaximize(HWND hWndChildToMaximize)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToMaximize));
		::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hWndChildToMaximize, 0);
	}

	void MDIRestore(HWND hWndChildToRestore)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToRestore));
		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, (WPARAM)hWndChildToRestore, 0);
	}

	void MDIDestroy(HWND hWndChildToDestroy)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToDestroy));
		::SendMessage(m_hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChildToDestroy, 0);
	}

	BOOL MDICascade(UINT uFlags = 0)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDICASCADE, (WPARAM)uFlags, 0);
	}

	BOOL MDITile(UINT uFlags = MDITILE_HORIZONTAL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDITILE, (WPARAM)uFlags, 0);
	}
	void MDIIconArrange()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0);
	}

	HMENU MDISetMenu(HMENU hMenuFrame, HMENU hMenuWindow)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDISETMENU, (WPARAM)hMenuFrame, (LPARAM)hMenuWindow);
	}

	HMENU MDIRefreshMenu()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}

// Additional operations
	static HMENU GetStandardWindowMenu(HMENU hMenu)
	{
		int nCount = ::GetMenuItemCount(hMenu);
		if(nCount == -1)
			return NULL;
		int nLen = ::GetMenuString(hMenu, nCount - 2, NULL, 0, MF_BYPOSITION);
		if(nLen == 0)
			return NULL;
		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
		if(::GetMenuString(hMenu, nCount - 2, lpszText, nLen + 1, MF_BYPOSITION) != nLen)
			return NULL;
		if(lstrcmp(lpszText, _T("&Window")))
			return NULL;
		return ::GetSubMenu(hMenu, nCount - 2);
	}

	void SetMDIFrameMenu()
	{
		HMENU hWindowMenu = GetStandardWindowMenu(m_hMenu);
		MDISetMenu(m_hMenu, hWindowMenu);
		MDIRefreshMenu();
		::DrawMenuBar(GetMDIFrame());
	}

	HWND GetMDIFrame()
	{
		return ::GetParent(m_hWndMDIClient);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWindowImpl

// MDI child command chaining macro
#define CHAIN_MDI_CHILD_COMMANDS() \
	if(uMsg == WM_COMMAND) \
	{ \
		HWND hWndChild = MDIGetActive(); \
		if(hWndChild != NULL) \
			::SendMessage(hWndChild, uMsg, wParam, lParam); \
	}


template <class T, class TBase = CMDIWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CMDIFrameWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		m_hMenu = hMenu;
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
		static RECT rect = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
		if(lpRect == NULL)
			lpRect = &rect;

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		return CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, *lpRect, szWindowName, dwStyle, dwExStyle,
			(UINT)hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, LPRECT lpRect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 255);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	virtual WNDPROC GetWindowProc()
	{
		return MDIFrameWindowProc;
	}

	static LRESULT CALLBACK MDIFrameWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CMDIFrameWindowImpl< T, TBase, TWinTraits >* pThis = (CMDIFrameWindowImpl< T, TBase, TWinTraits >*)hWnd;
#if (_ATL_VER >= 0x0300)
		// set a ptr to this message and save the old value
		MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
		const MSG* pOldMsg = pThis->m_pCurrentMsg;
		pThis->m_pCurrentMsg = &msg;
#endif //(_ATL_VER >= 0x0300)
		// pass to the message map to process
		LRESULT lRes;
		BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
#if (_ATL_VER >= 0x0300)
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
#endif //(_ATL_VER >= 0x0300)
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
				// clear out window handle
				HWND hWnd = pThis->m_hWnd;
				pThis->m_hWnd = NULL;
				// clean up after window is destroyed
				pThis->OnFinalMessage(hWnd);
			}
		}
		return lRes;
	}

#if (_ATL_VER >= 0x0300)
	// Overriden to call DefWindowProc which uses DefFrameProc
	LRESULT DefWindowProc()
	{
		const MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}
#endif //(_ATL_VER >= 0x0300)

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		return ::DefFrameProc(m_hWnd, m_hWndClient, uMsg, wParam, lParam);
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(CFrameWindowImplBase<TBase, TWinTraits>::PreTranslateMessage(pMsg))
			return TRUE;
		return ::TranslateMDISysAccel(m_hWndClient, pMsg);
	}

	HWND CreateMDIClient(HMENU hWindowMenu = NULL, UINT nID = ATL_IDW_CLIENT, UINT nFirstChildID = ATL_IDM_FIRST_MDICHILD)
	{
		DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MDIS_ALLCHILDSTYLES;
		DWORD dwExStyle = WS_EX_CLIENTEDGE;

		CLIENTCREATESTRUCT ccs;
		ccs.hWindowMenu = hWindowMenu;
		ccs.idFirstChild = nFirstChildID;

		if(GetStyle() & (WS_HSCROLL | WS_VSCROLL))
		{
			// parent MDI frame's scroll styles move to the MDICLIENT
			dwStyle |= (GetStyle() & (WS_HSCROLL | WS_VSCROLL));

			// fast way to turn off the scrollbar bits (without a resize)
			ModifyStyle(WS_HSCROLL | WS_VSCROLL, 0, SWP_NOREDRAW | SWP_FRAMECHANGED);
		}

		// Create MDICLIENT window
		m_hWndClient = ::CreateWindowEx(dwExStyle, _T("MDIClient"), NULL,
			dwStyle, 0, 0, 1, 1, m_hWnd, (HMENU)nID,
			_Module.GetModuleInstance(), (LPVOID)&ccs);
		if (m_hWndClient == NULL)
		{
			ATLTRACE2(atlTraceWindowing, 0, _T("MDI Frame failed to create MDICLIENT.\n"));
			return NULL;
		}

		// Move it to the top of z-order
		::BringWindowToTop(m_hWndClient);

		// set as MDI client window
		m_hWndMDIClient = m_hWndClient;

		// update to proper size
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout();

		return m_hWndClient;
	}

	typedef CMDIFrameWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		// message must be handled, otherwise DefFrameProc would resize the client again
		return 0;
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// don't allow CFrameWindowImplBase to handle this one
		return DefWindowProc(uMsg, wParam, lParam);
	}

	LRESULT OnMDISetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		SetMDIFrameMenu();
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMDIChildWindowImpl

template <class T, class TBase = CMDIWindow, class TWinTraits = CMDIChildWinTraits>
class ATL_NO_VTABLE CMDIChildWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nMenuID = 0, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		static RECT rect = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
		if(lpRect == NULL)
			lpRect = &rect;

		if(nMenuID != 0)
			m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nMenuID));

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		dwExStyle |= WS_EX_MDICHILD;	// force this one
		m_pfnSuperWindowProc = ::DefMDIChildProc;
		m_hWndMDIClient = hWndParent;
		ATLASSERT(::IsWindow(m_hWndMDIClient));

		HWND hWnd = CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, *lpRect, szWindowName, dwStyle, dwExStyle,
			0, atom, lpCreateParam);
		if(hWnd != NULL && ::IsWindowVisible(m_hWnd) && !::IsChild(hWnd, ::GetFocus()))
			::SetFocus(hWnd);
		return hWnd;
	}

	HWND CreateEx(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR lpcstrWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		if(lpcstrWindowName == NULL)
		{
			::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 255);
			lpcstrWindowName = szWindowName;
		}

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, lpRect, lpcstrWindowName, dwStyle, dwExStyle, T::GetWndClassInfo().m_uCommonResourceID, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	BOOL UpdateClientEdge(LPRECT lpRect = NULL)
	{
		// only adjust for active MDI child window
		HWND hWndChild = MDIGetActive();
		if(hWndChild != NULL && hWndChild != m_hWnd)
			return FALSE;

		// need to adjust the client edge style as max/restore happens
		DWORD dwStyle = ::GetWindowLong(m_hWndMDIClient, GWL_EXSTYLE);
		DWORD dwNewStyle = dwStyle;
		if(hWndChild != NULL && !(GetExStyle() & WS_EX_CLIENTEDGE) &&
				(GetStyle() & WS_MAXIMIZE))
			dwNewStyle &= ~(WS_EX_CLIENTEDGE);
		else
			dwNewStyle |= WS_EX_CLIENTEDGE;

		if(dwStyle != dwNewStyle)
		{
			// SetWindowPos will not move invalid bits
			::RedrawWindow(m_hWndMDIClient, NULL, NULL,
				RDW_INVALIDATE | RDW_ALLCHILDREN);
			// remove/add WS_EX_CLIENTEDGE to MDI client area
			::SetWindowLong(m_hWndMDIClient, GWL_EXSTYLE, dwNewStyle);
			::SetWindowPos(m_hWndMDIClient, NULL, 0, 0, 0, 0,
				SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE |
				SWP_NOZORDER | SWP_NOCOPYBITS);

			// return new client area
			if (lpRect != NULL)
				::GetClientRect(m_hWndMDIClient, lpRect);

			return TRUE;
		}

		return FALSE;
	}

	typedef CMDIChildWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(WM_MDIACTIVATE, OnMDIActivate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		DefWindowProc(uMsg, wParam, lParam);	// needed for MDI children

		CFrameWindowImplBase<TBase, TWinTraits >::OnSize(uMsg, wParam, lParam, bHandled);
		bHandled = TRUE;

		return 0;
	}

	LRESULT OnWindowPosChanging(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		// update MDI client edge and adjust MDI child rect
		LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;

		if(!(lpWndPos->flags & SWP_NOSIZE))
		{
			CWindow wnd(m_hWndMDIClient);
			RECT rectClient;

			if(UpdateClientEdge(&rectClient) && (GetStyle() & WS_MAXIMIZE))
			{
				::AdjustWindowRectEx(&rectClient, GetStyle(), FALSE, GetExStyle());
				lpWndPos->x = rectClient.left;
				lpWndPos->y = rectClient.top;
				lpWndPos->cx = rectClient.right - rectClient.left;
				lpWndPos->cy = rectClient.bottom - rectClient.top;
			}
		}

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		return ::SendMessage(GetMDIFrame(), uMsg, wParam, lParam);
	}

	LRESULT OnMDIActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if((HWND)lParam == m_hWnd && m_hMenu != NULL)
			SetMDIFrameMenu();
		else if((HWND)lParam == NULL)
			::SendMessage(GetMDIFrame(), WM_MDISETMENU, 0, 0);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		UpdateClientEdge();
		bHandled = FALSE;
		return 1;
	}
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// COwnerDraw - MI class for owner-draw support

template <class T>
class COwnerDraw
{
public:
	BEGIN_MSG_MAP(COwnerDraw< T >)
		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(WM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(WM_DELETEITEM, OnDeleteItem)
	ALT_MSG_MAP(1)
		MESSAGE_HANDLER(OCM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(OCM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(OCM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(OCM_DELETEITEM, OnDeleteItem)
	END_MSG_MAP()

// message handlers
	LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->DrawItem((LPDRAWITEMSTRUCT)lParam);
		return (LRESULT)TRUE;
	}
	LRESULT OnMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->MeasureItem((LPMEASUREITEMSTRUCT)lParam);
		return (LRESULT)TRUE;
	}
	LRESULT OnCompareItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		return (LRESULT)pT->CompareItem((LPCOMPAREITEMSTRUCT)lParam);
	}
	LRESULT OnDeleteItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->DeleteItem((LPDELETEITEMSTRUCT)lParam);
		return (LRESULT)TRUE;
	}

// overrideables
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
	{
		// must be implemented
		ATLASSERT(FALSE);
	}
	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
	{
		if(lpMeasureItemStruct->CtlType != ODT_MENU)
		{
			// return default height for a system font
			T* pT = static_cast<T*>(this);
			HWND hWnd = pT->GetDlgItem(lpMeasureItemStruct->CtlID);
			CClientDC dc(hWnd);
			TEXTMETRIC tm;
			dc.GetTextMetrics(&tm);

			lpMeasureItemStruct->itemHeight = tm.tmHeight;
		}
		else
			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU);
	}
	int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct)
	{
		// all items are equal
		return 0;
	}
	void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct)
	{
		// default - nothing
	}
};


/////////////////////////////////////////////////////////////////////////////
// Update UI structures and constants

// UI element type
#define UPDUI_MENUPOPUP	0x0001
#define UPDUI_MENUBAR	0x0002
#define UPDUI_CHILDWND	0x0004
#define UPDUI_TOOLBAR	0x0008
#define UPDUI_STATUSBAR	0x0010

// state
#define UPDUI_ENABLED	0x0000
#define UPDUI_DISABLED	0x0100
#define UPDUI_CHECKED	0x0200
#define UPDUI_CHECKED2	0x0400
#define UPDUI_RADIO	0x0800
#define UPDUI_DEFAULT	0x1000
#define UPDUI_TEXT	0x2000

// element data
struct _AtlUpdateUIElement
{
	HWND m_hWnd;
	WORD m_wType;
	BOOL operator ==(_AtlUpdateUIElement e)
	{
		if(m_hWnd == e.m_hWnd && m_wType == e.m_wType)
			return TRUE;
		return FALSE;
	}
};

// map data
struct _AtlUpdateUIMap
{
	WORD m_nID;
	WORD m_wType;
};

// instance data
struct _AtlUpdateUIData
{
	WORD m_wState;
	void* m_lpData;
};

// these should be inside the class definition
#define BEGIN_UPDATE_UI_MAP(thisClass) \
	static const _AtlUpdateUIMap* GetUpdateUIMap() \
	{ \
		static const _AtlUpdateUIMap theMap[] = \
		{

#define UPDATE_ELEMENT(nID, wType) \
			{ nID,  wType },

#define END_UPDATE_UI_MAP() \
			{ (WORD)-1, 0 } \
		}; \
		return theMap; \
	}

///////////////////////////////////////////////////////////////////////////////
// CUpdateUI - manages UI elements updating

class CUpdateUIBase
{
public:
	CSimpleArray<_AtlUpdateUIElement> m_UIElements;	// elements data
	const _AtlUpdateUIMap* m_pUIMap;		// static UI data
	_AtlUpdateUIData* m_pUIData;			// instance UI data
	WORD m_wDirtyType;				// global dirty flag

// Constructor, destructor
	CUpdateUIBase() : m_pUIMap(NULL), m_pUIData(NULL), m_wDirtyType(0)
	{ }

	~CUpdateUIBase()
	{
		if(m_pUIMap != NULL && m_pUIData != NULL)
		{
			const _AtlUpdateUIMap* pUIMap = m_pUIMap;
			_AtlUpdateUIData* pUIData = m_pUIData;
			while(pUIMap->m_nID != (WORD)-1)
			{
				if(pUIData->m_wState & UPDUI_TEXT)
					free(pUIData->m_lpData);
				pUIMap++;
				pUIData++;
			}
			delete [] m_pUIData;
		}
	}

// Add elements
	BOOL UIAddMenu(HWND hWnd)		// menu bar (main menu)
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_MENUBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddToolBar(HWND hWnd)		// toolbar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_TOOLBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddStatusBar(HWND hWnd)		// status bar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_STATUSBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddWindow(HWND hWnd)		// child window
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_CHILDWND;
		return m_UIElements.Add(e);
	}

// message map for popup menu updates
	BEGIN_MSG_MAP(CUpdateUIBase)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
	END_MSG_MAP()

	LRESULT OnInitMenuPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		HMENU hMenu = (HMENU)wParam;
		if(hMenu == NULL)
			return 1;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return 1;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		while(pMap->m_nID != (WORD)-1)
		{
			if(pMap->m_wType & UPDUI_MENUPOPUP)
				UIUpdateMenuElement(pMap->m_nID, pUIData, hMenu, FALSE);
			pMap++;
			pUIData++;
		}
		return 0;
	}

// methods for setting UI element state
	BOOL UIEnable(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE)
	{
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bEnable)
				{
					if(p->m_wState & UPDUI_DISABLED)
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState &= ~UPDUI_DISABLED;
					}
				}
				else
				{
					if(!(p->m_wState & UPDUI_DISABLED))
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState |= UPDUI_DISABLED;
					}
				}

				if(bForceUpdate)
					p->m_wState |= pMap->m_wType;
				if(p->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}

		return bRet;
	}

	BOOL UISetCheck(int nID, int nCheck, BOOL bForceUpdate = FALSE)
	{
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{
				switch(nCheck)
				{
				case 0:
					if((p->m_wState & UPDUI_CHECKED) || (p->m_wState & UPDUI_CHECKED2))
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState &= ~(UPDUI_CHECKED | UPDUI_CHECKED2);
					}
					break;
				case 1:
					if(!(p->m_wState & UPDUI_CHECKED))
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState &= ~UPDUI_CHECKED2;
						p->m_wState |= UPDUI_CHECKED;
					}
					break;
				case 2:
					if(!(p->m_wState & UPDUI_CHECKED2))
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState &= ~UPDUI_CHECKED;
						p->m_wState |= UPDUI_CHECKED2;
					}
					break;
				}

				if(bForceUpdate)
					p->m_wState |= pMap->m_wType;
				if(p->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}

		return bRet;
	}

	BOOL UISetRadio(int nID, BOOL bRadio, BOOL bForceUpdate = FALSE)
	{
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bRadio)
				{
					if(!(p->m_wState & UPDUI_RADIO))
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState |= UPDUI_RADIO;
					}
				}
				else
				{
					if(p->m_wState & UPDUI_RADIO)
					{
						p->m_wState |= pMap->m_wType;
						p->m_wState &= ~UPDUI_RADIO;
					}
				}

				if(bForceUpdate)
					p->m_wState |= pMap->m_wType;
				if(p->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}

		return bRet;
	}

	BOOL UISetText(int nID, LPCTSTR lpstrText, BOOL bForceUpdate = FALSE)
	{
		ATLASSERT(lpstrText != NULL);
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(p->m_lpData != NULL && lstrcmp((LPTSTR)p->m_lpData, lpstrText))
				{
					if(p->m_lpData != NULL)
						free(p->m_lpData);
					int nStrLen = lstrlen(lpstrText);
					p->m_lpData = malloc(nStrLen + sizeof(TCHAR));
					if(p->m_lpData == NULL)
					{
						ATLTRACE2(atlTraceWindowing, 0, _T("SetText - malloc failed\n"));
						break;
					}
					lstrcpy((LPTSTR)p->m_lpData, lpstrText);
					p->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				}

				if(bForceUpdate)
					p->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				if(p->m_wState | pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}

		return bRet;
	}

// methods for complete state set/get
	BOOL UISetState(int nID, DWORD dwState)
	{
		BOOL bRet = FALSE;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
			{		
				p->m_wState |= dwState | pMap->m_wType;
				m_wDirtyType |= pMap->m_wType;
				bRet = TRUE;
				break;
			}
		}

		return bRet;
	}
	DWORD UIGetState(int nID)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* p = m_pUIData;
		for( ; pMap->m_nID != (WORD)-1; pMap++, p++)
		{
			if(nID == (int)pMap->m_nID)
				return p->m_wState;
		}

		return 0;
	}

// methods for updating UI
#ifndef UNDER_CE
//REVIEW
	BOOL UIUpdateMenu(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_MENUBAR) && !bForceUpdate)
			return TRUE;

		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		HMENU hMenu;
		for(int i = 0; i < m_UIElements.GetSize(); i++)
		{
			if(m_UIElements[i].m_wType == UPDUI_MENUBAR)
			{
				pMap = m_pUIMap;
				pUIData = m_pUIData;
				hMenu = ::GetMenu(m_UIElements[i].m_hWnd);
				if(hMenu == NULL)
					continue;
				while(pMap->m_nID != (WORD)-1)
				{
					if((pUIData->m_wState & UPDUI_MENUBAR) && (pMap->m_wType & UPDUI_MENUBAR))
						UIUpdateMenuElement(pMap->m_nID, pUIData, hMenu, TRUE);
					pMap++;
					pUIData++;
				}

//REVIEW			::DrawMenuBar(m_UIElements[i].m_hWnd);
			}
		}
		m_wDirtyType &= ~UPDUI_MENUBAR;
		return TRUE;
	}
#endif //!UNDER_CE

	BOOL UIUpdateToolBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_TOOLBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for(int i = 0; i < m_UIElements.GetSize(); i++)
		{
			if(m_UIElements[i].m_wType == UPDUI_TOOLBAR)
			{
				pMap = m_pUIMap;
				pUIData = m_pUIData;
				while(pMap->m_nID != (WORD)-1)
				{
					if((pUIData->m_wState & UPDUI_TOOLBAR) && (pMap->m_wType & UPDUI_TOOLBAR))
						UIUpdateToolBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
					pMap++;
					pUIData++;
				}
			}
		}

		m_wDirtyType &= ~UPDUI_TOOLBAR;
		return TRUE;
	}

	BOOL UIUpdateStatusBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_STATUSBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for(int i = 0; i < m_UIElements.GetSize(); i++)
		{
			if(m_UIElements[i].m_wType == UPDUI_STATUSBAR)
			{
				pMap = m_pUIMap;
				pUIData = m_pUIData;
				while(pMap->m_nID != (WORD)-1)
				{
					if((pUIData->m_wState & UPDUI_STATUSBAR) && (pMap->m_wType & UPDUI_STATUSBAR))
						UIUpdateStatusBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
					pMap++;
					pUIData++;
				}
			}
		}

		m_wDirtyType &= ~UPDUI_STATUSBAR;
		return TRUE;
	}

	BOOL UIUpdateChildWnd(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_CHILDWND) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for(int i = 0; i < m_UIElements.GetSize(); i++)
		{
			if(m_UIElements[i].m_wType == UPDUI_CHILDWND)
			{
				pMap = m_pUIMap;
				pUIData = m_pUIData;
				while(pMap->m_nID != (WORD)-1)
				{
					if((pUIData->m_wState & UPDUI_CHILDWND) && (pMap->m_wType & UPDUI_CHILDWND))
						UIUpdateChildWndElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
					pMap++;
					pUIData++;
				}
			}
		}

		m_wDirtyType &= ~UPDUI_CHILDWND;
		return TRUE;
	}

// internal element specific methods
#ifndef UNDER_CE
	static void UIUpdateMenuElement(int nID, _AtlUpdateUIData* pUIData, HMENU hMenu, BOOL bClearState)
	{
		MENUITEMINFO mii;
		memset(&mii, 0, sizeof(MENUITEMINFO));
		mii.cbSize = sizeof(MENUITEMINFO);
		mii.fMask = MIIM_STATE;
		mii.wID = nID;

		if(pUIData->m_wState & UPDUI_DISABLED)
			mii.fState |= MFS_DISABLED | MFS_GRAYED;
		else
			mii.fState |= MFS_ENABLED;

		if(pUIData->m_wState & UPDUI_CHECKED)
			mii.fState |= MFS_CHECKED;
		else
			mii.fState |= MFS_UNCHECKED;

		if(pUIData->m_wState & UPDUI_DEFAULT)
			mii.fState |= MFS_DEFAULT;

		if(pUIData->m_wState & UPDUI_TEXT)
		{
			mii.fMask |= MIIM_TYPE;
			mii.fType = MFT_STRING;
			mii.dwTypeData = (LPTSTR)pUIData->m_lpData;
		}

		::SetMenuItemInfo(hMenu, nID, FALSE, &mii);

		if(pUIData->m_wState & UPDUI_TEXT)
		{
			free(pUIData->m_lpData);
			pUIData->m_wState &= ~UPDUI_TEXT;
		}

		if(bClearState)
			pUIData->m_wState &= ~UPDUI_MENUBAR;
	}
#else // CE specific
	static void UIUpdateMenuElement(int nID, _AtlUpdateUIData* pUIData, HMENU hMenu, BOOL bClearState)
	{
		UINT uState = 0;

		if(pUIData->m_wState & UPDUI_DISABLED)
			uState = MF_GRAYED;
		else
			uState = MF_ENABLED;
		::EnableMenuItem(hMenu, nID, uState);

		if(pUIData->m_wState & UPDUI_CHECKED)
			uState = 1;
		else
			uState = 0;
		::CheckMenuItem(hMenu, nID, uState);

//CE		if(pUIData->m_wState & UPDUI_DEFAULT)
//CE			mii.fState |= MFS_DEFAULT;

		if(pUIData->m_wState & UPDUI_TEXT)
		{
			MENUITEMINFO mii;
			memset(&mii, 0, sizeof(MENUITEMINFO));
			mii.cbSize = sizeof(MENUITEMINFO);
			mii.fMask = MIIM_TYPE;
			mii.wID = nID;
			mii.fType = MFT_STRING;
			mii.dwTypeData = (LPTSTR)pUIData->m_lpData;
			::SetMenuItemInfo(hMenu, nID, FALSE, &mii);
			free(pUIData->m_lpData);
			pUIData->m_wState &= ~UPDUI_TEXT;
		}


		if(bClearState)
			pUIData->m_wState &= ~UPDUI_MENUBAR;
	}
#endif //!UNDER_CE

	static void UIUpdateToolBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndToolBar)
	{
//REVIEW: only handles enabled/disabled and checked state, and radio (press)
		::SendMessage(hWndToolBar, TB_ENABLEBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		::SendMessage(hWndToolBar, TB_CHECKBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_INDETERMINATE, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED2) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_PRESSBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_RADIO) ? TRUE : FALSE);

		pUIData->m_wState &= ~UPDUI_TOOLBAR;
	}

	static void UIUpdateStatusBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndStatusBar)
	{
		if(pUIData->m_wState | UPDUI_TEXT)
		{
			::SendMessage(hWndStatusBar, SB_SETTEXT, nID, (LPARAM)pUIData->m_lpData);
			free(pUIData->m_lpData);
			pUIData->m_wState &= ~UPDUI_TEXT;
		}

		pUIData->m_wState &= ~UPDUI_STATUSBAR;
	}

	static void UIUpdateChildWndElement(int nID, _AtlUpdateUIData* pUIData, HWND hWnd)
	{
		HWND hChild = ::GetDlgItem(hWnd, nID);

		::EnableWindow(hChild, (pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		// for check and radio, assume that window is a button
		int nCheck = BST_UNCHECKED;
		if(pUIData->m_wState & UPDUI_CHECKED || pUIData->m_wState & UPDUI_RADIO)
			nCheck = BST_CHECKED;
		else if(pUIData->m_wState & UPDUI_CHECKED2)
			nCheck = BST_INDETERMINATE;
		::SendMessage(hChild, BM_SETCHECK, nCheck, 0L);
		if(pUIData->m_wState & UPDUI_DEFAULT)
		{
			DWORD dwRet = ::SendMessage(hWnd, DM_GETDEFID, 0, 0L);
			if(HIWORD(dwRet) == DC_HASDEFID)
			{
				HWND hOldDef = ::GetDlgItem(hWnd, LOWORD(dwRet));
				// remove BS_DEFPUSHBUTTON
				::SendMessage(hOldDef, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
			}
			::SendMessage(hWnd, DM_SETDEFID, nID, 0L);
		}
		if(pUIData->m_wState & UPDUI_TEXT)
		{
			::SetWindowText(hChild, (LPTSTR)pUIData->m_lpData);
			free(pUIData->m_lpData);
			pUIData->m_wState &= ~UPDUI_TEXT;
		}

		pUIData->m_wState &= ~UPDUI_CHILDWND;
	}
};

template <class T>
class CUpdateUI : public CUpdateUIBase
{
public:
	CUpdateUI()
	{
		T* pT = static_cast<T*>(this);
		pT;
		const _AtlUpdateUIMap* pMap = pT->GetUpdateUIMap();
		m_pUIMap = pMap;
		ATLASSERT(m_pUIMap != NULL);
		for(int nCount = 1; pMap->m_nID != (WORD)-1; nCount++)
			pMap++;

		ATLTRY(m_pUIData = new _AtlUpdateUIData[nCount]);
		ATLASSERT(m_pUIData != NULL);

		if(m_pUIData != NULL)
			memset(m_pUIData, 0, sizeof(_AtlUpdateUIData) * nCount);
	}
};

}; //namespace ATL

#endif // __ATLFRAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlctrls.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTRLS_H__
#define __ATLCTRLS_H__

#ifndef __cplusplus
    #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLWIN_H__
    #error atlctrls.h requires atlwin.h to be included first
#endif

#if (_ATL_VER < 0x0300)
#ifndef __ATLWIN21_H__
    #error atlctrls.h requires atlwin21.h to be included first when used with ATL 2.0/2.1
#endif
#endif //(_ATL_VER < 0x0300)

#include <commctrl.h>

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class Base> class CStaticT;
template <class Base> class CButtonT;
template <class Base> class CListBoxT;
template <class Base> class CComboBoxT;
template <class Base> class CEditT;
template <class Base> class CScrollBarT;
class CImageList;
template <class Base> class CListViewCtrlT;
template <class Base> class CTreeViewCtrlT;
class CTreeItem;
template <class Base> class CTreeViewCtrlExT;
template <class Base> class CHeaderCtrlT;
template <class Base> class CToolBarCtrlT;
template <class Base> class CStatusBarCtrlT;
template <class Base> class CTabCtrlT;
class CToolInfo;
template <class Base> class CToolTipCtrlT;
template <class Base> class CTrackBarCtrlT;
template <class Base> class CUpDownCtrlT;
template <class Base> class CProgressBarCtrlT;
template <class Base> class CHotKeyCtrlT;
template <class Base> class CAnimateCtrlT;
#ifndef UNDER_CE
template <class Base> class CRichEditCtrlT;
#endif //!UNDER_CE
template <class Base> class CDragListBoxT;
template <class T> class CDragListNotifyImpl;
template <class Base> class CReBarCtrlT;
template <class Base> class CComboBoxExT;
template <class Base> class CDateTimePickerCtrlT;
template <class Base> class CMonthCalendarCtrlT;
#if (_WIN32_IE >= 0x0400)
template <class Base> class CFlatScrollBarT;
template <class Base> class CIPAddressCtrlT;
template <class Base> class CPagerCtrlT;
#endif //(_WIN32_IE >= 0x0400)
template <class T> class CCustomDraw;
#ifdef UNDER_CE
template <class Base> class CCommandBarT;
template <class Base> class CCommandBandsT;
#endif //UNDER_CE

// --- Standard Windows controls ---

/////////////////////////////////////////////////////////////////////////////
// CStatic - client side for a Windows STATIC control

template <class Base>
class CStaticT : public Base
{
public:
// Constructors
    CStaticT(HWND hWnd = NULL) : Base(hWnd) { }

    CStaticT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("STATIC");
    }

    HICON SetIcon(HICON hIcon)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L);
    }
    HICON GetIcon() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L);
    }

    HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile);
    }
    HENHMETAFILE GetEnhMetaFile() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L);
    }
    HBITMAP SetBitmap(HBITMAP hBitmap)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
    }
    HBITMAP GetBitmap() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L);
    }
    HCURSOR SetCursor(HCURSOR hCursor)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);
    }
    HCURSOR GetCursor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L);
    }
};

typedef CStaticT<CWindow>   CStatic;

/////////////////////////////////////////////////////////////////////////////
// CButton - client side for a Windows BUTTON control

template <class Base>
class CButtonT : public Base
{
public:
// Constructors
    CButtonT(HWND hWnd = NULL) : Base(hWnd) { }

    CButtonT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("BUTTON");
    }

    UINT GetState() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0L);
    }
    void SetState(BOOL bHighlight)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0L);
    }
    int GetCheck() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0L);
    }
    void SetCheck(int nCheck)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0L);
    }
    UINT GetButtonStyle() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::GetWindowLong(m_hWnd, GWL_STYLE) & 0xff;
    }
    void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw);
    }

    HICON SetIcon(HICON hIcon)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
    }
    HICON GetIcon() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L);
    }
    HBITMAP SetBitmap(HBITMAP hBitmap)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
    }
    HBITMAP GetBitmap() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L);
    }
#ifndef UNDER_CE
    HCURSOR SetCursor(HCURSOR hCursor)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);
    }
    HCURSOR GetCursor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_CURSOR, 0L);
    }
#endif //!UNDER_CE
};

typedef CButtonT<CWindow>   CButton;

/////////////////////////////////////////////////////////////////////////////
// CListBox - client side for a Windows LISTBOX control

template <class Base>
class CListBoxT : public Base
{
public:
// Constructors
    CListBoxT(HWND hWnd = NULL) : Base(hWnd) { }

    CListBoxT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("LISTBOX");
    }

    // for entire listbox
    int GetCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0L);
    }
    int GetHorizontalExtent() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT, 0, 0L);
    }
    void SetHorizontalExtent(int cxExtent)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0L);
    }
    int GetTopIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0L);
    }
    int SetTopIndex(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0L);
    }
    LCID GetLocale() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0L);
    }
    LCID SetLocale(LCID nNewLocale)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0L);
    }
    int InitStorage(int nItems, UINT nBytes)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes);
    }
    UINT ItemFromPoint(POINT pt, BOOL& bOutside) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dw = (DWORD)::SendMessage(m_hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));
        bOutside = !!HIWORD(dw);
        return LOWORD(dw);
    }

    // for single-selection listboxes
    int GetCurSel() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(!(GetStyle() & LBS_MULTIPLESEL));
        return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0L);
    }
    int SetCurSel(int nSelect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(!(GetStyle() & LBS_MULTIPLESEL));
        return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0L);
    }

    // for multiple-selection listboxes
    int GetSel(int nIndex) const           // also works for single-selection
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0L);
    }
    int SetSel(int nIndex, BOOL bSelect = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LBS_MULTIPLESEL);
        return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex);
    }
    int GetSelCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LBS_MULTIPLESEL);
        return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0L);
    }
    int GetSelItems(int nMaxItems, LPINT rgIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LBS_MULTIPLESEL);
        return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex);
    }
    void SetAnchorIndex(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LBS_MULTIPLESEL);
        ::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0L);
    }
    int GetAnchorIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LBS_MULTIPLESEL);
        return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0L);
    }

    // for listbox items
    DWORD_PTR GetItemData(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
    }
    int SetItemData(int nIndex, DWORD_PTR dwItemData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
    }
    void* GetItemDataPtr(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LPVOID)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
    }
    int SetItemDataPtr(int nIndex, void* pData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)(LPVOID)pData);
    }
    int GetItemRect(int nIndex, LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect);
    }
    int GetText(int nIndex, LPTSTR lpszBuffer) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer);
    }
#ifndef _ATL_NO_COM
    BOOL GetTextBSTR(int nIndex, BSTR& bstrText) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(bstrText == NULL);

        int nLen = GetTextLen(nIndex);
        if(nLen == LB_ERR)
            return FALSE;

        LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

        if(GetText(nIndex, lpszText) == LB_ERR)
            return FALSE;

        bstrText = ::SysAllocString(T2OLE(lpszText));
        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
    int GetTextLen(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0L);
    }

    // Settable only attributes
    void SetColumnWidth(int cxWidth)
    {
        ATLASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0L);
    }
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
    }
    BOOL SetTabStops()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0L);
    }
    BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
    }

    int SetItemHeight(int nIndex, UINT cyItemHeight)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
    }
    int GetItemHeight(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L);
    }
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
    }
    int GetCaretIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0);
    }
    int SetCaretIndex(int nIndex, BOOL bScroll = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0));
    }

// Operations
    // manipulating listbox items
    int AddString(LPCTSTR lpszItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem);
    }
    int DeleteString(UINT nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0L);
    }
    int InsertString(int nIndex, LPCTSTR lpszItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem);
    }
    void ResetContent()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0L);
    }
    int Dir(UINT attr, LPCTSTR lpszWildCard)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard);
    }

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_FINDSTRING, nStartAfter, (LPARAM)lpszItem);
    }
    int SelectString(int nStartAfter, LPCTSTR lpszItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LB_SELECTSTRING, nStartAfter, (LPARAM)lpszItem);
    }
    int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return bSelect ? (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) : (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem);
    }
};

typedef CListBoxT<CWindow>  CListBox;

/////////////////////////////////////////////////////////////////////////////
// CComboBox - client side for a Windows COMBOBOX control

template <class Base>
class CComboBoxT : public Base
{
public:
// Constructors
    CComboBoxT(HWND hWnd = NULL) : Base(hWnd) { }

    CComboBoxT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("COMBOBOX");
    }

    // for entire combo box
    int GetCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0L);
    }
    int GetCurSel() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0L);
    }
    int SetCurSel(int nSelect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0L);
    }
    LCID GetLocale() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0L);
    }
    LCID SetLocale(LCID nNewLocale)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0L);
    }
    int GetTopIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0L);
    }
    int SetTopIndex(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0L);
    }
    int InitStorage(int nItems, UINT nBytes)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes);
    }
    void SetHorizontalExtent(UINT nExtent)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0L);
    }
    UINT GetHorizontalExtent() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0L);
    }
    int SetDroppedWidth(UINT nWidth)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0L);
    }
    int GetDroppedWidth() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0L);
    }

    // for edit control
    DWORD GetEditSel() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0L);
    }
    BOOL LimitText(int nMaxChars)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0L);
    }
    BOOL SetEditSel(int nStartChar, int nEndChar)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar));
    }

    // for combobox item
    DWORD_PTR GetItemData(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0L);
    }
    int SetItemData(int nIndex, DWORD_PTR dwItemData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
    }
    void* GetItemDataPtr(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (LPVOID)GetItemData(nIndex);
    }
    int SetItemDataPtr(int nIndex, void* pData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)(LPVOID)pData);
    }
    int GetLBText(int nIndex, LPTSTR lpszText) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText);
    }
#ifndef _ATL_NO_COM
    BOOL GetLBTextBSTR(int nIndex, BSTR& bstrText) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(bstrText == NULL);

        int nLen = GetLBTextLen(nIndex);
        if(nLen == CB_ERR)
            return FALSE;

        LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

        if(GetLBText(nIndex, lpszText) == CB_ERR)
            return FALSE;

        bstrText = ::SysAllocString(T2OLE(lpszText));
        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
    int GetLBTextLen(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0L);
    }

    int SetItemHeight(int nIndex, UINT cyItemHeight)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
    }
    int GetItemHeight(int nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L);
    }
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
    }
    int SetExtendedUI(BOOL bExtended = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L);
    }
    BOOL GetExtendedUI() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L);
    }
    void GetDroppedControlRect(LPRECT lprect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);
    }
    BOOL GetDroppedState() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L);
    }

// Operations
    // for drop-down combo boxes
    void ShowDropDown(BOOL bShowIt = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0L);
    }

    // manipulating listbox items
    int AddString(LPCTSTR lpszString)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString);
    }
    int DeleteString(UINT nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0L);
    }
    int InsertString(int nIndex, LPCTSTR lpszString)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString);
    }
    void ResetContent()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0L);
    }
    int Dir(UINT attr, LPCTSTR lpszWildCard)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard);
    }

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszString) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter, (LPARAM)lpszString);
    }
    int SelectString(int nStartAfter, LPCTSTR lpszString)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CB_SELECTSTRING, nStartAfter, (LPARAM)lpszString);
    }

    // Clipboard operations
    void Clear()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
    }
    void Copy()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_COPY, 0, 0L);
    }
    void Cut()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CUT, 0, 0L);
    }
    void Paste()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
    }
};

typedef CComboBoxT<CWindow> CComboBox;

/////////////////////////////////////////////////////////////////////////////
// CEdit - client side for a Windows EDIT control

template <class Base>
class CEditT : public Base
{
public:
// Constructors
    CEditT(HWND hWnd = NULL) : Base(hWnd) { }

    CEditT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("EDIT");
    }

    BOOL CanUndo() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
    }
    int GetLineCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
    }
    BOOL GetModify() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
    }
    void SetModify(BOOL bModified = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
    }
    void GetRect(LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
    }
    DWORD GetSel() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, EM_GETSEL, 0, 0L);
    }
    void GetSel(int& nStartChar, int& nEndChar) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
    }
    HLOCAL GetHandle() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0L);
    }
    void SetHandle(HLOCAL hBuffer)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0L);
    }
    void SetMargins(UINT nLeft, UINT nRight)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight));
    }
    DWORD GetMargins() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0L);
    }
    void SetLimitText(UINT nMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0L);
    }
    UINT GetLimitText() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
    }
    POINT PosFromChar(UINT nChar) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        POINT point;
        ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&point, (LPARAM)nChar);
        return point;
    }
    int CharFromPos(POINT pt) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
    }

    // NOTE: first word in lpszBuffer must contain the size of the buffer!
    int GetLine(int nIndex, LPTSTR lpszBuffer) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
    }
    int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        *(LPWORD)lpszBuffer = (WORD)nMaxLength;
        return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
    }

// Operations
    void EmptyUndoBuffer()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
    }
    BOOL FmtLines(BOOL bAddEOL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0L);
    }
    void LimitText(int nChars = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0L);
    }
    int LineFromChar(int nIndex = -1) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0L);
    }
    int LineIndex(int nLine = -1) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
    }
    int LineLength(int nLine = -1) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
    }
    void LineScroll(int nLines, int nChars = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
    }
    void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
    }
    void SetPasswordChar(TCHAR ch)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0L);
    }
    void SetRect(LPCRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
    }
    void SetRectNP(LPCRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect);
    }
    void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETSEL, LOWORD(dwSelection), HIWORD(dwSelection));
        if(!bNoScroll)
            ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
    }
    void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
        if(!bNoScroll)
            ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
    }
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
    }
    BOOL SetTabStops()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0L);
    }
    BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
    }

    // Additional operations
    void ScrollCaret()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
    }
    void InsertText(int nInsertAfterChar, LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
    {
        SetSel(nInsertAfterChar, nInsertAfterChar, bNoScroll);
        ReplaceSel(lpstrText, bCanUndo);
    }
    void AppendText(LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
    {
        InsertText(GetWindowTextLength(), lpstrText, bNoScroll, bCanUndo);
    }

    // Clipboard operations
    BOOL Undo()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
    }
    void Clear()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
    }
    void Copy()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_COPY, 0, 0L);
    }
    void Cut()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CUT, 0, 0L);
    }
    void Paste()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
    }

    BOOL SetReadOnly(BOOL bReadOnly = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
    }
    int GetFirstVisibleLine() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
    }
    TCHAR GetPasswordChar() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L);
    }
};

typedef CEditT<CWindow>     CEdit;

/////////////////////////////////////////////////////////////////////////////
// CScrollBar - client side for a Windows SCROLLBAR control

template <class Base>
class CScrollBarT : public Base
{
public:
// Constructors
    CScrollBarT(HWND hWnd = NULL) : Base(hWnd) { }

    CScrollBarT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return _T("SCROLLBAR");
    }

    int GetScrollPos() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::GetScrollPos(m_hWnd, SB_CTL);
    }
    int SetScrollPos(int nPos, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw);
    }
    void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos);
    }
    void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw);
    }
    void ShowScrollBar(BOOL bShow = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::ShowScrollBar(m_hWnd, SB_CTL, bShow);
    }

    BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags);
    }

    BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo, bRedraw);
    }
    BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::GetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo);
    }
    int GetScrollLimit()
    {
        int nMin, nMax;
        ::GetScrollRange(m_hWnd, SB_CTL, &nMin, &nMax);
        SCROLLINFO info;
        info.cbSize = sizeof(SCROLLINFO);
        info.fMask = SIF_PAGE;
        if(::GetScrollInfo(m_hWnd, SB_CTL, &info))
            nMax -= ((info.nPage-1) > 0) ? (info.nPage-1) : 0;

        return nMax;
    }
};

typedef CScrollBarT<CWindow>    CScrollBar;


// --- Windows Common Controls ---

/////////////////////////////////////////////////////////////////////////////
// CImageList

class CImageList
{
public:
    HIMAGELIST m_hImageList;

// Constructors
    CImageList(HIMAGELIST hImageList = NULL) : m_hImageList(hImageList) { }

    CImageList& operator=(HIMAGELIST hImageList)
    {
        m_hImageList = hImageList;
        return *this;
    }

    operator HIMAGELIST() const { return m_hImageList; }

    BOOL Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow)
    {
        ATLASSERT(m_hImageList == NULL);
        m_hImageList = ImageList_Create(cx, cy, nFlags, nInitial, nGrow);
        return (m_hImageList != NULL) ? TRUE : FALSE;
    }
    BOOL Create(UINT nBitmapID, int cx, int nGrow, COLORREF crMask)
    {
        ATLASSERT(m_hImageList == NULL);
        ATLASSERT(HIWORD(nBitmapID) == 0);
        m_hImageList = ImageList_LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(nBitmapID), cx, nGrow, crMask);
        return (m_hImageList != NULL) ? TRUE : FALSE;
    }
    BOOL Create(LPCTSTR lpszBitmapID, int cx, int nGrow, COLORREF crMask)
    {
        ATLASSERT(m_hImageList == NULL);
        m_hImageList = ImageList_LoadBitmap(_Module.GetModuleInstance(), lpszBitmapID, cx, nGrow, crMask);
        return (m_hImageList != NULL) ? TRUE : FALSE;
    }
    BOOL Merge(HIMAGELIST hImageList1, int nImage1, HIMAGELIST hImageList2, int nImage2, int dx, int dy)
    {
        ATLASSERT(m_hImageList == NULL);
        m_hImageList = ImageList_Merge(hImageList1, nImage1, hImageList2, nImage2, dx, dy);
        return (m_hImageList != NULL) ? TRUE : FALSE;
    }

// Attributes

    void Attach(HIMAGELIST hImageList)
    {
        ATLASSERT(m_hImageList == NULL);
        ATLASSERT(hImageList != NULL);
        m_hImageList = hImageList;
    }
    HIMAGELIST Detach()
    {
        HIMAGELIST hImageList = m_hImageList;
        m_hImageList = NULL;
        return hImageList;
    }

    int GetImageCount() const
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_GetImageCount(m_hImageList);
    }
    COLORREF SetBkColor(COLORREF cr)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_SetBkColor(m_hImageList, cr);
    }
    COLORREF GetBkColor() const
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_GetBkColor(m_hImageList);
    }
    BOOL GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_GetImageInfo(m_hImageList, nImage, pImageInfo);
    }

// Operations
    BOOL Destroy()
    {
        if (m_hImageList == NULL)
            return FALSE;
        BOOL bRet = ImageList_Destroy(Detach());
        if(bRet)
            m_hImageList = NULL;
        return bRet;
    }

    int Add(HBITMAP hBitmap, HBITMAP hBitmapMask)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_Add(m_hImageList, hBitmap, hBitmapMask);
    }
    int Add(HBITMAP hBitmap, COLORREF crMask)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_AddMasked(m_hImageList, hBitmap, crMask);
    }
    BOOL Remove(int nImage)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_Remove(m_hImageList, nImage);
    }
    BOOL Replace(int nImage, HBITMAP hBitmap, HBITMAP hBitmapMask)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_Replace(m_hImageList, nImage, hBitmap, hBitmapMask);
    }
    int AddIcon(HICON hIcon)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_AddIcon(m_hImageList, hIcon);
    }
    int ReplaceIcon(int nImage, HICON hIcon)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_ReplaceIcon(m_hImageList, nImage, hIcon);
    }
    HICON ExtractIcon(int nImage)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_ExtractIcon(NULL, m_hImageList, nImage);
    }
    BOOL Draw(HDC hDC, int nImage, POINT pt, UINT nStyle)
    {
        ATLASSERT(m_hImageList != NULL);
        ATLASSERT(hDC != NULL);
        return ImageList_Draw(m_hImageList, nImage, hDC, pt.x, pt.y, nStyle);
    }
    BOOL DrawEx(int nImage, HDC hDC, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
    {
        ATLASSERT(m_hImageList != NULL);
        ATLASSERT(hDC != NULL);
        return ImageList_DrawEx(m_hImageList, nImage, hDC, x, y, dx, dy, rgbBk, rgbFg, fStyle);
    }
    BOOL SetOverlayImage(int nImage, int nOverlay)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_SetOverlayImage(m_hImageList, nImage, nOverlay);
    }

// Drag APIs
    BOOL BeginDrag(int nImage, POINT ptHotSpot)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_BeginDrag(m_hImageList, nImage, ptHotSpot.x, ptHotSpot.y);
    }
    static void PASCAL EndDrag()
    {
        ImageList_EndDrag();
    }
    static BOOL PASCAL DragMove(POINT pt)
    {
        return ImageList_DragMove(pt.x, pt.y);
    }
    BOOL SetDragCursorImage(int nDrag, POINT ptHotSpot)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_SetDragCursorImage(m_hImageList, nDrag, ptHotSpot.x, ptHotSpot.y);
    }
    static BOOL PASCAL DragShowNolock(BOOL bShow)
    {
        return ImageList_DragShowNolock(bShow);
    }
    static HIMAGELIST PASCAL GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot)
    {
        return ImageList_GetDragImage(lpPoint, lpPointHotSpot);
    }
    static BOOL PASCAL DragEnter(HWND hWnd, POINT point)
    {
        return ImageList_DragEnter(hWnd, point.x, point.y);
    }
    static BOOL PASCAL DragLeave(HWND hWnd)
    {
        return ImageList_DragLeave(hWnd);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    HIMAGELIST Duplicate(HIMAGELIST hImageList)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_Duplicate(m_hImageList);
    }
    BOOL SetImageCount(UINT uNewCount)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_SetImageCount(m_hImageList, uNewCount);
    }
    BOOL Copy(int nSrc, int nDst, UINT uFlags = ILCF_MOVE)
    {
        ATLASSERT(m_hImageList != NULL);
        return ImageList_Copy(m_hImageList, nDst, m_hImageList, nSrc, uFlags);
    }
    static BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
    {
        return ImageList_DrawIndirect(pimldp);
    }
#endif //(_WIN32_IE >= 0x0400)
};


/////////////////////////////////////////////////////////////////////////////
// CListViewCtrl

template <class Base>
class CListViewCtrlT : public Base
{
public:
// Constructors
    CListViewCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CListViewCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return WC_LISTVIEW;
    }

    COLORREF GetBkColor() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L);
    }
    BOOL SetBkColor(COLORREF cr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr);
    }
    HIMAGELIST GetImageList(int nImageListType) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageListType, 0L);
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList, int nImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)hImageList);
    }
    int GetItemCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L);
    }
    BOOL GetItem(LV_ITEM* pItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
    }
    BOOL SetItem(const LV_ITEM* pItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem);
    }
    BOOL SetItemState(int nItem, UINT nState, UINT nStateMask)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(nItem, 0, LVIF_STATE, NULL, 0, nState, nStateMask, 0);
    }
    BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(nItem, nSubItem, LVIF_TEXT, lpszText, 0, 0, 0, 0);
    }
    BOOL SetItemData(int nItem, DWORD_PTR dwData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData);
    }
    int InsertItem(const LV_ITEM* pItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem);
    }
    int InsertItem(int nItem, LPCTSTR lpszItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0);
    }
    int InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0);
    }
    BOOL DeleteItem(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L);
    }
    BOOL DeleteAllItems()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L);
    }
    UINT GetCallbackMask() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0L);
    }
    BOOL SetCallbackMask(UINT nMask)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0L);
    }
    int GetNextItem(int nItem, int nFlags) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0));
    }
    int FindItem(LV_FINDINFO* pFindInfo, int nStart) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo);
    }
    int HitTest(LV_HITTESTINFO* pHitTestInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo);
    }
    BOOL SetItemPosition(int nItem, POINT pt)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
    }
    BOOL GetItemPosition(int nItem, LPPOINT lpPoint) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint);
    }
    int GetStringWidth(LPCTSTR lpsz) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz);
    }
    BOOL EnsureVisible(int nItem, BOOL bPartialOK)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0));
    }
    BOOL Scroll(SIZE size)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy);
    }
    BOOL RedrawItems(int nFirst, int nLast)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast);
    }
    BOOL Arrange(UINT nCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L);
    }
    HWND EditLabel(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L);
    }
    HWND GetEditControl() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L);
    }
    BOOL GetColumn(int nCol, LV_COLUMN* pColumn) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn);
    }
    BOOL SetColumn(int nCol, const LV_COLUMN* pColumn)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn);
    }
    int InsertColumn(int nCol, const LV_COLUMN* pColumn)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn);
    }
    BOOL DeleteColumn(int nCol)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0L);
    }
    int GetColumnWidth(int nCol) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0L);
    }
    BOOL SetColumnWidth(int nCol, int cx)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0));
    }
    BOOL GetViewRect(LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect);
    }
    COLORREF GetTextColor() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L);
    }
    BOOL SetTextColor(COLORREF cr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr);
    }
    COLORREF GetTextBkColor() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L);
    }
    BOOL SetTextBkColor(COLORREF cr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr);
    }
    int GetTopIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0L);
    }
    int GetCountPerPage() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0L);
    }
    BOOL GetOrigin(LPPOINT lpPoint) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint);
    }
    BOOL Update(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L);
    }
    BOOL SetItemState(int nItem, LV_ITEM* pItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem);
    }
    UINT GetItemState(int nItem, UINT nMask) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask);
    }
    void SetItemCount(int nItems)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0L);
    }
    BOOL SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare);
    }
    UINT GetSelectedCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L);
    }

    BOOL GetItemRect(int nItem, LPRECT lpRect, UINT nCode) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        lpRect->left = nCode;
        return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMRECT, (WPARAM)nItem, (LPARAM)lpRect);
    }

    int InsertColumn(int nCol, LPCTSTR lpszColumnHeading, int nFormat, int nWidth, int nSubItem)
    {
        LV_COLUMN column;
        column.mask = LVCF_TEXT|LVCF_FMT;
        column.pszText = (LPTSTR)lpszColumnHeading;
        column.fmt = nFormat;
        if (nWidth != -1)
        {
            column.mask |= LVCF_WIDTH;
            column.cx = nWidth;
        }
        if (nSubItem != -1)
        {
            column.mask |= LVCF_SUBITEM;
            column.iSubItem = nSubItem;
        }
        return InsertColumn(nCol, &column);
    }

    int InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem, UINT nState, UINT nStateMask, int nImage, LPARAM lParam)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_ITEM item;
        item.mask = nMask;
        item.iItem = nItem;
        item.iSubItem = 0;
        item.pszText = (LPTSTR)lpszItem;
        item.state = nState;
        item.stateMask = nStateMask;
        item.iImage = nImage;
        item.lParam = lParam;
        return InsertItem(&item);
    }

    int HitTest(POINT pt, UINT* pFlags) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_HITTESTINFO hti;
        hti.pt = pt;
        int nRes = (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)&hti);
        if (pFlags != NULL)
            *pFlags = hti.flags;
        return nRes;
    }

    BOOL SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
        int nImage, UINT nState, UINT nStateMask, LPARAM lParam)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_ITEM lvi;
        lvi.mask = nMask;
        lvi.iItem = nItem;
        lvi.iSubItem = nSubItem;
        lvi.stateMask = nStateMask;
        lvi.state = nState;
        lvi.pszText = (LPTSTR) lpszItem;
        lvi.iImage = nImage;
        lvi.lParam = lParam;
        return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)&lvi);
    }

#ifndef _ATL_NO_COM
    BOOL GetItemText(int nItem, int nSubItem, BSTR& bstrText) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(bstrText == NULL);
        LV_ITEM lvi;
        memset(&lvi, 0, sizeof(LV_ITEM));
        lvi.iSubItem = nSubItem;

        LPTSTR lpstrText = NULL;
        int nLen = 128;
        int nRes;
        do
        {
            nLen *= 2;
            lvi.cchTextMax = nLen;
            if(lpstrText != NULL)
            {
                delete [] lpstrText;
                lpstrText = NULL;
            }
            ATLTRY(lpstrText = new TCHAR[nLen]);
            if(lpstrText == NULL)
                break;
            lpstrText[0] = NULL;
            lvi.pszText = lpstrText;
            nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem,
                (LPARAM)&lvi);
        } while (nRes == nLen-1);

        bstrText = ::SysAllocString(T2OLE(lpstrText));
        delete [] lpstrText;

        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM

    int GetItemText(int nItem, int nSubItem, LPTSTR lpszText, int nLen) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_ITEM lvi;
        memset(&lvi, 0, sizeof(LV_ITEM));
        lvi.iSubItem = nSubItem;
        lvi.cchTextMax = nLen;
        lvi.pszText = lpszText;
        return (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
    }

    DWORD_PTR GetItemData(int nItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_ITEM lvi;
        memset(&lvi, 0, sizeof(LV_ITEM));
        lvi.iItem = nItem;
        lvi.mask = LVIF_PARAM;
        ::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)&lvi);
        return lvi.lParam;
    }

    void RemoveImageList(int nImageList)
    {
        HIMAGELIST h = (HIMAGELIST)::SendMessage(m_hWnd, LVM_GETIMAGELIST, (WPARAM)nImageList, 0L);
        if (h != NULL)
            ::SendMessage(m_hWnd, LVM_SETIMAGELIST, (WPARAM)nImageList, 0L);
    }

    HIMAGELIST CreateDragImage(int nItem, LPPOINT lpPoint)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, LVM_CREATEDRAGIMAGE, nItem, (LPARAM)lpPoint);
    }

    BOOL AddColumn(LPCTSTR strItem,int nItem,int nSubItem = -1,
            int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
            int nFmt = LVCFMT_LEFT)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        LV_COLUMN lvc;
        lvc.mask = nMask;
        lvc.fmt = nFmt;
        lvc.pszText = (LPTSTR)strItem;
        lvc.cx = GetStringWidth(lvc.pszText) + 15;
        if(nMask & LVCF_SUBITEM)
        {
            if(nSubItem != -1)
                lvc.iSubItem = nSubItem;
            else
                lvc.iSubItem = nItem;
        }
        return InsertColumn(nItem, &lvc);
    }

    BOOL AddItem(int nItem,int nSubItem,LPCTSTR strItem,int nImageIndex = -1)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItem;
        lvItem.iSubItem = nSubItem;
        lvItem.pszText = (LPTSTR) strItem;
        if(nImageIndex != -1){
            lvItem.mask |= LVIF_IMAGE;
            lvItem.iImage = nImageIndex;
        }
        if(nSubItem == 0)
            return InsertItem(&lvItem);
        return SetItem(&lvItem);
    }

    // single-selection only
    int GetSelectedIndex() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LVS_SINGLESEL);

        return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
    }

    BOOL GetSelectedItem(LV_ITEM* pItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LVS_SINGLESEL);
        ATLASSERT(pItem != NULL);

        pItem->iItem = (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
        if(pItem->iItem == -1)
            return FALSE;

        return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    BOOL GetBkImage(LPLVBKIMAGE plvbki)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbki);
    }
    BOOL SetBkImage(LPLVBKIMAGE plvbki)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbki);
    }
    DWORD GetExtendedListViewStyle()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0L);
    }
    // dwExMask = 0 means all styles
    DWORD SetExtendedListViewStyle(DWORD dwExStyle, DWORD dwExMask = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle);
    }
    HCURSOR GetHotCursor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0L);
    }
    HCURSOR SetHotCursor(HCURSOR hHotCursor)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HCURSOR)::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM)hHotCursor);
    }
    int GetHotItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0L);
    }
    int SetHotItem(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LVM_SETHOTITEM, nIndex, 0L);
    }
    int GetSelectionMark()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0L);
    }
    int SetSelectionMark(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, nIndex);
    }
    BOOL GetWorkAreas(int nWorkAreas, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
    }
    BOOL SetWorkAreas(int nWorkAreas, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
    }
    BOOL GetColumnOrderArray(int nCount, int* lpnArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
    }
    BOOL SetColumnOrderArray(int nCount, int* lpnArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
    }
    DWORD GetHoverTime()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE));
        return ::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0L);
    }
    DWORD SetHoverTime(DWORD dwHoverTime)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE));
        return ::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime);
    }
    HWND GetHeader()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, LVM_GETHEADER, 0, 0L);
    }
    BOOL GetSubItemRect(int nItem, int nSubItem, int nFlag, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LVS_REPORT);
        ATLASSERT(lpRect != NULL);
        lpRect->top = nSubItem;
        lpRect->left = nFlag;
        return (BOOL)::SendMessage(m_hWnd, LVM_GETSUBITEMRECT, nItem, (LPARAM)lpRect);
    }
    BOOL GetCheckState(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetExtendedListViewStyle() & LVS_EX_CHECKBOXES);
        UINT uRet = GetItemState(nIndex, LVIS_STATEIMAGEMASK);
//REVIEW
        return (uRet >> 12) - 1;
    }
    BOOL SetCheckState(int nItem, BOOL bCheck)
    {
        int nCheck = bCheck ? 2 : 1;    // one based index
        return SetItemState(nItem, INDEXTOSTATEIMAGEMASK(nCheck), LVIS_STATEIMAGEMASK);
    }
    DWORD ApproximateViewRect(int cx = -1, int cy = -1, int nCount = -1)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, nCount, MAKELPARAM(cx, cy));
    }
    BOOL GetNumberOfWorkAreas(int* pnWorkAreas)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)pnWorkAreas);
    }
    DWORD SetIconSpacing(int cx, int cy)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(GetStyle() & LVS_ICON);
        return ::SendMessage(m_hWnd, LVM_SETICONSPACING, 0, MAKELPARAM(cx, cy));
    }
    void SetItemCountEx(int nItems, DWORD dwFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT((GetStyle() & LVS_OWNERDATA) && (GetStyle() & (LVS_REPORT | LVS_LIST)));
        ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, dwFlags);
    }
    int SubItemHitTest(LPLVHITTESTINFO lpInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpInfo);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CListViewCtrlT<CWindow>     CListViewCtrl;

/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrl

template <class Base>
class CTreeViewCtrlT : public Base
{
public:
// Constructors
    CTreeViewCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CTreeViewCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Operations
    static LPCTSTR GetWndClassName()
    {
        return WC_TREEVIEW;
    }

    HTREEITEM InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
    }
    HTREEITEM InsertItem(LPCTSTR lpszItem, int nImage,
        int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter);
    }
    HTREEITEM InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
    }
    BOOL DeleteItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem);
    }
    BOOL DeleteAllItems()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);
    }
    BOOL Expand(HTREEITEM hItem, UINT nCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem);
    }
    UINT GetCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0L);
    }
    UINT GetIndent() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0L);
    }
    void SetIndent(UINT nIndent)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0L);
    }
    HIMAGELIST GetImageList(UINT nImageList) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)(::SendMessage(m_hWnd, TVM_GETIMAGELIST, (UINT)nImageList, 0L));
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList, int nImageListType)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)(::SendMessage(m_hWnd, TVM_SETIMAGELIST, (UINT)nImageListType, (LPARAM)hImageList));
    }
    HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
    }
    HTREEITEM GetChildItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
    }
    HTREEITEM GetNextSiblingItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem);
    }
    HTREEITEM GetPrevSiblingItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
    }
    HTREEITEM GetParentItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem);
    }
    HTREEITEM GetFirstVisibleItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
    }
    HTREEITEM GetNextVisibleItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
    }
    HTREEITEM GetPrevVisibleItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
    }
    HTREEITEM GetSelectedItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
    }
    HTREEITEM GetDropHilightItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
    }
    HTREEITEM GetRootItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
    }
    BOOL Select(HTREEITEM hItem, UINT nCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem);
    }
    BOOL SelectItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem);
    }
    BOOL SelectDropTarget(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem);
    }
    BOOL SelectSetFirstVisible(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem);
    }
    BOOL GetItem(TV_ITEM* pItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem);
    }
    BOOL SetItem(TV_ITEM* pItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem);
    }
    BOOL SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL);
    }
    BOOL SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL);
    }
    BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL);
    }
    BOOL SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData);
    }
    HWND EditLabel(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem);
    }
    HTREEITEM HitTest(TV_HITTESTINFO* pHitTestInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
    }
    HWND GetEditControl() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0L);
    }
    UINT GetVisibleCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0L);
    }
    BOOL SortChildren(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem);
    }
    BOOL EnsureVisible(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem);
    }
    BOOL SortChildrenCB(LPTV_SORTCB pSort)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort);
    }

    BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        *(HTREEITEM*)lpRect = hItem;
        return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMRECT, (WPARAM)bTextOnly, (LPARAM)lpRect);
    }

#ifndef _ATL_NO_COM
    BOOL GetItemText(HTREEITEM hItem, BSTR& bstrText) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(bstrText == NULL);
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = TVIF_TEXT;
        LPTSTR lpstrText = NULL;
        int nLen = 128;
        do
        {
            nLen *= 2;
            LPTSTR lpstrTemp;
            lpstrTemp = (LPTSTR)realloc(lpstrText, nLen * sizeof(TCHAR));
            if(lpstrTemp == NULL)
            {
                free(lpstrText);
                return FALSE;
            }
            lpstrText = lpstrTemp;
            item.pszText = lpstrText;
            item.cchTextMax = nLen;
            ::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
        }
        while (lstrlen(item.pszText) == (nLen-1));

        bstrText = ::SysAllocString(T2OLE(lpstrText));
        free(lpstrText);

        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM

    BOOL GetItemImage(HTREEITEM hItem, int& nImage, int& nSelectedImage) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
        BOOL bRes = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
        if (bRes)
        {
            nImage = item.iImage;
            nSelectedImage = item.iSelectedImage;
        }
        return bRes;
    }

    UINT GetItemState(HTREEITEM hItem, UINT nStateMask) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = TVIF_STATE;
        item.stateMask = nStateMask;
        item.state = 0;
        ::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
        return item.state;
    }

    DWORD_PTR GetItemData(HTREEITEM hItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = TVIF_PARAM;
        ::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
        return item.lParam;
    }

    BOOL ItemHasChildren(HTREEITEM hItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = TVIF_CHILDREN;
        ::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
        return item.cChildren;
    }

    BOOL SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
        int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_ITEM item;
        item.hItem = hItem;
        item.mask = nMask;
        item.pszText = (LPTSTR) lpszItem;
        item.iImage = nImage;
        item.iSelectedImage = nSelectedImage;
        item.state = nState;
        item.stateMask = nStateMask;
        item.lParam = lParam;
        return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
    }

    HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
        int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
        HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_INSERTSTRUCT tvis;
        tvis.hParent = hParent;
        tvis.hInsertAfter = hInsertAfter;
        tvis.item.mask = nMask;
        tvis.item.pszText = (LPTSTR) lpszItem;
        tvis.item.iImage = nImage;
        tvis.item.iSelectedImage = nSelectedImage;
        tvis.item.state = nState;
        tvis.item.stateMask = nStateMask;
        tvis.item.lParam = lParam;
        return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
    }

    HTREEITEM HitTest(POINT pt, UINT* pFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_HITTESTINFO hti;
        hti.pt = pt;
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
        if (pFlags != NULL)
            *pFlags = hti.flags;
        return hTreeItem;
    }

    void RemoveImageList(int nImageList)
    {
        HIMAGELIST h = (HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (WPARAM)nImageList, 0L);
        ::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, 0L);
    }

    HIMAGELIST CreateDragImage(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    HWND GetToolTips()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L);
    }
    HWND SetToolTips(HWND hWndTT)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L);
    }
    BOOL Expand(HTREEITEM hItem, int nType)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nType, (LPARAM)hItem);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTreeViewCtrlT<CWindow>     CTreeViewCtrl;

/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrlEx

typedef CTreeViewCtrlExT<CWindow> CTreeViewCtrlEx;  // forward declaration

class CTreeItem
{
public:
    HTREEITEM m_hTreeItem;
    CTreeViewCtrlEx* m_pTreeView;

// Construction
    CTreeItem(HTREEITEM hTreeItem = NULL, CTreeViewCtrlEx* pTreeView = NULL) : m_hTreeItem(hTreeItem), m_pTreeView(pTreeView)
    { }

    CTreeItem(const CTreeItem& posSrc)
    {
        *this = posSrc;
    }

    operator HTREEITEM() { return m_hTreeItem; }

    const CTreeItem& operator =(const CTreeItem& itemSrc)
    {
        m_hTreeItem = itemSrc.m_hTreeItem;
        m_pTreeView = itemSrc.m_pTreeView;
        return *this;
    }

// Attributes
    CTreeViewCtrlEx* GetTreeView() const { return m_pTreeView; }

    BOOL operator !() const { return m_hTreeItem == NULL; }
    BOOL IsNull() const { return m_hTreeItem == NULL; }

    BOOL GetRect(LPRECT lpRect, BOOL bTextOnly);
#ifndef _ATL_NO_COM
    BOOL GetText(BSTR& bstrText);
#endif //!_ATL_NO_COM
    BOOL GetImage(int& nImage, int& nSelectedImage);
    UINT GetState(UINT nStateMask);
    DWORD_PTR GetData();
    BOOL SetItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam);
    BOOL SetText(LPCTSTR lpszItem);
    BOOL SetImage(int nImage, int nSelectedImage);
    BOOL SetState(UINT nState, UINT nStateMask);
    BOOL SetData(DWORD_PTR dwData);

// Operations
    CTreeItem InsertAfter(LPCTSTR lpstrItem, HTREEITEM hItemAfter, int nImageIndex)
    {
        return _Insert(lpstrItem, nImageIndex, hItemAfter);
    }
    CTreeItem AddHead(LPCTSTR lpstrItem, int nImageIndex)
    {
        return _Insert(lpstrItem, nImageIndex, TVI_FIRST);
    }
    CTreeItem AddTail(LPCTSTR lpstrItem, int nImageIndex)
    {
        return _Insert(lpstrItem, nImageIndex, TVI_LAST);
    }

    CTreeItem GetChild();
    CTreeItem GetNext(UINT nCode);
    CTreeItem GetNextSibling();
    CTreeItem GetPrevSibling();
    CTreeItem GetParent();
    CTreeItem GetFirstVisible();
    CTreeItem GetNextVisible();
    CTreeItem GetPrevVisible();
    CTreeItem GetSelected();
    CTreeItem GetDropHilight();
    CTreeItem GetRoot();
    BOOL HasChildren();
    BOOL Delete();
    BOOL Expand(UINT nCode = TVE_EXPAND);
    BOOL Select(UINT nCode);
    BOOL Select();
    BOOL SelectDropTarget();
    BOOL SelectSetFirstVisible();
    HWND EditLabel();
    HIMAGELIST CreateDragImage();
    BOOL SortChildren();
    BOOL EnsureVisible();

    CTreeItem _Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter);
    int GetImageIndex();
};


template <class Base>
class CTreeViewCtrlExT : public CTreeViewCtrlT< Base >
{
public:
// Constructors
    CTreeViewCtrlExT(HWND hWnd = NULL) : CTreeViewCtrlT< Base >(hWnd) { }

    CTreeViewCtrlExT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

// Operations (overides that return CTreeItem)
    CTreeItem InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem InsertItem(LPCTSTR lpszItem, int nImage,
        int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter);
    }
    CTreeItem InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
    }
    CTreeItem GetNextItem(HTREEITEM hItem, UINT nCode)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetChildItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetNextSiblingItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetPrevSiblingItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetParentItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetFirstVisibleItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetNextVisibleItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetPrevVisibleItem(HTREEITEM hItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetSelectedItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetDropHilightItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem GetRootItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
        return CTreeItem(hTreeItem, this);
    }
    CTreeItem HitTest(TV_HITTESTINFO* pHitTestInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
        return CTreeItem(hTreeItem, this);
    }

    CTreeItem InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
        int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
        HTREEITEM hParent, HTREEITEM hInsertAfter)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_INSERTSTRUCT tvis;
        tvis.hParent = hParent;
        tvis.hInsertAfter = hInsertAfter;
        tvis.item.mask = nMask;
        tvis.item.pszText = (LPTSTR) lpszItem;
        tvis.item.iImage = nImage;
        tvis.item.iSelectedImage = nSelectedImage;
        tvis.item.state = nState;
        tvis.item.stateMask = nStateMask;
        tvis.item.lParam = lParam;
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
        return CTreeItem(hTreeItem, this);
    }

    CTreeItem HitTest(POINT pt, UINT* pFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TV_HITTESTINFO hti;
        hti.pt = pt;
        HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
        if (pFlags != NULL)
            *pFlags = hti.flags;
        return CTreeItem(hTreeItem, this);
    }
};


// CTreeItem inline methods
inline BOOL CTreeItem::GetRect(LPRECT lpRect, BOOL bTextOnly)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetItemRect(m_hTreeItem,lpRect,bTextOnly);
}
inline CTreeItem CTreeItem::GetNext(UINT nCode)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetNextItem(m_hTreeItem,nCode);
}
inline CTreeItem CTreeItem::GetChild()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetChildItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetNextSibling()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetNextSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevSibling()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetPrevSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetParent()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetParentItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetFirstVisible()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetFirstVisibleItem();
}
inline CTreeItem CTreeItem::GetNextVisible()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetNextVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevVisible()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetPrevVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetSelected()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetSelectedItem();
}
inline CTreeItem CTreeItem::GetDropHilight()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetDropHilightItem();
}
inline CTreeItem CTreeItem::GetRoot()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetRootItem();
}
#ifndef _ATL_NO_COM
inline BOOL CTreeItem::GetText(BSTR& bstrText)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetItemText(m_hTreeItem, bstrText);
}
#endif //!_ATL_NO_COM
inline BOOL CTreeItem::GetImage(int& nImage, int& nSelectedImage)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline UINT CTreeItem::GetState(UINT nStateMask)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetItemState(m_hTreeItem,nStateMask);
}
inline DWORD_PTR CTreeItem::GetData()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->GetItemData(m_hTreeItem);
}
inline BOOL CTreeItem::SetItem(UINT nMask, LPCTSTR lpszItem, int nImage,
        int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SetItem(m_hTreeItem, nMask, lpszItem, nImage, nSelectedImage, nState, nStateMask, lParam);
}
inline BOOL CTreeItem::SetText(LPCTSTR lpszItem)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SetItemText(m_hTreeItem,lpszItem);
}
inline BOOL CTreeItem::SetImage(int nImage, int nSelectedImage)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline BOOL CTreeItem::SetState(UINT nState, UINT nStateMask)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SetItemState(m_hTreeItem,nState,nStateMask);
}
inline BOOL CTreeItem::SetData(DWORD_PTR dwData)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SetItemData(m_hTreeItem,dwData);
}
inline BOOL CTreeItem::HasChildren()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->ItemHasChildren(m_hTreeItem);
}
inline BOOL CTreeItem::Delete()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->DeleteItem(m_hTreeItem);
}
inline BOOL CTreeItem::Expand(UINT nCode)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->Expand(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select(UINT nCode)
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->Select(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SelectItem(m_hTreeItem);
}
inline BOOL CTreeItem::SelectDropTarget()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SelectDropTarget(m_hTreeItem);
}
inline BOOL CTreeItem::SelectSetFirstVisible()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SelectSetFirstVisible(m_hTreeItem);
}
inline HWND CTreeItem::EditLabel()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->EditLabel(m_hTreeItem);
}
inline HIMAGELIST CTreeItem::CreateDragImage()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->CreateDragImage(m_hTreeItem);
}
inline BOOL CTreeItem::SortChildren()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->SortChildren(m_hTreeItem);
}
inline BOOL CTreeItem::EnsureVisible()
{
    ATLASSERT(m_pTreeView != NULL);
    return m_pTreeView->EnsureVisible(m_hTreeItem);
}

inline CTreeItem CTreeItem::_Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter)
{
    ATLASSERT(m_pTreeView != NULL);
    TV_INSERTSTRUCT ins;
    ins.hParent = m_hTreeItem;
    ins.hInsertAfter = hItemAfter;
    ins.item.mask = TVIF_TEXT;
    ins.item.pszText = (LPTSTR)lpstrItem;
    if(nImageIndex != -1)
    {
        ins.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        ins.item.iImage = nImageIndex;
        ins.item.iSelectedImage = nImageIndex;
    }
    return CTreeItem(m_pTreeView->InsertItem(&ins), m_pTreeView);
}

inline int CTreeItem::GetImageIndex()
{
    ATLASSERT(m_pTreeView != NULL);
    TV_ITEM item;
    item.mask = TVIF_HANDLE | TVIF_IMAGE;
    item.hItem = m_hTreeItem;
    m_pTreeView->GetItem(&item);
    return item.iImage;
}


/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

template <class Base>
class CHeaderCtrlT : public Base
{
public:
// Constructors
    CHeaderCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CHeaderCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return WC_HEADER;
    }

    int GetItemCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L);
    }
    BOOL GetItem(int nIndex, HD_ITEM* pHeaderItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nIndex, (LPARAM)pHeaderItem);
    }
    BOOL SetItem(int nIndex, HD_ITEM* pHeaderItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nIndex, (LPARAM)pHeaderItem);
    }

// Operations
    int InsertItem(int nIndex, HD_ITEM* phdi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nIndex, (LPARAM)phdi);
    }
    BOOL DeleteItem(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nIndex, 0L);
    }
    BOOL Layout(HD_LAYOUT* pHeaderLayout)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    HIMAGELIST GetImageList()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, HDM_GETIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, HDM_SETIMAGELIST, 0, (LPARAM)hImageList);
    }
    BOOL GetOrderArray(int nSize, int* lpnArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_GETORDERARRAY, nSize, (LPARAM)lpnArray);
    }
    BOOL SetOrderArray(int nSize, int* lpnArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_SETORDERARRAY, nSize, (LPARAM)lpnArray);
    }
    int OrderToIndex(int nOrder)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0L);
    }
    HIMAGELIST CreateDragImage(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L);
    }
    BOOL GetItemRect(int nIndex, LPRECT lpItemRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpItemRect);
    }
    int SetHotDivider(BOOL bPos, DWORD dwInputValue)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, bPos, dwInputValue);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CHeaderCtrlT<CWindow>       CHeaderCtrl;

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

template <class Base>
class CToolBarCtrlT : public Base
{
public:
// Construction
    CToolBarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CToolBarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return TOOLBARCLASSNAME;
    }

    BOOL IsButtonEnabled(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0L);
    }
    BOOL IsButtonChecked(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0L);
    }
    BOOL IsButtonPressed(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0L);
    }
    BOOL IsButtonHidden(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return(BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0L);
    }
    BOOL IsButtonIndeterminate(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0L);
    }
    BOOL SetState(int nID, UINT nState)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0));
    }
    int GetState(int nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L);
    }
    BOOL GetButton(int nIndex, LPTBBUTTON lpButton) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton);
    }
    int GetButtonCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L);
    }
    BOOL GetItemRect(int nIndex, LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect);
    }
    void SetButtonStructSize(int nSize)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L);
    }
    BOOL SetButtonSize(SIZE size)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));
    }
    BOOL SetBitmapSize(SIZE size)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));
    }
    HWND GetToolTips() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L);
    }
    void SetToolTips(HWND hWndToolTip)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
    }
    void SetNotifyWnd(HWND hWnd)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)hWnd, 0L);
    }
    void SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_SETROWS, MAKELPARAM(nRows, bLarger), (LPARAM)lpRect);
    }
    int GetRows() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_GETROWS, 0, 0L);
    }
    BOOL SetCmdID(int nIndex, UINT nID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID);
    }
    UINT GetBitmapFlags() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L);
    }

// Operations
    BOOL EnableButton(int nID, BOOL bEnable = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0));
    }
    BOOL CheckButton(int nID, BOOL bCheck = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0));
    }
    BOOL PressButton(int nID, BOOL bPress = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0));
    }
    BOOL HideButton(int nID, BOOL bHide = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0));
    }
    BOOL Indeterminate(int nID, BOOL bIndeterminate = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0));
    }
    int AddBitmap(int nNumButtons, UINT nBitmapID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TBADDBITMAP tbab;
        tbab.hInst = _Module.GetResourceInstance();
        ATLASSERT(tbab.hInst != NULL);
        tbab.nID = nBitmapID;
        return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
    }
    int AddBitmap(int nNumButtons, HBITMAP hBitmap)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TBADDBITMAP tbab;
        tbab.hInst = NULL;
        tbab.nID = (DWORD_PTR)hBitmap;
        return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
    }
    BOOL AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons);
    }
    BOOL InsertButton(int nIndex, LPTBBUTTON lpButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton);
    }
    BOOL DeleteButton(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0L);
    }
    UINT CommandToIndex(UINT nID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L);
    }
    void SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TBSAVEPARAMS tbs;
        tbs.hkr = hKeyRoot;
        tbs.pszSubKey = lpszSubKey;
        tbs.pszValueName = lpszValueName;
        ::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
    }
    void RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        TBSAVEPARAMS tbs;
        tbs.hkr = hKeyRoot;
        tbs.pszSubKey = lpszSubKey;
        tbs.pszValueName = lpszValueName;
        ::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
    }
    void Customize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L);
    }
    int AddString(UINT nStringID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_ADDSTRING, (WPARAM)_Module.GetResourceInstance(), (LPARAM)nStringID);
    }
    int AddStrings(LPCTSTR lpszStrings)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings);
    }
    void AutoSize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    BOOL GetAnchorHighlight()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0L);
    }
    BOOL SetAnchorHighlight(BOOL bEnable = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, bEnable, 0L);
    }
    BOOL GetButtonInfo(int nID, LPTBBUTTONINFO lptbbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTONINFO, 0, (LPARAM)lptbbi);
    }
    BOOL SetButtonInfo(int nID, LPTBBUTTONINFO lptbbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONINFO, 0, (LPARAM)lptbbi);
    }
    HIMAGELIST GetImageList()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)hImageList);
    }
    HIMAGELIST GetDisabledImageList()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetDisabledImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)hImageList);
    }
    HIMAGELIST GetHotImageList()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetHotImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)hImageList);
    }
    int GetHotItem()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0L);
    }
    int SetHotItem(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_SETHOTITEM, nItem, 0L);
    }
    DWORD GetStyle()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L);
    }
//REVIEW - return value?
    void SetStyle(DWORD dwStyle)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle);
    }
    DWORD GetBitmapFlags()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L);
    }
    DWORD GetButtonSize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
    }
    HRESULT GetObject(REFIID iid, LPVOID* ppvObject)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HRESULT)::SendMessage(m_hWnd, TB_GETOBJECT, (WPARAM)&iid, (LPARAM)ppvObject);
    }
    BOOL GetRect(int nID, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect);
    }
    int GetTextRows()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L);
    }
	 /*
    BOOL HighlightButton(int nButtonID, BOOL bHighlight)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_HIGHLIGHTBUTTON, nButtonID, MAKELPARAM(bHighlight, 0));
    }
	 */
    BOOL IsButtonHighlighted(int nButtonID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nButtonID, 0L);
    }
    int LoadImages(int nBitmapID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)_Module.GetResourceInstance());
    }
    int LoadStdImages(int nBitmapID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)HINST_COMMCTRL);
    }
    BOOL ReplaceBitmap(LPTBREPLACEBITMAP ptbrb)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)ptbrb);
    }
    BOOL SetButtonWidth(int cxMin, int cxMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
    }
    DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwFlags);
    }
    BOOL SetIndent(int nIndent)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETINDENT, nIndent, 0L);
    }
    BOOL SetMaxTextRows(int nMaxTextRows)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, nMaxTextRows, 0L);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CToolBarCtrlT<CWindow>      CToolBarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

template <class Base>
class CStatusBarCtrlT : public Base
{
public:
// Constructors
    CStatusBarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CStatusBarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return STATUSCLASSNAME;
    }

    BOOL SetText(int nPane, LPCTSTR lpszText, int nType = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(nPane < 256);
        return (BOOL)::SendMessage(m_hWnd, SB_SETTEXT, (nPane | nType), (LPARAM)lpszText);
    }
    int GetText(int nPane, LPSTR lpszText, int* pType = NULL) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(nPane < 256);
        DWORD dw = ::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane, (LPARAM)lpszText);
        if(pType != NULL)
            *pType = HIWORD(dw);
        return LOWORD(dw);
    }
#ifndef _ATL_NO_COM
    BOOL GetTextBSTR(int nPane, BSTR& bstrText, int* pType = NULL) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(nPane < 256);
        ATLASSERT(bstrText == NULL);
        int nLength = LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
        if(nLength == 0)
            return FALSE;

        LPSTR lpszText = (LPSTR)_alloca((nLength + 1) * sizeof(char));
        if(!GetText(nPane, lpszText, pType))
            return FALSE;

        bstrText = ::SysAllocString(A2W(lpszText));
        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
    int GetTextLength(int nPane, int* pType = NULL) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(nPane < 256);
        DWORD dw = ::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L);
        if (pType != NULL)
            *pType = HIWORD(dw);
        return LOWORD(dw);
    }
    BOOL SetParts(int nParts, int* pWidths)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths);
    }
    int GetParts(int nParts, int* pParts) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts);
    }
    BOOL GetBorders(int* pBorders) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders);
    }
    BOOL GetBorders(int& nHorz, int& nVert, int& nSpacing) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        int borders[3];
        BOOL bResult = (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)&borders);
        if (bResult)
        {
            nHorz = borders[0];
            nVert = borders[1];
            nSpacing = borders[2];
        }
        return bResult;
    }
    void SetMinHeight(int nMin)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L);
    }
    BOOL SetSimple(BOOL bSimple = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L);
    }
    BOOL GetRect(int nPane, LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect);
    }

    // new common control support
    BOOL IsSimple() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0L);
    }
};

typedef CStatusBarCtrlT<CWindow>    CStatusBarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

template <class Base>
class CTabCtrlT : public Base
{
public:
// Constructors
    CTabCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CTabCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return WC_TABCONTROL;
    }

    HIMAGELIST GetImageList() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)hImageList);
    }
    int GetItemCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L);
    }
    BOOL GetItem(int nItem, TC_ITEM* pTabCtrlItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem);
    }
    BOOL SetItem(int nItem, TC_ITEM* pTabCtrlItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem);
    }
    BOOL GetItemRect(int nItem, LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect);
    }
    int GetCurSel() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L);
    }
    int SetCurSel(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L);
    }
    SIZE SetItemSize(SIZE size)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dwSize = ::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));
        SIZE sizeRet;
        sizeRet.cx = LOWORD(dwSize);
        sizeRet.cy = HIWORD(dwSize);
        return sizeRet;
    }
    void SetPadding(SIZE size)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));
    }
    int GetRowCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L);
    }
    HWND GetTooltips() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L);
    }
    void SetTooltips(HWND hWndToolTip)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
    }
    int GetCurFocus() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L);
    }

// Operations
    BOOL InsertItem(int nItem, TC_ITEM* pTabCtrlItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem);
    }
    BOOL DeleteItem(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L);
    }
    BOOL DeleteAllItems()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L);
    }
    void AdjustRect(BOOL bLarger, LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
    }
    void RemoveImage(int nImage)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L);
    }
    int HitTest(TC_HITTESTINFO* pHitTestInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM)pHitTestInfo);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    DWORD GetExtendedStyle()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0L);
    }
    DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
    }
    int SetMinTabWidth(int nWidth = -1)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, nWidth);
    }
    void DeselectAll(BOOL bExcludeFocus = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TCM_DESELECTALL, bExcludeFocus, 0L);
    }
    BOOL HighlightItem(int nIndex, BOOL bHighlight = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, nIndex, MAKELPARAM(bHighlight, 0));
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTabCtrlT<CWindow>  CTabCtrl;

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolInfo : public TOOLINFO
{
public:
/**/    TCHAR m_szText[256];

/**/    operator LPTOOLINFO() { return this; }
/**/    operator LPARAM() { return (LPARAM)this; }

    void Fill(HWND hWnd, UINT nIDTool)
    {
        memset(this, 0, sizeof(TOOLINFO));
        cbSize = sizeof(TOOLINFO);
        if(nIDTool == 0)
        {
            hwnd = ::GetParent(hWnd);
            uFlags = TTF_IDISHWND;
            uId = (UINT_PTR)hWnd;
        }
        else
        {
            hwnd = hWnd;
            uFlags = 0;
            uId = nIDTool;
        }
    }
};

template <class Base>
class CToolTipCtrlT : public Base
{
public:
// Constructors
    CToolTipCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CToolTipCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return TOOLTIPS_CLASS;
    }

    void GetText(LPTOOLINFO lpToolInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_GETTEXT, 0, (LPARAM)&lpToolInfo);
    }
    void GetText(LPTSTR lpstrText, HWND hWnd, UINT nIDTool = 0) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);

//      TOOLINFO ti;
//      FillInToolInfo(ti, hWnd, nIDTool);
        CToolInfo ti;
        ti.Fill(hWnd, nIDTool);
        ti.lpszText = lpstrText;    // should be 256 characters long
        ::SendMessage(m_hWnd, TTM_GETTEXT, 0, ti);
    }
    BOOL GetToolInfo(LPTOOLINFO lpToolInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)lpToolInfo);
    }
    BOOL GetToolInfo(HWND hWnd, UINT nIDTool, UINT* puFlags, LPRECT lpRect, LPTSTR lpstrText) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);

        TOOLINFO ti;
        FillInToolInfo(ti, hWnd, nIDTool);
        ti.lpszText = lpstrText;
        BOOL bRet = (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)&ti);
        if(bRet)
        {
            *puFlags = ti.uFlags;
            memcpy(lpRect, &(ti.rect), sizeof(RECT));
        }
        return bRet;
    }
    void SetToolInfo(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo);
    }
    void SetToolRect(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)lpToolInfo);
    }
    void SetToolRect(HWND hWnd, UINT nIDTool, LPCRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);
        ATLASSERT(nIDTool != 0);

        TOOLINFO ti;
        FillInToolInfo(ti, hWnd, nIDTool);
        memcpy(&ti.rect, lpRect, sizeof(RECT));
        ::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
    }
    int GetToolCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L);
    }

// Operations
    void Activate(BOOL bActivate)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L);
    }
    BOOL AddTool(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)lpToolInfo);
    }
    BOOL AddTool(HWND hWnd, LPCTSTR lpszText = LPSTR_TEXTCALLBACK, LPCRECT lpRectTool = NULL, UINT nIDTool = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);
        ATLASSERT(lpszText != NULL);
        // the toolrect and toolid must both be zero or both valid
        ATLASSERT((lpRectTool != NULL && nIDTool != 0) || (lpRectTool == NULL && nIDTool == 0));

        TOOLINFO ti;
        FillInToolInfo(ti, hWnd, nIDTool);
        if(lpRectTool != NULL)
            memcpy(&ti.rect, lpRectTool, sizeof(RECT));
        ti.hinst = _Module.GetResourceInstance();   // needed only if lpszText is from MAKEINTRESOURCE
        ti.lpszText = (LPTSTR)lpszText;
        return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
    }
    BOOL AddTool(HWND hWnd, UINT nIDText, LPCRECT lpRectTool = NULL, UINT nIDTool = 0)
    {
        ATLASSERT(nIDText != 0);
        return AddTool(hWnd, MAKEINTRESOURCE(nIDText), lpRectTool, nIDTool);
    }
    void DelTool(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)lpToolInfo);
    }
    void DelTool(HWND hWnd, UINT nIDTool = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);

        TOOLINFO ti;
        FillInToolInfo(ti, hWnd, nIDTool);
        ::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)&ti);
    }
    BOOL HitTest(LPTTHITTESTINFO lpHitTestInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)lpHitTestInfo);
    }
    BOOL HitTest(HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);
        ATLASSERT(lpToolInfo != NULL);

        TTHITTESTINFO hti;
        memset(&hti, 0, sizeof(hti));
        hti.ti.cbSize = sizeof(TOOLINFO);
        hti.hwnd = hWnd;
        hti.pt.x = pt.x;
        hti.pt.y = pt.y;
        if((BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)&hti))
        {
            memcpy(lpToolInfo, &hti.ti, sizeof(TOOLINFO));
            return TRUE;
        }
        return FALSE;
    }
    void RelayEvent(LPMSG lpMsg)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg);
    }
    void SetDelayTime(UINT nDelay)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay);
    }
    void UpdateTipText(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)lpToolInfo);
    }
    void UpdateTipText(LPCTSTR lpszText, HWND hWnd, UINT nIDTool = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(hWnd != NULL);

        TOOLINFO ti;
        FillInToolInfo(ti, hWnd, nIDTool);
        ti.hinst = _Module.GetResourceInstance();
        ti.lpszText = (LPTSTR)lpszText;
        ::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
    }
    void UpdateTipText(UINT nIDText, HWND hWnd, UINT nIDTool = 0)
    {
        ATLASSERT(nIDText != 0);
        UpdateTipText(MAKEINTRESOURCE(nIDText), hWnd, nIDTool);
    }

// Implementation
/**/    static void FillInToolInfo(TOOLINFO& ti, HWND hWnd, UINT nIDTool)
    {
        memset(&ti, 0, sizeof(ti));
        ti.cbSize = sizeof(ti);
        if (nIDTool == 0)
        {
            ti.hwnd = ::GetParent(hWnd);
            ti.uFlags = TTF_IDISHWND;
            ti.uId = (UINT)hWnd;
        }
        else
        {
            ti.hwnd = hWnd;
            ti.uFlags = 0;
            ti.uId = nIDTool;
        }
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    int GetDelayTime(DWORD dwType)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwType, 0L);
    }
    void SetDelayTime(DWORD dwType, int nTime)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwType, MAKELPARAM(nTime, 0));
    }
    void GetMargin(LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lpRect);
    }
    void SetMargin(LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lpRect);
    }
    int GetMaxTipWidth()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L);
    }
    int SetMaxTipWidth(int nWidth)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, nWidth);
    }
    COLORREF GetTipBkColor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L);
    }
    void SetTipBkColor(COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, (WPARAM)clr, 0L);
    }
    COLORREF GetTipTextColor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L);
    }
    void SetTipTextColor(COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, (WPARAM)clr, 0L);
    }
    BOOL GetCurrentTool(LPTOOLINFO lpToolInfo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo);
    }
    void Pop()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_POP, 0, 0L);
    }
    void TrackActivate(LPTOOLINFO lpToolInfo, BOOL bActivate)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_TRACKACTIVATE, bActivate, (LPARAM)lpToolInfo);
    }
    void TrackPosition(int xPos, int yPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TTM_TRACKPOSITION, 0, MAKELPARAM(xPos, yPos));
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CToolTipCtrlT<CWindow>      CToolTipCtrl;

/////////////////////////////////////////////////////////////////////////////
// CTrackBarCtrl

template <class Base>
class CTrackBarCtrlT : public Base
{
public:
// Constructors
    CTrackBarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CTrackBarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return TRACKBAR_CLASS;
    }

    int GetLineSize() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0L);
    }
    int SetLineSize(int nSize)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize);
    }
    int GetPageSize() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0L);
    }
    int SetPageSize(int nSize)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize);
    }
    int GetRangeMax() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0L);
    }
    int GetRangeMin() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0L);
    }
    void GetRange(int& nMin, int& nMax) const
    {
        nMin = GetRangeMin();
        nMax = GetRangeMax();
    }
    void SetRangeMin(int nMin, BOOL bRedraw = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin);
    }
    void SetRangeMax(int nMax, BOOL bRedraw = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax);
    }
    void SetRange(int nMin, int nMax, BOOL bRedraw = FALSE)
    {
        SetRangeMin(nMin, bRedraw);
        SetRangeMax(nMax, bRedraw);
    }
    int GetSelStart() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TBM_GETSELSTART, 0, 0L);
    }
    int GetSelEnd() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, TBM_GETSELEND, 0, 0L);
    }
    void GetSelection(int& nMin, int& nMax) const
    {
        nMin = GetSelStart();
        nMax = GetSelEnd();
    }
    void SetSelStart(int nMin)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETSELSTART, 0, (LPARAM)nMin);
    }
    void SetSelEnd(int nMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETSELEND, 0, (LPARAM)nMax);
    }
    void SetSelection(int nMin, int nMax)
    {
        SetSelStart(nMin);
        SetSelEnd(nMin);
    }
    void GetChannelRect(LPRECT lprc) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc);
    }
    void GetThumbRect(LPRECT lprc) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc);
    }
    int GetPos() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETPOS, 0, 0L);
    }
    void SetPos(int nPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos);
    }
    UINT GetNumTics() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0L);
    }
    DWORD* GetTicArray() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD*)::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0L);
    }
    int GetTic(int nTic) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L);
    }
    int GetTicPos(int nTic) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L);
    }
    BOOL SetTic(int nTic)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic);
    }
    void SetTicFreq(int nFreq)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L);
    }

// Operations
    void ClearSel(BOOL bRedraw = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0L);
    }
    void VerifyPos()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETPOS, FALSE, 0L);
    }
    void ClearTics(BOOL bRedraw = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0L);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    HWND GetBuddy(BOOL bLeft = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TBM_GETBUDDY, bLeft, 0L);
    }
    HWND SetBuddy(HWND hWndBuddy, BOOL bLeft = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TBM_SETBUDDY, bLeft, (LPARAM)hWndBuddy);
    }
    HWND GetToolTips()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L);
    }
    void SetToolTips(HWND hWndTT)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)hWndTT, 0L);
    }
    int SetTipSide(int nSide)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nSide, 0L);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTrackBarCtrlT<CWindow>     CTrackBarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CUpDownCtrl

template <class Base>
class CUpDownCtrlT : public Base
{
public:
// Constructors
    CUpDownCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CUpDownCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return UPDOWN_CLASS;
    }

    BOOL SetAccel(int nAccel, UDACCEL* pAccel)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel));
    }
    UINT GetAccel(int nAccel, UDACCEL* pAccel) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel));
    }
    int SetBase(int nBase)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L);
    }
    UINT GetBase() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0L));
    }
    HWND SetBuddy(HWND hWndBuddy)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)hWndBuddy, 0L);
    }
    HWND GetBuddy() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0L);
    }
    int SetPos(int nPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)(short)LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0)));
    }
    int GetPos() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, UDM_GETPOS, 0, 0L);
    }
    void SetRange(int nLower, int nUpper)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower));
    }
    DWORD GetRange() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
    }
    void GetRange(int& nLower, int& nUpper) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dwRet = ::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
        nLower = (int)(short)HIWORD(dwRet);
        nUpper = (int)(short)LOWORD(dwRet);
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    void SetRange32(int nLower, int nUpper)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, UDM_SETRANGE32, nLower, nUpper);
    }
    void GetRange32(int& nLower, int& nUpper) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM)&nLower, (LPARAM)&nUpper);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CUpDownCtrlT<CWindow>       CUpDownCtrl;

/////////////////////////////////////////////////////////////////////////////
// CProgressBarCtrl

template <class Base>
class CProgressBarCtrlT : public Base
{
public:
// Constructors
    CProgressBarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CProgressBarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return PROGRESS_CLASS;
    }

    DWORD SetRange(int nLower, int nUpper)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));
    }
    int SetPos(int nPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)LOWORD(::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L));
    }
    int OffsetPos(int nPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)LOWORD(::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L));
    }
    int SetStep(int nStep)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)LOWORD(::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L));
    }

// Operations
    int StepIt()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int) LOWORD(::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L));
    }

    // new common control support
#if (_WIN32_IE >= 0x0400)
    UINT GetPos()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, PBM_GETPOS, 0, 0L);
    }
    void GetRange(PPBRANGE pPBRange)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(pPBRange != NULL);
        ::SendMessage(m_hWnd, PBM_GETRANGE, TRUE, (LPARAM)pPBRange);
    }
    int GetRangeLimit(BOOL bLimit)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PBM_GETRANGE, bLimit, (LPARAM)NULL);
    }
    DWORD SetRange32(int nMin, int nMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE32, nMin, nMax);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CProgressBarCtrlT<CWindow>  CProgressBarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

template <class Base>
class CHotKeyCtrlT : public Base
{
public:
// Constructors
    CHotKeyCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CHotKeyCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return HOTKEY_CLASS;
    }

    void SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L);
    }
    DWORD GetHotKey() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
    }
    void GetHotKey(WORD &wVirtualKeyCode, WORD &wModifiers) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dw = ::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
        wVirtualKeyCode = LOBYTE(LOWORD(dw));
        wModifiers = HIBYTE(LOWORD(dw));
    }

// Operations
    void SetRules(WORD wInvalidComb, WORD wModifiers)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0));
    }
};

typedef CHotKeyCtrlT<CWindow>       CHotKeyCtrl;

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

template <class Base>
class CAnimateCtrlT : public Base
{
public:
// Constructors
    CAnimateCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CAnimateCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Operations
    static LPCTSTR GetWndClassName()
    {
        return ANIMATE_CLASS;
    }

    BOOL Open(LPCTSTR lpszFileName)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, (LPARAM)lpszFileName);
    }
    BOOL Open(UINT nID)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, (LPARAM)MAKEINTRESOURCE(nID));
    }
    BOOL Play(UINT nFrom, UINT nTo, UINT nRep)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo));
    }
    BOOL Stop()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L);
    }
    BOOL Close()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L);
    }
    BOOL Seek(UINT nTo)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo));
    }
};

typedef CAnimateCtrlT<CWindow>      CAnimateCtrl;

/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

#ifndef UNDER_CE

#include <richedit.h>
#include <richole.h>

#ifdef _UNICODE
#if (_RICHEDIT_VER == 0x0100)
#undef RICHEDIT_CLASS
#define RICHEDIT_CLASS  L"RICHEDIT"
#endif //(_RICHEDIT_VER == 0x0100)
#endif //_UNICODE

template <class Base>
class CRichEditCtrlT : public Base
{
public:
// Constructors
    CRichEditCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CRichEditCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return RICHEDIT_CLASS;
    }

    BOOL CanUndo() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
    }
    int GetLineCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
    }
    BOOL GetModify() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
    }
    void SetModify(BOOL bModified = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
    }
    void GetRect(LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
    }
    POINT GetCharPos(long lChar) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        POINT pt;
        ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar);
        return pt;
    }
    UINT SetOptions(WORD wOp, DWORD dwFlags)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags);
    }

    // NOTE: first word in lpszBuffer must contain the size of the buffer!
    int GetLine(int nIndex, LPTSTR lpszBuffer) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
    }
    int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        *(LPINT)lpszBuffer = nMaxLength;
        return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
    }

    BOOL CanPaste(UINT nFormat = 0) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
    }
    void GetSel(long& nStartChar, long& nEndChar) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        CHARRANGE cr;
        ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
        nStartChar = cr.cpMin;
        nEndChar = cr.cpMax;
    }
    void GetSel(CHARRANGE &cr) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
    }
    void LimitText(long nChars = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars);
    }
    long LineFromChar(long nIndex) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex);
    }
    int SetSel(long nStartChar, long nEndChar)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        CHARRANGE cr;
        cr.cpMin = nStartChar;
        cr.cpMax = nEndChar;
        return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
    }
    int SetSel(CHARRANGE &cr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
    }
    DWORD GetDefaultCharFormat(CHARFORMAT &cf) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        cf.cbSize = sizeof(CHARFORMAT);
        return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
    }
    DWORD GetSelectionCharFormat(CHARFORMAT &cf) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        cf.cbSize = sizeof(CHARFORMAT);
        return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
    }
    long GetEventMask() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L);
    }
    long GetLimitText() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
    }
    DWORD GetParaFormat(PARAFORMAT &pf) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        pf.cbSize = sizeof(PARAFORMAT);
        return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
    }
    // richedit EM_GETSELTEXT is ANSI
    long GetSelText(LPSTR lpBuf) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf);
    }
#ifndef _ATL_NO_COM
    BOOL GetSelTextBSTR(BSTR& bstrText) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(bstrText == NULL);

        CHARRANGE cr;
        cr.cpMin = cr.cpMax = 0;
        ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
        LPSTR lpstrText = (char*)_alloca((cr.cpMax - cr.cpMin + 1) * 2);
        lpstrText[0] = 0;
        if(::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText) == 0)
            return FALSE;

        bstrText = ::SysAllocString(A2W(lpstrText));
        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
    WORD GetSelectionType() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L);
    }
    COLORREF SetBackgroundColor(BOOL bSysColor, COLORREF cr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr);
    }
    BOOL SetDefaultCharFormat(CHARFORMAT &cf)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        cf.cbSize = sizeof(CHARFORMAT);
        return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    }
    BOOL SetSelectionCharFormat(CHARFORMAT &cf)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        cf.cbSize = sizeof(CHARFORMAT);
        return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
    }
    BOOL SetWordCharFormat(CHARFORMAT &cf)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        cf.cbSize = sizeof(CHARFORMAT);
        return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
    }
    DWORD SetEventMask(DWORD dwEventMask)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask);
    }
    BOOL SetParaFormat(PARAFORMAT &pf)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        pf.cbSize = sizeof(PARAFORMAT);
        return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
    }
    BOOL SetTargetDevice(HDC hDC, long lLineWidth)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth);
    }
    long GetTextLength() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0L);
    }
    BOOL SetReadOnly(BOOL bReadOnly = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
    }
    int GetFirstVisibleLine() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
    }

// Operations
    void EmptyUndoBuffer()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
    }

    int LineIndex(int nLine = -1) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
    }
    int LineLength(int nLine = -1) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
    }
    BOOL LineScroll(int nLines, int nChars = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
    }
    void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
    }
    void SetRect(LPCRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
    }

    BOOL DisplayBand(LPRECT pDisplayRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect);
    }
    long FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText);
    }
    long FormatRange(FORMATRANGE* pfr, BOOL bDisplay = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr);
    }
    void HideSelection(BOOL bHide, BOOL bPerm)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm);
    }
    void PasteSpecial(UINT nClipFormat, DWORD dvAspect = 0, HMETAFILE hMF = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        REPASTESPECIAL reps;
        reps.dwAspect = dvAspect;
        reps.dwParam = (DWORD)hMF;
        ::SendMessage(m_hWnd, EM_PASTESPECIAL, nClipFormat, (LPARAM)&reps);
    }
    void RequestResize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L);
    }
    long StreamIn(int nFormat, EDITSTREAM& es)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es);
    }
    long StreamOut(int nFormat, EDITSTREAM& es)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es);
    }

    // Additional operations
    void ScrollCaret()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
    }
    int InsertText(long nInsertAfterChar, LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
    {
        int nRet = SetSel(nInsertAfterChar, nInsertAfterChar);
        ReplaceSel(lpstrText, bCanUndo);
        return nRet;
    }
    int AppendText(LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
    {
        return InsertText(GetWindowTextLength(), lpstrText, bCanUndo);
    }

    // Clipboard operations
    BOOL Undo()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
    }
    void Clear()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
    }
    void Copy()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_COPY, 0, 0L);
    }
    void Cut()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_CUT, 0, 0L);
    }
    void Paste()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
    }

// OLE support
    IRichEditOle* GetIRichEditOle() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        IRichEditOle *pRichItem = NULL;
        ::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichItem);
        return pRichItem;
    }
    BOOL SetOLECallback(IRichEditOleCallback* pCallback)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback);
    }
};

typedef CRichEditCtrlT<CWindow>     CRichEditCtrl;

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CDragListBox

template <class Base>
class CDragListBoxT : public CListBoxT< Base >
{
public:
// Constructors
    CDragListBoxT(HWND hWnd = NULL) : CListBoxT< Base >(hWnd) { }

    CDragListBoxT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Operations
    BOOL MakeDragList()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(!(GetStyle() & LBS_MULTIPLESEL));
        BOOL bRet = ::MakeDragList(m_hWnd);
        UINT& uMsg = GetDragListMessage();
        if(uMsg == 0)
        {
/*?*/           ::EnterCriticalSection(&_Module.m_csWindowCreate);
            if(uMsg == 0)
                uMsg = ::RegisterWindowMessage(DRAGLISTMSGSTRING);
/*?*/           ::LeaveCriticalSection(&_Module.m_csWindowCreate);
        }
        ATLASSERT(uMsg != 0);
        return bRet;
    }

    int LBItemFromPt(POINT pt, BOOL bAutoScroll = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::LBItemFromPt(m_hWnd, pt, bAutoScroll);
    }

    void DrawInsert(int nItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::DrawInsert(GetParent(), m_hWnd, nItem);
    }

    static UINT& GetDragListMessage()
    {
        static UINT m_uDragListMessage = 0;
        return m_uDragListMessage;
    }
};

typedef CDragListBoxT<CWindow>      CDragListBox;

template <class T>
class CDragListNotifyImpl
{
public:
    BEGIN_MSG_MAP(CDragListNotifyImpl< T >)
        MESSAGE_HANDLER(CDragList::GetDragListMessage(), OnDragListNotify)
    END_MSG_MAP()

    LRESULT OnDragListNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if(uMsg == 0)   // message not registered
        {
            bHandled = FALSE;
            return 1;
        }
        T* pT = static_cast<T*>(this);
        LPDRAGLISTINFO lpDragListInfo = (LPDRAGLISTINFO)lParam;
        LRESULT lRet = 0;
        switch(lpDragListInfo->uNotification)
        {
        case DL_BEGINDRAG:
            lRet = (LPARAM)pT->OnBeginDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
            break;
        case DL_CANCELDRAG:
            pT->OnCancelDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
            break;
        case DL_DRAGGING:
            lRet = (LPARAM)pT->OnDragging((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
            break;
        case DL_DROPPED:
            pT->OnDropped((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
            break;
        default:
            ATLTRACE2(atlTraceWindowing, 0, _T("Unknown DragListBox notification\n"));
            bHandled = FALSE;   // don't handle it
            break;
        }
        return lRet;
    }

    BOOL OnBeginDrag(int nCtlID, HWND hWndDragList, POINT ptCursor)
    {
        return TRUE;    // allow dragging
    }
    void OnCancelDrag(int nCtlID, HWND hWndDragList, POINT ptCursor)
    {
        // nothing to do
    }
    int OnDragging(int nCtlID, HWND hWndDragList, POINT ptCursor)
    {
        return 0;   // don't change cursor
    }
    void OnDropped(int nCtlID, HWND hWndDragList, POINT ptCursor)
    {
        // nothing to do
    }
};


// --- New Windows Common Controls ---

/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

template <class Base>
class CReBarCtrlT : public Base
{
public:
// Constructors
    CReBarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CReBarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return REBARCLASSNAME;
    }

#if (_WIN32_IE >= 0x0400)
    COLORREF GetTextColor() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L);
    }
    COLORREF SetTextColor(COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr);
    }
    COLORREF GetBkColor() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L);
    }
    COLORREF SetBkColor(COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr);
    }
#endif //(_WIN32_IE >= 0x0400)
    UINT GetBandCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L);
    }
    BOOL GetBandInfo(int nBand, LPREBARBANDINFO lprbbi) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_GETBANDINFO, nBand, (LPARAM)lprbbi);
    }
    BOOL SetBandInfo(int nBand, LPREBARBANDINFO lprbbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_SETBANDINFO, nBand, (LPARAM)lprbbi);
    }
    BOOL GetBarInfo(LPREBARINFO lprbi) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)lprbi);
    }
    BOOL SetBarInfo(LPREBARINFO lprbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)lprbi);
    }
#if (_WIN32_IE >= 0x0400)
    UINT GetBarHeight() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L);
    }
    BOOL GetRect(int nBand, LPRECT lpRect) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_GETRECT, nBand, (LPARAM)lpRect);
    }
#endif //(_WIN32_IE >= 0x0400)
    UINT GetRowCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L);
    }
    UINT GetRowHeight(int nBand) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (UINT)::SendMessage(m_hWnd, RB_GETROWHEIGHT, nBand, 0L);
    }
#if (_WIN32_IE >= 0x0400)
    HWND GetToolTips() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L);
    }
    void SetToolTips(HWND hwndToolTip)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)hwndToolTip, 0L);
    }
#endif //(_WIN32_IE >= 0x0400)

// Operations
#if (_WIN32_IE >= 0x0400)
    void BeginDrag(int nBand, DWORD dwPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, dwPos);
    }
    void BeginDrag(int nBand, int xPos, int yPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, MAKELPARAM(xPos, yPos));
    }
    void EndDrag()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L);
    }
    void DragMove(DWORD dwPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos);
    }
    void DragMove(int xPos, int yPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_DRAGMOVE, 0, MAKELPARAM(xPos, yPos));
    }
    void GetDropTarget(IDropTarget** ppDropTarget) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
    }
#endif //(_WIN32_IE >= 0x0400)
    BOOL InsertBand(int nBand, LPREBARBANDINFO lprbbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        lprbbi->cbSize = sizeof(REBARBANDINFO);
        return (BOOL)::SendMessage(m_hWnd, RB_INSERTBAND, nBand, (LPARAM)lprbbi);
    }
    BOOL DeleteBand(int nBand)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_DELETEBAND, nBand, 0L);
    }
#if (_WIN32_IE >= 0x0400)
    void MaximizeBand(int nBand)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, nBand, 0L);
    }
    void MinimizeBand(int nBand)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, RB_MINIMIZEBAND, nBand, 0L);
    }
    BOOL SizeToRect(LPRECT lpRect)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)lpRect);
    }
#endif //(_WIN32_IE >= 0x0400)
    HWND SetNotifyWnd(HWND hWnd)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)hWnd, 0L);
    }
#if (_WIN32_IE >= 0x0400)
    int IdToIndex(UINT uBandID) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L);
    }
    int HitTest(LPRBHITTESTINFO lprbht) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)lprbht);
    }
#endif //(_WIN32_IE >= 0x0400)
};

typedef CReBarCtrlT<CWindow>        CReBarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

template <class Base>
class CComboBoxExT : public CComboBoxT< Base >
{
public:
// Constructors
    CComboBoxExT(HWND hWnd = NULL) : CComboBoxT< Base >(hWnd) { }

    CComboBoxExT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return WC_COMBOBOXEX;
    }

#if (_WIN32_IE >= 0x0400)
    DWORD GetExtendedStyle() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0L);
    }
    DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
    }
#endif //(_WIN32_IE >= 0x0400)
    HIMAGELIST GetImageList() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0L);
    }
    HIMAGELIST SetImageList(HIMAGELIST hImageList)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HIMAGELIST)::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)hImageList);
    }

// Operations
    int InsertItem(const COMBOBOXEXITEM FAR* lpcCBItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)lpcCBItem);
    }
    int DeleteItem(int nIndex)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, CBEM_DELETEITEM, nIndex, 0L);
    }
    BOOL GetItem(PCOMBOBOXEXITEM pCBItem) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)pCBItem);
    }
    BOOL SetItem(const COMBOBOXEXITEM FAR* lpcCBItem)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)lpcCBItem);
    }
    HWND GetComboCtrl() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0L);
    }
    HWND GetEditCtrl() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0L);
    }
    BOOL HasEditChanged() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0L);
    }
};

typedef CComboBoxExT<CWindow>       CComboBoxEx;

/////////////////////////////////////////////////////////////////////////////
// CDateTimePickerCtrl

template <class Base>
class CDateTimePickerCtrlT : public Base
{
public:
// Constructors
    CDateTimePickerCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CDateTimePickerCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Operations
    static LPCTSTR GetWndClassName()
    {
        return DATETIMEPICK_CLASS;
    }

    BOOL SetFormat(LPTSTR lpszFormat)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM)lpszFormat);
    }
    COLORREF GetMonthCalColor(int nColorType) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, DTM_GETMCCOLOR, nColorType, 0L);
    }
    COLORREF SetMonthCalColor(int nColorType, COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, DTM_SETMCCOLOR, nColorType, clr);
    }
#if (_WIN32_IE >= 0x0400)
    HFONT GetMonthCalFont() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HFONT)::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0L);
    }
    void SetMonthCalFont(HFONT hFont, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
    }
#endif //(_WIN32_IE >= 0x0400)
    DWORD GetRange(LPSYSTEMTIME lpSysTimeArray) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM)lpSysTimeArray);
    }
    BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, DTM_SETRANGE, dwFlags, (LPARAM)lpSysTimeArray);
    }
    DWORD GetSystemTime(LPSYSTEMTIME lpSysTime) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM)lpSysTime);
    }
    BOOL SetSystemTime(DWORD dwFlags, LPSYSTEMTIME lpSysTime)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, DTM_SETSYSTEMTIME, dwFlags, (LPARAM)lpSysTime);
    }
    HWND GetMonthCal() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (HWND)::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0L);
    }
};

typedef CDateTimePickerCtrlT<CWindow>       CDateTimePickerCtrl;

/////////////////////////////////////////////////////////////////////////////
// CMonthCalendarCtrl

template <class Base>
class CMonthCalendarCtrlT : public Base
{
public:
// Constructors
    CMonthCalendarCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CMonthCalendarCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return MONTHCAL_CLASS;
    }

    COLORREF GetColor(int nColorType) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, MCM_GETCOLOR, nColorType, 0L);
    }
    COLORREF SetColor(int nColorType, COLORREF clr)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, MCM_SETCOLOR, nColorType, clr);
    }
    BOOL GetCurSel(LPSYSTEMTIME lpSysTime) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM)lpSysTime);
    }
    BOOL SetCurSel(LPSYSTEMTIME lpSysTime)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM)lpSysTime);
    }
    int GetFirstDayOfWeek(BOOL* pbLocaleVal = NULL) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dwRet = ::SendMessage(m_hWnd, MCM_GETFIRSTDAYOFWEEK, 0, 0L);
        if(pbLocaleVal != NULL)
            *pbLocaleVal = HIWORD(dwRet);
        return (int)LOWORD(dwRet);
    }
    int SetFirstDayOfWeek(int nDay, BOOL* pbLocaleVal = NULL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        DWORD dwRet = ::SendMessage(m_hWnd, MCM_SETFIRSTDAYOFWEEK, 0, nDay);
        if(pbLocaleVal != NULL)
            *pbLocaleVal = HIWORD(dwRet);
        return (int)LOWORD(dwRet);
    }
    int GetMaxSelCount() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0L);
    }
    BOOL SetMaxSelCount(int nMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0L);
    }
    int GetMonthDelta() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0L);
    }
    int SetMonthDelta(int nDelta)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, MCM_SETMONTHDELTA, nDelta, 0L);
    }
    DWORD GetRange(LPSYSTEMTIME lprgSysTimeArray) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM)lprgSysTimeArray);
    }
    BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_SETRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
    }
    BOOL GetSelRange(LPSYSTEMTIME lprgSysTimeArray) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
    }
    BOOL SetSelRange(LPSYSTEMTIME lprgSysTimeArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
    }
    BOOL GetToday(LPSYSTEMTIME lpSysTime) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM)lpSysTime);
    }
    void SetToday(LPSYSTEMTIME lpSysTime)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM)lpSysTime);
    }
    BOOL GetMinReqRect(LPRECT lpRectInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM)lpRectInfo);
    }

// Operations
    int GetMonthRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, MCM_GETMONTHRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
    }
    BOOL SetDayState(int nMonths, LPMONTHDAYSTATE lpDayStateArray)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, MCM_SETDAYSTATE, nMonths, (LPARAM)lpDayStateArray);
    }
    DWORD HitTest(PMCHITTESTINFO pMCHitTest) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM)pMCHitTest);
    }
};

typedef CMonthCalendarCtrlT<CWindow>        CMonthCalendarCtrl;

/////////////////////////////////////////////////////////////////////////////
// CFlatScrollBar

#if (_WIN32_IE >= 0x0400)

template <class Base>
class CFlatScrollBarT : public Base
{
public:
// Constructors
    CFlatScrollBarT(HWND hWnd = NULL) : Base(hWnd) { }

    CFlatScrollBarT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

// Initialization
    BOOL FlatSB_Initialize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::InitializeFlatSB(m_hWnd);
    }
    HRESULT FlatSB_Uninitialize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::UninitializeFlatSB(m_hWnd);
    }

// Attributes
    BOOL FlatSB_GetScrollProp(UINT uIndex, LPINT lpnValue) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_GetScrollProp(m_hWnd, uIndex, lpnValue);
    }
    BOOL FlatSB_SetScrollProp(UINT uIndex, int nValue, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_SetScrollProp(m_hWnd, uIndex, nValue, bRedraw);
    }

    int FlatSB_GetScrollPos(int nBar) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_GetScrollPos(m_hWnd, nBar);
    }

    int FlatSB_SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
    }

    BOOL FlatSB_GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
    }

    BOOL FlatSB_SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
    }

    BOOL FlatSB_GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
    }

    int FlatSB_SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
    }

// Operations
    BOOL FlatSB_ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_ShowScrollBar(m_hWnd, nBar, bShow);
    }

    BOOL FlatSB_EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return ::FlatSB_EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
    }
};

typedef CFlatScrollBarT<CWindow>    CFlatScrollBar;

#endif //(_WIN32_IE >= 0x0400)

/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

#if (_WIN32_IE >= 0x0400)

template <class Base>
class CIPAddressCtrlT : public Base
{
public:
// Constructors
    CIPAddressCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CIPAddressCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Atteributes
    static LPCTSTR GetWndClassName()
    {
        return WC_IPADDRESS;
    }

    BOOL IsBlank() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (BOOL)::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L);
    }
    int GetAddress(LPDWORD lpdwAddress) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM)lpdwAddress);
    }
    void SetAddress(DWORD dwAddress)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, dwAddress);
    }
    void ClearAddress()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L);
    }
    void SetRange(int nField, WORD wRange)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, IPM_SETRANGE, nField, wRange);
    }
    void SetRange(int nField, BYTE nMin, BYTE nMax)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, IPM_SETRANGE, nField, MAKEIPRANGE(nMin, nMax));
    }
    void SetFocus(int nField)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, IPM_SETFOCUS, nField, 0L);
    }
};

typedef CIPAddressCtrlT<CWindow>        CIPAddressCtrl;

#endif //(_WIN32_IE >= 0x0400)

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

#if (_WIN32_IE >= 0x0400)

template <class Base>
class CPagerCtrlT : public Base
{
public:
// Constructors
    CPagerCtrlT(HWND hWnd = NULL) : Base(hWnd) { }

    CPagerCtrlT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
    HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
    {
        return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
    }

// Attributes
    static LPCTSTR GetWndClassName()
    {
        return WC_PAGESCROLLER;
    }

    int GetButtonSize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_GETBUTTONSIZE, 0, 0L);
    }
    int SetButtonSize(int nButtonSize)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_SETBUTTONSIZE, 0, nButtonSize);
    }
    DWORD GetButtonState(int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(nButton == PGB_TOPORLEFT || nButton == PGB_BOTTOMORRIGHT);
        return (DWORD)::SendMessage(m_hWnd, PGM_GETBUTTONSTATE, 0, nButton);
    }
    COLORREF GetBkColor()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, PGM_GETBKCOLOR, 0, 0L);
    }
    COLORREF SetBkColor(COLORREF clrBk)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (COLORREF)::SendMessage(m_hWnd, PGM_SETBKCOLOR, 0, (LPARAM)clrBk);
    }
    int GetBorder()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_GETBORDER, 0, 0L);
    }
    int SetBorder(int nBorderSize)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_SETBORDER, 0, nBorderSize);
    }
    int GetPos()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_GETPOS, 0, 0L);
    }
    int SetPos(int nPos)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return (int)::SendMessage(m_hWnd, PGM_SETPOS, 0, nPos);
    }

// Operations
    void SetChild(HWND hWndChild)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, PGM_SETCHILD, 0, (LPARAM)hWndChild);
    }
    void ForwardMouse(BOOL bForward = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, PGM_FORWARDMOUSE, bForward, 0L);
    }
    void RecalcSize()
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ::SendMessage(m_hWnd, PGM_RECALCSIZE, 0, 0L);
    }
    void GetDropTarget(IDropTarget** ppDropTarget)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        ATLASSERT(ppDropTarget != NULL);
        ::SendMessage(m_hWnd, PGM_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
    }
};

typedef CPagerCtrlT<CWindow>        CPagerCtrl;

#endif //(_WIN32_IE >= 0x0400)

/////////////////////////////////////////////////////////////////////////////
// CCustomDraw - MI class for custom-draw support

template <class T>
class CCustomDraw
{
public:
    BEGIN_MSG_MAP(CCustomDraw< T >)
        NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
    ALT_MSG_MAP(1)
        if(uMsg == OCM_NOTIFY && NM_CUSTOMDRAW == ((LPNMHDR)lParam)->code)
        {
            bHandled = TRUE;
            lResult = OnCustomDraw((int)wParam, (LPNMHDR)lParam, bHandled);
            if(bHandled)
                return TRUE;
        }
    END_MSG_MAP()

// message handler
    LRESULT OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
    {
        T* pT = static_cast<T*>(this);
        LPNMCUSTOMDRAW lpNMCustomDraw = (LPNMCUSTOMDRAW)pnmh;
        DWORD dwRet = 0;
        switch(lpNMCustomDraw->dwDrawStage)
        {
        case CDDS_PREPAINT:
            dwRet = pT->OnPrePaint(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_POSTPAINT:
            dwRet = pT->OnPostPaint(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_PREERASE:
            dwRet = pT->OnPreErase(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_POSTERASE:
            dwRet = pT->OnPostErase(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_ITEMPREPAINT:
            dwRet = pT->OnItemPrePaint(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_ITEMPOSTPAINT:
            dwRet = pT->OnItemPostPaint(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_ITEMPREERASE:
            dwRet = pT->OnItemPreErase(idCtrl, lpNMCustomDraw);
            break;
        case CDDS_ITEMPOSTERASE:
            dwRet = pT->OnItemPostErase(idCtrl, lpNMCustomDraw);
            break;
        default:
            bHandled = FALSE;
            break;
        }
        return dwRet;
    }

// overrideables
    DWORD OnPrePaint(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnPostPaint(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnPreErase(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnPostErase(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnItemPrePaint(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnItemPostPaint(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnItemPreErase(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
    DWORD OnItemPostErase(int idCtrl, LPNMCUSTOMDRAW lpNMCustomDraw)
    {
        return CDRF_DODEFAULT;
    }
};


// --- Windows CE common controls ---

#ifdef UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CCommandBar

template <class Base>
class CCommandBarT : public Base
{
public:
// Constructors
    CCommandBarT(HWND hWnd = NULL) : Base(hWnd) { }

    CCommandBarT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

// Attributes
    BOOL IsVisible() const
    {
        return IsWindowVisible();
    }
    int GetHeight() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_Height(m_hWnd);
    }
    HMENU GetMenu(int nButton) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_GetMenu(m_hWnd, nButton);
    }

// Operations
    HWND Create(HWND hWndParent, int nCmdBarID)
    {
        ATLASSERT(!::IsWindow(m_hWnd));
        return CommandBar_Create(_Module.GetModuleInstance(), hWndParent, nCmdBarID);
    }
    void Destroy()
    {
        DestroyWindow();
    }
    BOOL Show(BOOL bShow = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_Show(m_hWnd, bShow);
    }
    BOOL DrawMenuBar(int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_DrawMenuBar(m_hWnd, nButton);
    }

    BOOL AddAdornments(DWORD dwFlags = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_AddAdornments(m_hWnd, dwFlags, 0);
    }
    int AddBitmap(int nBitmapID, int nNumImages)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_AddBitmap(m_hWnd, _Module.GetResourceInstance(), nBitmapID, nNumImages, 0, 0);
    }
    BOOL AddButtons(UINT uNumButtons, LPTBBUTTON lpButtons)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_AddButtons(m_hWnd, uNumButtons, lpButtons);
    }
    BOOL AddToolTips(UINT uNumToolTips, LPTSTR lpToolTips)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_AddToolTips(m_hWnd, uNumToolTips, lpToolTips);
    }
    BOOL InsertButton(int nButton, LPTBBUTTON lpButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_InsertButton(m_hWnd, nButton, lpButton);
    }
    HWND InsertComboBox(int nWidth, UINT dwStyle, WORD wComboBoxID, int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_InsertComboBox(m_hWnd, _Module.GetModuleInstance(), nWidth, dwStyle, wComboBoxID, nButton);
    }
    BOOL InsertMenubar(WORD wMenuID, int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_InsertMenubar(m_hWnd, _Module.GetResourceInstance(), wMenuID, nButton);
    }
    BOOL InsertMenubarEx(WORD wMenuID, int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_InsertMenubarEx(m_hWnd, _Module.GetResourceInstance(), MAKEINTRESOURCE(wMenuID), nButton);
    }
    BOOL InsertMenubarEx(LPTSTR pszMenu, int nButton)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBar_InsertMenubarEx(m_hWnd, _Module.GetResourceInstance(), pszMenu, nButton);
    }
};

typedef CCommandBarT<CWindow>   CCommandBar;

/////////////////////////////////////////////////////////////////////////////
// CCommandBands

template <class Base>
class CCommandBandsT : public Base
{
public:
// Constructors
    CCommandBandsT(HWND hWnd = NULL) : Base(hWnd) { }

    CCommandBandsT< Base >& operator=(HWND hWnd)
    {
        m_hWnd = hWnd;
        return *this;
    }

// Attributes
    BOOL IsVisible() const
    {
        return IsWindowVisible();
    }
#if (_WIN32_IE >= 0x0400)
    UINT GetHeight() const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_Height(m_hWnd);
    }
#endif //(_WIN32_IE >= 0x0400)
    HWND GetCommandBar(UINT uBand) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_GetCommandBar(m_hWnd, uBand);
    }
    BOOL GetRestoreInformation(UINT uBand, LPCOMMANDBANDSRESTOREINFO pcbr) const
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_GetRestoreInformation(m_hWnd, uBand, pcbr);
    }

// Operations
    HWND Create(HWND hWndParent, UINT wID, DWORD dwStyles, HIMAGELIST hImageList = NULL)
    {
        ATLASSERT(!::IsWindow(m_hWnd));
        return CommandBands_Create(_Module.GetModuleInstance(), hWndParent, wID, dwStyles, hImageList);
    }
    BOOL AddAdornments(DWORD dwFlags = 0, LPREBARBANDINFO prbbi = NULL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_AddAdornments(m_hWnd, _Module.GetModuleInstance(), dwFlags, prbbi);
    }
    BOOL AddBands(UINT uBandCount, LPREBARBANDINFO prbbi)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_AddBands(m_hWnd, _Module.GetModuleInstance(), uBandCount, prbbi);
    }
    BOOL Show(BOOL bShow = TRUE)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        return CommandBands_Show(m_hWnd, bShow);
    }
};

typedef CCommandBandsT<CWindow> CCommandBands;

#endif //UNDER_CE

}; //namespace ATL

#endif // __ATLCTRLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atlgdi.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLGDI_H__
#define __ATLGDI_H__

#ifndef __cplusplus
    #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
    #error atlgdi.h requires atlbase.h to be included first
#endif

#include <commctrl.h>


#ifdef UNDER_CE

#ifdef TrackPopupMenu
#undef TrackPopupMenu
#endif //TrackPopupMenu

//REVIEW
BOOL IsMenu(HMENU hMenu)
{
    return (hMenu != NULL);
}

#endif //UNDER_CE


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CDC;
class CPaintDC;
class CClientDC;
class CWindowDC;
class CMenu;
class CPen;
class CBrush;
class CFont;
class CBitmap;
class CPalette;
class CRgn;

/////////////////////////////////////////////////////////////////////////////
// CDC - The device context class

class CDC
{
public:

// Attributes
    HDC m_hDC;

    BOOL m_bAutoRestore;

    HPEN m_hOriginalPen;
    HBRUSH m_hOriginalBrush;
//  HPALETTE m_hOriginalPalette;
    HFONT m_hOriginalFont;
    HBITMAP m_hOriginalBitmap;

    void RestoreAllObjects()
    {
        if(m_hOriginalPen != NULL)
        {
#ifndef UNDER_CE
            ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN || ::GetObjectType(m_hOriginalPen) == OBJ_EXTPEN);
#else // CE specific
            ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN);
#endif //!UNDER_CE
            ::SelectObject(m_hDC, m_hOriginalPen);
            m_hOriginalPen = NULL;
        }
        if(m_hOriginalBrush != NULL)
        {
            ATLASSERT(::GetObjectType(m_hOriginalBrush) == OBJ_BRUSH);
            ::SelectObject(m_hDC, m_hOriginalBrush);
            m_hOriginalBrush = NULL;
        }
//      if(m_hOriginalPalette != NULL)
//      {
//          ATLASSERT(::GetObjectType(m_hOriginalPalette) == OBJ_PAL);
//          ::SelectPalette(m_hDC, m_hOriginalPalette, FALSE);
//          m_hOriginalPalette = NULL;
//      }
        if(m_hOriginalFont != NULL)
        {
            ATLASSERT(::GetObjectType(m_hOriginalFont) == OBJ_FONT);
            ::SelectObject(m_hDC, m_hOriginalFont);
            m_hOriginalFont = NULL;
        }
        if(m_hOriginalBitmap != NULL)
        {
            ATLASSERT(::GetObjectType(m_hOriginalBitmap) == OBJ_BITMAP);
            ::SelectObject(m_hDC, m_hOriginalBitmap);
            m_hOriginalBitmap = NULL;
        }
    }

    CDC(HDC hDC = NULL, BOOL bAutoRestore = TRUE) : m_hDC(hDC), m_bAutoRestore(bAutoRestore),
        m_hOriginalPen(NULL), m_hOriginalBrush(NULL), m_hOriginalFont(NULL), m_hOriginalBitmap(NULL)
    {
    }

    ~CDC()
    {
        if(m_hDC != NULL)
        {
            if(m_bAutoRestore)
                RestoreAllObjects();
            ::DeleteDC(Detach());
        }
    }

    CDC& operator=(HDC hDC)
    {
        m_hDC = hDC;
        return *this;
    }

    void Attach(HDC hDC)
    {
        m_hDC = hDC;
    }

    HDC Detach()
    {
        HDC hDC = m_hDC;
        m_hDC = NULL;
        return hDC;
    }

    operator HDC() const { return m_hDC; }

#ifndef UNDER_CE
    HWND WindowFromDC() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::WindowFromDC(m_hDC);
    }
#endif //!UNDER_CE

    HPEN GetCurrentPen() const
    {
        ATLASSERT(m_hDC != NULL);
        return (HPEN)::GetCurrentObject(m_hDC, OBJ_PEN);
    }
    HBRUSH GetCurrentBrush() const
    {
        ATLASSERT(m_hDC != NULL);
        return (HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH);
    }
    HPALETTE GetCurrentPalette() const
    {
        ATLASSERT(m_hDC != NULL);
        return (HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL);
    }
    HFONT GetCurrentFont() const
    {
        ATLASSERT(m_hDC != NULL);
        return (HFONT)::GetCurrentObject(m_hDC, OBJ_FONT);
    }
    HBITMAP GetCurrentBitmap() const
    {
        ATLASSERT(m_hDC != NULL);
        return (HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP);
    }

    HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
        LPCTSTR lpszOutput, const DEVMODE* lpInitData)
    {
        ATLASSERT(m_hDC == NULL);
        m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
        return m_hDC;
    }

    HDC CreateCompatibleDC(HDC hDC = NULL)
    {
        ATLASSERT(m_hDC == NULL);
        m_hDC = ::CreateCompatibleDC(hDC);
        return m_hDC;
    }

    BOOL DeleteDC()
    {
        if(m_hDC == NULL)
            return FALSE;

        if(m_bAutoRestore)
            RestoreAllObjects();

        return ::DeleteDC(Detach());
    }

// Device-Context Functions
    int SaveDC()
    {
        ATLASSERT(m_hDC != NULL);
        return ::SaveDC(m_hDC);
    }

    BOOL RestoreDC(int nSavedDC)
    {
        ATLASSERT(m_hDC != NULL);
        return ::RestoreDC(m_hDC, nSavedDC);
    }

    int GetDeviceCaps(int nIndex) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetDeviceCaps(m_hDC, nIndex);
    }
#ifndef UNDER_CE
    UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
    }
    UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags)
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
    }
    BOOL ResetDC(const DEVMODE* lpDevMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ResetDC(m_hDC, lpDevMode) != NULL;
    }
#endif //!UNDER_CE

// Drawing-Tool Functions
#ifndef UNDER_CE
    BOOL GetBrushOrg(LPPOINT lpPoint) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetBrushOrgEx(m_hDC, lpPoint);
    }
#endif //!UNDER_CE
    BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
    }
    BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
    }
#ifndef UNDER_CE
    int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
    {
        ATLASSERT(m_hDC != NULL);
#ifdef STRICT
        return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
#else
        return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
#endif
    }
#endif //!UNDER_CE

// Type-safe selection helpers
    HPEN SelectPen(HPEN hPen)
    {
        ATLASSERT(m_hDC != NULL);
#ifndef UNDER_CE
        ATLASSERT(::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
#else // CE specific
        ATLASSERT(::GetObjectType(hPen) == OBJ_PEN);
#endif //!UNDER_CE
		HPEN hOldPen = (HPEN)::SelectObject(m_hDC, hPen);
		if(m_hOriginalPen == NULL)
			m_hOriginalPen = hOldPen;
		return hOldPen;
	}
	HBRUSH SelectBrush(HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBrush) == OBJ_BRUSH);
		HBRUSH hOldBrush = (HBRUSH)::SelectObject(m_hDC, hBrush);
		if(m_hOriginalBrush == NULL)
			m_hOriginalBrush = hOldBrush;
		return hOldBrush;
	}
	HFONT SelectFont(HFONT hFont)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hFont) == OBJ_FONT);
		HFONT hOldFont = (HFONT)::SelectObject(m_hDC, hFont);
		if(m_hOriginalFont == NULL)
			m_hOriginalFont = hOldFont;
		return hOldFont;
	}
	HBITMAP SelectBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBitmap) == OBJ_BITMAP);
		HBITMAP hOldBitmap = (HBITMAP)::SelectObject(m_hDC, hBitmap);
		if(m_hOriginalBitmap == NULL)
			m_hOriginalBitmap = hOldBitmap;
		return hOldBitmap;
	}
	int SelectRgn(HRGN hRgn)       // special return for regions
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hRgn) == OBJ_REGION);
		return (int)(INT_PTR)::SelectObject(m_hDC, hRgn);
	}

    HGDIOBJ SelectStockObject(int nIndex)
    {
        ATLASSERT(m_hDC != NULL);
        HGDIOBJ hObject = ::GetStockObject(nIndex);
        ATLASSERT(hObject != NULL);
        switch(::GetObjectType(hObject))
        {
        case OBJ_PEN:
#ifndef UNDER_CE
/*?*/       case OBJ_EXTPEN:
#endif //!UNDER_CE
            return SelectPen((HPEN)hObject);
        case OBJ_BRUSH:
            return SelectBrush((HBRUSH)hObject);
        case OBJ_FONT:
            return SelectFont((HFONT)hObject);
        default:
            return NULL;
        }
    }

// Color and Color Palette Functions
    COLORREF GetNearestColor(COLORREF crColor) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetNearestColor(m_hDC, crColor);
    }
    HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
    {
        ATLASSERT(m_hDC != NULL);

        HPALETTE hOldPal = ::SelectPalette(m_hDC, hPalette, bForceBackground);
//      if(/*m_bAutoRestore && */m_hOriginalPal == NULL)
//          m_hOriginalPal = hOldPal;
        return hOldPal;
    }
    UINT RealizePalette()
    {
        ATLASSERT(m_hDC != NULL);
        return ::RealizePalette(m_hDC);
    }
#ifndef UNDER_CE
    void UpdateColors()
    {
        ATLASSERT(m_hDC != NULL);
        ::UpdateColors(m_hDC);
    }
#endif //!UNDER_CE

// Drawing-Attribute Functions
    COLORREF GetBkColor() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetBkColor(m_hDC);
    }
    int GetBkMode() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetBkMode(m_hDC);
    }
#ifndef UNDER_CE
    int GetPolyFillMode() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetPolyFillMode(m_hDC);
    }
    int GetROP2() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetROP2(m_hDC);
    }
    int GetStretchBltMode() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetStretchBltMode(m_hDC);
    }
#endif //!UNDER_CE
    COLORREF GetTextColor() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextColor(m_hDC);
    }

    COLORREF SetBkColor(COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetBkColor(m_hDC, crColor);
    }
    int SetBkMode(int nBkMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetBkMode(m_hDC, nBkMode);
    }
#ifndef UNDER_CE
    int SetPolyFillMode(int nPolyFillMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetPolyFillMode(m_hDC, nPolyFillMode);
    }
#endif //!UNDER_CE
    int SetROP2(int nDrawMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetROP2(m_hDC, nDrawMode);
    }
#ifndef UNDER_CE
    int SetStretchBltMode(int nStretchMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetStretchBltMode(m_hDC, nStretchMode);
    }
#endif //!UNDER_CE
    COLORREF SetTextColor(COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetTextColor(m_hDC, crColor);
    }

#ifndef UNDER_CE
    BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetColorAdjustment(m_hDC, lpColorAdjust);
    }
    BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetColorAdjustment(m_hDC, lpColorAdjust);
    }
#endif //!UNDER_CE

// Mapping Functions
#ifndef UNDER_CE
    int GetMapMode() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetMapMode(m_hDC);
    }
    BOOL GetViewportOrg(LPPOINT lpPoint) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetViewportOrgEx(m_hDC, lpPoint);
    }
    int SetMapMode(int nMapMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetMapMode(m_hDC, nMapMode);
    }
    // Viewport Origin
    BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
    }
    BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return SetViewportOrg(point.x, point.y, lpPointRet);
    }
    BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
    }

    // Viewport Extent
    BOOL GetViewportExt(LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetViewportExtEx(m_hDC, lpSize);
    }
    BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetViewportExtEx(m_hDC, x, y, lpSize);
    }
    BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return SetViewportExt(size.cx, size.cy, lpSizeRet);
    }
    BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
    }

    // Window Origin
    BOOL GetWindowOrg(LPPOINT lpPoint) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetWindowOrgEx(m_hDC, lpPoint);
    }
    BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
    }
    BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return SetWindowOrg(point.x, point.y, lpPointRet);
    }
    BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
    }

    // Window extent
    BOOL GetWindowExt(LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetWindowExtEx(m_hDC, lpSize);
    }
    BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetWindowExtEx(m_hDC, x, y, lpSize);
    }
    BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet)
    {
        ATLASSERT(m_hDC != NULL);
        return SetWindowExt(size.cx, size.cy, lpSizeRet);
    }
    BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
    }

// Coordinate Functions
    BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::DPtoLP(m_hDC, lpPoints, nCount);
    }
    BOOL DPtoLP(LPRECT lpRect) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
    }
    BOOL DPtoLP(LPSIZE lpSize) const
    {
        SIZE sizeWinExt;
        if(!GetWindowExt(&sizeWinExt))
            return FALSE;
        SIZE sizeVpExt;
        if(!GetViewportExt(&sizeVpExt))
            return FALSE;
        lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
        lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
        return TRUE;
    }
    BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::LPtoDP(m_hDC, lpPoints, nCount);
    }
    BOOL LPtoDP(LPRECT lpRect) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
    }
    BOOL LPtoDP(LPSIZE lpSize) const
    {
        SIZE sizeWinExt;
        if(!GetWindowExt(&sizeWinExt))
            return FALSE;
        SIZE sizeVpExt;
        if(!GetViewportExt(&sizeVpExt))
            return FALSE;
        lpSize->cx = MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
        lpSize->cy = MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
        return TRUE;
    }

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
    #define HIMETRIC_INCH   2540    // HIMETRIC units per inch

    void DPtoHIMETRIC(LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        int nMapMode;
        if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
        {
            // when using a constrained map mode, map against physical inch
            ((CDC*)this)->SetMapMode(MM_HIMETRIC);
            DPtoLP(lpSize);
            ((CDC*)this)->SetMapMode(nMapMode);
        }
        else
        {
            // map against logical inch for non-constrained mapping modes
            int cxPerInch = GetDeviceCaps(LOGPIXELSX);
            int cyPerInch = GetDeviceCaps(LOGPIXELSY);
            ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
            lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
            lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
        }
    }

    void HIMETRICtoDP(LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        int nMapMode;
        if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
        {
            // when using a constrained map mode, map against physical inch
            ((CDC*)this)->SetMapMode(MM_HIMETRIC);
            LPtoDP(lpSize);
            ((CDC*)this)->SetMapMode(nMapMode);
        }
        else
        {
            // map against logical inch for non-constrained mapping modes
            int cxPerInch = GetDeviceCaps(LOGPIXELSX);
            int cyPerInch = GetDeviceCaps(LOGPIXELSY);
            ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
            lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
            lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
        }
    }

    void LPtoHIMETRIC(LPSIZE lpSize) const
    {
        LPtoDP(lpSize);
        DPtoHIMETRIC(lpSize);
    }

    void HIMETRICtoLP(LPSIZE lpSize) const
    {
        HIMETRICtoDP(lpSize);
        DPtoLP(lpSize);
    }
#endif //!UNDER_CE

// Region Functions
    BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
    {
        ATLASSERT(m_hDC != NULL);
        return ::FillRgn(m_hDC, hRgn, hBrush);
    }
#ifndef UNDER_CE
    BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
    {
        ATLASSERT(m_hDC != NULL);
        return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
    }
    BOOL InvertRgn(HRGN hRgn)
    {
        ATLASSERT(m_hDC != NULL);
        return ::InvertRgn(m_hDC, hRgn);
    }
    BOOL PaintRgn(HRGN hRgn)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PaintRgn(m_hDC, hRgn);
    }
#endif //!UNDER_CE

// Clipping Functions
    int GetClipBox(LPRECT lpRect) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetClipBox(m_hDC, lpRect);
    }
#ifndef UNDER_CE
    BOOL PtVisible(int x, int y) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::PtVisible(m_hDC, x, y);
    }
    BOOL PtVisible(POINT point) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::PtVisible(m_hDC, point.x, point.y);
    }
#endif //!UNDER_CE
    BOOL RectVisible(LPCRECT lpRect) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::RectVisible(m_hDC, lpRect);
    }
    int SelectClipRgn(HRGN hRgn)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
    }
    int ExcludeClipRect(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
    }
    int ExcludeClipRect(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
    }
#ifndef UNDER_CE
    int ExcludeUpdateRgn(HWND hWnd)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExcludeUpdateRgn(m_hDC, hWnd);
    }
#endif //!UNDER_CE
    int IntersectClipRect(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hDC != NULL);
        return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
    }
    int IntersectClipRect(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
    }
#ifndef UNDER_CE
    int OffsetClipRgn(int x, int y)
    {
        ATLASSERT(m_hDC != NULL);
        return ::OffsetClipRgn(m_hDC, x, y);
    }
    int OffsetClipRgn(SIZE size)
    {
        ATLASSERT(m_hDC != NULL);
        return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
    }
    int SelectClipRgn(HRGN hRgn, int nMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
    }
#endif //!UNDER_CE

// Line-Output Functions
#ifndef UNDER_CE
//REVIEW
    BOOL GetCurrentPosition(LPPOINT lpPoint) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetCurrentPositionEx(m_hDC, lpPoint);
    }
    BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::MoveToEx(m_hDC, x, y, lpPoint);
    }
    BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return MoveTo(point.x, point.y, lpPointRet);
    }
    BOOL LineTo(int x, int y)
    {
        ATLASSERT(m_hDC != NULL);
        return ::LineTo(m_hDC, x, y);
    }
    BOOL LineTo(POINT point)
    {
        ATLASSERT(m_hDC != NULL);
        return LineTo(point.x, point.y);
    }
    BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
    }
    BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Arc(m_hDC, lpRect->left, lpRect->top,
            lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y);
    }
#endif //!UNDER_CE
    BOOL Polyline(LPPOINT lpPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Polyline(m_hDC, lpPoints, nCount);
    }

#ifndef UNDER_CE
    BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
    {
        ATLASSERT(m_hDC != NULL);
        return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
    }
    BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
    }
    BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    {
        ATLASSERT(m_hDC != NULL);
        return ArcTo(lpRect->left, lpRect->top, lpRect->right,
        lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
    }
    int GetArcDirection() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetArcDirection(m_hDC);
    }
    int SetArcDirection(int nArcDirection)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetArcDirection(m_hDC, nArcDirection);
    }

    BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
    }
    BOOL PolylineTo(const POINT* lpPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolylineTo(m_hDC, lpPoints, nCount);
    }
    BOOL PolyPolyline(const POINT* lpPoints,
        const DWORD* lpPolyPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
    }

    BOOL PolyBezier(const POINT* lpPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolyBezier(m_hDC, lpPoints, nCount);
    }
    BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolyBezierTo(m_hDC, lpPoints, nCount);
    }
#endif //!UNDER_CE

// Simple Drawing Functions
    BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
    {
        ATLASSERT(m_hDC != NULL);
        return ::FillRect(m_hDC, lpRect, hBrush);
    }
#ifndef UNDER_CE
    BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
    {
        ATLASSERT(m_hDC != NULL);
        return ::FrameRect(m_hDC, lpRect, hBrush);
    }
    BOOL InvertRect(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        return ::InvertRect(m_hDC, lpRect);
    }
    BOOL DrawIcon(int x, int y, HICON hIcon)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawIcon(m_hDC, x, y, hIcon);
    }
    BOOL DrawIcon(POINT point, HICON hIcon)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
    }

    BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
    }
    BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags,
        BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
    }
    BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc,
        LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
    }
#endif //!UNDER_CE

// Ellipse and Polygon Functions
#ifndef UNDER_CE
    BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
    }
    BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Chord(m_hDC, lpRect->left, lpRect->top,
            lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y);
    }
#endif //!UNDER_CE
    void DrawFocusRect(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        ::DrawFocusRect(m_hDC, lpRect);
    }
    BOOL Ellipse(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Ellipse(m_hDC, x1, y1, x2, y2);
    }
    BOOL Ellipse(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
    }
#ifndef UNDER_CE
    BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
    }
    BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Pie(m_hDC, lpRect->left, lpRect->top,
            lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y);
    }
#endif //!UNDER_CE
    BOOL Polygon(LPPOINT lpPoints, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Polygon(m_hDC, lpPoints, nCount);
    }
#ifndef UNDER_CE
    BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
    }
#endif //!UNDER_CE
    BOOL Rectangle(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Rectangle(m_hDC, x1, y1, x2, y2);
    }
    BOOL Rectangle(LPCRECT lpRect)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
    }
    BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
    {
        ATLASSERT(m_hDC != NULL);
        return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
    }
    BOOL RoundRect(LPCRECT lpRect, POINT point)
    {
        ATLASSERT(m_hDC != NULL);
        return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
    }

// Bitmap Functions
    BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
    }
    BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
        int xSrc, int ySrc, DWORD dwRop)
    {
        ATLASSERT(m_hDC != NULL);
        return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
    }
    BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
        int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
    {
        ATLASSERT(m_hDC != NULL);
        return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
    }
    COLORREF GetPixel(int x, int y) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetPixel(m_hDC, x, y);
    }
    COLORREF GetPixel(POINT point) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetPixel(m_hDC, point.x, point.y);
    }
    COLORREF SetPixel(int x, int y, COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetPixel(m_hDC, x, y, crColor);
    }
    COLORREF SetPixel(POINT point, COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetPixel(m_hDC, point.x, point.y, crColor);
    }
#ifndef UNDER_CE
    BOOL FloodFill(int x, int y, COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::FloodFill(m_hDC, x, y, crColor);
    }
    BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
    }
#endif //!UNDER_CE
    BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
        int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask,
        DWORD dwRop)
    {
        ATLASSERT(m_hDC != NULL);
        return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
    }
#ifndef UNDER_CE
    BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc,
        int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
    }
    BOOL SetPixelV(int x, int y, COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetPixelV(m_hDC, x, y, crColor);
    }
    BOOL SetPixelV(POINT point, COLORREF crColor)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetPixelV(m_hDC, point.x, point.y, crColor);
    }
#endif //!UNDER_CE

// Text Functions
#ifndef UNDER_CE
    BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
    {
        ATLASSERT(m_hDC != NULL);
        if(nCount == -1)
            nCount = lstrlen(lpszString);
        return ::TextOut(m_hDC, x, y, lpszString, nCount);
    }
#endif //!UNDER_CE
    BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
                LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
    {
        ATLASSERT(m_hDC != NULL);
        if(nCount == -1)
            nCount = lstrlen(lpszString);
        return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
    }
#ifndef UNDER_CE
    SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1,
            int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
    {
        ATLASSERT(m_hDC != NULL);
        if(nCount == -1)
            nCount = lstrlen(lpszString);
        SIZE size;
        LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        size.cx = LOWORD(lRes);
        size.cy = HIWORD(lRes);
        return size;
    }
#endif //!UNDER_CE
    int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);
    }
    BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        if(nCount == -1)
            nCount = lstrlen(lpszString);
        return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
    }
#ifndef UNDER_CE
    BOOL GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
        int nTabPositions, LPINT lpnTabStopPositions) const
    {
        ATLASSERT(m_hDC != NULL);
        if(nCount == -1)
            nCount = lstrlen(lpszString);
        return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
    }
    BOOL GrayString(HBRUSH hBrush,
        BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
            int nCount, int x, int y, int nWidth, int nHeight)
    {
        ATLASSERT(m_hDC != NULL);
        return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
    }
    UINT GetTextAlign() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextAlign(m_hDC);
    }
    UINT SetTextAlign(UINT nFlags)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetTextAlign(m_hDC, nFlags);
    }
#endif //!UNDER_CE
    int GetTextFace(LPTSTR lpszFacename, int nCount) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextFace(m_hDC, nCount, lpszFacename);
    }
    int GetTextFaceLen() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextFace(m_hDC, 0, NULL);
    }
#ifndef _ATL_NO_COM
    BOOL GetTextFace(BSTR& bstrFace) const
    {
        USES_CONVERSION;
        ATLASSERT(m_hDC != NULL);
        ATLASSERT(bstrFace == NULL);

        int nLen = GetTextFaceLen();
        if(nLen == 0)
            return FALSE;

        LPTSTR lpszText = (LPTSTR)_alloca(nLen * sizeof(TCHAR));

        if(!GetTextFace(lpszText, nLen))
            return FALSE;

        bstrFace = ::SysAllocString(T2OLE(lpszText));
        return (bstrFace != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
    BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextMetrics(m_hDC, lpMetrics);
    }
#ifndef UNDER_CE
    int SetTextJustification(int nBreakExtra, int nBreakCount)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
    }
    int GetTextCharacterExtra() const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetTextCharacterExtra(m_hDC);
    }
    int SetTextCharacterExtra(int nCharExtra)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetTextCharacterExtra(m_hDC, nCharExtra);
    }
#endif //!UNDER_CE

// Advanced Drawing
    BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
    }
    BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
    }

// Scrolling Functions
    BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
        HRGN hRgnUpdate, LPRECT lpRectUpdate)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
    }

// Font Functions
#ifndef UNDER_CE
    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
    }
    DWORD SetMapperFlags(DWORD dwFlag)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetMapperFlags(m_hDC, dwFlag);
    }
    BOOL GetAspectRatioFilter(LPSIZE lpSize) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetAspectRatioFilterEx(m_hDC, lpSize);
    }

    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
    }
    DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
    }
    int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
    }
    UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
    }
    DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
        DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
    }

    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
        LPABCFLOAT lpABCF) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
    }
    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
        float* lpFloatBuffer) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
    }
#endif //!UNDER_CE

// Printer/Device Escape Functions
#ifndef UNDER_CE
    int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
    {
        ATLASSERT(m_hDC != NULL);
        return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
    }
    int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
        int nOutputSize, LPSTR lpszOutputData)
    {
        ATLASSERT(m_hDC != NULL);
        return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
    }
    int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
    {
        ATLASSERT(m_hDC != NULL);
        return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
    }
#endif //!UNDER_CE

    // Escape helpers
    int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
    {
        DOCINFO di;
        memset(&di, 0, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = lpszDocName;
        return StartDoc(&di);
    }

    int StartDoc(LPDOCINFO lpDocInfo)
    {
        ATLASSERT(m_hDC != NULL);
        return ::StartDoc(m_hDC, lpDocInfo);
    }
    int StartPage()
    {
        ATLASSERT(m_hDC != NULL);
        return ::StartPage(m_hDC);
    }
    int EndPage()
    {
        ATLASSERT(m_hDC != NULL);
        return ::EndPage(m_hDC);
    }
    int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
    }
    int AbortDoc()
    {
        ATLASSERT(m_hDC != NULL);
        return ::AbortDoc(m_hDC);
    }
    int EndDoc()
    {
        ATLASSERT(m_hDC != NULL);
        return ::EndDoc(m_hDC);
    }

// MetaFile Functions
#ifndef UNDER_CE
    BOOL PlayMetaFile(HMETAFILE hMF)
    {
        ATLASSERT(m_hDC != NULL);
        if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
        {
            // playing metafile in metafile, just use core windows API
            return ::PlayMetaFile(m_hDC, hMF);
        }

        // for special playback, lParam == pDC
        return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
    }
    BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
    {
        ATLASSERT(m_hDC != NULL);
        return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
    }
    BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
    {
        ATLASSERT(m_hDC != NULL);
        return ::GdiComment(m_hDC, nDataSize, pCommentData);
    }

    // Special handling for metafile playback
    static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
    {
        CDC* pDC = (CDC*)lParam;

        switch (pMetaRec->rdFunction)
        {
        case META_SETMAPMODE:
            pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SETWINDOWEXT:
            pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SETWINDOWORG:
            pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SETVIEWPORTEXT:
            pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SETVIEWPORTORG:
            pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SCALEWINDOWEXT:
            pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
                (int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SCALEVIEWPORTEXT:
            pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
                (int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_OFFSETVIEWPORTORG:
            pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SAVEDC:
            pDC->SaveDC();
            break;
        case META_RESTOREDC:
            pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
            break;
        case META_SETBKCOLOR:
            pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
            break;
        case META_SETTEXTCOLOR:
            pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
            break;

        // need to watch out for SelectObject(HFONT), for custom font mapping
        case META_SELECTOBJECT:
            {
                HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
                UINT nObjType = ::GetObjectType(hObject);
                if(nObjType == 0)
                {
                    // object type is unknown, determine if it is a font
                    HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
/**/                    HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
/**/                    HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
                    if(hObjOld == hStockFont)
                    {
                        // got the stock object back, so must be selecting a font
                        pDC->SelectFont((HFONT)hObject);
                        break;  // don't play the default record
                    }
                    else
                    {
                        // didn't get the stock object back, so restore everything
/**/                        ::SelectObject(pDC->m_hDC, hFontOld);
/**/                        ::SelectObject(pDC->m_hDC, hObjOld);
                    }
                    // and fall through to PlayMetaFileRecord...
                }
                else if(nObjType == OBJ_FONT)
                {
                    // play back as CDC::SelectFont(HFONT)
                    pDC->SelectFont((HFONT)hObject);
                    break;  // don't play the default record
                }
            }
            // fall through...

        default:
            ::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
            break;
        }

        return 1;
    }
#endif //!UNDER_CE

// Path Functions
#ifndef UNDER_CE
    BOOL AbortPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::AbortPath(m_hDC);
    }
    BOOL BeginPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::BeginPath(m_hDC);
    }
    BOOL CloseFigure()
    {
        ATLASSERT(m_hDC != NULL);
        return ::CloseFigure(m_hDC);
    }
    BOOL EndPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::EndPath(m_hDC);
    }
    BOOL FillPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::FillPath(m_hDC);
    }
    BOOL FlattenPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::FlattenPath(m_hDC);
    }
    BOOL StrokeAndFillPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::StrokeAndFillPath(m_hDC);
    }
    BOOL StrokePath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::StrokePath(m_hDC);
    }
    BOOL WidenPath()
    {
        ATLASSERT(m_hDC != NULL);
        return ::WidenPath(m_hDC);
    }
    BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetMiterLimit(m_hDC, pfMiterLimit);
    }
    BOOL SetMiterLimit(float fMiterLimit)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
    }
    int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
    {
        ATLASSERT(m_hDC != NULL);
        return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
    }
    BOOL SelectClipPath(int nMode)
    {
        ATLASSERT(m_hDC != NULL);
        return ::SelectClipPath(m_hDC, nMode);
    }
#endif //!UNDER_CE

// Misc Helper Functions
    static HBRUSH PASCAL GetHalftoneBrush()
    {
        HBRUSH halftoneBrush;
        WORD grayPattern[8];
        for(int i = 0; i < 8; i++)
            grayPattern[i] = (WORD)(0x5555 << (i & 1));
        HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
        if(grayBitmap != NULL)
        {
            halftoneBrush = ::CreatePatternBrush(grayBitmap);
            DeleteObject(grayBitmap);
        }
        return halftoneBrush;
    }
    void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
    {
        // first, determine the update region and select it
        HRGN hRgnNew;
        HRGN hRgnOutside, hRgnInside;
        hRgnOutside = ::CreateRectRgnIndirect(lpRect);
        RECT rect = *lpRect;
        ::InflateRect(&rect, -size.cx, -size.cy);
        ::IntersectRect(&rect, &rect, lpRect);
        hRgnInside = ::CreateRectRgnIndirect(&rect);
        hRgnNew = ::CreateRectRgn(0, 0, 0, 0);
        ::CombineRgn(hRgnNew, hRgnOutside, hRgnInside, RGN_XOR);

        HBRUSH hBrushOld = NULL;
        if(hBrush == NULL)
            hBrush = CDC::GetHalftoneBrush();
        if(hBrushLast == NULL)
            hBrushLast = hBrush;

        HRGN hRgnLast, hRgnUpdate;
        if(lpRectLast != NULL)
        {
            // find difference between new region and old region
            hRgnLast = ::CreateRectRgn(0, 0, 0, 0);
            ::SetRectRgn(hRgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
            rect = *lpRectLast;
            ::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
            ::IntersectRect(&rect, &rect, lpRectLast);
            ::SetRectRgn(hRgnInside, rect.left, rect.top, rect.right, rect.bottom);
            ::CombineRgn(hRgnLast, hRgnOutside, hRgnInside, RGN_XOR);

            // only diff them if brushes are the same
            if(hBrush == hBrushLast)
            {
                hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
                ::CombineRgn(hRgnUpdate, hRgnLast, hRgnNew, RGN_XOR);
            }
        }
        if(hBrush != hBrushLast && lpRectLast != NULL)
        {
            // brushes are different -- erase old region first
            SelectClipRgn(hRgnLast);
            GetClipBox(&rect);
            hBrushOld = SelectBrush(hBrushLast);
            PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
            SelectBrush(hBrushOld);
            hBrushOld = NULL;
        }

        // draw into the update/new region
        SelectClipRgn(hRgnUpdate != NULL ? hRgnUpdate : hRgnNew);
        GetClipBox(&rect);
        hBrushOld = SelectBrush(hBrush);
        PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);

        // cleanup DC
        if(hBrushOld != NULL)
            SelectBrush(hBrushOld);
        SelectClipRgn(NULL);
    }
    void FillSolidRect(LPCRECT lpRect, COLORREF clr)
    {
        ATLASSERT(m_hDC != NULL);

        ::SetBkColor(m_hDC, clr);
        ::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
    }
    void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
    {
        ATLASSERT(m_hDC != NULL);

        ::SetBkColor(m_hDC, clr);
        RECT rect = { x, y, x + cx, y + cy };
        ::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
    }
    void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
    {
        Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
            lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
    }
    void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
    {
        FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
        FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
        FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
        FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
public:
    HWND m_hWnd;
    PAINTSTRUCT m_ps;

    CPaintDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
    {
        ATLASSERT(::IsWindow(hWnd));
        m_hWnd = hWnd;
        m_hDC = ::BeginPaint(hWnd, &m_ps);
    }
    ~CPaintDC()
    {
        ATLASSERT(m_hDC != NULL);
        ATLASSERT(::IsWindow(m_hWnd));

        if(m_bAutoRestore)
            RestoreAllObjects();

        ::EndPaint(m_hWnd, &m_ps);
        Detach();
    }
};

class CClientDC : public CDC
{
public:
    HWND m_hWnd;

    CClientDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
    {
        ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
        m_hWnd = hWnd;
        m_hDC = ::GetDC(hWnd);
    }
    ~CClientDC()
    {
        ATLASSERT(m_hDC != NULL);

        if(m_bAutoRestore)
            RestoreAllObjects();

        ::ReleaseDC(m_hWnd, Detach());
    }
};

class CWindowDC : public CDC
{
public:
    HWND m_hWnd;

    CWindowDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
    {
        ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
        m_hWnd = hWnd;
        m_hDC = ::GetWindowDC(hWnd);
    }
    ~CWindowDC()
    {
        ATLASSERT(m_hDC != NULL);

        if(m_bAutoRestore)
            RestoreAllObjects();

        ::ReleaseDC(m_hWnd, Detach());
    }
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu
{
public:
    HMENU m_hMenu;

    CMenu(HMENU hMenu = NULL) : m_hMenu(hMenu) { }

    ~CMenu()
    {
        if(m_hMenu != NULL)
            DestroyMenu();
    }

    CMenu& operator=(HMENU hMenu)
    {
        m_hMenu = hMenu;
        return *this;
    }

    void Attach(HMENU hMenuNew)
    {
        ATLASSERT(::IsMenu(hMenuNew));
        m_hMenu = hMenuNew;
    }

    HMENU Detach()
    {
        HMENU hMenu = m_hMenu;
        m_hMenu = NULL;
        return hMenu;
    }

    operator HMENU() const { return m_hMenu; }

    BOOL CreateMenu()
    {
        ATLASSERT(m_hMenu == NULL);
        m_hMenu = ::CreateMenu();
        return (m_hMenu != NULL) ? TRUE : FALSE;
    }
    BOOL CreatePopupMenu()
    {
        ATLASSERT(m_hMenu == NULL);
        m_hMenu = ::CreatePopupMenu();
        return (m_hMenu != NULL) ? TRUE : FALSE;
    }
    BOOL LoadMenu(LPCTSTR lpszResourceName)
    {
        ATLASSERT(m_hMenu == NULL);
        m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), lpszResourceName);
        return (m_hMenu != NULL) ? TRUE : FALSE;
    }
    BOOL LoadMenu(UINT nIDResource)
    {
        ATLASSERT(m_hMenu == NULL);
        m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
        return (m_hMenu != NULL) ? TRUE : FALSE;
    }
#ifndef UNDER_CE
    BOOL LoadMenuIndirect(const void* lpMenuTemplate)
    {
        ATLASSERT(m_hMenu == NULL);
        m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
        return (m_hMenu != NULL) ? TRUE : FALSE;
    }
#endif //!UNDER_CE
    BOOL DestroyMenu()
    {
        if (m_hMenu == NULL)
            return FALSE;
        return ::DestroyMenu(Detach());
    }

// Menu Operations
    BOOL DeleteMenu(UINT nPosition, UINT nFlags)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::DeleteMenu(m_hMenu, nPosition, nFlags);
    }
    BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
    {
        ATLASSERT(::IsMenu(m_hMenu));
#ifndef UNDER_CE
        return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
#else // CE specific
        return ::TrackPopupMenuEx(m_hMenu, nFlags, x, y, hWnd, NULL);
#endif //!UNDER_CE
    }
    BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
    }

// Menu Item Operations
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
	}
#ifndef UNDER_CE
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
    UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
    }
    UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
    }
#ifndef UNDER_CE
    UINT GetMenuItemCount() const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuItemCount(m_hMenu);
    }
    UINT GetMenuItemID(int nPos) const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuItemID(m_hMenu, nPos);
    }
    UINT GetMenuState(UINT nID, UINT nFlags) const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuState(m_hMenu, nID, nFlags);
    }
    int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
    }
    int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
    }
#ifndef _ATL_NO_COM
    BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
    {
        USES_CONVERSION;
        ATLASSERT(::IsMenu(m_hMenu));
        ATLASSERT(bstrText == NULL);

        int nLen = GetMenuStringLen(nIDItem, nFlags);
        {
            bstrText = ::SysAllocString(OLESTR(""));
            return (bstrText != NULL) ? TRUE : FALSE;
        }

        LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

        if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
            return FALSE;

        bstrText = ::SysAllocString(T2OLE(lpszText));
        return (bstrText != NULL) ? TRUE : FALSE;
    }
#endif //!_ATL_NO_COM
#endif //!UNDER_CE
    HMENU GetSubMenu(int nPos) const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetSubMenu(m_hMenu, nPos);
    }
#ifndef UNDER_CE
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
#ifndef UNDER_CE
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
    BOOL RemoveMenu(UINT nPosition, UINT nFlags)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::RemoveMenu(m_hMenu, nPosition, nFlags);
    }
#ifndef UNDER_CE
    BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
    }
#endif //!UNDER_CE
    BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
    }

    BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
    }
    BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
    }

// Context Help Functions
#ifndef UNDER_CE
    BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
    }
    DWORD GetMenuContextHelpId() const
    {
        ATLASSERT(::IsMenu(m_hMenu));
        return ::GetMenuContextHelpId(m_hMenu);
    }
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPen

class CPen
{
public:
    HPEN m_hPen;

    CPen(HPEN hPen = NULL) : m_hPen(hPen)
    { }
    ~CPen()
    {
        if(m_hPen != NULL)
            DeleteObject();
    }

    CPen& operator=(HPEN hPen)
    {
        m_hPen = hPen;
        return *this;
    }

    void Attach(HPEN hPen)
    {
        m_hPen = hPen;
    }
    HPEN Detach()
    {
        HPEN hPen = m_hPen;
        m_hPen = NULL;
        return hPen;
    }

    operator HPEN() const { return m_hPen; }

    HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
    {
        ATLASSERT(m_hPen == NULL);
        m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
        return m_hPen;
    }
#ifndef UNDER_CE
    HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
    {
        ATLASSERT(m_hPen == NULL);
        m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
        return m_hPen;
    }
#endif //!UNDER_CE
    HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
    {
        ATLASSERT(m_hPen == NULL);
        m_hPen = ::CreatePenIndirect(lpLogPen);
        return m_hPen;
    }

    BOOL DeleteObject()
    {
        ATLASSERT(m_hPen != NULL);
        BOOL bRet = ::DeleteObject(m_hPen);
        if(bRet)
            m_hPen = NULL;
        return bRet;
    }

// Attributes
    int GetLogPen(LOGPEN* pLogPen)
    {
        ATLASSERT(m_hPen != NULL);
        return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
    }
#ifndef UNDER_CE
    int GetExtLogPen(EXTLOGPEN* pLogPen)
    {
        ATLASSERT(m_hPen != NULL);
        return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
    }
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CBrush

class CBrush
{
public:
    HBRUSH m_hBrush;

    CBrush(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
    { }
    ~CBrush()
    {
        if(m_hBrush != NULL)
            DeleteObject();
    }

    CBrush& operator=(HBRUSH hBrush)
    {
        m_hBrush = hBrush;
        return *this;
    }

    void Attach(HBRUSH hBrush)
    {
        m_hBrush = hBrush;
    }
    HBRUSH Detach()
    {
        HBRUSH hBrush = m_hBrush;
        m_hBrush = NULL;
        return hBrush;
    }

    operator HBRUSH() const { return m_hBrush; }

    HBRUSH CreateSolidBrush(COLORREF crColor)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::CreateSolidBrush(crColor);
        return m_hBrush;
    }
#ifndef UNDER_CE
    HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::CreateHatchBrush(nIndex, crColor);
        return m_hBrush;
    }
    HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::CreateBrushIndirect(lpLogBrush);
        return m_hBrush;
    }
#endif //!UNDER_CE
    HBRUSH CreatePatternBrush(HBITMAP hBitmap)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::CreatePatternBrush(hBitmap);
        return m_hBrush;
    }
#ifndef UNDER_CE
//REVIEW
    HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
    {
        ATLASSERT(hPackedDIB != NULL);
        const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
        ATLASSERT(lpPackedDIB != NULL);
        m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
        ::GlobalUnlock(hPackedDIB);
        return m_hBrush;
    }
#endif //!UNDER_CE
    HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
        return m_hBrush;
    }
    HBRUSH CreateSysColorBrush(int nIndex)
    {
        ATLASSERT(m_hBrush == NULL);
        m_hBrush = ::GetSysColorBrush(nIndex);
        return m_hBrush;
    }

    BOOL DeleteObject()
    {
        ATLASSERT(m_hBrush != NULL);
        BOOL bRet = ::DeleteObject(m_hBrush);
        if(bRet)
            m_hBrush = NULL;
        return bRet;
    }

// Attributes
    int GetLogBrush(LOGBRUSH* pLogBrush)
    {
        ATLASSERT(m_hBrush != NULL);
        return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CFont

class CFont
{
public:
    HFONT m_hFont;

    CFont(HFONT hFont = NULL) : m_hFont(hFont)
    { }
    ~CFont()
    {
        if(m_hFont != NULL)
            DeleteObject();
    }

    CFont& operator=(HFONT hFont)
    {
        m_hFont = hFont;
        return *this;
    }

    void Attach(HFONT hFont)
    {
        m_hFont = hFont;
    }
    HFONT Detach()
    {
        HFONT hFont = m_hFont;
        m_hFont = NULL;
        return hFont;
    }

    operator HFONT() const { return m_hFont; }

    HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
    {
        ATLASSERT(m_hFont == NULL);
        m_hFont = ::CreateFontIndirect(lpLogFont);
        return m_hFont;
    }
    HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
            int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
            BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
            BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
            LPCTSTR lpszFacename)
    {
        ATLASSERT(m_hFont == NULL);
#ifndef UNDER_CE
        m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
#else // CE specific
        m_hFont = CreateFont(nHeight, nWidth, nEscapement,
#endif //!UNDER_CE
            nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
            nCharSet, nOutPrecision, nClipPrecision, nQuality,
            nPitchAndFamily, lpszFacename);
        return m_hFont;
    }
#ifndef UNDER_CE
    HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL)
    {
        LOGFONT logFont;
        memset(&logFont, 0, sizeof(LOGFONT));
        logFont.lfCharSet = DEFAULT_CHARSET;
        logFont.lfHeight = nPointSize;
        lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
        return CreatePointFontIndirect(&logFont, hDC);
    }
    HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
    {
        HDC hDC1 = (hDC != NULL) ? hDC : (::GetDC(NULL));

        // convert nPointSize to logical units based on hDC
        LOGFONT logFont = *lpLogFont;
        POINT pt;
        pt.y = ::GetDeviceCaps(hDC1, LOGPIXELSY) * logFont.lfHeight;
        pt.y /= 720;    // 72 points/inch, 10 decipoints/point
        ::DPtoLP(hDC1, &pt, 1);
        POINT ptOrg = { 0, 0 };
        ::DPtoLP(hDC1, &ptOrg, 1);
        logFont.lfHeight = -abs(pt.y - ptOrg.y);

        if(hDC == NULL)
            ::ReleaseDC(NULL, hDC1);

        return CreateFontIndirect(&logFont);
    }
#endif //!UNDER_CE

    BOOL DeleteObject()
    {
        ATLASSERT(m_hFont != NULL);
        BOOL bRet = ::DeleteObject(m_hFont);
        if(bRet)
            m_hFont = NULL;
        return bRet;
    }

// Attributes
    int GetLogFont(LOGFONT* pLogFont)
    {
        ATLASSERT(m_hFont != NULL);
        return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CBitmap

class CBitmap
{
public:
    HBITMAP m_hBitmap;

    CBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
    { }
    ~CBitmap()
    {
        if(m_hBitmap != NULL)
            DeleteObject();
    }

    CBitmap& operator=(HBITMAP hBitmap)
    {
        m_hBitmap = hBitmap;
        return *this;
    }

    void Attach(HBITMAP hBitmap)
    {
        m_hBitmap = hBitmap;
    }
    HBITMAP Detach()
    {
        HBITMAP hBitmap = m_hBitmap;
        m_hBitmap = NULL;
        return hBitmap;
    }

    operator HBITMAP() const { return m_hBitmap; }

    HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
        return m_hBitmap;
    }
    HBITMAP LoadBitmap(UINT nIDResource)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
        return m_hBitmap;
    }
    HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
        return m_hBitmap;
    }
    HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
        return m_hBitmap;
    }
    HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
        return m_hBitmap;
    }
#ifndef UNDER_CE
    HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
        return m_hBitmap;
    }
#endif //!UNDER_CE
    HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
        return m_hBitmap;
    }
#ifndef UNDER_CE
    HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
    {
        ATLASSERT(m_hBitmap == NULL);
        m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
        return m_hBitmap;
    }
#endif //!UNDER_CE

    BOOL DeleteObject()
    {
        ATLASSERT(m_hBitmap != NULL);
        BOOL bRet = ::DeleteObject(m_hBitmap);
        if(bRet)
            m_hBitmap = NULL;
        return bRet;
    }

// Attributes
    int GetBitmap(BITMAP* pBitMap)
    {
        ATLASSERT(m_hBitmap != NULL);
        return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
    }

// Operations
#ifndef UNDER_CE
//REVIEW
    DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
    {
        ATLASSERT(m_hBitmap != NULL);
        return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
    }
    DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
    {
        ATLASSERT(m_hBitmap != NULL);
        return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
    }
    BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
    {
        ATLASSERT(m_hBitmap != NULL);
        return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
    }
    BOOL GetBitmapDimension(LPSIZE lpSize) const
    {
        ATLASSERT(m_hBitmap != NULL);
        return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
    }
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPalette

class CPalette
{
public:
    HPALETTE m_hPalette;

    CPalette(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
    { }
    ~CPalette()
    {
        if(m_hPalette != NULL)
            DeleteObject();
    }

    CPalette& operator=(HPALETTE hPalette)
    {
        m_hPalette = hPalette;
        return *this;
    }

    void Attach(HPALETTE hPalette)
    {
        m_hPalette = hPalette;
    }
    HPALETTE Detach()
    {
        HPALETTE hPalette = m_hPalette;
        m_hPalette = NULL;
        return hPalette;
    }

    operator HPALETTE() const { return m_hPalette; }

    HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
    {
        ATLASSERT(m_hPalette == NULL);
        m_hPalette = ::CreatePalette(lpLogPalette);
        return m_hPalette;
    }
#ifndef UNDER_CE
    HPALETTE CreateHalftonePalette(HDC hDC)
    {
        ATLASSERT(m_hPalette == NULL);
        ATLASSERT(hDC != NULL);
        m_hPalette = ::CreateHalftonePalette(hDC);
        return m_hPalette;
    }
#endif //!UNDER_CE

    BOOL DeleteObject()
    {
        ATLASSERT(m_hPalette != NULL);
        BOOL bRet = ::DeleteObject(m_hPalette);
        if(bRet)
            m_hPalette = NULL;
        return bRet;
    }

// Attributes
    int GetEntryCount()
    {
        ATLASSERT(m_hPalette != NULL);
        WORD nEntries;
        ::GetObject(m_hPalette, sizeof(WORD), &nEntries);
        return (int)nEntries;
    }
    UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
    {
        ATLASSERT(m_hPalette != NULL);
        return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
    }
    UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
    {
        ATLASSERT(m_hPalette != NULL);
        return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
    }

// Operations
#ifndef UNDER_CE
    void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
    {
        ATLASSERT(m_hPalette != NULL);
        ::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
    }
    BOOL ResizePalette(UINT nNumEntries)
    {
        ATLASSERT(m_hPalette != NULL);
        return ::ResizePalette(m_hPalette, nNumEntries);
    }
#endif //!UNDER_CE
    UINT GetNearestPaletteIndex(COLORREF crColor) const
    {
        ATLASSERT(m_hPalette != NULL);
        return ::GetNearestPaletteIndex(m_hPalette, crColor);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CRgn

class CRgn
{
public:
    HRGN m_hRgn;
    CRgn(HRGN hRgn = NULL) : m_hRgn(hRgn)
    { }
    ~CRgn()
    {
        if(m_hRgn != NULL)
            DeleteObject();
    }

    CRgn& operator=(HRGN hRgn)
    {
        m_hRgn = hRgn;
        return *this;
    }

    void Attach(HRGN hRgn)
    {
        m_hRgn = hRgn;
    }
    HRGN Detach()
    {
        HRGN hRgn = m_hRgn;
        m_hRgn = NULL;
        return hRgn;
    }

    operator HRGN() const { return m_hRgn; }

    HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
        return m_hRgn;
    }
    HRGN CreateRectRgnIndirect(LPCRECT lpRect)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreateRectRgnIndirect(lpRect);
        return m_hRgn;
    }
#ifndef UNDER_CE
    HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
        return m_hRgn;
    }
    HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
        return m_hRgn;
    }
    HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
        return m_hRgn;
    }
    HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
        return m_hRgn;
    }
    HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
        return m_hRgn;
    }
    HRGN CreateFromPath(HDC hDC)
    {
        ATLASSERT(m_hRgn == NULL);
        ATLASSERT(hDC != NULL);
        m_hRgn = ::PathToRegion(hDC);
        return m_hRgn;
    }
    HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
    {
        ATLASSERT(m_hRgn == NULL);
        m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
        return m_hRgn;
    }
#endif //!UNDER_CE

    BOOL DeleteObject()
    {
        ATLASSERT(m_hRgn != NULL);
        BOOL bRet = ::DeleteObject(m_hRgn);
        if(bRet)
            m_hRgn = NULL;
        return bRet;
    }

// Operations
    void SetRectRgn(int x1, int y1, int x2, int y2)
    {
        ATLASSERT(m_hRgn != NULL);
        ::SetRectRgn(m_hRgn, x1, y1, x2, y2);
    }
    void SetRectRgn(LPCRECT lpRect)
    {
        ATLASSERT(m_hRgn != NULL);
        ::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
    }
    int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
    {
        ATLASSERT(m_hRgn != NULL);
        return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
    }
    int CombineRgn(HRGN hRgnSrc, int nCombineMode)
    {
        ATLASSERT(m_hRgn != NULL);
        return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
    }
    int CopyRgn(HRGN hRgnSrc)
    {
        ATLASSERT(m_hRgn != NULL);
        return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
    }
    BOOL EqualRgn(HRGN hRgn) const
    {
        ATLASSERT(m_hRgn != NULL);
        return ::EqualRgn(m_hRgn, hRgn);
    }
    int OffsetRgn(int x, int y)
    {
        ATLASSERT(m_hRgn != NULL);
        return ::OffsetRgn(m_hRgn, x, y);
    }
    int OffsetRgn(POINT point)
    {
        ATLASSERT(m_hRgn != NULL);
        return ::OffsetRgn(m_hRgn, point.x, point.y);
    }
    int GetRgnBox(LPRECT lpRect) const
    {
        ATLASSERT(m_hRgn != NULL);
        return ::GetRgnBox(m_hRgn, lpRect);
    }
    BOOL PtInRegion(int x, int y) const
    {
        ATLASSERT(m_hRgn != NULL);
        return ::PtInRegion(m_hRgn, x, y);
    }
    BOOL PtInRegion(POINT point) const
    {
        ATLASSERT(m_hRgn != NULL);
        return ::PtInRegion(m_hRgn, point.x, point.y);
    }
    BOOL RectInRegion(LPCRECT lpRect) const
    {
        ATLASSERT(m_hRgn != NULL);
        return ::RectInRegion(m_hRgn, lpRect);
    }
    int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
    {
        ATLASSERT(m_hRgn != NULL);
        return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
    }
};

}; //namespace ATL

#endif // __ATLGDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atldlgs.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDLGS_H__
#define __ATLDLGS_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLWIN_H__
	#error atldlgs.h requires atlwin.h to be included first
#endif

#if (_ATL_VER < 0x0300)
#ifndef __ATLWIN21_H__
	#error atldlgs.h requires atlwin21.h to be included first when used with ATL 2.0/2.1
#endif
#endif //(_ATL_VER < 0x0300)

#include <commdlg.h>
#include <commctrl.h>
#include <shlobj.h>


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CFileDialogImpl;
class CFileDialog;
#ifndef UNDER_CE
template <class T> class CFolderDialogImpl;
class CFolderDialog;
template <class T> class CFontDialogImpl;
class CFontDialog;
#ifdef _RICHEDIT_
template <class T> class CRichEditFontDialogImpl;
class CRichEditFontDialog;
#endif //_RICHEDIT_
template <class T> class CColorDialogImpl;
class CColorDialog;
template <class T> class CPrintDialogImpl;
class CPrintDialog;
template <class T> class CPageSetupDialogImpl;
class CPageSetupDialog;
template <class T> class CFindReplaceDialogImpl;
class CFindReplaceDialog;
#endif //!UNDER_CE

class CPropertySheetWindow;
template <class T, class TBase = CPropertySheetWindow> class CPropertySheetImpl;
class CPropertySheet;
class CPropertyPageWindow;
template <class T, class TBase = CPropertyPageWindow> class CPropertyPageImpl;
template <WORD t_wDlgTemplateID> class CPropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CFileDialogImpl - used for File Open or File Save As

template <class T>
class ATL_NO_VTABLE CFileDialogImpl : public CDialogImplBase
{
public:
	OPENFILENAME m_ofn;
	BOOL m_bOpenFileDialog;			// TRUE for file open, FALSE for file save
	TCHAR m_szFileTitle[_MAX_FNAME];	// contains file title after return
	TCHAR m_szFileName[_MAX_PATH];		// contains full path name after return

	CFileDialogImpl(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
			LPCTSTR lpszDefExt = NULL,
			LPCTSTR lpszFileName = NULL,
			DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
			LPCTSTR lpszFilter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_ofn, 0, sizeof(m_ofn)); // initialize structure to 0/NULL
		m_szFileName[0] = '\0';
		m_szFileTitle[0] = '\0';

		m_bOpenFileDialog = bOpenFileDialog;

		m_ofn.lStructSize = sizeof(m_ofn);
		m_ofn.lpstrFile = m_szFileName;
		m_ofn.nMaxFile = sizeof(TCHAR) * _MAX_PATH;
		m_ofn.lpstrDefExt = lpszDefExt;
		m_ofn.lpstrFileTitle = (LPTSTR)m_szFileTitle;
		m_ofn.nMaxFileTitle = sizeof(TCHAR) * _MAX_FNAME;
		m_ofn.Flags |= dwFlags | OFN_ENABLEHOOK | OFN_EXPLORER;
		m_ofn.lpstrFilter = lpszFilter;
		m_ofn.hInstance = _Module.GetResourceInstance();
		m_ofn.lpfnHook = (LPOFNHOOKPROC)T::StartDialogProc;
		m_ofn.hwndOwner = hWndParent;

		// setup initial file name
		if(lpszFileName != NULL)
			lstrcpyn(m_szFileName, lpszFileName, sizeof(TCHAR) * _MAX_PATH);
	}

	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
		ATLASSERT(m_ofn.lpfnHook != NULL);	// can still be a user hook

		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		if(m_ofn.hwndOwner == NULL)		// set only if not specified before
			m_ofn.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);

		int nResult;
		if(m_bOpenFileDialog)
			nResult = ::GetOpenFileName(&m_ofn);
		else
			nResult = ::GetSaveFileName(&m_ofn);

		m_hWnd = NULL;

		return nResult ? nResult : IDCANCEL;
	}

// Operations
	int GetFilePath(LPTSTR lpstrFilePath, int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)SendMessage(CDM_GETFILEPATH, nLength, (LPARAM)lpstrFilePath);
	}

	int GetFolderIDList(LPVOID lpBuff, int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)SendMessage(CDM_GETFOLDERIDLIST, nLength, (LPARAM)lpBuff);
	}

	int GetFolderPath(LPTSTR lpstrFolderPath, int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)SendMessage(CDM_GETFOLDERPATH, nLength, (LPARAM)lpstrFolderPath);
	}

	int GetSpec(LPTSTR lpstrSpec, int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)SendMessage(CDM_GETSPEC, nLength, (LPARAM)lpstrSpec);
	}

	void HideControl(int nCtrlID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		SendMessage(CDM_HIDECONTROL, nCtrlID);
	}

	void SetControlText(int nCtrlID, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		SendMessage(CDM_SETCONTROLTEXT, nCtrlID, (LPARAM)lpstrText);
	}

	void SetDefExt(LPCTSTR lpstrExt)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		SendMessage(CDM_SETDEFEXT, 0, (LPARAM)lpstrExt);
	}

	BOOL GetReadOnlyPref() const	// return TRUE if readonly checked
	{
		return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE;
	}

	BEGIN_MSG_MAP(CFileDialogImpl< T >)
		NOTIFY_CODE_HANDLER(CDN_FILEOK, _OnFileOK)
		NOTIFY_CODE_HANDLER(CDN_FOLDERCHANGE, _OnFolderChange)
		NOTIFY_CODE_HANDLER(CDN_HELP, _OnHelp)
		NOTIFY_CODE_HANDLER(CDN_INITDONE, _OnInitDone)
		NOTIFY_CODE_HANDLER(CDN_SELCHANGE, _OnSelChange)
		NOTIFY_CODE_HANDLER(CDN_SHAREVIOLATION, _OnShareViolation)
		NOTIFY_CODE_HANDLER(CDN_TYPECHANGE, _OnTypeChange)
	END_MSG_MAP()

	LRESULT _OnFileOK(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return !pT->OnFileOK((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnFolderChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnFolderChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnHelp(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnHelp((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnInitDone(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnInitDone((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnSelChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnSelChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnShareViolation(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return pT->OnShareViolation((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnTypeChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnSelChange((LPOFNOTIFY)pnmh);
		return 0;
	}

	BOOL OnFileOK(LPOFNOTIFY /*lpon*/)
	{
		return TRUE;
	}
	void OnFolderChange(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnHelp(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnInitDone(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnSelChange(LPOFNOTIFY /*lpon*/)
	{
	}
	int OnShareViolation(LPOFNOTIFY /*lpon*/)
	{
		return 0;
	}
	void OnTypeChange(LPOFNOTIFY /*lpon*/)
	{
	}
};


class CFileDialog : public CFileDialogImpl<CFileDialog>
{
public:
	CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		HWND hWndParent = NULL)
		: CFileDialogImpl<CFileDialog>(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFolderDialogImpl - used for browsing for a folder

#ifndef UNDER_CE

#ifndef BFFM_VALIDATEFAILED

#define BFFM_VALIDATEFAILEDA    3
#define BFFM_VALIDATEFAILEDW    4

#ifdef UNICODE
#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

#endif //!BFFM_VALIDATEFAILED

template <class T>
class CFolderDialogImpl
{
public:
	BROWSEINFO m_bi;
	TCHAR m_szFolderDisplayName[MAX_PATH];
	TCHAR m_szFolderPath[MAX_PATH];
	HWND m_hWnd;	// used only in the callback function

// Constructor
	CFolderDialogImpl(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
	{
		memset(&m_bi, 0, sizeof(m_bi)); // initialize structure to 0/NULL

		m_bi.hwndOwner = hWndParent;
		m_bi.pidlRoot = NULL;
		m_bi.pszDisplayName = m_szFolderDisplayName;
		m_bi.lpszTitle = lpstrTitle;
		m_bi.ulFlags = uFlags;
		m_bi.lpfn = BrowseCallbackProc;
		m_bi.lParam = (LPARAM)this;

		m_szFolderPath[0] = 0;
		m_szFolderDisplayName[0] = 0;

		m_hWnd = NULL;
	}

// Operations
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		if(m_bi.hwndOwner == NULL)	// set only if not specified before
			m_bi.hwndOwner = hWndParent;

		int nRet = -1;
		LPITEMIDLIST pItemIDList = ::SHBrowseForFolder(&m_bi);
		if(pItemIDList != NULL)
		{
			if(::SHGetPathFromIDList(pItemIDList, m_szFolderPath))
			{
				IMalloc* pMalloc = NULL;
				if(SUCCEEDED(::SHGetMalloc(&pMalloc)))
				{
					pMalloc->Free(pItemIDList);
					pMalloc->Release();
				}
				nRet = IDOK;
			}
			else
				nRet = IDCANCEL;
		}
		return nRet;
	}

	// filled after a call to DoModal
	LPTSTR GetFolderPath()
	{
		return m_szFolderPath;
	}
	LPTSTR GetFolderDisplayName()
	{
		return m_szFolderDisplayName;
	}
	int GetFolderImageIndex()
	{
		return m_bi.iImage;
	}

// Callback function and overrideables
	static int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
	{
		int nRet = 0;
		T* pT = (T*)lpData;
		pT->m_hWnd = hWnd;
		switch(uMsg)
		{
		case BFFM_INITIALIZED:
			pT->OnInitialized();
			break;
		case BFFM_SELCHANGED:
			pT->OnSelChanged((LPITEMIDLIST)lParam);
			break;
		case BFFM_VALIDATEFAILED:
			nRet = pT->OnValidateFailed((LPCTSTR)lParam);
			break;
		default:
			ATLTRACE2(atlTraceWindowing, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
			break;
		}
		pT->m_hWnd = NULL;
		return nRet;
	}
	void OnInitialized()
	{
	}
	void OnSelChanged(LPITEMIDLIST /*pItemIDList*/)
	{
	}
	int OnValidateFailed(LPCTSTR /*lpstrFolderPath*/)
	{
		return 1;	// 1=continue, 0=EndDialog
	}

	// Commands - valid to call only from handlers
	void EnableOK(BOOL bEnable)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_ENABLEOK, bEnable, 0L);
	}
	void SetSelection(LPITEMIDLIST pItemIDList)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, FALSE, (LPARAM)pItemIDList);
	}
	void SetSelection(LPCTSTR lpstrFolderPath)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrFolderPath);
	}
	void SetStatusText(LPCTSTR lpstrText)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)lpstrText);
	}
};

class CFolderDialog : public CFolderDialogImpl<CFolderDialog>
{
public:
	CFolderDialog(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
		: CFolderDialogImpl<CFolderDialog>(hWndParent, lpstrTitle, uFlags)
	{
		m_bi.lpfn = NULL;
	}
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CCommonDialogBaseImpl - base class for common dialog classes

class CCommonDialogImplBase : public CWindowImplBase
{
public:
	static UINT_PTR APIENTRY HookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if(uMsg != WM_INITDIALOG)
			return 0;
		CCommonDialogImplBase* pT = (CCommonDialogImplBase*)_Module.ExtractCreateWndData();
		ATLASSERT(pT != NULL);
		ATLASSERT(pT->m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		// subclass dialog's window
		if(!pT->SubclassWindow(hWnd))
		{
			ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing a common dialog failed\n"));
			return 0;
		}
		// check message map for WM_INITDIALOG handler
		LRESULT lRes;
		if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
			return 0;
		return lRes;
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EndDialog(m_hWnd, nRetCode);
	}

// Attempt to override these, to prevent errors
	HWND Create(HWND /*hWndParent*/, RECT& /*rcPos*/, LPCTSTR /*szWindowName*/,
			DWORD /*dwStyle*/, DWORD /*dwExStyle*/, UINT /*nID*/, ATOM /*atom*/, LPVOID /*lpCreateParam = NULL*/)
	{
		ATLASSERT(FALSE);	// should not be called
		return NULL;
	}
	static LRESULT CALLBACK StartWindowProc(HWND /*hWnd*/, UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/)
	{
		ATLASSERT(FALSE);	// should not be called
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFontDialogImpl - font selection dialog

#ifndef UNDER_CE

template <class T>
class ATL_NO_VTABLE CFontDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSEFONT m_cf;
	TCHAR m_szStyleName[64];	// contains style name after return
	LOGFONT m_lf;			// default LOGFONT to store the info

// Constructors
	CFontDialogImpl(LPLOGFONT lplfInitial = NULL,
			DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_cf, 0, sizeof(m_cf));
		memset(&m_lf, 0, sizeof(m_lf));
		memset(&m_szStyleName, 0, sizeof(m_szStyleName));

		m_cf.lStructSize = sizeof(m_cf);
		m_cf.hwndOwner = hWndParent;
		m_cf.rgbColors = RGB(0, 0, 0);
		m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
		m_cf.Flags = dwFlags | CF_ENABLEHOOK;
		m_cf.lpfnHook = (LPCFHOOKPROC)T::HookProc;

		if(lplfInitial != NULL)
		{
/*?*/			m_cf.lpLogFont = lplfInitial;
			m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		}
		else
		{
			m_cf.lpLogFont = &m_lf;
		}

		if(hDCPrinter != NULL)
		{
			m_cf.hDC = hDCPrinter;
			m_cf.Flags |= CF_PRINTERFONTS;
		}
	}

// Operations
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cf.Flags & CF_ENABLEHOOK);
		ATLASSERT(m_cf.lpfnHook != NULL);	// can still be a user hook

		if(m_cf.hwndOwner == NULL)		// set only if not specified before
			m_cf.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		int nResult = ::ChooseFont(&m_cf);

		m_hWnd = NULL;

		if(nResult == IDOK)
		{
			// copy logical font from user's initialization buffer (if needed)
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
			return IDOK;
		}

		return nResult ? nResult : IDCANCEL;
	}

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf)
	{
		ATLASSERT(lplf != NULL);

		if(m_hWnd != NULL)
			SendMessage(WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)lplf);
		else
			*lplf = m_lf;
	}

	// Helpers for parsing information after successful return
	LPCTSTR GetFaceName() const   // return the face name of the font
	{
		return (LPCTSTR)m_cf.lpLogFont->lfFaceName;
	}
	LPCTSTR GetStyleName() const  // return the style name of the font
	{
		return m_cf.lpszStyle;
	}
	int GetSize() const           // return the pt size of the font
	{
		return m_cf.iPointSize;
	}
	COLORREF GetColor() const     // return the color of the font
	{
		return m_cf.rgbColors;
	}
	int GetWeight() const         // return the chosen font weight
	{
		return (int)m_cf.lpLogFont->lfWeight;
	}
	BOOL IsStrikeOut() const      // return TRUE if strikeout
	{
		return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE;
	}
	BOOL IsUnderline() const      // return TRUE if underline
	{
		return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE;
	}
	BOOL IsBold() const           // return TRUE if bold font
	{
		return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE;
	}
	BOOL IsItalic() const         // return TRUE if italic font
	{
		return m_cf.lpLogFont->lfItalic ? TRUE : FALSE;
	}
};

class CFontDialog : public CFontDialogImpl<CFontDialog>
{
public:
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CFontDialogImpl<CFontDialog>(lplfInitial, dwFlags, hDCPrinter, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CRichEditFontDialogImpl - font selection for the Rich Edit ctrl

#ifndef UNDER_CE
#ifdef _RICHEDIT_

template <class T>
class ATL_NO_VTABLE CRichEditFontDialogImpl : public CFontDialogImpl< T >
{
public:
	CRichEditFontDialogImpl(const CHARFORMAT& charformat,
			DWORD dwFlags = CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
			: CFontDialogImpl< T >(NULL, dwFlags, hDCPrinter, hWndParent)
	{
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		m_cf.Flags |= FillInLogFont(charformat);
		m_cf.lpLogFont = &m_lf;

		if(charformat.dwMask & CFM_COLOR)
			m_cf.rgbColors = charformat.crTextColor;
	}

	void GetCharFormat(CHARFORMAT& cf) const
	{
		USES_CONVERSION;
		cf.dwEffects = 0;
		cf.dwMask = 0;
		if((m_cf.Flags & CF_NOSTYLESEL) == 0)
		{
			cf.dwMask |= CFM_BOLD | CFM_ITALIC;
			cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
			cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
		}
		if((m_cf.Flags & CF_NOSIZESEL) == 0)
		{
			cf.dwMask |= CFM_SIZE;
			//GetSize() returns in tenths of points so mulitply by 2 to get twips
			cf.yHeight = GetSize() * 2;
		}

		if((m_cf.Flags & CF_NOFACESEL) == 0)
		{
			cf.dwMask |= CFM_FACE;
			cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(cf.szFaceName, GetFaceName());
#else
			lstrcpyA(cf.szFaceName, T2A((LPTSTR)(LPCTSTR)GetFaceName()));
#endif //(_RICHEDIT_VER >= 0x0200)
		}

		if(m_cf.Flags & CF_EFFECTS)
		{
			cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
			cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
			cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
			cf.crTextColor = GetColor();
		}
		if((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
		{
			cf.bCharSet = m_cf.lpLogFont->lfCharSet;
			cf.dwMask |= CFM_CHARSET;
		}
		cf.yOffset = 0;
	}

	DWORD FillInLogFont(const CHARFORMAT& cf)
	{
		USES_CONVERSION;
		DWORD dwFlags = 0;
		if(cf.dwMask & CFM_SIZE)
		{
			HDC hDC = ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
			LONG yPerInch = ::GetDeviceCaps(hDC, LOGPIXELSY);
			m_lf.lfHeight = -(int)((cf.yHeight * yPerInch) / 1440);
		}
		else
			m_lf.lfHeight = 0;

		m_lf.lfWidth = 0;
		m_lf.lfEscapement = 0;
		m_lf.lfOrientation = 0;

		if((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
		{
			m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
			m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
		}
		else
		{
			dwFlags |= CF_NOSTYLESEL;
			m_lf.lfWeight = FW_DONTCARE;
			m_lf.lfItalic = FALSE;
		}

		if((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
			(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
		{
			dwFlags |= CF_EFFECTS;
			m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
			m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
		}
		else
		{
			m_lf.lfUnderline = (BYTE)FALSE;
			m_lf.lfStrikeOut = (BYTE)FALSE;
		}

		if(cf.dwMask & CFM_CHARSET)
			m_lf.lfCharSet = cf.bCharSet;
		else
			dwFlags |= CF_NOSCRIPTSEL;
		m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		m_lf.lfQuality = DEFAULT_QUALITY;
		if(cf.dwMask & CFM_FACE)
		{
			m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(m_lf.lfFaceName, cf.szFaceName);
#else
			lstrcpy(m_lf.lfFaceName, A2T((LPSTR)cf.szFaceName));
#endif //(_RICHEDIT_VER >= 0x0200)
		}
		else
		{
			m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
			m_lf.lfFaceName[0] = (TCHAR)0;
		}
		return dwFlags;
	}
};

class CRichEditFontDialog : public CRichEditFontDialogImpl<CRichEditFontDialog>
{
public:
	CRichEditFontDialog(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CRichEditFontDialogImpl<CRichEditFontDialog>(charformat, dwFlags, hDCPrinter, hWndParent)
	{ }
};

#endif // _RICHEDIT_
#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CColorDialogImpl - color selection

//REVIEW - temp
#ifndef UNDER_CE

static const UINT _nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
const UINT _nMsgSETRGB = ::RegisterWindowMessage(SETRGBSTRING);

template <class T>
class ATL_NO_VTABLE CColorDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialogImpl(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
	{
		memset(&m_cc, 0, sizeof(m_cc));

		m_cc.lStructSize = sizeof(m_cc);
		m_cc.lpCustColors = GetCustomColors();
		m_cc.hwndOwner = hWndParent;
		m_cc.Flags = dwFlags | CC_ENABLEHOOK;
		m_cc.lpfnHook = (LPCCHOOKPROC)T::HookProc;

		if(clrInit != 0)
		{
			m_cc.rgbResult = clrInit;
			m_cc.Flags |= CC_RGBINIT;
		}
	}

// Operations
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cc.Flags & CC_ENABLEHOOK);
		ATLASSERT(m_cc.lpfnHook != NULL);	// can still be a user hook

		if(m_cc.hwndOwner == NULL)		// set only if not specified before
			m_cc.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		int nResult = ::ChooseColor(&m_cc);

		m_hWnd = NULL;

		return nResult ? nResult : IDCANCEL;
	}

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(_nMsgSETRGB, 0, (DWORD)clr);
	}

	// Helpers for parsing information after successful return
	COLORREF GetColor() const
	{
		return m_cc.rgbResult;
	}

	static COLORREF* GetCustomColors()
	{
		static COLORREF rgbCustomColors[16] =
		{
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
			RGB(255, 255, 255), RGB(255, 255, 255),
		};

		return rgbCustomColors;
	}

// Overridable callbacks
	BEGIN_MSG_MAP(CColorDialogImpl< T >)
		MESSAGE_HANDLER(_nMsgCOLOROK, _OnColorOK)
	END_MSG_MAP()

	LRESULT _OnColorOK(UINT, WPARAM, LPARAM, BOOL&)
	{
		T* pT = static_cast<T*>(this);
		return pT->OnColorOK();
	}

	BOOL OnColorOK()        // validate color
	{
		return FALSE;
	}
};

class CColorDialog : public CColorDialogImpl<CColorDialog>
{
public:
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
		: CColorDialogImpl<CColorDialog>(clrInit, dwFlags, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CPrintDialogImpl - used for Print... and PrintSetup...

//REVIEW - temp
#ifndef UNDER_CE

// global helper
static HDC _AtlCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode)
{
	if(hDevNames == NULL)
		return NULL;

	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
	LPDEVMODE  lpDevMode = (hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(hDevMode) : NULL;

	if(lpDevNames == NULL)
		return NULL;

	HDC hDC = ::CreateDC((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
					  lpDevMode);

	::GlobalUnlock(hDevNames);
	if(hDevMode != NULL)
		::GlobalUnlock(hDevMode);
	return hDC;
}

template <class T>
class ATL_NO_VTABLE CPrintDialogImpl : public CCommonDialogImplBase
{
public:
	// print dialog parameter block (note this is a reference)
	PRINTDLG& m_pd;

// Constructors
	CPrintDialogImpl(BOOL bPrintSetupOnly,	// TRUE for Print Setup, FALSE for Print Dialog
			DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_HIDEPRINTTOFILE | PD_NOSELECTION,
			HWND hWndParent = NULL)
			: m_pd(m_pdActual)
	{
		memset(&m_pdActual, 0, sizeof(m_pdActual));

		m_pd.lStructSize = sizeof(m_pdActual);
		m_pd.hwndOwner = hWndParent;
		m_pd.Flags = (dwFlags | PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK);
		m_pd.lpfnPrintHook = (LPPRINTHOOKPROC)T::HookProc;
		m_pd.lpfnSetupHook = (LPSETUPHOOKPROC)T::HookProc;

		if(bPrintSetupOnly)
			m_pd.Flags |= PD_PRINTSETUP;
		else
			m_pd.Flags |= PD_RETURNDC;

		m_pd.Flags &= ~PD_RETURNIC; // do not support information context
	}

// Operations
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_pd.Flags & PD_ENABLEPRINTHOOK);
		ATLASSERT(m_pd.Flags & PD_ENABLESETUPHOOK);
		ATLASSERT(m_pd.lpfnPrintHook != NULL);	// can still be a user hook
		ATLASSERT(m_pd.lpfnSetupHook != NULL);	// can still be a user hook

		if(m_pd.hwndOwner == NULL)		// set only if not specified before
			m_pd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		int nResult = ::PrintDlg(&m_pd);

		m_hWnd = NULL;

		return nResult ? nResult : IDCANCEL;
	}

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults()
	{
		m_pd.Flags |= PD_RETURNDEFAULT;
		return ::PrintDlg(&m_pd);
	}

	// Helpers for parsing information after successful return
	int GetCopies() const           // num. copies requested
	{
		if(m_pd.Flags & PD_USEDEVMODECOPIES)
			return GetDevMode()->dmCopies;
		else
			return m_pd.nCopies;
	}
	BOOL PrintCollate() const       // TRUE if collate checked
	{
		return m_pd.Flags & PD_COLLATE ? TRUE : FALSE;
	}
	BOOL PrintSelection() const     // TRUE if printing selection
	{
		return m_pd.Flags & PD_SELECTION ? TRUE : FALSE;
	}
	BOOL PrintAll() const           // TRUE if printing all pages
	{
		return !PrintRange() && !PrintSelection() ? TRUE : FALSE;
	}
	BOOL PrintRange() const         // TRUE if printing page range
	{
		return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE;
	}
	int GetFromPage() const         // starting page if valid
	{
		return (PrintRange() ? m_pd.nFromPage :-1);
	}
	int GetToPage() const           // starting page if valid
	{
		return (PrintRange() ? m_pd.nToPage :-1);
	}
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_pd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_pd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_pd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC GetPrinterDC() const        // return HDC (caller must delete)
	{
		ATLASSERT(m_pd.Flags & PD_RETURNDC);
		return m_pd.hDC;
	}

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.
	HDC CreatePrinterDC()
	{
		m_pd.hDC = _AtlCreateDC(m_pd.hDevNames, m_pd.hDevMode);
		return m_pd.hDC;
	}

// Implementation
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this

	// The following handle the case of print setup... from the print dialog
	CPrintDialogImpl(PRINTDLG& pdInit) : m_pd(pdInit)
	{ }

	BEGIN_MSG_MAP(CPrintDialogImpl< T >)
		COMMAND_ID_HANDLER(psh1, OnPrintSetup) // print setup button when print is displayed
	END_MSG_MAP()

	LRESULT OnPrintSetup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
	{
		CPrintDialogImpl< T >* pDlgSetup = NULL;
		ATLTRY(pDlgSetup = new CPrintDialogImpl< T >(m_pd));
		ATLASSERT(pDlgSetup != NULL);

		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)pDlgSetup);
		LRESULT lRet = DefWindowProc(WM_COMMAND, MAKEWPARAM(wID, wNotifyCode), (LPARAM)hWndCtl);

		delete pDlgSetup;
		return lRet;
	}
};

class CPrintDialog : public CPrintDialogImpl<CPrintDialog>
{
public:
	CPrintDialog(BOOL bPrintSetupOnly,
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_HIDEPRINTTOFILE | PD_NOSELECTION,
		HWND hWndParent = NULL)
		: CPrintDialogImpl<CPrintDialog>(bPrintSetupOnly, dwFlags, hWndParent)
	{ }
	CPrintDialog(PRINTDLG& pdInit) : CPrintDialogImpl<CPrintDialog>(pdInit)
	{ }
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDialogImpl - Page Setup dialog

#ifndef UNDER_CE

template <class T>
class ATL_NO_VTABLE CPageSetupDialogImpl : public CCommonDialogImplBase
{
public:
	PAGESETUPDLG m_psd;
	CWndProcThunk m_thunkPaint;


// Constructors
	CPageSetupDialogImpl(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
	{
		memset(&m_psd, 0, sizeof(m_psd));

		m_psd.lStructSize = sizeof(m_psd);
		m_psd.hwndOwner = hWndParent;
		m_psd.Flags = (dwFlags | PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK);
		m_psd.lpfnPageSetupHook = (LPPAGESETUPHOOK)T::HookProc;
		m_thunkPaint.Init((WNDPROC)T::PaintHookProc, this);
		m_psd.lpfnPagePaintHook = (LPPAGEPAINTHOOK)(m_thunkPaint.thunk.pThunk);
	}

	DECLARE_EMPTY_MSG_MAP()

// Attributes
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_psd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_psd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC CreatePrinterDC()
	{
		return _AtlCreateDC(m_psd.hDevNames, m_psd.hDevMode);
	}
	SIZE GetPaperSize() const
	{
		SIZE size;
		size.cx = m_psd.ptPaperSize.x;
		size.cy = m_psd.ptPaperSize.y;
		return size;
	}
	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const
	{
		if(lpRectMargins != NULL)
			memcpy(lpRectMargins, &m_psd.rtMargin, sizeof(RECT));
		if(lpRectMinMargins != NULL)
			memcpy(lpRectMinMargins, &m_psd.rtMinMargin, sizeof(RECT));
	}

// Operations
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGESETUPHOOK);
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGEPAINTHOOK);
		ATLASSERT(m_psd.lpfnPageSetupHook != NULL);	// can still be a user hook
		ATLASSERT(m_psd.lpfnPagePaintHook != NULL);	// can still be a user hook

		if(m_psd.hwndOwner == NULL)		// set only if not specified before
			m_psd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		int nResult = ::PageSetupDlg(&m_psd);

		m_hWnd = NULL;

		return nResult ? nResult : IDCANCEL;
	}

// Implementation
	static UINT CALLBACK PaintHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CPageSetupDialogImpl< T >* pDlg = (CPageSetupDialogImpl< T >*)hWnd;
		ATLASSERT(pDlg->m_hWnd == ::GetParent(hWnd));
		UINT uRet = 0;
		switch(uMsg)
		{
		case WM_PSD_PAGESETUPDLG:
			uRet = pDlg->PreDrawPage(LOWORD(wParam), HIWORD(wParam), (LPPAGESETUPDLG)lParam);
			break;
		case WM_PSD_FULLPAGERECT:
		case WM_PSD_MINMARGINRECT:
		case WM_PSD_MARGINRECT:
		case WM_PSD_GREEKTEXTRECT:
		case WM_PSD_ENVSTAMPRECT:
		case WM_PSD_YAFULLPAGERECT:
			uRet = pDlg->OnDrawPage(uMsg, (HDC)wParam, (LPRECT)lParam);
			break;
		default:
			ATLTRACE2(atlTraceWindowing, 0, _T("CPageSetupDialogImpl::PaintHookProc - unknown message received\n"));
			break;
		}
		return uRet;
	}

// Overridables
	UINT PreDrawPage(WORD /*wPaper*/, WORD /*wFlags*/, LPPAGESETUPDLG /*pPSD*/)
	{
		// return 1 to prevent any more drawing
		return 0;
	}
	UINT OnDrawPage(UINT /*uMsg*/, HDC /*hDC*/, LPRECT /*lpRect*/)
	{
		return 0; // do the default
	}
};

class CPageSetupDialog : public CPageSetupDialogImpl<CPageSetupDialog>
{
public:
	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
		: CPageSetupDialogImpl<CPageSetupDialog>(dwFlags, hWndParent)
	{ }

	// override PaintHookProc and references to handlers
	static UINT CALLBACK PaintHookProc(HWND, UINT, WPARAM, LPARAM)
	{
		return 0;
	}
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CFindReplaceDialogImpl - Find/FindReplace modeless dialogs

#ifndef UNDER_CE

template <class T>
class ATL_NO_VTABLE CFindReplaceDialogImpl : public CCommonDialogImplBase
{
public:
	FINDREPLACE m_fr;
	TCHAR m_szFindWhat[128];
	TCHAR m_szReplaceWith[128];

// Constructors
	CFindReplaceDialogImpl()
	{
		memset(&m_fr, 0, sizeof(m_fr));
		m_szFindWhat[0] = '\0';
		m_szReplaceWith[0] = '\0';

		m_fr.lStructSize = sizeof(m_fr);
		m_fr.Flags = FR_ENABLEHOOK;
		m_fr.lpfnHook = (LPFRHOOKPROC)T::HookProc;
		m_fr.lpstrFindWhat = (LPTSTR)m_szFindWhat;
	}

	// Note: You must allocate the object on the heap.
	//       If you do not, you must override OnFinalMessage()
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		delete this;
	}

	HWND Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCTSTR lpszFindWhat,
			LPCTSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			HWND hWndParent = NULL)
	{
		ATLASSERT(m_fr.Flags & FR_ENABLEHOOK);
		ATLASSERT(m_fr.lpfnHook != NULL);

		m_fr.wFindWhatLen = sizeof(m_szFindWhat)/sizeof(TCHAR);
		m_fr.lpstrReplaceWith = (LPTSTR)m_szReplaceWith;
		m_fr.wReplaceWithLen = sizeof(m_szReplaceWith)/sizeof(TCHAR);
		m_fr.Flags |= dwFlags;

		if(hWndParent == NULL)
			m_fr.hwndOwner = ::GetActiveWindow();
		else
			m_fr.hwndOwner = hWndParent;
		ATLASSERT(m_fr.hwndOwner != NULL); // must have an owner for modeless dialog

		if(lpszFindWhat != NULL)
			lstrcpyn(m_szFindWhat, lpszFindWhat, sizeof(m_szFindWhat)/sizeof(TCHAR));

		if(lpszReplaceWith != NULL)
			lstrcpyn(m_szReplaceWith, lpszReplaceWith, sizeof(m_szReplaceWith)/sizeof(TCHAR));

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
		HWND hWnd;

		if(bFindDialogOnly)
			hWnd = ::FindText(&m_fr);
		else
			hWnd = ::ReplaceText(&m_fr);

		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}

	BOOL EndDialog(int /*nRetCode*/)
	{
		ATLASSERT(FALSE);
		// should not be called
		return FALSE;
	}

	static const UINT GetFindReplaceMsg()
	{
		static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);
		return nMsgFindReplace;
	}
	// call while handling FINDMSGSTRING registered message
	// to retreive the object
	static T* PASCAL GetNotifier(LPARAM lParam)
	{
		ATLASSERT(lParam != NULL);
		T* pDlg = (T*)(lParam - offsetof(T, m_fr));
		return pDlg;
	}

// Operations
	// Helpers for parsing information after successful return
	LPCTSTR GetFindString() const    // get find string
	{
		return (LPCTSTR)m_fr.lpstrFindWhat;
	}
	LPCTSTR GetReplaceString() const // get replacement string
	{
		return (LPCTSTR)m_fr.lpstrReplaceWith;
	}
	BOOL SearchDown() const          // TRUE if search down, FALSE is up
	{
		return m_fr.Flags & FR_DOWN ? TRUE : FALSE;
	}
	BOOL FindNext() const            // TRUE if command is find next
	{
		return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE;
	}
	BOOL MatchCase() const           // TRUE if matching case
	{
		return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE;
	}
	BOOL MatchWholeWord() const      // TRUE if matching whole words only
	{
		return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE;
	}
	BOOL ReplaceCurrent() const      // TRUE if replacing current string
	{
		return m_fr. Flags & FR_REPLACE ? TRUE : FALSE;
	}
	BOOL ReplaceAll() const          // TRUE if replacing all occurrences
	{
		return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE;
	}
	BOOL IsTerminating() const       // TRUE if terminating dialog
	{
		return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ;
	}
};

class CFindReplaceDialog : public CFindReplaceDialogImpl<CFindReplaceDialog>
{
public:
	DECLARE_EMPTY_MSG_MAP()
};

#endif //!UNDER_CE

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetWindow - client side for a property sheet

class CPropertySheetWindow : public CWindow
{
public:
// Constructors
	CPropertySheetWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertySheetWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	UINT GetPageCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
	}
	HWND GetActivePage() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
	}
	UINT GetActiveIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
	}
	BOOL SetActivePage(UINT uPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, uPageIndex, 0L);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, 0, (LPARAM)hPage);
	}
	BOOL SetActivePageByID(int nPageID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSELID, 0, nPageID);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText == NULL);
		::SendMessage(m_hWnd, PSM_SETTITLE, nStyle, (LPARAM)lpszText);
	}
	HWND GetTabControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
	}
	void SetFinishText(LPCTSTR lpszText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
	}

// Operations
	void AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(pPage != NULL);
		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
		return TRUE;
	}
	void RemovePage(UINT uPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, uPageIndex, 0L);
	}
	void RemovePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, 0, (LPARAM)hPage);
	}
	BOOL PressButton(int nButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
	}
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_APPLY, 0, 0L);
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(HWND hWndPage, BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsWindow(hWndPage));
		UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
		::SendMessage(m_hWnd, uMsg, (WPARAM)hWndPage, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd, PSM_QUERYSIBLINGS, wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REBOOTSYSTEM, 0, 0L);
	}
	void RestartWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_RESTARTWINDOWS, 0, 0L);
	}
	BOOL IsDialogMessage(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_ISDIALOGMESSAGE, 0, (LPARAM)lpMsg);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetImpl - implements a property sheet

template <class T, class TBase /*= CPropertySheetWindow */>
class ATL_NO_VTABLE CPropertySheetImpl : public CWindowImplBaseT< TBase >
{
public:
	PROPSHEETHEADER m_psh;

// Construction/Destruction
	CPropertySheetImpl(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
	{
		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
		m_psh.dwSize = sizeof(PROPSHEETHEADER);
		m_psh.dwFlags = PSH_USECALLBACK;
		m_psh.hInstance = _Module.GetResourceInstance();
		m_psh.phpage = NULL;
		m_psh.nPages = 0;
		m_psh.pszCaption = lpszTitle;
		m_psh.nStartPage = uStartPage;
		m_psh.hwndParent = hWndParent;	// if NULL, will be set in DoModal/Create
		m_psh.pfnCallback = T::PropSheetCallback;
	}

	~CPropertySheetImpl()
	{
		if(m_psh.phpage != NULL)
			delete[] m_psh.phpage;
	}

	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM)
	{
		if(uMsg == PSCB_INITIALIZED)
		{
			ATLASSERT(hWnd != NULL);
			CWindowImplBaseT< TBase >* pT = (CWindowImplBaseT< TBase >*)_Module.ExtractCreateWndData();
			pT->SubclassWindow(hWnd);
		}

		return 0;
	}

	HWND Create(HWND hWndParent = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags |= PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBaseT< TBase >*)this);

		HWND hWnd = (HWND)::PropertySheet(&m_psh);

		ATLASSERT(m_hWnd == hWnd);

		return hWnd;
	}

	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags &= ~PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBaseT< TBase >*)this);

		return ::PropertySheet(&m_psh);
	}

// Attributes (extended overrides of client class methods)
	UINT GetPageCount() const
	{
		if(m_hWnd == NULL)
			return m_psh.nPages;
		return TBase::GetPageCount();
	}
	UINT GetActiveIndex() const
	{
		if(m_hWnd == NULL)
			return m_psh.nStartPage;
		return TBase::GetActiveIndex();
	}
	HPROPSHEETPAGE GetPage(UINT uPageIndex)
	{
		ATLASSERT(uPageIndex < m_psh.nPages);

		return m_psh.phpage[uPageIndex];
	}
	UINT GetPageIndex(HPROPSHEETPAGE hPage)
	{
		for(UINT i = 0; i < m_psh.nPages; i++)
		{
			if(m_psh.phpage[i] == hPage)
				return i;
		}
		return (UINT)-1;  // hPage not found
	}
	BOOL SetActivePage(UINT uPageIndex)
	{
		if(m_hWnd == NULL)
		{
			m_psh.nStartPage = uPageIndex;
			return TRUE;
		}
		return TBase::SetActivePage(uPageIndex);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);

		UINT uPageIndex = GetPageIndex(hPage);
		if(uPageIndex == (UINT)-1)
			return FALSE;

		return SetActivePage(uPageIndex);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText == NULL);

		if(m_hWnd == NULL)
		{
			// set internal state
			m_psh.pszCaption = lpszText;
			m_psh.dwFlags &= ~PSH_PROPTITLE;
			m_psh.dwFlags |= nStyle;
		}
		else
		{
			// set external state
			TBase::SetTitle(lpszText, nStyle);
		}
	}
#ifndef UNDER_CE
	void SetWizardMode()
	{
		m_psh.dwFlags |= PSH_WIZARD;
	}
#endif //!UNDER_CE

// Operations
	BOOL AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);

		// add page to internal list
		HPROPSHEETPAGE* php = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages + 1) * sizeof(HPROPSHEETPAGE));
		if(php == NULL)
			return FALSE;

		m_psh.phpage = php;
		m_psh.phpage[m_psh.nPages] = hPage;
		m_psh.nPages++;

		if(m_hWnd != NULL)
			TBase::AddPage(hPage);

		return TRUE;
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(pPage != NULL);

		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;

		AddPage(hPage);
		return TRUE;
	}
	BOOL RemovePage(HPROPSHEETPAGE hPage, BOOL bDestroyPage = TRUE)
	{
		ATLASSERT(hPage != NULL);

		int nPage = GetPageIndex(hPage);
		if(nPage == -1)
			return FALSE;

		return RemovePage(nPage, bDestroyPage);
	}
	BOOL RemovePage(UINT uPageIndex, BOOL bDestroyPage = TRUE)
	{
		// remove the page externally
		if(m_hWnd != NULL)
			TBase::RemovePage(uPageIndex);

		// remove the page from internal list
		if(uPageIndex >= m_psh.nPages)
			return FALSE;

		if(bDestroyPage && !DestroyPropertySheetPage(m_psh.phpage[uPageIndex]))
			return FALSE;

		for(UINT i = uPageIndex; i < m_psh.nPages - 1; i++)
			m_psh.phpage[i] = m_psh.phpage[i+1];

        if (m_psh.nPages == 1) {
            free(m_psh.phpage);
            m_psh.phpage = NULL;
            m_psh.nPages = 0;
        } else {
            HPROPSHEETPAGE* php = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages - 1) * sizeof(HPROPSHEETPAGE));
            if (php == NULL)
                return FALSE;
    
            m_psh.phpage = php;
            m_psh.nPages--;
        }

		return TRUE;
	}
};

// for non-customized sheets
class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
{
public:
	CPropertySheet(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
		: CPropertySheetImpl<CPropertySheet>(lpszTitle, uStartPage, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageWindow - client side for a property page

class CPropertyPageWindow : public CWindow
{
public:
// Constructors
	CPropertyPageWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertyPageWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return (BOOL)::SendMessage(GetParent(), PSM_APPLY, 0, 0L);
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
		::SendMessage(GetParent(), uMsg, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		::SendMessage(GetParent(), PSM_REBOOTSYSTEM, 0, 0L);
	}
	void RestartWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		::SendMessage(GetParent(), PSM_RESTARTWINDOWS, 0, 0L);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageImpl - implements a property page

template <class T, class TBase /*= CPropertyPageWindow */>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBaseT< TBase >
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
			SetTitle(lpszTitle);
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			ATLASSERT(hWnd == NULL);
			CDialogImplBaseT< TBase >* pPage = (CDialogImplBaseT< TBase >*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

// Attributes
	void SetTitle(LPCTSTR lpszTitle)
	{
		m_psp.pszTitle = lpszTitle;
		m_psp.dwFlags |= PSP_USETITLE;
	}
	void SetTitle(UINT nTitleID)
	{
		SetTitle(MAKEINTRESOURCE(nTitleID));
	}

// Message map and handlers
	typedef CPropertyPageImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LRESULT lResult = 0;
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			pT->OnHelp();
			break;
#if (_WIN32_IE >= 0x0400)
		case PSN_GETOBJECT:
			if(!pT->OnGetObject((LPNMOBJECTNOTIFY)lParam))
				bHandled = FALSE;
			break;
#endif //(_WIN32_IE >= 0x0400)
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	int OnWizardBack()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	int OnWizardNext()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	void OnHelp()
	{
	}
#if (_WIN32_IE >= 0x0400)
	BOOL OnGetObject(LPNMOBJECTNOTIFY /*lpObjectNotify*/)
	{
		return FALSE;	// not processed
	}
#endif //(_WIN32_IE >= 0x0400)
};

// for non-customized pages
template <WORD t_wDlgTemplateID>
class CPropertyPage : public CPropertyPageImpl<CPropertyPage<t_wDlgTemplateID> >
{
public:
	enum { IDD = t_wDlgTemplateID };

	CPropertyPage(LPCTSTR lpszTitle = NULL) : CPropertyPageImpl<CPropertyPage>(lpszTitle)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

}; //namespace ATL

#endif // __ATLDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\atl21\atliface.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Nov 21 14:48:45 1996
 */
/* Compiler settings for atliface.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Nov 21 14:48:45 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRegistrar
 * at Thu Nov 21 14:48:45 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRegistrar : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddReplacement( 
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileRegister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileUnregister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringRegister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringUnregister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC